
==================== Output Cmm ====================
2018-03-16 16:00:06.200362472 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:00:06.201231162 UTC

[section ""data" . Data.Type.Coercion.testCoercion_closure" {
     Data.Type.Coercion.testCoercion_closure:
         const Data.Type.Coercion.testCoercion_info;
 },
 Data.Type.Coercion.testCoercion_entry() //  [R2]
         { info_tbl: [(c59EX,
                       label: Data.Type.Coercion.testCoercion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59EX: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.202016213 UTC

[section ""cstring" . lvl_r59Bb_bytes" {
     lvl_r59Bb_bytes:
         I8[] [68,97,116,97,46,84,121,112,101,46,67,111,101,114,99,105,111,110,46,116,111,69,110,117,109,58,32,98,97,100,32,97,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.202871262 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion1_closure" {
     Data.Type.Coercion.$fEnumCoercion1_closure:
         const Data.Type.Coercion.$fEnumCoercion1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Coercion.$fEnumCoercion1_entry() //  [R1]
         { info_tbl: [(c59F8,
                       label: Data.Type.Coercion.$fEnumCoercion1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59F8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c59F9; else goto c59Fa;
       c59F9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59Fa: // global
           (_c59F3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c59F3::I64 == 0) goto c59F5; else goto c59F4;
       c59F5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c59F4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c59F3::I64;
           I64[Sp - 24] = block_c59F6_info;
           R2 = lvl_r59Bb_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c59F6() //  [R1]
         { info_tbl: [(c59F6,
                       label: block_c59F6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59F6: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.204430814 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_$ctoEnum_closure" {
     Data.Type.Coercion.$fEnumCoercion_$ctoEnum_closure:
         const Data.Type.Coercion.$fEnumCoercion_$ctoEnum_info;
         const 0;
 },
 Data.Type.Coercion.$fEnumCoercion_$ctoEnum_entry() //  [R2, R3]
         { info_tbl: [(c59Fm,
                       label: Data.Type.Coercion.$fEnumCoercion_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Fm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59Fn; else goto c59Fo;
       c59Fn: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_$ctoEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59Fo: // global
           I64[Sp - 16] = block_c59Fj_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u59FB; else goto c59Fk;
       u59FB: // global
           call _c59Fj(R1) args: 0, res: 0, upd: 0;
       c59Fk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Fj() //  [R1]
         { info_tbl: [(c59Fj,
                       label: block_c59Fj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Fj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c59Ft; else goto c59Fs;
       c59Ft: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c59Fs: // global
           if (I64[R1 + 7] == 0) goto c59FA; else goto c59Fw;
       c59FA: // global
           I64[Hp - 8] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c59Fw: // global
           Hp = Hp - 16;
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.206775951 UTC

[section ""data" . Data.Type.Coercion.$w$cenumFromTo_closure" {
     Data.Type.Coercion.$w$cenumFromTo_closure:
         const Data.Type.Coercion.$w$cenumFromTo_info;
         const 0;
 },
 sat_s59BI_entry() //  [R1]
         { info_tbl: [(c59FU,
                       label: sat_s59BI_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59FU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59FV; else goto c59FW;
       c59FV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59FW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s59BG::I64 = I64[R1 + 24];
           if (_s59BG::I64 != 0) goto c59FS; else goto c59FT;
       c59FS: // global
           R2 = _s59BG::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s59BC_entry(R2, R1) args: 24, res: 0, upd: 24;
       c59FT: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s59BF_entry() //  [R1]
         { info_tbl: [(c59G7,
                       label: sat_s59BF_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59G7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59G8; else goto c59G9;
       c59G8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59G9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 24] == 0) goto c59G6; else goto c59G5;
       c59G6: // global
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c59G5: // global
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s59BC_entry() //  [R1, R2]
         { info_tbl: [(c59Gb,
                       label: go_s59BC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Gb: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c59Gf; else goto c59Ge;
       c59Gf: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c59Ge: // global
           _s59BB::P64 = P64[R1 + 7];
           I64[Hp - 80] = sat_s59BI_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s59BF_info;
           P64[Hp - 32] = _s59BB::P64;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$w$cenumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c59Gg,
                       label: Data.Type.Coercion.$w$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Gg: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c59Gk; else goto c59Gj;
       c59Gk: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$w$cenumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c59Gj: // global
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = go_s59BC_info;
           P64[Hp] = Hp - 23;
           R2 = 0;
           R1 = Hp - 7;
           call go_s59BC_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.209167967 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_closure" {
     Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_closure:
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_info;
         const 0;
 },
 Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(c59Gs,
                       label: Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Gs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c59Gw; else goto c59Gx;
       c59Gw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c59Gx: // global
           I64[Sp - 24] = block_c59Gp_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u59GF; else goto c59Gq;
       u59GF: // global
           call _c59Gp(R1) args: 0, res: 0, upd: 0;
       c59Gq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Gp() //  [R1]
         { info_tbl: [(c59Gp,
                       label: block_c59Gp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Gp: // global
           I64[Sp] = block_c59Gv_info;
           _s59BM::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s59BM::P64;
           if (R1 & 7 != 0) goto u59GE; else goto c59Gz;
       u59GE: // global
           call _c59Gv(R1) args: 0, res: 0, upd: 0;
       c59Gz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Gv() //  [R1]
         { info_tbl: [(c59Gv,
                       label: block_c59Gv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Gv: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Coercion.$w$cenumFromTo_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.210767016 UTC

[section ""data" . lvl1_r59Bc_closure" {
     lvl1_r59Bc_closure:
         const lvl1_r59Bc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r59Bc_entry() //  [R1]
         { info_tbl: [(c59GM,
                       label: lvl1_r59Bc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59GM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59GN; else goto c59GO;
       c59GN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59GO: // global
           (_c59GJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c59GJ::I64 == 0) goto c59GL; else goto c59GK;
       c59GL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c59GK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c59GJ::I64;
           R3 = 0;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.Enum.efdInt_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.21220986 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_closure" {
     Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_closure:
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_info;
         const 0;
 },
 sat_s59BX_entry() //  [R1, R2]
         { info_tbl: [(c59H8,
                       label: sat_s59BX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59H8: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Coercion.$fEnumCoercion_$ctoEnum_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(c59Hb,
                       label: Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Hb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c59Hc; else goto c59Hd;
       c59Hc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c59Hd: // global
           I64[Sp - 24] = block_c59GT_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u59Hj; else goto c59GU;
       u59Hj: // global
           call _c59GT() args: 0, res: 0, upd: 0;
       c59GU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59GT() //  []
         { info_tbl: [(c59GT,
                       label: block_c59GT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59GT: // global
           I64[Sp] = block_c59GY_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u59Hi; else goto c59GZ;
       u59Hi: // global
           call _c59GY(R1) args: 0, res: 0, upd: 0;
       c59GZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59GY() //  [R1]
         { info_tbl: [(c59GY,
                       label: block_c59GY_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59GY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c59Hh; else goto c59Hg;
       c59Hh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c59Hg: // global
           I64[Hp - 8] = sat_s59BX_info;
           P64[Hp] = P64[Sp + 8];
           R3 = lvl1_r59Bc_closure;
           R2 = Hp - 7;
           Sp = Sp + 24;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.214959598 UTC

[section ""data" . Data.Type.Coercion.$w$cenumFrom_closure" {
     Data.Type.Coercion.$w$cenumFrom_closure:
         const Data.Type.Coercion.$w$cenumFrom_info;
         const 0;
 },
 sat_s59C7_entry() //  [R1]
         { info_tbl: [(c59HC,
                       label: sat_s59C7_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59HC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59HD; else goto c59HE;
       c59HD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59HE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s59C5::I64 = I64[R1 + 24];
           if (_s59C5::I64 != 9223372036854775807) goto c59HA; else goto c59HB;
       c59HA: // global
           R2 = _s59C5::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s59C1_entry(R2, R1) args: 24, res: 0, upd: 24;
       c59HB: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s59C4_entry() //  [R1]
         { info_tbl: [(c59HP,
                       label: sat_s59C4_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59HP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59HQ; else goto c59HR;
       c59HQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59HR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 24] == 0) goto c59HO; else goto c59HN;
       c59HO: // global
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c59HN: // global
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s59C1_entry() //  [R1, R2]
         { info_tbl: [(c59HT,
                       label: go_s59C1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59HT: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c59HX; else goto c59HW;
       c59HX: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c59HW: // global
           _s59C0::P64 = P64[R1 + 7];
           I64[Hp - 80] = sat_s59C7_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s59C4_info;
           P64[Hp - 32] = _s59C0::P64;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$w$cenumFrom_entry() //  [R2, R3]
         { info_tbl: [(c59HY,
                       label: Data.Type.Coercion.$w$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59HY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c59I2; else goto c59I1;
       c59I2: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$w$cenumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59I1: // global
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = go_s59C1_info;
           P64[Hp] = Hp - 23;
           R2 = 0;
           R1 = Hp - 7;
           call go_s59C1_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.217990557 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_$cenumFrom_closure" {
     Data.Type.Coercion.$fEnumCoercion_$cenumFrom_closure:
         const Data.Type.Coercion.$fEnumCoercion_$cenumFrom_info;
         const 0;
 },
 Data.Type.Coercion.$fEnumCoercion_$cenumFrom_entry() //  [R2, R3]
         { info_tbl: [(c59Ia,
                       label: Data.Type.Coercion.$fEnumCoercion_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Ia: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59Ib; else goto c59Ic;
       c59Ib: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_$cenumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59Ic: // global
           I64[Sp - 16] = block_c59I7_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u59Ig; else goto c59I8;
       u59Ig: // global
           call _c59I7(R1) args: 0, res: 0, upd: 0;
       c59I8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59I7() //  [R1]
         { info_tbl: [(c59I7,
                       label: block_c59I7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59I7: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Type.Coercion.$w$cenumFrom_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.220237279 UTC

[section ""data" . Data.Type.Coercion.$w$cenumFromThenTo_closure" {
     Data.Type.Coercion.$w$cenumFromThenTo_closure:
         const Data.Type.Coercion.$w$cenumFromThenTo_info;
         const 0;
 },
 sat_s59Cm_entry() //  [R1]
         { info_tbl: [(c59IC,
                       label: sat_s59Cm_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59IC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59ID; else goto c59IE;
       c59ID: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59IE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s59Ch_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s59Cl_entry() //  [R1]
         { info_tbl: [(c59IN,
                       label: sat_s59Cl_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59IN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59IO; else goto c59IP;
       c59IO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59IP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 24] == 0) goto c59IM; else goto c59IL;
       c59IM: // global
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c59IL: // global
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s59Co_entry() //  [R1]
         { info_tbl: [(c59IZ,
                       label: sat_s59Co_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59IZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59J0; else goto c59J1;
       c59J0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59J1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 24] == 0) goto c59IY; else goto c59IX;
       c59IY: // global
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c59IX: // global
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s59Ch_entry() //  [R1, R2]
         { info_tbl: [(c59J5,
                       label: go_up_s59Ch_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59J5: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c59J9; else goto c59J8;
       c59J9: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c59J8: // global
           _s59Cg::P64 = P64[R1 + 7];
           if (%MO_S_Le_W64(R2, 0)) goto c59J3; else goto c59J4;
       c59J3: // global
           I64[Hp - 80] = sat_s59Cm_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s59Cl_info;
           P64[Hp - 32] = _s59Cg::P64;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c59J4: // global
           I64[Hp - 80] = sat_s59Co_info;
           P64[Hp - 64] = _s59Cg::P64;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c59Jb::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c59Jb::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59Cp_entry() //  [R1]
         { info_tbl: [(c59Jc,
                       label: sat_s59Cp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Jc: // global
           _s59Cp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c59Jd; else goto c59Je;
       c59Je: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c59Jg; else goto c59Jf;
       c59Jg: // global
           HpAlloc = 16;
           goto c59Jd;
       c59Jd: // global
           R1 = _s59Cp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59Jf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s59Cp::P64;
           _s59Cg::P64 = P64[_s59Cp::P64 + 16];
           I64[Hp - 8] = go_up_s59Ch_info;
           P64[Hp] = _s59Cg::P64;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call go_up_s59Ch_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Coercion.$w$cenumFromThenTo_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c59Jh,
                       label: Data.Type.Coercion.$w$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Jh: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c59Jl; else goto c59Jk;
       c59Jl: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$w$cenumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c59Jk: // global
           I64[Hp - 32] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s59Cp_info;
           _c59Il::P64 = Hp - 31;
           P64[Hp] = _c59Il::P64;
           R2 = Hp - 16;
           R1 = _c59Il::P64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.223640638 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_closure" {
     Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_closure:
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_info;
         const 0;
 },
 Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(c59Jt,
                       label: Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Jt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c59JJ; else goto c59JK;
       c59JJ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c59JK: // global
           I64[Sp - 32] = block_c59Jq_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u59JS; else goto c59Jr;
       u59JS: // global
           call _c59Jq(R1) args: 0, res: 0, upd: 0;
       c59Jr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Jq() //  [R1]
         { info_tbl: [(c59Jq,
                       label: block_c59Jq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Jq: // global
           I64[Sp] = block_c59Jw_info;
           _s59Cu::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s59Cu::P64;
           if (R1 & 7 != 0) goto u59JR; else goto c59Jx;
       u59JR: // global
           call _c59Jw(R1) args: 0, res: 0, upd: 0;
       c59Jx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Jw() //  [R1]
         { info_tbl: [(c59Jw,
                       label: block_c59Jw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Jw: // global
           I64[Sp] = block_c59JB_info;
           _s59Cw::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s59Cw::P64;
           if (R1 & 7 != 0) goto u59JT; else goto c59JC;
       u59JT: // global
           call _c59JB(R1) args: 0, res: 0, upd: 0;
       c59JC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59JB() //  [R1]
         { info_tbl: [(c59JB,
                       label: block_c59JB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59JB: // global
           _s59Cw::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c59JG_info;
           R5 = R1;
           R4 = _s59Cw::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Coercion.$w$cenumFromThenTo_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _c59JG() //  [R1, R2]
         { info_tbl: [(c59JG,
                       label: block_c59JG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59JG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c59JQ; else goto c59JP;
       c59JQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c59JP: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.225611761 UTC

[section ""data" . lvl2_r59Bd_closure" {
     lvl2_r59Bd_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.226489308 UTC

[section ""data" . lvl3_r59Be_closure" {
     lvl3_r59Be_closure:
         const lvl3_r59Be_info;
 },
 lvl3_r59Be_entry() //  [R2]
         { info_tbl: [(c59K1,
                       label: lvl3_r59Be_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59K1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c59K2; else goto c59K3;
       c59K2: // global
           R2 = R2;
           R1 = lvl3_r59Be_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c59K3: // global
           I64[Sp - 8] = block_c59JY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u59K7; else goto c59JZ;
       u59K7: // global
           call _c59JY() args: 0, res: 0, upd: 0;
       c59JZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59JY() //  []
         { info_tbl: [(c59JY,
                       label: block_c59JY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59JY: // global
           R1 = lvl2_r59Bd_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.227660725 UTC

[section ""data" . lvl4_r59Bf_closure" {
     lvl4_r59Bf_closure:
         const lvl4_r59Bf_info;
         const 0;
 },
 lvl4_r59Bf_entry() //  [R2]
         { info_tbl: [(c59Kf,
                       label: lvl4_r59Bf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Kf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c59Kg; else goto c59Kh;
       c59Kg: // global
           R2 = R2;
           R1 = lvl4_r59Bf_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c59Kh: // global
           I64[Sp - 8] = block_c59Kc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u59Kl; else goto c59Kd;
       u59Kl: // global
           call _c59Kc() args: 0, res: 0, upd: 0;
       c59Kd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Kc() //  []
         { info_tbl: [(c59Kc,
                       label: block_c59Kc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Kc: // global
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.229562926 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_closure" {
     Data.Type.Coercion.$fEnumCoercion_closure:
         const Data.Type.Coercion.$fEnumCoercion_info;
         const 0;
 },
 sat_s59CO_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c59Kv,
                       label: sat_s59CO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Kv: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59CN_entry() //  [R1, R2, R3]
         { info_tbl: [(c59KD,
                       label: sat_s59CN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59KD: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59CM_entry() //  [R1, R2, R3]
         { info_tbl: [(c59KL,
                       label: sat_s59CM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59KL: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59CL_entry() //  [R1, R2]
         { info_tbl: [(c59KT,
                       label: sat_s59CL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59KT: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Coercion.$fEnumCoercion_$cenumFrom_entry(R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59CK_entry() //  [R1, R2]
         { info_tbl: [(c59L1,
                       label: sat_s59CK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59L1: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Coercion.$fEnumCoercion_$ctoEnum_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$fEnumCoercion_entry() //  [R2]
         { info_tbl: [(c59L5,
                       label: Data.Type.Coercion.$fEnumCoercion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59L5: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto c59L9; else goto c59L8;
       c59L9: // global
           HpAlloc = 152;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c59L8: // global
           I64[Hp - 144] = sat_s59CO_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s59CN_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s59CM_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s59CL_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s59CK_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = lvl4_r59Bf_closure+1;
           P64[Hp - 48] = lvl4_r59Bf_closure+1;
           P64[Hp - 40] = Hp - 79;
           P64[Hp - 32] = lvl3_r59Be_closure+1;
           P64[Hp - 24] = Hp - 95;
           P64[Hp - 16] = Hp - 110;
           P64[Hp - 8] = Hp - 126;
           P64[Hp] = Hp - 141;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.231931537 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_closure" {
     Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_closure:
         const Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_info;
 },
 Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(c59Lh,
                       label: Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Lh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59Ls; else goto c59Lt;
       c59Ls: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59Lt: // global
           I64[Sp - 16] = block_c59Le_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u59Lz; else goto c59Lf;
       u59Lz: // global
           call _c59Le() args: 0, res: 0, upd: 0;
       c59Lf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Le() //  []
         { info_tbl: [(c59Le,
                       label: block_c59Le_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Le: // global
           _s59CQ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c59Lk_info;
           R1 = _s59CQ::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u59Ly; else goto c59Ll;
       u59Ly: // global
           call _c59Lk(R1) args: 0, res: 0, upd: 0;
       c59Ll: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Lk() //  [R1]
         { info_tbl: [(c59Lk,
                       label: block_c59Lk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Lk: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c59Lx; else goto c59Lw;
       c59Lx: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c59Lw: // global
           I64[Hp - 40] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = Hp - 39;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.233591684 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionk:~:_closure" {
     Data.Type.Coercion.$fTestCoercionk:~:_closure:
         const Data.Type.Coercion.$fTestCoercionk:~:_info;
 },
 Data.Type.Coercion.$fTestCoercionk:~:_entry() //  [R2, R3]
         { info_tbl: [(c59LE,
                       label: Data.Type.Coercion.$fTestCoercionk:~:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59LE: // global
           R3 = R3;
           R2 = R2;
           call Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_entry(R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.234734491 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_closure" {
     Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_closure:
         const Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_info;
 },
 Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(c59LO,
                       label: Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59LO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59LZ; else goto c59M0;
       c59LZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59M0: // global
           I64[Sp - 16] = block_c59LL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u59M6; else goto c59LM;
       u59M6: // global
           call _c59LL() args: 0, res: 0, upd: 0;
       c59LM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59LL() //  []
         { info_tbl: [(c59LL,
                       label: block_c59LL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59LL: // global
           _s59CW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c59LR_info;
           R1 = _s59CW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u59M5; else goto c59LS;
       u59M5: // global
           call _c59LR(R1) args: 0, res: 0, upd: 0;
       c59LS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59LR() //  [R1]
         { info_tbl: [(c59LR,
                       label: block_c59LR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59LR: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c59M4; else goto c59M3;
       c59M4: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c59M3: // global
           I64[Hp - 40] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = Hp - 39;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.236431297 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionk:~~:_closure" {
     Data.Type.Coercion.$fTestCoercionk:~~:_closure:
         const Data.Type.Coercion.$fTestCoercionk:~~:_info;
 },
 Data.Type.Coercion.$fTestCoercionk:~~:_entry() //  [R2, R3]
         { info_tbl: [(c59Mb,
                       label: Data.Type.Coercion.$fTestCoercionk:~~:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Mb: // global
           R3 = R3;
           R2 = R2;
           call Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_entry(R3,
                                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.240834182 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_closure" {
     Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_closure:
         const Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_info;
 },
 Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(c59Ml,
                       label: Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Ml: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59MA; else goto c59MB;
       c59MA: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59MB: // global
           I64[Sp - 16] = block_c59Mi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u59MJ; else goto c59Mj;
       u59MJ: // global
           call _c59Mi(R1) args: 0, res: 0, upd: 0;
       c59Mj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Mi() //  [R1]
         { info_tbl: [(c59Mi,
                       label: block_c59Mi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Mi: // global
           I64[Sp] = block_c59Mo_info;
           _s59D4::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s59D4::P64;
           if (R1 & 7 != 0) goto u59MI; else goto c59Mp;
       u59MI: // global
           call _c59Mo(R1) args: 0, res: 0, upd: 0;
       c59Mp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Mo() //  [R1]
         { info_tbl: [(c59Mo,
                       label: block_c59Mo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Mo: // global
           I64[Sp] = block_c59Mt_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 7];
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c59Mt() //  []
         { info_tbl: [(c59Mt,
                       label: block_c59Mt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Mt: // global
           _s59D6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c59Mv_info;
           R2 = _s59D6::P64;
           Sp = Sp + 8;
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c59Mv() //  []
         { info_tbl: [(c59Mv,
                       label: block_c59Mv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Mv: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c59MH; else goto c59MG;
       c59MH: // global
           HpAlloc = 48;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c59MG: // global
           I64[Hp - 40] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = Hp - 39;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.243875326 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionkCoercion_closure" {
     Data.Type.Coercion.$fTestCoercionkCoercion_closure:
         const Data.Type.Coercion.$fTestCoercionkCoercion_info;
 },
 Data.Type.Coercion.$fTestCoercionkCoercion_entry() //  [R2, R3]
         { info_tbl: [(c59MO,
                       label: Data.Type.Coercion.$fTestCoercionkCoercion_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59MO: // global
           R3 = R3;
           R2 = R2;
           call Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_entry(R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.245512164 UTC

[section ""data" . Data.Type.Coercion.$fEqCoercion_$c==_closure" {
     Data.Type.Coercion.$fEqCoercion_$c==_closure:
         const Data.Type.Coercion.$fEqCoercion_$c==_info;
 },
 Data.Type.Coercion.$fEqCoercion_$c==_entry() //  [R2, R3]
         { info_tbl: [(c59MY,
                       label: Data.Type.Coercion.$fEqCoercion_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59MY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59N2; else goto c59N3;
       c59N2: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEqCoercion_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59N3: // global
           I64[Sp - 16] = block_c59MV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u59Nb; else goto c59MW;
       u59Nb: // global
           call _c59MV() args: 0, res: 0, upd: 0;
       c59MW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59MV() //  []
         { info_tbl: [(c59MV,
                       label: block_c59MV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59MV: // global
           _s59Da::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c59N1_info;
           R1 = _s59Da::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u59Na; else goto c59N5;
       u59Na: // global
           call _c59N1() args: 0, res: 0, upd: 0;
       c59N5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59N1() //  []
         { info_tbl: [(c59N1,
                       label: block_c59N1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59N1: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.247937867 UTC

[section ""data" . Data.Type.Coercion.$fEqCoercion_$c/=_closure" {
     Data.Type.Coercion.$fEqCoercion_$c/=_closure:
         const Data.Type.Coercion.$fEqCoercion_$c/=_info;
 },
 Data.Type.Coercion.$fEqCoercion_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c59Nj,
                       label: Data.Type.Coercion.$fEqCoercion_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Nj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59Nn; else goto c59No;
       c59Nn: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEqCoercion_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59No: // global
           I64[Sp - 16] = block_c59Ng_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u59Nw; else goto c59Nh;
       u59Nw: // global
           call _c59Ng() args: 0, res: 0, upd: 0;
       c59Nh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Ng() //  []
         { info_tbl: [(c59Ng,
                       label: block_c59Ng_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Ng: // global
           _s59Dg::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c59Nm_info;
           R1 = _s59Dg::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u59Nv; else goto c59Nq;
       u59Nv: // global
           call _c59Nm() args: 0, res: 0, upd: 0;
       c59Nq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Nm() //  []
         { info_tbl: [(c59Nm,
                       label: block_c59Nm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Nm: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.249943913 UTC

[section ""data" . Data.Type.Coercion.$fEqCoercion_closure" {
     Data.Type.Coercion.$fEqCoercion_closure:
         const GHC.Classes.C:Eq_con_info;
         const Data.Type.Coercion.$fEqCoercion_$c==_closure+2;
         const Data.Type.Coercion.$fEqCoercion_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.250776837 UTC

[section ""cstring" . Data.Type.Coercion.$fReadCoercion3_bytes" {
     Data.Type.Coercion.$fReadCoercion3_bytes:
         I8[] [67,111,101,114,99,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.252012891 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion2_closure" {
     Data.Type.Coercion.$fReadCoercion2_closure:
         const Data.Type.Coercion.$fReadCoercion2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Coercion.$fReadCoercion2_entry() //  [R1]
         { info_tbl: [(c59ND,
                       label: Data.Type.Coercion.$fReadCoercion2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59ND: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59NE; else goto c59NF;
       c59NE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59NF: // global
           (_c59NA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c59NA::I64 == 0) goto c59NC; else goto c59NB;
       c59NC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c59NB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c59NA::I64;
           R2 = Data.Type.Coercion.$fReadCoercion3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.254001825 UTC

[section ""data" . Data.Type.Coercion.$fShowCoercion_$cshowsPrec_closure" {
     Data.Type.Coercion.$fShowCoercion_$cshowsPrec_closure:
         const Data.Type.Coercion.$fShowCoercion_$cshowsPrec_info;
         const 0;
 },
 Data.Type.Coercion.$fShowCoercion_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c59NN,
                       label: Data.Type.Coercion.$fShowCoercion_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59NN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59NO; else goto c59NP;
       c59NO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fShowCoercion_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c59NP: // global
           I64[Sp - 16] = block_c59NK_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u59NT; else goto c59NL;
       u59NT: // global
           call _c59NK() args: 0, res: 0, upd: 0;
       c59NL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59NK() //  []
         { info_tbl: [(c59NK,
                       label: block_c59NK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59NK: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Coercion.$fReadCoercion2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.256076982 UTC

[section ""data" . Data.Type.Coercion.$fShowCoercion_$cshow_closure" {
     Data.Type.Coercion.$fShowCoercion_$cshow_closure:
         const Data.Type.Coercion.$fShowCoercion_$cshow_info;
         const 0;
 },
 Data.Type.Coercion.$fShowCoercion_$cshow_entry() //  [R2]
         { info_tbl: [(c59O1,
                       label: Data.Type.Coercion.$fShowCoercion_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59O1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c59O2; else goto c59O3;
       c59O2: // global
           R2 = R2;
           R1 = Data.Type.Coercion.$fShowCoercion_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c59O3: // global
           I64[Sp - 8] = block_c59NY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u59O7; else goto c59NZ;
       u59O7: // global
           call _c59NY() args: 0, res: 0, upd: 0;
       c59NZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59NY() //  []
         { info_tbl: [(c59NY,
                       label: block_c59NY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59NY: // global
           R1 = Data.Type.Coercion.$fReadCoercion2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.258230185 UTC

[section ""data" . Data.Type.Coercion.$fShowCoercion1_closure" {
     Data.Type.Coercion.$fShowCoercion1_closure:
         const Data.Type.Coercion.$fShowCoercion1_info;
         const 0;
 },
 Data.Type.Coercion.$fShowCoercion1_entry() //  [R2, R3]
         { info_tbl: [(c59Of,
                       label: Data.Type.Coercion.$fShowCoercion1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Of: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59Og; else goto c59Oh;
       c59Og: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fShowCoercion1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59Oh: // global
           I64[Sp - 16] = block_c59Oc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u59Ol; else goto c59Od;
       u59Ol: // global
           call _c59Oc() args: 0, res: 0, upd: 0;
       c59Od: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Oc() //  []
         { info_tbl: [(c59Oc,
                       label: block_c59Oc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Oc: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Coercion.$fReadCoercion2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.260217915 UTC

[section ""data" . Data.Type.Coercion.$fShowCoercion_$cshowList_closure" {
     Data.Type.Coercion.$fShowCoercion_$cshowList_closure:
         const Data.Type.Coercion.$fShowCoercion_$cshowList_info;
         const 0;
 },
 Data.Type.Coercion.$fShowCoercion_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c59Oq,
                       label: Data.Type.Coercion.$fShowCoercion_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Oq: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Type.Coercion.$fShowCoercion1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.26148796 UTC

[section ""data" . Data.Type.Coercion.$fShowCoercion_closure" {
     Data.Type.Coercion.$fShowCoercion_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Type.Coercion.$fShowCoercion_$cshowsPrec_closure+3;
         const Data.Type.Coercion.$fShowCoercion_$cshow_closure+1;
         const Data.Type.Coercion.$fShowCoercion_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.262911388 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$c<_closure" {
     Data.Type.Coercion.$fOrdCoercion_$c<_closure:
         const Data.Type.Coercion.$fOrdCoercion_$c<_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$c<_entry() //  [R2, R3]
         { info_tbl: [(c59OA,
                       label: Data.Type.Coercion.$fOrdCoercion_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59OA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59OE; else goto c59OF;
       c59OE: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59OF: // global
           I64[Sp - 16] = block_c59Ox_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u59ON; else goto c59Oy;
       u59ON: // global
           call _c59Ox() args: 0, res: 0, upd: 0;
       c59Oy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Ox() //  []
         { info_tbl: [(c59Ox,
                       label: block_c59Ox_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Ox: // global
           _s59DA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c59OD_info;
           R1 = _s59DA::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u59OM; else goto c59OH;
       u59OM: // global
           call _c59OD() args: 0, res: 0, upd: 0;
       c59OH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59OD() //  []
         { info_tbl: [(c59OD,
                       label: block_c59OD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59OD: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.265526987 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$ccompare_closure" {
     Data.Type.Coercion.$fOrdCoercion_$ccompare_closure:
         const Data.Type.Coercion.$fOrdCoercion_$ccompare_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c59OV,
                       label: Data.Type.Coercion.$fOrdCoercion_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59OV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59OZ; else goto c59P0;
       c59OZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59P0: // global
           I64[Sp - 16] = block_c59OS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u59P8; else goto c59OT;
       u59P8: // global
           call _c59OS() args: 0, res: 0, upd: 0;
       c59OT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59OS() //  []
         { info_tbl: [(c59OS,
                       label: block_c59OS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59OS: // global
           _s59DG::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c59OY_info;
           R1 = _s59DG::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u59P7; else goto c59P2;
       u59P7: // global
           call _c59OY() args: 0, res: 0, upd: 0;
       c59P2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59OY() //  []
         { info_tbl: [(c59OY,
                       label: block_c59OY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59OY: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.26807668 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$c<=_closure" {
     Data.Type.Coercion.$fOrdCoercion_$c<=_closure:
         const Data.Type.Coercion.$fOrdCoercion_$c<=_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c59Pg,
                       label: Data.Type.Coercion.$fOrdCoercion_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Pg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59Pk; else goto c59Pl;
       c59Pk: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59Pl: // global
           I64[Sp - 16] = block_c59Pd_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u59Pt; else goto c59Pe;
       u59Pt: // global
           call _c59Pd() args: 0, res: 0, upd: 0;
       c59Pe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Pd() //  []
         { info_tbl: [(c59Pd,
                       label: block_c59Pd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Pd: // global
           _s59DL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c59Pj_info;
           R1 = _s59DL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u59Ps; else goto c59Pn;
       u59Ps: // global
           call _c59Pj() args: 0, res: 0, upd: 0;
       c59Pn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Pj() //  []
         { info_tbl: [(c59Pj,
                       label: block_c59Pj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Pj: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.270626769 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$cmax_closure" {
     Data.Type.Coercion.$fOrdCoercion_$cmax_closure:
         const Data.Type.Coercion.$fOrdCoercion_$cmax_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c59PB,
                       label: Data.Type.Coercion.$fOrdCoercion_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59PB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59PC; else goto c59PD;
       c59PC: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59PD: // global
           I64[Sp - 16] = block_c59Py_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u59PH; else goto c59Pz;
       u59PH: // global
           call _c59Py() args: 0, res: 0, upd: 0;
       c59Pz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Py() //  []
         { info_tbl: [(c59Py,
                       label: block_c59Py_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Py: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.272743387 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$c>_closure" {
     Data.Type.Coercion.$fOrdCoercion_$c>_closure:
         const Data.Type.Coercion.$fOrdCoercion_$c>_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$c>_entry() //  [R2, R3]
         { info_tbl: [(c59PP,
                       label: Data.Type.Coercion.$fOrdCoercion_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59PP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59PT; else goto c59PU;
       c59PT: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59PU: // global
           I64[Sp - 16] = block_c59PM_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u59Q2; else goto c59PN;
       u59Q2: // global
           call _c59PM() args: 0, res: 0, upd: 0;
       c59PN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59PM() //  []
         { info_tbl: [(c59PM,
                       label: block_c59PM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59PM: // global
           _s59DV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c59PS_info;
           R1 = _s59DV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u59Q1; else goto c59PW;
       u59Q1: // global
           call _c59PS() args: 0, res: 0, upd: 0;
       c59PW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59PS() //  []
         { info_tbl: [(c59PS,
                       label: block_c59PS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59PS: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.275169326 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$cmin_closure" {
     Data.Type.Coercion.$fOrdCoercion_$cmin_closure:
         const Data.Type.Coercion.$fOrdCoercion_$cmin_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c59Qa,
                       label: Data.Type.Coercion.$fOrdCoercion_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Qa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59Qb; else goto c59Qc;
       c59Qb: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59Qc: // global
           I64[Sp - 16] = block_c59Q7_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u59Qg; else goto c59Q8;
       u59Qg: // global
           call _c59Q7() args: 0, res: 0, upd: 0;
       c59Q8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Q7() //  []
         { info_tbl: [(c59Q7,
                       label: block_c59Q7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Q7: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.276855047 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_closure" {
     Data.Type.Coercion.$fOrdCoercion_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Type.Coercion.$fEqCoercion_closure+1;
         const Data.Type.Coercion.$fOrdCoercion_$ccompare_closure+2;
         const Data.Type.Coercion.$fOrdCoercion_$c<_closure+2;
         const Data.Type.Coercion.$fOrdCoercion_$c<=_closure+2;
         const Data.Type.Coercion.$fOrdCoercion_$c>_closure+2;
         const Data.Type.Coercion.$fEqCoercion_$c==_closure+2;
         const Data.Type.Coercion.$fOrdCoercion_$cmax_closure+2;
         const Data.Type.Coercion.$fOrdCoercion_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.277959412 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion_lexeme_closure" {
     Data.Type.Coercion.$fReadCoercion_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Type.Coercion.$fReadCoercion2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.279960949 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion1_closure" {
     Data.Type.Coercion.$fReadCoercion1_closure:
         const Data.Type.Coercion.$fReadCoercion1_info;
         const 0;
 },
 sat_s59Ec_entry() //  [R1]
         { info_tbl: [(c59Qw,
                       label: sat_s59Ec_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Qw: // global
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59Ef_entry() //  [R1, R2, R3]
         { info_tbl: [(c59QC,
                       label: sat_s59Ef_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59QC: // global
           _s59Ea::P64 = R3;
           _s59E9::P64 = R2;
           _s59Ef::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c59QD; else goto c59QE;
       c59QE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c59QG; else goto c59QF;
       c59QG: // global
           HpAlloc = 24;
           goto c59QD;
       c59QD: // global
           R3 = _s59Ea::P64;
           R2 = _s59E9::P64;
           R1 = _s59Ef::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59QF: // global
           _s59E8::P64 = P64[_s59Ef::P64 + 6];
           I64[Hp - 16] = sat_s59Ec_info;
           P64[Hp - 8] = _s59E8::P64;
           P64[Hp] = _s59Ea::P64;
           I64[Sp - 8] = block_c59Qz_info;
           R3 = Hp - 15;
           R2 = Data.Type.Coercion.$fReadCoercion_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c59Qz() //  [R1]
         { info_tbl: [(c59Qz,
                       label: block_c59Qz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Qz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c59QJ; else goto c59QI;
       c59QJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c59QI: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$fReadCoercion1_entry() //  [R2, R3, R4]
         { info_tbl: [(c59QK,
                       label: Data.Type.Coercion.$fReadCoercion1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59QK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c59QO; else goto c59QN;
       c59QO: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fReadCoercion1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c59QN: // global
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s59Ef_info;
           P64[Hp] = Hp - 23;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.284012585 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion_$creadsPrec_closure" {
     Data.Type.Coercion.$fReadCoercion_$creadsPrec_closure:
         const Data.Type.Coercion.$fReadCoercion_$creadsPrec_info;
         const 0;
 },
 sat_s59Ei_entry() //  [R1]
         { info_tbl: [(c59QX,
                       label: sat_s59Ei_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59QX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59QY; else goto c59QZ;
       c59QY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59QZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Coercion.$fReadCoercion1_entry(R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Coercion.$fReadCoercion_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c59R0,
                       label: Data.Type.Coercion.$fReadCoercion_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59R0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c59R4; else goto c59R3;
       c59R4: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fReadCoercion_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59R3: // global
           I64[Hp - 24] = sat_s59Ei_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.28667678 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion_$creadListPrec_closure" {
     Data.Type.Coercion.$fReadCoercion_$creadListPrec_closure:
         const Data.Type.Coercion.$fReadCoercion_$creadListPrec_info;
         const 0;
 },
 sat_s59Ek_entry() //  [R1, R2, R3]
         { info_tbl: [(c59Re,
                       label: sat_s59Ek_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Re: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Coercion.$fReadCoercion1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$fReadCoercion_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c59Rh,
                       label: Data.Type.Coercion.$fReadCoercion_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Rh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c59Rl; else goto c59Rk;
       c59Rl: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Type.Coercion.$fReadCoercion_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c59Rk: // global
           I64[Hp - 8] = sat_s59Ek_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.289213055 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion_$creadList_closure" {
     Data.Type.Coercion.$fReadCoercion_$creadList_closure:
         const Data.Type.Coercion.$fReadCoercion_$creadList_info;
         const 0;
 },
 sat_s59Em_entry() //  [R1, R2, R3]
         { info_tbl: [(c59Rz,
                       label: sat_s59Em_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Rz: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Coercion.$fReadCoercion1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59En_entry() //  [R1]
         { info_tbl: [(c59RC,
                       label: sat_s59En_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59RC: // global
           _s59En::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c59RD; else goto c59RE;
       c59RE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c59RG; else goto c59RF;
       c59RG: // global
           HpAlloc = 16;
           goto c59RD;
       c59RD: // global
           R1 = _s59En::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59RF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s59En::P64;
           _s59El::P64 = P64[_s59En::P64 + 16];
           I64[Hp - 8] = sat_s59Em_info;
           P64[Hp] = _s59El::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Type.Coercion.$fReadCoercion_$creadList_entry() //  [R2]
         { info_tbl: [(c59RH,
                       label: Data.Type.Coercion.$fReadCoercion_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59RH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c59RL; else goto c59RK;
       c59RL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Type.Coercion.$fReadCoercion_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c59RK: // global
           I64[Hp - 16] = sat_s59En_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.293013569 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion_closure" {
     Data.Type.Coercion.$fReadCoercion_closure:
         const Data.Type.Coercion.$fReadCoercion_info;
         const 0;
 },
 sat_s59Es_entry() //  [R1]
         { info_tbl: [(c59RU,
                       label: sat_s59Es_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59RU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59RV; else goto c59RW;
       c59RV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59RW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Coercion.$fReadCoercion_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s59Er_entry() //  [R1, R2, R3]
         { info_tbl: [(c59S2,
                       label: sat_s59Er_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59S2: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Coercion.$fReadCoercion1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59Eq_entry() //  [R1]
         { info_tbl: [(c59S9,
                       label: sat_s59Eq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59S9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59Sa; else goto c59Sb;
       c59Sa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59Sb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Coercion.$fReadCoercion_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s59Ep_entry() //  [R1, R2]
         { info_tbl: [(c59Sh,
                       label: sat_s59Ep_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Sh: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Coercion.$fReadCoercion_$creadsPrec_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$fReadCoercion_entry() //  [R2]
         { info_tbl: [(c59Sl,
                       label: Data.Type.Coercion.$fReadCoercion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Sl: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c59Sp; else goto c59So;
       c59Sp: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Type.Coercion.$fReadCoercion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c59So: // global
           I64[Hp - 112] = sat_s59Es_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s59Er_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s59Eq_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s59Ep_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 112;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.296663723 UTC

[section ""data" . Data.Type.Coercion.$fBoundedCoercion_closure" {
     Data.Type.Coercion.$fBoundedCoercion_closure:
         const Data.Type.Coercion.$fBoundedCoercion_info;
 },
 Data.Type.Coercion.$fBoundedCoercion_entry() //  [R2]
         { info_tbl: [(c59Sw,
                       label: Data.Type.Coercion.$fBoundedCoercion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Sw: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c59SA; else goto c59Sz;
       c59SA: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Type.Coercion.$fBoundedCoercion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c59Sz: // global
           I64[Hp - 32] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           _c59Su::P64 = Hp - 31;
           P64[Hp - 8] = _c59Su::P64;
           P64[Hp] = _c59Su::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.298731838 UTC

[section ""data" . Data.Type.Coercion.coerceWith_closure" {
     Data.Type.Coercion.coerceWith_closure:
         const Data.Type.Coercion.coerceWith_info;
 },
 Data.Type.Coercion.coerceWith_entry() //  [R2, R3]
         { info_tbl: [(c59SI,
                       label: Data.Type.Coercion.coerceWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59SI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59SM; else goto c59SN;
       c59SM: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.coerceWith_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59SN: // global
           I64[Sp - 16] = block_c59SF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u59SV; else goto c59SG;
       u59SV: // global
           call _c59SF(R1) args: 0, res: 0, upd: 0;
       c59SG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59SF() //  [R1]
         { info_tbl: [(c59SF,
                       label: block_c59SF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59SF: // global
           I64[Sp] = block_c59SL_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto u59SU; else goto c59SP;
       u59SU: // global
           call _c59SL() args: 0, res: 0, upd: 0;
       c59SP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59SL() //  []
         { info_tbl: [(c59SL,
                       label: block_c59SL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59SL: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.301327874 UTC

[section ""data" . Data.Type.Coercion.gcoerceWith_closure" {
     Data.Type.Coercion.gcoerceWith_closure:
         const Data.Type.Coercion.gcoerceWith_info;
 },
 Data.Type.Coercion.gcoerceWith_entry() //  [R2, R3]
         { info_tbl: [(c59T3,
                       label: Data.Type.Coercion.gcoerceWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59T3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59T4; else goto c59T5;
       c59T4: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.gcoerceWith_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59T5: // global
           I64[Sp - 16] = block_c59T0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u59T9; else goto c59T1;
       u59T9: // global
           call _c59T0(R1) args: 0, res: 0, upd: 0;
       c59T1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59T0() //  [R1]
         { info_tbl: [(c59T0,
                       label: block_c59T0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59T0: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.303661324 UTC

[section ""data" . Data.Type.Coercion.sym_closure" {
     Data.Type.Coercion.sym_closure:
         const Data.Type.Coercion.sym_info;
 },
 Data.Type.Coercion.sym_entry() //  [R2]
         { info_tbl: [(c59Th,
                       label: Data.Type.Coercion.sym_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Th: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c59To; else goto c59Tp;
       c59To: // global
           R2 = R2;
           R1 = Data.Type.Coercion.sym_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c59Tp: // global
           I64[Sp - 8] = block_c59Te_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u59Tu; else goto c59Tf;
       u59Tu: // global
           call _c59Te(R1) args: 0, res: 0, upd: 0;
       c59Tf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Te() //  [R1]
         { info_tbl: [(c59Te,
                       label: block_c59Te_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Te: // global
           I64[Sp] = block_c59Tk_info;
           R2 = P64[R1 + 7];
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c59Tk() //  []
         { info_tbl: [(c59Tk,
                       label: block_c59Tk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Tk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c59Tt; else goto c59Ts;
       c59Tt: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c59Ts: // global
           I64[Hp - 24] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 8] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.306812009 UTC

[section ""data" . Data.Type.Coercion.trans_closure" {
     Data.Type.Coercion.trans_closure:
         const Data.Type.Coercion.trans_info;
 },
 Data.Type.Coercion.trans_entry() //  [R2, R3]
         { info_tbl: [(c59TC,
                       label: Data.Type.Coercion.trans_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59TC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59TQ; else goto c59TR;
       c59TQ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.trans_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59TR: // global
           I64[Sp - 16] = block_c59Tz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u59TY; else goto c59TA;
       u59TY: // global
           call _c59Tz(R1) args: 0, res: 0, upd: 0;
       c59TA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Tz() //  [R1]
         { info_tbl: [(c59Tz,
                       label: block_c59Tz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Tz: // global
           I64[Sp] = block_c59TF_info;
           R2 = P64[R1 + 7];
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c59TF() //  []
         { info_tbl: [(c59TF,
                       label: block_c59TF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59TF: // global
           _s59EK::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c59TH_info;
           R1 = _s59EK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u59TZ; else goto c59TI;
       u59TZ: // global
           call _c59TH(R1) args: 0, res: 0, upd: 0;
       c59TI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59TH() //  [R1]
         { info_tbl: [(c59TH,
                       label: block_c59TH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59TH: // global
           I64[Sp] = block_c59TM_info;
           R2 = P64[R1 + 7];
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c59TM() //  []
         { info_tbl: [(c59TM,
                       label: block_c59TM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59TM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c59TX; else goto c59TW;
       c59TX: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c59TW: // global
           I64[Hp - 24] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 8] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.30995595 UTC

[section ""data" . Data.Type.Coercion.repr_closure" {
     Data.Type.Coercion.repr_closure:
         const Data.Type.Coercion.repr_info;
 },
 Data.Type.Coercion.repr_entry() //  [R2]
         { info_tbl: [(c59U7,
                       label: Data.Type.Coercion.repr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59U7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c59Uc; else goto c59Ud;
       c59Uc: // global
           R2 = R2;
           R1 = Data.Type.Coercion.repr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c59Ud: // global
           I64[Sp - 8] = block_c59U4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u59Uh; else goto c59U5;
       u59Uh: // global
           call _c59U4(R1) args: 0, res: 0, upd: 0;
       c59U5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59U4() //  [R1]
         { info_tbl: [(c59U4,
                       label: block_c59U4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59U4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c59Ug; else goto c59Uf;
       c59Ug: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c59Uf: // global
           I64[Hp - 24] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 8] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.311853073 UTC

[section ""cstring" . Data.Type.Coercion.$trModule4_bytes" {
     Data.Type.Coercion.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.312749561 UTC

[section ""data" . Data.Type.Coercion.$trModule3_closure" {
     Data.Type.Coercion.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Coercion.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.313685567 UTC

[section ""cstring" . Data.Type.Coercion.$trModule2_bytes" {
     Data.Type.Coercion.$trModule2_bytes:
         I8[] [68,97,116,97,46,84,121,112,101,46,67,111,101,114,99,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.314489242 UTC

[section ""data" . Data.Type.Coercion.$trModule1_closure" {
     Data.Type.Coercion.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Coercion.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.31535932 UTC

[section ""data" . Data.Type.Coercion.$trModule_closure" {
     Data.Type.Coercion.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Type.Coercion.$trModule3_closure+1;
         const Data.Type.Coercion.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.316214355 UTC

[section ""data" . $krep_r59Bg_closure" {
     $krep_r59Bg_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.317057282 UTC

[section ""data" . $krep1_r59Bh_closure" {
     $krep1_r59Bh_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.317899329 UTC

[section ""data" . $krep2_r59Bi_closure" {
     $krep2_r59Bi_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r59Bh_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.318792976 UTC

[section ""data" . Data.Type.Coercion.$tcCoercion1_closure" {
     Data.Type.Coercion.$tcCoercion1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r59Bh_closure+2;
         const $krep2_r59Bi_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.319673842 UTC

[section ""data" . Data.Type.Coercion.$tcTestCoercion1_closure" {
     Data.Type.Coercion.$tcTestCoercion1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r59Bi_closure+4;
         const $krep_r59Bg_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.320520658 UTC

[section ""data" . $krep3_r59Bj_closure" {
     $krep3_r59Bj_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.323919273 UTC

[section ""data" . $krep4_r59Bk_closure" {
     $krep4_r59Bk_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.324950525 UTC

[section ""data" . $krep5_r59Bl_closure" {
     $krep5_r59Bl_closure:
         const :_con_info;
         const $krep3_r59Bj_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.325830622 UTC

[section ""data" . $krep6_r59Bm_closure" {
     $krep6_r59Bm_closure:
         const :_con_info;
         const $krep4_r59Bk_closure+2;
         const $krep5_r59Bl_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.326746468 UTC

[section ""data" . $krep7_r59Bn_closure" {
     $krep7_r59Bn_closure:
         const :_con_info;
         const $krep1_r59Bh_closure+2;
         const $krep6_r59Bm_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.327607855 UTC

[section ""data" . $krep8_r59Bo_closure" {
     $krep8_r59Bo_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcCoercible_closure;
         const $krep7_r59Bn_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.328436573 UTC

[section ""data" . Data.Type.Coercion.$tcCoercion2_closure" {
     Data.Type.Coercion.$tcCoercion2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Coercion.$fReadCoercion3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.329377219 UTC

[section ""data" . Data.Type.Coercion.$tcCoercion_closure" {
     Data.Type.Coercion.$tcCoercion_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Coercion.$trModule_closure+1;
         const Data.Type.Coercion.$tcCoercion2_closure+1;
         const Data.Type.Coercion.$tcCoercion1_closure+4;
         const 14885566513674463733;
         const 8268940906925368652;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.330271717 UTC

[section ""data" . $krep9_r59Bp_closure" {
     $krep9_r59Bp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Type.Coercion.$tcCoercion_closure+1;
         const $krep7_r59Bn_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.331076209 UTC

[section ""data" . Data.Type.Coercion.$tc'Coercion1_closure" {
     Data.Type.Coercion.$tc'Coercion1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_r59Bo_closure+1;
         const $krep9_r59Bp_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.331930312 UTC

[section ""cstring" . Data.Type.Coercion.$tc'Coercion3_bytes" {
     Data.Type.Coercion.$tc'Coercion3_bytes:
         I8[] [39,67,111,101,114,99,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.332722288 UTC

[section ""data" . Data.Type.Coercion.$tc'Coercion2_closure" {
     Data.Type.Coercion.$tc'Coercion2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Coercion.$tc'Coercion3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.334170332 UTC

[section ""data" . Data.Type.Coercion.$tc'Coercion_closure" {
     Data.Type.Coercion.$tc'Coercion_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Coercion.$trModule_closure+1;
         const Data.Type.Coercion.$tc'Coercion2_closure+1;
         const Data.Type.Coercion.$tc'Coercion1_closure+4;
         const 16177208673276072700;
         const 13187043378465993605;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.335033566 UTC

[section ""cstring" . Data.Type.Coercion.$tcTestCoercion3_bytes" {
     Data.Type.Coercion.$tcTestCoercion3_bytes:
         I8[] [84,101,115,116,67,111,101,114,99,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.335833371 UTC

[section ""data" . Data.Type.Coercion.$tcTestCoercion2_closure" {
     Data.Type.Coercion.$tcTestCoercion2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Coercion.$tcTestCoercion3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.336650912 UTC

[section ""data" . Data.Type.Coercion.$tcTestCoercion_closure" {
     Data.Type.Coercion.$tcTestCoercion_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Coercion.$trModule_closure+1;
         const Data.Type.Coercion.$tcTestCoercion2_closure+1;
         const Data.Type.Coercion.$tcTestCoercion1_closure+4;
         const 14520160333183018944;
         const 2439357669602544154;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.338019369 UTC

[section ""data" . Data.Type.Coercion.Coercion_closure" {
     Data.Type.Coercion.Coercion_closure:
         const Data.Type.Coercion.Coercion_info;
 },
 Data.Type.Coercion.Coercion_entry() //  [R2]
         { info_tbl: [(c59Un,
                       label: Data.Type.Coercion.Coercion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Un: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c59Ur; else goto c59Uq;
       c59Ur: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Type.Coercion.Coercion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c59Uq: // global
           I64[Hp - 8] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.339297686 UTC

[Data.Type.Coercion.Coercion_con_entry() //  [R1]
         { info_tbl: [(c59Us,
                       label: Data.Type.Coercion.Coercion_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,84,121,112,101,46,67,111,101,114,99,105,111,110,46,67,111,101,114,99,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Us: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.34037765 UTC

[section ""relreadonly" . S59Fe_srt" {
     S59Fe_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Type.Coercion.$fEnumCoercion1_closure;
         const Data.Type.Coercion.$fEnumCoercion_$ctoEnum_closure;
         const Data.Type.Coercion.$w$cenumFromTo_closure;
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_closure;
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_closure;
         const lvl1_r59Bc_closure;
         const Data.Type.Coercion.$w$cenumFrom_closure;
         const Data.Type.Coercion.$fEnumCoercion_$cenumFrom_closure;
         const Data.Type.Coercion.$w$cenumFromThenTo_closure;
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_closure;
         const lvl4_r59Bf_closure;
         const Data.Type.Coercion.$fEnumCoercion_closure;
         const Data.Type.Coercion.$fReadCoercion2_closure;
         const Data.Type.Coercion.$fShowCoercion_$cshowsPrec_closure;
         const Data.Type.Coercion.$fShowCoercion_$cshow_closure;
         const Data.Type.Coercion.$fShowCoercion1_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Type.Coercion.$fReadCoercion_lexeme_closure;
         const GHC.Read.list3_closure;
         const Data.Type.Coercion.$fReadCoercion1_closure;
         const Data.Type.Coercion.$fReadCoercion_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Type.Coercion.$fReadCoercion_$creadListPrec_closure;
         const Data.Type.Coercion.$fReadCoercion_$creadList_closure;
         const Data.Type.Coercion.$fReadCoercion_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.341500051 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:00:06.342572236 UTC

[section ""data" . Data.Type.Coercion.testCoercion_closure" {
     Data.Type.Coercion.testCoercion_closure:
         const Data.Type.Coercion.testCoercion_info;
 },
 Data.Type.Coercion.testCoercion_entry() //  [R2]
         { info_tbl: [(c59Ux,
                       label: Data.Type.Coercion.testCoercion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Ux: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.343716808 UTC

[section ""cstring" . lvl_r59Bb_bytes" {
     lvl_r59Bb_bytes:
         I8[] [68,97,116,97,46,84,121,112,101,46,67,111,101,114,99,105,111,110,46,116,111,69,110,117,109,58,32,98,97,100,32,97,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.344872657 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion1_closure" {
     Data.Type.Coercion.$fEnumCoercion1_closure:
         const Data.Type.Coercion.$fEnumCoercion1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Coercion.$fEnumCoercion1_entry() //  [R1]
         { info_tbl: [(c59UI,
                       label: Data.Type.Coercion.$fEnumCoercion1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59UI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c59UJ; else goto c59UK;
       c59UJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59UK: // global
           (_c59UD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c59UD::I64 == 0) goto c59UF; else goto c59UE;
       c59UF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c59UE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c59UD::I64;
           I64[Sp - 24] = block_c59UG_info;
           R2 = lvl_r59Bb_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c59UG() //  [R1]
         { info_tbl: [(c59UG,
                       label: block_c59UG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59UG: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.347301845 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_$ctoEnum_closure" {
     Data.Type.Coercion.$fEnumCoercion_$ctoEnum_closure:
         const Data.Type.Coercion.$fEnumCoercion_$ctoEnum_info;
         const 0;
 },
 Data.Type.Coercion.$fEnumCoercion_$ctoEnum_entry() //  [R2, R3]
         { info_tbl: [(c59UV,
                       label: Data.Type.Coercion.$fEnumCoercion_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59UV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59UW; else goto c59UX;
       c59UW: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_$ctoEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59UX: // global
           I64[Sp - 16] = block_c59US_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u59Va; else goto c59UT;
       u59Va: // global
           call _c59US(R1) args: 0, res: 0, upd: 0;
       c59UT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59US() //  [R1]
         { info_tbl: [(c59US,
                       label: block_c59US_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59US: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c59V2; else goto c59V1;
       c59V2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c59V1: // global
           if (I64[R1 + 7] == 0) goto c59V9; else goto c59V5;
       c59V9: // global
           I64[Hp - 8] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c59V5: // global
           Hp = Hp - 16;
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.350661989 UTC

[section ""data" . Data.Type.Coercion.$w$cenumFromTo_closure" {
     Data.Type.Coercion.$w$cenumFromTo_closure:
         const Data.Type.Coercion.$w$cenumFromTo_info;
         const 0;
 },
 sat_s59BI_entry() //  [R1]
         { info_tbl: [(c59Vt,
                       label: sat_s59BI_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Vt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59Vu; else goto c59Vv;
       c59Vu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59Vv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s59BG::I64 = I64[R1 + 24];
           if (_s59BG::I64 != 0) goto c59Vr; else goto c59Vs;
       c59Vr: // global
           R2 = _s59BG::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s59BC_entry(R2, R1) args: 24, res: 0, upd: 24;
       c59Vs: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s59BF_entry() //  [R1]
         { info_tbl: [(c59VG,
                       label: sat_s59BF_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59VG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59VH; else goto c59VI;
       c59VH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59VI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 24] == 0) goto c59VF; else goto c59VE;
       c59VF: // global
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c59VE: // global
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s59BC_entry() //  [R1, R2]
         { info_tbl: [(c59VK,
                       label: go_s59BC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59VK: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c59VO; else goto c59VN;
       c59VO: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c59VN: // global
           _s59BB::P64 = P64[R1 + 7];
           I64[Hp - 80] = sat_s59BI_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s59BF_info;
           P64[Hp - 32] = _s59BB::P64;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$w$cenumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c59VP,
                       label: Data.Type.Coercion.$w$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59VP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c59VT; else goto c59VS;
       c59VT: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$w$cenumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c59VS: // global
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = go_s59BC_info;
           P64[Hp] = Hp - 23;
           R2 = 0;
           R1 = Hp - 7;
           call go_s59BC_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.355198468 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_closure" {
     Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_closure:
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_info;
         const 0;
 },
 Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(c59W1,
                       label: Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59W1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c59W5; else goto c59W6;
       c59W5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c59W6: // global
           I64[Sp - 24] = block_c59VY_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u59We; else goto c59VZ;
       u59We: // global
           call _c59VY(R1) args: 0, res: 0, upd: 0;
       c59VZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59VY() //  [R1]
         { info_tbl: [(c59VY,
                       label: block_c59VY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59VY: // global
           I64[Sp] = block_c59W4_info;
           _s59BM::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s59BM::P64;
           if (R1 & 7 != 0) goto u59Wd; else goto c59W8;
       u59Wd: // global
           call _c59W4(R1) args: 0, res: 0, upd: 0;
       c59W8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59W4() //  [R1]
         { info_tbl: [(c59W4,
                       label: block_c59W4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59W4: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Coercion.$w$cenumFromTo_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.357832065 UTC

[section ""data" . lvl1_r59Bc_closure" {
     lvl1_r59Bc_closure:
         const lvl1_r59Bc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r59Bc_entry() //  [R1]
         { info_tbl: [(c59Wl,
                       label: lvl1_r59Bc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Wl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59Wm; else goto c59Wn;
       c59Wm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59Wn: // global
           (_c59Wi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c59Wi::I64 == 0) goto c59Wk; else goto c59Wj;
       c59Wk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c59Wj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c59Wi::I64;
           R3 = 0;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.Enum.efdInt_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.360191226 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_closure" {
     Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_closure:
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_info;
         const 0;
 },
 sat_s59BX_entry() //  [R1, R2]
         { info_tbl: [(c59WH,
                       label: sat_s59BX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59WH: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Coercion.$fEnumCoercion_$ctoEnum_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(c59WK,
                       label: Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59WK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c59WL; else goto c59WM;
       c59WL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c59WM: // global
           I64[Sp - 24] = block_c59Ws_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u59WS; else goto c59Wt;
       u59WS: // global
           call _c59Ws() args: 0, res: 0, upd: 0;
       c59Wt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Ws() //  []
         { info_tbl: [(c59Ws,
                       label: block_c59Ws_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Ws: // global
           I64[Sp] = block_c59Wx_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u59WR; else goto c59Wy;
       u59WR: // global
           call _c59Wx(R1) args: 0, res: 0, upd: 0;
       c59Wy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Wx() //  [R1]
         { info_tbl: [(c59Wx,
                       label: block_c59Wx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Wx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c59WQ; else goto c59WP;
       c59WQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c59WP: // global
           I64[Hp - 8] = sat_s59BX_info;
           P64[Hp] = P64[Sp + 8];
           R3 = lvl1_r59Bc_closure;
           R2 = Hp - 7;
           Sp = Sp + 24;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.364264098 UTC

[section ""data" . Data.Type.Coercion.$w$cenumFrom_closure" {
     Data.Type.Coercion.$w$cenumFrom_closure:
         const Data.Type.Coercion.$w$cenumFrom_info;
         const 0;
 },
 sat_s59C7_entry() //  [R1]
         { info_tbl: [(c59Xb,
                       label: sat_s59C7_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Xb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59Xc; else goto c59Xd;
       c59Xc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59Xd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s59C5::I64 = I64[R1 + 24];
           if (_s59C5::I64 != 9223372036854775807) goto c59X9; else goto c59Xa;
       c59X9: // global
           R2 = _s59C5::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s59C1_entry(R2, R1) args: 24, res: 0, upd: 24;
       c59Xa: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s59C4_entry() //  [R1]
         { info_tbl: [(c59Xo,
                       label: sat_s59C4_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Xo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59Xp; else goto c59Xq;
       c59Xp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59Xq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 24] == 0) goto c59Xn; else goto c59Xm;
       c59Xn: // global
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c59Xm: // global
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s59C1_entry() //  [R1, R2]
         { info_tbl: [(c59Xs,
                       label: go_s59C1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Xs: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c59Xw; else goto c59Xv;
       c59Xw: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c59Xv: // global
           _s59C0::P64 = P64[R1 + 7];
           I64[Hp - 80] = sat_s59C7_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s59C4_info;
           P64[Hp - 32] = _s59C0::P64;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$w$cenumFrom_entry() //  [R2, R3]
         { info_tbl: [(c59Xx,
                       label: Data.Type.Coercion.$w$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Xx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c59XB; else goto c59XA;
       c59XB: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$w$cenumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59XA: // global
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = go_s59C1_info;
           P64[Hp] = Hp - 23;
           R2 = 0;
           R1 = Hp - 7;
           call go_s59C1_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.367070335 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_$cenumFrom_closure" {
     Data.Type.Coercion.$fEnumCoercion_$cenumFrom_closure:
         const Data.Type.Coercion.$fEnumCoercion_$cenumFrom_info;
         const 0;
 },
 Data.Type.Coercion.$fEnumCoercion_$cenumFrom_entry() //  [R2, R3]
         { info_tbl: [(c59XJ,
                       label: Data.Type.Coercion.$fEnumCoercion_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59XJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59XK; else goto c59XL;
       c59XK: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_$cenumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c59XL: // global
           I64[Sp - 16] = block_c59XG_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u59XP; else goto c59XH;
       u59XP: // global
           call _c59XG(R1) args: 0, res: 0, upd: 0;
       c59XH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59XG() //  [R1]
         { info_tbl: [(c59XG,
                       label: block_c59XG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59XG: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Type.Coercion.$w$cenumFrom_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.369386057 UTC

[section ""data" . Data.Type.Coercion.$w$cenumFromThenTo_closure" {
     Data.Type.Coercion.$w$cenumFromThenTo_closure:
         const Data.Type.Coercion.$w$cenumFromThenTo_info;
         const 0;
 },
 sat_s59Cm_entry() //  [R1]
         { info_tbl: [(c59Yb,
                       label: sat_s59Cm_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Yb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59Yc; else goto c59Yd;
       c59Yc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59Yd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s59Ch_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s59Cl_entry() //  [R1]
         { info_tbl: [(c59Ym,
                       label: sat_s59Cl_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Ym: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59Yn; else goto c59Yo;
       c59Yn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59Yo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 24] == 0) goto c59Yl; else goto c59Yk;
       c59Yl: // global
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c59Yk: // global
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s59Co_entry() //  [R1]
         { info_tbl: [(c59Yy,
                       label: sat_s59Co_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Yy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c59Yz; else goto c59YA;
       c59Yz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59YA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 24] == 0) goto c59Yx; else goto c59Yw;
       c59Yx: // global
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c59Yw: // global
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s59Ch_entry() //  [R1, R2]
         { info_tbl: [(c59YE,
                       label: go_up_s59Ch_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59YE: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c59YI; else goto c59YH;
       c59YI: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c59YH: // global
           _s59Cg::P64 = P64[R1 + 7];
           if (%MO_S_Le_W64(R2, 0)) goto c59YC; else goto c59YD;
       c59YC: // global
           I64[Hp - 80] = sat_s59Cm_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s59Cl_info;
           P64[Hp - 32] = _s59Cg::P64;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c59YD: // global
           I64[Hp - 80] = sat_s59Co_info;
           P64[Hp - 64] = _s59Cg::P64;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c59YK::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c59YK::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59Cp_entry() //  [R1]
         { info_tbl: [(c59YL,
                       label: sat_s59Cp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59YL: // global
           _s59Cp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c59YM; else goto c59YN;
       c59YN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c59YP; else goto c59YO;
       c59YP: // global
           HpAlloc = 16;
           goto c59YM;
       c59YM: // global
           R1 = _s59Cp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c59YO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s59Cp::P64;
           _s59Cg::P64 = P64[_s59Cp::P64 + 16];
           I64[Hp - 8] = go_up_s59Ch_info;
           P64[Hp] = _s59Cg::P64;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call go_up_s59Ch_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Coercion.$w$cenumFromThenTo_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c59YQ,
                       label: Data.Type.Coercion.$w$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59YQ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c59YU; else goto c59YT;
       c59YU: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$w$cenumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c59YT: // global
           I64[Hp - 32] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s59Cp_info;
           _c59XU::P64 = Hp - 31;
           P64[Hp] = _c59XU::P64;
           R2 = Hp - 16;
           R1 = _c59XU::P64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.373227787 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_closure" {
     Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_closure:
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_info;
         const 0;
 },
 Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(c59Z2,
                       label: Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Z2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c59Zi; else goto c59Zj;
       c59Zi: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c59Zj: // global
           I64[Sp - 32] = block_c59YZ_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u59Zr; else goto c59Z0;
       u59Zr: // global
           call _c59YZ(R1) args: 0, res: 0, upd: 0;
       c59Z0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59YZ() //  [R1]
         { info_tbl: [(c59YZ,
                       label: block_c59YZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59YZ: // global
           I64[Sp] = block_c59Z5_info;
           _s59Cu::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s59Cu::P64;
           if (R1 & 7 != 0) goto u59Zq; else goto c59Z6;
       u59Zq: // global
           call _c59Z5(R1) args: 0, res: 0, upd: 0;
       c59Z6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Z5() //  [R1]
         { info_tbl: [(c59Z5,
                       label: block_c59Z5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Z5: // global
           I64[Sp] = block_c59Za_info;
           _s59Cw::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s59Cw::P64;
           if (R1 & 7 != 0) goto u59Zs; else goto c59Zb;
       u59Zs: // global
           call _c59Za(R1) args: 0, res: 0, upd: 0;
       c59Zb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Za() //  [R1]
         { info_tbl: [(c59Za,
                       label: block_c59Za_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Za: // global
           _s59Cw::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c59Zf_info;
           R5 = R1;
           R4 = _s59Cw::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Coercion.$w$cenumFromThenTo_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _c59Zf() //  [R1, R2]
         { info_tbl: [(c59Zf,
                       label: block_c59Zf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Zf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c59Zp; else goto c59Zo;
       c59Zp: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c59Zo: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.375275965 UTC

[section ""data" . lvl2_r59Bd_closure" {
     lvl2_r59Bd_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.376192143 UTC

[section ""data" . lvl3_r59Be_closure" {
     lvl3_r59Be_closure:
         const lvl3_r59Be_info;
 },
 lvl3_r59Be_entry() //  [R2]
         { info_tbl: [(c59ZA,
                       label: lvl3_r59Be_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59ZA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c59ZB; else goto c59ZC;
       c59ZB: // global
           R2 = R2;
           R1 = lvl3_r59Be_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c59ZC: // global
           I64[Sp - 8] = block_c59Zx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u59ZG; else goto c59Zy;
       u59ZG: // global
           call _c59Zx() args: 0, res: 0, upd: 0;
       c59Zy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59Zx() //  []
         { info_tbl: [(c59Zx,
                       label: block_c59Zx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59Zx: // global
           R1 = lvl2_r59Bd_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.377465593 UTC

[section ""data" . lvl4_r59Bf_closure" {
     lvl4_r59Bf_closure:
         const lvl4_r59Bf_info;
         const 0;
 },
 lvl4_r59Bf_entry() //  [R2]
         { info_tbl: [(c59ZO,
                       label: lvl4_r59Bf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59ZO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c59ZP; else goto c59ZQ;
       c59ZP: // global
           R2 = R2;
           R1 = lvl4_r59Bf_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c59ZQ: // global
           I64[Sp - 8] = block_c59ZL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u59ZU; else goto c59ZM;
       u59ZU: // global
           call _c59ZL() args: 0, res: 0, upd: 0;
       c59ZM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c59ZL() //  []
         { info_tbl: [(c59ZL,
                       label: block_c59ZL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c59ZL: // global
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.379342797 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_closure" {
     Data.Type.Coercion.$fEnumCoercion_closure:
         const Data.Type.Coercion.$fEnumCoercion_info;
         const 0;
 },
 sat_s59CO_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c5a04,
                       label: sat_s59CO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a04: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59CN_entry() //  [R1, R2, R3]
         { info_tbl: [(c5a0c,
                       label: sat_s59CN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a0c: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59CM_entry() //  [R1, R2, R3]
         { info_tbl: [(c5a0k,
                       label: sat_s59CM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a0k: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59CL_entry() //  [R1, R2]
         { info_tbl: [(c5a0s,
                       label: sat_s59CL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a0s: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Coercion.$fEnumCoercion_$cenumFrom_entry(R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59CK_entry() //  [R1, R2]
         { info_tbl: [(c5a0A,
                       label: sat_s59CK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a0A: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Coercion.$fEnumCoercion_$ctoEnum_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$fEnumCoercion_entry() //  [R2]
         { info_tbl: [(c5a0E,
                       label: Data.Type.Coercion.$fEnumCoercion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a0E: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto c5a0I; else goto c5a0H;
       c5a0I: // global
           HpAlloc = 152;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5a0H: // global
           I64[Hp - 144] = sat_s59CO_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s59CN_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s59CM_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s59CL_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s59CK_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = lvl4_r59Bf_closure+1;
           P64[Hp - 48] = lvl4_r59Bf_closure+1;
           P64[Hp - 40] = Hp - 79;
           P64[Hp - 32] = lvl3_r59Be_closure+1;
           P64[Hp - 24] = Hp - 95;
           P64[Hp - 16] = Hp - 110;
           P64[Hp - 8] = Hp - 126;
           P64[Hp] = Hp - 141;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.381790463 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_closure" {
     Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_closure:
         const Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_info;
 },
 Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(c5a0Q,
                       label: Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a0Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5a11; else goto c5a12;
       c5a11: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5a12: // global
           I64[Sp - 16] = block_c5a0N_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5a18; else goto c5a0O;
       u5a18: // global
           call _c5a0N() args: 0, res: 0, upd: 0;
       c5a0O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a0N() //  []
         { info_tbl: [(c5a0N,
                       label: block_c5a0N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a0N: // global
           _s59CQ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5a0T_info;
           R1 = _s59CQ::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5a17; else goto c5a0U;
       u5a17: // global
           call _c5a0T(R1) args: 0, res: 0, upd: 0;
       c5a0U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a0T() //  [R1]
         { info_tbl: [(c5a0T,
                       label: block_c5a0T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a0T: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c5a16; else goto c5a15;
       c5a16: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5a15: // global
           I64[Hp - 40] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = Hp - 39;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.383389858 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionk:~:_closure" {
     Data.Type.Coercion.$fTestCoercionk:~:_closure:
         const Data.Type.Coercion.$fTestCoercionk:~:_info;
 },
 Data.Type.Coercion.$fTestCoercionk:~:_entry() //  [R2, R3]
         { info_tbl: [(c5a1d,
                       label: Data.Type.Coercion.$fTestCoercionk:~:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a1d: // global
           R3 = R3;
           R2 = R2;
           call Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_entry(R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.384523783 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_closure" {
     Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_closure:
         const Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_info;
 },
 Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(c5a1n,
                       label: Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a1n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5a1y; else goto c5a1z;
       c5a1y: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5a1z: // global
           I64[Sp - 16] = block_c5a1k_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5a1F; else goto c5a1l;
       u5a1F: // global
           call _c5a1k() args: 0, res: 0, upd: 0;
       c5a1l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a1k() //  []
         { info_tbl: [(c5a1k,
                       label: block_c5a1k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a1k: // global
           _s59CW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5a1q_info;
           R1 = _s59CW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5a1E; else goto c5a1r;
       u5a1E: // global
           call _c5a1q(R1) args: 0, res: 0, upd: 0;
       c5a1r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a1q() //  [R1]
         { info_tbl: [(c5a1q,
                       label: block_c5a1q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a1q: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c5a1D; else goto c5a1C;
       c5a1D: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5a1C: // global
           I64[Hp - 40] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = Hp - 39;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.386089059 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionk:~~:_closure" {
     Data.Type.Coercion.$fTestCoercionk:~~:_closure:
         const Data.Type.Coercion.$fTestCoercionk:~~:_info;
 },
 Data.Type.Coercion.$fTestCoercionk:~~:_entry() //  [R2, R3]
         { info_tbl: [(c5a1K,
                       label: Data.Type.Coercion.$fTestCoercionk:~~:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a1K: // global
           R3 = R3;
           R2 = R2;
           call Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_entry(R3,
                                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.387286773 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_closure" {
     Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_closure:
         const Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_info;
 },
 Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(c5a1U,
                       label: Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a1U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5a29; else goto c5a2a;
       c5a29: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5a2a: // global
           I64[Sp - 16] = block_c5a1R_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5a2i; else goto c5a1S;
       u5a2i: // global
           call _c5a1R(R1) args: 0, res: 0, upd: 0;
       c5a1S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a1R() //  [R1]
         { info_tbl: [(c5a1R,
                       label: block_c5a1R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a1R: // global
           I64[Sp] = block_c5a1X_info;
           _s59D4::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s59D4::P64;
           if (R1 & 7 != 0) goto u5a2h; else goto c5a1Y;
       u5a2h: // global
           call _c5a1X(R1) args: 0, res: 0, upd: 0;
       c5a1Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a1X() //  [R1]
         { info_tbl: [(c5a1X,
                       label: block_c5a1X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a1X: // global
           I64[Sp] = block_c5a22_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 7];
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5a22() //  []
         { info_tbl: [(c5a22,
                       label: block_c5a22_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a22: // global
           _s59D6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5a24_info;
           R2 = _s59D6::P64;
           Sp = Sp + 8;
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5a24() //  []
         { info_tbl: [(c5a24,
                       label: block_c5a24_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a24: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c5a2g; else goto c5a2f;
       c5a2g: // global
           HpAlloc = 48;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5a2f: // global
           I64[Hp - 40] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = Hp - 39;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.389075688 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionkCoercion_closure" {
     Data.Type.Coercion.$fTestCoercionkCoercion_closure:
         const Data.Type.Coercion.$fTestCoercionkCoercion_info;
 },
 Data.Type.Coercion.$fTestCoercionkCoercion_entry() //  [R2, R3]
         { info_tbl: [(c5a2n,
                       label: Data.Type.Coercion.$fTestCoercionkCoercion_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a2n: // global
           R3 = R3;
           R2 = R2;
           call Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_entry(R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.390548466 UTC

[section ""data" . Data.Type.Coercion.$fEqCoercion_$c==_closure" {
     Data.Type.Coercion.$fEqCoercion_$c==_closure:
         const Data.Type.Coercion.$fEqCoercion_$c==_info;
 },
 Data.Type.Coercion.$fEqCoercion_$c==_entry() //  [R2, R3]
         { info_tbl: [(c5a2x,
                       label: Data.Type.Coercion.$fEqCoercion_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a2x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5a2B; else goto c5a2C;
       c5a2B: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEqCoercion_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5a2C: // global
           I64[Sp - 16] = block_c5a2u_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5a2K; else goto c5a2v;
       u5a2K: // global
           call _c5a2u() args: 0, res: 0, upd: 0;
       c5a2v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a2u() //  []
         { info_tbl: [(c5a2u,
                       label: block_c5a2u_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a2u: // global
           _s59Da::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5a2A_info;
           R1 = _s59Da::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5a2J; else goto c5a2E;
       u5a2J: // global
           call _c5a2A() args: 0, res: 0, upd: 0;
       c5a2E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a2A() //  []
         { info_tbl: [(c5a2A,
                       label: block_c5a2A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a2A: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.392017466 UTC

[section ""data" . Data.Type.Coercion.$fEqCoercion_$c/=_closure" {
     Data.Type.Coercion.$fEqCoercion_$c/=_closure:
         const Data.Type.Coercion.$fEqCoercion_$c/=_info;
 },
 Data.Type.Coercion.$fEqCoercion_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c5a2S,
                       label: Data.Type.Coercion.$fEqCoercion_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a2S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5a2W; else goto c5a2X;
       c5a2W: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEqCoercion_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5a2X: // global
           I64[Sp - 16] = block_c5a2P_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5a35; else goto c5a2Q;
       u5a35: // global
           call _c5a2P() args: 0, res: 0, upd: 0;
       c5a2Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a2P() //  []
         { info_tbl: [(c5a2P,
                       label: block_c5a2P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a2P: // global
           _s59Dg::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5a2V_info;
           R1 = _s59Dg::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5a34; else goto c5a2Z;
       u5a34: // global
           call _c5a2V() args: 0, res: 0, upd: 0;
       c5a2Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a2V() //  []
         { info_tbl: [(c5a2V,
                       label: block_c5a2V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a2V: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.394969791 UTC

[section ""data" . Data.Type.Coercion.$fEqCoercion_closure" {
     Data.Type.Coercion.$fEqCoercion_closure:
         const GHC.Classes.C:Eq_con_info;
         const Data.Type.Coercion.$fEqCoercion_$c==_closure+2;
         const Data.Type.Coercion.$fEqCoercion_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.395572102 UTC

[section ""cstring" . Data.Type.Coercion.$fReadCoercion3_bytes" {
     Data.Type.Coercion.$fReadCoercion3_bytes:
         I8[] [67,111,101,114,99,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.396381264 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion2_closure" {
     Data.Type.Coercion.$fReadCoercion2_closure:
         const Data.Type.Coercion.$fReadCoercion2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Coercion.$fReadCoercion2_entry() //  [R1]
         { info_tbl: [(c5a3c,
                       label: Data.Type.Coercion.$fReadCoercion2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a3c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5a3d; else goto c5a3e;
       c5a3d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5a3e: // global
           (_c5a39::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c5a39::I64 == 0) goto c5a3b; else goto c5a3a;
       c5a3b: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c5a3a: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c5a39::I64;
           R2 = Data.Type.Coercion.$fReadCoercion3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.397620977 UTC

[section ""data" . Data.Type.Coercion.$fShowCoercion_$cshowsPrec_closure" {
     Data.Type.Coercion.$fShowCoercion_$cshowsPrec_closure:
         const Data.Type.Coercion.$fShowCoercion_$cshowsPrec_info;
         const 0;
 },
 Data.Type.Coercion.$fShowCoercion_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c5a3m,
                       label: Data.Type.Coercion.$fShowCoercion_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a3m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5a3n; else goto c5a3o;
       c5a3n: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fShowCoercion_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c5a3o: // global
           I64[Sp - 16] = block_c5a3j_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5a3s; else goto c5a3k;
       u5a3s: // global
           call _c5a3j() args: 0, res: 0, upd: 0;
       c5a3k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a3j() //  []
         { info_tbl: [(c5a3j,
                       label: block_c5a3j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a3j: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Coercion.$fReadCoercion2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.398896519 UTC

[section ""data" . Data.Type.Coercion.$fShowCoercion_$cshow_closure" {
     Data.Type.Coercion.$fShowCoercion_$cshow_closure:
         const Data.Type.Coercion.$fShowCoercion_$cshow_info;
         const 0;
 },
 Data.Type.Coercion.$fShowCoercion_$cshow_entry() //  [R2]
         { info_tbl: [(c5a3A,
                       label: Data.Type.Coercion.$fShowCoercion_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a3A: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5a3B; else goto c5a3C;
       c5a3B: // global
           R2 = R2;
           R1 = Data.Type.Coercion.$fShowCoercion_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5a3C: // global
           I64[Sp - 8] = block_c5a3x_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5a3G; else goto c5a3y;
       u5a3G: // global
           call _c5a3x() args: 0, res: 0, upd: 0;
       c5a3y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a3x() //  []
         { info_tbl: [(c5a3x,
                       label: block_c5a3x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a3x: // global
           R1 = Data.Type.Coercion.$fReadCoercion2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.400115293 UTC

[section ""data" . Data.Type.Coercion.$fShowCoercion1_closure" {
     Data.Type.Coercion.$fShowCoercion1_closure:
         const Data.Type.Coercion.$fShowCoercion1_info;
         const 0;
 },
 Data.Type.Coercion.$fShowCoercion1_entry() //  [R2, R3]
         { info_tbl: [(c5a3O,
                       label: Data.Type.Coercion.$fShowCoercion1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a3O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5a3P; else goto c5a3Q;
       c5a3P: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fShowCoercion1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5a3Q: // global
           I64[Sp - 16] = block_c5a3L_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5a3U; else goto c5a3M;
       u5a3U: // global
           call _c5a3L() args: 0, res: 0, upd: 0;
       c5a3M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a3L() //  []
         { info_tbl: [(c5a3L,
                       label: block_c5a3L_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a3L: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Coercion.$fReadCoercion2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.401213697 UTC

[section ""data" . Data.Type.Coercion.$fShowCoercion_$cshowList_closure" {
     Data.Type.Coercion.$fShowCoercion_$cshowList_closure:
         const Data.Type.Coercion.$fShowCoercion_$cshowList_info;
         const 0;
 },
 Data.Type.Coercion.$fShowCoercion_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c5a3Z,
                       label: Data.Type.Coercion.$fShowCoercion_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a3Z: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Type.Coercion.$fShowCoercion1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.402002292 UTC

[section ""data" . Data.Type.Coercion.$fShowCoercion_closure" {
     Data.Type.Coercion.$fShowCoercion_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Type.Coercion.$fShowCoercion_$cshowsPrec_closure+3;
         const Data.Type.Coercion.$fShowCoercion_$cshow_closure+1;
         const Data.Type.Coercion.$fShowCoercion_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.402851239 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$c<_closure" {
     Data.Type.Coercion.$fOrdCoercion_$c<_closure:
         const Data.Type.Coercion.$fOrdCoercion_$c<_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$c<_entry() //  [R2, R3]
         { info_tbl: [(c5a49,
                       label: Data.Type.Coercion.$fOrdCoercion_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a49: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5a4d; else goto c5a4e;
       c5a4d: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5a4e: // global
           I64[Sp - 16] = block_c5a46_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5a4m; else goto c5a47;
       u5a4m: // global
           call _c5a46() args: 0, res: 0, upd: 0;
       c5a47: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a46() //  []
         { info_tbl: [(c5a46,
                       label: block_c5a46_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a46: // global
           _s59DA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5a4c_info;
           R1 = _s59DA::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5a4l; else goto c5a4g;
       u5a4l: // global
           call _c5a4c() args: 0, res: 0, upd: 0;
       c5a4g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a4c() //  []
         { info_tbl: [(c5a4c,
                       label: block_c5a4c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a4c: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.404312531 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$ccompare_closure" {
     Data.Type.Coercion.$fOrdCoercion_$ccompare_closure:
         const Data.Type.Coercion.$fOrdCoercion_$ccompare_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c5a4u,
                       label: Data.Type.Coercion.$fOrdCoercion_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a4u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5a4y; else goto c5a4z;
       c5a4y: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5a4z: // global
           I64[Sp - 16] = block_c5a4r_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5a4H; else goto c5a4s;
       u5a4H: // global
           call _c5a4r() args: 0, res: 0, upd: 0;
       c5a4s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a4r() //  []
         { info_tbl: [(c5a4r,
                       label: block_c5a4r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a4r: // global
           _s59DG::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5a4x_info;
           R1 = _s59DG::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5a4G; else goto c5a4B;
       u5a4G: // global
           call _c5a4x() args: 0, res: 0, upd: 0;
       c5a4B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a4x() //  []
         { info_tbl: [(c5a4x,
                       label: block_c5a4x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a4x: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.405777722 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$c<=_closure" {
     Data.Type.Coercion.$fOrdCoercion_$c<=_closure:
         const Data.Type.Coercion.$fOrdCoercion_$c<=_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c5a4P,
                       label: Data.Type.Coercion.$fOrdCoercion_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a4P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5a4T; else goto c5a4U;
       c5a4T: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5a4U: // global
           I64[Sp - 16] = block_c5a4M_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5a52; else goto c5a4N;
       u5a52: // global
           call _c5a4M() args: 0, res: 0, upd: 0;
       c5a4N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a4M() //  []
         { info_tbl: [(c5a4M,
                       label: block_c5a4M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a4M: // global
           _s59DL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5a4S_info;
           R1 = _s59DL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5a51; else goto c5a4W;
       u5a51: // global
           call _c5a4S() args: 0, res: 0, upd: 0;
       c5a4W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a4S() //  []
         { info_tbl: [(c5a4S,
                       label: block_c5a4S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a4S: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.40725609 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$cmax_closure" {
     Data.Type.Coercion.$fOrdCoercion_$cmax_closure:
         const Data.Type.Coercion.$fOrdCoercion_$cmax_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c5a5a,
                       label: Data.Type.Coercion.$fOrdCoercion_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a5a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5a5b; else goto c5a5c;
       c5a5b: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5a5c: // global
           I64[Sp - 16] = block_c5a57_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5a5g; else goto c5a58;
       u5a5g: // global
           call _c5a57() args: 0, res: 0, upd: 0;
       c5a58: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a57() //  []
         { info_tbl: [(c5a57,
                       label: block_c5a57_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a57: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.408459882 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$c>_closure" {
     Data.Type.Coercion.$fOrdCoercion_$c>_closure:
         const Data.Type.Coercion.$fOrdCoercion_$c>_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$c>_entry() //  [R2, R3]
         { info_tbl: [(c5a5o,
                       label: Data.Type.Coercion.$fOrdCoercion_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a5o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5a5s; else goto c5a5t;
       c5a5s: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5a5t: // global
           I64[Sp - 16] = block_c5a5l_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5a5B; else goto c5a5m;
       u5a5B: // global
           call _c5a5l() args: 0, res: 0, upd: 0;
       c5a5m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a5l() //  []
         { info_tbl: [(c5a5l,
                       label: block_c5a5l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a5l: // global
           _s59DV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5a5r_info;
           R1 = _s59DV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5a5A; else goto c5a5v;
       u5a5A: // global
           call _c5a5r() args: 0, res: 0, upd: 0;
       c5a5v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a5r() //  []
         { info_tbl: [(c5a5r,
                       label: block_c5a5r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a5r: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.410431152 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$cmin_closure" {
     Data.Type.Coercion.$fOrdCoercion_$cmin_closure:
         const Data.Type.Coercion.$fOrdCoercion_$cmin_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c5a5J,
                       label: Data.Type.Coercion.$fOrdCoercion_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a5J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5a5K; else goto c5a5L;
       c5a5K: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5a5L: // global
           I64[Sp - 16] = block_c5a5G_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5a5P; else goto c5a5H;
       u5a5P: // global
           call _c5a5G() args: 0, res: 0, upd: 0;
       c5a5H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a5G() //  []
         { info_tbl: [(c5a5G,
                       label: block_c5a5G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a5G: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.411920818 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_closure" {
     Data.Type.Coercion.$fOrdCoercion_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Type.Coercion.$fEqCoercion_closure+1;
         const Data.Type.Coercion.$fOrdCoercion_$ccompare_closure+2;
         const Data.Type.Coercion.$fOrdCoercion_$c<_closure+2;
         const Data.Type.Coercion.$fOrdCoercion_$c<=_closure+2;
         const Data.Type.Coercion.$fOrdCoercion_$c>_closure+2;
         const Data.Type.Coercion.$fEqCoercion_$c==_closure+2;
         const Data.Type.Coercion.$fOrdCoercion_$cmax_closure+2;
         const Data.Type.Coercion.$fOrdCoercion_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.412830856 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion_lexeme_closure" {
     Data.Type.Coercion.$fReadCoercion_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Type.Coercion.$fReadCoercion2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.414858791 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion1_closure" {
     Data.Type.Coercion.$fReadCoercion1_closure:
         const Data.Type.Coercion.$fReadCoercion1_info;
         const 0;
 },
 sat_s59Ec_entry() //  [R1]
         { info_tbl: [(c5a65,
                       label: sat_s59Ec_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a65: // global
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59Ef_entry() //  [R1, R2, R3]
         { info_tbl: [(c5a6b,
                       label: sat_s59Ef_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a6b: // global
           _s59Ea::P64 = R3;
           _s59E9::P64 = R2;
           _s59Ef::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c5a6c; else goto c5a6d;
       c5a6d: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5a6f; else goto c5a6e;
       c5a6f: // global
           HpAlloc = 24;
           goto c5a6c;
       c5a6c: // global
           R3 = _s59Ea::P64;
           R2 = _s59E9::P64;
           R1 = _s59Ef::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5a6e: // global
           _s59E8::P64 = P64[_s59Ef::P64 + 6];
           I64[Hp - 16] = sat_s59Ec_info;
           P64[Hp - 8] = _s59E8::P64;
           P64[Hp] = _s59Ea::P64;
           I64[Sp - 8] = block_c5a68_info;
           R3 = Hp - 15;
           R2 = Data.Type.Coercion.$fReadCoercion_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5a68() //  [R1]
         { info_tbl: [(c5a68,
                       label: block_c5a68_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a68: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5a6i; else goto c5a6h;
       c5a6i: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5a6h: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$fReadCoercion1_entry() //  [R2, R3, R4]
         { info_tbl: [(c5a6j,
                       label: Data.Type.Coercion.$fReadCoercion1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a6j: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c5a6n; else goto c5a6m;
       c5a6n: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fReadCoercion1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c5a6m: // global
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s59Ef_info;
           P64[Hp] = Hp - 23;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.418386079 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion_$creadsPrec_closure" {
     Data.Type.Coercion.$fReadCoercion_$creadsPrec_closure:
         const Data.Type.Coercion.$fReadCoercion_$creadsPrec_info;
         const 0;
 },
 sat_s59Ei_entry() //  [R1]
         { info_tbl: [(c5a6w,
                       label: sat_s59Ei_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a6w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5a6x; else goto c5a6y;
       c5a6x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5a6y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Coercion.$fReadCoercion1_entry(R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Coercion.$fReadCoercion_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c5a6z,
                       label: Data.Type.Coercion.$fReadCoercion_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a6z: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c5a6D; else goto c5a6C;
       c5a6D: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fReadCoercion_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5a6C: // global
           I64[Hp - 24] = sat_s59Ei_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.420779141 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion_$creadListPrec_closure" {
     Data.Type.Coercion.$fReadCoercion_$creadListPrec_closure:
         const Data.Type.Coercion.$fReadCoercion_$creadListPrec_info;
         const 0;
 },
 sat_s59Ek_entry() //  [R1, R2, R3]
         { info_tbl: [(c5a6N,
                       label: sat_s59Ek_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a6N: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Coercion.$fReadCoercion1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$fReadCoercion_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c5a6Q,
                       label: Data.Type.Coercion.$fReadCoercion_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a6Q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5a6U; else goto c5a6T;
       c5a6U: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Type.Coercion.$fReadCoercion_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5a6T: // global
           I64[Hp - 8] = sat_s59Ek_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.423216157 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion_$creadList_closure" {
     Data.Type.Coercion.$fReadCoercion_$creadList_closure:
         const Data.Type.Coercion.$fReadCoercion_$creadList_info;
         const 0;
 },
 sat_s59Em_entry() //  [R1, R2, R3]
         { info_tbl: [(c5a78,
                       label: sat_s59Em_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a78: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Coercion.$fReadCoercion1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59En_entry() //  [R1]
         { info_tbl: [(c5a7b,
                       label: sat_s59En_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a7b: // global
           _s59En::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c5a7c; else goto c5a7d;
       c5a7d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5a7f; else goto c5a7e;
       c5a7f: // global
           HpAlloc = 16;
           goto c5a7c;
       c5a7c: // global
           R1 = _s59En::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5a7e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s59En::P64;
           _s59El::P64 = P64[_s59En::P64 + 16];
           I64[Hp - 8] = sat_s59Em_info;
           P64[Hp] = _s59El::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Type.Coercion.$fReadCoercion_$creadList_entry() //  [R2]
         { info_tbl: [(c5a7g,
                       label: Data.Type.Coercion.$fReadCoercion_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a7g: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5a7k; else goto c5a7j;
       c5a7k: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Type.Coercion.$fReadCoercion_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5a7j: // global
           I64[Hp - 16] = sat_s59En_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.426667933 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion_closure" {
     Data.Type.Coercion.$fReadCoercion_closure:
         const Data.Type.Coercion.$fReadCoercion_info;
         const 0;
 },
 sat_s59Es_entry() //  [R1]
         { info_tbl: [(c5a7t,
                       label: sat_s59Es_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a7t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5a7u; else goto c5a7v;
       c5a7u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5a7v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Coercion.$fReadCoercion_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s59Er_entry() //  [R1, R2, R3]
         { info_tbl: [(c5a7B,
                       label: sat_s59Er_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a7B: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Coercion.$fReadCoercion1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59Eq_entry() //  [R1]
         { info_tbl: [(c5a7I,
                       label: sat_s59Eq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a7I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5a7J; else goto c5a7K;
       c5a7J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5a7K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Coercion.$fReadCoercion_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s59Ep_entry() //  [R1, R2]
         { info_tbl: [(c5a7Q,
                       label: sat_s59Ep_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a7Q: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Coercion.$fReadCoercion_$creadsPrec_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$fReadCoercion_entry() //  [R2]
         { info_tbl: [(c5a7U,
                       label: Data.Type.Coercion.$fReadCoercion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a7U: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c5a7Y; else goto c5a7X;
       c5a7Y: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Type.Coercion.$fReadCoercion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5a7X: // global
           I64[Hp - 112] = sat_s59Es_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s59Er_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s59Eq_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s59Ep_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 112;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.43012442 UTC

[section ""data" . Data.Type.Coercion.$fBoundedCoercion_closure" {
     Data.Type.Coercion.$fBoundedCoercion_closure:
         const Data.Type.Coercion.$fBoundedCoercion_info;
 },
 Data.Type.Coercion.$fBoundedCoercion_entry() //  [R2]
         { info_tbl: [(c5a85,
                       label: Data.Type.Coercion.$fBoundedCoercion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a85: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c5a89; else goto c5a88;
       c5a89: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Type.Coercion.$fBoundedCoercion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5a88: // global
           I64[Hp - 32] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           _c5a83::P64 = Hp - 31;
           P64[Hp - 8] = _c5a83::P64;
           P64[Hp] = _c5a83::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.431850043 UTC

[section ""data" . Data.Type.Coercion.coerceWith_closure" {
     Data.Type.Coercion.coerceWith_closure:
         const Data.Type.Coercion.coerceWith_info;
 },
 Data.Type.Coercion.coerceWith_entry() //  [R2, R3]
         { info_tbl: [(c5a8h,
                       label: Data.Type.Coercion.coerceWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a8h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5a8l; else goto c5a8m;
       c5a8l: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.coerceWith_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5a8m: // global
           I64[Sp - 16] = block_c5a8e_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5a8u; else goto c5a8f;
       u5a8u: // global
           call _c5a8e(R1) args: 0, res: 0, upd: 0;
       c5a8f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a8e() //  [R1]
         { info_tbl: [(c5a8e,
                       label: block_c5a8e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a8e: // global
           I64[Sp] = block_c5a8k_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto u5a8t; else goto c5a8o;
       u5a8t: // global
           call _c5a8k() args: 0, res: 0, upd: 0;
       c5a8o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a8k() //  []
         { info_tbl: [(c5a8k,
                       label: block_c5a8k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a8k: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.434048163 UTC

[section ""data" . Data.Type.Coercion.gcoerceWith_closure" {
     Data.Type.Coercion.gcoerceWith_closure:
         const Data.Type.Coercion.gcoerceWith_info;
 },
 Data.Type.Coercion.gcoerceWith_entry() //  [R2, R3]
         { info_tbl: [(c5a8C,
                       label: Data.Type.Coercion.gcoerceWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a8C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5a8D; else goto c5a8E;
       c5a8D: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.gcoerceWith_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5a8E: // global
           I64[Sp - 16] = block_c5a8z_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5a8I; else goto c5a8A;
       u5a8I: // global
           call _c5a8z(R1) args: 0, res: 0, upd: 0;
       c5a8A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a8z() //  [R1]
         { info_tbl: [(c5a8z,
                       label: block_c5a8z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a8z: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.436206168 UTC

[section ""data" . Data.Type.Coercion.sym_closure" {
     Data.Type.Coercion.sym_closure:
         const Data.Type.Coercion.sym_info;
 },
 Data.Type.Coercion.sym_entry() //  [R2]
         { info_tbl: [(c5a8Q,
                       label: Data.Type.Coercion.sym_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a8Q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5a8X; else goto c5a8Y;
       c5a8X: // global
           R2 = R2;
           R1 = Data.Type.Coercion.sym_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5a8Y: // global
           I64[Sp - 8] = block_c5a8N_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5a93; else goto c5a8O;
       u5a93: // global
           call _c5a8N(R1) args: 0, res: 0, upd: 0;
       c5a8O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a8N() //  [R1]
         { info_tbl: [(c5a8N,
                       label: block_c5a8N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a8N: // global
           I64[Sp] = block_c5a8T_info;
           R2 = P64[R1 + 7];
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5a8T() //  []
         { info_tbl: [(c5a8T,
                       label: block_c5a8T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a8T: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c5a92; else goto c5a91;
       c5a92: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5a91: // global
           I64[Hp - 24] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 8] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.438496089 UTC

[section ""data" . Data.Type.Coercion.trans_closure" {
     Data.Type.Coercion.trans_closure:
         const Data.Type.Coercion.trans_info;
 },
 Data.Type.Coercion.trans_entry() //  [R2, R3]
         { info_tbl: [(c5a9b,
                       label: Data.Type.Coercion.trans_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a9b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5a9p; else goto c5a9q;
       c5a9p: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.trans_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5a9q: // global
           I64[Sp - 16] = block_c5a98_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5a9x; else goto c5a99;
       u5a9x: // global
           call _c5a98(R1) args: 0, res: 0, upd: 0;
       c5a99: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a98() //  [R1]
         { info_tbl: [(c5a98,
                       label: block_c5a98_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a98: // global
           I64[Sp] = block_c5a9e_info;
           R2 = P64[R1 + 7];
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5a9e() //  []
         { info_tbl: [(c5a9e,
                       label: block_c5a9e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a9e: // global
           _s59EK::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5a9g_info;
           R1 = _s59EK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5a9y; else goto c5a9h;
       u5a9y: // global
           call _c5a9g(R1) args: 0, res: 0, upd: 0;
       c5a9h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a9g() //  [R1]
         { info_tbl: [(c5a9g,
                       label: block_c5a9g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a9g: // global
           I64[Sp] = block_c5a9l_info;
           R2 = P64[R1 + 7];
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5a9l() //  []
         { info_tbl: [(c5a9l,
                       label: block_c5a9l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a9l: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c5a9w; else goto c5a9v;
       c5a9w: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5a9v: // global
           I64[Hp - 24] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 8] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.441972121 UTC

[section ""data" . Data.Type.Coercion.repr_closure" {
     Data.Type.Coercion.repr_closure:
         const Data.Type.Coercion.repr_info;
 },
 Data.Type.Coercion.repr_entry() //  [R2]
         { info_tbl: [(c5a9G,
                       label: Data.Type.Coercion.repr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a9G: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5a9L; else goto c5a9M;
       c5a9L: // global
           R2 = R2;
           R1 = Data.Type.Coercion.repr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5a9M: // global
           I64[Sp - 8] = block_c5a9D_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5a9Q; else goto c5a9E;
       u5a9Q: // global
           call _c5a9D(R1) args: 0, res: 0, upd: 0;
       c5a9E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5a9D() //  [R1]
         { info_tbl: [(c5a9D,
                       label: block_c5a9D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a9D: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c5a9P; else goto c5a9O;
       c5a9P: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5a9O: // global
           I64[Hp - 24] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 8] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.443472394 UTC

[section ""cstring" . Data.Type.Coercion.$trModule4_bytes" {
     Data.Type.Coercion.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.444324521 UTC

[section ""data" . Data.Type.Coercion.$trModule3_closure" {
     Data.Type.Coercion.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Coercion.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.445207012 UTC

[section ""cstring" . Data.Type.Coercion.$trModule2_bytes" {
     Data.Type.Coercion.$trModule2_bytes:
         I8[] [68,97,116,97,46,84,121,112,101,46,67,111,101,114,99,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.446075678 UTC

[section ""data" . Data.Type.Coercion.$trModule1_closure" {
     Data.Type.Coercion.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Coercion.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.446882474 UTC

[section ""data" . Data.Type.Coercion.$trModule_closure" {
     Data.Type.Coercion.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Type.Coercion.$trModule3_closure+1;
         const Data.Type.Coercion.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.447800051 UTC

[section ""data" . $krep_r59Bg_closure" {
     $krep_r59Bg_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.44868699 UTC

[section ""data" . $krep1_r59Bh_closure" {
     $krep1_r59Bh_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.449528362 UTC

[section ""data" . $krep2_r59Bi_closure" {
     $krep2_r59Bi_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r59Bh_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.450126855 UTC

[section ""data" . Data.Type.Coercion.$tcCoercion1_closure" {
     Data.Type.Coercion.$tcCoercion1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r59Bh_closure+2;
         const $krep2_r59Bi_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.450704738 UTC

[section ""data" . Data.Type.Coercion.$tcTestCoercion1_closure" {
     Data.Type.Coercion.$tcTestCoercion1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r59Bi_closure+4;
         const $krep_r59Bg_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.451273931 UTC

[section ""data" . $krep3_r59Bj_closure" {
     $krep3_r59Bj_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.451845345 UTC

[section ""data" . $krep4_r59Bk_closure" {
     $krep4_r59Bk_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.452404829 UTC

[section ""data" . $krep5_r59Bl_closure" {
     $krep5_r59Bl_closure:
         const :_con_info;
         const $krep3_r59Bj_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.452968893 UTC

[section ""data" . $krep6_r59Bm_closure" {
     $krep6_r59Bm_closure:
         const :_con_info;
         const $krep4_r59Bk_closure+2;
         const $krep5_r59Bl_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.453595245 UTC

[section ""data" . $krep7_r59Bn_closure" {
     $krep7_r59Bn_closure:
         const :_con_info;
         const $krep1_r59Bh_closure+2;
         const $krep6_r59Bm_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.455637561 UTC

[section ""data" . $krep8_r59Bo_closure" {
     $krep8_r59Bo_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcCoercible_closure;
         const $krep7_r59Bn_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.456229861 UTC

[section ""data" . Data.Type.Coercion.$tcCoercion2_closure" {
     Data.Type.Coercion.$tcCoercion2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Coercion.$fReadCoercion3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.456807018 UTC

[section ""data" . Data.Type.Coercion.$tcCoercion_closure" {
     Data.Type.Coercion.$tcCoercion_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Coercion.$trModule_closure+1;
         const Data.Type.Coercion.$tcCoercion2_closure+1;
         const Data.Type.Coercion.$tcCoercion1_closure+4;
         const 14885566513674463733;
         const 8268940906925368652;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.457569083 UTC

[section ""data" . $krep9_r59Bp_closure" {
     $krep9_r59Bp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Type.Coercion.$tcCoercion_closure+1;
         const $krep7_r59Bn_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.458106028 UTC

[section ""data" . Data.Type.Coercion.$tc'Coercion1_closure" {
     Data.Type.Coercion.$tc'Coercion1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_r59Bo_closure+1;
         const $krep9_r59Bp_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.458660386 UTC

[section ""cstring" . Data.Type.Coercion.$tc'Coercion3_bytes" {
     Data.Type.Coercion.$tc'Coercion3_bytes:
         I8[] [39,67,111,101,114,99,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.459167444 UTC

[section ""data" . Data.Type.Coercion.$tc'Coercion2_closure" {
     Data.Type.Coercion.$tc'Coercion2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Coercion.$tc'Coercion3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.459715247 UTC

[section ""data" . Data.Type.Coercion.$tc'Coercion_closure" {
     Data.Type.Coercion.$tc'Coercion_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Coercion.$trModule_closure+1;
         const Data.Type.Coercion.$tc'Coercion2_closure+1;
         const Data.Type.Coercion.$tc'Coercion1_closure+4;
         const 16177208673276072700;
         const 13187043378465993605;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.460360802 UTC

[section ""cstring" . Data.Type.Coercion.$tcTestCoercion3_bytes" {
     Data.Type.Coercion.$tcTestCoercion3_bytes:
         I8[] [84,101,115,116,67,111,101,114,99,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.460898349 UTC

[section ""data" . Data.Type.Coercion.$tcTestCoercion2_closure" {
     Data.Type.Coercion.$tcTestCoercion2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Coercion.$tcTestCoercion3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.461508061 UTC

[section ""data" . Data.Type.Coercion.$tcTestCoercion_closure" {
     Data.Type.Coercion.$tcTestCoercion_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Coercion.$trModule_closure+1;
         const Data.Type.Coercion.$tcTestCoercion2_closure+1;
         const Data.Type.Coercion.$tcTestCoercion1_closure+4;
         const 14520160333183018944;
         const 2439357669602544154;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.462381488 UTC

[section ""data" . Data.Type.Coercion.Coercion_closure" {
     Data.Type.Coercion.Coercion_closure:
         const Data.Type.Coercion.Coercion_info;
 },
 Data.Type.Coercion.Coercion_entry() //  [R2]
         { info_tbl: [(c5a9W,
                       label: Data.Type.Coercion.Coercion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5a9W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5aa0; else goto c5a9Z;
       c5aa0: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Type.Coercion.Coercion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5a9Z: // global
           I64[Hp - 8] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.463274983 UTC

[Data.Type.Coercion.Coercion_con_entry() //  [R1]
         { info_tbl: [(c5aa1,
                       label: Data.Type.Coercion.Coercion_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,84,121,112,101,46,67,111,101,114,99,105,111,110,46,67,111,101,114,99,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aa1: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.463943951 UTC

[section ""relreadonly" . S59Fe_srt" {
     S59Fe_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Type.Coercion.$fEnumCoercion1_closure;
         const Data.Type.Coercion.$fEnumCoercion_$ctoEnum_closure;
         const Data.Type.Coercion.$w$cenumFromTo_closure;
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_closure;
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_closure;
         const lvl1_r59Bc_closure;
         const Data.Type.Coercion.$w$cenumFrom_closure;
         const Data.Type.Coercion.$fEnumCoercion_$cenumFrom_closure;
         const Data.Type.Coercion.$w$cenumFromThenTo_closure;
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_closure;
         const lvl4_r59Bf_closure;
         const Data.Type.Coercion.$fEnumCoercion_closure;
         const Data.Type.Coercion.$fReadCoercion2_closure;
         const Data.Type.Coercion.$fShowCoercion_$cshowsPrec_closure;
         const Data.Type.Coercion.$fShowCoercion_$cshow_closure;
         const Data.Type.Coercion.$fShowCoercion1_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Type.Coercion.$fReadCoercion_lexeme_closure;
         const GHC.Read.list3_closure;
         const Data.Type.Coercion.$fReadCoercion1_closure;
         const Data.Type.Coercion.$fReadCoercion_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Type.Coercion.$fReadCoercion_$creadListPrec_closure;
         const Data.Type.Coercion.$fReadCoercion_$creadList_closure;
         const Data.Type.Coercion.$fReadCoercion_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.464891146 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:00:06.466157151 UTC

[section ""data" . Data.Type.Coercion.testCoercion_closure" {
     Data.Type.Coercion.testCoercion_closure:
         const Data.Type.Coercion.testCoercion_info;
 },
 Data.Type.Coercion.testCoercion_entry() //  [R2]
         { info_tbl: [(c5aa7,
                       label: Data.Type.Coercion.testCoercion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aa7: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.469420646 UTC

[section ""cstring" . lvl_r59Bb_bytes" {
     lvl_r59Bb_bytes:
         I8[] [68,97,116,97,46,84,121,112,101,46,67,111,101,114,99,105,111,110,46,116,111,69,110,117,109,58,32,98,97,100,32,97,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.471385787 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion1_closure" {
     Data.Type.Coercion.$fEnumCoercion1_closure:
         const Data.Type.Coercion.$fEnumCoercion1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Coercion.$fEnumCoercion1_entry() //  [R1]
         { info_tbl: [(c5aan,
                       label: Data.Type.Coercion.$fEnumCoercion1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aan: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c5aao; else goto c5aap;
       c5aao: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5aap: // global
           (_c5aai::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c5aai::I64 == 0) goto c5aak; else goto c5aaj;
       c5aak: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c5aaj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c5aai::I64;
           I64[Sp - 24] = block_c5aal_info;
           R2 = lvl_r59Bb_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c5aal() //  [R1]
         { info_tbl: [(c5aal,
                       label: block_c5aal_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aal: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.477475248 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_$ctoEnum_closure" {
     Data.Type.Coercion.$fEnumCoercion_$ctoEnum_closure:
         const Data.Type.Coercion.$fEnumCoercion_$ctoEnum_info;
         const 0;
 },
 Data.Type.Coercion.$fEnumCoercion_$ctoEnum_entry() //  [R2, R3]
         { info_tbl: [(c5aaK,
                       label: Data.Type.Coercion.$fEnumCoercion_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aaK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aaL; else goto c5aaM;
       c5aaL: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_$ctoEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aaM: // global
           I64[Sp - 16] = block_c5aaH_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5aaZ; else goto c5aaI;
       u5aaZ: // global
           call _c5aaH(R1) args: 0, res: 0, upd: 0;
       c5aaI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aaH() //  [R1]
         { info_tbl: [(c5aaH,
                       label: block_c5aaH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aaH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5aaR; else goto c5aaQ;
       c5aaR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5aaQ: // global
           if (I64[R1 + 7] == 0) goto c5aaY; else goto c5aaU;
       c5aaY: // global
           I64[Hp - 8] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5aaU: // global
           Hp = Hp - 16;
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.484018518 UTC

[section ""data" . Data.Type.Coercion.$w$cenumFromTo_closure" {
     Data.Type.Coercion.$w$cenumFromTo_closure:
         const Data.Type.Coercion.$w$cenumFromTo_info;
         const 0;
 },
 sat_s59BI_entry() //  [R1]
         { info_tbl: [(c5abu,
                       label: sat_s59BI_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5abu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5abv; else goto c5abw;
       c5abv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5abw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s59BG::I64 = I64[R1 + 24];
           if (_s59BG::I64 != 0) goto c5abs; else goto c5abt;
       c5abs: // global
           R2 = _s59BG::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s59BC_entry(R2, R1) args: 24, res: 0, upd: 24;
       c5abt: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s59BF_entry() //  [R1]
         { info_tbl: [(c5abH,
                       label: sat_s59BF_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5abH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5abI; else goto c5abJ;
       c5abI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5abJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 24] == 0) goto c5abG; else goto c5abF;
       c5abG: // global
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c5abF: // global
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s59BC_entry() //  [R1, R2]
         { info_tbl: [(c5abL,
                       label: go_s59BC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5abL: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c5abP; else goto c5abO;
       c5abP: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5abO: // global
           _s59BB::P64 = P64[R1 + 7];
           I64[Hp - 80] = sat_s59BI_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s59BF_info;
           P64[Hp - 32] = _s59BB::P64;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$w$cenumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c5abQ,
                       label: Data.Type.Coercion.$w$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5abQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c5abU; else goto c5abT;
       c5abU: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$w$cenumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c5abT: // global
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = go_s59BC_info;
           P64[Hp] = Hp - 23;
           R2 = 0;
           R1 = Hp - 7;
           call go_s59BC_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.495104807 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_closure" {
     Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_closure:
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_info;
         const 0;
 },
 Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(c5aco,
                       label: Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aco: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c5acs; else goto c5act;
       c5acs: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c5act: // global
           I64[Sp - 24] = block_c5acl_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u5acB; else goto c5acm;
       u5acB: // global
           call _c5acl(R1) args: 0, res: 0, upd: 0;
       c5acm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5acl() //  [R1]
         { info_tbl: [(c5acl,
                       label: block_c5acl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5acl: // global
           I64[Sp] = block_c5acr_info;
           _s59BM::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s59BM::P64;
           if (R1 & 7 != 0) goto u5acA; else goto c5acv;
       u5acA: // global
           call _c5acr(R1) args: 0, res: 0, upd: 0;
       c5acv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5acr() //  [R1]
         { info_tbl: [(c5acr,
                       label: block_c5acr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5acr: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Coercion.$w$cenumFromTo_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.502325702 UTC

[section ""data" . lvl1_r59Bc_closure" {
     lvl1_r59Bc_closure:
         const lvl1_r59Bc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r59Bc_entry() //  [R1]
         { info_tbl: [(c5acV,
                       label: lvl1_r59Bc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5acV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5acW; else goto c5acX;
       c5acW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5acX: // global
           (_c5acS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c5acS::I64 == 0) goto c5acU; else goto c5acT;
       c5acU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c5acT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c5acS::I64;
           R3 = 0;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.Enum.efdInt_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.506672832 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_closure" {
     Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_closure:
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_info;
         const 0;
 },
 sat_s59BX_entry() //  [R1, R2]
         { info_tbl: [(c5ado,
                       label: sat_s59BX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ado: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Coercion.$fEnumCoercion_$ctoEnum_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(c5adr,
                       label: Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5adr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c5ads; else goto c5adt;
       c5ads: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c5adt: // global
           I64[Sp - 24] = block_c5ad9_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u5adz; else goto c5ada;
       u5adz: // global
           call _c5ad9() args: 0, res: 0, upd: 0;
       c5ada: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5ad9() //  []
         { info_tbl: [(c5ad9,
                       label: block_c5ad9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ad9: // global
           I64[Sp] = block_c5ade_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u5ady; else goto c5adf;
       u5ady: // global
           call _c5ade(R1) args: 0, res: 0, upd: 0;
       c5adf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5ade() //  [R1]
         { info_tbl: [(c5ade,
                       label: block_c5ade_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ade: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5adx; else goto c5adw;
       c5adx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5adw: // global
           I64[Hp - 8] = sat_s59BX_info;
           P64[Hp] = P64[Sp + 8];
           R3 = lvl1_r59Bc_closure;
           R2 = Hp - 7;
           Sp = Sp + 24;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.516265918 UTC

[section ""data" . Data.Type.Coercion.$w$cenumFrom_closure" {
     Data.Type.Coercion.$w$cenumFrom_closure:
         const Data.Type.Coercion.$w$cenumFrom_info;
         const 0;
 },
 sat_s59C7_entry() //  [R1]
         { info_tbl: [(c5ae9,
                       label: sat_s59C7_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ae9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aea; else goto c5aeb;
       c5aea: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5aeb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s59C5::I64 = I64[R1 + 24];
           if (_s59C5::I64 != 9223372036854775807) goto c5ae7; else goto c5ae8;
       c5ae7: // global
           R2 = _s59C5::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s59C1_entry(R2, R1) args: 24, res: 0, upd: 24;
       c5ae8: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s59C4_entry() //  [R1]
         { info_tbl: [(c5aem,
                       label: sat_s59C4_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aem: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aen; else goto c5aeo;
       c5aen: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5aeo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 24] == 0) goto c5ael; else goto c5aek;
       c5ael: // global
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c5aek: // global
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s59C1_entry() //  [R1, R2]
         { info_tbl: [(c5aeq,
                       label: go_s59C1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aeq: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c5aeu; else goto c5aet;
       c5aeu: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5aet: // global
           _s59C0::P64 = P64[R1 + 7];
           I64[Hp - 80] = sat_s59C7_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s59C4_info;
           P64[Hp - 32] = _s59C0::P64;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$w$cenumFrom_entry() //  [R2, R3]
         { info_tbl: [(c5aev,
                       label: Data.Type.Coercion.$w$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aev: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c5aez; else goto c5aey;
       c5aez: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$w$cenumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aey: // global
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = go_s59C1_info;
           P64[Hp] = Hp - 23;
           R2 = 0;
           R1 = Hp - 7;
           call go_s59C1_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.527783433 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_$cenumFrom_closure" {
     Data.Type.Coercion.$fEnumCoercion_$cenumFrom_closure:
         const Data.Type.Coercion.$fEnumCoercion_$cenumFrom_info;
         const 0;
 },
 Data.Type.Coercion.$fEnumCoercion_$cenumFrom_entry() //  [R2, R3]
         { info_tbl: [(c5af4,
                       label: Data.Type.Coercion.$fEnumCoercion_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5af4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5af5; else goto c5af6;
       c5af5: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_$cenumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5af6: // global
           I64[Sp - 16] = block_c5af1_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5afa; else goto c5af2;
       u5afa: // global
           call _c5af1(R1) args: 0, res: 0, upd: 0;
       c5af2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5af1() //  [R1]
         { info_tbl: [(c5af1,
                       label: block_c5af1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5af1: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Type.Coercion.$w$cenumFrom_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.534557297 UTC

[section ""data" . Data.Type.Coercion.$w$cenumFromThenTo_closure" {
     Data.Type.Coercion.$w$cenumFromThenTo_closure:
         const Data.Type.Coercion.$w$cenumFromThenTo_info;
         const 0;
 },
 sat_s59Cm_entry() //  [R1]
         { info_tbl: [(c5afF,
                       label: sat_s59Cm_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5afF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5afG; else goto c5afH;
       c5afG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5afH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s59Ch_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s59Cl_entry() //  [R1]
         { info_tbl: [(c5afQ,
                       label: sat_s59Cl_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5afQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5afR; else goto c5afS;
       c5afR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5afS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 24] == 0) goto c5afP; else goto c5afO;
       c5afP: // global
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c5afO: // global
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s59Co_entry() //  [R1]
         { info_tbl: [(c5ag2,
                       label: sat_s59Co_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ag2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5ag3; else goto c5ag4;
       c5ag3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5ag4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 24] == 0) goto c5ag1; else goto c5ag0;
       c5ag1: // global
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c5ag0: // global
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s59Ch_entry() //  [R1, R2]
         { info_tbl: [(c5ag8,
                       label: go_up_s59Ch_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ag8: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c5agc; else goto c5agb;
       c5agc: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5agb: // global
           _s59Cg::P64 = P64[R1 + 7];
           if (%MO_S_Le_W64(R2, 0)) goto c5ag6; else goto c5ag7;
       c5ag6: // global
           I64[Hp - 80] = sat_s59Cm_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s59Cl_info;
           P64[Hp - 32] = _s59Cg::P64;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5ag7: // global
           I64[Hp - 80] = sat_s59Co_info;
           P64[Hp - 64] = _s59Cg::P64;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c5age::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c5age::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59Cp_entry() //  [R1]
         { info_tbl: [(c5agf,
                       label: sat_s59Cp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5agf: // global
           _s59Cp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c5agg; else goto c5agh;
       c5agh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5agj; else goto c5agi;
       c5agj: // global
           HpAlloc = 16;
           goto c5agg;
       c5agg: // global
           R1 = _s59Cp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5agi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s59Cp::P64;
           _s59Cg::P64 = P64[_s59Cp::P64 + 16];
           I64[Hp - 8] = go_up_s59Ch_info;
           P64[Hp] = _s59Cg::P64;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call go_up_s59Ch_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Coercion.$w$cenumFromThenTo_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c5agk,
                       label: Data.Type.Coercion.$w$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5agk: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c5ago; else goto c5agn;
       c5ago: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$w$cenumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c5agn: // global
           I64[Hp - 32] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s59Cp_info;
           _c5afo::P64 = Hp - 31;
           P64[Hp] = _c5afo::P64;
           R2 = Hp - 16;
           R1 = _c5afo::P64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.551316654 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_closure" {
     Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_closure:
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_info;
         const 0;
 },
 Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(c5ah3,
                       label: Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ah3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c5ahj; else goto c5ahk;
       c5ahj: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c5ahk: // global
           I64[Sp - 32] = block_c5ah0_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u5ahs; else goto c5ah1;
       u5ahs: // global
           call _c5ah0(R1) args: 0, res: 0, upd: 0;
       c5ah1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5ah0() //  [R1]
         { info_tbl: [(c5ah0,
                       label: block_c5ah0_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ah0: // global
           I64[Sp] = block_c5ah6_info;
           _s59Cu::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s59Cu::P64;
           if (R1 & 7 != 0) goto u5ahr; else goto c5ah7;
       u5ahr: // global
           call _c5ah6(R1) args: 0, res: 0, upd: 0;
       c5ah7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5ah6() //  [R1]
         { info_tbl: [(c5ah6,
                       label: block_c5ah6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ah6: // global
           I64[Sp] = block_c5ahb_info;
           _s59Cw::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s59Cw::P64;
           if (R1 & 7 != 0) goto u5aht; else goto c5ahc;
       u5aht: // global
           call _c5ahb(R1) args: 0, res: 0, upd: 0;
       c5ahc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5ahb() //  [R1]
         { info_tbl: [(c5ahb,
                       label: block_c5ahb_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ahb: // global
           _s59Cw::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c5ahg_info;
           R5 = R1;
           R4 = _s59Cw::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Coercion.$w$cenumFromThenTo_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5ahg() //  [R1, R2]
         { info_tbl: [(c5ahg,
                       label: block_c5ahg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ahg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5ahq; else goto c5ahp;
       c5ahq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c5ahp: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.562527514 UTC

[section ""data" . lvl2_r59Bd_closure" {
     lvl2_r59Bd_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.56450504 UTC

[section ""data" . lvl3_r59Be_closure" {
     lvl3_r59Be_closure:
         const lvl3_r59Be_info;
 },
 lvl3_r59Be_entry() //  [R2]
         { info_tbl: [(c5ahX,
                       label: lvl3_r59Be_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ahX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5ahY; else goto c5ahZ;
       c5ahY: // global
           R2 = R2;
           R1 = lvl3_r59Be_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5ahZ: // global
           I64[Sp - 8] = block_c5ahU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5ai3; else goto c5ahV;
       u5ai3: // global
           call _c5ahU() args: 0, res: 0, upd: 0;
       c5ahV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5ahU() //  []
         { info_tbl: [(c5ahU,
                       label: block_c5ahU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ahU: // global
           R1 = lvl2_r59Bd_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.570522714 UTC

[section ""data" . lvl4_r59Bf_closure" {
     lvl4_r59Bf_closure:
         const lvl4_r59Bf_info;
         const 0;
 },
 lvl4_r59Bf_entry() //  [R2]
         { info_tbl: [(c5ail,
                       label: lvl4_r59Bf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ail: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5aim; else goto c5ain;
       c5aim: // global
           R2 = R2;
           R1 = lvl4_r59Bf_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5ain: // global
           I64[Sp - 8] = block_c5aii_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5air; else goto c5aij;
       u5air: // global
           call _c5aii() args: 0, res: 0, upd: 0;
       c5aij: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aii() //  []
         { info_tbl: [(c5aii,
                       label: block_c5aii_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aii: // global
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.576697176 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_closure" {
     Data.Type.Coercion.$fEnumCoercion_closure:
         const Data.Type.Coercion.$fEnumCoercion_info;
         const 0;
 },
 sat_s59CO_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c5aiL,
                       label: sat_s59CO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aiL: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59CN_entry() //  [R1, R2, R3]
         { info_tbl: [(c5aiT,
                       label: sat_s59CN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aiT: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59CM_entry() //  [R1, R2, R3]
         { info_tbl: [(c5aj1,
                       label: sat_s59CM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aj1: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59CL_entry() //  [R1, R2]
         { info_tbl: [(c5aj9,
                       label: sat_s59CL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aj9: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Coercion.$fEnumCoercion_$cenumFrom_entry(R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59CK_entry() //  [R1, R2]
         { info_tbl: [(c5ajh,
                       label: sat_s59CK_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ajh: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Coercion.$fEnumCoercion_$ctoEnum_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$fEnumCoercion_entry() //  [R2]
         { info_tbl: [(c5ajl,
                       label: Data.Type.Coercion.$fEnumCoercion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ajl: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto c5ajp; else goto c5ajo;
       c5ajp: // global
           HpAlloc = 152;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5ajo: // global
           I64[Hp - 144] = sat_s59CO_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s59CN_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s59CM_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s59CL_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s59CK_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = lvl4_r59Bf_closure+1;
           P64[Hp - 48] = lvl4_r59Bf_closure+1;
           P64[Hp - 40] = Hp - 79;
           P64[Hp - 32] = lvl3_r59Be_closure+1;
           P64[Hp - 24] = Hp - 95;
           P64[Hp - 16] = Hp - 110;
           P64[Hp - 8] = Hp - 126;
           P64[Hp] = Hp - 141;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.589167065 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_closure" {
     Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_closure:
         const Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_info;
 },
 Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(c5ajW,
                       label: Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ajW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5ak7; else goto c5ak8;
       c5ak7: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5ak8: // global
           I64[Sp - 16] = block_c5ajT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5ake; else goto c5ajU;
       u5ake: // global
           call _c5ajT() args: 0, res: 0, upd: 0;
       c5ajU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5ajT() //  []
         { info_tbl: [(c5ajT,
                       label: block_c5ajT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ajT: // global
           _s59CQ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5ajZ_info;
           R1 = _s59CQ::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5akd; else goto c5ak0;
       u5akd: // global
           call _c5ajZ(R1) args: 0, res: 0, upd: 0;
       c5ak0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5ajZ() //  [R1]
         { info_tbl: [(c5ajZ,
                       label: block_c5ajZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ajZ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c5akc; else goto c5akb;
       c5akc: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5akb: // global
           I64[Hp - 40] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = Hp - 39;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.597344122 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionk:~:_closure" {
     Data.Type.Coercion.$fTestCoercionk:~:_closure:
         const Data.Type.Coercion.$fTestCoercionk:~:_info;
 },
 Data.Type.Coercion.$fTestCoercionk:~:_entry() //  [R2, R3]
         { info_tbl: [(c5akz,
                       label: Data.Type.Coercion.$fTestCoercionk:~:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5akz: // global
           R3 = R3;
           R2 = R2;
           call Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_entry(R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.600983313 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_closure" {
     Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_closure:
         const Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_info;
 },
 Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(c5akN,
                       label: Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5akN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5akY; else goto c5akZ;
       c5akY: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5akZ: // global
           I64[Sp - 16] = block_c5akK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5al5; else goto c5akL;
       u5al5: // global
           call _c5akK() args: 0, res: 0, upd: 0;
       c5akL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5akK() //  []
         { info_tbl: [(c5akK,
                       label: block_c5akK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5akK: // global
           _s59CW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5akQ_info;
           R1 = _s59CW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5al4; else goto c5akR;
       u5al4: // global
           call _c5akQ(R1) args: 0, res: 0, upd: 0;
       c5akR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5akQ() //  [R1]
         { info_tbl: [(c5akQ,
                       label: block_c5akQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5akQ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c5al3; else goto c5al2;
       c5al3: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5al2: // global
           I64[Hp - 40] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = Hp - 39;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.60940876 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionk:~~:_closure" {
     Data.Type.Coercion.$fTestCoercionk:~~:_closure:
         const Data.Type.Coercion.$fTestCoercionk:~~:_info;
 },
 Data.Type.Coercion.$fTestCoercionk:~~:_entry() //  [R2, R3]
         { info_tbl: [(c5alq,
                       label: Data.Type.Coercion.$fTestCoercionk:~~:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5alq: // global
           R3 = R3;
           R2 = R2;
           call Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_entry(R3,
                                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.613230264 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_closure" {
     Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_closure:
         const Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_info;
 },
 Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(c5alE,
                       label: Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5alE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5alT; else goto c5alU;
       c5alT: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5alU: // global
           I64[Sp - 16] = block_c5alB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5am2; else goto c5alC;
       u5am2: // global
           call _c5alB(R1) args: 0, res: 0, upd: 0;
       c5alC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5alB() //  [R1]
         { info_tbl: [(c5alB,
                       label: block_c5alB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5alB: // global
           I64[Sp] = block_c5alH_info;
           _s59D4::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s59D4::P64;
           if (R1 & 7 != 0) goto u5am1; else goto c5alI;
       u5am1: // global
           call _c5alH(R1) args: 0, res: 0, upd: 0;
       c5alI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5alH() //  [R1]
         { info_tbl: [(c5alH,
                       label: block_c5alH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5alH: // global
           I64[Sp] = block_c5alM_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 7];
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5alM() //  []
         { info_tbl: [(c5alM,
                       label: block_c5alM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5alM: // global
           _s59D6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5alO_info;
           R2 = _s59D6::P64;
           Sp = Sp + 8;
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5alO() //  []
         { info_tbl: [(c5alO,
                       label: block_c5alO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5alO: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c5am0; else goto c5alZ;
       c5am0: // global
           HpAlloc = 48;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5alZ: // global
           I64[Hp - 40] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = Hp - 39;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.624141195 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionkCoercion_closure" {
     Data.Type.Coercion.$fTestCoercionkCoercion_closure:
         const Data.Type.Coercion.$fTestCoercionkCoercion_info;
 },
 Data.Type.Coercion.$fTestCoercionkCoercion_entry() //  [R2, R3]
         { info_tbl: [(c5amu,
                       label: Data.Type.Coercion.$fTestCoercionkCoercion_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5amu: // global
           R3 = R3;
           R2 = R2;
           call Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_entry(R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.627812591 UTC

[section ""data" . Data.Type.Coercion.$fEqCoercion_$c==_closure" {
     Data.Type.Coercion.$fEqCoercion_$c==_closure:
         const Data.Type.Coercion.$fEqCoercion_$c==_info;
 },
 Data.Type.Coercion.$fEqCoercion_$c==_entry() //  [R2, R3]
         { info_tbl: [(c5amI,
                       label: Data.Type.Coercion.$fEqCoercion_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5amI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5amM; else goto c5amN;
       c5amM: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEqCoercion_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5amN: // global
           I64[Sp - 16] = block_c5amF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5amV; else goto c5amG;
       u5amV: // global
           call _c5amF() args: 0, res: 0, upd: 0;
       c5amG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5amF() //  []
         { info_tbl: [(c5amF,
                       label: block_c5amF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5amF: // global
           _s59Da::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5amL_info;
           R1 = _s59Da::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5amU; else goto c5amP;
       u5amU: // global
           call _c5amL() args: 0, res: 0, upd: 0;
       c5amP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5amL() //  []
         { info_tbl: [(c5amL,
                       label: block_c5amL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5amL: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.635547326 UTC

[section ""data" . Data.Type.Coercion.$fEqCoercion_$c/=_closure" {
     Data.Type.Coercion.$fEqCoercion_$c/=_closure:
         const Data.Type.Coercion.$fEqCoercion_$c/=_info;
 },
 Data.Type.Coercion.$fEqCoercion_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c5anh,
                       label: Data.Type.Coercion.$fEqCoercion_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5anh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5anl; else goto c5anm;
       c5anl: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEqCoercion_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5anm: // global
           I64[Sp - 16] = block_c5ane_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5anu; else goto c5anf;
       u5anu: // global
           call _c5ane() args: 0, res: 0, upd: 0;
       c5anf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5ane() //  []
         { info_tbl: [(c5ane,
                       label: block_c5ane_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ane: // global
           _s59Dg::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5ank_info;
           R1 = _s59Dg::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5ant; else goto c5ano;
       u5ant: // global
           call _c5ank() args: 0, res: 0, upd: 0;
       c5ano: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5ank() //  []
         { info_tbl: [(c5ank,
                       label: block_c5ank_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ank: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.6431835 UTC

[section ""data" . Data.Type.Coercion.$fEqCoercion_closure" {
     Data.Type.Coercion.$fEqCoercion_closure:
         const GHC.Classes.C:Eq_con_info;
         const Data.Type.Coercion.$fEqCoercion_$c==_closure+2;
         const Data.Type.Coercion.$fEqCoercion_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.644812762 UTC

[section ""cstring" . Data.Type.Coercion.$fReadCoercion3_bytes" {
     Data.Type.Coercion.$fReadCoercion3_bytes:
         I8[] [67,111,101,114,99,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.647154146 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion2_closure" {
     Data.Type.Coercion.$fReadCoercion2_closure:
         const Data.Type.Coercion.$fReadCoercion2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Coercion.$fReadCoercion2_entry() //  [R1]
         { info_tbl: [(c5anR,
                       label: Data.Type.Coercion.$fReadCoercion2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5anR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5anS; else goto c5anT;
       c5anS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5anT: // global
           (_c5anO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c5anO::I64 == 0) goto c5anQ; else goto c5anP;
       c5anQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c5anP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c5anO::I64;
           R2 = Data.Type.Coercion.$fReadCoercion3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.651366746 UTC

[section ""data" . Data.Type.Coercion.$fShowCoercion_$cshowsPrec_closure" {
     Data.Type.Coercion.$fShowCoercion_$cshowsPrec_closure:
         const Data.Type.Coercion.$fShowCoercion_$cshowsPrec_info;
         const 0;
 },
 Data.Type.Coercion.$fShowCoercion_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c5ao8,
                       label: Data.Type.Coercion.$fShowCoercion_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ao8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5ao9; else goto c5aoa;
       c5ao9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fShowCoercion_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aoa: // global
           I64[Sp - 16] = block_c5ao5_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5aoe; else goto c5ao6;
       u5aoe: // global
           call _c5ao5() args: 0, res: 0, upd: 0;
       c5ao6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5ao5() //  []
         { info_tbl: [(c5ao5,
                       label: block_c5ao5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ao5: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Coercion.$fReadCoercion2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.657006787 UTC

[section ""data" . Data.Type.Coercion.$fShowCoercion_$cshow_closure" {
     Data.Type.Coercion.$fShowCoercion_$cshow_closure:
         const Data.Type.Coercion.$fShowCoercion_$cshow_info;
         const 0;
 },
 Data.Type.Coercion.$fShowCoercion_$cshow_entry() //  [R2]
         { info_tbl: [(c5aov,
                       label: Data.Type.Coercion.$fShowCoercion_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aov: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5aow; else goto c5aox;
       c5aow: // global
           R2 = R2;
           R1 = Data.Type.Coercion.$fShowCoercion_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5aox: // global
           I64[Sp - 8] = block_c5aos_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5aoB; else goto c5aot;
       u5aoB: // global
           call _c5aos() args: 0, res: 0, upd: 0;
       c5aot: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aos() //  []
         { info_tbl: [(c5aos,
                       label: block_c5aos_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aos: // global
           R1 = Data.Type.Coercion.$fReadCoercion2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.662819068 UTC

[section ""data" . Data.Type.Coercion.$fShowCoercion1_closure" {
     Data.Type.Coercion.$fShowCoercion1_closure:
         const Data.Type.Coercion.$fShowCoercion1_info;
         const 0;
 },
 Data.Type.Coercion.$fShowCoercion1_entry() //  [R2, R3]
         { info_tbl: [(c5aoT,
                       label: Data.Type.Coercion.$fShowCoercion1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aoT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aoU; else goto c5aoV;
       c5aoU: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fShowCoercion1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aoV: // global
           I64[Sp - 16] = block_c5aoQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5aoZ; else goto c5aoR;
       u5aoZ: // global
           call _c5aoQ() args: 0, res: 0, upd: 0;
       c5aoR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aoQ() //  []
         { info_tbl: [(c5aoQ,
                       label: block_c5aoQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aoQ: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Coercion.$fReadCoercion2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.668017147 UTC

[section ""data" . Data.Type.Coercion.$fShowCoercion_$cshowList_closure" {
     Data.Type.Coercion.$fShowCoercion_$cshowList_closure:
         const Data.Type.Coercion.$fShowCoercion_$cshowList_info;
         const 0;
 },
 Data.Type.Coercion.$fShowCoercion_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c5apd,
                       label: Data.Type.Coercion.$fShowCoercion_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5apd: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Type.Coercion.$fShowCoercion1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.671255114 UTC

[section ""data" . Data.Type.Coercion.$fShowCoercion_closure" {
     Data.Type.Coercion.$fShowCoercion_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Type.Coercion.$fShowCoercion_$cshowsPrec_closure+3;
         const Data.Type.Coercion.$fShowCoercion_$cshow_closure+1;
         const Data.Type.Coercion.$fShowCoercion_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.673910294 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$c<_closure" {
     Data.Type.Coercion.$fOrdCoercion_$c<_closure:
         const Data.Type.Coercion.$fOrdCoercion_$c<_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$c<_entry() //  [R2, R3]
         { info_tbl: [(c5aps,
                       label: Data.Type.Coercion.$fOrdCoercion_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aps: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5apw; else goto c5apx;
       c5apw: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5apx: // global
           I64[Sp - 16] = block_c5app_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5apF; else goto c5apq;
       u5apF: // global
           call _c5app() args: 0, res: 0, upd: 0;
       c5apq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5app() //  []
         { info_tbl: [(c5app,
                       label: block_c5app_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5app: // global
           _s59DA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5apv_info;
           R1 = _s59DA::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5apE; else goto c5apz;
       u5apE: // global
           call _c5apv() args: 0, res: 0, upd: 0;
       c5apz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5apv() //  []
         { info_tbl: [(c5apv,
                       label: block_c5apv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5apv: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.681069592 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$ccompare_closure" {
     Data.Type.Coercion.$fOrdCoercion_$ccompare_closure:
         const Data.Type.Coercion.$fOrdCoercion_$ccompare_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c5aq1,
                       label: Data.Type.Coercion.$fOrdCoercion_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aq1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aq5; else goto c5aq6;
       c5aq5: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aq6: // global
           I64[Sp - 16] = block_c5apY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5aqe; else goto c5apZ;
       u5aqe: // global
           call _c5apY() args: 0, res: 0, upd: 0;
       c5apZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5apY() //  []
         { info_tbl: [(c5apY,
                       label: block_c5apY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5apY: // global
           _s59DG::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5aq4_info;
           R1 = _s59DG::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5aqd; else goto c5aq8;
       u5aqd: // global
           call _c5aq4() args: 0, res: 0, upd: 0;
       c5aq8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aq4() //  []
         { info_tbl: [(c5aq4,
                       label: block_c5aq4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aq4: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.688953006 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$c<=_closure" {
     Data.Type.Coercion.$fOrdCoercion_$c<=_closure:
         const Data.Type.Coercion.$fOrdCoercion_$c<=_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c5aqA,
                       label: Data.Type.Coercion.$fOrdCoercion_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aqA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aqE; else goto c5aqF;
       c5aqE: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aqF: // global
           I64[Sp - 16] = block_c5aqx_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5aqN; else goto c5aqy;
       u5aqN: // global
           call _c5aqx() args: 0, res: 0, upd: 0;
       c5aqy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aqx() //  []
         { info_tbl: [(c5aqx,
                       label: block_c5aqx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aqx: // global
           _s59DL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5aqD_info;
           R1 = _s59DL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5aqM; else goto c5aqH;
       u5aqM: // global
           call _c5aqD() args: 0, res: 0, upd: 0;
       c5aqH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aqD() //  []
         { info_tbl: [(c5aqD,
                       label: block_c5aqD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aqD: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.696390834 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$cmax_closure" {
     Data.Type.Coercion.$fOrdCoercion_$cmax_closure:
         const Data.Type.Coercion.$fOrdCoercion_$cmax_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c5ar9,
                       label: Data.Type.Coercion.$fOrdCoercion_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ar9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5ara; else goto c5arb;
       c5ara: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5arb: // global
           I64[Sp - 16] = block_c5ar6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5arf; else goto c5ar7;
       u5arf: // global
           call _c5ar6() args: 0, res: 0, upd: 0;
       c5ar7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5ar6() //  []
         { info_tbl: [(c5ar6,
                       label: block_c5ar6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ar6: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.702466052 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$c>_closure" {
     Data.Type.Coercion.$fOrdCoercion_$c>_closure:
         const Data.Type.Coercion.$fOrdCoercion_$c>_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$c>_entry() //  [R2, R3]
         { info_tbl: [(c5ary,
                       label: Data.Type.Coercion.$fOrdCoercion_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ary: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5arC; else goto c5arD;
       c5arC: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5arD: // global
           I64[Sp - 16] = block_c5arv_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5arL; else goto c5arw;
       u5arL: // global
           call _c5arv() args: 0, res: 0, upd: 0;
       c5arw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5arv() //  []
         { info_tbl: [(c5arv,
                       label: block_c5arv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5arv: // global
           _s59DV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5arB_info;
           R1 = _s59DV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5arK; else goto c5arF;
       u5arK: // global
           call _c5arB() args: 0, res: 0, upd: 0;
       c5arF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5arB() //  []
         { info_tbl: [(c5arB,
                       label: block_c5arB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5arB: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.710469418 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$cmin_closure" {
     Data.Type.Coercion.$fOrdCoercion_$cmin_closure:
         const Data.Type.Coercion.$fOrdCoercion_$cmin_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c5as7,
                       label: Data.Type.Coercion.$fOrdCoercion_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5as7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5as8; else goto c5as9;
       c5as8: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5as9: // global
           I64[Sp - 16] = block_c5as4_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5asd; else goto c5as5;
       u5asd: // global
           call _c5as4() args: 0, res: 0, upd: 0;
       c5as5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5as4() //  []
         { info_tbl: [(c5as4,
                       label: block_c5as4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5as4: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.71578946 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_closure" {
     Data.Type.Coercion.$fOrdCoercion_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Type.Coercion.$fEqCoercion_closure+1;
         const Data.Type.Coercion.$fOrdCoercion_$ccompare_closure+2;
         const Data.Type.Coercion.$fOrdCoercion_$c<_closure+2;
         const Data.Type.Coercion.$fOrdCoercion_$c<=_closure+2;
         const Data.Type.Coercion.$fOrdCoercion_$c>_closure+2;
         const Data.Type.Coercion.$fEqCoercion_$c==_closure+2;
         const Data.Type.Coercion.$fOrdCoercion_$cmax_closure+2;
         const Data.Type.Coercion.$fOrdCoercion_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.717637139 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion_lexeme_closure" {
     Data.Type.Coercion.$fReadCoercion_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Type.Coercion.$fReadCoercion2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.72019763 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion1_closure" {
     Data.Type.Coercion.$fReadCoercion1_closure:
         const Data.Type.Coercion.$fReadCoercion1_info;
         const 0;
 },
 sat_s59Ec_entry() //  [R1]
         { info_tbl: [(c5asG,
                       label: sat_s59Ec_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5asG: // global
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59Ef_entry() //  [R1, R2, R3]
         { info_tbl: [(c5asM,
                       label: sat_s59Ef_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5asM: // global
           _s59Ea::P64 = R3;
           _s59E9::P64 = R2;
           _s59Ef::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c5asN; else goto c5asO;
       c5asO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5asQ; else goto c5asP;
       c5asQ: // global
           HpAlloc = 24;
           goto c5asN;
       c5asN: // global
           R3 = _s59Ea::P64;
           R2 = _s59E9::P64;
           R1 = _s59Ef::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5asP: // global
           _s59E8::P64 = P64[_s59Ef::P64 + 6];
           I64[Hp - 16] = sat_s59Ec_info;
           P64[Hp - 8] = _s59E8::P64;
           P64[Hp] = _s59Ea::P64;
           I64[Sp - 8] = block_c5asJ_info;
           R3 = Hp - 15;
           R2 = Data.Type.Coercion.$fReadCoercion_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5asJ() //  [R1]
         { info_tbl: [(c5asJ,
                       label: block_c5asJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5asJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5asT; else goto c5asS;
       c5asT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5asS: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$fReadCoercion1_entry() //  [R2, R3, R4]
         { info_tbl: [(c5asU,
                       label: Data.Type.Coercion.$fReadCoercion1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5asU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c5asY; else goto c5asX;
       c5asY: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fReadCoercion1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c5asX: // global
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s59Ef_info;
           P64[Hp] = Hp - 23;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.730315095 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion_$creadsPrec_closure" {
     Data.Type.Coercion.$fReadCoercion_$creadsPrec_closure:
         const Data.Type.Coercion.$fReadCoercion_$creadsPrec_info;
         const 0;
 },
 sat_s59Ei_entry() //  [R1]
         { info_tbl: [(c5atn,
                       label: sat_s59Ei_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5atn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5ato; else goto c5atp;
       c5ato: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5atp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Coercion.$fReadCoercion1_entry(R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Coercion.$fReadCoercion_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c5atq,
                       label: Data.Type.Coercion.$fReadCoercion_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5atq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c5atu; else goto c5att;
       c5atu: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fReadCoercion_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5att: // global
           I64[Hp - 24] = sat_s59Ei_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.736828175 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion_$creadListPrec_closure" {
     Data.Type.Coercion.$fReadCoercion_$creadListPrec_closure:
         const Data.Type.Coercion.$fReadCoercion_$creadListPrec_info;
         const 0;
 },
 sat_s59Ek_entry() //  [R1, R2, R3]
         { info_tbl: [(c5atM,
                       label: sat_s59Ek_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5atM: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Coercion.$fReadCoercion1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$fReadCoercion_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c5atP,
                       label: Data.Type.Coercion.$fReadCoercion_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5atP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5atT; else goto c5atS;
       c5atT: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Type.Coercion.$fReadCoercion_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5atS: // global
           I64[Hp - 8] = sat_s59Ek_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.743356516 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion_$creadList_closure" {
     Data.Type.Coercion.$fReadCoercion_$creadList_closure:
         const Data.Type.Coercion.$fReadCoercion_$creadList_info;
         const 0;
 },
 sat_s59Em_entry() //  [R1, R2, R3]
         { info_tbl: [(c5aue,
                       label: sat_s59Em_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aue: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Coercion.$fReadCoercion1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59En_entry() //  [R1]
         { info_tbl: [(c5auh,
                       label: sat_s59En_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5auh: // global
           _s59En::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c5aui; else goto c5auj;
       c5auj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5aul; else goto c5auk;
       c5aul: // global
           HpAlloc = 16;
           goto c5aui;
       c5aui: // global
           R1 = _s59En::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5auk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s59En::P64;
           _s59El::P64 = P64[_s59En::P64 + 16];
           I64[Hp - 8] = sat_s59Em_info;
           P64[Hp] = _s59El::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Type.Coercion.$fReadCoercion_$creadList_entry() //  [R2]
         { info_tbl: [(c5aum,
                       label: Data.Type.Coercion.$fReadCoercion_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aum: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5auq; else goto c5aup;
       c5auq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Type.Coercion.$fReadCoercion_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5aup: // global
           I64[Hp - 16] = sat_s59En_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.75254847 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion_closure" {
     Data.Type.Coercion.$fReadCoercion_closure:
         const Data.Type.Coercion.$fReadCoercion_info;
         const 0;
 },
 sat_s59Es_entry() //  [R1]
         { info_tbl: [(c5auK,
                       label: sat_s59Es_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5auK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5auL; else goto c5auM;
       c5auL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5auM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Coercion.$fReadCoercion_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s59Er_entry() //  [R1, R2, R3]
         { info_tbl: [(c5auS,
                       label: sat_s59Er_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5auS: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Coercion.$fReadCoercion1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s59Eq_entry() //  [R1]
         { info_tbl: [(c5auZ,
                       label: sat_s59Eq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5auZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5av0; else goto c5av1;
       c5av0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5av1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Coercion.$fReadCoercion_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s59Ep_entry() //  [R1, R2]
         { info_tbl: [(c5av7,
                       label: sat_s59Ep_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5av7: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Coercion.$fReadCoercion_$creadsPrec_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$fReadCoercion_entry() //  [R2]
         { info_tbl: [(c5avb,
                       label: Data.Type.Coercion.$fReadCoercion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5avb: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c5avf; else goto c5ave;
       c5avf: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Type.Coercion.$fReadCoercion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5ave: // global
           I64[Hp - 112] = sat_s59Es_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s59Er_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s59Eq_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s59Ep_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 112;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.764436791 UTC

[section ""data" . Data.Type.Coercion.$fBoundedCoercion_closure" {
     Data.Type.Coercion.$fBoundedCoercion_closure:
         const Data.Type.Coercion.$fBoundedCoercion_info;
 },
 Data.Type.Coercion.$fBoundedCoercion_entry() //  [R2]
         { info_tbl: [(c5avJ,
                       label: Data.Type.Coercion.$fBoundedCoercion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5avJ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c5avN; else goto c5avM;
       c5avN: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Type.Coercion.$fBoundedCoercion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5avM: // global
           I64[Hp - 32] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           _c5avH::P64 = Hp - 31;
           P64[Hp - 8] = _c5avH::P64;
           P64[Hp] = _c5avH::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.768833718 UTC

[section ""data" . Data.Type.Coercion.coerceWith_closure" {
     Data.Type.Coercion.coerceWith_closure:
         const Data.Type.Coercion.coerceWith_info;
 },
 Data.Type.Coercion.coerceWith_entry() //  [R2, R3]
         { info_tbl: [(c5aw0,
                       label: Data.Type.Coercion.coerceWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aw0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aw4; else goto c5aw5;
       c5aw4: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.coerceWith_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aw5: // global
           I64[Sp - 16] = block_c5avX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5awd; else goto c5avY;
       u5awd: // global
           call _c5avX(R1) args: 0, res: 0, upd: 0;
       c5avY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5avX() //  [R1]
         { info_tbl: [(c5avX,
                       label: block_c5avX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5avX: // global
           I64[Sp] = block_c5aw3_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto u5awc; else goto c5aw7;
       u5awc: // global
           call _c5aw3() args: 0, res: 0, upd: 0;
       c5aw7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aw3() //  []
         { info_tbl: [(c5aw3,
                       label: block_c5aw3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aw3: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.776516106 UTC

[section ""data" . Data.Type.Coercion.gcoerceWith_closure" {
     Data.Type.Coercion.gcoerceWith_closure:
         const Data.Type.Coercion.gcoerceWith_info;
 },
 Data.Type.Coercion.gcoerceWith_entry() //  [R2, R3]
         { info_tbl: [(c5awy,
                       label: Data.Type.Coercion.gcoerceWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5awy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5awz; else goto c5awA;
       c5awz: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.gcoerceWith_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5awA: // global
           I64[Sp - 16] = block_c5awv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5awE; else goto c5aww;
       u5awE: // global
           call _c5awv(R1) args: 0, res: 0, upd: 0;
       c5aww: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5awv() //  [R1]
         { info_tbl: [(c5awv,
                       label: block_c5awv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5awv: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.782423364 UTC

[section ""data" . Data.Type.Coercion.sym_closure" {
     Data.Type.Coercion.sym_closure:
         const Data.Type.Coercion.sym_info;
 },
 Data.Type.Coercion.sym_entry() //  [R2]
         { info_tbl: [(c5awV,
                       label: Data.Type.Coercion.sym_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5awV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5ax2; else goto c5ax3;
       c5ax2: // global
           R2 = R2;
           R1 = Data.Type.Coercion.sym_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5ax3: // global
           I64[Sp - 8] = block_c5awS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5ax8; else goto c5awT;
       u5ax8: // global
           call _c5awS(R1) args: 0, res: 0, upd: 0;
       c5awT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5awS() //  [R1]
         { info_tbl: [(c5awS,
                       label: block_c5awS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5awS: // global
           I64[Sp] = block_c5awY_info;
           R2 = P64[R1 + 7];
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5awY() //  []
         { info_tbl: [(c5awY,
                       label: block_c5awY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5awY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c5ax7; else goto c5ax6;
       c5ax7: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5ax6: // global
           I64[Hp - 24] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 8] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.790671835 UTC

[section ""data" . Data.Type.Coercion.trans_closure" {
     Data.Type.Coercion.trans_closure:
         const Data.Type.Coercion.trans_info;
 },
 Data.Type.Coercion.trans_entry() //  [R2, R3]
         { info_tbl: [(c5axu,
                       label: Data.Type.Coercion.trans_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5axu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5axI; else goto c5axJ;
       c5axI: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.trans_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5axJ: // global
           I64[Sp - 16] = block_c5axr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5axQ; else goto c5axs;
       u5axQ: // global
           call _c5axr(R1) args: 0, res: 0, upd: 0;
       c5axs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5axr() //  [R1]
         { info_tbl: [(c5axr,
                       label: block_c5axr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5axr: // global
           I64[Sp] = block_c5axx_info;
           R2 = P64[R1 + 7];
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5axx() //  []
         { info_tbl: [(c5axx,
                       label: block_c5axx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5axx: // global
           _s59EK::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5axz_info;
           R1 = _s59EK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5axR; else goto c5axA;
       u5axR: // global
           call _c5axz(R1) args: 0, res: 0, upd: 0;
       c5axA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5axz() //  [R1]
         { info_tbl: [(c5axz,
                       label: block_c5axz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5axz: // global
           I64[Sp] = block_c5axE_info;
           R2 = P64[R1 + 7];
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5axE() //  []
         { info_tbl: [(c5axE,
                       label: block_c5axE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5axE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c5axP; else goto c5axO;
       c5axP: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5axO: // global
           I64[Hp - 24] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 8] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.801808216 UTC

[section ""data" . Data.Type.Coercion.repr_closure" {
     Data.Type.Coercion.repr_closure:
         const Data.Type.Coercion.repr_info;
 },
 Data.Type.Coercion.repr_entry() //  [R2]
         { info_tbl: [(c5ayk,
                       label: Data.Type.Coercion.repr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ayk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5ayp; else goto c5ayq;
       c5ayp: // global
           R2 = R2;
           R1 = Data.Type.Coercion.repr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5ayq: // global
           I64[Sp - 8] = block_c5ayh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5ayu; else goto c5ayi;
       u5ayu: // global
           call _c5ayh(R1) args: 0, res: 0, upd: 0;
       c5ayi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5ayh() //  [R1]
         { info_tbl: [(c5ayh,
                       label: block_c5ayh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5ayh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c5ayt; else goto c5ays;
       c5ayt: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5ays: // global
           I64[Hp - 24] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 8] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.807482433 UTC

[section ""cstring" . Data.Type.Coercion.$trModule4_bytes" {
     Data.Type.Coercion.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.809190262 UTC

[section ""data" . Data.Type.Coercion.$trModule3_closure" {
     Data.Type.Coercion.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Coercion.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.811329888 UTC

[section ""cstring" . Data.Type.Coercion.$trModule2_bytes" {
     Data.Type.Coercion.$trModule2_bytes:
         I8[] [68,97,116,97,46,84,121,112,101,46,67,111,101,114,99,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.812905288 UTC

[section ""data" . Data.Type.Coercion.$trModule1_closure" {
     Data.Type.Coercion.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Coercion.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.814586973 UTC

[section ""data" . Data.Type.Coercion.$trModule_closure" {
     Data.Type.Coercion.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Type.Coercion.$trModule3_closure+1;
         const Data.Type.Coercion.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.816373956 UTC

[section ""data" . $krep_r59Bg_closure" {
     $krep_r59Bg_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.818670297 UTC

[section ""data" . $krep1_r59Bh_closure" {
     $krep1_r59Bh_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.820771737 UTC

[section ""data" . $krep2_r59Bi_closure" {
     $krep2_r59Bi_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r59Bh_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.82265878 UTC

[section ""data" . Data.Type.Coercion.$tcCoercion1_closure" {
     Data.Type.Coercion.$tcCoercion1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r59Bh_closure+2;
         const $krep2_r59Bi_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.824561568 UTC

[section ""data" . Data.Type.Coercion.$tcTestCoercion1_closure" {
     Data.Type.Coercion.$tcTestCoercion1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r59Bi_closure+4;
         const $krep_r59Bg_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.826323388 UTC

[section ""data" . $krep3_r59Bj_closure" {
     $krep3_r59Bj_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.828259335 UTC

[section ""data" . $krep4_r59Bk_closure" {
     $krep4_r59Bk_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.830067594 UTC

[section ""data" . $krep5_r59Bl_closure" {
     $krep5_r59Bl_closure:
         const :_con_info;
         const $krep3_r59Bj_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.831955515 UTC

[section ""data" . $krep6_r59Bm_closure" {
     $krep6_r59Bm_closure:
         const :_con_info;
         const $krep4_r59Bk_closure+2;
         const $krep5_r59Bl_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.834185639 UTC

[section ""data" . $krep7_r59Bn_closure" {
     $krep7_r59Bn_closure:
         const :_con_info;
         const $krep1_r59Bh_closure+2;
         const $krep6_r59Bm_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.835830782 UTC

[section ""data" . $krep8_r59Bo_closure" {
     $krep8_r59Bo_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcCoercible_closure;
         const $krep7_r59Bn_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.837616809 UTC

[section ""data" . Data.Type.Coercion.$tcCoercion2_closure" {
     Data.Type.Coercion.$tcCoercion2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Coercion.$fReadCoercion3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.839263887 UTC

[section ""data" . Data.Type.Coercion.$tcCoercion_closure" {
     Data.Type.Coercion.$tcCoercion_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Coercion.$trModule_closure+1;
         const Data.Type.Coercion.$tcCoercion2_closure+1;
         const Data.Type.Coercion.$tcCoercion1_closure+4;
         const 14885566513674463733;
         const 8268940906925368652;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.841043224 UTC

[section ""data" . $krep9_r59Bp_closure" {
     $krep9_r59Bp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Type.Coercion.$tcCoercion_closure+1;
         const $krep7_r59Bn_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.842802795 UTC

[section ""data" . Data.Type.Coercion.$tc'Coercion1_closure" {
     Data.Type.Coercion.$tc'Coercion1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_r59Bo_closure+1;
         const $krep9_r59Bp_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.844982071 UTC

[section ""cstring" . Data.Type.Coercion.$tc'Coercion3_bytes" {
     Data.Type.Coercion.$tc'Coercion3_bytes:
         I8[] [39,67,111,101,114,99,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.846808516 UTC

[section ""data" . Data.Type.Coercion.$tc'Coercion2_closure" {
     Data.Type.Coercion.$tc'Coercion2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Coercion.$tc'Coercion3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.848455842 UTC

[section ""data" . Data.Type.Coercion.$tc'Coercion_closure" {
     Data.Type.Coercion.$tc'Coercion_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Coercion.$trModule_closure+1;
         const Data.Type.Coercion.$tc'Coercion2_closure+1;
         const Data.Type.Coercion.$tc'Coercion1_closure+4;
         const 16177208673276072700;
         const 13187043378465993605;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.850780648 UTC

[section ""cstring" . Data.Type.Coercion.$tcTestCoercion3_bytes" {
     Data.Type.Coercion.$tcTestCoercion3_bytes:
         I8[] [84,101,115,116,67,111,101,114,99,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.852458998 UTC

[section ""data" . Data.Type.Coercion.$tcTestCoercion2_closure" {
     Data.Type.Coercion.$tcTestCoercion2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Coercion.$tcTestCoercion3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.854197535 UTC

[section ""data" . Data.Type.Coercion.$tcTestCoercion_closure" {
     Data.Type.Coercion.$tcTestCoercion_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Coercion.$trModule_closure+1;
         const Data.Type.Coercion.$tcTestCoercion2_closure+1;
         const Data.Type.Coercion.$tcTestCoercion1_closure+4;
         const 14520160333183018944;
         const 2439357669602544154;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.856304323 UTC

[section ""data" . Data.Type.Coercion.Coercion_closure" {
     Data.Type.Coercion.Coercion_closure:
         const Data.Type.Coercion.Coercion_info;
 },
 Data.Type.Coercion.Coercion_entry() //  [R2]
         { info_tbl: [(c5azb,
                       label: Data.Type.Coercion.Coercion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5azb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5azf; else goto c5aze;
       c5azf: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Type.Coercion.Coercion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5aze: // global
           I64[Hp - 8] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.859892551 UTC

[Data.Type.Coercion.Coercion_con_entry() //  [R1]
         { info_tbl: [(c5azl,
                       label: Data.Type.Coercion.Coercion_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,84,121,112,101,46,67,111,101,114,99,105,111,110,46,67,111,101,114,99,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5azl: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:06.863170829 UTC

[section ""relreadonly" . S59Fe_srt" {
     S59Fe_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Type.Coercion.$fEnumCoercion1_closure;
         const Data.Type.Coercion.$fEnumCoercion_$ctoEnum_closure;
         const Data.Type.Coercion.$w$cenumFromTo_closure;
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_closure;
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_closure;
         const lvl1_r59Bc_closure;
         const Data.Type.Coercion.$w$cenumFrom_closure;
         const Data.Type.Coercion.$fEnumCoercion_$cenumFrom_closure;
         const Data.Type.Coercion.$w$cenumFromThenTo_closure;
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_closure;
         const lvl4_r59Bf_closure;
         const Data.Type.Coercion.$fEnumCoercion_closure;
         const Data.Type.Coercion.$fReadCoercion2_closure;
         const Data.Type.Coercion.$fShowCoercion_$cshowsPrec_closure;
         const Data.Type.Coercion.$fShowCoercion_$cshow_closure;
         const Data.Type.Coercion.$fShowCoercion1_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Type.Coercion.$fReadCoercion_lexeme_closure;
         const GHC.Read.list3_closure;
         const Data.Type.Coercion.$fReadCoercion1_closure;
         const Data.Type.Coercion.$fReadCoercion_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Type.Coercion.$fReadCoercion_$creadListPrec_closure;
         const Data.Type.Coercion.$fReadCoercion_$creadList_closure;
         const Data.Type.Coercion.$fReadCoercion_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.716585442 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:00:07.718247948 UTC

[section ""data" . Data.Type.Coercion.testCoercion_closure" {
     Data.Type.Coercion.testCoercion_closure:
         const Data.Type.Coercion.testCoercion_info;
 },
 Data.Type.Coercion.testCoercion_entry() //  [R2]
         { info_tbl: [(c5aCY,
                       label: Data.Type.Coercion.testCoercion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aCY: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.7219932 UTC

[section ""cstring" . lvl_r59Bb_bytes" {
     lvl_r59Bb_bytes:
         I8[] [68,97,116,97,46,84,121,112,101,46,67,111,101,114,99,105,111,110,46,116,111,69,110,117,109,58,32,98,97,100,32,97,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.72490274 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion1_closure" {
     Data.Type.Coercion.$fEnumCoercion1_closure:
         const Data.Type.Coercion.$fEnumCoercion1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Coercion.$fEnumCoercion1_entry() //  [R1]
         { info_tbl: [(c5aDe,
                       label: Data.Type.Coercion.$fEnumCoercion1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aDe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c5aDf; else goto c5aDg;
       c5aDf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5aDg: // global
           (_c5aD9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c5aD9::I64 == 0) goto c5aDb; else goto c5aDa;
       c5aDb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c5aDa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c5aD9::I64;
           I64[Sp - 24] = block_c5aDc_info;
           R2 = lvl_r59Bb_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c5aDc() //  [R1]
         { info_tbl: [(c5aDc,
                       label: block_c5aDc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aDc: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.731642844 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_$ctoEnum_closure" {
     Data.Type.Coercion.$fEnumCoercion_$ctoEnum_closure:
         const Data.Type.Coercion.$fEnumCoercion_$ctoEnum_info;
         const 0;
 },
 Data.Type.Coercion.$fEnumCoercion_$ctoEnum_entry() //  [R2, R3]
         { info_tbl: [(c5aDE,
                       label: Data.Type.Coercion.$fEnumCoercion_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aDE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aDF; else goto c5aDG;
       c5aDF: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_$ctoEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aDG: // global
           I64[Sp - 16] = block_c5aDB_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5aDT; else goto c5aDC;
       u5aDT: // global
           call _c5aDB(R1) args: 0, res: 0, upd: 0;
       c5aDC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aDB() //  [R1]
         { info_tbl: [(c5aDB,
                       label: block_c5aDB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aDB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5aDL; else goto c5aDK;
       c5aDL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5aDK: // global
           if (I64[R1 + 7] == 0) goto c5aDS; else goto c5aDO;
       c5aDS: // global
           I64[Hp - 8] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5aDO: // global
           Hp = Hp - 16;
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.738849813 UTC

[section ""data" . Data.Type.Coercion.$w$cenumFromTo_closure" {
     Data.Type.Coercion.$w$cenumFromTo_closure:
         const Data.Type.Coercion.$w$cenumFromTo_info;
         const 0;
 },
 sat_s5azJ_entry() //  [R1]
         { info_tbl: [(c5aEq,
                       label: sat_s5azJ_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aEq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aEr; else goto c5aEs;
       c5aEr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5aEs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s5azH::I64 = I64[R1 + 24];
           if (_s5azH::I64 != 0) goto c5aEo; else goto c5aEp;
       c5aEo: // global
           R2 = _s5azH::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s5azD_entry(R2, R1) args: 24, res: 0, upd: 24;
       c5aEp: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s5azG_entry() //  [R1]
         { info_tbl: [(c5aED,
                       label: sat_s5azG_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aED: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aEE; else goto c5aEF;
       c5aEE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5aEF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 24] == 0) goto c5aEC; else goto c5aEB;
       c5aEC: // global
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c5aEB: // global
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s5azD_entry() //  [R1, R2]
         { info_tbl: [(c5aEH,
                       label: go_s5azD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aEH: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c5aEL; else goto c5aEK;
       c5aEL: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5aEK: // global
           _s5azC::P64 = P64[R1 + 7];
           I64[Hp - 80] = sat_s5azJ_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s5azG_info;
           P64[Hp - 32] = _s5azC::P64;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$w$cenumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c5aEM,
                       label: Data.Type.Coercion.$w$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aEM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c5aEQ; else goto c5aEP;
       c5aEQ: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$w$cenumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aEP: // global
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = go_s5azD_info;
           P64[Hp] = Hp - 23;
           R2 = 0;
           R1 = Hp - 7;
           call go_s5azD_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.751390178 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_closure" {
     Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_closure:
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_info;
         const 0;
 },
 Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(c5aFs,
                       label: Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aFs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c5aFw; else goto c5aFx;
       c5aFw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aFx: // global
           I64[Sp - 24] = block_c5aFp_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u5aFF; else goto c5aFq;
       u5aFF: // global
           call _c5aFp(R1) args: 0, res: 0, upd: 0;
       c5aFq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aFp() //  [R1]
         { info_tbl: [(c5aFp,
                       label: block_c5aFp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aFp: // global
           I64[Sp] = block_c5aFv_info;
           _s5azN::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s5azN::P64;
           if (R1 & 7 != 0) goto u5aFE; else goto c5aFz;
       u5aFE: // global
           call _c5aFv(R1) args: 0, res: 0, upd: 0;
       c5aFz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aFv() //  [R1]
         { info_tbl: [(c5aFv,
                       label: block_c5aFv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aFv: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Coercion.$w$cenumFromTo_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.762359575 UTC

[section ""data" . lvl1_r59Bc_closure" {
     lvl1_r59Bc_closure:
         const lvl1_r59Bc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r59Bc_entry() //  [R1]
         { info_tbl: [(c5aG1,
                       label: lvl1_r59Bc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aG1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aG2; else goto c5aG3;
       c5aG2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5aG3: // global
           (_c5aFY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c5aFY::I64 == 0) goto c5aG0; else goto c5aFZ;
       c5aG0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c5aFZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c5aFY::I64;
           R3 = 0;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.Enum.efdInt_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.769028993 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_closure" {
     Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_closure:
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_info;
         const 0;
 },
 sat_s5azY_entry() //  [R1, R2]
         { info_tbl: [(c5aGv,
                       label: sat_s5azY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aGv: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Coercion.$fEnumCoercion_$ctoEnum_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(c5aGy,
                       label: Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aGy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c5aGz; else goto c5aGA;
       c5aGz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aGA: // global
           I64[Sp - 24] = block_c5aGg_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u5aGG; else goto c5aGh;
       u5aGG: // global
           call _c5aGg() args: 0, res: 0, upd: 0;
       c5aGh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aGg() //  []
         { info_tbl: [(c5aGg,
                       label: block_c5aGg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aGg: // global
           I64[Sp] = block_c5aGl_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u5aGF; else goto c5aGm;
       u5aGF: // global
           call _c5aGl(R1) args: 0, res: 0, upd: 0;
       c5aGm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aGl() //  [R1]
         { info_tbl: [(c5aGl,
                       label: block_c5aGl_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aGl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5aGE; else goto c5aGD;
       c5aGE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5aGD: // global
           I64[Hp - 8] = sat_s5azY_info;
           P64[Hp] = P64[Sp + 8];
           R3 = lvl1_r59Bc_closure;
           R2 = Hp - 7;
           Sp = Sp + 24;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.784726088 UTC

[section ""data" . Data.Type.Coercion.$w$cenumFrom_closure" {
     Data.Type.Coercion.$w$cenumFrom_closure:
         const Data.Type.Coercion.$w$cenumFrom_info;
         const 0;
 },
 sat_s5aA8_entry() //  [R1]
         { info_tbl: [(c5aHj,
                       label: sat_s5aA8_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aHj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aHk; else goto c5aHl;
       c5aHk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5aHl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s5aA6::I64 = I64[R1 + 24];
           if (_s5aA6::I64 != 9223372036854775807) goto c5aHh; else goto c5aHi;
       c5aHh: // global
           R2 = _s5aA6::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s5aA2_entry(R2, R1) args: 24, res: 0, upd: 24;
       c5aHi: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s5aA5_entry() //  [R1]
         { info_tbl: [(c5aHw,
                       label: sat_s5aA5_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aHw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aHx; else goto c5aHy;
       c5aHx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5aHy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 24] == 0) goto c5aHv; else goto c5aHu;
       c5aHv: // global
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c5aHu: // global
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s5aA2_entry() //  [R1, R2]
         { info_tbl: [(c5aHA,
                       label: go_s5aA2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aHA: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c5aHE; else goto c5aHD;
       c5aHE: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5aHD: // global
           _s5aA1::P64 = P64[R1 + 7];
           I64[Hp - 80] = sat_s5aA8_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s5aA5_info;
           P64[Hp - 32] = _s5aA1::P64;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$w$cenumFrom_entry() //  [R2, R3]
         { info_tbl: [(c5aHF,
                       label: Data.Type.Coercion.$w$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aHF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c5aHJ; else goto c5aHI;
       c5aHJ: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$w$cenumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aHI: // global
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = go_s5aA2_info;
           P64[Hp] = Hp - 23;
           R2 = 0;
           R1 = Hp - 7;
           call go_s5aA2_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.801070013 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_$cenumFrom_closure" {
     Data.Type.Coercion.$fEnumCoercion_$cenumFrom_closure:
         const Data.Type.Coercion.$fEnumCoercion_$cenumFrom_info;
         const 0;
 },
 Data.Type.Coercion.$fEnumCoercion_$cenumFrom_entry() //  [R2, R3]
         { info_tbl: [(c5aIm,
                       label: Data.Type.Coercion.$fEnumCoercion_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aIm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aIn; else goto c5aIo;
       c5aIn: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_$cenumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aIo: // global
           I64[Sp - 16] = block_c5aIj_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5aIs; else goto c5aIk;
       u5aIs: // global
           call _c5aIj(R1) args: 0, res: 0, upd: 0;
       c5aIk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aIj() //  [R1]
         { info_tbl: [(c5aIj,
                       label: block_c5aIj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aIj: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Type.Coercion.$w$cenumFrom_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.810711991 UTC

[section ""data" . Data.Type.Coercion.$w$cenumFromThenTo_closure" {
     Data.Type.Coercion.$w$cenumFromThenTo_closure:
         const Data.Type.Coercion.$w$cenumFromThenTo_info;
         const 0;
 },
 sat_s5aAn_entry() //  [R1]
         { info_tbl: [(c5aIY,
                       label: sat_s5aAn_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aIY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aIZ; else goto c5aJ0;
       c5aIZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5aJ0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s5aAi_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s5aAm_entry() //  [R1]
         { info_tbl: [(c5aJ9,
                       label: sat_s5aAm_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aJ9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aJa; else goto c5aJb;
       c5aJa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5aJb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 24] == 0) goto c5aJ8; else goto c5aJ7;
       c5aJ8: // global
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c5aJ7: // global
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s5aAp_entry() //  [R1]
         { info_tbl: [(c5aJl,
                       label: sat_s5aAp_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aJl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aJm; else goto c5aJn;
       c5aJm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5aJn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 24] == 0) goto c5aJk; else goto c5aJj;
       c5aJk: // global
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c5aJj: // global
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s5aAi_entry() //  [R1, R2]
         { info_tbl: [(c5aJr,
                       label: go_up_s5aAi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aJr: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c5aJv; else goto c5aJu;
       c5aJv: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5aJu: // global
           _s5aAh::P64 = P64[R1 + 7];
           if (%MO_S_Le_W64(R2, 0)) goto c5aJp; else goto c5aJq;
       c5aJp: // global
           I64[Hp - 80] = sat_s5aAn_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s5aAm_info;
           P64[Hp - 32] = _s5aAh::P64;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c5aJq: // global
           I64[Hp - 80] = sat_s5aAp_info;
           P64[Hp - 64] = _s5aAh::P64;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 80;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c5aJx::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c5aJx::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s5aAq_entry() //  [R1]
         { info_tbl: [(c5aJy,
                       label: sat_s5aAq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aJy: // global
           _s5aAq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c5aJz; else goto c5aJA;
       c5aJA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5aJC; else goto c5aJB;
       c5aJC: // global
           HpAlloc = 16;
           goto c5aJz;
       c5aJz: // global
           R1 = _s5aAq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5aJB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s5aAq::P64;
           _s5aAh::P64 = P64[_s5aAq::P64 + 16];
           I64[Hp - 8] = go_up_s5aAi_info;
           P64[Hp] = _s5aAh::P64;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call go_up_s5aAi_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Coercion.$w$cenumFromThenTo_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c5aJD,
                       label: Data.Type.Coercion.$w$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aJD: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c5aJH; else goto c5aJG;
       c5aJH: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$w$cenumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aJG: // global
           I64[Hp - 32] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s5aAq_info;
           _c5aIH::P64 = Hp - 31;
           P64[Hp] = _c5aIH::P64;
           R2 = Hp - 16;
           R1 = _c5aIH::P64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.835828959 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_closure" {
     Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_closure:
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_info;
         const 0;
 },
 Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_entry() //  [R2,
                                                                 R3, R4, R5]
         { info_tbl: [(c5aKA,
                       label: Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aKA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c5aKQ; else goto c5aKR;
       c5aKQ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aKR: // global
           I64[Sp - 32] = block_c5aKx_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u5aKZ; else goto c5aKy;
       u5aKZ: // global
           call _c5aKx(R1) args: 0, res: 0, upd: 0;
       c5aKy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aKx() //  [R1]
         { info_tbl: [(c5aKx,
                       label: block_c5aKx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aKx: // global
           I64[Sp] = block_c5aKD_info;
           _s5aAv::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s5aAv::P64;
           if (R1 & 7 != 0) goto u5aKY; else goto c5aKE;
       u5aKY: // global
           call _c5aKD(R1) args: 0, res: 0, upd: 0;
       c5aKE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aKD() //  [R1]
         { info_tbl: [(c5aKD,
                       label: block_c5aKD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aKD: // global
           I64[Sp] = block_c5aKI_info;
           _s5aAx::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s5aAx::P64;
           if (R1 & 7 != 0) goto u5aL0; else goto c5aKJ;
       u5aL0: // global
           call _c5aKI(R1) args: 0, res: 0, upd: 0;
       c5aKJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aKI() //  [R1]
         { info_tbl: [(c5aKI,
                       label: block_c5aKI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aKI: // global
           _s5aAx::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c5aKN_info;
           R5 = R1;
           R4 = _s5aAx::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Coercion.$w$cenumFromThenTo_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5aKN() //  [R1, R2]
         { info_tbl: [(c5aKN,
                       label: block_c5aKN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aKN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5aKX; else goto c5aKW;
       c5aKX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c5aKW: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.85496911 UTC

[section ""data" . lvl2_r59Bd_closure" {
     lvl2_r59Bd_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.858444563 UTC

[section ""data" . lvl3_r59Be_closure" {
     lvl3_r59Be_closure:
         const lvl3_r59Be_info;
 },
 lvl3_r59Be_entry() //  [R2]
         { info_tbl: [(c5aLz,
                       label: lvl3_r59Be_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aLz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5aLA; else goto c5aLB;
       c5aLA: // global
           R2 = R2;
           R1 = lvl3_r59Be_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5aLB: // global
           I64[Sp - 8] = block_c5aLw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5aLF; else goto c5aLx;
       u5aLF: // global
           call _c5aLw() args: 0, res: 0, upd: 0;
       c5aLx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aLw() //  []
         { info_tbl: [(c5aLw,
                       label: block_c5aLw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aLw: // global
           R1 = lvl2_r59Bd_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.864334675 UTC

[section ""data" . lvl4_r59Bf_closure" {
     lvl4_r59Bf_closure:
         const lvl4_r59Bf_info;
         const 0;
 },
 lvl4_r59Bf_entry() //  [R2]
         { info_tbl: [(c5aLY,
                       label: lvl4_r59Bf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aLY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5aLZ; else goto c5aM0;
       c5aLZ: // global
           R2 = R2;
           R1 = lvl4_r59Bf_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5aM0: // global
           I64[Sp - 8] = block_c5aLV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5aM4; else goto c5aLW;
       u5aM4: // global
           call _c5aLV() args: 0, res: 0, upd: 0;
       c5aLW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aLV() //  []
         { info_tbl: [(c5aLV,
                       label: block_c5aLV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aLV: // global
           R1 = Data.Type.Coercion.$fEnumCoercion1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.870842417 UTC

[section ""data" . Data.Type.Coercion.$fEnumCoercion_closure" {
     Data.Type.Coercion.$fEnumCoercion_closure:
         const Data.Type.Coercion.$fEnumCoercion_info;
         const 0;
 },
 sat_s5aAP_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c5aMp,
                       label: sat_s5aAP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aMp: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_entry(R5,
                                                                         R4,
                                                                         R3,
                                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s5aAO_entry() //  [R1, R2, R3]
         { info_tbl: [(c5aMx,
                       label: sat_s5aAO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aMx: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s5aAN_entry() //  [R1, R2, R3]
         { info_tbl: [(c5aMF,
                       label: sat_s5aAN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aMF: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s5aAM_entry() //  [R1, R2]
         { info_tbl: [(c5aMN,
                       label: sat_s5aAM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aMN: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Coercion.$fEnumCoercion_$cenumFrom_entry(R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s5aAL_entry() //  [R1, R2]
         { info_tbl: [(c5aMV,
                       label: sat_s5aAL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aMV: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Coercion.$fEnumCoercion_$ctoEnum_entry(R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$fEnumCoercion_entry() //  [R2]
         { info_tbl: [(c5aMZ,
                       label: Data.Type.Coercion.$fEnumCoercion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aMZ: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto c5aN3; else goto c5aN2;
       c5aN3: // global
           HpAlloc = 152;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEnumCoercion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5aN2: // global
           I64[Hp - 144] = sat_s5aAP_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s5aAO_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s5aAN_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s5aAM_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s5aAL_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = lvl4_r59Bf_closure+1;
           P64[Hp - 48] = lvl4_r59Bf_closure+1;
           P64[Hp - 40] = Hp - 79;
           P64[Hp - 32] = lvl3_r59Be_closure+1;
           P64[Hp - 24] = Hp - 95;
           P64[Hp - 16] = Hp - 110;
           P64[Hp - 8] = Hp - 126;
           P64[Hp] = Hp - 141;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.88492366 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_closure" {
     Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_closure:
         const Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_info;
 },
 Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(c5aNJ,
                       label: Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aNJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aNU; else goto c5aNV;
       c5aNU: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aNV: // global
           I64[Sp - 16] = block_c5aNG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5aO1; else goto c5aNH;
       u5aO1: // global
           call _c5aNG() args: 0, res: 0, upd: 0;
       c5aNH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aNG() //  []
         { info_tbl: [(c5aNG,
                       label: block_c5aNG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aNG: // global
           _s5aAR::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5aNM_info;
           R1 = _s5aAR::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5aO0; else goto c5aNN;
       u5aO0: // global
           call _c5aNM(R1) args: 0, res: 0, upd: 0;
       c5aNN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aNM() //  [R1]
         { info_tbl: [(c5aNM,
                       label: block_c5aNM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aNM: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c5aNZ; else goto c5aNY;
       c5aNZ: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5aNY: // global
           I64[Hp - 40] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = Hp - 39;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.893474747 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionk:~:_closure" {
     Data.Type.Coercion.$fTestCoercionk:~:_closure:
         const Data.Type.Coercion.$fTestCoercionk:~:_info;
 },
 Data.Type.Coercion.$fTestCoercionk:~:_entry() //  [R2, R3]
         { info_tbl: [(c5aOr,
                       label: Data.Type.Coercion.$fTestCoercionk:~:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aOr: // global
           R3 = R3;
           R2 = R2;
           call Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion_entry(R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.897390663 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_closure" {
     Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_closure:
         const Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_info;
 },
 Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(c5aOF,
                       label: Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aOF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aOQ; else goto c5aOR;
       c5aOQ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aOR: // global
           I64[Sp - 16] = block_c5aOC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5aOX; else goto c5aOD;
       u5aOX: // global
           call _c5aOC() args: 0, res: 0, upd: 0;
       c5aOD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aOC() //  []
         { info_tbl: [(c5aOC,
                       label: block_c5aOC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aOC: // global
           _s5aAX::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5aOI_info;
           R1 = _s5aAX::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5aOW; else goto c5aOJ;
       u5aOW: // global
           call _c5aOI(R1) args: 0, res: 0, upd: 0;
       c5aOJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aOI() //  [R1]
         { info_tbl: [(c5aOI,
                       label: block_c5aOI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aOI: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c5aOV; else goto c5aOU;
       c5aOV: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5aOU: // global
           I64[Hp - 40] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = Hp - 39;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.906398644 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionk:~~:_closure" {
     Data.Type.Coercion.$fTestCoercionk:~~:_closure:
         const Data.Type.Coercion.$fTestCoercionk:~~:_info;
 },
 Data.Type.Coercion.$fTestCoercionk:~~:_entry() //  [R2, R3]
         { info_tbl: [(c5aPn,
                       label: Data.Type.Coercion.$fTestCoercionk:~~:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aPn: // global
           R3 = R3;
           R2 = R2;
           call Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion_entry(R3,
                                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.911009035 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_closure" {
     Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_closure:
         const Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_info;
 },
 Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_entry() //  [R2,
                                                                        R3]
         { info_tbl: [(c5aPB,
                       label: Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aPB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aPQ; else goto c5aPR;
       c5aPQ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aPR: // global
           I64[Sp - 16] = block_c5aPy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5aPZ; else goto c5aPz;
       u5aPZ: // global
           call _c5aPy(R1) args: 0, res: 0, upd: 0;
       c5aPz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aPy() //  [R1]
         { info_tbl: [(c5aPy,
                       label: block_c5aPy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aPy: // global
           I64[Sp] = block_c5aPE_info;
           _s5aB5::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s5aB5::P64;
           if (R1 & 7 != 0) goto u5aPY; else goto c5aPF;
       u5aPY: // global
           call _c5aPE(R1) args: 0, res: 0, upd: 0;
       c5aPF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aPE() //  [R1]
         { info_tbl: [(c5aPE,
                       label: block_c5aPE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aPE: // global
           I64[Sp] = block_c5aPJ_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 7];
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5aPJ() //  []
         { info_tbl: [(c5aPJ,
                       label: block_c5aPJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aPJ: // global
           _s5aB7::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5aPL_info;
           R2 = _s5aB7::P64;
           Sp = Sp + 8;
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5aPL() //  []
         { info_tbl: [(c5aPL,
                       label: block_c5aPL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aPL: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c5aPX; else goto c5aPW;
       c5aPX: // global
           HpAlloc = 48;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5aPW: // global
           I64[Hp - 40] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = Hp - 39;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.922328506 UTC

[section ""data" . Data.Type.Coercion.$fTestCoercionkCoercion_closure" {
     Data.Type.Coercion.$fTestCoercionkCoercion_closure:
         const Data.Type.Coercion.$fTestCoercionkCoercion_info;
 },
 Data.Type.Coercion.$fTestCoercionkCoercion_entry() //  [R2, R3]
         { info_tbl: [(c5aQy,
                       label: Data.Type.Coercion.$fTestCoercionkCoercion_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aQy: // global
           R3 = R3;
           R2 = R2;
           call Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion_entry(R3,
                                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.926356029 UTC

[section ""data" . Data.Type.Coercion.$fEqCoercion_$c==_closure" {
     Data.Type.Coercion.$fEqCoercion_$c==_closure:
         const Data.Type.Coercion.$fEqCoercion_$c==_info;
 },
 Data.Type.Coercion.$fEqCoercion_$c==_entry() //  [R2, R3]
         { info_tbl: [(c5aQM,
                       label: Data.Type.Coercion.$fEqCoercion_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aQM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aQQ; else goto c5aQR;
       c5aQQ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEqCoercion_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aQR: // global
           I64[Sp - 16] = block_c5aQJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5aQZ; else goto c5aQK;
       u5aQZ: // global
           call _c5aQJ() args: 0, res: 0, upd: 0;
       c5aQK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aQJ() //  []
         { info_tbl: [(c5aQJ,
                       label: block_c5aQJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aQJ: // global
           _s5aBb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5aQP_info;
           R1 = _s5aBb::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5aQY; else goto c5aQT;
       u5aQY: // global
           call _c5aQP() args: 0, res: 0, upd: 0;
       c5aQT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aQP() //  []
         { info_tbl: [(c5aQP,
                       label: block_c5aQP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aQP: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.937069181 UTC

[section ""data" . Data.Type.Coercion.$fEqCoercion_$c/=_closure" {
     Data.Type.Coercion.$fEqCoercion_$c/=_closure:
         const Data.Type.Coercion.$fEqCoercion_$c/=_info;
 },
 Data.Type.Coercion.$fEqCoercion_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c5aRo,
                       label: Data.Type.Coercion.$fEqCoercion_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aRo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aRs; else goto c5aRt;
       c5aRs: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fEqCoercion_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aRt: // global
           I64[Sp - 16] = block_c5aRl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5aRB; else goto c5aRm;
       u5aRB: // global
           call _c5aRl() args: 0, res: 0, upd: 0;
       c5aRm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aRl() //  []
         { info_tbl: [(c5aRl,
                       label: block_c5aRl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aRl: // global
           _s5aBh::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5aRr_info;
           R1 = _s5aBh::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5aRA; else goto c5aRv;
       u5aRA: // global
           call _c5aRr() args: 0, res: 0, upd: 0;
       c5aRv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aRr() //  []
         { info_tbl: [(c5aRr,
                       label: block_c5aRr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aRr: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.945290551 UTC

[section ""data" . Data.Type.Coercion.$fEqCoercion_closure" {
     Data.Type.Coercion.$fEqCoercion_closure:
         const GHC.Classes.C:Eq_con_info;
         const Data.Type.Coercion.$fEqCoercion_$c==_closure+2;
         const Data.Type.Coercion.$fEqCoercion_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.94705219 UTC

[section ""cstring" . Data.Type.Coercion.$fReadCoercion3_bytes" {
     Data.Type.Coercion.$fReadCoercion3_bytes:
         I8[] [67,111,101,114,99,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.949316628 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion2_closure" {
     Data.Type.Coercion.$fReadCoercion2_closure:
         const Data.Type.Coercion.$fReadCoercion2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Coercion.$fReadCoercion2_entry() //  [R1]
         { info_tbl: [(c5aS1,
                       label: Data.Type.Coercion.$fReadCoercion2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aS1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aS2; else goto c5aS3;
       c5aS2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5aS3: // global
           (_c5aRY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c5aRY::I64 == 0) goto c5aS0; else goto c5aRZ;
       c5aS0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c5aRZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c5aRY::I64;
           R2 = Data.Type.Coercion.$fReadCoercion3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.954274323 UTC

[section ""data" . Data.Type.Coercion.$fShowCoercion_$cshowsPrec_closure" {
     Data.Type.Coercion.$fShowCoercion_$cshowsPrec_closure:
         const Data.Type.Coercion.$fShowCoercion_$cshowsPrec_info;
         const 0;
 },
 Data.Type.Coercion.$fShowCoercion_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c5aSj,
                       label: Data.Type.Coercion.$fShowCoercion_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aSj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aSk; else goto c5aSl;
       c5aSk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fShowCoercion_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aSl: // global
           I64[Sp - 16] = block_c5aSg_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5aSp; else goto c5aSh;
       u5aSp: // global
           call _c5aSg() args: 0, res: 0, upd: 0;
       c5aSh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aSg() //  []
         { info_tbl: [(c5aSg,
                       label: block_c5aSg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aSg: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Coercion.$fReadCoercion2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.96175256 UTC

[section ""data" . Data.Type.Coercion.$fShowCoercion_$cshow_closure" {
     Data.Type.Coercion.$fShowCoercion_$cshow_closure:
         const Data.Type.Coercion.$fShowCoercion_$cshow_info;
         const 0;
 },
 Data.Type.Coercion.$fShowCoercion_$cshow_entry() //  [R2]
         { info_tbl: [(c5aSH,
                       label: Data.Type.Coercion.$fShowCoercion_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aSH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5aSI; else goto c5aSJ;
       c5aSI: // global
           R2 = R2;
           R1 = Data.Type.Coercion.$fShowCoercion_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5aSJ: // global
           I64[Sp - 8] = block_c5aSE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5aSN; else goto c5aSF;
       u5aSN: // global
           call _c5aSE() args: 0, res: 0, upd: 0;
       c5aSF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aSE() //  []
         { info_tbl: [(c5aSE,
                       label: block_c5aSE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aSE: // global
           R1 = Data.Type.Coercion.$fReadCoercion2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.967927405 UTC

[section ""data" . Data.Type.Coercion.$fShowCoercion1_closure" {
     Data.Type.Coercion.$fShowCoercion1_closure:
         const Data.Type.Coercion.$fShowCoercion1_info;
         const 0;
 },
 Data.Type.Coercion.$fShowCoercion1_entry() //  [R2, R3]
         { info_tbl: [(c5aT6,
                       label: Data.Type.Coercion.$fShowCoercion1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aT6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aT7; else goto c5aT8;
       c5aT7: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fShowCoercion1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aT8: // global
           I64[Sp - 16] = block_c5aT3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5aTc; else goto c5aT4;
       u5aTc: // global
           call _c5aT3() args: 0, res: 0, upd: 0;
       c5aT4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aT3() //  []
         { info_tbl: [(c5aT3,
                       label: block_c5aT3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aT3: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Coercion.$fReadCoercion2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.974576904 UTC

[section ""data" . Data.Type.Coercion.$fShowCoercion_$cshowList_closure" {
     Data.Type.Coercion.$fShowCoercion_$cshowList_closure:
         const Data.Type.Coercion.$fShowCoercion_$cshowList_info;
         const 0;
 },
 Data.Type.Coercion.$fShowCoercion_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c5aTr,
                       label: Data.Type.Coercion.$fShowCoercion_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aTr: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Type.Coercion.$fShowCoercion1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.979123772 UTC

[section ""data" . Data.Type.Coercion.$fShowCoercion_closure" {
     Data.Type.Coercion.$fShowCoercion_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Type.Coercion.$fShowCoercion_$cshowsPrec_closure+3;
         const Data.Type.Coercion.$fShowCoercion_$cshow_closure+1;
         const Data.Type.Coercion.$fShowCoercion_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.982439122 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$c<_closure" {
     Data.Type.Coercion.$fOrdCoercion_$c<_closure:
         const Data.Type.Coercion.$fOrdCoercion_$c<_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$c<_entry() //  [R2, R3]
         { info_tbl: [(c5aTG,
                       label: Data.Type.Coercion.$fOrdCoercion_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aTG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aTK; else goto c5aTL;
       c5aTK: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aTL: // global
           I64[Sp - 16] = block_c5aTD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5aTT; else goto c5aTE;
       u5aTT: // global
           call _c5aTD() args: 0, res: 0, upd: 0;
       c5aTE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aTD() //  []
         { info_tbl: [(c5aTD,
                       label: block_c5aTD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aTD: // global
           _s5aBB::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5aTJ_info;
           R1 = _s5aBB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5aTS; else goto c5aTN;
       u5aTS: // global
           call _c5aTJ() args: 0, res: 0, upd: 0;
       c5aTN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aTJ() //  []
         { info_tbl: [(c5aTJ,
                       label: block_c5aTJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aTJ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:07.991462091 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$ccompare_closure" {
     Data.Type.Coercion.$fOrdCoercion_$ccompare_closure:
         const Data.Type.Coercion.$fOrdCoercion_$ccompare_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c5aUi,
                       label: Data.Type.Coercion.$fOrdCoercion_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aUi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aUm; else goto c5aUn;
       c5aUm: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aUn: // global
           I64[Sp - 16] = block_c5aUf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5aUv; else goto c5aUg;
       u5aUv: // global
           call _c5aUf() args: 0, res: 0, upd: 0;
       c5aUg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aUf() //  []
         { info_tbl: [(c5aUf,
                       label: block_c5aUf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aUf: // global
           _s5aBH::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5aUl_info;
           R1 = _s5aBH::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5aUu; else goto c5aUp;
       u5aUu: // global
           call _c5aUl() args: 0, res: 0, upd: 0;
       c5aUp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aUl() //  []
         { info_tbl: [(c5aUl,
                       label: block_c5aUl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aUl: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.002055585 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$c<=_closure" {
     Data.Type.Coercion.$fOrdCoercion_$c<=_closure:
         const Data.Type.Coercion.$fOrdCoercion_$c<=_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c5aUU,
                       label: Data.Type.Coercion.$fOrdCoercion_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aUU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aUY; else goto c5aUZ;
       c5aUY: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aUZ: // global
           I64[Sp - 16] = block_c5aUR_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5aV7; else goto c5aUS;
       u5aV7: // global
           call _c5aUR() args: 0, res: 0, upd: 0;
       c5aUS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aUR() //  []
         { info_tbl: [(c5aUR,
                       label: block_c5aUR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aUR: // global
           _s5aBM::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5aUX_info;
           R1 = _s5aBM::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5aV6; else goto c5aV1;
       u5aV6: // global
           call _c5aUX() args: 0, res: 0, upd: 0;
       c5aV1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aUX() //  []
         { info_tbl: [(c5aUX,
                       label: block_c5aUX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aUX: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.013550032 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$cmax_closure" {
     Data.Type.Coercion.$fOrdCoercion_$cmax_closure:
         const Data.Type.Coercion.$fOrdCoercion_$cmax_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c5aVw,
                       label: Data.Type.Coercion.$fOrdCoercion_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aVw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aVx; else goto c5aVy;
       c5aVx: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aVy: // global
           I64[Sp - 16] = block_c5aVt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5aVC; else goto c5aVu;
       u5aVC: // global
           call _c5aVt() args: 0, res: 0, upd: 0;
       c5aVu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aVt() //  []
         { info_tbl: [(c5aVt,
                       label: block_c5aVt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aVt: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.022718458 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$c>_closure" {
     Data.Type.Coercion.$fOrdCoercion_$c>_closure:
         const Data.Type.Coercion.$fOrdCoercion_$c>_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$c>_entry() //  [R2, R3]
         { info_tbl: [(c5aVW,
                       label: Data.Type.Coercion.$fOrdCoercion_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aVW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aW0; else goto c5aW1;
       c5aW0: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aW1: // global
           I64[Sp - 16] = block_c5aVT_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5aW9; else goto c5aVU;
       u5aW9: // global
           call _c5aVT() args: 0, res: 0, upd: 0;
       c5aVU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aVT() //  []
         { info_tbl: [(c5aVT,
                       label: block_c5aVT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aVT: // global
           _s5aBW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5aVZ_info;
           R1 = _s5aBW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5aW8; else goto c5aW3;
       u5aW8: // global
           call _c5aVZ() args: 0, res: 0, upd: 0;
       c5aW3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aVZ() //  []
         { info_tbl: [(c5aVZ,
                       label: block_c5aVZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aVZ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.035965752 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_$cmin_closure" {
     Data.Type.Coercion.$fOrdCoercion_$cmin_closure:
         const Data.Type.Coercion.$fOrdCoercion_$cmin_info;
 },
 Data.Type.Coercion.$fOrdCoercion_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c5aWy,
                       label: Data.Type.Coercion.$fOrdCoercion_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aWy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aWz; else goto c5aWA;
       c5aWz: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fOrdCoercion_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aWA: // global
           I64[Sp - 16] = block_c5aWv_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5aWE; else goto c5aWw;
       u5aWE: // global
           call _c5aWv() args: 0, res: 0, upd: 0;
       c5aWw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5aWv() //  []
         { info_tbl: [(c5aWv,
                       label: block_c5aWv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aWv: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.044513029 UTC

[section ""data" . Data.Type.Coercion.$fOrdCoercion_closure" {
     Data.Type.Coercion.$fOrdCoercion_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Type.Coercion.$fEqCoercion_closure+1;
         const Data.Type.Coercion.$fOrdCoercion_$ccompare_closure+2;
         const Data.Type.Coercion.$fOrdCoercion_$c<_closure+2;
         const Data.Type.Coercion.$fOrdCoercion_$c<=_closure+2;
         const Data.Type.Coercion.$fOrdCoercion_$c>_closure+2;
         const Data.Type.Coercion.$fEqCoercion_$c==_closure+2;
         const Data.Type.Coercion.$fOrdCoercion_$cmax_closure+2;
         const Data.Type.Coercion.$fOrdCoercion_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.047594913 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion_lexeme_closure" {
     Data.Type.Coercion.$fReadCoercion_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Type.Coercion.$fReadCoercion2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.051330083 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion1_closure" {
     Data.Type.Coercion.$fReadCoercion1_closure:
         const Data.Type.Coercion.$fReadCoercion1_info;
         const 0;
 },
 sat_s5aCd_entry() //  [R1]
         { info_tbl: [(c5aX8,
                       label: sat_s5aCd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aX8: // global
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s5aCg_entry() //  [R1, R2, R3]
         { info_tbl: [(c5aXe,
                       label: sat_s5aCg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aXe: // global
           _s5aCb::P64 = R3;
           _s5aCa::P64 = R2;
           _s5aCg::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c5aXf; else goto c5aXg;
       c5aXg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5aXi; else goto c5aXh;
       c5aXi: // global
           HpAlloc = 24;
           goto c5aXf;
       c5aXf: // global
           R3 = _s5aCb::P64;
           R2 = _s5aCa::P64;
           R1 = _s5aCg::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aXh: // global
           _s5aC9::P64 = P64[_s5aCg::P64 + 6];
           I64[Hp - 16] = sat_s5aCd_info;
           P64[Hp - 8] = _s5aC9::P64;
           P64[Hp] = _s5aCb::P64;
           I64[Sp - 8] = block_c5aXb_info;
           R3 = Hp - 15;
           R2 = Data.Type.Coercion.$fReadCoercion_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5aXb() //  [R1]
         { info_tbl: [(c5aXb,
                       label: block_c5aXb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aXb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5aXl; else goto c5aXk;
       c5aXl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5aXk: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$fReadCoercion1_entry() //  [R2, R3, R4]
         { info_tbl: [(c5aXm,
                       label: Data.Type.Coercion.$fReadCoercion1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aXm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c5aXq; else goto c5aXp;
       c5aXq: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fReadCoercion1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aXp: // global
           I64[Hp - 24] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s5aCg_info;
           P64[Hp] = Hp - 23;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.068830653 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion_$creadsPrec_closure" {
     Data.Type.Coercion.$fReadCoercion_$creadsPrec_closure:
         const Data.Type.Coercion.$fReadCoercion_$creadsPrec_info;
         const 0;
 },
 sat_s5aCj_entry() //  [R1]
         { info_tbl: [(c5aXU,
                       label: sat_s5aCj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aXU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aXV; else goto c5aXW;
       c5aXV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5aXW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Coercion.$fReadCoercion1_entry(R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Coercion.$fReadCoercion_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c5aXX,
                       label: Data.Type.Coercion.$fReadCoercion_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aXX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c5aY1; else goto c5aY0;
       c5aY1: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.$fReadCoercion_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5aY0: // global
           I64[Hp - 24] = sat_s5aCj_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.079237776 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion_$creadListPrec_closure" {
     Data.Type.Coercion.$fReadCoercion_$creadListPrec_closure:
         const Data.Type.Coercion.$fReadCoercion_$creadListPrec_info;
         const 0;
 },
 sat_s5aCl_entry() //  [R1, R2, R3]
         { info_tbl: [(c5aYn,
                       label: sat_s5aCl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aYn: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Coercion.$fReadCoercion1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$fReadCoercion_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c5aYq,
                       label: Data.Type.Coercion.$fReadCoercion_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aYq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5aYu; else goto c5aYt;
       c5aYu: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Type.Coercion.$fReadCoercion_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5aYt: // global
           I64[Hp - 8] = sat_s5aCl_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.088783033 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion_$creadList_closure" {
     Data.Type.Coercion.$fReadCoercion_$creadList_closure:
         const Data.Type.Coercion.$fReadCoercion_$creadList_info;
         const 0;
 },
 sat_s5aCn_entry() //  [R1, R2, R3]
         { info_tbl: [(c5aYQ,
                       label: sat_s5aCn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aYQ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Coercion.$fReadCoercion1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s5aCo_entry() //  [R1]
         { info_tbl: [(c5aYT,
                       label: sat_s5aCo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aYT: // global
           _s5aCo::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c5aYU; else goto c5aYV;
       c5aYV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5aYX; else goto c5aYW;
       c5aYX: // global
           HpAlloc = 16;
           goto c5aYU;
       c5aYU: // global
           R1 = _s5aCo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5aYW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s5aCo::P64;
           _s5aCm::P64 = P64[_s5aCo::P64 + 16];
           I64[Hp - 8] = sat_s5aCn_info;
           P64[Hp] = _s5aCm::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Type.Coercion.$fReadCoercion_$creadList_entry() //  [R2]
         { info_tbl: [(c5aYY,
                       label: Data.Type.Coercion.$fReadCoercion_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aYY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c5aZ2; else goto c5aZ1;
       c5aZ2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Type.Coercion.$fReadCoercion_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5aZ1: // global
           I64[Hp - 16] = sat_s5aCo_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.10077936 UTC

[section ""data" . Data.Type.Coercion.$fReadCoercion_closure" {
     Data.Type.Coercion.$fReadCoercion_closure:
         const Data.Type.Coercion.$fReadCoercion_info;
         const 0;
 },
 sat_s5aCt_entry() //  [R1]
         { info_tbl: [(c5aZu,
                       label: sat_s5aCt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aZu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aZv; else goto c5aZw;
       c5aZv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5aZw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Coercion.$fReadCoercion_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s5aCs_entry() //  [R1, R2, R3]
         { info_tbl: [(c5aZC,
                       label: sat_s5aCs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aZC: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Coercion.$fReadCoercion1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s5aCr_entry() //  [R1]
         { info_tbl: [(c5aZJ,
                       label: sat_s5aCr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aZJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5aZK; else goto c5aZL;
       c5aZK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5aZL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Coercion.$fReadCoercion_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s5aCq_entry() //  [R1, R2]
         { info_tbl: [(c5aZR,
                       label: sat_s5aCq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aZR: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Coercion.$fReadCoercion_$creadsPrec_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Coercion.$fReadCoercion_entry() //  [R2]
         { info_tbl: [(c5aZV,
                       label: Data.Type.Coercion.$fReadCoercion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5aZV: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c5aZZ; else goto c5aZY;
       c5aZZ: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Type.Coercion.$fReadCoercion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5aZY: // global
           I64[Hp - 112] = sat_s5aCt_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s5aCs_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s5aCr_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s5aCq_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 112;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.113975249 UTC

[section ""data" . Data.Type.Coercion.$fBoundedCoercion_closure" {
     Data.Type.Coercion.$fBoundedCoercion_closure:
         const Data.Type.Coercion.$fBoundedCoercion_info;
 },
 Data.Type.Coercion.$fBoundedCoercion_entry() //  [R2]
         { info_tbl: [(c5b0A,
                       label: Data.Type.Coercion.$fBoundedCoercion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5b0A: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c5b0E; else goto c5b0D;
       c5b0E: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Type.Coercion.$fBoundedCoercion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5b0D: // global
           I64[Hp - 32] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           _c5b0y::P64 = Hp - 31;
           P64[Hp - 8] = _c5b0y::P64;
           P64[Hp] = _c5b0y::P64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.118455306 UTC

[section ""data" . Data.Type.Coercion.coerceWith_closure" {
     Data.Type.Coercion.coerceWith_closure:
         const Data.Type.Coercion.coerceWith_info;
 },
 Data.Type.Coercion.coerceWith_entry() //  [R2, R3]
         { info_tbl: [(c5b0T,
                       label: Data.Type.Coercion.coerceWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5b0T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5b0X; else goto c5b0Y;
       c5b0X: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.coerceWith_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5b0Y: // global
           I64[Sp - 16] = block_c5b0Q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5b16; else goto c5b0R;
       u5b16: // global
           call _c5b0Q(R1) args: 0, res: 0, upd: 0;
       c5b0R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5b0Q() //  [R1]
         { info_tbl: [(c5b0Q,
                       label: block_c5b0Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5b0Q: // global
           I64[Sp] = block_c5b0W_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto u5b15; else goto c5b10;
       u5b15: // global
           call _c5b0W() args: 0, res: 0, upd: 0;
       c5b10: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5b0W() //  []
         { info_tbl: [(c5b0W,
                       label: block_c5b0W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5b0W: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.126562677 UTC

[section ""data" . Data.Type.Coercion.gcoerceWith_closure" {
     Data.Type.Coercion.gcoerceWith_closure:
         const Data.Type.Coercion.gcoerceWith_info;
 },
 Data.Type.Coercion.gcoerceWith_entry() //  [R2, R3]
         { info_tbl: [(c5b1t,
                       label: Data.Type.Coercion.gcoerceWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5b1t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5b1u; else goto c5b1v;
       c5b1u: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.gcoerceWith_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5b1v: // global
           I64[Sp - 16] = block_c5b1q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5b1z; else goto c5b1r;
       u5b1z: // global
           call _c5b1q(R1) args: 0, res: 0, upd: 0;
       c5b1r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5b1q() //  [R1]
         { info_tbl: [(c5b1q,
                       label: block_c5b1q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5b1q: // global
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.133889334 UTC

[section ""data" . Data.Type.Coercion.sym_closure" {
     Data.Type.Coercion.sym_closure:
         const Data.Type.Coercion.sym_info;
 },
 Data.Type.Coercion.sym_entry() //  [R2]
         { info_tbl: [(c5b1R,
                       label: Data.Type.Coercion.sym_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5b1R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5b1Y; else goto c5b1Z;
       c5b1Y: // global
           R2 = R2;
           R1 = Data.Type.Coercion.sym_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5b1Z: // global
           I64[Sp - 8] = block_c5b1O_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5b24; else goto c5b1P;
       u5b24: // global
           call _c5b1O(R1) args: 0, res: 0, upd: 0;
       c5b1P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5b1O() //  [R1]
         { info_tbl: [(c5b1O,
                       label: block_c5b1O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5b1O: // global
           I64[Sp] = block_c5b1U_info;
           R2 = P64[R1 + 7];
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5b1U() //  []
         { info_tbl: [(c5b1U,
                       label: block_c5b1U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5b1U: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c5b23; else goto c5b22;
       c5b23: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5b22: // global
           I64[Hp - 24] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 8] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.142091974 UTC

[section ""data" . Data.Type.Coercion.trans_closure" {
     Data.Type.Coercion.trans_closure:
         const Data.Type.Coercion.trans_info;
 },
 Data.Type.Coercion.trans_entry() //  [R2, R3]
         { info_tbl: [(c5b2u,
                       label: Data.Type.Coercion.trans_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5b2u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5b2I; else goto c5b2J;
       c5b2I: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Coercion.trans_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5b2J: // global
           I64[Sp - 16] = block_c5b2r_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5b2Q; else goto c5b2s;
       u5b2Q: // global
           call _c5b2r(R1) args: 0, res: 0, upd: 0;
       c5b2s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5b2r() //  [R1]
         { info_tbl: [(c5b2r,
                       label: block_c5b2r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5b2r: // global
           I64[Sp] = block_c5b2x_info;
           R2 = P64[R1 + 7];
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5b2x() //  []
         { info_tbl: [(c5b2x,
                       label: block_c5b2x_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5b2x: // global
           _s5aCL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5b2z_info;
           R1 = _s5aCL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u5b2R; else goto c5b2A;
       u5b2R: // global
           call _c5b2z(R1) args: 0, res: 0, upd: 0;
       c5b2A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5b2z() //  [R1]
         { info_tbl: [(c5b2z,
                       label: block_c5b2z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5b2z: // global
           I64[Sp] = block_c5b2E_info;
           R2 = P64[R1 + 7];
           call GHC.Types.coercible_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5b2E() //  []
         { info_tbl: [(c5b2E,
                       label: block_c5b2E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5b2E: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c5b2P; else goto c5b2O;
       c5b2P: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c5b2O: // global
           I64[Hp - 24] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 8] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.157861265 UTC

[section ""data" . Data.Type.Coercion.repr_closure" {
     Data.Type.Coercion.repr_closure:
         const Data.Type.Coercion.repr_info;
 },
 Data.Type.Coercion.repr_entry() //  [R2]
         { info_tbl: [(c5b3q,
                       label: Data.Type.Coercion.repr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5b3q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c5b3v; else goto c5b3w;
       c5b3v: // global
           R2 = R2;
           R1 = Data.Type.Coercion.repr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5b3w: // global
           I64[Sp - 8] = block_c5b3n_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u5b3A; else goto c5b3o;
       u5b3A: // global
           call _c5b3n(R1) args: 0, res: 0, upd: 0;
       c5b3o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5b3n() //  [R1]
         { info_tbl: [(c5b3n,
                       label: block_c5b3n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5b3n: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c5b3z; else goto c5b3y;
       c5b3z: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5b3y: // global
           I64[Hp - 24] = GHC.Types.MkCoercible_con_info;
           I64[Hp - 8] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.166864217 UTC

[section ""cstring" . Data.Type.Coercion.$trModule4_bytes" {
     Data.Type.Coercion.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.169031404 UTC

[section ""data" . Data.Type.Coercion.$trModule3_closure" {
     Data.Type.Coercion.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Coercion.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.170748208 UTC

[section ""cstring" . Data.Type.Coercion.$trModule2_bytes" {
     Data.Type.Coercion.$trModule2_bytes:
         I8[] [68,97,116,97,46,84,121,112,101,46,67,111,101,114,99,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.172704961 UTC

[section ""data" . Data.Type.Coercion.$trModule1_closure" {
     Data.Type.Coercion.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Coercion.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.175927118 UTC

[section ""data" . Data.Type.Coercion.$trModule_closure" {
     Data.Type.Coercion.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Type.Coercion.$trModule3_closure+1;
         const Data.Type.Coercion.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.178574371 UTC

[section ""data" . $krep_r59Bg_closure" {
     $krep_r59Bg_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.181075776 UTC

[section ""data" . $krep1_r59Bh_closure" {
     $krep1_r59Bh_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.183692815 UTC

[section ""data" . $krep2_r59Bi_closure" {
     $krep2_r59Bi_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r59Bh_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.186185257 UTC

[section ""data" . Data.Type.Coercion.$tcCoercion1_closure" {
     Data.Type.Coercion.$tcCoercion1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r59Bh_closure+2;
         const $krep2_r59Bi_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.188805963 UTC

[section ""data" . Data.Type.Coercion.$tcTestCoercion1_closure" {
     Data.Type.Coercion.$tcTestCoercion1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r59Bi_closure+4;
         const $krep_r59Bg_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.192165919 UTC

[section ""data" . $krep3_r59Bj_closure" {
     $krep3_r59Bj_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.194600724 UTC

[section ""data" . $krep4_r59Bk_closure" {
     $krep4_r59Bk_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.196903005 UTC

[section ""data" . $krep5_r59Bl_closure" {
     $krep5_r59Bl_closure:
         const :_con_info;
         const $krep3_r59Bj_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.199209003 UTC

[section ""data" . $krep6_r59Bm_closure" {
     $krep6_r59Bm_closure:
         const :_con_info;
         const $krep4_r59Bk_closure+2;
         const $krep5_r59Bl_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.201555847 UTC

[section ""data" . $krep7_r59Bn_closure" {
     $krep7_r59Bn_closure:
         const :_con_info;
         const $krep1_r59Bh_closure+2;
         const $krep6_r59Bm_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.204085568 UTC

[section ""data" . $krep8_r59Bo_closure" {
     $krep8_r59Bo_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcCoercible_closure;
         const $krep7_r59Bn_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.206204173 UTC

[section ""data" . Data.Type.Coercion.$tcCoercion2_closure" {
     Data.Type.Coercion.$tcCoercion2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Coercion.$fReadCoercion3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.20797389 UTC

[section ""data" . Data.Type.Coercion.$tcCoercion_closure" {
     Data.Type.Coercion.$tcCoercion_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Coercion.$trModule_closure+1;
         const Data.Type.Coercion.$tcCoercion2_closure+1;
         const Data.Type.Coercion.$tcCoercion1_closure+4;
         const 14885566513674463733;
         const 8268940906925368652;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.209934572 UTC

[section ""data" . $krep9_r59Bp_closure" {
     $krep9_r59Bp_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Type.Coercion.$tcCoercion_closure+1;
         const $krep7_r59Bn_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.21177139 UTC

[section ""data" . Data.Type.Coercion.$tc'Coercion1_closure" {
     Data.Type.Coercion.$tc'Coercion1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_r59Bo_closure+1;
         const $krep9_r59Bp_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.213693926 UTC

[section ""cstring" . Data.Type.Coercion.$tc'Coercion3_bytes" {
     Data.Type.Coercion.$tc'Coercion3_bytes:
         I8[] [39,67,111,101,114,99,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.215449303 UTC

[section ""data" . Data.Type.Coercion.$tc'Coercion2_closure" {
     Data.Type.Coercion.$tc'Coercion2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Coercion.$tc'Coercion3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.218703801 UTC

[section ""data" . Data.Type.Coercion.$tc'Coercion_closure" {
     Data.Type.Coercion.$tc'Coercion_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Coercion.$trModule_closure+1;
         const Data.Type.Coercion.$tc'Coercion2_closure+1;
         const Data.Type.Coercion.$tc'Coercion1_closure+4;
         const 16177208673276072700;
         const 13187043378465993605;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.220596898 UTC

[section ""cstring" . Data.Type.Coercion.$tcTestCoercion3_bytes" {
     Data.Type.Coercion.$tcTestCoercion3_bytes:
         I8[] [84,101,115,116,67,111,101,114,99,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.222417533 UTC

[section ""data" . Data.Type.Coercion.$tcTestCoercion2_closure" {
     Data.Type.Coercion.$tcTestCoercion2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Coercion.$tcTestCoercion3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.224119271 UTC

[section ""data" . Data.Type.Coercion.$tcTestCoercion_closure" {
     Data.Type.Coercion.$tcTestCoercion_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Coercion.$trModule_closure+1;
         const Data.Type.Coercion.$tcTestCoercion2_closure+1;
         const Data.Type.Coercion.$tcTestCoercion1_closure+4;
         const 14520160333183018944;
         const 2439357669602544154;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.226407655 UTC

[section ""data" . Data.Type.Coercion.Coercion_closure" {
     Data.Type.Coercion.Coercion_closure:
         const Data.Type.Coercion.Coercion_info;
 },
 Data.Type.Coercion.Coercion_entry() //  [R2]
         { info_tbl: [(c5b4k,
                       label: Data.Type.Coercion.Coercion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5b4k: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5b4o; else goto c5b4n;
       c5b4o: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Type.Coercion.Coercion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5b4n: // global
           I64[Hp - 8] = Data.Type.Coercion.Coercion_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.230420977 UTC

[Data.Type.Coercion.Coercion_con_entry() //  [R1]
         { info_tbl: [(c5b4v,
                       label: Data.Type.Coercion.Coercion_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,84,121,112,101,46,67,111,101,114,99,105,111,110,46,67,111,101,114,99,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5b4v: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:08.234791367 UTC

[section ""relreadonly" . S5aDk_srt" {
     S5aDk_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Type.Coercion.$fEnumCoercion1_closure;
         const Data.Type.Coercion.$fEnumCoercion_$ctoEnum_closure;
         const Data.Type.Coercion.$w$cenumFromTo_closure;
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromTo_closure;
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromThen_closure;
         const lvl1_r59Bc_closure;
         const Data.Type.Coercion.$w$cenumFrom_closure;
         const Data.Type.Coercion.$fEnumCoercion_$cenumFrom_closure;
         const Data.Type.Coercion.$w$cenumFromThenTo_closure;
         const Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo_closure;
         const lvl4_r59Bf_closure;
         const Data.Type.Coercion.$fEnumCoercion_closure;
         const Data.Type.Coercion.$fReadCoercion2_closure;
         const Data.Type.Coercion.$fShowCoercion_$cshowsPrec_closure;
         const Data.Type.Coercion.$fShowCoercion_$cshow_closure;
         const Data.Type.Coercion.$fShowCoercion1_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Type.Coercion.$fReadCoercion_lexeme_closure;
         const GHC.Read.list3_closure;
         const Data.Type.Coercion.$fReadCoercion1_closure;
         const Data.Type.Coercion.$fReadCoercion_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Type.Coercion.$fReadCoercion_$creadListPrec_closure;
         const Data.Type.Coercion.$fReadCoercion_$creadList_closure;
         const Data.Type.Coercion.$fReadCoercion_closure;
 }]

