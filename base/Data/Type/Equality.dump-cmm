
==================== Output Cmm ====================
2018-03-16 16:00:01.558205905 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:00:01.559122012 UTC

[section ""data" . Data.Type.Equality.$p1~_closure" {
     Data.Type.Equality.$p1~_closure:
         const Data.Type.Equality.$p1~_info;
 },
 Data.Type.Equality.$p1~_entry() //  [R2]
         { info_tbl: [(c56dS,
                       label: Data.Type.Equality.$p1~_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56dS: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.560038295 UTC

[section ""data" . Data.Type.Equality.testEquality_closure" {
     Data.Type.Equality.testEquality_closure:
         const Data.Type.Equality.testEquality_info;
 },
 Data.Type.Equality.testEquality_entry() //  [R2]
         { info_tbl: [(c56dZ,
                       label: Data.Type.Equality.testEquality_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56dZ: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.560744419 UTC

[section ""data" . Data.Type.Equality.$WHRefl_closure" {
     Data.Type.Equality.$WHRefl_closure:
         const Data.Type.Equality.HRefl_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.561398509 UTC

[section ""data" . Data.Type.Equality.$WRefl_closure" {
     Data.Type.Equality.$WRefl_closure:
         const Data.Type.Equality.Refl_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.562242969 UTC

[section ""data" . Data.Type.Equality.$f~kab_$cp1~_closure" {
     Data.Type.Equality.$f~kab_$cp1~_closure:
         const Data.Type.Equality.$f~kab_$cp1~_info;
 },
 Data.Type.Equality.$f~kab_$cp1~_entry() //  [R2]
         { info_tbl: [(c56e8,
                       label: Data.Type.Equality.$f~kab_$cp1~_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56e8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56e9; else goto c56ea;
       c56e9: // global
           R2 = R2;
           R1 = Data.Type.Equality.$f~kab_$cp1~_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56ea: // global
           I64[Sp - 16] = block_c56e6_info;
           _s568u::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s568u::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56e6() //  []
         { info_tbl: [(c56e6,
                       label: block_c56e6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56e6: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.563431937 UTC

[section ""data" . Data.Type.Equality.$f~kab_closure" {
     Data.Type.Equality.$f~kab_closure:
         const Data.Type.Equality.$f~kab_info;
 },
 Data.Type.Equality.$f~kab_entry() //  [R2]
         { info_tbl: [(c56eg,
                       label: Data.Type.Equality.$f~kab_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56eg: // global
           R2 = R2;
           call Data.Type.Equality.$f~kab_$cp1~_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.564145269 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:3_closure" {
     Data.Type.Equality.$fEnum:~:3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.565051226 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$cfromEnum_closure" {
     Data.Type.Equality.$fEnum:~:_$cfromEnum_closure:
         const Data.Type.Equality.$fEnum:~:_$cfromEnum_info;
 },
 Data.Type.Equality.$fEnum:~:_$cfromEnum_entry() //  [R2, R3]
         { info_tbl: [(c56es,
                       label: Data.Type.Equality.$fEnum:~:_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56es: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56et; else goto c56eu;
       c56et: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$cfromEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56eu: // global
           I64[Sp - 16] = block_c56en_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56en() //  []
         { info_tbl: [(c56en,
                       label: block_c56en_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56en: // global
           _s568w::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56ep_info;
           R1 = _s568w::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56ez; else goto c56eq;
       u56ez: // global
           call _c56ep() args: 0, res: 0, upd: 0;
       c56eq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56ep() //  []
         { info_tbl: [(c56ep,
                       label: block_c56ep_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ep: // global
           R1 = Data.Type.Equality.$fEnum:~:3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.566260487 UTC

[section ""cstring" . lvl_r5689_bytes" {
     lvl_r5689_bytes:
         I8[] [68,97,116,97,46,84,121,112,101,46,69,113,117,97,108,105,116,121,46,116,111,69,110,117,109,58,32,98,97,100,32,97,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.567189039 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:1_closure" {
     Data.Type.Equality.$fEnum:~:1_closure:
         const Data.Type.Equality.$fEnum:~:1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:1_entry() //  [R1]
         { info_tbl: [(c56eI,
                       label: Data.Type.Equality.$fEnum:~:1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56eI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c56eJ; else goto c56eK;
       c56eJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56eK: // global
           (_c56eD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c56eD::I64 == 0) goto c56eF; else goto c56eE;
       c56eF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c56eE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c56eD::I64;
           I64[Sp - 24] = block_c56eG_info;
           R2 = lvl_r5689_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c56eG() //  [R1]
         { info_tbl: [(c56eG,
                       label: block_c56eG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56eG: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.568718703 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$ctoEnum_closure" {
     Data.Type.Equality.$fEnum:~:_$ctoEnum_closure:
         const Data.Type.Equality.$fEnum:~:_$ctoEnum_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$ctoEnum_entry() //  [R2, R3]
         { info_tbl: [(c56eY,
                       label: Data.Type.Equality.$fEnum:~:_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56eY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56eZ; else goto c56f0;
       c56eZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$ctoEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56f0: // global
           I64[Sp - 16] = block_c56eT_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56eT() //  []
         { info_tbl: [(c56eT,
                       label: block_c56eT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56eT: // global
           _s568A::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56eV_info;
           R1 = _s568A::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56f9; else goto c56eW;
       u56f9: // global
           call _c56eV(R1) args: 0, res: 0, upd: 0;
       c56eW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56eV() //  [R1]
         { info_tbl: [(c56eV,
                       label: block_c56eV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56eV: // global
           if (I64[R1 + 7] == 0) goto c56f8; else goto c56f7;
       c56f8: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c56f7: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.570294299 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$csucc_closure" {
     Data.Type.Equality.$fEnum:~:_$csucc_closure:
         const Data.Type.Equality.$fEnum:~:_$csucc_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$csucc_entry() //  [R2, R3]
         { info_tbl: [(c56fi,
                       label: Data.Type.Equality.$fEnum:~:_$csucc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56fi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56fj; else goto c56fk;
       c56fj: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$csucc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56fk: // global
           I64[Sp - 16] = block_c56fe_info;
           _s568E::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s568E::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56fe() //  []
         { info_tbl: [(c56fe,
                       label: block_c56fe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56fe: // global
           _s568E::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56fg_info;
           R2 = _s568E::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56fg() //  []
         { info_tbl: [(c56fg,
                       label: block_c56fg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56fg: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.57243366 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromTo_closure" {
     Data.Type.Equality.$w$cenumFromTo_closure:
         const Data.Type.Equality.$w$cenumFromTo_info;
         const 0;
 },
 sat_s568P_entry() //  [R1]
         { info_tbl: [(c56fI,
                       label: sat_s568P_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56fI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56fJ; else goto c56fK;
       c56fJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56fK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s568N::I64 = I64[R1 + 24];
           if (_s568N::I64 != 0) goto c56fG; else goto c56fH;
       c56fG: // global
           R2 = _s568N::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s568J_entry(R2, R1) args: 24, res: 0, upd: 24;
       c56fH: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s568M_entry() //  [R1]
         { info_tbl: [(c56fV,
                       label: sat_s568M_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56fV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56fW; else goto c56fX;
       c56fW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56fX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c56fU; else goto c56fT;
       c56fU: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c56fT: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s568J_entry() //  [R1, R2]
         { info_tbl: [(c56fZ,
                       label: go_s568J_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56fZ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c56g3; else goto c56g2;
       c56g3: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56g2: // global
           I64[Hp - 72] = sat_s568P_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s568M_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c56g4,
                       label: Data.Type.Equality.$w$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56g4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56g5; else goto c56g6;
       c56g5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56g6: // global
           I64[Sp - 16] = block_c56fr_info;
           _s568G::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s568G::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56fr() //  []
         { info_tbl: [(c56fr,
                       label: block_c56fr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56fr: // global
           _s568G::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56ft_info;
           R2 = _s568G::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56ft() //  []
         { info_tbl: [(c56ft,
                       label: block_c56ft_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ft: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56ga; else goto c56g9;
       c56ga: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c56g9: // global
           I64[Hp - 8] = go_s568J_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call go_s568J_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.575299914 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$cenumFromTo_closure" {
     Data.Type.Equality.$fEnum:~:_$cenumFromTo_closure:
         const Data.Type.Equality.$fEnum:~:_$cenumFromTo_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$cenumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c56gi,
                       label: Data.Type.Equality.$fEnum:~:_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56gi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c56gm; else goto c56gn;
       c56gm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$cenumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56gn: // global
           I64[Sp - 24] = block_c56gf_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u56gv; else goto c56gg;
       u56gv: // global
           call _c56gf(R1) args: 0, res: 0, upd: 0;
       c56gg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56gf() //  [R1]
         { info_tbl: [(c56gf,
                       label: block_c56gf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56gf: // global
           I64[Sp] = block_c56gl_info;
           _s568T::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s568T::P64;
           if (R1 & 7 != 0) goto u56gu; else goto c56gp;
       u56gu: // global
           call _c56gl(R1) args: 0, res: 0, upd: 0;
       c56gp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56gl() //  [R1]
         { info_tbl: [(c56gl,
                       label: block_c56gl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56gl: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromTo_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.576987078 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:2_closure" {
     Data.Type.Equality.$fEnum:~:2_closure:
         const Data.Type.Equality.$fEnum:~:2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:2_entry() //  [R1]
         { info_tbl: [(c56gC,
                       label: Data.Type.Equality.$fEnum:~:2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56gC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56gD; else goto c56gE;
       c56gD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56gE: // global
           (_c56gz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c56gz::I64 == 0) goto c56gB; else goto c56gA;
       c56gB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c56gA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c56gz::I64;
           R3 = 0;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.Enum.efdInt_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.578488916 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromThen_closure" {
     Data.Type.Equality.$w$cenumFromThen_closure:
         const Data.Type.Equality.$w$cenumFromThen_info;
         const 0;
 },
 sat_s568Y_entry() //  [R1, R2]
         { info_tbl: [(c56gS,
                       label: sat_s568Y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56gS: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$ctoEnum_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFromThen_entry() //  [R2, R3, R4]
         { info_tbl: [(c56gV,
                       label: Data.Type.Equality.$w$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56gV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56gW; else goto c56gX;
       c56gW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56gX: // global
           I64[Sp - 16] = block_c56gJ_info;
           _s568V::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s568V::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56gJ() //  []
         { info_tbl: [(c56gJ,
                       label: block_c56gJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56gJ: // global
           I64[Sp] = block_c56gL_info;
           R2 = P64[Sp + 8];
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56gL() //  []
         { info_tbl: [(c56gL,
                       label: block_c56gL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56gL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56h1; else goto c56h0;
       c56h1: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c56h0: // global
           I64[Hp - 8] = sat_s568Y_info;
           P64[Hp] = P64[Sp + 8];
           R3 = Data.Type.Equality.$fEnum:~:2_closure;
           R2 = Hp - 7;
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.580300625 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$cenumFromThen_closure" {
     Data.Type.Equality.$fEnum:~:_$cenumFromThen_closure:
         const Data.Type.Equality.$fEnum:~:_$cenumFromThen_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$cenumFromThen_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(c56h9,
                       label: Data.Type.Equality.$fEnum:~:_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56h9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c56hd; else goto c56he;
       c56hd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$cenumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56he: // global
           I64[Sp - 24] = block_c56h6_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u56hm; else goto c56h7;
       u56hm: // global
           call _c56h6(R1) args: 0, res: 0, upd: 0;
       c56h7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56h6() //  [R1]
         { info_tbl: [(c56h6,
                       label: block_c56h6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56h6: // global
           I64[Sp] = block_c56hc_info;
           _s5692::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s5692::P64;
           if (R1 & 7 != 0) goto u56hl; else goto c56hg;
       u56hl: // global
           call _c56hc(R1) args: 0, res: 0, upd: 0;
       c56hg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56hc() //  [R1]
         { info_tbl: [(c56hc,
                       label: block_c56hc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56hc: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromThen_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.582780188 UTC

[section ""data" . Data.Type.Equality.$w$cenumFrom_closure" {
     Data.Type.Equality.$w$cenumFrom_closure:
         const Data.Type.Equality.$w$cenumFrom_info;
         const 0;
 },
 sat_s569c_entry() //  [R1]
         { info_tbl: [(c56hI,
                       label: sat_s569c_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56hI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56hJ; else goto c56hK;
       c56hJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56hK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s569a::I64 = I64[R1 + 24];
           if (_s569a::I64 != 9223372036854775807) goto c56hG; else goto c56hH;
       c56hG: // global
           R2 = _s569a::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s5696_entry(R2, R1) args: 24, res: 0, upd: 24;
       c56hH: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s5699_entry() //  [R1]
         { info_tbl: [(c56hV,
                       label: sat_s5699_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56hV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56hW; else goto c56hX;
       c56hW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56hX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c56hU; else goto c56hT;
       c56hU: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c56hT: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s5696_entry() //  [R1, R2]
         { info_tbl: [(c56hZ,
                       label: go_s5696_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56hZ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c56i3; else goto c56i2;
       c56i3: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56i2: // global
           I64[Hp - 72] = sat_s569c_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s5699_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFrom_entry() //  [R2, R3]
         { info_tbl: [(c56i4,
                       label: Data.Type.Equality.$w$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56i4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56i5; else goto c56i6;
       c56i5: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56i6: // global
           I64[Sp - 16] = block_c56hr_info;
           _s5694::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s5694::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56hr() //  []
         { info_tbl: [(c56hr,
                       label: block_c56hr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56hr: // global
           _s5694::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56ht_info;
           R2 = _s5694::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56ht() //  []
         { info_tbl: [(c56ht,
                       label: block_c56ht_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ht: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56ia; else goto c56i9;
       c56ia: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c56i9: // global
           I64[Hp - 8] = go_s5696_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call go_s5696_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.585560935 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$cenumFrom_closure" {
     Data.Type.Equality.$fEnum:~:_$cenumFrom_closure:
         const Data.Type.Equality.$fEnum:~:_$cenumFrom_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$cenumFrom_entry() //  [R2, R3]
         { info_tbl: [(c56ii,
                       label: Data.Type.Equality.$fEnum:~:_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ii: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56ij; else goto c56ik;
       c56ij: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$cenumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56ik: // global
           I64[Sp - 16] = block_c56if_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56io; else goto c56ig;
       u56io: // global
           call _c56if(R1) args: 0, res: 0, upd: 0;
       c56ig: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56if() //  [R1]
         { info_tbl: [(c56if,
                       label: block_c56if_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56if: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Type.Equality.$w$cenumFrom_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.587970883 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromThenTo_closure" {
     Data.Type.Equality.$w$cenumFromThenTo_closure:
         const Data.Type.Equality.$w$cenumFromThenTo_info;
         const 0;
 },
 sat_s569p_entry() //  [R1]
         { info_tbl: [(c56iN,
                       label: sat_s569p_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56iN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56iO; else goto c56iP;
       c56iO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56iP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s569k_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s569o_entry() //  [R1]
         { info_tbl: [(c56iY,
                       label: sat_s569o_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56iY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56iZ; else goto c56j0;
       c56iZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56j0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c56iX; else goto c56iW;
       c56iX: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c56iW: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s569r_entry() //  [R1]
         { info_tbl: [(c56ja,
                       label: sat_s569r_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ja: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56jb; else goto c56jc;
       c56jb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56jc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c56j9; else goto c56j8;
       c56j9: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c56j8: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s569k_entry() //  [R1, R2]
         { info_tbl: [(c56jg,
                       label: go_up_s569k_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56jg: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c56jk; else goto c56jj;
       c56jk: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56jj: // global
           if (%MO_S_Le_W64(R2, 0)) goto c56je; else goto c56jf;
       c56je: // global
           I64[Hp - 72] = sat_s569p_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s569o_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c56jf: // global
           I64[Hp - 72] = sat_s569r_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c56jm::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c56jm::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569s_entry() //  [R1]
         { info_tbl: [(c56jn,
                       label: sat_s569s_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56jn: // global
           _s569s::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c56jo; else goto c56jp;
       c56jp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56jr; else goto c56jq;
       c56jr: // global
           HpAlloc = 16;
           goto c56jo;
       c56jo: // global
           R1 = _s569s::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56jq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s569s::P64;
           I64[Hp - 8] = go_up_s569k_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call go_up_s569k_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$w$cenumFromThenTo_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c56js,
                       label: Data.Type.Equality.$w$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56js: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56jt; else goto c56ju;
       c56jt: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56ju: // global
           I64[Sp - 16] = block_c56it_info;
           _s569g::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s569g::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56it() //  []
         { info_tbl: [(c56it,
                       label: block_c56it_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56it: // global
           _s569g::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56iv_info;
           R2 = _s569g::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56iv() //  []
         { info_tbl: [(c56iv,
                       label: block_c56iv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56iv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56jy; else goto c56jx;
       c56jy: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c56jx: // global
           I64[Hp - 8] = sat_s569s_info;
           R2 = Hp - 8;
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.592002683 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_closure" {
     Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_closure:
         const Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(c56jG,
                       label: Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56jG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c56jW; else goto c56jX;
       c56jW: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56jX: // global
           I64[Sp - 32] = block_c56jD_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u56k5; else goto c56jE;
       u56k5: // global
           call _c56jD(R1) args: 0, res: 0, upd: 0;
       c56jE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56jD() //  [R1]
         { info_tbl: [(c56jD,
                       label: block_c56jD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56jD: // global
           I64[Sp] = block_c56jJ_info;
           _s569x::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s569x::P64;
           if (R1 & 7 != 0) goto u56k4; else goto c56jK;
       u56k4: // global
           call _c56jJ(R1) args: 0, res: 0, upd: 0;
       c56jK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56jJ() //  [R1]
         { info_tbl: [(c56jJ,
                       label: block_c56jJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56jJ: // global
           I64[Sp] = block_c56jO_info;
           _s569y::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s569y::P64;
           if (R1 & 7 != 0) goto u56k6; else goto c56jP;
       u56k6: // global
           call _c56jO(R1) args: 0, res: 0, upd: 0;
       c56jP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56jO() //  [R1]
         { info_tbl: [(c56jO,
                       label: block_c56jO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56jO: // global
           _s569y::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c56jT_info;
           R5 = R1;
           R4 = _s569y::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromThenTo_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56jT() //  [R1, R2]
         { info_tbl: [(c56jT,
                       label: block_c56jT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56jT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c56k3; else goto c56k2;
       c56k3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c56k2: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.595338069 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_closure" {
     Data.Type.Equality.$fEnum:~:_closure:
         const Data.Type.Equality.$fEnum:~:_info;
         const 0;
 },
 sat_s569L_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c56kg,
                       label: sat_s569L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56kg: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569K_entry() //  [R1, R2, R3]
         { info_tbl: [(c56ko,
                       label: sat_s569K_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ko: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fEnum:~:_$cenumFromTo_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569J_entry() //  [R1, R2, R3]
         { info_tbl: [(c56kw,
                       label: sat_s569J_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56kw: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fEnum:~:_$cenumFromThen_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569I_entry() //  [R1, R2]
         { info_tbl: [(c56kE,
                       label: sat_s569I_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56kE: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$cenumFrom_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569H_entry() //  [R1, R2]
         { info_tbl: [(c56kM,
                       label: sat_s569H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56kM: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$cfromEnum_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569G_entry() //  [R1, R2]
         { info_tbl: [(c56kU,
                       label: sat_s569G_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56kU: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$ctoEnum_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569F_entry() //  [R1, R2]
         { info_tbl: [(c56l2,
                       label: sat_s569F_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56l2: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$csucc_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569E_entry() //  [R1, R2]
         { info_tbl: [(c56la,
                       label: sat_s569E_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56la: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$csucc_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fEnum:~:_entry() //  [R2]
         { info_tbl: [(c56le,
                       label: Data.Type.Equality.$fEnum:~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56le: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto c56li; else goto c56lh;
       c56li: // global
           HpAlloc = 200;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56lh: // global
           I64[Hp - 192] = sat_s569L_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s569K_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s569J_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_s569I_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s569H_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s569G_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s569F_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s569E_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = Hp - 95;
           P64[Hp - 40] = Hp - 111;
           P64[Hp - 32] = Hp - 127;
           P64[Hp - 24] = Hp - 143;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 174;
           P64[Hp] = Hp - 189;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.598394436 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$cfromEnum_closure" {
     Data.Type.Equality.$fEnum:~~:_$cfromEnum_closure:
         const Data.Type.Equality.$fEnum:~~:_$cfromEnum_info;
 },
 Data.Type.Equality.$fEnum:~~:_$cfromEnum_entry() //  [R2, R3]
         { info_tbl: [(c56ls,
                       label: Data.Type.Equality.$fEnum:~~:_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ls: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56lt; else goto c56lu;
       c56lt: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$cfromEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56lu: // global
           I64[Sp - 16] = block_c56ln_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56ln() //  []
         { info_tbl: [(c56ln,
                       label: block_c56ln_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ln: // global
           _s569N::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56lp_info;
           R1 = _s569N::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56lz; else goto c56lq;
       u56lz: // global
           call _c56lp() args: 0, res: 0, upd: 0;
       c56lq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56lp() //  []
         { info_tbl: [(c56lp,
                       label: block_c56lp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56lp: // global
           R1 = Data.Type.Equality.$fEnum:~:3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.599921165 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:1_closure" {
     Data.Type.Equality.$fEnum:~~:1_closure:
         const Data.Type.Equality.$fEnum:~~:1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:1_entry() //  [R1]
         { info_tbl: [(c56lI,
                       label: Data.Type.Equality.$fEnum:~~:1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56lI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c56lJ; else goto c56lK;
       c56lJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56lK: // global
           (_c56lD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c56lD::I64 == 0) goto c56lF; else goto c56lE;
       c56lF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c56lE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c56lD::I64;
           I64[Sp - 24] = block_c56lG_info;
           R2 = lvl_r5689_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c56lG() //  [R1]
         { info_tbl: [(c56lG,
                       label: block_c56lG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56lG: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.601484847 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$ctoEnum_closure" {
     Data.Type.Equality.$fEnum:~~:_$ctoEnum_closure:
         const Data.Type.Equality.$fEnum:~~:_$ctoEnum_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$ctoEnum_entry() //  [R2, R3]
         { info_tbl: [(c56lX,
                       label: Data.Type.Equality.$fEnum:~~:_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56lX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56lY; else goto c56lZ;
       c56lY: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$ctoEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56lZ: // global
           I64[Sp - 16] = block_c56lS_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56lS() //  []
         { info_tbl: [(c56lS,
                       label: block_c56lS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56lS: // global
           _s569R::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56lU_info;
           R1 = _s569R::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56m8; else goto c56lV;
       u56m8: // global
           call _c56lU(R1) args: 0, res: 0, upd: 0;
       c56lV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56lU() //  [R1]
         { info_tbl: [(c56lU,
                       label: block_c56lU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56lU: // global
           if (I64[R1 + 7] == 0) goto c56m7; else goto c56m6;
       c56m7: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c56m6: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.605826838 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$csucc_closure" {
     Data.Type.Equality.$fEnum:~~:_$csucc_closure:
         const Data.Type.Equality.$fEnum:~~:_$csucc_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$csucc_entry() //  [R2, R3]
         { info_tbl: [(c56mh,
                       label: Data.Type.Equality.$fEnum:~~:_$csucc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56mh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56mi; else goto c56mj;
       c56mi: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$csucc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56mj: // global
           I64[Sp - 16] = block_c56md_info;
           _s569V::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s569V::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56md() //  []
         { info_tbl: [(c56md,
                       label: block_c56md_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56md: // global
           _s569V::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56mf_info;
           R2 = _s569V::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56mf() //  []
         { info_tbl: [(c56mf,
                       label: block_c56mf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56mf: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.608130383 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromTo1_closure" {
     Data.Type.Equality.$w$cenumFromTo1_closure:
         const Data.Type.Equality.$w$cenumFromTo1_info;
         const 0;
 },
 sat_s56a6_entry() //  [R1]
         { info_tbl: [(c56mH,
                       label: sat_s56a6_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56mH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56mI; else goto c56mJ;
       c56mI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56mJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s56a4::I64 = I64[R1 + 24];
           if (_s56a4::I64 != 0) goto c56mF; else goto c56mG;
       c56mF: // global
           R2 = _s56a4::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s56a0_entry(R2, R1) args: 24, res: 0, upd: 24;
       c56mG: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56a3_entry() //  [R1]
         { info_tbl: [(c56mU,
                       label: sat_s56a3_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56mU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56mV; else goto c56mW;
       c56mV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56mW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c56mT; else goto c56mS;
       c56mT: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c56mS: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s56a0_entry() //  [R1, R2]
         { info_tbl: [(c56mY,
                       label: go_s56a0_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56mY: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c56n2; else goto c56n1;
       c56n2: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56n1: // global
           I64[Hp - 72] = sat_s56a6_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s56a3_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFromTo1_entry() //  [R2, R3, R4]
         { info_tbl: [(c56n3,
                       label: Data.Type.Equality.$w$cenumFromTo1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56n3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56n4; else goto c56n5;
       c56n4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromTo1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56n5: // global
           I64[Sp - 16] = block_c56mq_info;
           _s569X::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s569X::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56mq() //  []
         { info_tbl: [(c56mq,
                       label: block_c56mq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56mq: // global
           _s569X::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56ms_info;
           R2 = _s569X::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56ms() //  []
         { info_tbl: [(c56ms,
                       label: block_c56ms_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ms: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56n9; else goto c56n8;
       c56n9: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c56n8: // global
           I64[Hp - 8] = go_s56a0_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call go_s56a0_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.611416799 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$cenumFromTo_closure" {
     Data.Type.Equality.$fEnum:~~:_$cenumFromTo_closure:
         const Data.Type.Equality.$fEnum:~~:_$cenumFromTo_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$cenumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c56nh,
                       label: Data.Type.Equality.$fEnum:~~:_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56nh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c56nl; else goto c56nm;
       c56nl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$cenumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56nm: // global
           I64[Sp - 24] = block_c56ne_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u56nu; else goto c56nf;
       u56nu: // global
           call _c56ne(R1) args: 0, res: 0, upd: 0;
       c56nf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56ne() //  [R1]
         { info_tbl: [(c56ne,
                       label: block_c56ne_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ne: // global
           I64[Sp] = block_c56nk_info;
           _s56aa::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s56aa::P64;
           if (R1 & 7 != 0) goto u56nt; else goto c56no;
       u56nt: // global
           call _c56nk(R1) args: 0, res: 0, upd: 0;
       c56no: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56nk() //  [R1]
         { info_tbl: [(c56nk,
                       label: block_c56nk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56nk: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromTo1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.613366389 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromThen1_closure" {
     Data.Type.Equality.$w$cenumFromThen1_closure:
         const Data.Type.Equality.$w$cenumFromThen1_info;
         const 0;
 },
 sat_s56af_entry() //  [R1, R2]
         { info_tbl: [(c56nI,
                       label: sat_s56af_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56nI: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$ctoEnum_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFromThen1_entry() //  [R2, R3, R4]
         { info_tbl: [(c56nL,
                       label: Data.Type.Equality.$w$cenumFromThen1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56nL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56nM; else goto c56nN;
       c56nM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromThen1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56nN: // global
           I64[Sp - 16] = block_c56nz_info;
           _s56ac::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s56ac::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56nz() //  []
         { info_tbl: [(c56nz,
                       label: block_c56nz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56nz: // global
           I64[Sp] = block_c56nB_info;
           R2 = P64[Sp + 8];
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56nB() //  []
         { info_tbl: [(c56nB,
                       label: block_c56nB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56nB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56nR; else goto c56nQ;
       c56nR: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c56nQ: // global
           I64[Hp - 8] = sat_s56af_info;
           P64[Hp] = P64[Sp + 8];
           R3 = Data.Type.Equality.$fEnum:~:2_closure;
           R2 = Hp - 7;
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.615260949 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$cenumFromThen_closure" {
     Data.Type.Equality.$fEnum:~~:_$cenumFromThen_closure:
         const Data.Type.Equality.$fEnum:~~:_$cenumFromThen_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$cenumFromThen_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c56nZ,
                       label: Data.Type.Equality.$fEnum:~~:_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56nZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c56o3; else goto c56o4;
       c56o3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$cenumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56o4: // global
           I64[Sp - 24] = block_c56nW_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u56oc; else goto c56nX;
       u56oc: // global
           call _c56nW(R1) args: 0, res: 0, upd: 0;
       c56nX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56nW() //  [R1]
         { info_tbl: [(c56nW,
                       label: block_c56nW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56nW: // global
           I64[Sp] = block_c56o2_info;
           _s56aj::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s56aj::P64;
           if (R1 & 7 != 0) goto u56ob; else goto c56o6;
       u56ob: // global
           call _c56o2(R1) args: 0, res: 0, upd: 0;
       c56o6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56o2() //  [R1]
         { info_tbl: [(c56o2,
                       label: block_c56o2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56o2: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromThen1_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.617633979 UTC

[section ""data" . Data.Type.Equality.$w$cenumFrom1_closure" {
     Data.Type.Equality.$w$cenumFrom1_closure:
         const Data.Type.Equality.$w$cenumFrom1_info;
         const 0;
 },
 sat_s56at_entry() //  [R1]
         { info_tbl: [(c56oy,
                       label: sat_s56at_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56oy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56oz; else goto c56oA;
       c56oz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56oA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s56ar::I64 = I64[R1 + 24];
           if (_s56ar::I64 != 9223372036854775807) goto c56ow; else goto c56ox;
       c56ow: // global
           R2 = _s56ar::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s56an_entry(R2, R1) args: 24, res: 0, upd: 24;
       c56ox: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56aq_entry() //  [R1]
         { info_tbl: [(c56oL,
                       label: sat_s56aq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56oL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56oM; else goto c56oN;
       c56oM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56oN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c56oK; else goto c56oJ;
       c56oK: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c56oJ: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s56an_entry() //  [R1, R2]
         { info_tbl: [(c56oP,
                       label: go_s56an_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56oP: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c56oT; else goto c56oS;
       c56oT: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56oS: // global
           I64[Hp - 72] = sat_s56at_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s56aq_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFrom1_entry() //  [R2, R3]
         { info_tbl: [(c56oU,
                       label: Data.Type.Equality.$w$cenumFrom1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56oU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56oV; else goto c56oW;
       c56oV: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFrom1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56oW: // global
           I64[Sp - 16] = block_c56oh_info;
           _s56al::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s56al::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56oh() //  []
         { info_tbl: [(c56oh,
                       label: block_c56oh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56oh: // global
           _s56al::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56oj_info;
           R2 = _s56al::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56oj() //  []
         { info_tbl: [(c56oj,
                       label: block_c56oj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56oj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56p0; else goto c56oZ;
       c56p0: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c56oZ: // global
           I64[Hp - 8] = go_s56an_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call go_s56an_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.620329061 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$cenumFrom_closure" {
     Data.Type.Equality.$fEnum:~~:_$cenumFrom_closure:
         const Data.Type.Equality.$fEnum:~~:_$cenumFrom_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$cenumFrom_entry() //  [R2, R3]
         { info_tbl: [(c56p8,
                       label: Data.Type.Equality.$fEnum:~~:_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56p8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56p9; else goto c56pa;
       c56p9: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$cenumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56pa: // global
           I64[Sp - 16] = block_c56p5_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56pe; else goto c56p6;
       u56pe: // global
           call _c56p5(R1) args: 0, res: 0, upd: 0;
       c56p6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56p5() //  [R1]
         { info_tbl: [(c56p5,
                       label: block_c56p5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56p5: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Type.Equality.$w$cenumFrom1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.622821983 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromThenTo1_closure" {
     Data.Type.Equality.$w$cenumFromThenTo1_closure:
         const Data.Type.Equality.$w$cenumFromThenTo1_info;
         const 0;
 },
 sat_s56aG_entry() //  [R1]
         { info_tbl: [(c56pD,
                       label: sat_s56aG_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56pD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56pE; else goto c56pF;
       c56pE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56pF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s56aB_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56aF_entry() //  [R1]
         { info_tbl: [(c56pO,
                       label: sat_s56aF_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56pO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56pP; else goto c56pQ;
       c56pP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56pQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c56pN; else goto c56pM;
       c56pN: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c56pM: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56aI_entry() //  [R1]
         { info_tbl: [(c56q0,
                       label: sat_s56aI_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56q0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56q1; else goto c56q2;
       c56q1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56q2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c56pZ; else goto c56pY;
       c56pZ: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c56pY: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s56aB_entry() //  [R1, R2]
         { info_tbl: [(c56q6,
                       label: go_up_s56aB_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56q6: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c56qa; else goto c56q9;
       c56qa: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56q9: // global
           if (%MO_S_Le_W64(R2, 0)) goto c56q4; else goto c56q5;
       c56q4: // global
           I64[Hp - 72] = sat_s56aG_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s56aF_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c56q5: // global
           I64[Hp - 72] = sat_s56aI_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c56qc::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c56qc::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56aJ_entry() //  [R1]
         { info_tbl: [(c56qd,
                       label: sat_s56aJ_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56qd: // global
           _s56aJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c56qe; else goto c56qf;
       c56qf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56qh; else goto c56qg;
       c56qh: // global
           HpAlloc = 16;
           goto c56qe;
       c56qe: // global
           R1 = _s56aJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56qg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s56aJ::P64;
           I64[Hp - 8] = go_up_s56aB_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call go_up_s56aB_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$w$cenumFromThenTo1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c56qi,
                       label: Data.Type.Equality.$w$cenumFromThenTo1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56qi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56qj; else goto c56qk;
       c56qj: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromThenTo1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56qk: // global
           I64[Sp - 16] = block_c56pj_info;
           _s56ax::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s56ax::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56pj() //  []
         { info_tbl: [(c56pj,
                       label: block_c56pj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56pj: // global
           _s56ax::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56pl_info;
           R2 = _s56ax::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56pl() //  []
         { info_tbl: [(c56pl,
                       label: block_c56pl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56pl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56qo; else goto c56qn;
       c56qo: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c56qn: // global
           I64[Hp - 8] = sat_s56aJ_info;
           R2 = Hp - 8;
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.626494021 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_closure" {
     Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_closure:
         const Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(c56qw,
                       label: Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56qw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c56qM; else goto c56qN;
       c56qM: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56qN: // global
           I64[Sp - 32] = block_c56qt_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u56qV; else goto c56qu;
       u56qV: // global
           call _c56qt(R1) args: 0, res: 0, upd: 0;
       c56qu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56qt() //  [R1]
         { info_tbl: [(c56qt,
                       label: block_c56qt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56qt: // global
           I64[Sp] = block_c56qz_info;
           _s56aO::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s56aO::P64;
           if (R1 & 7 != 0) goto u56qU; else goto c56qA;
       u56qU: // global
           call _c56qz(R1) args: 0, res: 0, upd: 0;
       c56qA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56qz() //  [R1]
         { info_tbl: [(c56qz,
                       label: block_c56qz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56qz: // global
           I64[Sp] = block_c56qE_info;
           _s56aP::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s56aP::P64;
           if (R1 & 7 != 0) goto u56qW; else goto c56qF;
       u56qW: // global
           call _c56qE(R1) args: 0, res: 0, upd: 0;
       c56qF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56qE() //  [R1]
         { info_tbl: [(c56qE,
                       label: block_c56qE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56qE: // global
           _s56aP::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c56qJ_info;
           R5 = R1;
           R4 = _s56aP::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromThenTo1_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56qJ() //  [R1, R2]
         { info_tbl: [(c56qJ,
                       label: block_c56qJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56qJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c56qT; else goto c56qS;
       c56qT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c56qS: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.629586979 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_closure" {
     Data.Type.Equality.$fEnum:~~:_closure:
         const Data.Type.Equality.$fEnum:~~:_info;
         const 0;
 },
 sat_s56b2_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c56r6,
                       label: sat_s56b2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56r6: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56b1_entry() //  [R1, R2, R3]
         { info_tbl: [(c56re,
                       label: sat_s56b1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56re: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fEnum:~~:_$cenumFromTo_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56b0_entry() //  [R1, R2, R3]
         { info_tbl: [(c56rm,
                       label: sat_s56b0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56rm: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fEnum:~~:_$cenumFromThen_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56aZ_entry() //  [R1, R2]
         { info_tbl: [(c56ru,
                       label: sat_s56aZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ru: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$cenumFrom_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56aY_entry() //  [R1, R2]
         { info_tbl: [(c56rC,
                       label: sat_s56aY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56rC: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$cfromEnum_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56aX_entry() //  [R1, R2]
         { info_tbl: [(c56rK,
                       label: sat_s56aX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56rK: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$ctoEnum_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56aW_entry() //  [R1, R2]
         { info_tbl: [(c56rS,
                       label: sat_s56aW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56rS: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$csucc_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56aV_entry() //  [R1, R2]
         { info_tbl: [(c56s0,
                       label: sat_s56aV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56s0: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$csucc_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fEnum:~~:_entry() //  [R2]
         { info_tbl: [(c56s4,
                       label: Data.Type.Equality.$fEnum:~~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56s4: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto c56s8; else goto c56s7;
       c56s8: // global
           HpAlloc = 200;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56s7: // global
           I64[Hp - 192] = sat_s56b2_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s56b1_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s56b0_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_s56aZ_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s56aY_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s56aX_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s56aW_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s56aV_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = Hp - 95;
           P64[Hp - 40] = Hp - 111;
           P64[Hp - 32] = Hp - 127;
           P64[Hp - 24] = Hp - 143;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 174;
           P64[Hp] = Hp - 189;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.632083755 UTC

[section ""data" . Data.Type.Equality.$fTestEqualityk:~:1_closure" {
     Data.Type.Equality.$fTestEqualityk:~:1_closure:
         const GHC.Base.Just_con_info;
         const Data.Type.Equality.$WRefl_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.633085251 UTC

[section ""data" . Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_closure" {
     Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_closure:
         const Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_info;
 },
 Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(c56sg,
                       label: Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56sg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56sk; else goto c56sl;
       c56sk: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56sl: // global
           I64[Sp - 16] = block_c56sd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56st; else goto c56se;
       u56st: // global
           call _c56sd() args: 0, res: 0, upd: 0;
       c56se: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56sd() //  []
         { info_tbl: [(c56sd,
                       label: block_c56sd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56sd: // global
           _s56b4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56sj_info;
           R1 = _s56b4::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56ss; else goto c56sn;
       u56ss: // global
           call _c56sj() args: 0, res: 0, upd: 0;
       c56sn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56sj() //  []
         { info_tbl: [(c56sj,
                       label: block_c56sj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56sj: // global
           R1 = Data.Type.Equality.$fTestEqualityk:~:1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.634478706 UTC

[section ""data" . Data.Type.Equality.$fTestEqualityk:~:_closure" {
     Data.Type.Equality.$fTestEqualityk:~:_closure:
         const Data.Type.Equality.$fTestEqualityk:~:_info;
 },
 Data.Type.Equality.$fTestEqualityk:~:_entry() //  [R2, R3]
         { info_tbl: [(c56sy,
                       label: Data.Type.Equality.$fTestEqualityk:~:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56sy: // global
           R3 = R3;
           R2 = R2;
           call Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_entry(R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.6355153 UTC

[section ""data" . Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_closure" {
     Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_closure:
         const Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_info;
 },
 Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(c56sI,
                       label: Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56sI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56sM; else goto c56sN;
       c56sM: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56sN: // global
           I64[Sp - 16] = block_c56sF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56sV; else goto c56sG;
       u56sV: // global
           call _c56sF() args: 0, res: 0, upd: 0;
       c56sG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56sF() //  []
         { info_tbl: [(c56sF,
                       label: block_c56sF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56sF: // global
           _s56b8::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56sL_info;
           R1 = _s56b8::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56sU; else goto c56sP;
       u56sU: // global
           call _c56sL() args: 0, res: 0, upd: 0;
       c56sP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56sL() //  []
         { info_tbl: [(c56sL,
                       label: block_c56sL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56sL: // global
           R1 = Data.Type.Equality.$fTestEqualityk:~:1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.636794257 UTC

[section ""data" . Data.Type.Equality.$fTestEqualityk:~~:_closure" {
     Data.Type.Equality.$fTestEqualityk:~~:_closure:
         const Data.Type.Equality.$fTestEqualityk:~~:_info;
 },
 Data.Type.Equality.$fTestEqualityk:~~:_entry() //  [R2, R3]
         { info_tbl: [(c56t0,
                       label: Data.Type.Equality.$fTestEqualityk:~~:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56t0: // global
           R3 = R3;
           R2 = R2;
           call Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_entry(R3,
                                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.637907684 UTC

[section ""data" . Data.Type.Equality.$fEq:~:_$c==_closure" {
     Data.Type.Equality.$fEq:~:_$c==_closure:
         const Data.Type.Equality.$fEq:~:_$c==_info;
 },
 Data.Type.Equality.$fEq:~:_$c==_entry() //  [R2, R3]
         { info_tbl: [(c56ta,
                       label: Data.Type.Equality.$fEq:~:_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ta: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56te; else goto c56tf;
       c56te: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEq:~:_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56tf: // global
           I64[Sp - 16] = block_c56t7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56tn; else goto c56t8;
       u56tn: // global
           call _c56t7() args: 0, res: 0, upd: 0;
       c56t8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56t7() //  []
         { info_tbl: [(c56t7,
                       label: block_c56t7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56t7: // global
           _s56bc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56td_info;
           R1 = _s56bc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56tm; else goto c56th;
       u56tm: // global
           call _c56td() args: 0, res: 0, upd: 0;
       c56th: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56td() //  []
         { info_tbl: [(c56td,
                       label: block_c56td_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56td: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.639422554 UTC

[section ""data" . Data.Type.Equality.$fEq:~:_$c/=_closure" {
     Data.Type.Equality.$fEq:~:_$c/=_closure:
         const Data.Type.Equality.$fEq:~:_$c/=_info;
 },
 Data.Type.Equality.$fEq:~:_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c56tv,
                       label: Data.Type.Equality.$fEq:~:_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56tv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56tz; else goto c56tA;
       c56tz: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEq:~:_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56tA: // global
           I64[Sp - 16] = block_c56ts_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56tI; else goto c56tt;
       u56tI: // global
           call _c56ts() args: 0, res: 0, upd: 0;
       c56tt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56ts() //  []
         { info_tbl: [(c56ts,
                       label: block_c56ts_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ts: // global
           _s56bg::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56ty_info;
           R1 = _s56bg::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56tH; else goto c56tC;
       u56tH: // global
           call _c56ty() args: 0, res: 0, upd: 0;
       c56tC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56ty() //  []
         { info_tbl: [(c56ty,
                       label: block_c56ty_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ty: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.640578848 UTC

[section ""data" . Data.Type.Equality.$fEq:~:_closure" {
     Data.Type.Equality.$fEq:~:_closure:
         const GHC.Classes.C:Eq_con_info;
         const Data.Type.Equality.$fEq:~:_$c==_closure+2;
         const Data.Type.Equality.$fEq:~:_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.641150565 UTC

[section ""cstring" . Data.Type.Equality.$fRead:~:3_bytes" {
     Data.Type.Equality.$fRead:~:3_bytes:
         I8[] [82,101,102,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.642238392 UTC

[section ""data" . Data.Type.Equality.$fRead:~:2_closure" {
     Data.Type.Equality.$fRead:~:2_closure:
         const Data.Type.Equality.$fRead:~:2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Equality.$fRead:~:2_entry() //  [R1]
         { info_tbl: [(c56tP,
                       label: Data.Type.Equality.$fRead:~:2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56tP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56tQ; else goto c56tR;
       c56tQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56tR: // global
           (_c56tM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c56tM::I64 == 0) goto c56tO; else goto c56tN;
       c56tO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c56tN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c56tM::I64;
           R2 = Data.Type.Equality.$fRead:~:3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.643454463 UTC

[section ""data" . Data.Type.Equality.$fShow:~:_$cshowsPrec_closure" {
     Data.Type.Equality.$fShow:~:_$cshowsPrec_closure:
         const Data.Type.Equality.$fShow:~:_$cshowsPrec_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~:_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c56tZ,
                       label: Data.Type.Equality.$fShow:~:_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56tZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56u0; else goto c56u1;
       c56u0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~:_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56u1: // global
           I64[Sp - 16] = block_c56tW_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56u5; else goto c56tX;
       u56u5: // global
           call _c56tW() args: 0, res: 0, upd: 0;
       c56tX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56tW() //  []
         { info_tbl: [(c56tW,
                       label: block_c56tW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56tW: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~:2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.644702109 UTC

[section ""data" . Data.Type.Equality.$fShow:~:_$cshow_closure" {
     Data.Type.Equality.$fShow:~:_$cshow_closure:
         const Data.Type.Equality.$fShow:~:_$cshow_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~:_$cshow_entry() //  [R2]
         { info_tbl: [(c56ud,
                       label: Data.Type.Equality.$fShow:~:_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ud: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c56ue; else goto c56uf;
       c56ue: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~:_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56uf: // global
           I64[Sp - 8] = block_c56ua_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u56uj; else goto c56ub;
       u56uj: // global
           call _c56ua() args: 0, res: 0, upd: 0;
       c56ub: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56ua() //  []
         { info_tbl: [(c56ua,
                       label: block_c56ua_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ua: // global
           R1 = Data.Type.Equality.$fRead:~:2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.646033632 UTC

[section ""data" . Data.Type.Equality.$fShow:~:1_closure" {
     Data.Type.Equality.$fShow:~:1_closure:
         const Data.Type.Equality.$fShow:~:1_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~:1_entry() //  [R2, R3]
         { info_tbl: [(c56ur,
                       label: Data.Type.Equality.$fShow:~:1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ur: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56us; else goto c56ut;
       c56us: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~:1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56ut: // global
           I64[Sp - 16] = block_c56uo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56ux; else goto c56up;
       u56ux: // global
           call _c56uo() args: 0, res: 0, upd: 0;
       c56up: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56uo() //  []
         { info_tbl: [(c56uo,
                       label: block_c56uo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56uo: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~:2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.647204149 UTC

[section ""data" . Data.Type.Equality.$fShow:~:_$cshowList_closure" {
     Data.Type.Equality.$fShow:~:_$cshowList_closure:
         const Data.Type.Equality.$fShow:~:_$cshowList_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~:_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c56uC,
                       label: Data.Type.Equality.$fShow:~:_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56uC: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Type.Equality.$fShow:~:1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.647979712 UTC

[section ""data" . Data.Type.Equality.$fShow:~:_closure" {
     Data.Type.Equality.$fShow:~:_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Type.Equality.$fShow:~:_$cshowsPrec_closure+3;
         const Data.Type.Equality.$fShow:~:_$cshow_closure+1;
         const Data.Type.Equality.$fShow:~:_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.648985854 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$c<_closure" {
     Data.Type.Equality.$fOrd:~:_$c<_closure:
         const Data.Type.Equality.$fOrd:~:_$c<_info;
 },
 Data.Type.Equality.$fOrd:~:_$c<_entry() //  [R2, R3]
         { info_tbl: [(c56uM,
                       label: Data.Type.Equality.$fOrd:~:_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56uM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56uQ; else goto c56uR;
       c56uQ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56uR: // global
           I64[Sp - 16] = block_c56uJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56uZ; else goto c56uK;
       u56uZ: // global
           call _c56uJ() args: 0, res: 0, upd: 0;
       c56uK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56uJ() //  []
         { info_tbl: [(c56uJ,
                       label: block_c56uJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56uJ: // global
           _s56bv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56uP_info;
           R1 = _s56bv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56uY; else goto c56uT;
       u56uY: // global
           call _c56uP() args: 0, res: 0, upd: 0;
       c56uT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56uP() //  []
         { info_tbl: [(c56uP,
                       label: block_c56uP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56uP: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.650645294 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$ccompare_closure" {
     Data.Type.Equality.$fOrd:~:_$ccompare_closure:
         const Data.Type.Equality.$fOrd:~:_$ccompare_info;
 },
 Data.Type.Equality.$fOrd:~:_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c56v7,
                       label: Data.Type.Equality.$fOrd:~:_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56v7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56vb; else goto c56vc;
       c56vb: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56vc: // global
           I64[Sp - 16] = block_c56v4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56vk; else goto c56v5;
       u56vk: // global
           call _c56v4() args: 0, res: 0, upd: 0;
       c56v5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56v4() //  []
         { info_tbl: [(c56v4,
                       label: block_c56v4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56v4: // global
           _s56bz::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56va_info;
           R1 = _s56bz::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56vj; else goto c56ve;
       u56vj: // global
           call _c56va() args: 0, res: 0, upd: 0;
       c56ve: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56va() //  []
         { info_tbl: [(c56va,
                       label: block_c56va_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56va: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.652204285 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$c<=_closure" {
     Data.Type.Equality.$fOrd:~:_$c<=_closure:
         const Data.Type.Equality.$fOrd:~:_$c<=_info;
 },
 Data.Type.Equality.$fOrd:~:_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c56vs,
                       label: Data.Type.Equality.$fOrd:~:_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56vs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56vw; else goto c56vx;
       c56vw: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56vx: // global
           I64[Sp - 16] = block_c56vp_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56vF; else goto c56vq;
       u56vF: // global
           call _c56vp() args: 0, res: 0, upd: 0;
       c56vq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56vp() //  []
         { info_tbl: [(c56vp,
                       label: block_c56vp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56vp: // global
           _s56bC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56vv_info;
           R1 = _s56bC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56vE; else goto c56vz;
       u56vE: // global
           call _c56vv() args: 0, res: 0, upd: 0;
       c56vz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56vv() //  []
         { info_tbl: [(c56vv,
                       label: block_c56vv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56vv: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.653651311 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$cmax_closure" {
     Data.Type.Equality.$fOrd:~:_$cmax_closure:
         const Data.Type.Equality.$fOrd:~:_$cmax_info;
 },
 Data.Type.Equality.$fOrd:~:_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c56vN,
                       label: Data.Type.Equality.$fOrd:~:_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56vN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56vO; else goto c56vP;
       c56vO: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56vP: // global
           I64[Sp - 16] = block_c56vK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56vT; else goto c56vL;
       u56vT: // global
           call _c56vK() args: 0, res: 0, upd: 0;
       c56vL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56vK() //  []
         { info_tbl: [(c56vK,
                       label: block_c56vK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56vK: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.654938619 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$c>_closure" {
     Data.Type.Equality.$fOrd:~:_$c>_closure:
         const Data.Type.Equality.$fOrd:~:_$c>_info;
 },
 Data.Type.Equality.$fOrd:~:_$c>_entry() //  [R2, R3]
         { info_tbl: [(c56w1,
                       label: Data.Type.Equality.$fOrd:~:_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56w1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56w5; else goto c56w6;
       c56w5: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56w6: // global
           I64[Sp - 16] = block_c56vY_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56we; else goto c56vZ;
       u56we: // global
           call _c56vY() args: 0, res: 0, upd: 0;
       c56vZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56vY() //  []
         { info_tbl: [(c56vY,
                       label: block_c56vY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56vY: // global
           _s56bJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56w4_info;
           R1 = _s56bJ::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56wd; else goto c56w8;
       u56wd: // global
           call _c56w4() args: 0, res: 0, upd: 0;
       c56w8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56w4() //  []
         { info_tbl: [(c56w4,
                       label: block_c56w4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56w4: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.656376815 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$cmin_closure" {
     Data.Type.Equality.$fOrd:~:_$cmin_closure:
         const Data.Type.Equality.$fOrd:~:_$cmin_info;
 },
 Data.Type.Equality.$fOrd:~:_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c56wm,
                       label: Data.Type.Equality.$fOrd:~:_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56wm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56wn; else goto c56wo;
       c56wn: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56wo: // global
           I64[Sp - 16] = block_c56wj_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56ws; else goto c56wk;
       u56ws: // global
           call _c56wj() args: 0, res: 0, upd: 0;
       c56wk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56wj() //  []
         { info_tbl: [(c56wj,
                       label: block_c56wj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56wj: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.657940548 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_closure" {
     Data.Type.Equality.$fOrd:~:_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Type.Equality.$fEq:~:_closure+1;
         const Data.Type.Equality.$fOrd:~:_$ccompare_closure+2;
         const Data.Type.Equality.$fOrd:~:_$c<_closure+2;
         const Data.Type.Equality.$fOrd:~:_$c<=_closure+2;
         const Data.Type.Equality.$fOrd:~:_$c>_closure+2;
         const Data.Type.Equality.$fEq:~:_$c==_closure+2;
         const Data.Type.Equality.$fOrd:~:_$cmax_closure+2;
         const Data.Type.Equality.$fOrd:~:_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.658566781 UTC

[section ""data" . Data.Type.Equality.$fRead:~:_lexeme_closure" {
     Data.Type.Equality.$fRead:~:_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Type.Equality.$fRead:~:2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.659623817 UTC

[section ""data" . Data.Type.Equality.$fRead:~:1_closure" {
     Data.Type.Equality.$fRead:~:1_closure:
         const Data.Type.Equality.$fRead:~:1_info;
         const 0;
 },
 sat_s56bT_entry() //  [R1]
         { info_tbl: [(c56wC,
                       label: sat_s56bT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56wC: // global
           R2 = Data.Type.Equality.$WRefl_closure+1;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~:1_entry() //  [R2, R3]
         { info_tbl: [(c56wI,
                       label: Data.Type.Equality.$fRead:~:1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56wI: // global
           _s56bR::P64 = R3;
           _s56bQ::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c56wJ; else goto c56wK;
       c56wK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56wM; else goto c56wL;
       c56wM: // global
           HpAlloc = 16;
           goto c56wJ;
       c56wJ: // global
           R3 = _s56bR::P64;
           R2 = _s56bQ::P64;
           R1 = Data.Type.Equality.$fRead:~:1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56wL: // global
           I64[Hp - 8] = sat_s56bT_info;
           P64[Hp] = _s56bR::P64;
           I64[Sp - 8] = block_c56wF_info;
           R3 = Hp - 7;
           R2 = Data.Type.Equality.$fRead:~:_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56wF() //  [R1]
         { info_tbl: [(c56wF,
                       label: block_c56wF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56wF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56wP; else goto c56wO;
       c56wP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c56wO: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.661299132 UTC

[section ""data" . Data.Type.Equality.$fRead:~:4_closure" {
     Data.Type.Equality.$fRead:~:4_closure:
         const Data.Type.Equality.$fRead:~:4_info;
         const 0;
 },
 Data.Type.Equality.$fRead:~:4_entry() //  [R2, R3, R4]
         { info_tbl: [(c56wW,
                       label: Data.Type.Equality.$fRead:~:4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56wW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c56wX; else goto c56wY;
       c56wX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~:4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56wY: // global
           I64[Sp - 24] = block_c56wU_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56wU() //  []
         { info_tbl: [(c56wU,
                       label: block_c56wU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56wU: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~:1_closure+2;
           Sp = Sp + 24;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.662814828 UTC

[section ""data" . Data.Type.Equality.$fRead:~:_$creadsPrec_closure" {
     Data.Type.Equality.$fRead:~:_$creadsPrec_closure:
         const Data.Type.Equality.$fRead:~:_$creadsPrec_info;
         const 0;
 },
 sat_s56c1_entry() //  [R1]
         { info_tbl: [(c56xc,
                       label: sat_s56c1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56xc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c56xd; else goto c56xe;
       c56xd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56xe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c56xa_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c56xa() //  []
         { info_tbl: [(c56xa,
                       label: block_c56xa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56xa: // global
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~:1_closure+2;
           Sp = Sp + 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fRead:~:_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c56xg,
                       label: Data.Type.Equality.$fRead:~:_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56xg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c56xh; else goto c56xi;
       c56xh: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~:_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56xi: // global
           I64[Sp - 24] = block_c56x4_info;
           _s56bZ::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s56bZ::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56x4() //  []
         { info_tbl: [(c56x4,
                       label: block_c56x4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56x4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c56xl; else goto c56xk;
       c56xl: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c56xk: // global
           I64[Hp - 24] = sat_s56c1_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.664829094 UTC

[section ""data" . Data.Type.Equality.$fRead:~:_$creadListPrec_closure" {
     Data.Type.Equality.$fRead:~:_$creadListPrec_closure:
         const Data.Type.Equality.$fRead:~:_$creadListPrec_info;
         const 0;
 },
 sat_s56c5_entry() //  [R1, R2, R3]
         { info_tbl: [(c56xz,
                       label: sat_s56c5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56xz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c56xA; else goto c56xB;
       c56xA: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56xB: // global
           I64[Sp - 24] = block_c56xx_info;
           _s56c3::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = _s56c3::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56xx() //  []
         { info_tbl: [(c56xx,
                       label: block_c56xx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56xx: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~:1_closure+2;
           Sp = Sp + 24;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~:_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c56xD,
                       label: Data.Type.Equality.$fRead:~:_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56xD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56xE; else goto c56xF;
       c56xE: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~:_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56xF: // global
           I64[Sp - 16] = block_c56xq_info;
           _s56c2::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s56c2::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56xq() //  []
         { info_tbl: [(c56xq,
                       label: block_c56xq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56xq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56xI; else goto c56xH;
       c56xI: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c56xH: // global
           I64[Hp - 8] = sat_s56c5_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 6;
           Sp = Sp + 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.667035422 UTC

[section ""data" . Data.Type.Equality.$fRead:~:_$creadList_closure" {
     Data.Type.Equality.$fRead:~:_$creadList_closure:
         const Data.Type.Equality.$fRead:~:_$creadList_info;
         const 0;
 },
 sat_s56c9_entry() //  [R2, R3]
         { info_tbl: [(c56y0,
                       label: sat_s56c9_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56y0: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Type.Equality.$fRead:~:1_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56ca_entry() //  [R1]
         { info_tbl: [(c56y3,
                       label: sat_s56ca_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56y3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c56y4; else goto c56y5;
       c56y4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56y5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c56xT_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c56xT() //  []
         { info_tbl: [(c56xT,
                       label: block_c56xT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56xT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56y8; else goto c56y7;
       c56y8: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c56y7: // global
           I64[Hp - 8] = sat_s56c9_info;
           R2 = Hp - 6;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = GHC.Read.$fRead()7_closure;
           P64[Sp] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fRead:~:_$creadList_entry() //  [R2]
         { info_tbl: [(c56y9,
                       label: Data.Type.Equality.$fRead:~:_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56y9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56ya; else goto c56yb;
       c56ya: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~:_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56yb: // global
           I64[Sp - 16] = block_c56xN_info;
           _s56c6::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s56c6::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56xN() //  []
         { info_tbl: [(c56xN,
                       label: block_c56xN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56xN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c56ye; else goto c56yd;
       c56ye: // global
           HpAlloc = 24;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c56yd: // global
           I64[Hp - 16] = sat_s56ca_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.669637964 UTC

[section ""data" . Data.Type.Equality.$fRead:~:_closure" {
     Data.Type.Equality.$fRead:~:_closure:
         const Data.Type.Equality.$fRead:~:_info;
         const 0;
 },
 sat_s56cf_entry() //  [R1]
         { info_tbl: [(c56yn,
                       label: sat_s56cf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56yn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56yo; else goto c56yp;
       c56yo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56yp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fRead:~:_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56ce_entry() //  [R1, R2, R3]
         { info_tbl: [(c56yv,
                       label: sat_s56ce_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56yv: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fRead:~:4_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56cd_entry() //  [R1]
         { info_tbl: [(c56yC,
                       label: sat_s56cd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56yC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56yD; else goto c56yE;
       c56yD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56yE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fRead:~:_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56cc_entry() //  [R1, R2]
         { info_tbl: [(c56yK,
                       label: sat_s56cc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56yK: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fRead:~:_$creadsPrec_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~:_entry() //  [R2]
         { info_tbl: [(c56yO,
                       label: Data.Type.Equality.$fRead:~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56yO: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c56yS; else goto c56yR;
       c56yS: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56yR: // global
           I64[Hp - 112] = sat_s56cf_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s56ce_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s56cd_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s56cc_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 112;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.671634783 UTC

[section ""data" . Data.Type.Equality.$fBounded:~:_$cmaxBound_closure" {
     Data.Type.Equality.$fBounded:~:_$cmaxBound_closure:
         const Data.Type.Equality.$fBounded:~:_$cmaxBound_info;
 },
 Data.Type.Equality.$fBounded:~:_$cmaxBound_entry() //  [R2]
         { info_tbl: [(c56yZ,
                       label: Data.Type.Equality.$fBounded:~:_$cmaxBound_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56yZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c56z0; else goto c56z1;
       c56z0: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fBounded:~:_$cmaxBound_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56z1: // global
           I64[Sp - 8] = block_c56yX_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56yX() //  []
         { info_tbl: [(c56yX,
                       label: block_c56yX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56yX: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.673019346 UTC

[section ""data" . Data.Type.Equality.$fBounded:~:_closure" {
     Data.Type.Equality.$fBounded:~:_closure:
         const Data.Type.Equality.$fBounded:~:_info;
 },
 sat_s56cj_entry() //  [R1]
         { info_tbl: [(c56zb,
                       label: sat_s56cj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56zb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56zc; else goto c56zd;
       c56zc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56zd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fBounded:~:_$cmaxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56ci_entry() //  [R1]
         { info_tbl: [(c56zi,
                       label: sat_s56ci_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56zi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56zj; else goto c56zk;
       c56zj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56zk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fBounded:~:_$cmaxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fBounded:~:_entry() //  [R2]
         { info_tbl: [(c56zm,
                       label: Data.Type.Equality.$fBounded:~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56zm: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c56zq; else goto c56zp;
       c56zq: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Type.Equality.$fBounded:~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56zp: // global
           I64[Hp - 64] = sat_s56cj_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s56ci_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.674723987 UTC

[section ""data" . Data.Type.Equality.$fEq:~~:_$c==_closure" {
     Data.Type.Equality.$fEq:~~:_$c==_closure:
         const Data.Type.Equality.$fEq:~~:_$c==_info;
 },
 Data.Type.Equality.$fEq:~~:_$c==_entry() //  [R2, R3]
         { info_tbl: [(c56zy,
                       label: Data.Type.Equality.$fEq:~~:_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56zy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56zC; else goto c56zD;
       c56zC: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEq:~~:_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56zD: // global
           I64[Sp - 16] = block_c56zv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56zL; else goto c56zw;
       u56zL: // global
           call _c56zv() args: 0, res: 0, upd: 0;
       c56zw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56zv() //  []
         { info_tbl: [(c56zv,
                       label: block_c56zv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56zv: // global
           _s56cl::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56zB_info;
           R1 = _s56cl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56zK; else goto c56zF;
       u56zK: // global
           call _c56zB() args: 0, res: 0, upd: 0;
       c56zF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56zB() //  []
         { info_tbl: [(c56zB,
                       label: block_c56zB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56zB: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.678985059 UTC

[section ""data" . Data.Type.Equality.$fEq:~~:_$c/=_closure" {
     Data.Type.Equality.$fEq:~~:_$c/=_closure:
         const Data.Type.Equality.$fEq:~~:_$c/=_info;
 },
 Data.Type.Equality.$fEq:~~:_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c56zT,
                       label: Data.Type.Equality.$fEq:~~:_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56zT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56zX; else goto c56zY;
       c56zX: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEq:~~:_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56zY: // global
           I64[Sp - 16] = block_c56zQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56A6; else goto c56zR;
       u56A6: // global
           call _c56zQ() args: 0, res: 0, upd: 0;
       c56zR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56zQ() //  []
         { info_tbl: [(c56zQ,
                       label: block_c56zQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56zQ: // global
           _s56cp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56zW_info;
           R1 = _s56cp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56A5; else goto c56A0;
       u56A5: // global
           call _c56zW() args: 0, res: 0, upd: 0;
       c56A0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56zW() //  []
         { info_tbl: [(c56zW,
                       label: block_c56zW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56zW: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.680477416 UTC

[section ""data" . Data.Type.Equality.$fEq:~~:_closure" {
     Data.Type.Equality.$fEq:~~:_closure:
         const GHC.Classes.C:Eq_con_info;
         const Data.Type.Equality.$fEq:~~:_$c==_closure+2;
         const Data.Type.Equality.$fEq:~~:_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.681075455 UTC

[section ""cstring" . Data.Type.Equality.$fRead:~~:3_bytes" {
     Data.Type.Equality.$fRead:~~:3_bytes:
         I8[] [72,82,101,102,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.68199327 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:2_closure" {
     Data.Type.Equality.$fRead:~~:2_closure:
         const Data.Type.Equality.$fRead:~~:2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Equality.$fRead:~~:2_entry() //  [R1]
         { info_tbl: [(c56Ad,
                       label: Data.Type.Equality.$fRead:~~:2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Ad: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Ae; else goto c56Af;
       c56Ae: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56Af: // global
           (_c56Aa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c56Aa::I64 == 0) goto c56Ac; else goto c56Ab;
       c56Ac: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c56Ab: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c56Aa::I64;
           R2 = Data.Type.Equality.$fRead:~~:3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.683292152 UTC

[section ""data" . Data.Type.Equality.$fShow:~~:_$cshowsPrec_closure" {
     Data.Type.Equality.$fShow:~~:_$cshowsPrec_closure:
         const Data.Type.Equality.$fShow:~~:_$cshowsPrec_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~~:_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c56An,
                       label: Data.Type.Equality.$fShow:~~:_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56An: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Ao; else goto c56Ap;
       c56Ao: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~~:_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Ap: // global
           I64[Sp - 16] = block_c56Ak_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56At; else goto c56Al;
       u56At: // global
           call _c56Ak() args: 0, res: 0, upd: 0;
       c56Al: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Ak() //  []
         { info_tbl: [(c56Ak,
                       label: block_c56Ak_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Ak: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~~:2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.684578216 UTC

[section ""data" . Data.Type.Equality.$fShow:~~:_$cshow_closure" {
     Data.Type.Equality.$fShow:~~:_$cshow_closure:
         const Data.Type.Equality.$fShow:~~:_$cshow_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~~:_$cshow_entry() //  [R2]
         { info_tbl: [(c56AB,
                       label: Data.Type.Equality.$fShow:~~:_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56AB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c56AC; else goto c56AD;
       c56AC: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~~:_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56AD: // global
           I64[Sp - 8] = block_c56Ay_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u56AH; else goto c56Az;
       u56AH: // global
           call _c56Ay() args: 0, res: 0, upd: 0;
       c56Az: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Ay() //  []
         { info_tbl: [(c56Ay,
                       label: block_c56Ay_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Ay: // global
           R1 = Data.Type.Equality.$fRead:~~:2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.685996115 UTC

[section ""data" . Data.Type.Equality.$fShow:~~:1_closure" {
     Data.Type.Equality.$fShow:~~:1_closure:
         const Data.Type.Equality.$fShow:~~:1_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~~:1_entry() //  [R2, R3]
         { info_tbl: [(c56AP,
                       label: Data.Type.Equality.$fShow:~~:1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56AP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56AQ; else goto c56AR;
       c56AQ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~~:1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56AR: // global
           I64[Sp - 16] = block_c56AM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56AV; else goto c56AN;
       u56AV: // global
           call _c56AM() args: 0, res: 0, upd: 0;
       c56AN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56AM() //  []
         { info_tbl: [(c56AM,
                       label: block_c56AM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56AM: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~~:2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.687209455 UTC

[section ""data" . Data.Type.Equality.$fShow:~~:_$cshowList_closure" {
     Data.Type.Equality.$fShow:~~:_$cshowList_closure:
         const Data.Type.Equality.$fShow:~~:_$cshowList_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~~:_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c56B0,
                       label: Data.Type.Equality.$fShow:~~:_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56B0: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Type.Equality.$fShow:~~:1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.687976281 UTC

[section ""data" . Data.Type.Equality.$fShow:~~:_closure" {
     Data.Type.Equality.$fShow:~~:_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Type.Equality.$fShow:~~:_$cshowsPrec_closure+3;
         const Data.Type.Equality.$fShow:~~:_$cshow_closure+1;
         const Data.Type.Equality.$fShow:~~:_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.68893916 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$c<_closure" {
     Data.Type.Equality.$fOrd:~~:_$c<_closure:
         const Data.Type.Equality.$fOrd:~~:_$c<_info;
 },
 Data.Type.Equality.$fOrd:~~:_$c<_entry() //  [R2, R3]
         { info_tbl: [(c56Ba,
                       label: Data.Type.Equality.$fOrd:~~:_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Ba: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Be; else goto c56Bf;
       c56Be: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Bf: // global
           I64[Sp - 16] = block_c56B7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56Bn; else goto c56B8;
       u56Bn: // global
           call _c56B7() args: 0, res: 0, upd: 0;
       c56B8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56B7() //  []
         { info_tbl: [(c56B7,
                       label: block_c56B7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56B7: // global
           _s56cE::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56Bd_info;
           R1 = _s56cE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56Bm; else goto c56Bh;
       u56Bm: // global
           call _c56Bd() args: 0, res: 0, upd: 0;
       c56Bh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Bd() //  []
         { info_tbl: [(c56Bd,
                       label: block_c56Bd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Bd: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.690613292 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$ccompare_closure" {
     Data.Type.Equality.$fOrd:~~:_$ccompare_closure:
         const Data.Type.Equality.$fOrd:~~:_$ccompare_info;
 },
 Data.Type.Equality.$fOrd:~~:_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c56Bv,
                       label: Data.Type.Equality.$fOrd:~~:_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Bv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Bz; else goto c56BA;
       c56Bz: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56BA: // global
           I64[Sp - 16] = block_c56Bs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56BI; else goto c56Bt;
       u56BI: // global
           call _c56Bs() args: 0, res: 0, upd: 0;
       c56Bt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Bs() //  []
         { info_tbl: [(c56Bs,
                       label: block_c56Bs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Bs: // global
           _s56cI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56By_info;
           R1 = _s56cI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56BH; else goto c56BC;
       u56BH: // global
           call _c56By() args: 0, res: 0, upd: 0;
       c56BC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56By() //  []
         { info_tbl: [(c56By,
                       label: block_c56By_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56By: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.692178116 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$c<=_closure" {
     Data.Type.Equality.$fOrd:~~:_$c<=_closure:
         const Data.Type.Equality.$fOrd:~~:_$c<=_info;
 },
 Data.Type.Equality.$fOrd:~~:_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c56BQ,
                       label: Data.Type.Equality.$fOrd:~~:_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56BQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56BU; else goto c56BV;
       c56BU: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56BV: // global
           I64[Sp - 16] = block_c56BN_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56C3; else goto c56BO;
       u56C3: // global
           call _c56BN() args: 0, res: 0, upd: 0;
       c56BO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56BN() //  []
         { info_tbl: [(c56BN,
                       label: block_c56BN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56BN: // global
           _s56cL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56BT_info;
           R1 = _s56cL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56C2; else goto c56BX;
       u56C2: // global
           call _c56BT() args: 0, res: 0, upd: 0;
       c56BX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56BT() //  []
         { info_tbl: [(c56BT,
                       label: block_c56BT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56BT: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.693752025 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$cmax_closure" {
     Data.Type.Equality.$fOrd:~~:_$cmax_closure:
         const Data.Type.Equality.$fOrd:~~:_$cmax_info;
 },
 Data.Type.Equality.$fOrd:~~:_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c56Cb,
                       label: Data.Type.Equality.$fOrd:~~:_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Cb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Cc; else goto c56Cd;
       c56Cc: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Cd: // global
           I64[Sp - 16] = block_c56C8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56Ch; else goto c56C9;
       u56Ch: // global
           call _c56C8() args: 0, res: 0, upd: 0;
       c56C9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56C8() //  []
         { info_tbl: [(c56C8,
                       label: block_c56C8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56C8: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.695064461 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$c>_closure" {
     Data.Type.Equality.$fOrd:~~:_$c>_closure:
         const Data.Type.Equality.$fOrd:~~:_$c>_info;
 },
 Data.Type.Equality.$fOrd:~~:_$c>_entry() //  [R2, R3]
         { info_tbl: [(c56Cp,
                       label: Data.Type.Equality.$fOrd:~~:_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Cp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Ct; else goto c56Cu;
       c56Ct: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Cu: // global
           I64[Sp - 16] = block_c56Cm_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56CC; else goto c56Cn;
       u56CC: // global
           call _c56Cm() args: 0, res: 0, upd: 0;
       c56Cn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Cm() //  []
         { info_tbl: [(c56Cm,
                       label: block_c56Cm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Cm: // global
           _s56cS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56Cs_info;
           R1 = _s56cS::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56CB; else goto c56Cw;
       u56CB: // global
           call _c56Cs() args: 0, res: 0, upd: 0;
       c56Cw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Cs() //  []
         { info_tbl: [(c56Cs,
                       label: block_c56Cs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Cs: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.696568269 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$cmin_closure" {
     Data.Type.Equality.$fOrd:~~:_$cmin_closure:
         const Data.Type.Equality.$fOrd:~~:_$cmin_info;
 },
 Data.Type.Equality.$fOrd:~~:_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c56CK,
                       label: Data.Type.Equality.$fOrd:~~:_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56CK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56CL; else goto c56CM;
       c56CL: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56CM: // global
           I64[Sp - 16] = block_c56CH_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56CQ; else goto c56CI;
       u56CQ: // global
           call _c56CH() args: 0, res: 0, upd: 0;
       c56CI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56CH() //  []
         { info_tbl: [(c56CH,
                       label: block_c56CH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56CH: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.698081525 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_closure" {
     Data.Type.Equality.$fOrd:~~:_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Type.Equality.$fEq:~~:_closure+1;
         const Data.Type.Equality.$fOrd:~~:_$ccompare_closure+2;
         const Data.Type.Equality.$fOrd:~~:_$c<_closure+2;
         const Data.Type.Equality.$fOrd:~~:_$c<=_closure+2;
         const Data.Type.Equality.$fOrd:~~:_$c>_closure+2;
         const Data.Type.Equality.$fEq:~~:_$c==_closure+2;
         const Data.Type.Equality.$fOrd:~~:_$cmax_closure+2;
         const Data.Type.Equality.$fOrd:~~:_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.698671846 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:_lexeme_closure" {
     Data.Type.Equality.$fRead:~~:_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Type.Equality.$fRead:~~:2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.699792045 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:1_closure" {
     Data.Type.Equality.$fRead:~~:1_closure:
         const Data.Type.Equality.$fRead:~~:1_info;
         const 0;
 },
 sat_s56d2_entry() //  [R1]
         { info_tbl: [(c56D0,
                       label: sat_s56d2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56D0: // global
           R2 = Data.Type.Equality.$WHRefl_closure+1;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~~:1_entry() //  [R2, R3]
         { info_tbl: [(c56D6,
                       label: Data.Type.Equality.$fRead:~~:1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56D6: // global
           _s56d0::P64 = R3;
           _s56cZ::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c56D7; else goto c56D8;
       c56D8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56Da; else goto c56D9;
       c56Da: // global
           HpAlloc = 16;
           goto c56D7;
       c56D7: // global
           R3 = _s56d0::P64;
           R2 = _s56cZ::P64;
           R1 = Data.Type.Equality.$fRead:~~:1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56D9: // global
           I64[Hp - 8] = sat_s56d2_info;
           P64[Hp] = _s56d0::P64;
           I64[Sp - 8] = block_c56D3_info;
           R3 = Hp - 7;
           R2 = Data.Type.Equality.$fRead:~~:_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56D3() //  [R1]
         { info_tbl: [(c56D3,
                       label: block_c56D3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56D3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56Dd; else goto c56Dc;
       c56Dd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c56Dc: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.701600265 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:4_closure" {
     Data.Type.Equality.$fRead:~~:4_closure:
         const Data.Type.Equality.$fRead:~~:4_info;
         const 0;
 },
 Data.Type.Equality.$fRead:~~:4_entry() //  [R2, R3, R4]
         { info_tbl: [(c56Dk,
                       label: Data.Type.Equality.$fRead:~~:4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Dk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c56Dl; else goto c56Dm;
       c56Dl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~~:4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Dm: // global
           I64[Sp - 24] = block_c56Di_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56Di() //  []
         { info_tbl: [(c56Di,
                       label: block_c56Di_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Di: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~~:1_closure+2;
           Sp = Sp + 24;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.70326684 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:_$creadsPrec_closure" {
     Data.Type.Equality.$fRead:~~:_$creadsPrec_closure:
         const Data.Type.Equality.$fRead:~~:_$creadsPrec_info;
         const 0;
 },
 sat_s56da_entry() //  [R1]
         { info_tbl: [(c56DA,
                       label: sat_s56da_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56DA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c56DB; else goto c56DC;
       c56DB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56DC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c56Dy_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c56Dy() //  []
         { info_tbl: [(c56Dy,
                       label: block_c56Dy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Dy: // global
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~~:1_closure+2;
           Sp = Sp + 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fRead:~~:_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c56DE,
                       label: Data.Type.Equality.$fRead:~~:_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56DE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c56DF; else goto c56DG;
       c56DF: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~~:_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56DG: // global
           I64[Sp - 24] = block_c56Ds_info;
           _s56d8::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s56d8::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56Ds() //  []
         { info_tbl: [(c56Ds,
                       label: block_c56Ds_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Ds: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c56DJ; else goto c56DI;
       c56DJ: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c56DI: // global
           I64[Hp - 24] = sat_s56da_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.705356546 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:_$creadListPrec_closure" {
     Data.Type.Equality.$fRead:~~:_$creadListPrec_closure:
         const Data.Type.Equality.$fRead:~~:_$creadListPrec_info;
         const 0;
 },
 sat_s56de_entry() //  [R1, R2, R3]
         { info_tbl: [(c56DX,
                       label: sat_s56de_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56DX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c56DY; else goto c56DZ;
       c56DY: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56DZ: // global
           I64[Sp - 24] = block_c56DV_info;
           _s56dc::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = _s56dc::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56DV() //  []
         { info_tbl: [(c56DV,
                       label: block_c56DV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56DV: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~~:1_closure+2;
           Sp = Sp + 24;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~~:_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c56E1,
                       label: Data.Type.Equality.$fRead:~~:_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56E1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56E2; else goto c56E3;
       c56E2: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~~:_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56E3: // global
           I64[Sp - 16] = block_c56DO_info;
           _s56db::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s56db::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56DO() //  []
         { info_tbl: [(c56DO,
                       label: block_c56DO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56DO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56E6; else goto c56E5;
       c56E6: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c56E5: // global
           I64[Hp - 8] = sat_s56de_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 6;
           Sp = Sp + 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.707602712 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:_$creadList_closure" {
     Data.Type.Equality.$fRead:~~:_$creadList_closure:
         const Data.Type.Equality.$fRead:~~:_$creadList_info;
         const 0;
 },
 sat_s56di_entry() //  [R2, R3]
         { info_tbl: [(c56Eo,
                       label: sat_s56di_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Eo: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Type.Equality.$fRead:~~:1_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56dj_entry() //  [R1]
         { info_tbl: [(c56Er,
                       label: sat_s56dj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Er: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c56Es; else goto c56Et;
       c56Es: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56Et: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c56Eh_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c56Eh() //  []
         { info_tbl: [(c56Eh,
                       label: block_c56Eh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Eh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56Ew; else goto c56Ev;
       c56Ew: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c56Ev: // global
           I64[Hp - 8] = sat_s56di_info;
           R2 = Hp - 6;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = GHC.Read.$fRead()7_closure;
           P64[Sp] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fRead:~~:_$creadList_entry() //  [R2]
         { info_tbl: [(c56Ex,
                       label: Data.Type.Equality.$fRead:~~:_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Ex: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Ey; else goto c56Ez;
       c56Ey: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~~:_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56Ez: // global
           I64[Sp - 16] = block_c56Eb_info;
           _s56df::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s56df::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56Eb() //  []
         { info_tbl: [(c56Eb,
                       label: block_c56Eb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Eb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c56EC; else goto c56EB;
       c56EC: // global
           HpAlloc = 24;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c56EB: // global
           I64[Hp - 16] = sat_s56dj_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.710216094 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:_closure" {
     Data.Type.Equality.$fRead:~~:_closure:
         const Data.Type.Equality.$fRead:~~:_info;
         const 0;
 },
 sat_s56do_entry() //  [R1]
         { info_tbl: [(c56EL,
                       label: sat_s56do_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56EL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56EM; else goto c56EN;
       c56EM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56EN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fRead:~~:_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56dn_entry() //  [R1, R2, R3]
         { info_tbl: [(c56ET,
                       label: sat_s56dn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ET: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fRead:~~:4_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56dm_entry() //  [R1]
         { info_tbl: [(c56F0,
                       label: sat_s56dm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56F0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56F1; else goto c56F2;
       c56F1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56F2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fRead:~~:_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56dl_entry() //  [R1, R2]
         { info_tbl: [(c56F8,
                       label: sat_s56dl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56F8: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fRead:~~:_$creadsPrec_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~~:_entry() //  [R2]
         { info_tbl: [(c56Fc,
                       label: Data.Type.Equality.$fRead:~~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Fc: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c56Fg; else goto c56Ff;
       c56Fg: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56Ff: // global
           I64[Hp - 112] = sat_s56do_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s56dn_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s56dm_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s56dl_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 112;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.712323341 UTC

[section ""data" . Data.Type.Equality.$fBounded:~~:_$cmaxBound_closure" {
     Data.Type.Equality.$fBounded:~~:_$cmaxBound_closure:
         const Data.Type.Equality.$fBounded:~~:_$cmaxBound_info;
 },
 Data.Type.Equality.$fBounded:~~:_$cmaxBound_entry() //  [R2]
         { info_tbl: [(c56Fn,
                       label: Data.Type.Equality.$fBounded:~~:_$cmaxBound_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Fn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c56Fo; else goto c56Fp;
       c56Fo: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fBounded:~~:_$cmaxBound_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56Fp: // global
           I64[Sp - 8] = block_c56Fl_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56Fl() //  []
         { info_tbl: [(c56Fl,
                       label: block_c56Fl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Fl: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.713843095 UTC

[section ""data" . Data.Type.Equality.$fBounded:~~:_closure" {
     Data.Type.Equality.$fBounded:~~:_closure:
         const Data.Type.Equality.$fBounded:~~:_info;
 },
 sat_s56ds_entry() //  [R1]
         { info_tbl: [(c56Fz,
                       label: sat_s56ds_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Fz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56FA; else goto c56FB;
       c56FA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56FB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fBounded:~~:_$cmaxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56dr_entry() //  [R1]
         { info_tbl: [(c56FG,
                       label: sat_s56dr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56FG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56FH; else goto c56FI;
       c56FH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56FI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fBounded:~~:_$cmaxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fBounded:~~:_entry() //  [R2]
         { info_tbl: [(c56FK,
                       label: Data.Type.Equality.$fBounded:~~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56FK: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c56FO; else goto c56FN;
       c56FO: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Type.Equality.$fBounded:~~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56FN: // global
           I64[Hp - 64] = sat_s56ds_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s56dr_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.715463344 UTC

[section ""data" . Data.Type.Equality.sym_closure" {
     Data.Type.Equality.sym_closure:
         const Data.Type.Equality.sym_info;
 },
 Data.Type.Equality.sym_entry() //  [R2]
         { info_tbl: [(c56FW,
                       label: Data.Type.Equality.sym_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56FW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c56FX; else goto c56FY;
       c56FX: // global
           R2 = R2;
           R1 = Data.Type.Equality.sym_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56FY: // global
           I64[Sp - 8] = block_c56FT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u56G2; else goto c56FU;
       u56G2: // global
           call _c56FT() args: 0, res: 0, upd: 0;
       c56FU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56FT() //  []
         { info_tbl: [(c56FT,
                       label: block_c56FT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56FT: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.716760197 UTC

[section ""data" . Data.Type.Equality.trans_closure" {
     Data.Type.Equality.trans_closure:
         const Data.Type.Equality.trans_info;
 },
 Data.Type.Equality.trans_entry() //  [R2, R3]
         { info_tbl: [(c56Ga,
                       label: Data.Type.Equality.trans_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Ga: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Ge; else goto c56Gf;
       c56Ge: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.trans_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Gf: // global
           I64[Sp - 16] = block_c56G7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56Gn; else goto c56G8;
       u56Gn: // global
           call _c56G7() args: 0, res: 0, upd: 0;
       c56G8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56G7() //  []
         { info_tbl: [(c56G7,
                       label: block_c56G7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56G7: // global
           _s56dw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56Gd_info;
           R1 = _s56dw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56Gm; else goto c56Gh;
       u56Gm: // global
           call _c56Gd() args: 0, res: 0, upd: 0;
       c56Gh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Gd() //  []
         { info_tbl: [(c56Gd,
                       label: block_c56Gd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Gd: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.718330583 UTC

[section ""data" . Data.Type.Equality.castWith_closure" {
     Data.Type.Equality.castWith_closure:
         const Data.Type.Equality.castWith_info;
 },
 Data.Type.Equality.castWith_entry() //  [R2, R3]
         { info_tbl: [(c56Gv,
                       label: Data.Type.Equality.castWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Gv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Gw; else goto c56Gx;
       c56Gw: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.castWith_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Gx: // global
           I64[Sp - 16] = block_c56Gs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56GB; else goto c56Gt;
       u56GB: // global
           call _c56Gs() args: 0, res: 0, upd: 0;
       c56Gt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Gs() //  []
         { info_tbl: [(c56Gs,
                       label: block_c56Gs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Gs: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.719806024 UTC

[section ""data" . Data.Type.Equality.gcastWith_closure" {
     Data.Type.Equality.gcastWith_closure:
         const Data.Type.Equality.gcastWith_info;
 },
 Data.Type.Equality.gcastWith_entry() //  [R2, R3]
         { info_tbl: [(c56GJ,
                       label: Data.Type.Equality.gcastWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56GJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56GN; else goto c56GO;
       c56GN: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.gcastWith_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56GO: // global
           I64[Sp - 16] = block_c56GG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56GS; else goto c56GH;
       u56GS: // global
           call _c56GG(R1) args: 0, res: 0, upd: 0;
       c56GH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56GG() //  [R1]
         { info_tbl: [(c56GG,
                       label: block_c56GG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56GG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56GR; else goto c56GQ;
       c56GR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c56GQ: // global
           I64[Hp - 8] = GHC.Types.Eq#_con_info;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.721387812 UTC

[section ""data" . Data.Type.Equality.apply_closure" {
     Data.Type.Equality.apply_closure:
         const Data.Type.Equality.apply_info;
 },
 Data.Type.Equality.apply_entry() //  [R2, R3]
         { info_tbl: [(c56H0,
                       label: Data.Type.Equality.apply_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56H0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56H4; else goto c56H5;
       c56H4: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.apply_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56H5: // global
           I64[Sp - 16] = block_c56GX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56Hd; else goto c56GY;
       u56Hd: // global
           call _c56GX() args: 0, res: 0, upd: 0;
       c56GY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56GX() //  []
         { info_tbl: [(c56GX,
                       label: block_c56GX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56GX: // global
           _s56dH::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56H3_info;
           R1 = _s56dH::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56Hc; else goto c56H7;
       u56Hc: // global
           call _c56H3() args: 0, res: 0, upd: 0;
       c56H7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56H3() //  []
         { info_tbl: [(c56H3,
                       label: block_c56H3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56H3: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.722972555 UTC

[section ""data" . Data.Type.Equality.inner_closure" {
     Data.Type.Equality.inner_closure:
         const Data.Type.Equality.inner_info;
 },
 Data.Type.Equality.inner_entry() //  [R2]
         { info_tbl: [(c56Hl,
                       label: Data.Type.Equality.inner_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Hl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c56Hm; else goto c56Hn;
       c56Hm: // global
           R2 = R2;
           R1 = Data.Type.Equality.inner_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56Hn: // global
           I64[Sp - 8] = block_c56Hi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u56Hr; else goto c56Hj;
       u56Hr: // global
           call _c56Hi() args: 0, res: 0, upd: 0;
       c56Hj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Hi() //  []
         { info_tbl: [(c56Hi,
                       label: block_c56Hi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Hi: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.724180804 UTC

[section ""data" . Data.Type.Equality.outer_closure" {
     Data.Type.Equality.outer_closure:
         const Data.Type.Equality.outer_info;
 },
 Data.Type.Equality.outer_entry() //  [R2]
         { info_tbl: [(c56Hz,
                       label: Data.Type.Equality.outer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Hz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c56HA; else goto c56HB;
       c56HA: // global
           R2 = R2;
           R1 = Data.Type.Equality.outer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56HB: // global
           I64[Sp - 8] = block_c56Hw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u56HF; else goto c56Hx;
       u56HF: // global
           call _c56Hw() args: 0, res: 0, upd: 0;
       c56Hx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Hw() //  []
         { info_tbl: [(c56Hw,
                       label: block_c56Hw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Hw: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.72520388 UTC

[section ""cstring" . Data.Type.Equality.$trModule4_bytes" {
     Data.Type.Equality.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.726234105 UTC

[section ""data" . Data.Type.Equality.$trModule3_closure" {
     Data.Type.Equality.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.726790017 UTC

[section ""cstring" . Data.Type.Equality.$trModule2_bytes" {
     Data.Type.Equality.$trModule2_bytes:
         I8[] [68,97,116,97,46,84,121,112,101,46,69,113,117,97,108,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.727389058 UTC

[section ""data" . Data.Type.Equality.$trModule1_closure" {
     Data.Type.Equality.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.727955779 UTC

[section ""data" . Data.Type.Equality.$trModule_closure" {
     Data.Type.Equality.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Type.Equality.$trModule3_closure+1;
         const Data.Type.Equality.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.728592537 UTC

[section ""data" . $krep_r568a_closure" {
     $krep_r568a_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.729196455 UTC

[section ""data" . $krep1_r568b_closure" {
     $krep1_r568b_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.729828907 UTC

[section ""data" . $krep2_r568c_closure" {
     $krep2_r568c_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r568b_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.730433001 UTC

[section ""data" . $krep3_r568d_closure" {
     $krep3_r568d_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.730981781 UTC

[section ""data" . Data.Type.Equality.$tc:~~:1_closure" {
     Data.Type.Equality.$tc:~~:1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r568d_closure+2;
         const $krep2_r568c_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.731599857 UTC

[section ""data" . $krep4_r568e_closure" {
     $krep4_r568e_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r568d_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.733917616 UTC

[section ""data" . Data.Type.Equality.$tc:~:1_closure" {
     Data.Type.Equality.$tc:~:1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r568d_closure+2;
         const $krep4_r568e_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.734936107 UTC

[section ""data" . Data.Type.Equality.$tcTestEquality1_closure" {
     Data.Type.Equality.$tcTestEquality1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r568e_closure+4;
         const $krep_r568a_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.73578996 UTC

[section ""data" . $krep5_r568f_closure" {
     $krep5_r568f_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r568d_closure+2;
         const $krep_r568a_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.736683076 UTC

[section ""data" . Data.Type.Equality.$tc~1_closure" {
     Data.Type.Equality.$tc~1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r568d_closure+2;
         const $krep5_r568f_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.737601915 UTC

[section ""data" . $krep6_r568g_closure" {
     $krep6_r568g_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.738171696 UTC

[section ""data" . $krep7_r568h_closure" {
     $krep7_r568h_closure:
         const :_con_info;
         const $krep6_r568g_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.739070163 UTC

[section ""data" . $krep8_r568i_closure" {
     $krep8_r568i_closure:
         const :_con_info;
         const $krep1_r568b_closure+2;
         const $krep7_r568h_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.73999142 UTC

[section ""data" . $krep9_r568j_closure" {
     $krep9_r568j_closure:
         const :_con_info;
         const $krep3_r568d_closure+2;
         const $krep8_r568i_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.740790039 UTC

[section ""data" . $krep10_r568k_closure" {
     $krep10_r568k_closure:
         const :_con_info;
         const $krep3_r568d_closure+2;
         const $krep9_r568j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.741689666 UTC

[section ""data" . $krep11_r568l_closure" {
     $krep11_r568l_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc~~_closure;
         const $krep10_r568k_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.742502078 UTC

[section ""cstring" . Data.Type.Equality.$tc~3_bytes" {
     Data.Type.Equality.$tc~3_bytes:
         I8[] [126]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.743220393 UTC

[section ""data" . Data.Type.Equality.$tc~2_closure" {
     Data.Type.Equality.$tc~2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc~3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.74396362 UTC

[section ""data" . Data.Type.Equality.$tc~_closure" {
     Data.Type.Equality.$tc~_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc~2_closure+1;
         const Data.Type.Equality.$tc~1_closure+4;
         const 11470827771536267938;
         const 3625512399163125290;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.744594168 UTC

[section ""data" . $krep12_r568m_closure" {
     $krep12_r568m_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Type.Equality.$tc~_closure+1;
         const $krep9_r568j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.745186212 UTC

[section ""data" . Data.Type.Equality.$tc'C:~1_closure" {
     Data.Type.Equality.$tc'C:~1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r568l_closure+1;
         const $krep12_r568m_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.745849112 UTC

[section ""cstring" . Data.Type.Equality.$tc'C:~3_bytes" {
     Data.Type.Equality.$tc'C:~3_bytes:
         I8[] [39,67,58,126]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.746384605 UTC

[section ""data" . Data.Type.Equality.$tc'C:~2_closure" {
     Data.Type.Equality.$tc'C:~2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc'C:~3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.746957456 UTC

[section ""data" . Data.Type.Equality.$tc'C:~_closure" {
     Data.Type.Equality.$tc'C:~_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc'C:~2_closure+1;
         const Data.Type.Equality.$tc'C:~1_closure+4;
         const 6023002849810837484;
         const 5427525916893308990;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.747544009 UTC

[section ""cstring" . Data.Type.Equality.$tc:~:3_bytes" {
     Data.Type.Equality.$tc:~:3_bytes:
         I8[] [58,126,58]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.748373451 UTC

[section ""data" . Data.Type.Equality.$tc:~:2_closure" {
     Data.Type.Equality.$tc:~:2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc:~:3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.749007156 UTC

[section ""data" . Data.Type.Equality.$tc:~:_closure" {
     Data.Type.Equality.$tc:~:_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc:~:2_closure+1;
         const Data.Type.Equality.$tc:~:1_closure+4;
         const 10597498348876412676;
         const 16281320961088145472;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.750160125 UTC

[section ""data" . $krep13_r568n_closure" {
     $krep13_r568n_closure:
         const :_con_info;
         const $krep1_r568b_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.750697832 UTC

[section ""data" . $krep14_r568o_closure" {
     $krep14_r568o_closure:
         const :_con_info;
         const $krep1_r568b_closure+2;
         const $krep13_r568n_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.751228668 UTC

[section ""data" . $krep15_r568p_closure" {
     $krep15_r568p_closure:
         const :_con_info;
         const $krep3_r568d_closure+2;
         const $krep14_r568o_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.751834631 UTC

[section ""data" . Data.Type.Equality.$tc'Refl1_closure" {
     Data.Type.Equality.$tc'Refl1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Type.Equality.$tc:~:_closure+1;
         const $krep15_r568p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.752342315 UTC

[section ""cstring" . Data.Type.Equality.$tc'Refl3_bytes" {
     Data.Type.Equality.$tc'Refl3_bytes:
         I8[] [39,82,101,102,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.752894328 UTC

[section ""data" . Data.Type.Equality.$tc'Refl2_closure" {
     Data.Type.Equality.$tc'Refl2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc'Refl3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.753499569 UTC

[section ""data" . Data.Type.Equality.$tc'Refl_closure" {
     Data.Type.Equality.$tc'Refl_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc'Refl2_closure+1;
         const Data.Type.Equality.$tc'Refl1_closure+1;
         const 16680242040484769242;
         const 2864388906562808793;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.754096881 UTC

[section ""cstring" . Data.Type.Equality.$tc:~~:3_bytes" {
     Data.Type.Equality.$tc:~~:3_bytes:
         I8[] [58,126,126,58]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.754657095 UTC

[section ""data" . Data.Type.Equality.$tc:~~:2_closure" {
     Data.Type.Equality.$tc:~~:2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc:~~:3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.755238787 UTC

[section ""data" . Data.Type.Equality.$tc:~~:_closure" {
     Data.Type.Equality.$tc:~~:_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc:~~:2_closure+1;
         const Data.Type.Equality.$tc:~~:1_closure+4;
         const 4361259188665111259;
         const 11706467685470543992;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.755846171 UTC

[section ""data" . $krep16_r568q_closure" {
     $krep16_r568q_closure:
         const :_con_info;
         const $krep3_r568d_closure+2;
         const $krep15_r568p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.75642844 UTC

[section ""data" . Data.Type.Equality.$tc'HRefl1_closure" {
     Data.Type.Equality.$tc'HRefl1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Type.Equality.$tc:~~:_closure+1;
         const $krep16_r568q_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.756998581 UTC

[section ""cstring" . Data.Type.Equality.$tc'HRefl3_bytes" {
     Data.Type.Equality.$tc'HRefl3_bytes:
         I8[] [39,72,82,101,102,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.757653338 UTC

[section ""data" . Data.Type.Equality.$tc'HRefl2_closure" {
     Data.Type.Equality.$tc'HRefl2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc'HRefl3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.758205366 UTC

[section ""data" . Data.Type.Equality.$tc'HRefl_closure" {
     Data.Type.Equality.$tc'HRefl_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc'HRefl2_closure+1;
         const Data.Type.Equality.$tc'HRefl1_closure+1;
         const 4486133906173668740;
         const 6341741464738386857;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.758762858 UTC

[section ""cstring" . Data.Type.Equality.$tcTestEquality3_bytes" {
     Data.Type.Equality.$tcTestEquality3_bytes:
         I8[] [84,101,115,116,69,113,117,97,108,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.759298493 UTC

[section ""data" . Data.Type.Equality.$tcTestEquality2_closure" {
     Data.Type.Equality.$tcTestEquality2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tcTestEquality3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.759872672 UTC

[section ""data" . Data.Type.Equality.$tcTestEquality_closure" {
     Data.Type.Equality.$tcTestEquality_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tcTestEquality2_closure+1;
         const Data.Type.Equality.$tcTestEquality1_closure+4;
         const 2944680549948432194;
         const 17791533211054855448;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.760762963 UTC

[section ""data" . Data.Type.Equality.HRefl_closure" {
     Data.Type.Equality.HRefl_closure:
         const Data.Type.Equality.HRefl_info;
 },
 Data.Type.Equality.HRefl_entry() //  []
         { info_tbl: [(c56HL,
                       label: Data.Type.Equality.HRefl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56HL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56HP; else goto c56HO;
       c56HP: // global
           HpAlloc = 16;
           R1 = Data.Type.Equality.HRefl_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c56HO: // global
           I64[Hp - 8] = Data.Type.Equality.HRefl_con_info;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.761846599 UTC

[section ""data" . Data.Type.Equality.Refl_closure" {
     Data.Type.Equality.Refl_closure:
         const Data.Type.Equality.Refl_info;
 },
 Data.Type.Equality.Refl_entry() //  []
         { info_tbl: [(c56HV,
                       label: Data.Type.Equality.Refl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56HV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56HZ; else goto c56HY;
       c56HZ: // global
           HpAlloc = 16;
           R1 = Data.Type.Equality.Refl_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c56HY: // global
           I64[Hp - 8] = Data.Type.Equality.Refl_con_info;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.762685711 UTC

[Data.Type.Equality.HRefl_con_entry() //  [R1]
         { info_tbl: [(c56I0,
                       label: Data.Type.Equality.HRefl_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,84,121,112,101,46,69,113,117,97,108,105,116,121,46,72,82,101,102,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56I0: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.763505248 UTC

[Data.Type.Equality.Refl_con_entry() //  [R1]
         { info_tbl: [(c56I1,
                       label: Data.Type.Equality.Refl_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,84,121,112,101,46,69,113,117,97,108,105,116,121,46,82,101,102,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56I1: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.7651917 UTC

[section ""relreadonly" . S56eO_srt" {
     S56eO_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Type.Equality.$fEnum:~:1_closure;
         const Data.Type.Equality.$fEnum:~:_$ctoEnum_closure;
         const Data.Type.Equality.$fEnum:~:_$csucc_closure;
         const Data.Type.Equality.$w$cenumFromTo_closure;
         const Data.Type.Equality.$fEnum:~:_$cenumFromTo_closure;
         const Data.Type.Equality.$w$cenumFromThen_closure;
         const Data.Type.Equality.$fEnum:~:2_closure;
         const Data.Type.Equality.$fEnum:~:_$cenumFromThen_closure;
         const Data.Type.Equality.$w$cenumFrom_closure;
         const Data.Type.Equality.$fEnum:~:_$cenumFrom_closure;
         const Data.Type.Equality.$w$cenumFromThenTo_closure;
         const Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_closure;
         const Data.Type.Equality.$fEnum:~:_closure;
         const Data.Type.Equality.$fEnum:~~:1_closure;
         const Data.Type.Equality.$fEnum:~~:_$ctoEnum_closure;
         const Data.Type.Equality.$fEnum:~~:_$csucc_closure;
         const Data.Type.Equality.$w$cenumFromTo1_closure;
         const Data.Type.Equality.$fEnum:~~:_$cenumFromTo_closure;
         const Data.Type.Equality.$w$cenumFromThen1_closure;
         const Data.Type.Equality.$fEnum:~~:_$cenumFromThen_closure;
         const Data.Type.Equality.$w$cenumFrom1_closure;
         const Data.Type.Equality.$fEnum:~~:_$cenumFrom_closure;
         const Data.Type.Equality.$w$cenumFromThenTo1_closure;
         const Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_closure;
         const Data.Type.Equality.$fEnum:~~:_closure;
         const Data.Type.Equality.$fRead:~:2_closure;
         const Data.Type.Equality.$fShow:~:_$cshowsPrec_closure;
         const Data.Type.Equality.$fShow:~:_$cshow_closure;
         const Data.Type.Equality.$fShow:~:1_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Type.Equality.$fRead:~:1_closure;
         const Data.Type.Equality.$fRead:~:_lexeme_closure;
         const GHC.Read.list3_closure;
         const Data.Type.Equality.$fRead:~:4_closure;
         const Data.Type.Equality.$fRead:~:_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Type.Equality.$fRead:~:_$creadListPrec_closure;
         const Data.Type.Equality.$fRead:~:_$creadList_closure;
         const Data.Type.Equality.$fRead:~:_closure;
         const Data.Type.Equality.$fRead:~~:2_closure;
         const Data.Type.Equality.$fShow:~~:_$cshowsPrec_closure;
         const Data.Type.Equality.$fShow:~~:_$cshow_closure;
         const Data.Type.Equality.$fShow:~~:1_closure;
         const Data.Type.Equality.$fRead:~~:1_closure;
         const Data.Type.Equality.$fRead:~~:_lexeme_closure;
         const Data.Type.Equality.$fRead:~~:4_closure;
         const Data.Type.Equality.$fRead:~~:_$creadsPrec_closure;
         const Data.Type.Equality.$fRead:~~:_$creadListPrec_closure;
         const Data.Type.Equality.$fRead:~~:_$creadList_closure;
         const Data.Type.Equality.$fRead:~~:_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.766102758 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:00:01.766889897 UTC

[section ""data" . Data.Type.Equality.$p1~_closure" {
     Data.Type.Equality.$p1~_closure:
         const Data.Type.Equality.$p1~_info;
 },
 Data.Type.Equality.$p1~_entry() //  [R2]
         { info_tbl: [(c56I6,
                       label: Data.Type.Equality.$p1~_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56I6: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.767786598 UTC

[section ""data" . Data.Type.Equality.testEquality_closure" {
     Data.Type.Equality.testEquality_closure:
         const Data.Type.Equality.testEquality_info;
 },
 Data.Type.Equality.testEquality_entry() //  [R2]
         { info_tbl: [(c56Id,
                       label: Data.Type.Equality.testEquality_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Id: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.768450363 UTC

[section ""data" . Data.Type.Equality.$WHRefl_closure" {
     Data.Type.Equality.$WHRefl_closure:
         const Data.Type.Equality.HRefl_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.768994266 UTC

[section ""data" . Data.Type.Equality.$WRefl_closure" {
     Data.Type.Equality.$WRefl_closure:
         const Data.Type.Equality.Refl_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.770600123 UTC

[section ""data" . Data.Type.Equality.$f~kab_$cp1~_closure" {
     Data.Type.Equality.$f~kab_$cp1~_closure:
         const Data.Type.Equality.$f~kab_$cp1~_info;
 },
 Data.Type.Equality.$f~kab_$cp1~_entry() //  [R2]
         { info_tbl: [(c56Im,
                       label: Data.Type.Equality.$f~kab_$cp1~_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Im: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56In; else goto c56Io;
       c56In: // global
           R2 = R2;
           R1 = Data.Type.Equality.$f~kab_$cp1~_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56Io: // global
           I64[Sp - 16] = block_c56Ik_info;
           _s568u::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s568u::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56Ik() //  []
         { info_tbl: [(c56Ik,
                       label: block_c56Ik_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Ik: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.771818736 UTC

[section ""data" . Data.Type.Equality.$f~kab_closure" {
     Data.Type.Equality.$f~kab_closure:
         const Data.Type.Equality.$f~kab_info;
 },
 Data.Type.Equality.$f~kab_entry() //  [R2]
         { info_tbl: [(c56Iu,
                       label: Data.Type.Equality.$f~kab_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Iu: // global
           R2 = R2;
           call Data.Type.Equality.$f~kab_$cp1~_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.772542721 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:3_closure" {
     Data.Type.Equality.$fEnum:~:3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.773828092 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$cfromEnum_closure" {
     Data.Type.Equality.$fEnum:~:_$cfromEnum_closure:
         const Data.Type.Equality.$fEnum:~:_$cfromEnum_info;
 },
 Data.Type.Equality.$fEnum:~:_$cfromEnum_entry() //  [R2, R3]
         { info_tbl: [(c56IG,
                       label: Data.Type.Equality.$fEnum:~:_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56IG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56IH; else goto c56II;
       c56IH: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$cfromEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56II: // global
           I64[Sp - 16] = block_c56IB_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56IB() //  []
         { info_tbl: [(c56IB,
                       label: block_c56IB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56IB: // global
           _s568w::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56ID_info;
           R1 = _s568w::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56IN; else goto c56IE;
       u56IN: // global
           call _c56ID() args: 0, res: 0, upd: 0;
       c56IE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56ID() //  []
         { info_tbl: [(c56ID,
                       label: block_c56ID_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ID: // global
           R1 = Data.Type.Equality.$fEnum:~:3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.774971885 UTC

[section ""cstring" . lvl_r5689_bytes" {
     lvl_r5689_bytes:
         I8[] [68,97,116,97,46,84,121,112,101,46,69,113,117,97,108,105,116,121,46,116,111,69,110,117,109,58,32,98,97,100,32,97,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.776094638 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:1_closure" {
     Data.Type.Equality.$fEnum:~:1_closure:
         const Data.Type.Equality.$fEnum:~:1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:1_entry() //  [R1]
         { info_tbl: [(c56IW,
                       label: Data.Type.Equality.$fEnum:~:1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56IW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c56IX; else goto c56IY;
       c56IX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56IY: // global
           (_c56IR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c56IR::I64 == 0) goto c56IT; else goto c56IS;
       c56IT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c56IS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c56IR::I64;
           I64[Sp - 24] = block_c56IU_info;
           R2 = lvl_r5689_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c56IU() //  [R1]
         { info_tbl: [(c56IU,
                       label: block_c56IU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56IU: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.778657357 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$ctoEnum_closure" {
     Data.Type.Equality.$fEnum:~:_$ctoEnum_closure:
         const Data.Type.Equality.$fEnum:~:_$ctoEnum_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$ctoEnum_entry() //  [R2, R3]
         { info_tbl: [(c56Jb,
                       label: Data.Type.Equality.$fEnum:~:_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Jb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Jc; else goto c56Jd;
       c56Jc: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$ctoEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Jd: // global
           I64[Sp - 16] = block_c56J6_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56J6() //  []
         { info_tbl: [(c56J6,
                       label: block_c56J6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56J6: // global
           _s568A::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56J8_info;
           R1 = _s568A::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56Jm; else goto c56J9;
       u56Jm: // global
           call _c56J8(R1) args: 0, res: 0, upd: 0;
       c56J9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56J8() //  [R1]
         { info_tbl: [(c56J8,
                       label: block_c56J8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56J8: // global
           if (I64[R1 + 7] == 0) goto c56Jl; else goto c56Jk;
       c56Jl: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c56Jk: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.781301742 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$csucc_closure" {
     Data.Type.Equality.$fEnum:~:_$csucc_closure:
         const Data.Type.Equality.$fEnum:~:_$csucc_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$csucc_entry() //  [R2, R3]
         { info_tbl: [(c56Jv,
                       label: Data.Type.Equality.$fEnum:~:_$csucc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Jv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Jw; else goto c56Jx;
       c56Jw: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$csucc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Jx: // global
           I64[Sp - 16] = block_c56Jr_info;
           _s568E::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s568E::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56Jr() //  []
         { info_tbl: [(c56Jr,
                       label: block_c56Jr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Jr: // global
           _s568E::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56Jt_info;
           R2 = _s568E::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56Jt() //  []
         { info_tbl: [(c56Jt,
                       label: block_c56Jt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Jt: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.784711682 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromTo_closure" {
     Data.Type.Equality.$w$cenumFromTo_closure:
         const Data.Type.Equality.$w$cenumFromTo_info;
         const 0;
 },
 sat_s568P_entry() //  [R1]
         { info_tbl: [(c56JV,
                       label: sat_s568P_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56JV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56JW; else goto c56JX;
       c56JW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56JX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s568N::I64 = I64[R1 + 24];
           if (_s568N::I64 != 0) goto c56JT; else goto c56JU;
       c56JT: // global
           R2 = _s568N::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s568J_entry(R2, R1) args: 24, res: 0, upd: 24;
       c56JU: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s568M_entry() //  [R1]
         { info_tbl: [(c56K8,
                       label: sat_s568M_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56K8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56K9; else goto c56Ka;
       c56K9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56Ka: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c56K7; else goto c56K6;
       c56K7: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c56K6: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s568J_entry() //  [R1, R2]
         { info_tbl: [(c56Kc,
                       label: go_s568J_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Kc: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c56Kg; else goto c56Kf;
       c56Kg: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56Kf: // global
           I64[Hp - 72] = sat_s568P_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s568M_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c56Kh,
                       label: Data.Type.Equality.$w$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Kh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Ki; else goto c56Kj;
       c56Ki: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Kj: // global
           I64[Sp - 16] = block_c56JE_info;
           _s568G::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s568G::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56JE() //  []
         { info_tbl: [(c56JE,
                       label: block_c56JE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56JE: // global
           _s568G::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56JG_info;
           R2 = _s568G::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56JG() //  []
         { info_tbl: [(c56JG,
                       label: block_c56JG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56JG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56Kn; else goto c56Km;
       c56Kn: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c56Km: // global
           I64[Hp - 8] = go_s568J_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call go_s568J_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.788765892 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$cenumFromTo_closure" {
     Data.Type.Equality.$fEnum:~:_$cenumFromTo_closure:
         const Data.Type.Equality.$fEnum:~:_$cenumFromTo_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$cenumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c56Kv,
                       label: Data.Type.Equality.$fEnum:~:_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Kv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c56Kz; else goto c56KA;
       c56Kz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$cenumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56KA: // global
           I64[Sp - 24] = block_c56Ks_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u56KI; else goto c56Kt;
       u56KI: // global
           call _c56Ks(R1) args: 0, res: 0, upd: 0;
       c56Kt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Ks() //  [R1]
         { info_tbl: [(c56Ks,
                       label: block_c56Ks_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Ks: // global
           I64[Sp] = block_c56Ky_info;
           _s568T::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s568T::P64;
           if (R1 & 7 != 0) goto u56KH; else goto c56KC;
       u56KH: // global
           call _c56Ky(R1) args: 0, res: 0, upd: 0;
       c56KC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Ky() //  [R1]
         { info_tbl: [(c56Ky,
                       label: block_c56Ky_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Ky: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromTo_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.790788558 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:2_closure" {
     Data.Type.Equality.$fEnum:~:2_closure:
         const Data.Type.Equality.$fEnum:~:2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:2_entry() //  [R1]
         { info_tbl: [(c56KP,
                       label: Data.Type.Equality.$fEnum:~:2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56KP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56KQ; else goto c56KR;
       c56KQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56KR: // global
           (_c56KM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c56KM::I64 == 0) goto c56KO; else goto c56KN;
       c56KO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c56KN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c56KM::I64;
           R3 = 0;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.Enum.efdInt_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.792278362 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromThen_closure" {
     Data.Type.Equality.$w$cenumFromThen_closure:
         const Data.Type.Equality.$w$cenumFromThen_info;
         const 0;
 },
 sat_s568Y_entry() //  [R1, R2]
         { info_tbl: [(c56L5,
                       label: sat_s568Y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56L5: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$ctoEnum_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFromThen_entry() //  [R2, R3, R4]
         { info_tbl: [(c56L8,
                       label: Data.Type.Equality.$w$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56L8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56L9; else goto c56La;
       c56L9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56La: // global
           I64[Sp - 16] = block_c56KW_info;
           _s568V::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s568V::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56KW() //  []
         { info_tbl: [(c56KW,
                       label: block_c56KW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56KW: // global
           I64[Sp] = block_c56KY_info;
           R2 = P64[Sp + 8];
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56KY() //  []
         { info_tbl: [(c56KY,
                       label: block_c56KY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56KY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56Le; else goto c56Ld;
       c56Le: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c56Ld: // global
           I64[Hp - 8] = sat_s568Y_info;
           P64[Hp] = P64[Sp + 8];
           R3 = Data.Type.Equality.$fEnum:~:2_closure;
           R2 = Hp - 7;
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.794303048 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$cenumFromThen_closure" {
     Data.Type.Equality.$fEnum:~:_$cenumFromThen_closure:
         const Data.Type.Equality.$fEnum:~:_$cenumFromThen_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$cenumFromThen_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(c56Lm,
                       label: Data.Type.Equality.$fEnum:~:_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Lm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c56Lq; else goto c56Lr;
       c56Lq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$cenumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Lr: // global
           I64[Sp - 24] = block_c56Lj_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u56Lz; else goto c56Lk;
       u56Lz: // global
           call _c56Lj(R1) args: 0, res: 0, upd: 0;
       c56Lk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Lj() //  [R1]
         { info_tbl: [(c56Lj,
                       label: block_c56Lj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Lj: // global
           I64[Sp] = block_c56Lp_info;
           _s5692::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s5692::P64;
           if (R1 & 7 != 0) goto u56Ly; else goto c56Lt;
       u56Ly: // global
           call _c56Lp(R1) args: 0, res: 0, upd: 0;
       c56Lt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Lp() //  [R1]
         { info_tbl: [(c56Lp,
                       label: block_c56Lp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Lp: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromThen_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.796697423 UTC

[section ""data" . Data.Type.Equality.$w$cenumFrom_closure" {
     Data.Type.Equality.$w$cenumFrom_closure:
         const Data.Type.Equality.$w$cenumFrom_info;
         const 0;
 },
 sat_s569c_entry() //  [R1]
         { info_tbl: [(c56LV,
                       label: sat_s569c_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56LV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56LW; else goto c56LX;
       c56LW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56LX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s569a::I64 = I64[R1 + 24];
           if (_s569a::I64 != 9223372036854775807) goto c56LT; else goto c56LU;
       c56LT: // global
           R2 = _s569a::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s5696_entry(R2, R1) args: 24, res: 0, upd: 24;
       c56LU: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s5699_entry() //  [R1]
         { info_tbl: [(c56M8,
                       label: sat_s5699_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56M8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56M9; else goto c56Ma;
       c56M9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56Ma: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c56M7; else goto c56M6;
       c56M7: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c56M6: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s5696_entry() //  [R1, R2]
         { info_tbl: [(c56Mc,
                       label: go_s5696_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Mc: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c56Mg; else goto c56Mf;
       c56Mg: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56Mf: // global
           I64[Hp - 72] = sat_s569c_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s5699_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFrom_entry() //  [R2, R3]
         { info_tbl: [(c56Mh,
                       label: Data.Type.Equality.$w$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Mh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Mi; else goto c56Mj;
       c56Mi: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Mj: // global
           I64[Sp - 16] = block_c56LE_info;
           _s5694::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s5694::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56LE() //  []
         { info_tbl: [(c56LE,
                       label: block_c56LE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56LE: // global
           _s5694::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56LG_info;
           R2 = _s5694::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56LG() //  []
         { info_tbl: [(c56LG,
                       label: block_c56LG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56LG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56Mn; else goto c56Mm;
       c56Mn: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c56Mm: // global
           I64[Hp - 8] = go_s5696_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call go_s5696_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.799385551 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$cenumFrom_closure" {
     Data.Type.Equality.$fEnum:~:_$cenumFrom_closure:
         const Data.Type.Equality.$fEnum:~:_$cenumFrom_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$cenumFrom_entry() //  [R2, R3]
         { info_tbl: [(c56Mv,
                       label: Data.Type.Equality.$fEnum:~:_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Mv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Mw; else goto c56Mx;
       c56Mw: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$cenumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Mx: // global
           I64[Sp - 16] = block_c56Ms_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56MB; else goto c56Mt;
       u56MB: // global
           call _c56Ms(R1) args: 0, res: 0, upd: 0;
       c56Mt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Ms() //  [R1]
         { info_tbl: [(c56Ms,
                       label: block_c56Ms_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Ms: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Type.Equality.$w$cenumFrom_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.801904679 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromThenTo_closure" {
     Data.Type.Equality.$w$cenumFromThenTo_closure:
         const Data.Type.Equality.$w$cenumFromThenTo_info;
         const 0;
 },
 sat_s569p_entry() //  [R1]
         { info_tbl: [(c56N0,
                       label: sat_s569p_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56N0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56N1; else goto c56N2;
       c56N1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56N2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s569k_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s569o_entry() //  [R1]
         { info_tbl: [(c56Nb,
                       label: sat_s569o_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Nb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Nc; else goto c56Nd;
       c56Nc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56Nd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c56Na; else goto c56N9;
       c56Na: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c56N9: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s569r_entry() //  [R1]
         { info_tbl: [(c56Nn,
                       label: sat_s569r_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Nn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56No; else goto c56Np;
       c56No: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56Np: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c56Nm; else goto c56Nl;
       c56Nm: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c56Nl: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s569k_entry() //  [R1, R2]
         { info_tbl: [(c56Nt,
                       label: go_up_s569k_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Nt: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c56Nx; else goto c56Nw;
       c56Nx: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56Nw: // global
           if (%MO_S_Le_W64(R2, 0)) goto c56Nr; else goto c56Ns;
       c56Nr: // global
           I64[Hp - 72] = sat_s569p_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s569o_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c56Ns: // global
           I64[Hp - 72] = sat_s569r_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c56Nz::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c56Nz::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569s_entry() //  [R1]
         { info_tbl: [(c56NA,
                       label: sat_s569s_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56NA: // global
           _s569s::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c56NB; else goto c56NC;
       c56NC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56NE; else goto c56ND;
       c56NE: // global
           HpAlloc = 16;
           goto c56NB;
       c56NB: // global
           R1 = _s569s::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56ND: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s569s::P64;
           I64[Hp - 8] = go_up_s569k_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call go_up_s569k_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$w$cenumFromThenTo_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c56NF,
                       label: Data.Type.Equality.$w$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56NF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56NG; else goto c56NH;
       c56NG: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56NH: // global
           I64[Sp - 16] = block_c56MG_info;
           _s569g::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s569g::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56MG() //  []
         { info_tbl: [(c56MG,
                       label: block_c56MG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56MG: // global
           _s569g::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56MI_info;
           R2 = _s569g::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56MI() //  []
         { info_tbl: [(c56MI,
                       label: block_c56MI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56MI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56NL; else goto c56NK;
       c56NL: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c56NK: // global
           I64[Hp - 8] = sat_s569s_info;
           R2 = Hp - 8;
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.805947808 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_closure" {
     Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_closure:
         const Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(c56NT,
                       label: Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56NT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c56O9; else goto c56Oa;
       c56O9: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Oa: // global
           I64[Sp - 32] = block_c56NQ_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u56Oi; else goto c56NR;
       u56Oi: // global
           call _c56NQ(R1) args: 0, res: 0, upd: 0;
       c56NR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56NQ() //  [R1]
         { info_tbl: [(c56NQ,
                       label: block_c56NQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56NQ: // global
           I64[Sp] = block_c56NW_info;
           _s569x::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s569x::P64;
           if (R1 & 7 != 0) goto u56Oh; else goto c56NX;
       u56Oh: // global
           call _c56NW(R1) args: 0, res: 0, upd: 0;
       c56NX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56NW() //  [R1]
         { info_tbl: [(c56NW,
                       label: block_c56NW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56NW: // global
           I64[Sp] = block_c56O1_info;
           _s569y::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s569y::P64;
           if (R1 & 7 != 0) goto u56Oj; else goto c56O2;
       u56Oj: // global
           call _c56O1(R1) args: 0, res: 0, upd: 0;
       c56O2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56O1() //  [R1]
         { info_tbl: [(c56O1,
                       label: block_c56O1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56O1: // global
           _s569y::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c56O6_info;
           R5 = R1;
           R4 = _s569y::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromThenTo_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56O6() //  [R1, R2]
         { info_tbl: [(c56O6,
                       label: block_c56O6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56O6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c56Og; else goto c56Of;
       c56Og: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c56Of: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.809096779 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_closure" {
     Data.Type.Equality.$fEnum:~:_closure:
         const Data.Type.Equality.$fEnum:~:_info;
         const 0;
 },
 sat_s569L_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c56Ot,
                       label: sat_s569L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Ot: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569K_entry() //  [R1, R2, R3]
         { info_tbl: [(c56OB,
                       label: sat_s569K_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56OB: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fEnum:~:_$cenumFromTo_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569J_entry() //  [R1, R2, R3]
         { info_tbl: [(c56OJ,
                       label: sat_s569J_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56OJ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fEnum:~:_$cenumFromThen_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569I_entry() //  [R1, R2]
         { info_tbl: [(c56OR,
                       label: sat_s569I_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56OR: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$cenumFrom_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569H_entry() //  [R1, R2]
         { info_tbl: [(c56OZ,
                       label: sat_s569H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56OZ: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$cfromEnum_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569G_entry() //  [R1, R2]
         { info_tbl: [(c56P7,
                       label: sat_s569G_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56P7: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$ctoEnum_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569F_entry() //  [R1, R2]
         { info_tbl: [(c56Pf,
                       label: sat_s569F_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Pf: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$csucc_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569E_entry() //  [R1, R2]
         { info_tbl: [(c56Pn,
                       label: sat_s569E_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Pn: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$csucc_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fEnum:~:_entry() //  [R2]
         { info_tbl: [(c56Pr,
                       label: Data.Type.Equality.$fEnum:~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Pr: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto c56Pv; else goto c56Pu;
       c56Pv: // global
           HpAlloc = 200;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56Pu: // global
           I64[Hp - 192] = sat_s569L_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s569K_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s569J_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_s569I_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s569H_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s569G_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s569F_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s569E_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = Hp - 95;
           P64[Hp - 40] = Hp - 111;
           P64[Hp - 32] = Hp - 127;
           P64[Hp - 24] = Hp - 143;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 174;
           P64[Hp] = Hp - 189;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.812081527 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$cfromEnum_closure" {
     Data.Type.Equality.$fEnum:~~:_$cfromEnum_closure:
         const Data.Type.Equality.$fEnum:~~:_$cfromEnum_info;
 },
 Data.Type.Equality.$fEnum:~~:_$cfromEnum_entry() //  [R2, R3]
         { info_tbl: [(c56PF,
                       label: Data.Type.Equality.$fEnum:~~:_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56PF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56PG; else goto c56PH;
       c56PG: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$cfromEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56PH: // global
           I64[Sp - 16] = block_c56PA_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56PA() //  []
         { info_tbl: [(c56PA,
                       label: block_c56PA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56PA: // global
           _s569N::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56PC_info;
           R1 = _s569N::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56PM; else goto c56PD;
       u56PM: // global
           call _c56PC() args: 0, res: 0, upd: 0;
       c56PD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56PC() //  []
         { info_tbl: [(c56PC,
                       label: block_c56PC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56PC: // global
           R1 = Data.Type.Equality.$fEnum:~:3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.813685678 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:1_closure" {
     Data.Type.Equality.$fEnum:~~:1_closure:
         const Data.Type.Equality.$fEnum:~~:1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:1_entry() //  [R1]
         { info_tbl: [(c56PV,
                       label: Data.Type.Equality.$fEnum:~~:1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56PV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c56PW; else goto c56PX;
       c56PW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56PX: // global
           (_c56PQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c56PQ::I64 == 0) goto c56PS; else goto c56PR;
       c56PS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c56PR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c56PQ::I64;
           I64[Sp - 24] = block_c56PT_info;
           R2 = lvl_r5689_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c56PT() //  [R1]
         { info_tbl: [(c56PT,
                       label: block_c56PT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56PT: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.815190077 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$ctoEnum_closure" {
     Data.Type.Equality.$fEnum:~~:_$ctoEnum_closure:
         const Data.Type.Equality.$fEnum:~~:_$ctoEnum_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$ctoEnum_entry() //  [R2, R3]
         { info_tbl: [(c56Qa,
                       label: Data.Type.Equality.$fEnum:~~:_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Qa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Qb; else goto c56Qc;
       c56Qb: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$ctoEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Qc: // global
           I64[Sp - 16] = block_c56Q5_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56Q5() //  []
         { info_tbl: [(c56Q5,
                       label: block_c56Q5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Q5: // global
           _s569R::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56Q7_info;
           R1 = _s569R::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56Ql; else goto c56Q8;
       u56Ql: // global
           call _c56Q7(R1) args: 0, res: 0, upd: 0;
       c56Q8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Q7() //  [R1]
         { info_tbl: [(c56Q7,
                       label: block_c56Q7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Q7: // global
           if (I64[R1 + 7] == 0) goto c56Qk; else goto c56Qj;
       c56Qk: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c56Qj: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.816723016 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$csucc_closure" {
     Data.Type.Equality.$fEnum:~~:_$csucc_closure:
         const Data.Type.Equality.$fEnum:~~:_$csucc_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$csucc_entry() //  [R2, R3]
         { info_tbl: [(c56Qu,
                       label: Data.Type.Equality.$fEnum:~~:_$csucc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Qu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Qv; else goto c56Qw;
       c56Qv: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$csucc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Qw: // global
           I64[Sp - 16] = block_c56Qq_info;
           _s569V::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s569V::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56Qq() //  []
         { info_tbl: [(c56Qq,
                       label: block_c56Qq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Qq: // global
           _s569V::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56Qs_info;
           R2 = _s569V::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56Qs() //  []
         { info_tbl: [(c56Qs,
                       label: block_c56Qs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Qs: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.818992927 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromTo1_closure" {
     Data.Type.Equality.$w$cenumFromTo1_closure:
         const Data.Type.Equality.$w$cenumFromTo1_info;
         const 0;
 },
 sat_s56a6_entry() //  [R1]
         { info_tbl: [(c56QU,
                       label: sat_s56a6_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56QU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56QV; else goto c56QW;
       c56QV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56QW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s56a4::I64 = I64[R1 + 24];
           if (_s56a4::I64 != 0) goto c56QS; else goto c56QT;
       c56QS: // global
           R2 = _s56a4::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s56a0_entry(R2, R1) args: 24, res: 0, upd: 24;
       c56QT: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56a3_entry() //  [R1]
         { info_tbl: [(c56R7,
                       label: sat_s56a3_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56R7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56R8; else goto c56R9;
       c56R8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56R9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c56R6; else goto c56R5;
       c56R6: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c56R5: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s56a0_entry() //  [R1, R2]
         { info_tbl: [(c56Rb,
                       label: go_s56a0_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Rb: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c56Rf; else goto c56Re;
       c56Rf: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56Re: // global
           I64[Hp - 72] = sat_s56a6_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s56a3_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFromTo1_entry() //  [R2, R3, R4]
         { info_tbl: [(c56Rg,
                       label: Data.Type.Equality.$w$cenumFromTo1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Rg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Rh; else goto c56Ri;
       c56Rh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromTo1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Ri: // global
           I64[Sp - 16] = block_c56QD_info;
           _s569X::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s569X::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56QD() //  []
         { info_tbl: [(c56QD,
                       label: block_c56QD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56QD: // global
           _s569X::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56QF_info;
           R2 = _s569X::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56QF() //  []
         { info_tbl: [(c56QF,
                       label: block_c56QF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56QF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56Rm; else goto c56Rl;
       c56Rm: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c56Rl: // global
           I64[Hp - 8] = go_s56a0_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call go_s56a0_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.822229628 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$cenumFromTo_closure" {
     Data.Type.Equality.$fEnum:~~:_$cenumFromTo_closure:
         const Data.Type.Equality.$fEnum:~~:_$cenumFromTo_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$cenumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c56Ru,
                       label: Data.Type.Equality.$fEnum:~~:_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Ru: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c56Ry; else goto c56Rz;
       c56Ry: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$cenumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Rz: // global
           I64[Sp - 24] = block_c56Rr_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u56RH; else goto c56Rs;
       u56RH: // global
           call _c56Rr(R1) args: 0, res: 0, upd: 0;
       c56Rs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Rr() //  [R1]
         { info_tbl: [(c56Rr,
                       label: block_c56Rr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Rr: // global
           I64[Sp] = block_c56Rx_info;
           _s56aa::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s56aa::P64;
           if (R1 & 7 != 0) goto u56RG; else goto c56RB;
       u56RG: // global
           call _c56Rx(R1) args: 0, res: 0, upd: 0;
       c56RB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Rx() //  [R1]
         { info_tbl: [(c56Rx,
                       label: block_c56Rx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Rx: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromTo1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.825452433 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromThen1_closure" {
     Data.Type.Equality.$w$cenumFromThen1_closure:
         const Data.Type.Equality.$w$cenumFromThen1_info;
         const 0;
 },
 sat_s56af_entry() //  [R1, R2]
         { info_tbl: [(c56RV,
                       label: sat_s56af_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56RV: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$ctoEnum_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFromThen1_entry() //  [R2, R3, R4]
         { info_tbl: [(c56RY,
                       label: Data.Type.Equality.$w$cenumFromThen1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56RY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56RZ; else goto c56S0;
       c56RZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromThen1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56S0: // global
           I64[Sp - 16] = block_c56RM_info;
           _s56ac::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s56ac::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56RM() //  []
         { info_tbl: [(c56RM,
                       label: block_c56RM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56RM: // global
           I64[Sp] = block_c56RO_info;
           R2 = P64[Sp + 8];
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56RO() //  []
         { info_tbl: [(c56RO,
                       label: block_c56RO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56RO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56S4; else goto c56S3;
       c56S4: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c56S3: // global
           I64[Hp - 8] = sat_s56af_info;
           P64[Hp] = P64[Sp + 8];
           R3 = Data.Type.Equality.$fEnum:~:2_closure;
           R2 = Hp - 7;
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.828183903 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$cenumFromThen_closure" {
     Data.Type.Equality.$fEnum:~~:_$cenumFromThen_closure:
         const Data.Type.Equality.$fEnum:~~:_$cenumFromThen_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$cenumFromThen_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c56Sc,
                       label: Data.Type.Equality.$fEnum:~~:_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Sc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c56Sg; else goto c56Sh;
       c56Sg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$cenumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Sh: // global
           I64[Sp - 24] = block_c56S9_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u56Sp; else goto c56Sa;
       u56Sp: // global
           call _c56S9(R1) args: 0, res: 0, upd: 0;
       c56Sa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56S9() //  [R1]
         { info_tbl: [(c56S9,
                       label: block_c56S9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56S9: // global
           I64[Sp] = block_c56Sf_info;
           _s56aj::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s56aj::P64;
           if (R1 & 7 != 0) goto u56So; else goto c56Sj;
       u56So: // global
           call _c56Sf(R1) args: 0, res: 0, upd: 0;
       c56Sj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Sf() //  [R1]
         { info_tbl: [(c56Sf,
                       label: block_c56Sf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Sf: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromThen1_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.831480058 UTC

[section ""data" . Data.Type.Equality.$w$cenumFrom1_closure" {
     Data.Type.Equality.$w$cenumFrom1_closure:
         const Data.Type.Equality.$w$cenumFrom1_info;
         const 0;
 },
 sat_s56at_entry() //  [R1]
         { info_tbl: [(c56SL,
                       label: sat_s56at_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56SL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56SM; else goto c56SN;
       c56SM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56SN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s56ar::I64 = I64[R1 + 24];
           if (_s56ar::I64 != 9223372036854775807) goto c56SJ; else goto c56SK;
       c56SJ: // global
           R2 = _s56ar::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s56an_entry(R2, R1) args: 24, res: 0, upd: 24;
       c56SK: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56aq_entry() //  [R1]
         { info_tbl: [(c56SY,
                       label: sat_s56aq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56SY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56SZ; else goto c56T0;
       c56SZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56T0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c56SX; else goto c56SW;
       c56SX: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c56SW: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s56an_entry() //  [R1, R2]
         { info_tbl: [(c56T2,
                       label: go_s56an_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56T2: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c56T6; else goto c56T5;
       c56T6: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56T5: // global
           I64[Hp - 72] = sat_s56at_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s56aq_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFrom1_entry() //  [R2, R3]
         { info_tbl: [(c56T7,
                       label: Data.Type.Equality.$w$cenumFrom1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56T7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56T8; else goto c56T9;
       c56T8: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFrom1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56T9: // global
           I64[Sp - 16] = block_c56Su_info;
           _s56al::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s56al::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56Su() //  []
         { info_tbl: [(c56Su,
                       label: block_c56Su_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Su: // global
           _s56al::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56Sw_info;
           R2 = _s56al::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56Sw() //  []
         { info_tbl: [(c56Sw,
                       label: block_c56Sw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Sw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56Td; else goto c56Tc;
       c56Td: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c56Tc: // global
           I64[Hp - 8] = go_s56an_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call go_s56an_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.83436498 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$cenumFrom_closure" {
     Data.Type.Equality.$fEnum:~~:_$cenumFrom_closure:
         const Data.Type.Equality.$fEnum:~~:_$cenumFrom_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$cenumFrom_entry() //  [R2, R3]
         { info_tbl: [(c56Tl,
                       label: Data.Type.Equality.$fEnum:~~:_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Tl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Tm; else goto c56Tn;
       c56Tm: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$cenumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Tn: // global
           I64[Sp - 16] = block_c56Ti_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56Tr; else goto c56Tj;
       u56Tr: // global
           call _c56Ti(R1) args: 0, res: 0, upd: 0;
       c56Tj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Ti() //  [R1]
         { info_tbl: [(c56Ti,
                       label: block_c56Ti_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Ti: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Type.Equality.$w$cenumFrom1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.836749544 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromThenTo1_closure" {
     Data.Type.Equality.$w$cenumFromThenTo1_closure:
         const Data.Type.Equality.$w$cenumFromThenTo1_info;
         const 0;
 },
 sat_s56aG_entry() //  [R1]
         { info_tbl: [(c56TQ,
                       label: sat_s56aG_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56TQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56TR; else goto c56TS;
       c56TR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56TS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s56aB_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56aF_entry() //  [R1]
         { info_tbl: [(c56U1,
                       label: sat_s56aF_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56U1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56U2; else goto c56U3;
       c56U2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56U3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c56U0; else goto c56TZ;
       c56U0: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c56TZ: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56aI_entry() //  [R1]
         { info_tbl: [(c56Ud,
                       label: sat_s56aI_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Ud: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Ue; else goto c56Uf;
       c56Ue: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56Uf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c56Uc; else goto c56Ub;
       c56Uc: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c56Ub: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s56aB_entry() //  [R1, R2]
         { info_tbl: [(c56Uj,
                       label: go_up_s56aB_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Uj: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c56Un; else goto c56Um;
       c56Un: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56Um: // global
           if (%MO_S_Le_W64(R2, 0)) goto c56Uh; else goto c56Ui;
       c56Uh: // global
           I64[Hp - 72] = sat_s56aG_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s56aF_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c56Ui: // global
           I64[Hp - 72] = sat_s56aI_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c56Up::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c56Up::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56aJ_entry() //  [R1]
         { info_tbl: [(c56Uq,
                       label: sat_s56aJ_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Uq: // global
           _s56aJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c56Ur; else goto c56Us;
       c56Us: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56Uu; else goto c56Ut;
       c56Uu: // global
           HpAlloc = 16;
           goto c56Ur;
       c56Ur: // global
           R1 = _s56aJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56Ut: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s56aJ::P64;
           I64[Hp - 8] = go_up_s56aB_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call go_up_s56aB_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$w$cenumFromThenTo1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c56Uv,
                       label: Data.Type.Equality.$w$cenumFromThenTo1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Uv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Uw; else goto c56Ux;
       c56Uw: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromThenTo1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Ux: // global
           I64[Sp - 16] = block_c56Tw_info;
           _s56ax::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s56ax::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56Tw() //  []
         { info_tbl: [(c56Tw,
                       label: block_c56Tw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Tw: // global
           _s56ax::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56Ty_info;
           R2 = _s56ax::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56Ty() //  []
         { info_tbl: [(c56Ty,
                       label: block_c56Ty_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Ty: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c56UB; else goto c56UA;
       c56UB: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c56UA: // global
           I64[Hp - 8] = sat_s56aJ_info;
           R2 = Hp - 8;
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.840457382 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_closure" {
     Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_closure:
         const Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(c56UJ,
                       label: Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56UJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c56UZ; else goto c56V0;
       c56UZ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56V0: // global
           I64[Sp - 32] = block_c56UG_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u56V8; else goto c56UH;
       u56V8: // global
           call _c56UG(R1) args: 0, res: 0, upd: 0;
       c56UH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56UG() //  [R1]
         { info_tbl: [(c56UG,
                       label: block_c56UG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56UG: // global
           I64[Sp] = block_c56UM_info;
           _s56aO::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s56aO::P64;
           if (R1 & 7 != 0) goto u56V7; else goto c56UN;
       u56V7: // global
           call _c56UM(R1) args: 0, res: 0, upd: 0;
       c56UN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56UM() //  [R1]
         { info_tbl: [(c56UM,
                       label: block_c56UM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56UM: // global
           I64[Sp] = block_c56UR_info;
           _s56aP::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s56aP::P64;
           if (R1 & 7 != 0) goto u56V9; else goto c56US;
       u56V9: // global
           call _c56UR(R1) args: 0, res: 0, upd: 0;
       c56US: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56UR() //  [R1]
         { info_tbl: [(c56UR,
                       label: block_c56UR_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56UR: // global
           _s56aP::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c56UW_info;
           R5 = R1;
           R4 = _s56aP::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromThenTo1_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _c56UW() //  [R1, R2]
         { info_tbl: [(c56UW,
                       label: block_c56UW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56UW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c56V6; else goto c56V5;
       c56V6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c56V5: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.843982957 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_closure" {
     Data.Type.Equality.$fEnum:~~:_closure:
         const Data.Type.Equality.$fEnum:~~:_info;
         const 0;
 },
 sat_s56b2_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c56Vj,
                       label: sat_s56b2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Vj: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56b1_entry() //  [R1, R2, R3]
         { info_tbl: [(c56Vr,
                       label: sat_s56b1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Vr: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fEnum:~~:_$cenumFromTo_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56b0_entry() //  [R1, R2, R3]
         { info_tbl: [(c56Vz,
                       label: sat_s56b0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Vz: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fEnum:~~:_$cenumFromThen_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56aZ_entry() //  [R1, R2]
         { info_tbl: [(c56VH,
                       label: sat_s56aZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56VH: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$cenumFrom_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56aY_entry() //  [R1, R2]
         { info_tbl: [(c56VP,
                       label: sat_s56aY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56VP: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$cfromEnum_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56aX_entry() //  [R1, R2]
         { info_tbl: [(c56VX,
                       label: sat_s56aX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56VX: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$ctoEnum_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56aW_entry() //  [R1, R2]
         { info_tbl: [(c56W5,
                       label: sat_s56aW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56W5: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$csucc_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56aV_entry() //  [R1, R2]
         { info_tbl: [(c56Wd,
                       label: sat_s56aV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Wd: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$csucc_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fEnum:~~:_entry() //  [R2]
         { info_tbl: [(c56Wh,
                       label: Data.Type.Equality.$fEnum:~~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Wh: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto c56Wl; else goto c56Wk;
       c56Wl: // global
           HpAlloc = 200;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56Wk: // global
           I64[Hp - 192] = sat_s56b2_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s56b1_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s56b0_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_s56aZ_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s56aY_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s56aX_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s56aW_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s56aV_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = Hp - 95;
           P64[Hp - 40] = Hp - 111;
           P64[Hp - 32] = Hp - 127;
           P64[Hp - 24] = Hp - 143;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 174;
           P64[Hp] = Hp - 189;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.846861039 UTC

[section ""data" . Data.Type.Equality.$fTestEqualityk:~:1_closure" {
     Data.Type.Equality.$fTestEqualityk:~:1_closure:
         const GHC.Base.Just_con_info;
         const Data.Type.Equality.$WRefl_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.848171438 UTC

[section ""data" . Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_closure" {
     Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_closure:
         const Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_info;
 },
 Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(c56Wt,
                       label: Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Wt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Wx; else goto c56Wy;
       c56Wx: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Wy: // global
           I64[Sp - 16] = block_c56Wq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56WG; else goto c56Wr;
       u56WG: // global
           call _c56Wq() args: 0, res: 0, upd: 0;
       c56Wr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Wq() //  []
         { info_tbl: [(c56Wq,
                       label: block_c56Wq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Wq: // global
           _s56b4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56Ww_info;
           R1 = _s56b4::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56WF; else goto c56WA;
       u56WF: // global
           call _c56Ww() args: 0, res: 0, upd: 0;
       c56WA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Ww() //  []
         { info_tbl: [(c56Ww,
                       label: block_c56Ww_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Ww: // global
           R1 = Data.Type.Equality.$fTestEqualityk:~:1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.849735904 UTC

[section ""data" . Data.Type.Equality.$fTestEqualityk:~:_closure" {
     Data.Type.Equality.$fTestEqualityk:~:_closure:
         const Data.Type.Equality.$fTestEqualityk:~:_info;
 },
 Data.Type.Equality.$fTestEqualityk:~:_entry() //  [R2, R3]
         { info_tbl: [(c56WL,
                       label: Data.Type.Equality.$fTestEqualityk:~:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56WL: // global
           R3 = R3;
           R2 = R2;
           call Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_entry(R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.850771502 UTC

[section ""data" . Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_closure" {
     Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_closure:
         const Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_info;
 },
 Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(c56WV,
                       label: Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56WV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56WZ; else goto c56X0;
       c56WZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56X0: // global
           I64[Sp - 16] = block_c56WS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56X8; else goto c56WT;
       u56X8: // global
           call _c56WS() args: 0, res: 0, upd: 0;
       c56WT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56WS() //  []
         { info_tbl: [(c56WS,
                       label: block_c56WS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56WS: // global
           _s56b8::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56WY_info;
           R1 = _s56b8::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56X7; else goto c56X2;
       u56X7: // global
           call _c56WY() args: 0, res: 0, upd: 0;
       c56X2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56WY() //  []
         { info_tbl: [(c56WY,
                       label: block_c56WY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56WY: // global
           R1 = Data.Type.Equality.$fTestEqualityk:~:1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.852206233 UTC

[section ""data" . Data.Type.Equality.$fTestEqualityk:~~:_closure" {
     Data.Type.Equality.$fTestEqualityk:~~:_closure:
         const Data.Type.Equality.$fTestEqualityk:~~:_info;
 },
 Data.Type.Equality.$fTestEqualityk:~~:_entry() //  [R2, R3]
         { info_tbl: [(c56Xd,
                       label: Data.Type.Equality.$fTestEqualityk:~~:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Xd: // global
           R3 = R3;
           R2 = R2;
           call Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_entry(R3,
                                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.857043179 UTC

[section ""data" . Data.Type.Equality.$fEq:~:_$c==_closure" {
     Data.Type.Equality.$fEq:~:_$c==_closure:
         const Data.Type.Equality.$fEq:~:_$c==_info;
 },
 Data.Type.Equality.$fEq:~:_$c==_entry() //  [R2, R3]
         { info_tbl: [(c56Xn,
                       label: Data.Type.Equality.$fEq:~:_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Xn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Xr; else goto c56Xs;
       c56Xr: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEq:~:_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Xs: // global
           I64[Sp - 16] = block_c56Xk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56XA; else goto c56Xl;
       u56XA: // global
           call _c56Xk() args: 0, res: 0, upd: 0;
       c56Xl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Xk() //  []
         { info_tbl: [(c56Xk,
                       label: block_c56Xk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Xk: // global
           _s56bc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56Xq_info;
           R1 = _s56bc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56Xz; else goto c56Xu;
       u56Xz: // global
           call _c56Xq() args: 0, res: 0, upd: 0;
       c56Xu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Xq() //  []
         { info_tbl: [(c56Xq,
                       label: block_c56Xq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Xq: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.859948776 UTC

[section ""data" . Data.Type.Equality.$fEq:~:_$c/=_closure" {
     Data.Type.Equality.$fEq:~:_$c/=_closure:
         const Data.Type.Equality.$fEq:~:_$c/=_info;
 },
 Data.Type.Equality.$fEq:~:_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c56XI,
                       label: Data.Type.Equality.$fEq:~:_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56XI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56XM; else goto c56XN;
       c56XM: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEq:~:_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56XN: // global
           I64[Sp - 16] = block_c56XF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56XV; else goto c56XG;
       u56XV: // global
           call _c56XF() args: 0, res: 0, upd: 0;
       c56XG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56XF() //  []
         { info_tbl: [(c56XF,
                       label: block_c56XF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56XF: // global
           _s56bg::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56XL_info;
           R1 = _s56bg::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56XU; else goto c56XP;
       u56XU: // global
           call _c56XL() args: 0, res: 0, upd: 0;
       c56XP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56XL() //  []
         { info_tbl: [(c56XL,
                       label: block_c56XL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56XL: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.862336116 UTC

[section ""data" . Data.Type.Equality.$fEq:~:_closure" {
     Data.Type.Equality.$fEq:~:_closure:
         const GHC.Classes.C:Eq_con_info;
         const Data.Type.Equality.$fEq:~:_$c==_closure+2;
         const Data.Type.Equality.$fEq:~:_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.863224252 UTC

[section ""cstring" . Data.Type.Equality.$fRead:~:3_bytes" {
     Data.Type.Equality.$fRead:~:3_bytes:
         I8[] [82,101,102,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.864542157 UTC

[section ""data" . Data.Type.Equality.$fRead:~:2_closure" {
     Data.Type.Equality.$fRead:~:2_closure:
         const Data.Type.Equality.$fRead:~:2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Equality.$fRead:~:2_entry() //  [R1]
         { info_tbl: [(c56Y2,
                       label: Data.Type.Equality.$fRead:~:2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Y2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Y3; else goto c56Y4;
       c56Y3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c56Y4: // global
           (_c56XZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c56XZ::I64 == 0) goto c56Y1; else goto c56Y0;
       c56Y1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c56Y0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c56XZ::I64;
           R2 = Data.Type.Equality.$fRead:~:3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.866636158 UTC

[section ""data" . Data.Type.Equality.$fShow:~:_$cshowsPrec_closure" {
     Data.Type.Equality.$fShow:~:_$cshowsPrec_closure:
         const Data.Type.Equality.$fShow:~:_$cshowsPrec_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~:_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c56Yc,
                       label: Data.Type.Equality.$fShow:~:_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Yc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Yd; else goto c56Ye;
       c56Yd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~:_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Ye: // global
           I64[Sp - 16] = block_c56Y9_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56Yi; else goto c56Ya;
       u56Yi: // global
           call _c56Y9() args: 0, res: 0, upd: 0;
       c56Ya: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Y9() //  []
         { info_tbl: [(c56Y9,
                       label: block_c56Y9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Y9: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~:2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.868773138 UTC

[section ""data" . Data.Type.Equality.$fShow:~:_$cshow_closure" {
     Data.Type.Equality.$fShow:~:_$cshow_closure:
         const Data.Type.Equality.$fShow:~:_$cshow_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~:_$cshow_entry() //  [R2]
         { info_tbl: [(c56Yq,
                       label: Data.Type.Equality.$fShow:~:_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Yq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c56Yr; else goto c56Ys;
       c56Yr: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~:_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c56Ys: // global
           I64[Sp - 8] = block_c56Yn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u56Yw; else goto c56Yo;
       u56Yw: // global
           call _c56Yn() args: 0, res: 0, upd: 0;
       c56Yo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Yn() //  []
         { info_tbl: [(c56Yn,
                       label: block_c56Yn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Yn: // global
           R1 = Data.Type.Equality.$fRead:~:2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.871069375 UTC

[section ""data" . Data.Type.Equality.$fShow:~:1_closure" {
     Data.Type.Equality.$fShow:~:1_closure:
         const Data.Type.Equality.$fShow:~:1_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~:1_entry() //  [R2, R3]
         { info_tbl: [(c56YE,
                       label: Data.Type.Equality.$fShow:~:1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56YE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56YF; else goto c56YG;
       c56YF: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~:1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56YG: // global
           I64[Sp - 16] = block_c56YB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56YK; else goto c56YC;
       u56YK: // global
           call _c56YB() args: 0, res: 0, upd: 0;
       c56YC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56YB() //  []
         { info_tbl: [(c56YB,
                       label: block_c56YB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56YB: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~:2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.873002222 UTC

[section ""data" . Data.Type.Equality.$fShow:~:_$cshowList_closure" {
     Data.Type.Equality.$fShow:~:_$cshowList_closure:
         const Data.Type.Equality.$fShow:~:_$cshowList_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~:_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c56YP,
                       label: Data.Type.Equality.$fShow:~:_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56YP: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Type.Equality.$fShow:~:1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.874317358 UTC

[section ""data" . Data.Type.Equality.$fShow:~:_closure" {
     Data.Type.Equality.$fShow:~:_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Type.Equality.$fShow:~:_$cshowsPrec_closure+3;
         const Data.Type.Equality.$fShow:~:_$cshow_closure+1;
         const Data.Type.Equality.$fShow:~:_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.875815252 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$c<_closure" {
     Data.Type.Equality.$fOrd:~:_$c<_closure:
         const Data.Type.Equality.$fOrd:~:_$c<_info;
 },
 Data.Type.Equality.$fOrd:~:_$c<_entry() //  [R2, R3]
         { info_tbl: [(c56YZ,
                       label: Data.Type.Equality.$fOrd:~:_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56YZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Z3; else goto c56Z4;
       c56Z3: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Z4: // global
           I64[Sp - 16] = block_c56YW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56Zc; else goto c56YX;
       u56Zc: // global
           call _c56YW() args: 0, res: 0, upd: 0;
       c56YX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56YW() //  []
         { info_tbl: [(c56YW,
                       label: block_c56YW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56YW: // global
           _s56bv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56Z2_info;
           R1 = _s56bv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56Zb; else goto c56Z6;
       u56Zb: // global
           call _c56Z2() args: 0, res: 0, upd: 0;
       c56Z6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Z2() //  []
         { info_tbl: [(c56Z2,
                       label: block_c56Z2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Z2: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.878443259 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$ccompare_closure" {
     Data.Type.Equality.$fOrd:~:_$ccompare_closure:
         const Data.Type.Equality.$fOrd:~:_$ccompare_info;
 },
 Data.Type.Equality.$fOrd:~:_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c56Zk,
                       label: Data.Type.Equality.$fOrd:~:_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Zk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56Zo; else goto c56Zp;
       c56Zo: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56Zp: // global
           I64[Sp - 16] = block_c56Zh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56Zx; else goto c56Zi;
       u56Zx: // global
           call _c56Zh() args: 0, res: 0, upd: 0;
       c56Zi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Zh() //  []
         { info_tbl: [(c56Zh,
                       label: block_c56Zh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Zh: // global
           _s56bz::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56Zn_info;
           R1 = _s56bz::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56Zw; else goto c56Zr;
       u56Zw: // global
           call _c56Zn() args: 0, res: 0, upd: 0;
       c56Zr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56Zn() //  []
         { info_tbl: [(c56Zn,
                       label: block_c56Zn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56Zn: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.881094009 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$c<=_closure" {
     Data.Type.Equality.$fOrd:~:_$c<=_closure:
         const Data.Type.Equality.$fOrd:~:_$c<=_info;
 },
 Data.Type.Equality.$fOrd:~:_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c56ZF,
                       label: Data.Type.Equality.$fOrd:~:_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ZF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c56ZJ; else goto c56ZK;
       c56ZJ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c56ZK: // global
           I64[Sp - 16] = block_c56ZC_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u56ZS; else goto c56ZD;
       u56ZS: // global
           call _c56ZC() args: 0, res: 0, upd: 0;
       c56ZD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56ZC() //  []
         { info_tbl: [(c56ZC,
                       label: block_c56ZC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ZC: // global
           _s56bC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c56ZI_info;
           R1 = _s56bC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u56ZR; else goto c56ZM;
       u56ZR: // global
           call _c56ZI() args: 0, res: 0, upd: 0;
       c56ZM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56ZI() //  []
         { info_tbl: [(c56ZI,
                       label: block_c56ZI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ZI: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.884087468 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$cmax_closure" {
     Data.Type.Equality.$fOrd:~:_$cmax_closure:
         const Data.Type.Equality.$fOrd:~:_$cmax_info;
 },
 Data.Type.Equality.$fOrd:~:_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c5700,
                       label: Data.Type.Equality.$fOrd:~:_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5700: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5701; else goto c5702;
       c5701: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5702: // global
           I64[Sp - 16] = block_c56ZX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5706; else goto c56ZY;
       u5706: // global
           call _c56ZX() args: 0, res: 0, upd: 0;
       c56ZY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c56ZX() //  []
         { info_tbl: [(c56ZX,
                       label: block_c56ZX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c56ZX: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.886418839 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$c>_closure" {
     Data.Type.Equality.$fOrd:~:_$c>_closure:
         const Data.Type.Equality.$fOrd:~:_$c>_info;
 },
 Data.Type.Equality.$fOrd:~:_$c>_entry() //  [R2, R3]
         { info_tbl: [(c570e,
                       label: Data.Type.Equality.$fOrd:~:_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c570e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c570i; else goto c570j;
       c570i: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c570j: // global
           I64[Sp - 16] = block_c570b_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u570r; else goto c570c;
       u570r: // global
           call _c570b() args: 0, res: 0, upd: 0;
       c570c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c570b() //  []
         { info_tbl: [(c570b,
                       label: block_c570b_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c570b: // global
           _s56bJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c570h_info;
           R1 = _s56bJ::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u570q; else goto c570l;
       u570q: // global
           call _c570h() args: 0, res: 0, upd: 0;
       c570l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c570h() //  []
         { info_tbl: [(c570h,
                       label: block_c570h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c570h: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.888965939 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$cmin_closure" {
     Data.Type.Equality.$fOrd:~:_$cmin_closure:
         const Data.Type.Equality.$fOrd:~:_$cmin_info;
 },
 Data.Type.Equality.$fOrd:~:_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c570z,
                       label: Data.Type.Equality.$fOrd:~:_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c570z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c570A; else goto c570B;
       c570A: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c570B: // global
           I64[Sp - 16] = block_c570w_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u570F; else goto c570x;
       u570F: // global
           call _c570w() args: 0, res: 0, upd: 0;
       c570x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c570w() //  []
         { info_tbl: [(c570w,
                       label: block_c570w_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c570w: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.890728334 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_closure" {
     Data.Type.Equality.$fOrd:~:_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Type.Equality.$fEq:~:_closure+1;
         const Data.Type.Equality.$fOrd:~:_$ccompare_closure+2;
         const Data.Type.Equality.$fOrd:~:_$c<_closure+2;
         const Data.Type.Equality.$fOrd:~:_$c<=_closure+2;
         const Data.Type.Equality.$fOrd:~:_$c>_closure+2;
         const Data.Type.Equality.$fEq:~:_$c==_closure+2;
         const Data.Type.Equality.$fOrd:~:_$cmax_closure+2;
         const Data.Type.Equality.$fOrd:~:_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.891731287 UTC

[section ""data" . Data.Type.Equality.$fRead:~:_lexeme_closure" {
     Data.Type.Equality.$fRead:~:_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Type.Equality.$fRead:~:2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.893496281 UTC

[section ""data" . Data.Type.Equality.$fRead:~:1_closure" {
     Data.Type.Equality.$fRead:~:1_closure:
         const Data.Type.Equality.$fRead:~:1_info;
         const 0;
 },
 sat_s56bT_entry() //  [R1]
         { info_tbl: [(c570P,
                       label: sat_s56bT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c570P: // global
           R2 = Data.Type.Equality.$WRefl_closure+1;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~:1_entry() //  [R2, R3]
         { info_tbl: [(c570V,
                       label: Data.Type.Equality.$fRead:~:1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c570V: // global
           _s56bR::P64 = R3;
           _s56bQ::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c570W; else goto c570X;
       c570X: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c570Z; else goto c570Y;
       c570Z: // global
           HpAlloc = 16;
           goto c570W;
       c570W: // global
           R3 = _s56bR::P64;
           R2 = _s56bQ::P64;
           R1 = Data.Type.Equality.$fRead:~:1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c570Y: // global
           I64[Hp - 8] = sat_s56bT_info;
           P64[Hp] = _s56bR::P64;
           I64[Sp - 8] = block_c570S_info;
           R3 = Hp - 7;
           R2 = Data.Type.Equality.$fRead:~:_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c570S() //  [R1]
         { info_tbl: [(c570S,
                       label: block_c570S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c570S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c5712; else goto c5711;
       c5712: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c5711: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.896219112 UTC

[section ""data" . Data.Type.Equality.$fRead:~:4_closure" {
     Data.Type.Equality.$fRead:~:4_closure:
         const Data.Type.Equality.$fRead:~:4_info;
         const 0;
 },
 Data.Type.Equality.$fRead:~:4_entry() //  [R2, R3, R4]
         { info_tbl: [(c5719,
                       label: Data.Type.Equality.$fRead:~:4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5719: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c571a; else goto c571b;
       c571a: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~:4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c571b: // global
           I64[Sp - 24] = block_c5717_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5717() //  []
         { info_tbl: [(c5717,
                       label: block_c5717_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5717: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~:1_closure+2;
           Sp = Sp + 24;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.898934541 UTC

[section ""data" . Data.Type.Equality.$fRead:~:_$creadsPrec_closure" {
     Data.Type.Equality.$fRead:~:_$creadsPrec_closure:
         const Data.Type.Equality.$fRead:~:_$creadsPrec_info;
         const 0;
 },
 sat_s56c1_entry() //  [R1]
         { info_tbl: [(c571p,
                       label: sat_s56c1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c571p: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c571q; else goto c571r;
       c571q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c571r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c571n_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c571n() //  []
         { info_tbl: [(c571n,
                       label: block_c571n_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c571n: // global
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~:1_closure+2;
           Sp = Sp + 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fRead:~:_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c571t,
                       label: Data.Type.Equality.$fRead:~:_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c571t: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c571u; else goto c571v;
       c571u: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~:_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c571v: // global
           I64[Sp - 24] = block_c571h_info;
           _s56bZ::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s56bZ::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c571h() //  []
         { info_tbl: [(c571h,
                       label: block_c571h_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c571h: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c571y; else goto c571x;
       c571y: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c571x: // global
           I64[Hp - 24] = sat_s56c1_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.902778473 UTC

[section ""data" . Data.Type.Equality.$fRead:~:_$creadListPrec_closure" {
     Data.Type.Equality.$fRead:~:_$creadListPrec_closure:
         const Data.Type.Equality.$fRead:~:_$creadListPrec_info;
         const 0;
 },
 sat_s56c5_entry() //  [R1, R2, R3]
         { info_tbl: [(c571M,
                       label: sat_s56c5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c571M: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c571N; else goto c571O;
       c571N: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c571O: // global
           I64[Sp - 24] = block_c571K_info;
           _s56c3::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = _s56c3::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c571K() //  []
         { info_tbl: [(c571K,
                       label: block_c571K_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c571K: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~:1_closure+2;
           Sp = Sp + 24;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~:_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c571Q,
                       label: Data.Type.Equality.$fRead:~:_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c571Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c571R; else goto c571S;
       c571R: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~:_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c571S: // global
           I64[Sp - 16] = block_c571D_info;
           _s56c2::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s56c2::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c571D() //  []
         { info_tbl: [(c571D,
                       label: block_c571D_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c571D: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c571V; else goto c571U;
       c571V: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c571U: // global
           I64[Hp - 8] = sat_s56c5_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 6;
           Sp = Sp + 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.906490285 UTC

[section ""data" . Data.Type.Equality.$fRead:~:_$creadList_closure" {
     Data.Type.Equality.$fRead:~:_$creadList_closure:
         const Data.Type.Equality.$fRead:~:_$creadList_info;
         const 0;
 },
 sat_s56c9_entry() //  [R2, R3]
         { info_tbl: [(c572d,
                       label: sat_s56c9_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c572d: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Type.Equality.$fRead:~:1_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56ca_entry() //  [R1]
         { info_tbl: [(c572g,
                       label: sat_s56ca_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c572g: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c572h; else goto c572i;
       c572h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c572i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c5726_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c5726() //  []
         { info_tbl: [(c5726,
                       label: block_c5726_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5726: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c572l; else goto c572k;
       c572l: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c572k: // global
           I64[Hp - 8] = sat_s56c9_info;
           R2 = Hp - 6;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = GHC.Read.$fRead()7_closure;
           P64[Sp] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fRead:~:_$creadList_entry() //  [R2]
         { info_tbl: [(c572m,
                       label: Data.Type.Equality.$fRead:~:_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c572m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c572n; else goto c572o;
       c572n: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~:_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c572o: // global
           I64[Sp - 16] = block_c5720_info;
           _s56c6::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s56c6::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5720() //  []
         { info_tbl: [(c5720,
                       label: block_c5720_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5720: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c572r; else goto c572q;
       c572r: // global
           HpAlloc = 24;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c572q: // global
           I64[Hp - 16] = sat_s56ca_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.910412103 UTC

[section ""data" . Data.Type.Equality.$fRead:~:_closure" {
     Data.Type.Equality.$fRead:~:_closure:
         const Data.Type.Equality.$fRead:~:_info;
         const 0;
 },
 sat_s56cf_entry() //  [R1]
         { info_tbl: [(c572A,
                       label: sat_s56cf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c572A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c572B; else goto c572C;
       c572B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c572C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fRead:~:_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56ce_entry() //  [R1, R2, R3]
         { info_tbl: [(c572I,
                       label: sat_s56ce_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c572I: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fRead:~:4_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56cd_entry() //  [R1]
         { info_tbl: [(c572P,
                       label: sat_s56cd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c572P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c572Q; else goto c572R;
       c572Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c572R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fRead:~:_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56cc_entry() //  [R1, R2]
         { info_tbl: [(c572X,
                       label: sat_s56cc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c572X: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fRead:~:_$creadsPrec_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~:_entry() //  [R2]
         { info_tbl: [(c5731,
                       label: Data.Type.Equality.$fRead:~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5731: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c5735; else goto c5734;
       c5735: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c5734: // global
           I64[Hp - 112] = sat_s56cf_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s56ce_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s56cd_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s56cc_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 112;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.912622049 UTC

[section ""data" . Data.Type.Equality.$fBounded:~:_$cmaxBound_closure" {
     Data.Type.Equality.$fBounded:~:_$cmaxBound_closure:
         const Data.Type.Equality.$fBounded:~:_$cmaxBound_info;
 },
 Data.Type.Equality.$fBounded:~:_$cmaxBound_entry() //  [R2]
         { info_tbl: [(c573c,
                       label: Data.Type.Equality.$fBounded:~:_$cmaxBound_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c573c: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c573d; else goto c573e;
       c573d: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fBounded:~:_$cmaxBound_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c573e: // global
           I64[Sp - 8] = block_c573a_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c573a() //  []
         { info_tbl: [(c573a,
                       label: block_c573a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c573a: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.914125084 UTC

[section ""data" . Data.Type.Equality.$fBounded:~:_closure" {
     Data.Type.Equality.$fBounded:~:_closure:
         const Data.Type.Equality.$fBounded:~:_info;
 },
 sat_s56cj_entry() //  [R1]
         { info_tbl: [(c573o,
                       label: sat_s56cj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c573o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c573p; else goto c573q;
       c573p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c573q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fBounded:~:_$cmaxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56ci_entry() //  [R1]
         { info_tbl: [(c573v,
                       label: sat_s56ci_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c573v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c573w; else goto c573x;
       c573w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c573x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fBounded:~:_$cmaxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fBounded:~:_entry() //  [R2]
         { info_tbl: [(c573z,
                       label: Data.Type.Equality.$fBounded:~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c573z: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c573D; else goto c573C;
       c573D: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Type.Equality.$fBounded:~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c573C: // global
           I64[Hp - 64] = sat_s56cj_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s56ci_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.915879353 UTC

[section ""data" . Data.Type.Equality.$fEq:~~:_$c==_closure" {
     Data.Type.Equality.$fEq:~~:_$c==_closure:
         const Data.Type.Equality.$fEq:~~:_$c==_info;
 },
 Data.Type.Equality.$fEq:~~:_$c==_entry() //  [R2, R3]
         { info_tbl: [(c573L,
                       label: Data.Type.Equality.$fEq:~~:_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c573L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c573P; else goto c573Q;
       c573P: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEq:~~:_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c573Q: // global
           I64[Sp - 16] = block_c573I_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u573Y; else goto c573J;
       u573Y: // global
           call _c573I() args: 0, res: 0, upd: 0;
       c573J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c573I() //  []
         { info_tbl: [(c573I,
                       label: block_c573I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c573I: // global
           _s56cl::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c573O_info;
           R1 = _s56cl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u573X; else goto c573S;
       u573X: // global
           call _c573O() args: 0, res: 0, upd: 0;
       c573S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c573O() //  []
         { info_tbl: [(c573O,
                       label: block_c573O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c573O: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.917620543 UTC

[section ""data" . Data.Type.Equality.$fEq:~~:_$c/=_closure" {
     Data.Type.Equality.$fEq:~~:_$c/=_closure:
         const Data.Type.Equality.$fEq:~~:_$c/=_info;
 },
 Data.Type.Equality.$fEq:~~:_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c5746,
                       label: Data.Type.Equality.$fEq:~~:_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5746: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c574a; else goto c574b;
       c574a: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEq:~~:_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c574b: // global
           I64[Sp - 16] = block_c5743_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u574j; else goto c5744;
       u574j: // global
           call _c5743() args: 0, res: 0, upd: 0;
       c5744: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5743() //  []
         { info_tbl: [(c5743,
                       label: block_c5743_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5743: // global
           _s56cp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5749_info;
           R1 = _s56cp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u574i; else goto c574d;
       u574i: // global
           call _c5749() args: 0, res: 0, upd: 0;
       c574d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5749() //  []
         { info_tbl: [(c5749,
                       label: block_c5749_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5749: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.91887782 UTC

[section ""data" . Data.Type.Equality.$fEq:~~:_closure" {
     Data.Type.Equality.$fEq:~~:_closure:
         const GHC.Classes.C:Eq_con_info;
         const Data.Type.Equality.$fEq:~~:_$c==_closure+2;
         const Data.Type.Equality.$fEq:~~:_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.919461711 UTC

[section ""cstring" . Data.Type.Equality.$fRead:~~:3_bytes" {
     Data.Type.Equality.$fRead:~~:3_bytes:
         I8[] [72,82,101,102,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.920364516 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:2_closure" {
     Data.Type.Equality.$fRead:~~:2_closure:
         const Data.Type.Equality.$fRead:~~:2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Equality.$fRead:~~:2_entry() //  [R1]
         { info_tbl: [(c574q,
                       label: Data.Type.Equality.$fRead:~~:2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c574q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c574r; else goto c574s;
       c574r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c574s: // global
           (_c574n::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c574n::I64 == 0) goto c574p; else goto c574o;
       c574p: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c574o: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c574n::I64;
           R2 = Data.Type.Equality.$fRead:~~:3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.921681682 UTC

[section ""data" . Data.Type.Equality.$fShow:~~:_$cshowsPrec_closure" {
     Data.Type.Equality.$fShow:~~:_$cshowsPrec_closure:
         const Data.Type.Equality.$fShow:~~:_$cshowsPrec_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~~:_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c574A,
                       label: Data.Type.Equality.$fShow:~~:_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c574A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c574B; else goto c574C;
       c574B: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~~:_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c574C: // global
           I64[Sp - 16] = block_c574x_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u574G; else goto c574y;
       u574G: // global
           call _c574x() args: 0, res: 0, upd: 0;
       c574y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c574x() //  []
         { info_tbl: [(c574x,
                       label: block_c574x_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c574x: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~~:2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.923034773 UTC

[section ""data" . Data.Type.Equality.$fShow:~~:_$cshow_closure" {
     Data.Type.Equality.$fShow:~~:_$cshow_closure:
         const Data.Type.Equality.$fShow:~~:_$cshow_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~~:_$cshow_entry() //  [R2]
         { info_tbl: [(c574O,
                       label: Data.Type.Equality.$fShow:~~:_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c574O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c574P; else goto c574Q;
       c574P: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~~:_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c574Q: // global
           I64[Sp - 8] = block_c574L_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u574U; else goto c574M;
       u574U: // global
           call _c574L() args: 0, res: 0, upd: 0;
       c574M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c574L() //  []
         { info_tbl: [(c574L,
                       label: block_c574L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c574L: // global
           R1 = Data.Type.Equality.$fRead:~~:2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.924337585 UTC

[section ""data" . Data.Type.Equality.$fShow:~~:1_closure" {
     Data.Type.Equality.$fShow:~~:1_closure:
         const Data.Type.Equality.$fShow:~~:1_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~~:1_entry() //  [R2, R3]
         { info_tbl: [(c5752,
                       label: Data.Type.Equality.$fShow:~~:1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5752: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5753; else goto c5754;
       c5753: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~~:1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5754: // global
           I64[Sp - 16] = block_c574Z_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5758; else goto c5750;
       u5758: // global
           call _c574Z() args: 0, res: 0, upd: 0;
       c5750: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c574Z() //  []
         { info_tbl: [(c574Z,
                       label: block_c574Z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c574Z: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~~:2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.925637313 UTC

[section ""data" . Data.Type.Equality.$fShow:~~:_$cshowList_closure" {
     Data.Type.Equality.$fShow:~~:_$cshowList_closure:
         const Data.Type.Equality.$fShow:~~:_$cshowList_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~~:_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c575d,
                       label: Data.Type.Equality.$fShow:~~:_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c575d: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Type.Equality.$fShow:~~:1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.92639794 UTC

[section ""data" . Data.Type.Equality.$fShow:~~:_closure" {
     Data.Type.Equality.$fShow:~~:_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Type.Equality.$fShow:~~:_$cshowsPrec_closure+3;
         const Data.Type.Equality.$fShow:~~:_$cshow_closure+1;
         const Data.Type.Equality.$fShow:~~:_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.927330706 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$c<_closure" {
     Data.Type.Equality.$fOrd:~~:_$c<_closure:
         const Data.Type.Equality.$fOrd:~~:_$c<_info;
 },
 Data.Type.Equality.$fOrd:~~:_$c<_entry() //  [R2, R3]
         { info_tbl: [(c575n,
                       label: Data.Type.Equality.$fOrd:~~:_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c575n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c575r; else goto c575s;
       c575r: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c575s: // global
           I64[Sp - 16] = block_c575k_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u575A; else goto c575l;
       u575A: // global
           call _c575k() args: 0, res: 0, upd: 0;
       c575l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c575k() //  []
         { info_tbl: [(c575k,
                       label: block_c575k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c575k: // global
           _s56cE::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c575q_info;
           R1 = _s56cE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u575z; else goto c575u;
       u575z: // global
           call _c575q() args: 0, res: 0, upd: 0;
       c575u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c575q() //  []
         { info_tbl: [(c575q,
                       label: block_c575q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c575q: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.928831958 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$ccompare_closure" {
     Data.Type.Equality.$fOrd:~~:_$ccompare_closure:
         const Data.Type.Equality.$fOrd:~~:_$ccompare_info;
 },
 Data.Type.Equality.$fOrd:~~:_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c575I,
                       label: Data.Type.Equality.$fOrd:~~:_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c575I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c575M; else goto c575N;
       c575M: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c575N: // global
           I64[Sp - 16] = block_c575F_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u575V; else goto c575G;
       u575V: // global
           call _c575F() args: 0, res: 0, upd: 0;
       c575G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c575F() //  []
         { info_tbl: [(c575F,
                       label: block_c575F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c575F: // global
           _s56cI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c575L_info;
           R1 = _s56cI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u575U; else goto c575P;
       u575U: // global
           call _c575L() args: 0, res: 0, upd: 0;
       c575P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c575L() //  []
         { info_tbl: [(c575L,
                       label: block_c575L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c575L: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.930359133 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$c<=_closure" {
     Data.Type.Equality.$fOrd:~~:_$c<=_closure:
         const Data.Type.Equality.$fOrd:~~:_$c<=_info;
 },
 Data.Type.Equality.$fOrd:~~:_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c5763,
                       label: Data.Type.Equality.$fOrd:~~:_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5763: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c5767; else goto c5768;
       c5767: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c5768: // global
           I64[Sp - 16] = block_c5760_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u576g; else goto c5761;
       u576g: // global
           call _c5760() args: 0, res: 0, upd: 0;
       c5761: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5760() //  []
         { info_tbl: [(c5760,
                       label: block_c5760_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5760: // global
           _s56cL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c5766_info;
           R1 = _s56cL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u576f; else goto c576a;
       u576f: // global
           call _c5766() args: 0, res: 0, upd: 0;
       c576a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c5766() //  []
         { info_tbl: [(c5766,
                       label: block_c5766_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5766: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.931863578 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$cmax_closure" {
     Data.Type.Equality.$fOrd:~~:_$cmax_closure:
         const Data.Type.Equality.$fOrd:~~:_$cmax_info;
 },
 Data.Type.Equality.$fOrd:~~:_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c576o,
                       label: Data.Type.Equality.$fOrd:~~:_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c576o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c576p; else goto c576q;
       c576p: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c576q: // global
           I64[Sp - 16] = block_c576l_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u576u; else goto c576m;
       u576u: // global
           call _c576l() args: 0, res: 0, upd: 0;
       c576m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c576l() //  []
         { info_tbl: [(c576l,
                       label: block_c576l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c576l: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.933155729 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$c>_closure" {
     Data.Type.Equality.$fOrd:~~:_$c>_closure:
         const Data.Type.Equality.$fOrd:~~:_$c>_info;
 },
 Data.Type.Equality.$fOrd:~~:_$c>_entry() //  [R2, R3]
         { info_tbl: [(c576C,
                       label: Data.Type.Equality.$fOrd:~~:_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c576C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c576G; else goto c576H;
       c576G: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c576H: // global
           I64[Sp - 16] = block_c576z_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u576P; else goto c576A;
       u576P: // global
           call _c576z() args: 0, res: 0, upd: 0;
       c576A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c576z() //  []
         { info_tbl: [(c576z,
                       label: block_c576z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c576z: // global
           _s56cS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c576F_info;
           R1 = _s56cS::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u576O; else goto c576J;
       u576O: // global
           call _c576F() args: 0, res: 0, upd: 0;
       c576J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c576F() //  []
         { info_tbl: [(c576F,
                       label: block_c576F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c576F: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.934696686 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$cmin_closure" {
     Data.Type.Equality.$fOrd:~~:_$cmin_closure:
         const Data.Type.Equality.$fOrd:~~:_$cmin_info;
 },
 Data.Type.Equality.$fOrd:~~:_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c576X,
                       label: Data.Type.Equality.$fOrd:~~:_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c576X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c576Y; else goto c576Z;
       c576Y: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c576Z: // global
           I64[Sp - 16] = block_c576U_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u5773; else goto c576V;
       u5773: // global
           call _c576U() args: 0, res: 0, upd: 0;
       c576V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c576U() //  []
         { info_tbl: [(c576U,
                       label: block_c576U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c576U: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.935761018 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_closure" {
     Data.Type.Equality.$fOrd:~~:_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Type.Equality.$fEq:~~:_closure+1;
         const Data.Type.Equality.$fOrd:~~:_$ccompare_closure+2;
         const Data.Type.Equality.$fOrd:~~:_$c<_closure+2;
         const Data.Type.Equality.$fOrd:~~:_$c<=_closure+2;
         const Data.Type.Equality.$fOrd:~~:_$c>_closure+2;
         const Data.Type.Equality.$fEq:~~:_$c==_closure+2;
         const Data.Type.Equality.$fOrd:~~:_$cmax_closure+2;
         const Data.Type.Equality.$fOrd:~~:_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.938636696 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:_lexeme_closure" {
     Data.Type.Equality.$fRead:~~:_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Type.Equality.$fRead:~~:2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.94005503 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:1_closure" {
     Data.Type.Equality.$fRead:~~:1_closure:
         const Data.Type.Equality.$fRead:~~:1_info;
         const 0;
 },
 sat_s56d2_entry() //  [R1]
         { info_tbl: [(c577d,
                       label: sat_s56d2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c577d: // global
           R2 = Data.Type.Equality.$WHRefl_closure+1;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~~:1_entry() //  [R2, R3]
         { info_tbl: [(c577j,
                       label: Data.Type.Equality.$fRead:~~:1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c577j: // global
           _s56d0::P64 = R3;
           _s56cZ::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c577k; else goto c577l;
       c577l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c577n; else goto c577m;
       c577n: // global
           HpAlloc = 16;
           goto c577k;
       c577k: // global
           R3 = _s56d0::P64;
           R2 = _s56cZ::P64;
           R1 = Data.Type.Equality.$fRead:~~:1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c577m: // global
           I64[Hp - 8] = sat_s56d2_info;
           P64[Hp] = _s56d0::P64;
           I64[Sp - 8] = block_c577g_info;
           R3 = Hp - 7;
           R2 = Data.Type.Equality.$fRead:~~:_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c577g() //  [R1]
         { info_tbl: [(c577g,
                       label: block_c577g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c577g: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c577q; else goto c577p;
       c577q: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c577p: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.941962221 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:4_closure" {
     Data.Type.Equality.$fRead:~~:4_closure:
         const Data.Type.Equality.$fRead:~~:4_info;
         const 0;
 },
 Data.Type.Equality.$fRead:~~:4_entry() //  [R2, R3, R4]
         { info_tbl: [(c577x,
                       label: Data.Type.Equality.$fRead:~~:4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c577x: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c577y; else goto c577z;
       c577y: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~~:4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c577z: // global
           I64[Sp - 24] = block_c577v_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c577v() //  []
         { info_tbl: [(c577v,
                       label: block_c577v_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c577v: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~~:1_closure+2;
           Sp = Sp + 24;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.943576033 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:_$creadsPrec_closure" {
     Data.Type.Equality.$fRead:~~:_$creadsPrec_closure:
         const Data.Type.Equality.$fRead:~~:_$creadsPrec_info;
         const 0;
 },
 sat_s56da_entry() //  [R1]
         { info_tbl: [(c577N,
                       label: sat_s56da_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c577N: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c577O; else goto c577P;
       c577O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c577P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c577L_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c577L() //  []
         { info_tbl: [(c577L,
                       label: block_c577L_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c577L: // global
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~~:1_closure+2;
           Sp = Sp + 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fRead:~~:_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c577R,
                       label: Data.Type.Equality.$fRead:~~:_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c577R: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c577S; else goto c577T;
       c577S: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~~:_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c577T: // global
           I64[Sp - 24] = block_c577F_info;
           _s56d8::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s56d8::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c577F() //  []
         { info_tbl: [(c577F,
                       label: block_c577F_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c577F: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c577W; else goto c577V;
       c577W: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c577V: // global
           I64[Hp - 24] = sat_s56da_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.946177703 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:_$creadListPrec_closure" {
     Data.Type.Equality.$fRead:~~:_$creadListPrec_closure:
         const Data.Type.Equality.$fRead:~~:_$creadListPrec_info;
         const 0;
 },
 sat_s56de_entry() //  [R1, R2, R3]
         { info_tbl: [(c578a,
                       label: sat_s56de_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c578a: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c578b; else goto c578c;
       c578b: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c578c: // global
           I64[Sp - 24] = block_c5788_info;
           _s56dc::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = _s56dc::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5788() //  []
         { info_tbl: [(c5788,
                       label: block_c5788_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5788: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~~:1_closure+2;
           Sp = Sp + 24;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~~:_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c578e,
                       label: Data.Type.Equality.$fRead:~~:_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c578e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c578f; else goto c578g;
       c578f: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~~:_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c578g: // global
           I64[Sp - 16] = block_c5781_info;
           _s56db::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s56db::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c5781() //  []
         { info_tbl: [(c5781,
                       label: block_c5781_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5781: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c578j; else goto c578i;
       c578j: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c578i: // global
           I64[Hp - 8] = sat_s56de_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 6;
           Sp = Sp + 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.948627483 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:_$creadList_closure" {
     Data.Type.Equality.$fRead:~~:_$creadList_closure:
         const Data.Type.Equality.$fRead:~~:_$creadList_info;
         const 0;
 },
 sat_s56di_entry() //  [R2, R3]
         { info_tbl: [(c578B,
                       label: sat_s56di_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c578B: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Type.Equality.$fRead:~~:1_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56dj_entry() //  [R1]
         { info_tbl: [(c578E,
                       label: sat_s56dj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c578E: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c578F; else goto c578G;
       c578F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c578G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c578u_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c578u() //  []
         { info_tbl: [(c578u,
                       label: block_c578u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c578u: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c578J; else goto c578I;
       c578J: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c578I: // global
           I64[Hp - 8] = sat_s56di_info;
           R2 = Hp - 6;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = GHC.Read.$fRead()7_closure;
           P64[Sp] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fRead:~~:_$creadList_entry() //  [R2]
         { info_tbl: [(c578K,
                       label: Data.Type.Equality.$fRead:~~:_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c578K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c578L; else goto c578M;
       c578L: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~~:_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c578M: // global
           I64[Sp - 16] = block_c578o_info;
           _s56df::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s56df::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c578o() //  []
         { info_tbl: [(c578o,
                       label: block_c578o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c578o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c578P; else goto c578O;
       c578P: // global
           HpAlloc = 24;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c578O: // global
           I64[Hp - 16] = sat_s56dj_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.951492316 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:_closure" {
     Data.Type.Equality.$fRead:~~:_closure:
         const Data.Type.Equality.$fRead:~~:_info;
         const 0;
 },
 sat_s56do_entry() //  [R1]
         { info_tbl: [(c578Y,
                       label: sat_s56do_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c578Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c578Z; else goto c5790;
       c578Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c5790: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fRead:~~:_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56dn_entry() //  [R1, R2, R3]
         { info_tbl: [(c5796,
                       label: sat_s56dn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5796: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fRead:~~:4_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56dm_entry() //  [R1]
         { info_tbl: [(c579d,
                       label: sat_s56dm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c579d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c579e; else goto c579f;
       c579e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c579f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fRead:~~:_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56dl_entry() //  [R1, R2]
         { info_tbl: [(c579l,
                       label: sat_s56dl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c579l: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fRead:~~:_$creadsPrec_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~~:_entry() //  [R2]
         { info_tbl: [(c579p,
                       label: Data.Type.Equality.$fRead:~~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c579p: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c579t; else goto c579s;
       c579t: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c579s: // global
           I64[Hp - 112] = sat_s56do_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s56dn_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s56dm_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s56dl_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 112;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.953776151 UTC

[section ""data" . Data.Type.Equality.$fBounded:~~:_$cmaxBound_closure" {
     Data.Type.Equality.$fBounded:~~:_$cmaxBound_closure:
         const Data.Type.Equality.$fBounded:~~:_$cmaxBound_info;
 },
 Data.Type.Equality.$fBounded:~~:_$cmaxBound_entry() //  [R2]
         { info_tbl: [(c579A,
                       label: Data.Type.Equality.$fBounded:~~:_$cmaxBound_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c579A: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c579B; else goto c579C;
       c579B: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fBounded:~~:_$cmaxBound_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c579C: // global
           I64[Sp - 8] = block_c579y_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c579y() //  []
         { info_tbl: [(c579y,
                       label: block_c579y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c579y: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.955243081 UTC

[section ""data" . Data.Type.Equality.$fBounded:~~:_closure" {
     Data.Type.Equality.$fBounded:~~:_closure:
         const Data.Type.Equality.$fBounded:~~:_info;
 },
 sat_s56ds_entry() //  [R1]
         { info_tbl: [(c579M,
                       label: sat_s56ds_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c579M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c579N; else goto c579O;
       c579N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c579O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fBounded:~~:_$cmaxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56dr_entry() //  [R1]
         { info_tbl: [(c579T,
                       label: sat_s56dr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c579T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c579U; else goto c579V;
       c579U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c579V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fBounded:~~:_$cmaxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fBounded:~~:_entry() //  [R2]
         { info_tbl: [(c579X,
                       label: Data.Type.Equality.$fBounded:~~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c579X: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c57a1; else goto c57a0;
       c57a1: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Type.Equality.$fBounded:~~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57a0: // global
           I64[Hp - 64] = sat_s56ds_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s56dr_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.956837085 UTC

[section ""data" . Data.Type.Equality.sym_closure" {
     Data.Type.Equality.sym_closure:
         const Data.Type.Equality.sym_info;
 },
 Data.Type.Equality.sym_entry() //  [R2]
         { info_tbl: [(c57a9,
                       label: Data.Type.Equality.sym_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57a9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c57aa; else goto c57ab;
       c57aa: // global
           R2 = R2;
           R1 = Data.Type.Equality.sym_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57ab: // global
           I64[Sp - 8] = block_c57a6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u57af; else goto c57a7;
       u57af: // global
           call _c57a6() args: 0, res: 0, upd: 0;
       c57a7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57a6() //  []
         { info_tbl: [(c57a6,
                       label: block_c57a6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57a6: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.958320575 UTC

[section ""data" . Data.Type.Equality.trans_closure" {
     Data.Type.Equality.trans_closure:
         const Data.Type.Equality.trans_info;
 },
 Data.Type.Equality.trans_entry() //  [R2, R3]
         { info_tbl: [(c57an,
                       label: Data.Type.Equality.trans_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57an: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57ar; else goto c57as;
       c57ar: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.trans_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57as: // global
           I64[Sp - 16] = block_c57ak_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57aA; else goto c57al;
       u57aA: // global
           call _c57ak() args: 0, res: 0, upd: 0;
       c57al: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57ak() //  []
         { info_tbl: [(c57ak,
                       label: block_c57ak_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57ak: // global
           _s56dw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57aq_info;
           R1 = _s56dw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57az; else goto c57au;
       u57az: // global
           call _c57aq() args: 0, res: 0, upd: 0;
       c57au: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57aq() //  []
         { info_tbl: [(c57aq,
                       label: block_c57aq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57aq: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.959675888 UTC

[section ""data" . Data.Type.Equality.castWith_closure" {
     Data.Type.Equality.castWith_closure:
         const Data.Type.Equality.castWith_info;
 },
 Data.Type.Equality.castWith_entry() //  [R2, R3]
         { info_tbl: [(c57aI,
                       label: Data.Type.Equality.castWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57aI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57aJ; else goto c57aK;
       c57aJ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.castWith_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57aK: // global
           I64[Sp - 16] = block_c57aF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57aO; else goto c57aG;
       u57aO: // global
           call _c57aF() args: 0, res: 0, upd: 0;
       c57aG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57aF() //  []
         { info_tbl: [(c57aF,
                       label: block_c57aF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57aF: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.96094359 UTC

[section ""data" . Data.Type.Equality.gcastWith_closure" {
     Data.Type.Equality.gcastWith_closure:
         const Data.Type.Equality.gcastWith_info;
 },
 Data.Type.Equality.gcastWith_entry() //  [R2, R3]
         { info_tbl: [(c57aW,
                       label: Data.Type.Equality.gcastWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57aW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57b0; else goto c57b1;
       c57b0: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.gcastWith_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57b1: // global
           I64[Sp - 16] = block_c57aT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57b5; else goto c57aU;
       u57b5: // global
           call _c57aT(R1) args: 0, res: 0, upd: 0;
       c57aU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57aT() //  [R1]
         { info_tbl: [(c57aT,
                       label: block_c57aT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57aT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57b4; else goto c57b3;
       c57b4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c57b3: // global
           I64[Hp - 8] = GHC.Types.Eq#_con_info;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.962417337 UTC

[section ""data" . Data.Type.Equality.apply_closure" {
     Data.Type.Equality.apply_closure:
         const Data.Type.Equality.apply_info;
 },
 Data.Type.Equality.apply_entry() //  [R2, R3]
         { info_tbl: [(c57bd,
                       label: Data.Type.Equality.apply_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57bd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57bh; else goto c57bi;
       c57bh: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.apply_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57bi: // global
           I64[Sp - 16] = block_c57ba_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57bq; else goto c57bb;
       u57bq: // global
           call _c57ba() args: 0, res: 0, upd: 0;
       c57bb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57ba() //  []
         { info_tbl: [(c57ba,
                       label: block_c57ba_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57ba: // global
           _s56dH::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57bg_info;
           R1 = _s56dH::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57bp; else goto c57bk;
       u57bp: // global
           call _c57bg() args: 0, res: 0, upd: 0;
       c57bk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57bg() //  []
         { info_tbl: [(c57bg,
                       label: block_c57bg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57bg: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.963869729 UTC

[section ""data" . Data.Type.Equality.inner_closure" {
     Data.Type.Equality.inner_closure:
         const Data.Type.Equality.inner_info;
 },
 Data.Type.Equality.inner_entry() //  [R2]
         { info_tbl: [(c57by,
                       label: Data.Type.Equality.inner_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57by: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c57bz; else goto c57bA;
       c57bz: // global
           R2 = R2;
           R1 = Data.Type.Equality.inner_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57bA: // global
           I64[Sp - 8] = block_c57bv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u57bE; else goto c57bw;
       u57bE: // global
           call _c57bv() args: 0, res: 0, upd: 0;
       c57bw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57bv() //  []
         { info_tbl: [(c57bv,
                       label: block_c57bv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57bv: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.965132031 UTC

[section ""data" . Data.Type.Equality.outer_closure" {
     Data.Type.Equality.outer_closure:
         const Data.Type.Equality.outer_info;
 },
 Data.Type.Equality.outer_entry() //  [R2]
         { info_tbl: [(c57bM,
                       label: Data.Type.Equality.outer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57bM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c57bN; else goto c57bO;
       c57bN: // global
           R2 = R2;
           R1 = Data.Type.Equality.outer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57bO: // global
           I64[Sp - 8] = block_c57bJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u57bS; else goto c57bK;
       u57bS: // global
           call _c57bJ() args: 0, res: 0, upd: 0;
       c57bK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57bJ() //  []
         { info_tbl: [(c57bJ,
                       label: block_c57bJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57bJ: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.966139597 UTC

[section ""cstring" . Data.Type.Equality.$trModule4_bytes" {
     Data.Type.Equality.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.966681614 UTC

[section ""data" . Data.Type.Equality.$trModule3_closure" {
     Data.Type.Equality.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.967206476 UTC

[section ""cstring" . Data.Type.Equality.$trModule2_bytes" {
     Data.Type.Equality.$trModule2_bytes:
         I8[] [68,97,116,97,46,84,121,112,101,46,69,113,117,97,108,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.967722932 UTC

[section ""data" . Data.Type.Equality.$trModule1_closure" {
     Data.Type.Equality.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.968239349 UTC

[section ""data" . Data.Type.Equality.$trModule_closure" {
     Data.Type.Equality.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Type.Equality.$trModule3_closure+1;
         const Data.Type.Equality.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.968814071 UTC

[section ""data" . $krep_r568a_closure" {
     $krep_r568a_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.96944768 UTC

[section ""data" . $krep1_r568b_closure" {
     $krep1_r568b_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.969956404 UTC

[section ""data" . $krep2_r568c_closure" {
     $krep2_r568c_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r568b_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.97050528 UTC

[section ""data" . $krep3_r568d_closure" {
     $krep3_r568d_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.971037082 UTC

[section ""data" . Data.Type.Equality.$tc:~~:1_closure" {
     Data.Type.Equality.$tc:~~:1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r568d_closure+2;
         const $krep2_r568c_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.971647675 UTC

[section ""data" . $krep4_r568e_closure" {
     $krep4_r568e_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r568d_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.972200946 UTC

[section ""data" . Data.Type.Equality.$tc:~:1_closure" {
     Data.Type.Equality.$tc:~:1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r568d_closure+2;
         const $krep4_r568e_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.97276825 UTC

[section ""data" . Data.Type.Equality.$tcTestEquality1_closure" {
     Data.Type.Equality.$tcTestEquality1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r568e_closure+4;
         const $krep_r568a_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.973377232 UTC

[section ""data" . $krep5_r568f_closure" {
     $krep5_r568f_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r568d_closure+2;
         const $krep_r568a_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.97390899 UTC

[section ""data" . Data.Type.Equality.$tc~1_closure" {
     Data.Type.Equality.$tc~1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r568d_closure+2;
         const $krep5_r568f_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.974464013 UTC

[section ""data" . $krep6_r568g_closure" {
     $krep6_r568g_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.975070652 UTC

[section ""data" . $krep7_r568h_closure" {
     $krep7_r568h_closure:
         const :_con_info;
         const $krep6_r568g_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.975702657 UTC

[section ""data" . $krep8_r568i_closure" {
     $krep8_r568i_closure:
         const :_con_info;
         const $krep1_r568b_closure+2;
         const $krep7_r568h_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.976298134 UTC

[section ""data" . $krep9_r568j_closure" {
     $krep9_r568j_closure:
         const :_con_info;
         const $krep3_r568d_closure+2;
         const $krep8_r568i_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.976859125 UTC

[section ""data" . $krep10_r568k_closure" {
     $krep10_r568k_closure:
         const :_con_info;
         const $krep3_r568d_closure+2;
         const $krep9_r568j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.978099365 UTC

[section ""data" . $krep11_r568l_closure" {
     $krep11_r568l_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc~~_closure;
         const $krep10_r568k_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.978630299 UTC

[section ""cstring" . Data.Type.Equality.$tc~3_bytes" {
     Data.Type.Equality.$tc~3_bytes:
         I8[] [126]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.979244119 UTC

[section ""data" . Data.Type.Equality.$tc~2_closure" {
     Data.Type.Equality.$tc~2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc~3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.979861193 UTC

[section ""data" . Data.Type.Equality.$tc~_closure" {
     Data.Type.Equality.$tc~_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc~2_closure+1;
         const Data.Type.Equality.$tc~1_closure+4;
         const 11470827771536267938;
         const 3625512399163125290;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.980477687 UTC

[section ""data" . $krep12_r568m_closure" {
     $krep12_r568m_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Type.Equality.$tc~_closure+1;
         const $krep9_r568j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.981050986 UTC

[section ""data" . Data.Type.Equality.$tc'C:~1_closure" {
     Data.Type.Equality.$tc'C:~1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r568l_closure+1;
         const $krep12_r568m_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.981684231 UTC

[section ""cstring" . Data.Type.Equality.$tc'C:~3_bytes" {
     Data.Type.Equality.$tc'C:~3_bytes:
         I8[] [39,67,58,126]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.983860062 UTC

[section ""data" . Data.Type.Equality.$tc'C:~2_closure" {
     Data.Type.Equality.$tc'C:~2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc'C:~3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.98451293 UTC

[section ""data" . Data.Type.Equality.$tc'C:~_closure" {
     Data.Type.Equality.$tc'C:~_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc'C:~2_closure+1;
         const Data.Type.Equality.$tc'C:~1_closure+4;
         const 6023002849810837484;
         const 5427525916893308990;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.985113957 UTC

[section ""cstring" . Data.Type.Equality.$tc:~:3_bytes" {
     Data.Type.Equality.$tc:~:3_bytes:
         I8[] [58,126,58]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.985717722 UTC

[section ""data" . Data.Type.Equality.$tc:~:2_closure" {
     Data.Type.Equality.$tc:~:2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc:~:3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.986330557 UTC

[section ""data" . Data.Type.Equality.$tc:~:_closure" {
     Data.Type.Equality.$tc:~:_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc:~:2_closure+1;
         const Data.Type.Equality.$tc:~:1_closure+4;
         const 10597498348876412676;
         const 16281320961088145472;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.986920295 UTC

[section ""data" . $krep13_r568n_closure" {
     $krep13_r568n_closure:
         const :_con_info;
         const $krep1_r568b_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.987485245 UTC

[section ""data" . $krep14_r568o_closure" {
     $krep14_r568o_closure:
         const :_con_info;
         const $krep1_r568b_closure+2;
         const $krep13_r568n_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.988039926 UTC

[section ""data" . $krep15_r568p_closure" {
     $krep15_r568p_closure:
         const :_con_info;
         const $krep3_r568d_closure+2;
         const $krep14_r568o_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.988654023 UTC

[section ""data" . Data.Type.Equality.$tc'Refl1_closure" {
     Data.Type.Equality.$tc'Refl1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Type.Equality.$tc:~:_closure+1;
         const $krep15_r568p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.989210555 UTC

[section ""cstring" . Data.Type.Equality.$tc'Refl3_bytes" {
     Data.Type.Equality.$tc'Refl3_bytes:
         I8[] [39,82,101,102,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.989833888 UTC

[section ""data" . Data.Type.Equality.$tc'Refl2_closure" {
     Data.Type.Equality.$tc'Refl2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc'Refl3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.990439158 UTC

[section ""data" . Data.Type.Equality.$tc'Refl_closure" {
     Data.Type.Equality.$tc'Refl_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc'Refl2_closure+1;
         const Data.Type.Equality.$tc'Refl1_closure+1;
         const 16680242040484769242;
         const 2864388906562808793;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.991077134 UTC

[section ""cstring" . Data.Type.Equality.$tc:~~:3_bytes" {
     Data.Type.Equality.$tc:~~:3_bytes:
         I8[] [58,126,126,58]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.991609061 UTC

[section ""data" . Data.Type.Equality.$tc:~~:2_closure" {
     Data.Type.Equality.$tc:~~:2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc:~~:3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.992140944 UTC

[section ""data" . Data.Type.Equality.$tc:~~:_closure" {
     Data.Type.Equality.$tc:~~:_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc:~~:2_closure+1;
         const Data.Type.Equality.$tc:~~:1_closure+4;
         const 4361259188665111259;
         const 11706467685470543992;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.992744742 UTC

[section ""data" . $krep16_r568q_closure" {
     $krep16_r568q_closure:
         const :_con_info;
         const $krep3_r568d_closure+2;
         const $krep15_r568p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.993938991 UTC

[section ""data" . Data.Type.Equality.$tc'HRefl1_closure" {
     Data.Type.Equality.$tc'HRefl1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Type.Equality.$tc:~~:_closure+1;
         const $krep16_r568q_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.994515151 UTC

[section ""cstring" . Data.Type.Equality.$tc'HRefl3_bytes" {
     Data.Type.Equality.$tc'HRefl3_bytes:
         I8[] [39,72,82,101,102,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.99506307 UTC

[section ""data" . Data.Type.Equality.$tc'HRefl2_closure" {
     Data.Type.Equality.$tc'HRefl2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc'HRefl3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.995616001 UTC

[section ""data" . Data.Type.Equality.$tc'HRefl_closure" {
     Data.Type.Equality.$tc'HRefl_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc'HRefl2_closure+1;
         const Data.Type.Equality.$tc'HRefl1_closure+1;
         const 4486133906173668740;
         const 6341741464738386857;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.996230019 UTC

[section ""cstring" . Data.Type.Equality.$tcTestEquality3_bytes" {
     Data.Type.Equality.$tcTestEquality3_bytes:
         I8[] [84,101,115,116,69,113,117,97,108,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.996751395 UTC

[section ""data" . Data.Type.Equality.$tcTestEquality2_closure" {
     Data.Type.Equality.$tcTestEquality2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tcTestEquality3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.997352451 UTC

[section ""data" . Data.Type.Equality.$tcTestEquality_closure" {
     Data.Type.Equality.$tcTestEquality_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tcTestEquality2_closure+1;
         const Data.Type.Equality.$tcTestEquality1_closure+4;
         const 2944680549948432194;
         const 17791533211054855448;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.998262386 UTC

[section ""data" . Data.Type.Equality.HRefl_closure" {
     Data.Type.Equality.HRefl_closure:
         const Data.Type.Equality.HRefl_info;
 },
 Data.Type.Equality.HRefl_entry() //  []
         { info_tbl: [(c57bY,
                       label: Data.Type.Equality.HRefl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57bY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57c2; else goto c57c1;
       c57c2: // global
           HpAlloc = 16;
           R1 = Data.Type.Equality.HRefl_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c57c1: // global
           I64[Hp - 8] = Data.Type.Equality.HRefl_con_info;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:01.999246693 UTC

[section ""data" . Data.Type.Equality.Refl_closure" {
     Data.Type.Equality.Refl_closure:
         const Data.Type.Equality.Refl_info;
 },
 Data.Type.Equality.Refl_entry() //  []
         { info_tbl: [(c57c8,
                       label: Data.Type.Equality.Refl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57c8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57cc; else goto c57cb;
       c57cc: // global
           HpAlloc = 16;
           R1 = Data.Type.Equality.Refl_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c57cb: // global
           I64[Hp - 8] = Data.Type.Equality.Refl_con_info;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.000099339 UTC

[Data.Type.Equality.HRefl_con_entry() //  [R1]
         { info_tbl: [(c57cd,
                       label: Data.Type.Equality.HRefl_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,84,121,112,101,46,69,113,117,97,108,105,116,121,46,72,82,101,102,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57cd: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.000828398 UTC

[Data.Type.Equality.Refl_con_entry() //  [R1]
         { info_tbl: [(c57cf,
                       label: Data.Type.Equality.Refl_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,84,121,112,101,46,69,113,117,97,108,105,116,121,46,82,101,102,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57cf: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.001552267 UTC

[section ""relreadonly" . S56eO_srt" {
     S56eO_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Type.Equality.$fEnum:~:1_closure;
         const Data.Type.Equality.$fEnum:~:_$ctoEnum_closure;
         const Data.Type.Equality.$fEnum:~:_$csucc_closure;
         const Data.Type.Equality.$w$cenumFromTo_closure;
         const Data.Type.Equality.$fEnum:~:_$cenumFromTo_closure;
         const Data.Type.Equality.$w$cenumFromThen_closure;
         const Data.Type.Equality.$fEnum:~:2_closure;
         const Data.Type.Equality.$fEnum:~:_$cenumFromThen_closure;
         const Data.Type.Equality.$w$cenumFrom_closure;
         const Data.Type.Equality.$fEnum:~:_$cenumFrom_closure;
         const Data.Type.Equality.$w$cenumFromThenTo_closure;
         const Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_closure;
         const Data.Type.Equality.$fEnum:~:_closure;
         const Data.Type.Equality.$fEnum:~~:1_closure;
         const Data.Type.Equality.$fEnum:~~:_$ctoEnum_closure;
         const Data.Type.Equality.$fEnum:~~:_$csucc_closure;
         const Data.Type.Equality.$w$cenumFromTo1_closure;
         const Data.Type.Equality.$fEnum:~~:_$cenumFromTo_closure;
         const Data.Type.Equality.$w$cenumFromThen1_closure;
         const Data.Type.Equality.$fEnum:~~:_$cenumFromThen_closure;
         const Data.Type.Equality.$w$cenumFrom1_closure;
         const Data.Type.Equality.$fEnum:~~:_$cenumFrom_closure;
         const Data.Type.Equality.$w$cenumFromThenTo1_closure;
         const Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_closure;
         const Data.Type.Equality.$fEnum:~~:_closure;
         const Data.Type.Equality.$fRead:~:2_closure;
         const Data.Type.Equality.$fShow:~:_$cshowsPrec_closure;
         const Data.Type.Equality.$fShow:~:_$cshow_closure;
         const Data.Type.Equality.$fShow:~:1_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Type.Equality.$fRead:~:1_closure;
         const Data.Type.Equality.$fRead:~:_lexeme_closure;
         const GHC.Read.list3_closure;
         const Data.Type.Equality.$fRead:~:4_closure;
         const Data.Type.Equality.$fRead:~:_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Type.Equality.$fRead:~:_$creadListPrec_closure;
         const Data.Type.Equality.$fRead:~:_$creadList_closure;
         const Data.Type.Equality.$fRead:~:_closure;
         const Data.Type.Equality.$fRead:~~:2_closure;
         const Data.Type.Equality.$fShow:~~:_$cshowsPrec_closure;
         const Data.Type.Equality.$fShow:~~:_$cshow_closure;
         const Data.Type.Equality.$fShow:~~:1_closure;
         const Data.Type.Equality.$fRead:~~:1_closure;
         const Data.Type.Equality.$fRead:~~:_lexeme_closure;
         const Data.Type.Equality.$fRead:~~:4_closure;
         const Data.Type.Equality.$fRead:~~:_$creadsPrec_closure;
         const Data.Type.Equality.$fRead:~~:_$creadListPrec_closure;
         const Data.Type.Equality.$fRead:~~:_$creadList_closure;
         const Data.Type.Equality.$fRead:~~:_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.002680667 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:00:02.004115676 UTC

[section ""data" . Data.Type.Equality.$p1~_closure" {
     Data.Type.Equality.$p1~_closure:
         const Data.Type.Equality.$p1~_info;
 },
 Data.Type.Equality.$p1~_entry() //  [R2]
         { info_tbl: [(c57cl,
                       label: Data.Type.Equality.$p1~_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57cl: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.007930523 UTC

[section ""data" . Data.Type.Equality.testEquality_closure" {
     Data.Type.Equality.testEquality_closure:
         const Data.Type.Equality.testEquality_info;
 },
 Data.Type.Equality.testEquality_entry() //  [R2]
         { info_tbl: [(c57cy,
                       label: Data.Type.Equality.testEquality_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57cy: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.011499818 UTC

[section ""data" . Data.Type.Equality.$WHRefl_closure" {
     Data.Type.Equality.$WHRefl_closure:
         const Data.Type.Equality.HRefl_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.014162434 UTC

[section ""data" . Data.Type.Equality.$WRefl_closure" {
     Data.Type.Equality.$WRefl_closure:
         const Data.Type.Equality.Refl_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.016307152 UTC

[section ""data" . Data.Type.Equality.$f~kab_$cp1~_closure" {
     Data.Type.Equality.$f~kab_$cp1~_closure:
         const Data.Type.Equality.$f~kab_$cp1~_info;
 },
 Data.Type.Equality.$f~kab_$cp1~_entry() //  [R2]
         { info_tbl: [(c57cN,
                       label: Data.Type.Equality.$f~kab_$cp1~_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57cN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57cO; else goto c57cP;
       c57cO: // global
           R2 = R2;
           R1 = Data.Type.Equality.$f~kab_$cp1~_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57cP: // global
           I64[Sp - 16] = block_c57cL_info;
           _s568u::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s568u::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57cL() //  []
         { info_tbl: [(c57cL,
                       label: block_c57cL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57cL: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.021948196 UTC

[section ""data" . Data.Type.Equality.$f~kab_closure" {
     Data.Type.Equality.$f~kab_closure:
         const Data.Type.Equality.$f~kab_info;
 },
 Data.Type.Equality.$f~kab_entry() //  [R2]
         { info_tbl: [(c57d5,
                       label: Data.Type.Equality.$f~kab_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57d5: // global
           R2 = R2;
           call Data.Type.Equality.$f~kab_$cp1~_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.02537358 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:3_closure" {
     Data.Type.Equality.$fEnum:~:3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.027641421 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$cfromEnum_closure" {
     Data.Type.Equality.$fEnum:~:_$cfromEnum_closure:
         const Data.Type.Equality.$fEnum:~:_$cfromEnum_info;
 },
 Data.Type.Equality.$fEnum:~:_$cfromEnum_entry() //  [R2, R3]
         { info_tbl: [(c57dm,
                       label: Data.Type.Equality.$fEnum:~:_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57dm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57dn; else goto c57do;
       c57dn: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$cfromEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57do: // global
           I64[Sp - 16] = block_c57dh_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57dh() //  []
         { info_tbl: [(c57dh,
                       label: block_c57dh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57dh: // global
           _s568w::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57dj_info;
           R1 = _s568w::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57dt; else goto c57dk;
       u57dt: // global
           call _c57dj() args: 0, res: 0, upd: 0;
       c57dk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57dj() //  []
         { info_tbl: [(c57dj,
                       label: block_c57dj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57dj: // global
           R1 = Data.Type.Equality.$fEnum:~:3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.035117903 UTC

[section ""cstring" . lvl_r5689_bytes" {
     lvl_r5689_bytes:
         I8[] [68,97,116,97,46,84,121,112,101,46,69,113,117,97,108,105,116,121,46,116,111,69,110,117,109,58,32,98,97,100,32,97,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.037228696 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:1_closure" {
     Data.Type.Equality.$fEnum:~:1_closure:
         const Data.Type.Equality.$fEnum:~:1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:1_entry() //  [R1]
         { info_tbl: [(c57dQ,
                       label: Data.Type.Equality.$fEnum:~:1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57dQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c57dR; else goto c57dS;
       c57dR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57dS: // global
           (_c57dL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c57dL::I64 == 0) goto c57dN; else goto c57dM;
       c57dN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c57dM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c57dL::I64;
           I64[Sp - 24] = block_c57dO_info;
           R2 = lvl_r5689_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c57dO() //  [R1]
         { info_tbl: [(c57dO,
                       label: block_c57dO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57dO: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.043588007 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$ctoEnum_closure" {
     Data.Type.Equality.$fEnum:~:_$ctoEnum_closure:
         const Data.Type.Equality.$fEnum:~:_$ctoEnum_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$ctoEnum_entry() //  [R2, R3]
         { info_tbl: [(c57ef,
                       label: Data.Type.Equality.$fEnum:~:_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57ef: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57eg; else goto c57eh;
       c57eg: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$ctoEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57eh: // global
           I64[Sp - 16] = block_c57ea_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57ea() //  []
         { info_tbl: [(c57ea,
                       label: block_c57ea_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57ea: // global
           _s568A::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57ec_info;
           R1 = _s568A::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57eq; else goto c57ed;
       u57eq: // global
           call _c57ec(R1) args: 0, res: 0, upd: 0;
       c57ed: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57ec() //  [R1]
         { info_tbl: [(c57ec,
                       label: block_c57ec_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57ec: // global
           if (I64[R1 + 7] == 0) goto c57ep; else goto c57eo;
       c57ep: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c57eo: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.056232072 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$csucc_closure" {
     Data.Type.Equality.$fEnum:~:_$csucc_closure:
         const Data.Type.Equality.$fEnum:~:_$csucc_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$csucc_entry() //  [R2, R3]
         { info_tbl: [(c57eN,
                       label: Data.Type.Equality.$fEnum:~:_$csucc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57eN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57eO; else goto c57eP;
       c57eO: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$csucc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57eP: // global
           I64[Sp - 16] = block_c57eJ_info;
           _s568E::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s568E::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57eJ() //  []
         { info_tbl: [(c57eJ,
                       label: block_c57eJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57eJ: // global
           _s568E::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57eL_info;
           R2 = _s568E::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57eL() //  []
         { info_tbl: [(c57eL,
                       label: block_c57eL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57eL: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.068027104 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromTo_closure" {
     Data.Type.Equality.$w$cenumFromTo_closure:
         const Data.Type.Equality.$w$cenumFromTo_info;
         const 0;
 },
 sat_s568P_entry() //  [R1]
         { info_tbl: [(c57fp,
                       label: sat_s568P_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57fp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57fq; else goto c57fr;
       c57fq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57fr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s568N::I64 = I64[R1 + 24];
           if (_s568N::I64 != 0) goto c57fn; else goto c57fo;
       c57fn: // global
           R2 = _s568N::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s568J_entry(R2, R1) args: 24, res: 0, upd: 24;
       c57fo: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s568M_entry() //  [R1]
         { info_tbl: [(c57fC,
                       label: sat_s568M_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57fC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57fD; else goto c57fE;
       c57fD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57fE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c57fB; else goto c57fA;
       c57fB: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c57fA: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s568J_entry() //  [R1, R2]
         { info_tbl: [(c57fG,
                       label: go_s568J_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57fG: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c57fK; else goto c57fJ;
       c57fK: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57fJ: // global
           I64[Hp - 72] = sat_s568P_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s568M_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c57fL,
                       label: Data.Type.Equality.$w$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57fL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57fM; else goto c57fN;
       c57fM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c57fN: // global
           I64[Sp - 16] = block_c57f8_info;
           _s568G::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s568G::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57f8() //  []
         { info_tbl: [(c57f8,
                       label: block_c57f8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57f8: // global
           _s568G::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57fa_info;
           R2 = _s568G::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57fa() //  []
         { info_tbl: [(c57fa,
                       label: block_c57fa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57fa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57fR; else goto c57fQ;
       c57fR: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c57fQ: // global
           I64[Hp - 8] = go_s568J_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call go_s568J_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.090151889 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$cenumFromTo_closure" {
     Data.Type.Equality.$fEnum:~:_$cenumFromTo_closure:
         const Data.Type.Equality.$fEnum:~:_$cenumFromTo_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$cenumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c57gr,
                       label: Data.Type.Equality.$fEnum:~:_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57gr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c57gv; else goto c57gw;
       c57gv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$cenumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c57gw: // global
           I64[Sp - 24] = block_c57go_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u57gE; else goto c57gp;
       u57gE: // global
           call _c57go(R1) args: 0, res: 0, upd: 0;
       c57gp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57go() //  [R1]
         { info_tbl: [(c57go,
                       label: block_c57go_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57go: // global
           I64[Sp] = block_c57gu_info;
           _s568T::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s568T::P64;
           if (R1 & 7 != 0) goto u57gD; else goto c57gy;
       u57gD: // global
           call _c57gu(R1) args: 0, res: 0, upd: 0;
       c57gy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57gu() //  [R1]
         { info_tbl: [(c57gu,
                       label: block_c57gu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57gu: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromTo_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.102570504 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:2_closure" {
     Data.Type.Equality.$fEnum:~:2_closure:
         const Data.Type.Equality.$fEnum:~:2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:2_entry() //  [R1]
         { info_tbl: [(c57gY,
                       label: Data.Type.Equality.$fEnum:~:2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57gY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57gZ; else goto c57h0;
       c57gZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57h0: // global
           (_c57gV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c57gV::I64 == 0) goto c57gX; else goto c57gW;
       c57gX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c57gW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c57gV::I64;
           R3 = 0;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.Enum.efdInt_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.10878576 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromThen_closure" {
     Data.Type.Equality.$w$cenumFromThen_closure:
         const Data.Type.Equality.$w$cenumFromThen_info;
         const 0;
 },
 sat_s568Y_entry() //  [R1, R2]
         { info_tbl: [(c57hl,
                       label: sat_s568Y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57hl: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$ctoEnum_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFromThen_entry() //  [R2, R3, R4]
         { info_tbl: [(c57ho,
                       label: Data.Type.Equality.$w$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57ho: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57hp; else goto c57hq;
       c57hp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c57hq: // global
           I64[Sp - 16] = block_c57hc_info;
           _s568V::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s568V::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57hc() //  []
         { info_tbl: [(c57hc,
                       label: block_c57hc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57hc: // global
           I64[Sp] = block_c57he_info;
           R2 = P64[Sp + 8];
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57he() //  []
         { info_tbl: [(c57he,
                       label: block_c57he_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57he: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57hu; else goto c57ht;
       c57hu: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c57ht: // global
           I64[Hp - 8] = sat_s568Y_info;
           P64[Hp] = P64[Sp + 8];
           R3 = Data.Type.Equality.$fEnum:~:2_closure;
           R2 = Hp - 7;
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.118688327 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$cenumFromThen_closure" {
     Data.Type.Equality.$fEnum:~:_$cenumFromThen_closure:
         const Data.Type.Equality.$fEnum:~:_$cenumFromThen_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$cenumFromThen_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(c57hR,
                       label: Data.Type.Equality.$fEnum:~:_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57hR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c57hV; else goto c57hW;
       c57hV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$cenumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c57hW: // global
           I64[Sp - 24] = block_c57hO_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u57i4; else goto c57hP;
       u57i4: // global
           call _c57hO(R1) args: 0, res: 0, upd: 0;
       c57hP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57hO() //  [R1]
         { info_tbl: [(c57hO,
                       label: block_c57hO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57hO: // global
           I64[Sp] = block_c57hU_info;
           _s5692::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s5692::P64;
           if (R1 & 7 != 0) goto u57i3; else goto c57hY;
       u57i3: // global
           call _c57hU(R1) args: 0, res: 0, upd: 0;
       c57hY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57hU() //  [R1]
         { info_tbl: [(c57hU,
                       label: block_c57hU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57hU: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromThen_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.127936419 UTC

[section ""data" . Data.Type.Equality.$w$cenumFrom_closure" {
     Data.Type.Equality.$w$cenumFrom_closure:
         const Data.Type.Equality.$w$cenumFrom_info;
         const 0;
 },
 sat_s569c_entry() //  [R1]
         { info_tbl: [(c57iD,
                       label: sat_s569c_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57iD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57iE; else goto c57iF;
       c57iE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57iF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s569a::I64 = I64[R1 + 24];
           if (_s569a::I64 != 9223372036854775807) goto c57iB; else goto c57iC;
       c57iB: // global
           R2 = _s569a::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s5696_entry(R2, R1) args: 24, res: 0, upd: 24;
       c57iC: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s5699_entry() //  [R1]
         { info_tbl: [(c57iQ,
                       label: sat_s5699_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57iQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57iR; else goto c57iS;
       c57iR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57iS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c57iP; else goto c57iO;
       c57iP: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c57iO: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s5696_entry() //  [R1, R2]
         { info_tbl: [(c57iU,
                       label: go_s5696_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57iU: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c57iY; else goto c57iX;
       c57iY: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57iX: // global
           I64[Hp - 72] = sat_s569c_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s5699_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFrom_entry() //  [R2, R3]
         { info_tbl: [(c57iZ,
                       label: Data.Type.Equality.$w$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57iZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57j0; else goto c57j1;
       c57j0: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57j1: // global
           I64[Sp - 16] = block_c57im_info;
           _s5694::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s5694::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57im() //  []
         { info_tbl: [(c57im,
                       label: block_c57im_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57im: // global
           _s5694::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57io_info;
           R2 = _s5694::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57io() //  []
         { info_tbl: [(c57io,
                       label: block_c57io_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57io: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57j5; else goto c57j4;
       c57j5: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c57j4: // global
           I64[Hp - 8] = go_s5696_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call go_s5696_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.143013499 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$cenumFrom_closure" {
     Data.Type.Equality.$fEnum:~:_$cenumFrom_closure:
         const Data.Type.Equality.$fEnum:~:_$cenumFrom_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$cenumFrom_entry() //  [R2, R3]
         { info_tbl: [(c57jG,
                       label: Data.Type.Equality.$fEnum:~:_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57jG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57jH; else goto c57jI;
       c57jH: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$cenumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57jI: // global
           I64[Sp - 16] = block_c57jD_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57jM; else goto c57jE;
       u57jM: // global
           call _c57jD(R1) args: 0, res: 0, upd: 0;
       c57jE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57jD() //  [R1]
         { info_tbl: [(c57jD,
                       label: block_c57jD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57jD: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Type.Equality.$w$cenumFrom_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.150576162 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromThenTo_closure" {
     Data.Type.Equality.$w$cenumFromThenTo_closure:
         const Data.Type.Equality.$w$cenumFromThenTo_info;
         const 0;
 },
 sat_s569p_entry() //  [R1]
         { info_tbl: [(c57kk,
                       label: sat_s569p_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57kk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57kl; else goto c57km;
       c57kl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57km: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s569k_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s569o_entry() //  [R1]
         { info_tbl: [(c57kv,
                       label: sat_s569o_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57kv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57kw; else goto c57kx;
       c57kw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57kx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c57ku; else goto c57kt;
       c57ku: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c57kt: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s569r_entry() //  [R1]
         { info_tbl: [(c57kH,
                       label: sat_s569r_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57kH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57kI; else goto c57kJ;
       c57kI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57kJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c57kG; else goto c57kF;
       c57kG: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c57kF: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s569k_entry() //  [R1, R2]
         { info_tbl: [(c57kN,
                       label: go_up_s569k_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57kN: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c57kR; else goto c57kQ;
       c57kR: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57kQ: // global
           if (%MO_S_Le_W64(R2, 0)) goto c57kL; else goto c57kM;
       c57kL: // global
           I64[Hp - 72] = sat_s569p_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s569o_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c57kM: // global
           I64[Hp - 72] = sat_s569r_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c57kT::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c57kT::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569s_entry() //  [R1]
         { info_tbl: [(c57kU,
                       label: sat_s569s_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57kU: // global
           _s569s::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c57kV; else goto c57kW;
       c57kW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57kY; else goto c57kX;
       c57kY: // global
           HpAlloc = 16;
           goto c57kV;
       c57kV: // global
           R1 = _s569s::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57kX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s569s::P64;
           I64[Hp - 8] = go_up_s569k_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call go_up_s569k_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$w$cenumFromThenTo_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c57kZ,
                       label: Data.Type.Equality.$w$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57kZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57l0; else goto c57l1;
       c57l0: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c57l1: // global
           I64[Sp - 16] = block_c57k0_info;
           _s569g::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s569g::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57k0() //  []
         { info_tbl: [(c57k0,
                       label: block_c57k0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57k0: // global
           _s569g::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57k2_info;
           R2 = _s569g::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57k2() //  []
         { info_tbl: [(c57k2,
                       label: block_c57k2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57k2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57l5; else goto c57l4;
       c57l5: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c57l4: // global
           I64[Hp - 8] = sat_s569s_info;
           R2 = Hp - 8;
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.172245742 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_closure" {
     Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_closure:
         const Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(c57lR,
                       label: Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57lR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c57m7; else goto c57m8;
       c57m7: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c57m8: // global
           I64[Sp - 32] = block_c57lO_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u57mg; else goto c57lP;
       u57mg: // global
           call _c57lO(R1) args: 0, res: 0, upd: 0;
       c57lP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57lO() //  [R1]
         { info_tbl: [(c57lO,
                       label: block_c57lO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57lO: // global
           I64[Sp] = block_c57lU_info;
           _s569x::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s569x::P64;
           if (R1 & 7 != 0) goto u57mf; else goto c57lV;
       u57mf: // global
           call _c57lU(R1) args: 0, res: 0, upd: 0;
       c57lV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57lU() //  [R1]
         { info_tbl: [(c57lU,
                       label: block_c57lU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57lU: // global
           I64[Sp] = block_c57lZ_info;
           _s569y::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s569y::P64;
           if (R1 & 7 != 0) goto u57mh; else goto c57m0;
       u57mh: // global
           call _c57lZ(R1) args: 0, res: 0, upd: 0;
       c57m0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57lZ() //  [R1]
         { info_tbl: [(c57lZ,
                       label: block_c57lZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57lZ: // global
           _s569y::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c57m4_info;
           R5 = R1;
           R4 = _s569y::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromThenTo_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57m4() //  [R1, R2]
         { info_tbl: [(c57m4,
                       label: block_c57m4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57m4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c57me; else goto c57md;
       c57me: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c57md: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.185100076 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_closure" {
     Data.Type.Equality.$fEnum:~:_closure:
         const Data.Type.Equality.$fEnum:~:_info;
         const 0;
 },
 sat_s569L_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c57mM,
                       label: sat_s569L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57mM: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569K_entry() //  [R1, R2, R3]
         { info_tbl: [(c57mU,
                       label: sat_s569K_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57mU: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fEnum:~:_$cenumFromTo_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569J_entry() //  [R1, R2, R3]
         { info_tbl: [(c57n2,
                       label: sat_s569J_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57n2: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fEnum:~:_$cenumFromThen_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569I_entry() //  [R1, R2]
         { info_tbl: [(c57na,
                       label: sat_s569I_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57na: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$cenumFrom_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569H_entry() //  [R1, R2]
         { info_tbl: [(c57ni,
                       label: sat_s569H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57ni: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$cfromEnum_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569G_entry() //  [R1, R2]
         { info_tbl: [(c57nq,
                       label: sat_s569G_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57nq: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$ctoEnum_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569F_entry() //  [R1, R2]
         { info_tbl: [(c57ny,
                       label: sat_s569F_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57ny: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$csucc_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s569E_entry() //  [R1, R2]
         { info_tbl: [(c57nG,
                       label: sat_s569E_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57nG: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$csucc_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fEnum:~:_entry() //  [R2]
         { info_tbl: [(c57nK,
                       label: Data.Type.Equality.$fEnum:~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57nK: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto c57nO; else goto c57nN;
       c57nO: // global
           HpAlloc = 200;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57nN: // global
           I64[Hp - 192] = sat_s569L_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s569K_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s569J_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_s569I_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s569H_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s569G_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s569F_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s569E_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = Hp - 95;
           P64[Hp - 40] = Hp - 111;
           P64[Hp - 32] = Hp - 127;
           P64[Hp - 24] = Hp - 143;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 174;
           P64[Hp] = Hp - 189;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.216402437 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$cfromEnum_closure" {
     Data.Type.Equality.$fEnum:~~:_$cfromEnum_closure:
         const Data.Type.Equality.$fEnum:~~:_$cfromEnum_info;
 },
 Data.Type.Equality.$fEnum:~~:_$cfromEnum_entry() //  [R2, R3]
         { info_tbl: [(c57oz,
                       label: Data.Type.Equality.$fEnum:~~:_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57oz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57oA; else goto c57oB;
       c57oA: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$cfromEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57oB: // global
           I64[Sp - 16] = block_c57ou_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57ou() //  []
         { info_tbl: [(c57ou,
                       label: block_c57ou_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57ou: // global
           _s569N::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57ow_info;
           R1 = _s569N::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57oG; else goto c57ox;
       u57oG: // global
           call _c57ow() args: 0, res: 0, upd: 0;
       c57ox: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57ow() //  []
         { info_tbl: [(c57ow,
                       label: block_c57ow_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57ow: // global
           R1 = Data.Type.Equality.$fEnum:~:3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.228311682 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:1_closure" {
     Data.Type.Equality.$fEnum:~~:1_closure:
         const Data.Type.Equality.$fEnum:~~:1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:1_entry() //  [R1]
         { info_tbl: [(c57p2,
                       label: Data.Type.Equality.$fEnum:~~:1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57p2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c57p3; else goto c57p4;
       c57p3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57p4: // global
           (_c57oX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c57oX::I64 == 0) goto c57oZ; else goto c57oY;
       c57oZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c57oY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c57oX::I64;
           I64[Sp - 24] = block_c57p0_info;
           R2 = lvl_r5689_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c57p0() //  [R1]
         { info_tbl: [(c57p0,
                       label: block_c57p0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57p0: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.238308952 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$ctoEnum_closure" {
     Data.Type.Equality.$fEnum:~~:_$ctoEnum_closure:
         const Data.Type.Equality.$fEnum:~~:_$ctoEnum_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$ctoEnum_entry() //  [R2, R3]
         { info_tbl: [(c57pr,
                       label: Data.Type.Equality.$fEnum:~~:_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57pr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57ps; else goto c57pt;
       c57ps: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$ctoEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57pt: // global
           I64[Sp - 16] = block_c57pm_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57pm() //  []
         { info_tbl: [(c57pm,
                       label: block_c57pm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57pm: // global
           _s569R::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57po_info;
           R1 = _s569R::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57pC; else goto c57pp;
       u57pC: // global
           call _c57po(R1) args: 0, res: 0, upd: 0;
       c57pp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57po() //  [R1]
         { info_tbl: [(c57po,
                       label: block_c57po_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57po: // global
           if (I64[R1 + 7] == 0) goto c57pB; else goto c57pA;
       c57pB: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c57pA: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.251221516 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$csucc_closure" {
     Data.Type.Equality.$fEnum:~~:_$csucc_closure:
         const Data.Type.Equality.$fEnum:~~:_$csucc_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$csucc_entry() //  [R2, R3]
         { info_tbl: [(c57pZ,
                       label: Data.Type.Equality.$fEnum:~~:_$csucc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57pZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57q0; else goto c57q1;
       c57q0: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$csucc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57q1: // global
           I64[Sp - 16] = block_c57pV_info;
           _s569V::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s569V::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57pV() //  []
         { info_tbl: [(c57pV,
                       label: block_c57pV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57pV: // global
           _s569V::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57pX_info;
           R2 = _s569V::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57pX() //  []
         { info_tbl: [(c57pX,
                       label: block_c57pX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57pX: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.264839994 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromTo1_closure" {
     Data.Type.Equality.$w$cenumFromTo1_closure:
         const Data.Type.Equality.$w$cenumFromTo1_info;
         const 0;
 },
 sat_s56a6_entry() //  [R1]
         { info_tbl: [(c57qB,
                       label: sat_s56a6_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57qB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57qC; else goto c57qD;
       c57qC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57qD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s56a4::I64 = I64[R1 + 24];
           if (_s56a4::I64 != 0) goto c57qz; else goto c57qA;
       c57qz: // global
           R2 = _s56a4::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s56a0_entry(R2, R1) args: 24, res: 0, upd: 24;
       c57qA: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56a3_entry() //  [R1]
         { info_tbl: [(c57qO,
                       label: sat_s56a3_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57qO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57qP; else goto c57qQ;
       c57qP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57qQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c57qN; else goto c57qM;
       c57qN: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c57qM: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s56a0_entry() //  [R1, R2]
         { info_tbl: [(c57qS,
                       label: go_s56a0_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57qS: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c57qW; else goto c57qV;
       c57qW: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57qV: // global
           I64[Hp - 72] = sat_s56a6_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s56a3_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFromTo1_entry() //  [R2, R3, R4]
         { info_tbl: [(c57qX,
                       label: Data.Type.Equality.$w$cenumFromTo1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57qX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57qY; else goto c57qZ;
       c57qY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromTo1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c57qZ: // global
           I64[Sp - 16] = block_c57qk_info;
           _s569X::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s569X::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57qk() //  []
         { info_tbl: [(c57qk,
                       label: block_c57qk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57qk: // global
           _s569X::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57qm_info;
           R2 = _s569X::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57qm() //  []
         { info_tbl: [(c57qm,
                       label: block_c57qm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57qm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57r3; else goto c57r2;
       c57r3: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c57r2: // global
           I64[Hp - 8] = go_s56a0_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call go_s56a0_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.288769216 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$cenumFromTo_closure" {
     Data.Type.Equality.$fEnum:~~:_$cenumFromTo_closure:
         const Data.Type.Equality.$fEnum:~~:_$cenumFromTo_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$cenumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c57rD,
                       label: Data.Type.Equality.$fEnum:~~:_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57rD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c57rH; else goto c57rI;
       c57rH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$cenumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c57rI: // global
           I64[Sp - 24] = block_c57rA_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u57rQ; else goto c57rB;
       u57rQ: // global
           call _c57rA(R1) args: 0, res: 0, upd: 0;
       c57rB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57rA() //  [R1]
         { info_tbl: [(c57rA,
                       label: block_c57rA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57rA: // global
           I64[Sp] = block_c57rG_info;
           _s56aa::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s56aa::P64;
           if (R1 & 7 != 0) goto u57rP; else goto c57rK;
       u57rP: // global
           call _c57rG(R1) args: 0, res: 0, upd: 0;
       c57rK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57rG() //  [R1]
         { info_tbl: [(c57rG,
                       label: block_c57rG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57rG: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromTo1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.301105721 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromThen1_closure" {
     Data.Type.Equality.$w$cenumFromThen1_closure:
         const Data.Type.Equality.$w$cenumFromThen1_info;
         const 0;
 },
 sat_s56af_entry() //  [R1, R2]
         { info_tbl: [(c57sh,
                       label: sat_s56af_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57sh: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$ctoEnum_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFromThen1_entry() //  [R2, R3, R4]
         { info_tbl: [(c57sk,
                       label: Data.Type.Equality.$w$cenumFromThen1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57sk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57sl; else goto c57sm;
       c57sl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromThen1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c57sm: // global
           I64[Sp - 16] = block_c57s8_info;
           _s56ac::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s56ac::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57s8() //  []
         { info_tbl: [(c57s8,
                       label: block_c57s8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57s8: // global
           I64[Sp] = block_c57sa_info;
           R2 = P64[Sp + 8];
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57sa() //  []
         { info_tbl: [(c57sa,
                       label: block_c57sa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57sa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57sq; else goto c57sp;
       c57sq: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c57sp: // global
           I64[Hp - 8] = sat_s56af_info;
           P64[Hp] = P64[Sp + 8];
           R3 = Data.Type.Equality.$fEnum:~:2_closure;
           R2 = Hp - 7;
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.324086466 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$cenumFromThen_closure" {
     Data.Type.Equality.$fEnum:~~:_$cenumFromThen_closure:
         const Data.Type.Equality.$fEnum:~~:_$cenumFromThen_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$cenumFromThen_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c57sN,
                       label: Data.Type.Equality.$fEnum:~~:_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57sN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c57sR; else goto c57sS;
       c57sR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$cenumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c57sS: // global
           I64[Sp - 24] = block_c57sK_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u57t0; else goto c57sL;
       u57t0: // global
           call _c57sK(R1) args: 0, res: 0, upd: 0;
       c57sL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57sK() //  [R1]
         { info_tbl: [(c57sK,
                       label: block_c57sK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57sK: // global
           I64[Sp] = block_c57sQ_info;
           _s56aj::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s56aj::P64;
           if (R1 & 7 != 0) goto u57sZ; else goto c57sU;
       u57sZ: // global
           call _c57sQ(R1) args: 0, res: 0, upd: 0;
       c57sU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57sQ() //  [R1]
         { info_tbl: [(c57sQ,
                       label: block_c57sQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57sQ: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromThen1_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.336088321 UTC

[section ""data" . Data.Type.Equality.$w$cenumFrom1_closure" {
     Data.Type.Equality.$w$cenumFrom1_closure:
         const Data.Type.Equality.$w$cenumFrom1_info;
         const 0;
 },
 sat_s56at_entry() //  [R1]
         { info_tbl: [(c57tz,
                       label: sat_s56at_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57tz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57tA; else goto c57tB;
       c57tA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57tB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s56ar::I64 = I64[R1 + 24];
           if (_s56ar::I64 != 9223372036854775807) goto c57tx; else goto c57ty;
       c57tx: // global
           R2 = _s56ar::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s56an_entry(R2, R1) args: 24, res: 0, upd: 24;
       c57ty: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56aq_entry() //  [R1]
         { info_tbl: [(c57tM,
                       label: sat_s56aq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57tM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57tN; else goto c57tO;
       c57tN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57tO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c57tL; else goto c57tK;
       c57tL: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c57tK: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s56an_entry() //  [R1, R2]
         { info_tbl: [(c57tQ,
                       label: go_s56an_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57tQ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c57tU; else goto c57tT;
       c57tU: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57tT: // global
           I64[Hp - 72] = sat_s56at_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s56aq_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFrom1_entry() //  [R2, R3]
         { info_tbl: [(c57tV,
                       label: Data.Type.Equality.$w$cenumFrom1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57tV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57tW; else goto c57tX;
       c57tW: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFrom1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57tX: // global
           I64[Sp - 16] = block_c57ti_info;
           _s56al::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s56al::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57ti() //  []
         { info_tbl: [(c57ti,
                       label: block_c57ti_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57ti: // global
           _s56al::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57tk_info;
           R2 = _s56al::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57tk() //  []
         { info_tbl: [(c57tk,
                       label: block_c57tk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57tk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57u1; else goto c57u0;
       c57u1: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c57u0: // global
           I64[Hp - 8] = go_s56an_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call go_s56an_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.352119446 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$cenumFrom_closure" {
     Data.Type.Equality.$fEnum:~~:_$cenumFrom_closure:
         const Data.Type.Equality.$fEnum:~~:_$cenumFrom_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$cenumFrom_entry() //  [R2, R3]
         { info_tbl: [(c57uC,
                       label: Data.Type.Equality.$fEnum:~~:_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57uC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57uD; else goto c57uE;
       c57uD: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$cenumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57uE: // global
           I64[Sp - 16] = block_c57uz_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57uI; else goto c57uA;
       u57uI: // global
           call _c57uz(R1) args: 0, res: 0, upd: 0;
       c57uA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57uz() //  [R1]
         { info_tbl: [(c57uz,
                       label: block_c57uz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57uz: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Type.Equality.$w$cenumFrom1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.359615951 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromThenTo1_closure" {
     Data.Type.Equality.$w$cenumFromThenTo1_closure:
         const Data.Type.Equality.$w$cenumFromThenTo1_info;
         const 0;
 },
 sat_s56aG_entry() //  [R1]
         { info_tbl: [(c57vg,
                       label: sat_s56aG_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57vg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57vh; else goto c57vi;
       c57vh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57vi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s56aB_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56aF_entry() //  [R1]
         { info_tbl: [(c57vr,
                       label: sat_s56aF_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57vr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57vs; else goto c57vt;
       c57vs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57vt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c57vq; else goto c57vp;
       c57vq: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c57vp: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56aI_entry() //  [R1]
         { info_tbl: [(c57vD,
                       label: sat_s56aI_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57vD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57vE; else goto c57vF;
       c57vE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57vF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c57vC; else goto c57vB;
       c57vC: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c57vB: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s56aB_entry() //  [R1, R2]
         { info_tbl: [(c57vJ,
                       label: go_up_s56aB_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57vJ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c57vN; else goto c57vM;
       c57vN: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57vM: // global
           if (%MO_S_Le_W64(R2, 0)) goto c57vH; else goto c57vI;
       c57vH: // global
           I64[Hp - 72] = sat_s56aG_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s56aF_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c57vI: // global
           I64[Hp - 72] = sat_s56aI_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c57vP::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c57vP::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56aJ_entry() //  [R1]
         { info_tbl: [(c57vQ,
                       label: sat_s56aJ_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57vQ: // global
           _s56aJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c57vR; else goto c57vS;
       c57vS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57vU; else goto c57vT;
       c57vU: // global
           HpAlloc = 16;
           goto c57vR;
       c57vR: // global
           R1 = _s56aJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57vT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s56aJ::P64;
           I64[Hp - 8] = go_up_s56aB_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call go_up_s56aB_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$w$cenumFromThenTo1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c57vV,
                       label: Data.Type.Equality.$w$cenumFromThenTo1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57vV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57vW; else goto c57vX;
       c57vW: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromThenTo1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c57vX: // global
           I64[Sp - 16] = block_c57uW_info;
           _s56ax::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s56ax::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57uW() //  []
         { info_tbl: [(c57uW,
                       label: block_c57uW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57uW: // global
           _s56ax::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57uY_info;
           R2 = _s56ax::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57uY() //  []
         { info_tbl: [(c57uY,
                       label: block_c57uY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57uY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57w1; else goto c57w0;
       c57w1: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c57w0: // global
           I64[Hp - 8] = sat_s56aJ_info;
           R2 = Hp - 8;
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.379797117 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_closure" {
     Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_closure:
         const Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(c57wN,
                       label: Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57wN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c57x3; else goto c57x4;
       c57x3: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c57x4: // global
           I64[Sp - 32] = block_c57wK_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u57xc; else goto c57wL;
       u57xc: // global
           call _c57wK(R1) args: 0, res: 0, upd: 0;
       c57wL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57wK() //  [R1]
         { info_tbl: [(c57wK,
                       label: block_c57wK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57wK: // global
           I64[Sp] = block_c57wQ_info;
           _s56aO::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s56aO::P64;
           if (R1 & 7 != 0) goto u57xb; else goto c57wR;
       u57xb: // global
           call _c57wQ(R1) args: 0, res: 0, upd: 0;
       c57wR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57wQ() //  [R1]
         { info_tbl: [(c57wQ,
                       label: block_c57wQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57wQ: // global
           I64[Sp] = block_c57wV_info;
           _s56aP::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s56aP::P64;
           if (R1 & 7 != 0) goto u57xd; else goto c57wW;
       u57xd: // global
           call _c57wV(R1) args: 0, res: 0, upd: 0;
       c57wW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57wV() //  [R1]
         { info_tbl: [(c57wV,
                       label: block_c57wV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57wV: // global
           _s56aP::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c57x0_info;
           R5 = R1;
           R4 = _s56aP::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromThenTo1_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57x0() //  [R1, R2]
         { info_tbl: [(c57x0,
                       label: block_c57x0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57x0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c57xa; else goto c57x9;
       c57xa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c57x9: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.393171809 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_closure" {
     Data.Type.Equality.$fEnum:~~:_closure:
         const Data.Type.Equality.$fEnum:~~:_info;
         const 0;
 },
 sat_s56b2_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c57xI,
                       label: sat_s56b2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57xI: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56b1_entry() //  [R1, R2, R3]
         { info_tbl: [(c57xQ,
                       label: sat_s56b1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57xQ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fEnum:~~:_$cenumFromTo_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56b0_entry() //  [R1, R2, R3]
         { info_tbl: [(c57xY,
                       label: sat_s56b0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57xY: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fEnum:~~:_$cenumFromThen_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56aZ_entry() //  [R1, R2]
         { info_tbl: [(c57y6,
                       label: sat_s56aZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57y6: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$cenumFrom_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56aY_entry() //  [R1, R2]
         { info_tbl: [(c57ye,
                       label: sat_s56aY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57ye: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$cfromEnum_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56aX_entry() //  [R1, R2]
         { info_tbl: [(c57ym,
                       label: sat_s56aX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57ym: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$ctoEnum_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56aW_entry() //  [R1, R2]
         { info_tbl: [(c57yu,
                       label: sat_s56aW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57yu: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$csucc_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56aV_entry() //  [R1, R2]
         { info_tbl: [(c57yC,
                       label: sat_s56aV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57yC: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$csucc_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fEnum:~~:_entry() //  [R2]
         { info_tbl: [(c57yG,
                       label: Data.Type.Equality.$fEnum:~~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57yG: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto c57yK; else goto c57yJ;
       c57yK: // global
           HpAlloc = 200;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57yJ: // global
           I64[Hp - 192] = sat_s56b2_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s56b1_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s56b0_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_s56aZ_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s56aY_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s56aX_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s56aW_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s56aV_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = Hp - 95;
           P64[Hp - 40] = Hp - 111;
           P64[Hp - 32] = Hp - 127;
           P64[Hp - 24] = Hp - 143;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 174;
           P64[Hp] = Hp - 189;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.410507924 UTC

[section ""data" . Data.Type.Equality.$fTestEqualityk:~:1_closure" {
     Data.Type.Equality.$fTestEqualityk:~:1_closure:
         const GHC.Base.Just_con_info;
         const Data.Type.Equality.$WRefl_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.412662308 UTC

[section ""data" . Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_closure" {
     Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_closure:
         const Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_info;
 },
 Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(c57zu,
                       label: Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57zu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57zy; else goto c57zz;
       c57zy: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57zz: // global
           I64[Sp - 16] = block_c57zr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57zH; else goto c57zs;
       u57zH: // global
           call _c57zr() args: 0, res: 0, upd: 0;
       c57zs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57zr() //  []
         { info_tbl: [(c57zr,
                       label: block_c57zr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57zr: // global
           _s56b4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57zx_info;
           R1 = _s56b4::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57zG; else goto c57zB;
       u57zG: // global
           call _c57zx() args: 0, res: 0, upd: 0;
       c57zB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57zx() //  []
         { info_tbl: [(c57zx,
                       label: block_c57zx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57zx: // global
           R1 = Data.Type.Equality.$fTestEqualityk:~:1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.421463863 UTC

[section ""data" . Data.Type.Equality.$fTestEqualityk:~:_closure" {
     Data.Type.Equality.$fTestEqualityk:~:_closure:
         const Data.Type.Equality.$fTestEqualityk:~:_info;
 },
 Data.Type.Equality.$fTestEqualityk:~:_entry() //  [R2, R3]
         { info_tbl: [(c57A0,
                       label: Data.Type.Equality.$fTestEqualityk:~:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57A0: // global
           R3 = R3;
           R2 = R2;
           call Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_entry(R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.425148844 UTC

[section ""data" . Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_closure" {
     Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_closure:
         const Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_info;
 },
 Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(c57Ae,
                       label: Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Ae: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57Ai; else goto c57Aj;
       c57Ai: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57Aj: // global
           I64[Sp - 16] = block_c57Ab_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57Ar; else goto c57Ac;
       u57Ar: // global
           call _c57Ab() args: 0, res: 0, upd: 0;
       c57Ac: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57Ab() //  []
         { info_tbl: [(c57Ab,
                       label: block_c57Ab_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Ab: // global
           _s56b8::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57Ah_info;
           R1 = _s56b8::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57Aq; else goto c57Al;
       u57Aq: // global
           call _c57Ah() args: 0, res: 0, upd: 0;
       c57Al: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57Ah() //  []
         { info_tbl: [(c57Ah,
                       label: block_c57Ah_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Ah: // global
           R1 = Data.Type.Equality.$fTestEqualityk:~:1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.432610274 UTC

[section ""data" . Data.Type.Equality.$fTestEqualityk:~~:_closure" {
     Data.Type.Equality.$fTestEqualityk:~~:_closure:
         const Data.Type.Equality.$fTestEqualityk:~~:_info;
 },
 Data.Type.Equality.$fTestEqualityk:~~:_entry() //  [R2, R3]
         { info_tbl: [(c57AK,
                       label: Data.Type.Equality.$fTestEqualityk:~~:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57AK: // global
           R3 = R3;
           R2 = R2;
           call Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_entry(R3,
                                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.436405227 UTC

[section ""data" . Data.Type.Equality.$fEq:~:_$c==_closure" {
     Data.Type.Equality.$fEq:~:_$c==_closure:
         const Data.Type.Equality.$fEq:~:_$c==_info;
 },
 Data.Type.Equality.$fEq:~:_$c==_entry() //  [R2, R3]
         { info_tbl: [(c57AY,
                       label: Data.Type.Equality.$fEq:~:_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57AY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57B2; else goto c57B3;
       c57B2: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEq:~:_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57B3: // global
           I64[Sp - 16] = block_c57AV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57Bb; else goto c57AW;
       u57Bb: // global
           call _c57AV() args: 0, res: 0, upd: 0;
       c57AW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57AV() //  []
         { info_tbl: [(c57AV,
                       label: block_c57AV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57AV: // global
           _s56bc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57B1_info;
           R1 = _s56bc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57Ba; else goto c57B5;
       u57Ba: // global
           call _c57B1() args: 0, res: 0, upd: 0;
       c57B5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57B1() //  []
         { info_tbl: [(c57B1,
                       label: block_c57B1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57B1: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.443998539 UTC

[section ""data" . Data.Type.Equality.$fEq:~:_$c/=_closure" {
     Data.Type.Equality.$fEq:~:_$c/=_closure:
         const Data.Type.Equality.$fEq:~:_$c/=_info;
 },
 Data.Type.Equality.$fEq:~:_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c57Bx,
                       label: Data.Type.Equality.$fEq:~:_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Bx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57BB; else goto c57BC;
       c57BB: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEq:~:_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57BC: // global
           I64[Sp - 16] = block_c57Bu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57BK; else goto c57Bv;
       u57BK: // global
           call _c57Bu() args: 0, res: 0, upd: 0;
       c57Bv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57Bu() //  []
         { info_tbl: [(c57Bu,
                       label: block_c57Bu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Bu: // global
           _s56bg::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57BA_info;
           R1 = _s56bg::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57BJ; else goto c57BE;
       u57BJ: // global
           call _c57BA() args: 0, res: 0, upd: 0;
       c57BE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57BA() //  []
         { info_tbl: [(c57BA,
                       label: block_c57BA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57BA: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.452072511 UTC

[section ""data" . Data.Type.Equality.$fEq:~:_closure" {
     Data.Type.Equality.$fEq:~:_closure:
         const GHC.Classes.C:Eq_con_info;
         const Data.Type.Equality.$fEq:~:_$c==_closure+2;
         const Data.Type.Equality.$fEq:~:_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.45473278 UTC

[section ""cstring" . Data.Type.Equality.$fRead:~:3_bytes" {
     Data.Type.Equality.$fRead:~:3_bytes:
         I8[] [82,101,102,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.456736074 UTC

[section ""data" . Data.Type.Equality.$fRead:~:2_closure" {
     Data.Type.Equality.$fRead:~:2_closure:
         const Data.Type.Equality.$fRead:~:2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Equality.$fRead:~:2_entry() //  [R1]
         { info_tbl: [(c57C7,
                       label: Data.Type.Equality.$fRead:~:2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57C7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57C8; else goto c57C9;
       c57C8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57C9: // global
           (_c57C4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c57C4::I64 == 0) goto c57C6; else goto c57C5;
       c57C6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c57C5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c57C4::I64;
           R2 = Data.Type.Equality.$fRead:~:3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.461363233 UTC

[section ""data" . Data.Type.Equality.$fShow:~:_$cshowsPrec_closure" {
     Data.Type.Equality.$fShow:~:_$cshowsPrec_closure:
         const Data.Type.Equality.$fShow:~:_$cshowsPrec_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~:_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c57Co,
                       label: Data.Type.Equality.$fShow:~:_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Co: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57Cp; else goto c57Cq;
       c57Cp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~:_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c57Cq: // global
           I64[Sp - 16] = block_c57Cl_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57Cu; else goto c57Cm;
       u57Cu: // global
           call _c57Cl() args: 0, res: 0, upd: 0;
       c57Cm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57Cl() //  []
         { info_tbl: [(c57Cl,
                       label: block_c57Cl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Cl: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~:2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.467551616 UTC

[section ""data" . Data.Type.Equality.$fShow:~:_$cshow_closure" {
     Data.Type.Equality.$fShow:~:_$cshow_closure:
         const Data.Type.Equality.$fShow:~:_$cshow_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~:_$cshow_entry() //  [R2]
         { info_tbl: [(c57CL,
                       label: Data.Type.Equality.$fShow:~:_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57CL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c57CM; else goto c57CN;
       c57CM: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~:_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57CN: // global
           I64[Sp - 8] = block_c57CI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u57CR; else goto c57CJ;
       u57CR: // global
           call _c57CI() args: 0, res: 0, upd: 0;
       c57CJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57CI() //  []
         { info_tbl: [(c57CI,
                       label: block_c57CI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57CI: // global
           R1 = Data.Type.Equality.$fRead:~:2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.473401897 UTC

[section ""data" . Data.Type.Equality.$fShow:~:1_closure" {
     Data.Type.Equality.$fShow:~:1_closure:
         const Data.Type.Equality.$fShow:~:1_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~:1_entry() //  [R2, R3]
         { info_tbl: [(c57D9,
                       label: Data.Type.Equality.$fShow:~:1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57D9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57Da; else goto c57Db;
       c57Da: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~:1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57Db: // global
           I64[Sp - 16] = block_c57D6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57Df; else goto c57D7;
       u57Df: // global
           call _c57D6() args: 0, res: 0, upd: 0;
       c57D7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57D6() //  []
         { info_tbl: [(c57D6,
                       label: block_c57D6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57D6: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~:2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.479321291 UTC

[section ""data" . Data.Type.Equality.$fShow:~:_$cshowList_closure" {
     Data.Type.Equality.$fShow:~:_$cshowList_closure:
         const Data.Type.Equality.$fShow:~:_$cshowList_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~:_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c57Dt,
                       label: Data.Type.Equality.$fShow:~:_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Dt: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Type.Equality.$fShow:~:1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.482785958 UTC

[section ""data" . Data.Type.Equality.$fShow:~:_closure" {
     Data.Type.Equality.$fShow:~:_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Type.Equality.$fShow:~:_$cshowsPrec_closure+3;
         const Data.Type.Equality.$fShow:~:_$cshow_closure+1;
         const Data.Type.Equality.$fShow:~:_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.484998174 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$c<_closure" {
     Data.Type.Equality.$fOrd:~:_$c<_closure:
         const Data.Type.Equality.$fOrd:~:_$c<_info;
 },
 Data.Type.Equality.$fOrd:~:_$c<_entry() //  [R2, R3]
         { info_tbl: [(c57DI,
                       label: Data.Type.Equality.$fOrd:~:_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57DI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57DM; else goto c57DN;
       c57DM: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57DN: // global
           I64[Sp - 16] = block_c57DF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57DV; else goto c57DG;
       u57DV: // global
           call _c57DF() args: 0, res: 0, upd: 0;
       c57DG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57DF() //  []
         { info_tbl: [(c57DF,
                       label: block_c57DF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57DF: // global
           _s56bv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57DL_info;
           R1 = _s56bv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57DU; else goto c57DP;
       u57DU: // global
           call _c57DL() args: 0, res: 0, upd: 0;
       c57DP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57DL() //  []
         { info_tbl: [(c57DL,
                       label: block_c57DL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57DL: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.494127419 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$ccompare_closure" {
     Data.Type.Equality.$fOrd:~:_$ccompare_closure:
         const Data.Type.Equality.$fOrd:~:_$ccompare_info;
 },
 Data.Type.Equality.$fOrd:~:_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c57Eh,
                       label: Data.Type.Equality.$fOrd:~:_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Eh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57El; else goto c57Em;
       c57El: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57Em: // global
           I64[Sp - 16] = block_c57Ee_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57Eu; else goto c57Ef;
       u57Eu: // global
           call _c57Ee() args: 0, res: 0, upd: 0;
       c57Ef: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57Ee() //  []
         { info_tbl: [(c57Ee,
                       label: block_c57Ee_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Ee: // global
           _s56bz::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57Ek_info;
           R1 = _s56bz::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57Et; else goto c57Eo;
       u57Et: // global
           call _c57Ek() args: 0, res: 0, upd: 0;
       c57Eo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57Ek() //  []
         { info_tbl: [(c57Ek,
                       label: block_c57Ek_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Ek: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.501823998 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$c<=_closure" {
     Data.Type.Equality.$fOrd:~:_$c<=_closure:
         const Data.Type.Equality.$fOrd:~:_$c<=_info;
 },
 Data.Type.Equality.$fOrd:~:_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c57EQ,
                       label: Data.Type.Equality.$fOrd:~:_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57EQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57EU; else goto c57EV;
       c57EU: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57EV: // global
           I64[Sp - 16] = block_c57EN_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57F3; else goto c57EO;
       u57F3: // global
           call _c57EN() args: 0, res: 0, upd: 0;
       c57EO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57EN() //  []
         { info_tbl: [(c57EN,
                       label: block_c57EN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57EN: // global
           _s56bC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57ET_info;
           R1 = _s56bC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57F2; else goto c57EX;
       u57F2: // global
           call _c57ET() args: 0, res: 0, upd: 0;
       c57EX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57ET() //  []
         { info_tbl: [(c57ET,
                       label: block_c57ET_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57ET: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.50954357 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$cmax_closure" {
     Data.Type.Equality.$fOrd:~:_$cmax_closure:
         const Data.Type.Equality.$fOrd:~:_$cmax_info;
 },
 Data.Type.Equality.$fOrd:~:_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c57Fp,
                       label: Data.Type.Equality.$fOrd:~:_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Fp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57Fq; else goto c57Fr;
       c57Fq: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57Fr: // global
           I64[Sp - 16] = block_c57Fm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57Fv; else goto c57Fn;
       u57Fv: // global
           call _c57Fm() args: 0, res: 0, upd: 0;
       c57Fn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57Fm() //  []
         { info_tbl: [(c57Fm,
                       label: block_c57Fm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Fm: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.516161464 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$c>_closure" {
     Data.Type.Equality.$fOrd:~:_$c>_closure:
         const Data.Type.Equality.$fOrd:~:_$c>_info;
 },
 Data.Type.Equality.$fOrd:~:_$c>_entry() //  [R2, R3]
         { info_tbl: [(c57FO,
                       label: Data.Type.Equality.$fOrd:~:_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57FO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57FS; else goto c57FT;
       c57FS: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57FT: // global
           I64[Sp - 16] = block_c57FL_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57G1; else goto c57FM;
       u57G1: // global
           call _c57FL() args: 0, res: 0, upd: 0;
       c57FM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57FL() //  []
         { info_tbl: [(c57FL,
                       label: block_c57FL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57FL: // global
           _s56bJ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57FR_info;
           R1 = _s56bJ::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57G0; else goto c57FV;
       u57G0: // global
           call _c57FR() args: 0, res: 0, upd: 0;
       c57FV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57FR() //  []
         { info_tbl: [(c57FR,
                       label: block_c57FR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57FR: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.523844899 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$cmin_closure" {
     Data.Type.Equality.$fOrd:~:_$cmin_closure:
         const Data.Type.Equality.$fOrd:~:_$cmin_info;
 },
 Data.Type.Equality.$fOrd:~:_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c57Gn,
                       label: Data.Type.Equality.$fOrd:~:_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Gn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57Go; else goto c57Gp;
       c57Go: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57Gp: // global
           I64[Sp - 16] = block_c57Gk_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57Gt; else goto c57Gl;
       u57Gt: // global
           call _c57Gk() args: 0, res: 0, upd: 0;
       c57Gl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57Gk() //  []
         { info_tbl: [(c57Gk,
                       label: block_c57Gk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Gk: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.530625544 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_closure" {
     Data.Type.Equality.$fOrd:~:_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Type.Equality.$fEq:~:_closure+1;
         const Data.Type.Equality.$fOrd:~:_$ccompare_closure+2;
         const Data.Type.Equality.$fOrd:~:_$c<_closure+2;
         const Data.Type.Equality.$fOrd:~:_$c<=_closure+2;
         const Data.Type.Equality.$fOrd:~:_$c>_closure+2;
         const Data.Type.Equality.$fEq:~:_$c==_closure+2;
         const Data.Type.Equality.$fOrd:~:_$cmax_closure+2;
         const Data.Type.Equality.$fOrd:~:_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.532599509 UTC

[section ""data" . Data.Type.Equality.$fRead:~:_lexeme_closure" {
     Data.Type.Equality.$fRead:~:_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Type.Equality.$fRead:~:2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.535040577 UTC

[section ""data" . Data.Type.Equality.$fRead:~:1_closure" {
     Data.Type.Equality.$fRead:~:1_closure:
         const Data.Type.Equality.$fRead:~:1_info;
         const 0;
 },
 sat_s56bT_entry() //  [R1]
         { info_tbl: [(c57GQ,
                       label: sat_s56bT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57GQ: // global
           R2 = Data.Type.Equality.$WRefl_closure+1;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~:1_entry() //  [R2, R3]
         { info_tbl: [(c57GW,
                       label: Data.Type.Equality.$fRead:~:1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57GW: // global
           _s56bR::P64 = R3;
           _s56bQ::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c57GX; else goto c57GY;
       c57GY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57H0; else goto c57GZ;
       c57H0: // global
           HpAlloc = 16;
           goto c57GX;
       c57GX: // global
           R3 = _s56bR::P64;
           R2 = _s56bQ::P64;
           R1 = Data.Type.Equality.$fRead:~:1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57GZ: // global
           I64[Hp - 8] = sat_s56bT_info;
           P64[Hp] = _s56bR::P64;
           I64[Sp - 8] = block_c57GT_info;
           R3 = Hp - 7;
           R2 = Data.Type.Equality.$fRead:~:_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57GT() //  [R1]
         { info_tbl: [(c57GT,
                       label: block_c57GT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57GT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57H3; else goto c57H2;
       c57H3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c57H2: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.543256459 UTC

[section ""data" . Data.Type.Equality.$fRead:~:4_closure" {
     Data.Type.Equality.$fRead:~:4_closure:
         const Data.Type.Equality.$fRead:~:4_info;
         const 0;
 },
 Data.Type.Equality.$fRead:~:4_entry() //  [R2, R3, R4]
         { info_tbl: [(c57Hm,
                       label: Data.Type.Equality.$fRead:~:4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Hm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c57Hn; else goto c57Ho;
       c57Hn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~:4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c57Ho: // global
           I64[Sp - 24] = block_c57Hk_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57Hk() //  []
         { info_tbl: [(c57Hk,
                       label: block_c57Hk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Hk: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~:1_closure+2;
           Sp = Sp + 24;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.550006022 UTC

[section ""data" . Data.Type.Equality.$fRead:~:_$creadsPrec_closure" {
     Data.Type.Equality.$fRead:~:_$creadsPrec_closure:
         const Data.Type.Equality.$fRead:~:_$creadsPrec_info;
         const 0;
 },
 sat_s56c1_entry() //  [R1]
         { info_tbl: [(c57HK,
                       label: sat_s56c1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57HK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c57HL; else goto c57HM;
       c57HL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57HM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c57HI_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c57HI() //  []
         { info_tbl: [(c57HI,
                       label: block_c57HI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57HI: // global
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~:1_closure+2;
           Sp = Sp + 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fRead:~:_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c57HO,
                       label: Data.Type.Equality.$fRead:~:_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57HO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c57HP; else goto c57HQ;
       c57HP: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~:_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57HQ: // global
           I64[Sp - 24] = block_c57HC_info;
           _s56bZ::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s56bZ::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57HC() //  []
         { info_tbl: [(c57HC,
                       label: block_c57HC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57HC: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c57HT; else goto c57HS;
       c57HT: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c57HS: // global
           I64[Hp - 24] = sat_s56c1_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.560111186 UTC

[section ""data" . Data.Type.Equality.$fRead:~:_$creadListPrec_closure" {
     Data.Type.Equality.$fRead:~:_$creadListPrec_closure:
         const Data.Type.Equality.$fRead:~:_$creadListPrec_info;
         const 0;
 },
 sat_s56c5_entry() //  [R1, R2, R3]
         { info_tbl: [(c57Ip,
                       label: sat_s56c5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Ip: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c57Iq; else goto c57Ir;
       c57Iq: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57Ir: // global
           I64[Sp - 24] = block_c57In_info;
           _s56c3::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = _s56c3::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57In() //  []
         { info_tbl: [(c57In,
                       label: block_c57In_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57In: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~:1_closure+2;
           Sp = Sp + 24;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~:_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c57It,
                       label: Data.Type.Equality.$fRead:~:_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57It: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57Iu; else goto c57Iv;
       c57Iu: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~:_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57Iv: // global
           I64[Sp - 16] = block_c57Ig_info;
           _s56c2::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s56c2::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57Ig() //  []
         { info_tbl: [(c57Ig,
                       label: block_c57Ig_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Ig: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57Iy; else goto c57Ix;
       c57Iy: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c57Ix: // global
           I64[Hp - 8] = sat_s56c5_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 6;
           Sp = Sp + 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.57139035 UTC

[section ""data" . Data.Type.Equality.$fRead:~:_$creadList_closure" {
     Data.Type.Equality.$fRead:~:_$creadList_closure:
         const Data.Type.Equality.$fRead:~:_$creadList_info;
         const 0;
 },
 sat_s56c9_entry() //  [R2, R3]
         { info_tbl: [(c57J6,
                       label: sat_s56c9_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57J6: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Type.Equality.$fRead:~:1_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56ca_entry() //  [R1]
         { info_tbl: [(c57J9,
                       label: sat_s56ca_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57J9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c57Ja; else goto c57Jb;
       c57Ja: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57Jb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c57IZ_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c57IZ() //  []
         { info_tbl: [(c57IZ,
                       label: block_c57IZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57IZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57Je; else goto c57Jd;
       c57Je: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c57Jd: // global
           I64[Hp - 8] = sat_s56c9_info;
           R2 = Hp - 6;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = GHC.Read.$fRead()7_closure;
           P64[Sp] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fRead:~:_$creadList_entry() //  [R2]
         { info_tbl: [(c57Jf,
                       label: Data.Type.Equality.$fRead:~:_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Jf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57Jg; else goto c57Jh;
       c57Jg: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~:_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57Jh: // global
           I64[Sp - 16] = block_c57IT_info;
           _s56c6::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s56c6::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57IT() //  []
         { info_tbl: [(c57IT,
                       label: block_c57IT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57IT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c57Jk; else goto c57Jj;
       c57Jk: // global
           HpAlloc = 24;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c57Jj: // global
           I64[Hp - 16] = sat_s56ca_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.584152416 UTC

[section ""data" . Data.Type.Equality.$fRead:~:_closure" {
     Data.Type.Equality.$fRead:~:_closure:
         const Data.Type.Equality.$fRead:~:_info;
         const 0;
 },
 sat_s56cf_entry() //  [R1]
         { info_tbl: [(c57JM,
                       label: sat_s56cf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57JM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57JN; else goto c57JO;
       c57JN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57JO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fRead:~:_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56ce_entry() //  [R1, R2, R3]
         { info_tbl: [(c57JU,
                       label: sat_s56ce_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57JU: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fRead:~:4_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56cd_entry() //  [R1]
         { info_tbl: [(c57K1,
                       label: sat_s56cd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57K1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57K2; else goto c57K3;
       c57K2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57K3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fRead:~:_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56cc_entry() //  [R1, R2]
         { info_tbl: [(c57K9,
                       label: sat_s56cc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57K9: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fRead:~:_$creadsPrec_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~:_entry() //  [R2]
         { info_tbl: [(c57Kd,
                       label: Data.Type.Equality.$fRead:~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Kd: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c57Kh; else goto c57Kg;
       c57Kh: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57Kg: // global
           I64[Hp - 112] = sat_s56cf_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s56ce_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s56cd_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s56cc_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 112;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.596045088 UTC

[section ""data" . Data.Type.Equality.$fBounded:~:_$cmaxBound_closure" {
     Data.Type.Equality.$fBounded:~:_$cmaxBound_closure:
         const Data.Type.Equality.$fBounded:~:_$cmaxBound_info;
 },
 Data.Type.Equality.$fBounded:~:_$cmaxBound_entry() //  [R2]
         { info_tbl: [(c57KL,
                       label: Data.Type.Equality.$fBounded:~:_$cmaxBound_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57KL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c57KM; else goto c57KN;
       c57KM: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fBounded:~:_$cmaxBound_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57KN: // global
           I64[Sp - 8] = block_c57KJ_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57KJ() //  []
         { info_tbl: [(c57KJ,
                       label: block_c57KJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57KJ: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.602227656 UTC

[section ""data" . Data.Type.Equality.$fBounded:~:_closure" {
     Data.Type.Equality.$fBounded:~:_closure:
         const Data.Type.Equality.$fBounded:~:_info;
 },
 sat_s56cj_entry() //  [R1]
         { info_tbl: [(c57L6,
                       label: sat_s56cj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57L6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57L7; else goto c57L8;
       c57L7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57L8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fBounded:~:_$cmaxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56ci_entry() //  [R1]
         { info_tbl: [(c57Ld,
                       label: sat_s56ci_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Ld: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57Le; else goto c57Lf;
       c57Le: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57Lf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fBounded:~:_$cmaxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fBounded:~:_entry() //  [R2]
         { info_tbl: [(c57Lh,
                       label: Data.Type.Equality.$fBounded:~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Lh: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c57Ll; else goto c57Lk;
       c57Ll: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Type.Equality.$fBounded:~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57Lk: // global
           I64[Hp - 64] = sat_s56cj_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s56ci_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.611655583 UTC

[section ""data" . Data.Type.Equality.$fEq:~~:_$c==_closure" {
     Data.Type.Equality.$fEq:~~:_$c==_closure:
         const Data.Type.Equality.$fEq:~~:_$c==_info;
 },
 Data.Type.Equality.$fEq:~~:_$c==_entry() //  [R2, R3]
         { info_tbl: [(c57LI,
                       label: Data.Type.Equality.$fEq:~~:_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57LI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57LM; else goto c57LN;
       c57LM: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEq:~~:_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57LN: // global
           I64[Sp - 16] = block_c57LF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57LV; else goto c57LG;
       u57LV: // global
           call _c57LF() args: 0, res: 0, upd: 0;
       c57LG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57LF() //  []
         { info_tbl: [(c57LF,
                       label: block_c57LF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57LF: // global
           _s56cl::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57LL_info;
           R1 = _s56cl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57LU; else goto c57LP;
       u57LU: // global
           call _c57LL() args: 0, res: 0, upd: 0;
       c57LP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57LL() //  []
         { info_tbl: [(c57LL,
                       label: block_c57LL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57LL: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.619609345 UTC

[section ""data" . Data.Type.Equality.$fEq:~~:_$c/=_closure" {
     Data.Type.Equality.$fEq:~~:_$c/=_closure:
         const Data.Type.Equality.$fEq:~~:_$c/=_info;
 },
 Data.Type.Equality.$fEq:~~:_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c57Mh,
                       label: Data.Type.Equality.$fEq:~~:_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Mh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57Ml; else goto c57Mm;
       c57Ml: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEq:~~:_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57Mm: // global
           I64[Sp - 16] = block_c57Me_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57Mu; else goto c57Mf;
       u57Mu: // global
           call _c57Me() args: 0, res: 0, upd: 0;
       c57Mf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57Me() //  []
         { info_tbl: [(c57Me,
                       label: block_c57Me_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Me: // global
           _s56cp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57Mk_info;
           R1 = _s56cp::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57Mt; else goto c57Mo;
       u57Mt: // global
           call _c57Mk() args: 0, res: 0, upd: 0;
       c57Mo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57Mk() //  []
         { info_tbl: [(c57Mk,
                       label: block_c57Mk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Mk: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.627477767 UTC

[section ""data" . Data.Type.Equality.$fEq:~~:_closure" {
     Data.Type.Equality.$fEq:~~:_closure:
         const GHC.Classes.C:Eq_con_info;
         const Data.Type.Equality.$fEq:~~:_$c==_closure+2;
         const Data.Type.Equality.$fEq:~~:_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.629401393 UTC

[section ""cstring" . Data.Type.Equality.$fRead:~~:3_bytes" {
     Data.Type.Equality.$fRead:~~:3_bytes:
         I8[] [72,82,101,102,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.631513935 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:2_closure" {
     Data.Type.Equality.$fRead:~~:2_closure:
         const Data.Type.Equality.$fRead:~~:2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Equality.$fRead:~~:2_entry() //  [R1]
         { info_tbl: [(c57MR,
                       label: Data.Type.Equality.$fRead:~~:2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57MR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57MS; else goto c57MT;
       c57MS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57MT: // global
           (_c57MO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c57MO::I64 == 0) goto c57MQ; else goto c57MP;
       c57MQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c57MP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c57MO::I64;
           R2 = Data.Type.Equality.$fRead:~~:3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.63623782 UTC

[section ""data" . Data.Type.Equality.$fShow:~~:_$cshowsPrec_closure" {
     Data.Type.Equality.$fShow:~~:_$cshowsPrec_closure:
         const Data.Type.Equality.$fShow:~~:_$cshowsPrec_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~~:_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c57N8,
                       label: Data.Type.Equality.$fShow:~~:_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57N8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57N9; else goto c57Na;
       c57N9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~~:_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c57Na: // global
           I64[Sp - 16] = block_c57N5_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57Ne; else goto c57N6;
       u57Ne: // global
           call _c57N5() args: 0, res: 0, upd: 0;
       c57N6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57N5() //  []
         { info_tbl: [(c57N5,
                       label: block_c57N5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57N5: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~~:2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.643166804 UTC

[section ""data" . Data.Type.Equality.$fShow:~~:_$cshow_closure" {
     Data.Type.Equality.$fShow:~~:_$cshow_closure:
         const Data.Type.Equality.$fShow:~~:_$cshow_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~~:_$cshow_entry() //  [R2]
         { info_tbl: [(c57Nv,
                       label: Data.Type.Equality.$fShow:~~:_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Nv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c57Nw; else goto c57Nx;
       c57Nw: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~~:_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57Nx: // global
           I64[Sp - 8] = block_c57Ns_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u57NB; else goto c57Nt;
       u57NB: // global
           call _c57Ns() args: 0, res: 0, upd: 0;
       c57Nt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57Ns() //  []
         { info_tbl: [(c57Ns,
                       label: block_c57Ns_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Ns: // global
           R1 = Data.Type.Equality.$fRead:~~:2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.649944492 UTC

[section ""data" . Data.Type.Equality.$fShow:~~:1_closure" {
     Data.Type.Equality.$fShow:~~:1_closure:
         const Data.Type.Equality.$fShow:~~:1_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~~:1_entry() //  [R2, R3]
         { info_tbl: [(c57NT,
                       label: Data.Type.Equality.$fShow:~~:1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57NT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57NU; else goto c57NV;
       c57NU: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~~:1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57NV: // global
           I64[Sp - 16] = block_c57NQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57NZ; else goto c57NR;
       u57NZ: // global
           call _c57NQ() args: 0, res: 0, upd: 0;
       c57NR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57NQ() //  []
         { info_tbl: [(c57NQ,
                       label: block_c57NQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57NQ: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~~:2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.655845033 UTC

[section ""data" . Data.Type.Equality.$fShow:~~:_$cshowList_closure" {
     Data.Type.Equality.$fShow:~~:_$cshowList_closure:
         const Data.Type.Equality.$fShow:~~:_$cshowList_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~~:_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c57Od,
                       label: Data.Type.Equality.$fShow:~~:_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Od: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Type.Equality.$fShow:~~:1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.659336043 UTC

[section ""data" . Data.Type.Equality.$fShow:~~:_closure" {
     Data.Type.Equality.$fShow:~~:_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Type.Equality.$fShow:~~:_$cshowsPrec_closure+3;
         const Data.Type.Equality.$fShow:~~:_$cshow_closure+1;
         const Data.Type.Equality.$fShow:~~:_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.662016051 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$c<_closure" {
     Data.Type.Equality.$fOrd:~~:_$c<_closure:
         const Data.Type.Equality.$fOrd:~~:_$c<_info;
 },
 Data.Type.Equality.$fOrd:~~:_$c<_entry() //  [R2, R3]
         { info_tbl: [(c57Os,
                       label: Data.Type.Equality.$fOrd:~~:_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Os: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57Ow; else goto c57Ox;
       c57Ow: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57Ox: // global
           I64[Sp - 16] = block_c57Op_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57OF; else goto c57Oq;
       u57OF: // global
           call _c57Op() args: 0, res: 0, upd: 0;
       c57Oq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57Op() //  []
         { info_tbl: [(c57Op,
                       label: block_c57Op_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Op: // global
           _s56cE::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57Ov_info;
           R1 = _s56cE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57OE; else goto c57Oz;
       u57OE: // global
           call _c57Ov() args: 0, res: 0, upd: 0;
       c57Oz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57Ov() //  []
         { info_tbl: [(c57Ov,
                       label: block_c57Ov_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Ov: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.669539819 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$ccompare_closure" {
     Data.Type.Equality.$fOrd:~~:_$ccompare_closure:
         const Data.Type.Equality.$fOrd:~~:_$ccompare_info;
 },
 Data.Type.Equality.$fOrd:~~:_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c57P1,
                       label: Data.Type.Equality.$fOrd:~~:_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57P1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57P5; else goto c57P6;
       c57P5: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57P6: // global
           I64[Sp - 16] = block_c57OY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57Pe; else goto c57OZ;
       u57Pe: // global
           call _c57OY() args: 0, res: 0, upd: 0;
       c57OZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57OY() //  []
         { info_tbl: [(c57OY,
                       label: block_c57OY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57OY: // global
           _s56cI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57P4_info;
           R1 = _s56cI::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57Pd; else goto c57P8;
       u57Pd: // global
           call _c57P4() args: 0, res: 0, upd: 0;
       c57P8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57P4() //  []
         { info_tbl: [(c57P4,
                       label: block_c57P4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57P4: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.677591215 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$c<=_closure" {
     Data.Type.Equality.$fOrd:~~:_$c<=_closure:
         const Data.Type.Equality.$fOrd:~~:_$c<=_info;
 },
 Data.Type.Equality.$fOrd:~~:_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c57PA,
                       label: Data.Type.Equality.$fOrd:~~:_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57PA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57PE; else goto c57PF;
       c57PE: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57PF: // global
           I64[Sp - 16] = block_c57Px_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57PN; else goto c57Py;
       u57PN: // global
           call _c57Px() args: 0, res: 0, upd: 0;
       c57Py: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57Px() //  []
         { info_tbl: [(c57Px,
                       label: block_c57Px_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Px: // global
           _s56cL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57PD_info;
           R1 = _s56cL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57PM; else goto c57PH;
       u57PM: // global
           call _c57PD() args: 0, res: 0, upd: 0;
       c57PH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57PD() //  []
         { info_tbl: [(c57PD,
                       label: block_c57PD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57PD: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.686369797 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$cmax_closure" {
     Data.Type.Equality.$fOrd:~~:_$cmax_closure:
         const Data.Type.Equality.$fOrd:~~:_$cmax_info;
 },
 Data.Type.Equality.$fOrd:~~:_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c57Q9,
                       label: Data.Type.Equality.$fOrd:~~:_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Q9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57Qa; else goto c57Qb;
       c57Qa: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57Qb: // global
           I64[Sp - 16] = block_c57Q6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57Qf; else goto c57Q7;
       u57Qf: // global
           call _c57Q6() args: 0, res: 0, upd: 0;
       c57Q7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57Q6() //  []
         { info_tbl: [(c57Q6,
                       label: block_c57Q6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Q6: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.692359342 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$c>_closure" {
     Data.Type.Equality.$fOrd:~~:_$c>_closure:
         const Data.Type.Equality.$fOrd:~~:_$c>_info;
 },
 Data.Type.Equality.$fOrd:~~:_$c>_entry() //  [R2, R3]
         { info_tbl: [(c57Qy,
                       label: Data.Type.Equality.$fOrd:~~:_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Qy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57QC; else goto c57QD;
       c57QC: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57QD: // global
           I64[Sp - 16] = block_c57Qv_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57QL; else goto c57Qw;
       u57QL: // global
           call _c57Qv() args: 0, res: 0, upd: 0;
       c57Qw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57Qv() //  []
         { info_tbl: [(c57Qv,
                       label: block_c57Qv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Qv: // global
           _s56cS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57QB_info;
           R1 = _s56cS::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57QK; else goto c57QF;
       u57QK: // global
           call _c57QB() args: 0, res: 0, upd: 0;
       c57QF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57QB() //  []
         { info_tbl: [(c57QB,
                       label: block_c57QB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57QB: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.70005292 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$cmin_closure" {
     Data.Type.Equality.$fOrd:~~:_$cmin_closure:
         const Data.Type.Equality.$fOrd:~~:_$cmin_info;
 },
 Data.Type.Equality.$fOrd:~~:_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c57R7,
                       label: Data.Type.Equality.$fOrd:~~:_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57R7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57R8; else goto c57R9;
       c57R8: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57R9: // global
           I64[Sp - 16] = block_c57R4_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57Rd; else goto c57R5;
       u57Rd: // global
           call _c57R4() args: 0, res: 0, upd: 0;
       c57R5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57R4() //  []
         { info_tbl: [(c57R4,
                       label: block_c57R4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57R4: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.705976186 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_closure" {
     Data.Type.Equality.$fOrd:~~:_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Type.Equality.$fEq:~~:_closure+1;
         const Data.Type.Equality.$fOrd:~~:_$ccompare_closure+2;
         const Data.Type.Equality.$fOrd:~~:_$c<_closure+2;
         const Data.Type.Equality.$fOrd:~~:_$c<=_closure+2;
         const Data.Type.Equality.$fOrd:~~:_$c>_closure+2;
         const Data.Type.Equality.$fEq:~~:_$c==_closure+2;
         const Data.Type.Equality.$fOrd:~~:_$cmax_closure+2;
         const Data.Type.Equality.$fOrd:~~:_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.707931598 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:_lexeme_closure" {
     Data.Type.Equality.$fRead:~~:_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Type.Equality.$fRead:~~:2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.710392582 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:1_closure" {
     Data.Type.Equality.$fRead:~~:1_closure:
         const Data.Type.Equality.$fRead:~~:1_info;
         const 0;
 },
 sat_s56d2_entry() //  [R1]
         { info_tbl: [(c57RA,
                       label: sat_s56d2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57RA: // global
           R2 = Data.Type.Equality.$WHRefl_closure+1;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~~:1_entry() //  [R2, R3]
         { info_tbl: [(c57RG,
                       label: Data.Type.Equality.$fRead:~~:1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57RG: // global
           _s56d0::P64 = R3;
           _s56cZ::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c57RH; else goto c57RI;
       c57RI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57RK; else goto c57RJ;
       c57RK: // global
           HpAlloc = 16;
           goto c57RH;
       c57RH: // global
           R3 = _s56d0::P64;
           R2 = _s56cZ::P64;
           R1 = Data.Type.Equality.$fRead:~~:1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57RJ: // global
           I64[Hp - 8] = sat_s56d2_info;
           P64[Hp] = _s56d0::P64;
           I64[Sp - 8] = block_c57RD_info;
           R3 = Hp - 7;
           R2 = Data.Type.Equality.$fRead:~~:_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57RD() //  [R1]
         { info_tbl: [(c57RD,
                       label: block_c57RD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57RD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57RN; else goto c57RM;
       c57RN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c57RM: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.718364857 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:4_closure" {
     Data.Type.Equality.$fRead:~~:4_closure:
         const Data.Type.Equality.$fRead:~~:4_info;
         const 0;
 },
 Data.Type.Equality.$fRead:~~:4_entry() //  [R2, R3, R4]
         { info_tbl: [(c57S6,
                       label: Data.Type.Equality.$fRead:~~:4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57S6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c57S7; else goto c57S8;
       c57S7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~~:4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c57S8: // global
           I64[Sp - 24] = block_c57S4_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57S4() //  []
         { info_tbl: [(c57S4,
                       label: block_c57S4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57S4: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~~:1_closure+2;
           Sp = Sp + 24;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.725432802 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:_$creadsPrec_closure" {
     Data.Type.Equality.$fRead:~~:_$creadsPrec_closure:
         const Data.Type.Equality.$fRead:~~:_$creadsPrec_info;
         const 0;
 },
 sat_s56da_entry() //  [R1]
         { info_tbl: [(c57Su,
                       label: sat_s56da_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Su: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c57Sv; else goto c57Sw;
       c57Sv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57Sw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c57Ss_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c57Ss() //  []
         { info_tbl: [(c57Ss,
                       label: block_c57Ss_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Ss: // global
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~~:1_closure+2;
           Sp = Sp + 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fRead:~~:_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c57Sy,
                       label: Data.Type.Equality.$fRead:~~:_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Sy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c57Sz; else goto c57SA;
       c57Sz: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~~:_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57SA: // global
           I64[Sp - 24] = block_c57Sm_info;
           _s56d8::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s56d8::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57Sm() //  []
         { info_tbl: [(c57Sm,
                       label: block_c57Sm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Sm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c57SD; else goto c57SC;
       c57SD: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c57SC: // global
           I64[Hp - 24] = sat_s56da_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.735502639 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:_$creadListPrec_closure" {
     Data.Type.Equality.$fRead:~~:_$creadListPrec_closure:
         const Data.Type.Equality.$fRead:~~:_$creadListPrec_info;
         const 0;
 },
 sat_s56de_entry() //  [R1, R2, R3]
         { info_tbl: [(c57T9,
                       label: sat_s56de_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57T9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c57Ta; else goto c57Tb;
       c57Ta: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57Tb: // global
           I64[Sp - 24] = block_c57T7_info;
           _s56dc::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = _s56dc::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57T7() //  []
         { info_tbl: [(c57T7,
                       label: block_c57T7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57T7: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~~:1_closure+2;
           Sp = Sp + 24;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~~:_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c57Td,
                       label: Data.Type.Equality.$fRead:~~:_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Td: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57Te; else goto c57Tf;
       c57Te: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~~:_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57Tf: // global
           I64[Sp - 16] = block_c57T0_info;
           _s56db::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s56db::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57T0() //  []
         { info_tbl: [(c57T0,
                       label: block_c57T0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57T0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57Ti; else goto c57Th;
       c57Ti: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c57Th: // global
           I64[Hp - 8] = sat_s56de_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 6;
           Sp = Sp + 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.746334907 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:_$creadList_closure" {
     Data.Type.Equality.$fRead:~~:_$creadList_closure:
         const Data.Type.Equality.$fRead:~~:_$creadList_info;
         const 0;
 },
 sat_s56di_entry() //  [R2, R3]
         { info_tbl: [(c57TQ,
                       label: sat_s56di_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57TQ: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Type.Equality.$fRead:~~:1_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56dj_entry() //  [R1]
         { info_tbl: [(c57TT,
                       label: sat_s56dj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57TT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c57TU; else goto c57TV;
       c57TU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57TV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c57TJ_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c57TJ() //  []
         { info_tbl: [(c57TJ,
                       label: block_c57TJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57TJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57TY; else goto c57TX;
       c57TY: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c57TX: // global
           I64[Hp - 8] = sat_s56di_info;
           R2 = Hp - 6;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = GHC.Read.$fRead()7_closure;
           P64[Sp] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fRead:~~:_$creadList_entry() //  [R2]
         { info_tbl: [(c57TZ,
                       label: Data.Type.Equality.$fRead:~~:_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57TZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57U0; else goto c57U1;
       c57U0: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~~:_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57U1: // global
           I64[Sp - 16] = block_c57TD_info;
           _s56df::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s56df::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57TD() //  []
         { info_tbl: [(c57TD,
                       label: block_c57TD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57TD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c57U4; else goto c57U3;
       c57U4: // global
           HpAlloc = 24;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c57U3: // global
           I64[Hp - 16] = sat_s56dj_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.758768418 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:_closure" {
     Data.Type.Equality.$fRead:~~:_closure:
         const Data.Type.Equality.$fRead:~~:_info;
         const 0;
 },
 sat_s56do_entry() //  [R1]
         { info_tbl: [(c57Uw,
                       label: sat_s56do_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Uw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57Ux; else goto c57Uy;
       c57Ux: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57Uy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fRead:~~:_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56dn_entry() //  [R1, R2, R3]
         { info_tbl: [(c57UE,
                       label: sat_s56dn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57UE: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fRead:~~:4_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s56dm_entry() //  [R1]
         { info_tbl: [(c57UL,
                       label: sat_s56dm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57UL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57UM; else goto c57UN;
       c57UM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57UN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fRead:~~:_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56dl_entry() //  [R1, R2]
         { info_tbl: [(c57UT,
                       label: sat_s56dl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57UT: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fRead:~~:_$creadsPrec_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~~:_entry() //  [R2]
         { info_tbl: [(c57UX,
                       label: Data.Type.Equality.$fRead:~~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57UX: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c57V1; else goto c57V0;
       c57V1: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57V0: // global
           I64[Hp - 112] = sat_s56do_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s56dn_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s56dm_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s56dl_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 112;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.771030405 UTC

[section ""data" . Data.Type.Equality.$fBounded:~~:_$cmaxBound_closure" {
     Data.Type.Equality.$fBounded:~~:_$cmaxBound_closure:
         const Data.Type.Equality.$fBounded:~~:_$cmaxBound_info;
 },
 Data.Type.Equality.$fBounded:~~:_$cmaxBound_entry() //  [R2]
         { info_tbl: [(c57Vv,
                       label: Data.Type.Equality.$fBounded:~~:_$cmaxBound_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Vv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c57Vw; else goto c57Vx;
       c57Vw: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fBounded:~~:_$cmaxBound_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57Vx: // global
           I64[Sp - 8] = block_c57Vt_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c57Vt() //  []
         { info_tbl: [(c57Vt,
                       label: block_c57Vt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Vt: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.777220267 UTC

[section ""data" . Data.Type.Equality.$fBounded:~~:_closure" {
     Data.Type.Equality.$fBounded:~~:_closure:
         const Data.Type.Equality.$fBounded:~~:_info;
 },
 sat_s56ds_entry() //  [R1]
         { info_tbl: [(c57VQ,
                       label: sat_s56ds_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57VQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57VR; else goto c57VS;
       c57VR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57VS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fBounded:~~:_$cmaxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s56dr_entry() //  [R1]
         { info_tbl: [(c57VX,
                       label: sat_s56dr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57VX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57VY; else goto c57VZ;
       c57VY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c57VZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fBounded:~~:_$cmaxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fBounded:~~:_entry() //  [R2]
         { info_tbl: [(c57W1,
                       label: Data.Type.Equality.$fBounded:~~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57W1: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c57W5; else goto c57W4;
       c57W5: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Type.Equality.$fBounded:~~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57W4: // global
           I64[Hp - 64] = sat_s56ds_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s56dr_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.785683863 UTC

[section ""data" . Data.Type.Equality.sym_closure" {
     Data.Type.Equality.sym_closure:
         const Data.Type.Equality.sym_info;
 },
 Data.Type.Equality.sym_entry() //  [R2]
         { info_tbl: [(c57Ws,
                       label: Data.Type.Equality.sym_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Ws: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c57Wt; else goto c57Wu;
       c57Wt: // global
           R2 = R2;
           R1 = Data.Type.Equality.sym_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57Wu: // global
           I64[Sp - 8] = block_c57Wp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u57Wy; else goto c57Wq;
       u57Wy: // global
           call _c57Wp() args: 0, res: 0, upd: 0;
       c57Wq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57Wp() //  []
         { info_tbl: [(c57Wp,
                       label: block_c57Wp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Wp: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.791703208 UTC

[section ""data" . Data.Type.Equality.trans_closure" {
     Data.Type.Equality.trans_closure:
         const Data.Type.Equality.trans_info;
 },
 Data.Type.Equality.trans_entry() //  [R2, R3]
         { info_tbl: [(c57WQ,
                       label: Data.Type.Equality.trans_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57WQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57WU; else goto c57WV;
       c57WU: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.trans_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57WV: // global
           I64[Sp - 16] = block_c57WN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57X3; else goto c57WO;
       u57X3: // global
           call _c57WN() args: 0, res: 0, upd: 0;
       c57WO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57WN() //  []
         { info_tbl: [(c57WN,
                       label: block_c57WN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57WN: // global
           _s56dw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57WT_info;
           R1 = _s56dw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57X2; else goto c57WX;
       u57X2: // global
           call _c57WT() args: 0, res: 0, upd: 0;
       c57WX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57WT() //  []
         { info_tbl: [(c57WT,
                       label: block_c57WT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57WT: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.799941298 UTC

[section ""data" . Data.Type.Equality.castWith_closure" {
     Data.Type.Equality.castWith_closure:
         const Data.Type.Equality.castWith_info;
 },
 Data.Type.Equality.castWith_entry() //  [R2, R3]
         { info_tbl: [(c57Xp,
                       label: Data.Type.Equality.castWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Xp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57Xq; else goto c57Xr;
       c57Xq: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.castWith_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57Xr: // global
           I64[Sp - 16] = block_c57Xm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57Xv; else goto c57Xn;
       u57Xv: // global
           call _c57Xm() args: 0, res: 0, upd: 0;
       c57Xn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57Xm() //  []
         { info_tbl: [(c57Xm,
                       label: block_c57Xm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Xm: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.80642476 UTC

[section ""data" . Data.Type.Equality.gcastWith_closure" {
     Data.Type.Equality.gcastWith_closure:
         const Data.Type.Equality.gcastWith_info;
 },
 Data.Type.Equality.gcastWith_entry() //  [R2, R3]
         { info_tbl: [(c57XM,
                       label: Data.Type.Equality.gcastWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57XM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57XQ; else goto c57XR;
       c57XQ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.gcastWith_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57XR: // global
           I64[Sp - 16] = block_c57XJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57XV; else goto c57XK;
       u57XV: // global
           call _c57XJ(R1) args: 0, res: 0, upd: 0;
       c57XK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57XJ() //  [R1]
         { info_tbl: [(c57XJ,
                       label: block_c57XJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57XJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c57XU; else goto c57XT;
       c57XU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c57XT: // global
           I64[Hp - 8] = GHC.Types.Eq#_con_info;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.812575794 UTC

[section ""data" . Data.Type.Equality.apply_closure" {
     Data.Type.Equality.apply_closure:
         const Data.Type.Equality.apply_info;
 },
 Data.Type.Equality.apply_entry() //  [R2, R3]
         { info_tbl: [(c57Yc,
                       label: Data.Type.Equality.apply_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Yc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c57Yg; else goto c57Yh;
       c57Yg: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.apply_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c57Yh: // global
           I64[Sp - 16] = block_c57Y9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u57Yp; else goto c57Ya;
       u57Yp: // global
           call _c57Y9() args: 0, res: 0, upd: 0;
       c57Ya: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57Y9() //  []
         { info_tbl: [(c57Y9,
                       label: block_c57Y9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Y9: // global
           _s56dH::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c57Yf_info;
           R1 = _s56dH::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u57Yo; else goto c57Yj;
       u57Yo: // global
           call _c57Yf() args: 0, res: 0, upd: 0;
       c57Yj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57Yf() //  []
         { info_tbl: [(c57Yf,
                       label: block_c57Yf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Yf: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.820113446 UTC

[section ""data" . Data.Type.Equality.inner_closure" {
     Data.Type.Equality.inner_closure:
         const Data.Type.Equality.inner_info;
 },
 Data.Type.Equality.inner_entry() //  [R2]
         { info_tbl: [(c57YL,
                       label: Data.Type.Equality.inner_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57YL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c57YM; else goto c57YN;
       c57YM: // global
           R2 = R2;
           R1 = Data.Type.Equality.inner_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57YN: // global
           I64[Sp - 8] = block_c57YI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u57YR; else goto c57YJ;
       u57YR: // global
           call _c57YI() args: 0, res: 0, upd: 0;
       c57YJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57YI() //  []
         { info_tbl: [(c57YI,
                       label: block_c57YI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57YI: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.826546371 UTC

[section ""data" . Data.Type.Equality.outer_closure" {
     Data.Type.Equality.outer_closure:
         const Data.Type.Equality.outer_info;
 },
 Data.Type.Equality.outer_entry() //  [R2]
         { info_tbl: [(c57Z9,
                       label: Data.Type.Equality.outer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Z9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c57Za; else goto c57Zb;
       c57Za: // global
           R2 = R2;
           R1 = Data.Type.Equality.outer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c57Zb: // global
           I64[Sp - 8] = block_c57Z6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u57Zf; else goto c57Z7;
       u57Zf: // global
           call _c57Z6() args: 0, res: 0, upd: 0;
       c57Z7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c57Z6() //  []
         { info_tbl: [(c57Z6,
                       label: block_c57Z6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c57Z6: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.831832106 UTC

[section ""cstring" . Data.Type.Equality.$trModule4_bytes" {
     Data.Type.Equality.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.833605244 UTC

[section ""data" . Data.Type.Equality.$trModule3_closure" {
     Data.Type.Equality.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.835840621 UTC

[section ""cstring" . Data.Type.Equality.$trModule2_bytes" {
     Data.Type.Equality.$trModule2_bytes:
         I8[] [68,97,116,97,46,84,121,112,101,46,69,113,117,97,108,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.837667937 UTC

[section ""data" . Data.Type.Equality.$trModule1_closure" {
     Data.Type.Equality.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.839292823 UTC

[section ""data" . Data.Type.Equality.$trModule_closure" {
     Data.Type.Equality.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Type.Equality.$trModule3_closure+1;
         const Data.Type.Equality.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.840917601 UTC

[section ""data" . $krep_r568a_closure" {
     $krep_r568a_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.842762569 UTC

[section ""data" . $krep1_r568b_closure" {
     $krep1_r568b_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.84441806 UTC

[section ""data" . $krep2_r568c_closure" {
     $krep2_r568c_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r568b_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.846580235 UTC

[section ""data" . $krep3_r568d_closure" {
     $krep3_r568d_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.848172875 UTC

[section ""data" . Data.Type.Equality.$tc:~~:1_closure" {
     Data.Type.Equality.$tc:~~:1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r568d_closure+2;
         const $krep2_r568c_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.849919523 UTC

[section ""data" . $krep4_r568e_closure" {
     $krep4_r568e_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r568d_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.851686084 UTC

[section ""data" . Data.Type.Equality.$tc:~:1_closure" {
     Data.Type.Equality.$tc:~:1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r568d_closure+2;
         const $krep4_r568e_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.854088376 UTC

[section ""data" . Data.Type.Equality.$tcTestEquality1_closure" {
     Data.Type.Equality.$tcTestEquality1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r568e_closure+4;
         const $krep_r568a_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.855796624 UTC

[section ""data" . $krep5_r568f_closure" {
     $krep5_r568f_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r568d_closure+2;
         const $krep_r568a_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.857490083 UTC

[section ""data" . Data.Type.Equality.$tc~1_closure" {
     Data.Type.Equality.$tc~1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r568d_closure+2;
         const $krep5_r568f_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.859179105 UTC

[section ""data" . $krep6_r568g_closure" {
     $krep6_r568g_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.86135451 UTC

[section ""data" . $krep7_r568h_closure" {
     $krep7_r568h_closure:
         const :_con_info;
         const $krep6_r568g_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.863165099 UTC

[section ""data" . $krep8_r568i_closure" {
     $krep8_r568i_closure:
         const :_con_info;
         const $krep1_r568b_closure+2;
         const $krep7_r568h_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.864981038 UTC

[section ""data" . $krep9_r568j_closure" {
     $krep9_r568j_closure:
         const :_con_info;
         const $krep3_r568d_closure+2;
         const $krep8_r568i_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.866628606 UTC

[section ""data" . $krep10_r568k_closure" {
     $krep10_r568k_closure:
         const :_con_info;
         const $krep3_r568d_closure+2;
         const $krep9_r568j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.868360067 UTC

[section ""data" . $krep11_r568l_closure" {
     $krep11_r568l_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc~~_closure;
         const $krep10_r568k_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.871006213 UTC

[section ""cstring" . Data.Type.Equality.$tc~3_bytes" {
     Data.Type.Equality.$tc~3_bytes:
         I8[] [126]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.872669056 UTC

[section ""data" . Data.Type.Equality.$tc~2_closure" {
     Data.Type.Equality.$tc~2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc~3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.874397682 UTC

[section ""data" . Data.Type.Equality.$tc~_closure" {
     Data.Type.Equality.$tc~_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc~2_closure+1;
         const Data.Type.Equality.$tc~1_closure+4;
         const 11470827771536267938;
         const 3625512399163125290;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.876243105 UTC

[section ""data" . $krep12_r568m_closure" {
     $krep12_r568m_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Type.Equality.$tc~_closure+1;
         const $krep9_r568j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.878047019 UTC

[section ""data" . Data.Type.Equality.$tc'C:~1_closure" {
     Data.Type.Equality.$tc'C:~1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r568l_closure+1;
         const $krep12_r568m_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.879809227 UTC

[section ""cstring" . Data.Type.Equality.$tc'C:~3_bytes" {
     Data.Type.Equality.$tc'C:~3_bytes:
         I8[] [39,67,58,126]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.881549529 UTC

[section ""data" . Data.Type.Equality.$tc'C:~2_closure" {
     Data.Type.Equality.$tc'C:~2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc'C:~3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.883297536 UTC

[section ""data" . Data.Type.Equality.$tc'C:~_closure" {
     Data.Type.Equality.$tc'C:~_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc'C:~2_closure+1;
         const Data.Type.Equality.$tc'C:~1_closure+4;
         const 6023002849810837484;
         const 5427525916893308990;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.885081387 UTC

[section ""cstring" . Data.Type.Equality.$tc:~:3_bytes" {
     Data.Type.Equality.$tc:~:3_bytes:
         I8[] [58,126,58]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.88737414 UTC

[section ""data" . Data.Type.Equality.$tc:~:2_closure" {
     Data.Type.Equality.$tc:~:2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc:~:3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.88989272 UTC

[section ""data" . Data.Type.Equality.$tc:~:_closure" {
     Data.Type.Equality.$tc:~:_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc:~:2_closure+1;
         const Data.Type.Equality.$tc:~:1_closure+4;
         const 10597498348876412676;
         const 16281320961088145472;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.891785989 UTC

[section ""data" . $krep13_r568n_closure" {
     $krep13_r568n_closure:
         const :_con_info;
         const $krep1_r568b_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.89354399 UTC

[section ""data" . $krep14_r568o_closure" {
     $krep14_r568o_closure:
         const :_con_info;
         const $krep1_r568b_closure+2;
         const $krep13_r568n_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.89525706 UTC

[section ""data" . $krep15_r568p_closure" {
     $krep15_r568p_closure:
         const :_con_info;
         const $krep3_r568d_closure+2;
         const $krep14_r568o_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.897020793 UTC

[section ""data" . Data.Type.Equality.$tc'Refl1_closure" {
     Data.Type.Equality.$tc'Refl1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Type.Equality.$tc:~:_closure+1;
         const $krep15_r568p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.898841787 UTC

[section ""cstring" . Data.Type.Equality.$tc'Refl3_bytes" {
     Data.Type.Equality.$tc'Refl3_bytes:
         I8[] [39,82,101,102,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.900502025 UTC

[section ""data" . Data.Type.Equality.$tc'Refl2_closure" {
     Data.Type.Equality.$tc'Refl2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc'Refl3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.902256282 UTC

[section ""data" . Data.Type.Equality.$tc'Refl_closure" {
     Data.Type.Equality.$tc'Refl_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc'Refl2_closure+1;
         const Data.Type.Equality.$tc'Refl1_closure+1;
         const 16680242040484769242;
         const 2864388906562808793;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.904118707 UTC

[section ""cstring" . Data.Type.Equality.$tc:~~:3_bytes" {
     Data.Type.Equality.$tc:~~:3_bytes:
         I8[] [58,126,126,58]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.906479393 UTC

[section ""data" . Data.Type.Equality.$tc:~~:2_closure" {
     Data.Type.Equality.$tc:~~:2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc:~~:3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.908257329 UTC

[section ""data" . Data.Type.Equality.$tc:~~:_closure" {
     Data.Type.Equality.$tc:~~:_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc:~~:2_closure+1;
         const Data.Type.Equality.$tc:~~:1_closure+4;
         const 4361259188665111259;
         const 11706467685470543992;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.910142247 UTC

[section ""data" . $krep16_r568q_closure" {
     $krep16_r568q_closure:
         const :_con_info;
         const $krep3_r568d_closure+2;
         const $krep15_r568p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.911913376 UTC

[section ""data" . Data.Type.Equality.$tc'HRefl1_closure" {
     Data.Type.Equality.$tc'HRefl1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Type.Equality.$tc:~~:_closure+1;
         const $krep16_r568q_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.913739974 UTC

[section ""cstring" . Data.Type.Equality.$tc'HRefl3_bytes" {
     Data.Type.Equality.$tc'HRefl3_bytes:
         I8[] [39,72,82,101,102,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.916164348 UTC

[section ""data" . Data.Type.Equality.$tc'HRefl2_closure" {
     Data.Type.Equality.$tc'HRefl2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc'HRefl3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.918017869 UTC

[section ""data" . Data.Type.Equality.$tc'HRefl_closure" {
     Data.Type.Equality.$tc'HRefl_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc'HRefl2_closure+1;
         const Data.Type.Equality.$tc'HRefl1_closure+1;
         const 4486133906173668740;
         const 6341741464738386857;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.919932547 UTC

[section ""cstring" . Data.Type.Equality.$tcTestEquality3_bytes" {
     Data.Type.Equality.$tcTestEquality3_bytes:
         I8[] [84,101,115,116,69,113,117,97,108,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.921750843 UTC

[section ""data" . Data.Type.Equality.$tcTestEquality2_closure" {
     Data.Type.Equality.$tcTestEquality2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tcTestEquality3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.923493889 UTC

[section ""data" . Data.Type.Equality.$tcTestEquality_closure" {
     Data.Type.Equality.$tcTestEquality_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tcTestEquality2_closure+1;
         const Data.Type.Equality.$tcTestEquality1_closure+4;
         const 2944680549948432194;
         const 17791533211054855448;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.925706688 UTC

[section ""data" . Data.Type.Equality.HRefl_closure" {
     Data.Type.Equality.HRefl_closure:
         const Data.Type.Equality.HRefl_info;
 },
 Data.Type.Equality.HRefl_entry() //  []
         { info_tbl: [(c580j,
                       label: Data.Type.Equality.HRefl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c580j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c580n; else goto c580m;
       c580n: // global
           HpAlloc = 16;
           R1 = Data.Type.Equality.HRefl_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c580m: // global
           I64[Hp - 8] = Data.Type.Equality.HRefl_con_info;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.930142348 UTC

[section ""data" . Data.Type.Equality.Refl_closure" {
     Data.Type.Equality.Refl_closure:
         const Data.Type.Equality.Refl_info;
 },
 Data.Type.Equality.Refl_entry() //  []
         { info_tbl: [(c580y,
                       label: Data.Type.Equality.Refl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c580y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c580C; else goto c580B;
       c580C: // global
           HpAlloc = 16;
           R1 = Data.Type.Equality.Refl_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c580B: // global
           I64[Hp - 8] = Data.Type.Equality.Refl_con_info;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.933761974 UTC

[Data.Type.Equality.HRefl_con_entry() //  [R1]
         { info_tbl: [(c580I,
                       label: Data.Type.Equality.HRefl_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,84,121,112,101,46,69,113,117,97,108,105,116,121,46,72,82,101,102,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c580I: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.937080764 UTC

[Data.Type.Equality.Refl_con_entry() //  [R1]
         { info_tbl: [(c580O,
                       label: Data.Type.Equality.Refl_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,84,121,112,101,46,69,113,117,97,108,105,116,121,46,82,101,102,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c580O: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:02.940336106 UTC

[section ""relreadonly" . S56eO_srt" {
     S56eO_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Type.Equality.$fEnum:~:1_closure;
         const Data.Type.Equality.$fEnum:~:_$ctoEnum_closure;
         const Data.Type.Equality.$fEnum:~:_$csucc_closure;
         const Data.Type.Equality.$w$cenumFromTo_closure;
         const Data.Type.Equality.$fEnum:~:_$cenumFromTo_closure;
         const Data.Type.Equality.$w$cenumFromThen_closure;
         const Data.Type.Equality.$fEnum:~:2_closure;
         const Data.Type.Equality.$fEnum:~:_$cenumFromThen_closure;
         const Data.Type.Equality.$w$cenumFrom_closure;
         const Data.Type.Equality.$fEnum:~:_$cenumFrom_closure;
         const Data.Type.Equality.$w$cenumFromThenTo_closure;
         const Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_closure;
         const Data.Type.Equality.$fEnum:~:_closure;
         const Data.Type.Equality.$fEnum:~~:1_closure;
         const Data.Type.Equality.$fEnum:~~:_$ctoEnum_closure;
         const Data.Type.Equality.$fEnum:~~:_$csucc_closure;
         const Data.Type.Equality.$w$cenumFromTo1_closure;
         const Data.Type.Equality.$fEnum:~~:_$cenumFromTo_closure;
         const Data.Type.Equality.$w$cenumFromThen1_closure;
         const Data.Type.Equality.$fEnum:~~:_$cenumFromThen_closure;
         const Data.Type.Equality.$w$cenumFrom1_closure;
         const Data.Type.Equality.$fEnum:~~:_$cenumFrom_closure;
         const Data.Type.Equality.$w$cenumFromThenTo1_closure;
         const Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_closure;
         const Data.Type.Equality.$fEnum:~~:_closure;
         const Data.Type.Equality.$fRead:~:2_closure;
         const Data.Type.Equality.$fShow:~:_$cshowsPrec_closure;
         const Data.Type.Equality.$fShow:~:_$cshow_closure;
         const Data.Type.Equality.$fShow:~:1_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Type.Equality.$fRead:~:1_closure;
         const Data.Type.Equality.$fRead:~:_lexeme_closure;
         const GHC.Read.list3_closure;
         const Data.Type.Equality.$fRead:~:4_closure;
         const Data.Type.Equality.$fRead:~:_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Type.Equality.$fRead:~:_$creadListPrec_closure;
         const Data.Type.Equality.$fRead:~:_$creadList_closure;
         const Data.Type.Equality.$fRead:~:_closure;
         const Data.Type.Equality.$fRead:~~:2_closure;
         const Data.Type.Equality.$fShow:~~:_$cshowsPrec_closure;
         const Data.Type.Equality.$fShow:~~:_$cshow_closure;
         const Data.Type.Equality.$fShow:~~:1_closure;
         const Data.Type.Equality.$fRead:~~:1_closure;
         const Data.Type.Equality.$fRead:~~:_lexeme_closure;
         const Data.Type.Equality.$fRead:~~:4_closure;
         const Data.Type.Equality.$fRead:~~:_$creadsPrec_closure;
         const Data.Type.Equality.$fRead:~~:_$creadListPrec_closure;
         const Data.Type.Equality.$fRead:~~:_$creadList_closure;
         const Data.Type.Equality.$fRead:~~:_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:04.964030296 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:00:04.965383881 UTC

[section ""data" . Data.Type.Equality.$p1~_closure" {
     Data.Type.Equality.$p1~_closure:
         const Data.Type.Equality.$p1~_info;
 },
 Data.Type.Equality.$p1~_entry() //  [R2]
         { info_tbl: [(c586l,
                       label: Data.Type.Equality.$p1~_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c586l: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:04.968878349 UTC

[section ""data" . Data.Type.Equality.testEquality_closure" {
     Data.Type.Equality.testEquality_closure:
         const Data.Type.Equality.testEquality_info;
 },
 Data.Type.Equality.testEquality_entry() //  [R2]
         { info_tbl: [(c586y,
                       label: Data.Type.Equality.testEquality_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c586y: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:04.972152337 UTC

[section ""data" . Data.Type.Equality.$WHRefl_closure" {
     Data.Type.Equality.$WHRefl_closure:
         const Data.Type.Equality.HRefl_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:04.973729124 UTC

[section ""data" . Data.Type.Equality.$WRefl_closure" {
     Data.Type.Equality.$WRefl_closure:
         const Data.Type.Equality.Refl_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:04.975662141 UTC

[section ""data" . Data.Type.Equality.$f~kab_$cp1~_closure" {
     Data.Type.Equality.$f~kab_$cp1~_closure:
         const Data.Type.Equality.$f~kab_$cp1~_info;
 },
 Data.Type.Equality.$f~kab_$cp1~_entry() //  [R2]
         { info_tbl: [(c586N,
                       label: Data.Type.Equality.$f~kab_$cp1~_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c586N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c586O; else goto c586P;
       c586O: // global
           R2 = R2;
           R1 = Data.Type.Equality.$f~kab_$cp1~_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c586P: // global
           I64[Sp - 16] = block_c586L_info;
           _s580X::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s580X::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c586L() //  []
         { info_tbl: [(c586L,
                       label: block_c586L_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c586L: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:04.98099163 UTC

[section ""data" . Data.Type.Equality.$f~kab_closure" {
     Data.Type.Equality.$f~kab_closure:
         const Data.Type.Equality.$f~kab_info;
 },
 Data.Type.Equality.$f~kab_entry() //  [R2]
         { info_tbl: [(c5876,
                       label: Data.Type.Equality.$f~kab_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c5876: // global
           R2 = R2;
           call Data.Type.Equality.$f~kab_$cp1~_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:04.984277313 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:3_closure" {
     Data.Type.Equality.$fEnum:~:3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:04.986308296 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$cfromEnum_closure" {
     Data.Type.Equality.$fEnum:~:_$cfromEnum_closure:
         const Data.Type.Equality.$fEnum:~:_$cfromEnum_info;
 },
 Data.Type.Equality.$fEnum:~:_$cfromEnum_entry() //  [R2, R3]
         { info_tbl: [(c587n,
                       label: Data.Type.Equality.$fEnum:~:_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c587n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c587o; else goto c587p;
       c587o: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$cfromEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c587p: // global
           I64[Sp - 16] = block_c587i_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c587i() //  []
         { info_tbl: [(c587i,
                       label: block_c587i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c587i: // global
           _s580Z::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c587k_info;
           R1 = _s580Z::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u587u; else goto c587l;
       u587u: // global
           call _c587k() args: 0, res: 0, upd: 0;
       c587l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c587k() //  []
         { info_tbl: [(c587k,
                       label: block_c587k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c587k: // global
           R1 = Data.Type.Equality.$fEnum:~:3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:04.993985978 UTC

[section ""cstring" . lvl_r5689_bytes" {
     lvl_r5689_bytes:
         I8[] [68,97,116,97,46,84,121,112,101,46,69,113,117,97,108,105,116,121,46,116,111,69,110,117,109,58,32,98,97,100,32,97,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:04.996125903 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:1_closure" {
     Data.Type.Equality.$fEnum:~:1_closure:
         const Data.Type.Equality.$fEnum:~:1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:1_entry() //  [R1]
         { info_tbl: [(c587T,
                       label: Data.Type.Equality.$fEnum:~:1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c587T: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c587U; else goto c587V;
       c587U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c587V: // global
           (_c587O::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c587O::I64 == 0) goto c587Q; else goto c587P;
       c587Q: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c587P: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c587O::I64;
           I64[Sp - 24] = block_c587R_info;
           R2 = lvl_r5689_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c587R() //  [R1]
         { info_tbl: [(c587R,
                       label: block_c587R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c587R: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.003212247 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$ctoEnum_closure" {
     Data.Type.Equality.$fEnum:~:_$ctoEnum_closure:
         const Data.Type.Equality.$fEnum:~:_$ctoEnum_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$ctoEnum_entry() //  [R2, R3]
         { info_tbl: [(c588l,
                       label: Data.Type.Equality.$fEnum:~:_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c588l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c588m; else goto c588n;
       c588m: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$ctoEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c588n: // global
           I64[Sp - 16] = block_c588g_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c588g() //  []
         { info_tbl: [(c588g,
                       label: block_c588g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c588g: // global
           _s5813::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c588i_info;
           R1 = _s5813::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u588w; else goto c588j;
       u588w: // global
           call _c588i(R1) args: 0, res: 0, upd: 0;
       c588j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c588i() //  [R1]
         { info_tbl: [(c588i,
                       label: block_c588i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c588i: // global
           if (I64[R1 + 7] == 0) goto c588v; else goto c588u;
       c588v: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c588u: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.013478507 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$csucc_closure" {
     Data.Type.Equality.$fEnum:~:_$csucc_closure:
         const Data.Type.Equality.$fEnum:~:_$csucc_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$csucc_entry() //  [R2, R3]
         { info_tbl: [(c588V,
                       label: Data.Type.Equality.$fEnum:~:_$csucc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c588V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c588W; else goto c588X;
       c588W: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$csucc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c588X: // global
           I64[Sp - 16] = block_c588R_info;
           _s5817::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s5817::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c588R() //  []
         { info_tbl: [(c588R,
                       label: block_c588R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c588R: // global
           _s5817::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c588T_info;
           R2 = _s5817::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c588T() //  []
         { info_tbl: [(c588T,
                       label: block_c588T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c588T: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.025674876 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromTo_closure" {
     Data.Type.Equality.$w$cenumFromTo_closure:
         const Data.Type.Equality.$w$cenumFromTo_info;
         const 0;
 },
 sat_s581i_entry() //  [R1]
         { info_tbl: [(c589z,
                       label: sat_s581i_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c589z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c589A; else goto c589B;
       c589A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c589B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s581g::I64 = I64[R1 + 24];
           if (_s581g::I64 != 0) goto c589x; else goto c589y;
       c589x: // global
           R2 = _s581g::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s581c_entry(R2, R1) args: 24, res: 0, upd: 24;
       c589y: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s581f_entry() //  [R1]
         { info_tbl: [(c589M,
                       label: sat_s581f_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c589M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c589N; else goto c589O;
       c589N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c589O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c589L; else goto c589K;
       c589L: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c589K: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s581c_entry() //  [R1, R2]
         { info_tbl: [(c589Q,
                       label: go_s581c_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c589Q: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c589U; else goto c589T;
       c589U: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c589T: // global
           I64[Hp - 72] = sat_s581i_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s581f_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c589V,
                       label: Data.Type.Equality.$w$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c589V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c589W; else goto c589X;
       c589W: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c589X: // global
           I64[Sp - 16] = block_c589i_info;
           _s5819::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s5819::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c589i() //  []
         { info_tbl: [(c589i,
                       label: block_c589i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c589i: // global
           _s5819::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c589k_info;
           R2 = _s5819::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c589k() //  []
         { info_tbl: [(c589k,
                       label: block_c589k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c589k: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c58a1; else goto c58a0;
       c58a1: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c58a0: // global
           I64[Hp - 8] = go_s581c_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call go_s581c_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.044510863 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$cenumFromTo_closure" {
     Data.Type.Equality.$fEnum:~:_$cenumFromTo_closure:
         const Data.Type.Equality.$fEnum:~:_$cenumFromTo_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$cenumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c58aK,
                       label: Data.Type.Equality.$fEnum:~:_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58aK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c58aO; else goto c58aP;
       c58aO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$cenumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c58aP: // global
           I64[Sp - 24] = block_c58aH_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u58aX; else goto c58aI;
       u58aX: // global
           call _c58aH(R1) args: 0, res: 0, upd: 0;
       c58aI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58aH() //  [R1]
         { info_tbl: [(c58aH,
                       label: block_c58aH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58aH: // global
           I64[Sp] = block_c58aN_info;
           _s581m::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s581m::P64;
           if (R1 & 7 != 0) goto u58aW; else goto c58aR;
       u58aW: // global
           call _c58aN(R1) args: 0, res: 0, upd: 0;
       c58aR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58aN() //  [R1]
         { info_tbl: [(c58aN,
                       label: block_c58aN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58aN: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromTo_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.052350958 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:2_closure" {
     Data.Type.Equality.$fEnum:~:2_closure:
         const Data.Type.Equality.$fEnum:~:2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:2_entry() //  [R1]
         { info_tbl: [(c58bj,
                       label: Data.Type.Equality.$fEnum:~:2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58bj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58bk; else goto c58bl;
       c58bk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58bl: // global
           (_c58bg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c58bg::I64 == 0) goto c58bi; else goto c58bh;
       c58bi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c58bh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c58bg::I64;
           R3 = 0;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.Enum.efdInt_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.057073297 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromThen_closure" {
     Data.Type.Equality.$w$cenumFromThen_closure:
         const Data.Type.Equality.$w$cenumFromThen_info;
         const 0;
 },
 sat_s581r_entry() //  [R1, R2]
         { info_tbl: [(c58bH,
                       label: sat_s581r_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58bH: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$ctoEnum_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFromThen_entry() //  [R2, R3, R4]
         { info_tbl: [(c58bK,
                       label: Data.Type.Equality.$w$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58bK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58bL; else goto c58bM;
       c58bL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c58bM: // global
           I64[Sp - 16] = block_c58by_info;
           _s581o::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s581o::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58by() //  []
         { info_tbl: [(c58by,
                       label: block_c58by_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58by: // global
           I64[Sp] = block_c58bA_info;
           R2 = P64[Sp + 8];
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58bA() //  []
         { info_tbl: [(c58bA,
                       label: block_c58bA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58bA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c58bQ; else goto c58bP;
       c58bQ: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c58bP: // global
           I64[Hp - 8] = sat_s581r_info;
           P64[Hp] = P64[Sp + 8];
           R3 = Data.Type.Equality.$fEnum:~:2_closure;
           R2 = Hp - 7;
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.067195057 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$cenumFromThen_closure" {
     Data.Type.Equality.$fEnum:~:_$cenumFromThen_closure:
         const Data.Type.Equality.$fEnum:~:_$cenumFromThen_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$cenumFromThen_entry() //  [R2, R3,
                                                          R4]
         { info_tbl: [(c58cg,
                       label: Data.Type.Equality.$fEnum:~:_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58cg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c58ck; else goto c58cl;
       c58ck: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$cenumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c58cl: // global
           I64[Sp - 24] = block_c58cd_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u58ct; else goto c58ce;
       u58ct: // global
           call _c58cd(R1) args: 0, res: 0, upd: 0;
       c58ce: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58cd() //  [R1]
         { info_tbl: [(c58cd,
                       label: block_c58cd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58cd: // global
           I64[Sp] = block_c58cj_info;
           _s581v::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s581v::P64;
           if (R1 & 7 != 0) goto u58cs; else goto c58cn;
       u58cs: // global
           call _c58cj(R1) args: 0, res: 0, upd: 0;
       c58cn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58cj() //  [R1]
         { info_tbl: [(c58cj,
                       label: block_c58cj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58cj: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromThen_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.080073175 UTC

[section ""data" . Data.Type.Equality.$w$cenumFrom_closure" {
     Data.Type.Equality.$w$cenumFrom_closure:
         const Data.Type.Equality.$w$cenumFrom_info;
         const 0;
 },
 sat_s581F_entry() //  [R1]
         { info_tbl: [(c58d4,
                       label: sat_s581F_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58d4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58d5; else goto c58d6;
       c58d5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58d6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s581D::I64 = I64[R1 + 24];
           if (_s581D::I64 != 9223372036854775807) goto c58d2; else goto c58d3;
       c58d2: // global
           R2 = _s581D::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s581z_entry(R2, R1) args: 24, res: 0, upd: 24;
       c58d3: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s581C_entry() //  [R1]
         { info_tbl: [(c58dh,
                       label: sat_s581C_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58dh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58di; else goto c58dj;
       c58di: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58dj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c58dg; else goto c58df;
       c58dg: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c58df: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s581z_entry() //  [R1, R2]
         { info_tbl: [(c58dl,
                       label: go_s581z_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58dl: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c58dp; else goto c58do;
       c58dp: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58do: // global
           I64[Hp - 72] = sat_s581F_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s581C_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFrom_entry() //  [R2, R3]
         { info_tbl: [(c58dq,
                       label: Data.Type.Equality.$w$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58dq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58dr; else goto c58ds;
       c58dr: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58ds: // global
           I64[Sp - 16] = block_c58cN_info;
           _s581x::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s581x::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58cN() //  []
         { info_tbl: [(c58cN,
                       label: block_c58cN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58cN: // global
           _s581x::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58cP_info;
           R2 = _s581x::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58cP() //  []
         { info_tbl: [(c58cP,
                       label: block_c58cP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58cP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c58dw; else goto c58dv;
       c58dw: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c58dv: // global
           I64[Hp - 8] = go_s581z_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call go_s581z_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.103129398 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$cenumFrom_closure" {
     Data.Type.Equality.$fEnum:~:_$cenumFrom_closure:
         const Data.Type.Equality.$fEnum:~:_$cenumFrom_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$cenumFrom_entry() //  [R2, R3]
         { info_tbl: [(c58eg,
                       label: Data.Type.Equality.$fEnum:~:_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58eg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58eh; else goto c58ei;
       c58eh: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$cenumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58ei: // global
           I64[Sp - 16] = block_c58ed_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58em; else goto c58ee;
       u58em: // global
           call _c58ed(R1) args: 0, res: 0, upd: 0;
       c58ee: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58ed() //  [R1]
         { info_tbl: [(c58ed,
                       label: block_c58ed_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58ed: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Type.Equality.$w$cenumFrom_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.114060915 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromThenTo_closure" {
     Data.Type.Equality.$w$cenumFromThenTo_closure:
         const Data.Type.Equality.$w$cenumFromThenTo_info;
         const 0;
 },
 sat_s581S_entry() //  [R1]
         { info_tbl: [(c58eV,
                       label: sat_s581S_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58eV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58eW; else goto c58eX;
       c58eW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58eX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s581N_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s581R_entry() //  [R1]
         { info_tbl: [(c58f6,
                       label: sat_s581R_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58f6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58f7; else goto c58f8;
       c58f7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58f8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c58f5; else goto c58f4;
       c58f5: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c58f4: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s581U_entry() //  [R1]
         { info_tbl: [(c58fi,
                       label: sat_s581U_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58fi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58fj; else goto c58fk;
       c58fj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58fk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c58fh; else goto c58fg;
       c58fh: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c58fg: // global
           R1 = Data.Type.Equality.$fEnum:~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s581N_entry() //  [R1, R2]
         { info_tbl: [(c58fo,
                       label: go_up_s581N_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58fo: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c58fs; else goto c58fr;
       c58fs: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58fr: // global
           if (%MO_S_Le_W64(R2, 0)) goto c58fm; else goto c58fn;
       c58fm: // global
           I64[Hp - 72] = sat_s581S_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s581R_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c58fn: // global
           I64[Hp - 72] = sat_s581U_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c58fu::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c58fu::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s581V_entry() //  [R1]
         { info_tbl: [(c58fv,
                       label: sat_s581V_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58fv: // global
           _s581V::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c58fw; else goto c58fx;
       c58fx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c58fz; else goto c58fy;
       c58fz: // global
           HpAlloc = 16;
           goto c58fw;
       c58fw: // global
           R1 = _s581V::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58fy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s581V::P64;
           I64[Hp - 8] = go_up_s581N_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call go_up_s581N_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$w$cenumFromThenTo_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c58fA,
                       label: Data.Type.Equality.$w$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58fA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58fB; else goto c58fC;
       c58fB: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c58fC: // global
           I64[Sp - 16] = block_c58eB_info;
           _s581J::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s581J::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58eB() //  []
         { info_tbl: [(c58eB,
                       label: block_c58eB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58eB: // global
           _s581J::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58eD_info;
           R2 = _s581J::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58eD() //  []
         { info_tbl: [(c58eD,
                       label: block_c58eD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58eD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c58fG; else goto c58fF;
       c58fG: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c58fF: // global
           I64[Hp - 8] = sat_s581V_info;
           R2 = Hp - 8;
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.143573156 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_closure" {
     Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_closure:
         const Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_entry() //  [R2, R3,
                                                            R4, R5]
         { info_tbl: [(c58gH,
                       label: Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58gH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c58gX; else goto c58gY;
       c58gX: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c58gY: // global
           I64[Sp - 32] = block_c58gE_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u58h6; else goto c58gF;
       u58h6: // global
           call _c58gE(R1) args: 0, res: 0, upd: 0;
       c58gF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58gE() //  [R1]
         { info_tbl: [(c58gE,
                       label: block_c58gE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58gE: // global
           I64[Sp] = block_c58gK_info;
           _s5820::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s5820::P64;
           if (R1 & 7 != 0) goto u58h5; else goto c58gL;
       u58h5: // global
           call _c58gK(R1) args: 0, res: 0, upd: 0;
       c58gL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58gK() //  [R1]
         { info_tbl: [(c58gK,
                       label: block_c58gK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58gK: // global
           I64[Sp] = block_c58gP_info;
           _s5821::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s5821::P64;
           if (R1 & 7 != 0) goto u58h7; else goto c58gQ;
       u58h7: // global
           call _c58gP(R1) args: 0, res: 0, upd: 0;
       c58gQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58gP() //  [R1]
         { info_tbl: [(c58gP,
                       label: block_c58gP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58gP: // global
           _s5821::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c58gU_info;
           R5 = R1;
           R4 = _s5821::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromThenTo_entry(R5,
                                                            R4,
                                                            R3,
                                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58gU() //  [R1, R2]
         { info_tbl: [(c58gU,
                       label: block_c58gU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58gU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c58h4; else goto c58h3;
       c58h4: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c58h3: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.162914284 UTC

[section ""data" . Data.Type.Equality.$fEnum:~:_closure" {
     Data.Type.Equality.$fEnum:~:_closure:
         const Data.Type.Equality.$fEnum:~:_info;
         const 0;
 },
 sat_s582e_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c58hH,
                       label: sat_s582e_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58hH: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_entry(R5,
                                                                    R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s582d_entry() //  [R1, R2, R3]
         { info_tbl: [(c58hP,
                       label: sat_s582d_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58hP: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fEnum:~:_$cenumFromTo_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s582c_entry() //  [R1, R2, R3]
         { info_tbl: [(c58hX,
                       label: sat_s582c_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58hX: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fEnum:~:_$cenumFromThen_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s582b_entry() //  [R1, R2]
         { info_tbl: [(c58i5,
                       label: sat_s582b_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58i5: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$cenumFrom_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s582a_entry() //  [R1, R2]
         { info_tbl: [(c58id,
                       label: sat_s582a_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58id: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$cfromEnum_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s5829_entry() //  [R1, R2]
         { info_tbl: [(c58il,
                       label: sat_s5829_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58il: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$ctoEnum_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s5828_entry() //  [R1, R2]
         { info_tbl: [(c58it,
                       label: sat_s5828_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58it: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$csucc_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s5827_entry() //  [R1, R2]
         { info_tbl: [(c58iB,
                       label: sat_s5827_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58iB: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~:_$csucc_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fEnum:~:_entry() //  [R2]
         { info_tbl: [(c58iF,
                       label: Data.Type.Equality.$fEnum:~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58iF: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto c58iJ; else goto c58iI;
       c58iJ: // global
           HpAlloc = 200;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58iI: // global
           I64[Hp - 192] = sat_s582e_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s582d_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s582c_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_s582b_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s582a_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s5829_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s5828_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s5827_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = Hp - 95;
           P64[Hp - 40] = Hp - 111;
           P64[Hp - 32] = Hp - 127;
           P64[Hp - 24] = Hp - 143;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 174;
           P64[Hp] = Hp - 189;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.190087637 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$cfromEnum_closure" {
     Data.Type.Equality.$fEnum:~~:_$cfromEnum_closure:
         const Data.Type.Equality.$fEnum:~~:_$cfromEnum_info;
 },
 Data.Type.Equality.$fEnum:~~:_$cfromEnum_entry() //  [R2, R3]
         { info_tbl: [(c58jD,
                       label: Data.Type.Equality.$fEnum:~~:_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58jD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58jE; else goto c58jF;
       c58jE: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$cfromEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58jF: // global
           I64[Sp - 16] = block_c58jy_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58jy() //  []
         { info_tbl: [(c58jy,
                       label: block_c58jy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58jy: // global
           _s582g::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58jA_info;
           R1 = _s582g::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u58jK; else goto c58jB;
       u58jK: // global
           call _c58jA() args: 0, res: 0, upd: 0;
       c58jB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58jA() //  []
         { info_tbl: [(c58jA,
                       label: block_c58jA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58jA: // global
           R1 = Data.Type.Equality.$fEnum:~:3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.201190805 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:1_closure" {
     Data.Type.Equality.$fEnum:~~:1_closure:
         const Data.Type.Equality.$fEnum:~~:1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:1_entry() //  [R1]
         { info_tbl: [(c58k8,
                       label: Data.Type.Equality.$fEnum:~~:1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58k8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c58k9; else goto c58ka;
       c58k9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58ka: // global
           (_c58k3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c58k3::I64 == 0) goto c58k5; else goto c58k4;
       c58k5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c58k4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c58k3::I64;
           I64[Sp - 24] = block_c58k6_info;
           R2 = lvl_r5689_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c58k6() //  [R1]
         { info_tbl: [(c58k6,
                       label: block_c58k6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58k6: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.210507712 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$ctoEnum_closure" {
     Data.Type.Equality.$fEnum:~~:_$ctoEnum_closure:
         const Data.Type.Equality.$fEnum:~~:_$ctoEnum_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$ctoEnum_entry() //  [R2, R3]
         { info_tbl: [(c58kz,
                       label: Data.Type.Equality.$fEnum:~~:_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58kz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58kA; else goto c58kB;
       c58kA: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$ctoEnum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58kB: // global
           I64[Sp - 16] = block_c58ku_info;
           R2 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58ku() //  []
         { info_tbl: [(c58ku,
                       label: block_c58ku_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58ku: // global
           _s582k::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58kw_info;
           R1 = _s582k::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u58kK; else goto c58kx;
       u58kK: // global
           call _c58kw(R1) args: 0, res: 0, upd: 0;
       c58kx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58kw() //  [R1]
         { info_tbl: [(c58kw,
                       label: block_c58kw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58kw: // global
           if (I64[R1 + 7] == 0) goto c58kJ; else goto c58kI;
       c58kJ: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c58kI: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.222753057 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$csucc_closure" {
     Data.Type.Equality.$fEnum:~~:_$csucc_closure:
         const Data.Type.Equality.$fEnum:~~:_$csucc_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$csucc_entry() //  [R2, R3]
         { info_tbl: [(c58l9,
                       label: Data.Type.Equality.$fEnum:~~:_$csucc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58l9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58la; else goto c58lb;
       c58la: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$csucc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58lb: // global
           I64[Sp - 16] = block_c58l5_info;
           _s582o::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s582o::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58l5() //  []
         { info_tbl: [(c58l5,
                       label: block_c58l5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58l5: // global
           _s582o::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58l7_info;
           R2 = _s582o::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58l7() //  []
         { info_tbl: [(c58l7,
                       label: block_c58l7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58l7: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.230560858 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromTo1_closure" {
     Data.Type.Equality.$w$cenumFromTo1_closure:
         const Data.Type.Equality.$w$cenumFromTo1_info;
         const 0;
 },
 sat_s582z_entry() //  [R1]
         { info_tbl: [(c58lN,
                       label: sat_s582z_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58lN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58lO; else goto c58lP;
       c58lO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58lP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s582x::I64 = I64[R1 + 24];
           if (_s582x::I64 != 0) goto c58lL; else goto c58lM;
       c58lL: // global
           R2 = _s582x::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s582t_entry(R2, R1) args: 24, res: 0, upd: 24;
       c58lM: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s582w_entry() //  [R1]
         { info_tbl: [(c58m0,
                       label: sat_s582w_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58m0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58m1; else goto c58m2;
       c58m1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58m2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c58lZ; else goto c58lY;
       c58lZ: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c58lY: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s582t_entry() //  [R1, R2]
         { info_tbl: [(c58m4,
                       label: go_s582t_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58m4: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c58m8; else goto c58m7;
       c58m8: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58m7: // global
           I64[Hp - 72] = sat_s582z_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s582w_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFromTo1_entry() //  [R2, R3, R4]
         { info_tbl: [(c58m9,
                       label: Data.Type.Equality.$w$cenumFromTo1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58m9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58ma; else goto c58mb;
       c58ma: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromTo1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c58mb: // global
           I64[Sp - 16] = block_c58lw_info;
           _s582q::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s582q::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58lw() //  []
         { info_tbl: [(c58lw,
                       label: block_c58lw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58lw: // global
           _s582q::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58ly_info;
           R2 = _s582q::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58ly() //  []
         { info_tbl: [(c58ly,
                       label: block_c58ly_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58ly: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c58mf; else goto c58me;
       c58mf: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c58me: // global
           I64[Hp - 8] = go_s582t_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call go_s582t_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.245464934 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$cenumFromTo_closure" {
     Data.Type.Equality.$fEnum:~~:_$cenumFromTo_closure:
         const Data.Type.Equality.$fEnum:~~:_$cenumFromTo_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$cenumFromTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c58mY,
                       label: Data.Type.Equality.$fEnum:~~:_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58mY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c58n2; else goto c58n3;
       c58n2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$cenumFromTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c58n3: // global
           I64[Sp - 24] = block_c58mV_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u58nb; else goto c58mW;
       u58nb: // global
           call _c58mV(R1) args: 0, res: 0, upd: 0;
       c58mW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58mV() //  [R1]
         { info_tbl: [(c58mV,
                       label: block_c58mV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58mV: // global
           I64[Sp] = block_c58n1_info;
           _s582D::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s582D::P64;
           if (R1 & 7 != 0) goto u58na; else goto c58n5;
       u58na: // global
           call _c58n1(R1) args: 0, res: 0, upd: 0;
       c58n5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58n1() //  [R1]
         { info_tbl: [(c58n1,
                       label: block_c58n1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58n1: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromTo1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.2548339 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromThen1_closure" {
     Data.Type.Equality.$w$cenumFromThen1_closure:
         const Data.Type.Equality.$w$cenumFromThen1_info;
         const 0;
 },
 sat_s582I_entry() //  [R1, R2]
         { info_tbl: [(c58nE,
                       label: sat_s582I_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58nE: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$ctoEnum_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFromThen1_entry() //  [R2, R3, R4]
         { info_tbl: [(c58nH,
                       label: Data.Type.Equality.$w$cenumFromThen1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58nH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58nI; else goto c58nJ;
       c58nI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromThen1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c58nJ: // global
           I64[Sp - 16] = block_c58nv_info;
           _s582F::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s582F::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58nv() //  []
         { info_tbl: [(c58nv,
                       label: block_c58nv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58nv: // global
           I64[Sp] = block_c58nx_info;
           R2 = P64[Sp + 8];
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58nx() //  []
         { info_tbl: [(c58nx,
                       label: block_c58nx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58nx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c58nN; else goto c58nM;
       c58nN: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c58nM: // global
           I64[Hp - 8] = sat_s582I_info;
           P64[Hp] = P64[Sp + 8];
           R3 = Data.Type.Equality.$fEnum:~:2_closure;
           R2 = Hp - 7;
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.266830554 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$cenumFromThen_closure" {
     Data.Type.Equality.$fEnum:~~:_$cenumFromThen_closure:
         const Data.Type.Equality.$fEnum:~~:_$cenumFromThen_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$cenumFromThen_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c58od,
                       label: Data.Type.Equality.$fEnum:~~:_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58od: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c58oh; else goto c58oi;
       c58oh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$cenumFromThen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c58oi: // global
           I64[Sp - 24] = block_c58oa_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u58oq; else goto c58ob;
       u58oq: // global
           call _c58oa(R1) args: 0, res: 0, upd: 0;
       c58ob: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58oa() //  [R1]
         { info_tbl: [(c58oa,
                       label: block_c58oa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58oa: // global
           I64[Sp] = block_c58og_info;
           _s582M::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s582M::P64;
           if (R1 & 7 != 0) goto u58op; else goto c58ok;
       u58op: // global
           call _c58og(R1) args: 0, res: 0, upd: 0;
       c58ok: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58og() //  [R1]
         { info_tbl: [(c58og,
                       label: block_c58og_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58og: // global
           R4 = R1;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromThen1_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.281121758 UTC

[section ""data" . Data.Type.Equality.$w$cenumFrom1_closure" {
     Data.Type.Equality.$w$cenumFrom1_closure:
         const Data.Type.Equality.$w$cenumFrom1_info;
         const 0;
 },
 sat_s582W_entry() //  [R1]
         { info_tbl: [(c58p1,
                       label: sat_s582W_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58p1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58p2; else goto c58p3;
       c58p2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58p3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s582U::I64 = I64[R1 + 24];
           if (_s582U::I64 != 9223372036854775807) goto c58oZ; else goto c58p0;
       c58oZ: // global
           R2 = _s582U::I64 + 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_s582Q_entry(R2, R1) args: 24, res: 0, upd: 24;
       c58p0: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s582T_entry() //  [R1]
         { info_tbl: [(c58pe,
                       label: sat_s582T_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58pe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58pf; else goto c58pg;
       c58pf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58pg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c58pd; else goto c58pc;
       c58pd: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c58pc: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_s582Q_entry() //  [R1, R2]
         { info_tbl: [(c58pi,
                       label: go_s582Q_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58pi: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c58pm; else goto c58pl;
       c58pm: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58pl: // global
           I64[Hp - 72] = sat_s582W_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s582T_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$w$cenumFrom1_entry() //  [R2, R3]
         { info_tbl: [(c58pn,
                       label: Data.Type.Equality.$w$cenumFrom1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58pn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58po; else goto c58pp;
       c58po: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFrom1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58pp: // global
           I64[Sp - 16] = block_c58oK_info;
           _s582O::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s582O::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58oK() //  []
         { info_tbl: [(c58oK,
                       label: block_c58oK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58oK: // global
           _s582O::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58oM_info;
           R2 = _s582O::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58oM() //  []
         { info_tbl: [(c58oM,
                       label: block_c58oM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58oM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c58pt; else goto c58ps;
       c58pt: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c58ps: // global
           I64[Hp - 8] = go_s582Q_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call go_s582Q_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.303425106 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$cenumFrom_closure" {
     Data.Type.Equality.$fEnum:~~:_$cenumFrom_closure:
         const Data.Type.Equality.$fEnum:~~:_$cenumFrom_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$cenumFrom_entry() //  [R2, R3]
         { info_tbl: [(c58qd,
                       label: Data.Type.Equality.$fEnum:~~:_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58qd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58qe; else goto c58qf;
       c58qe: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$cenumFrom_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58qf: // global
           I64[Sp - 16] = block_c58qa_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58qj; else goto c58qb;
       u58qj: // global
           call _c58qa(R1) args: 0, res: 0, upd: 0;
       c58qb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58qa() //  [R1]
         { info_tbl: [(c58qa,
                       label: block_c58qa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58qa: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Type.Equality.$w$cenumFrom1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.314063991 UTC

[section ""data" . Data.Type.Equality.$w$cenumFromThenTo1_closure" {
     Data.Type.Equality.$w$cenumFromThenTo1_closure:
         const Data.Type.Equality.$w$cenumFromThenTo1_info;
         const 0;
 },
 sat_s5839_entry() //  [R1]
         { info_tbl: [(c58qS,
                       label: sat_s5839_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58qS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58qT; else goto c58qU;
       c58qT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58qU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_s5834_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s5838_entry() //  [R1]
         { info_tbl: [(c58r3,
                       label: sat_s5838_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58r3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58r4; else goto c58r5;
       c58r4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58r5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c58r2; else goto c58r1;
       c58r2: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c58r1: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s583b_entry() //  [R1]
         { info_tbl: [(c58rf,
                       label: sat_s583b_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58rf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58rg; else goto c58rh;
       c58rg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58rh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c58re; else goto c58rd;
       c58re: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c58rd: // global
           R1 = Data.Type.Equality.$fEnum:~~:1_closure;
           Sp = Sp - 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_s5834_entry() //  [R1, R2]
         { info_tbl: [(c58rl,
                       label: go_up_s5834_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58rl: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c58rp; else goto c58ro;
       c58rp: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58ro: // global
           if (%MO_S_Le_W64(R2, 0)) goto c58rj; else goto c58rk;
       c58rj: // global
           I64[Hp - 72] = sat_s5839_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s5838_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c58rk: // global
           I64[Hp - 72] = sat_s583b_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _c58rr::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _c58rr::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s583c_entry() //  [R1]
         { info_tbl: [(c58rs,
                       label: sat_s583c_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58rs: // global
           _s583c::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c58rt; else goto c58ru;
       c58ru: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c58rw; else goto c58rv;
       c58rw: // global
           HpAlloc = 16;
           goto c58rt;
       c58rt: // global
           R1 = _s583c::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58rv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s583c::P64;
           I64[Hp - 8] = go_up_s5834_info;
           R2 = 0;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call go_up_s5834_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$w$cenumFromThenTo1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c58rx,
                       label: Data.Type.Equality.$w$cenumFromThenTo1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58rx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58ry; else goto c58rz;
       c58ry: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$w$cenumFromThenTo1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c58rz: // global
           I64[Sp - 16] = block_c58qy_info;
           _s5830::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s5830::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58qy() //  []
         { info_tbl: [(c58qy,
                       label: block_c58qy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58qy: // global
           _s5830::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58qA_info;
           R2 = _s5830::P64;
           Sp = Sp + 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58qA() //  []
         { info_tbl: [(c58qA,
                       label: block_c58qA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58qA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c58rD; else goto c58rC;
       c58rD: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c58rC: // global
           I64[Hp - 8] = sat_s583c_info;
           R2 = Hp - 8;
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.337929244 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_closure" {
     Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_closure:
         const Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_info;
         const 0;
 },
 Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(c58sE,
                       label: Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58sE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c58sU; else goto c58sV;
       c58sU: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c58sV: // global
           I64[Sp - 32] = block_c58sB_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u58t3; else goto c58sC;
       u58t3: // global
           call _c58sB(R1) args: 0, res: 0, upd: 0;
       c58sC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58sB() //  [R1]
         { info_tbl: [(c58sB,
                       label: block_c58sB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58sB: // global
           I64[Sp] = block_c58sH_info;
           _s583h::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s583h::P64;
           if (R1 & 7 != 0) goto u58t2; else goto c58sI;
       u58t2: // global
           call _c58sH(R1) args: 0, res: 0, upd: 0;
       c58sI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58sH() //  [R1]
         { info_tbl: [(c58sH,
                       label: block_c58sH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58sH: // global
           I64[Sp] = block_c58sM_info;
           _s583i::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s583i::P64;
           if (R1 & 7 != 0) goto u58t4; else goto c58sN;
       u58t4: // global
           call _c58sM(R1) args: 0, res: 0, upd: 0;
       c58sN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58sM() //  [R1]
         { info_tbl: [(c58sM,
                       label: block_c58sM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58sM: // global
           _s583i::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_c58sR_info;
           R5 = R1;
           R4 = _s583i::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Type.Equality.$w$cenumFromThenTo1_entry(R5,
                                                             R4,
                                                             R3,
                                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58sR() //  [R1, R2]
         { info_tbl: [(c58sR,
                       label: block_c58sR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58sR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c58t1; else goto c58t0;
       c58t1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c58t0: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.350716326 UTC

[section ""data" . Data.Type.Equality.$fEnum:~~:_closure" {
     Data.Type.Equality.$fEnum:~~:_closure:
         const Data.Type.Equality.$fEnum:~~:_info;
         const 0;
 },
 sat_s583v_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c58tE,
                       label: sat_s583v_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58tE: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s583u_entry() //  [R1, R2, R3]
         { info_tbl: [(c58tM,
                       label: sat_s583u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58tM: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fEnum:~~:_$cenumFromTo_entry(R4,
                                                                 R3,
                                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s583t_entry() //  [R1, R2, R3]
         { info_tbl: [(c58tU,
                       label: sat_s583t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58tU: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fEnum:~~:_$cenumFromThen_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s583s_entry() //  [R1, R2]
         { info_tbl: [(c58u2,
                       label: sat_s583s_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58u2: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$cenumFrom_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s583r_entry() //  [R1, R2]
         { info_tbl: [(c58ua,
                       label: sat_s583r_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58ua: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$cfromEnum_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s583q_entry() //  [R1, R2]
         { info_tbl: [(c58ui,
                       label: sat_s583q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58ui: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$ctoEnum_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s583p_entry() //  [R1, R2]
         { info_tbl: [(c58uq,
                       label: sat_s583p_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58uq: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$csucc_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s583o_entry() //  [R1, R2]
         { info_tbl: [(c58uy,
                       label: sat_s583o_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58uy: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fEnum:~~:_$csucc_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fEnum:~~:_entry() //  [R2]
         { info_tbl: [(c58uC,
                       label: Data.Type.Equality.$fEnum:~~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58uC: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto c58uG; else goto c58uF;
       c58uG: // global
           HpAlloc = 200;
           R2 = R2;
           R1 = Data.Type.Equality.$fEnum:~~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58uF: // global
           I64[Hp - 192] = sat_s583v_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s583u_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s583t_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_s583s_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s583r_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s583q_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s583p_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s583o_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = Hp - 95;
           P64[Hp - 40] = Hp - 111;
           P64[Hp - 32] = Hp - 127;
           P64[Hp - 24] = Hp - 143;
           P64[Hp - 16] = Hp - 158;
           P64[Hp - 8] = Hp - 174;
           P64[Hp] = Hp - 189;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.371450315 UTC

[section ""data" . Data.Type.Equality.$fTestEqualityk:~:1_closure" {
     Data.Type.Equality.$fTestEqualityk:~:1_closure:
         const GHC.Base.Just_con_info;
         const Data.Type.Equality.$WRefl_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.3736524 UTC

[section ""data" . Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_closure" {
     Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_closure:
         const Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_info;
 },
 Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(c58vz,
                       label: Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58vz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58vD; else goto c58vE;
       c58vD: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58vE: // global
           I64[Sp - 16] = block_c58vw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58vM; else goto c58vx;
       u58vM: // global
           call _c58vw() args: 0, res: 0, upd: 0;
       c58vx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58vw() //  []
         { info_tbl: [(c58vw,
                       label: block_c58vw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58vw: // global
           _s583x::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58vC_info;
           R1 = _s583x::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u58vL; else goto c58vG;
       u58vL: // global
           call _c58vC() args: 0, res: 0, upd: 0;
       c58vG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58vC() //  []
         { info_tbl: [(c58vC,
                       label: block_c58vC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58vC: // global
           R1 = Data.Type.Equality.$fTestEqualityk:~:1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.381506914 UTC

[section ""data" . Data.Type.Equality.$fTestEqualityk:~:_closure" {
     Data.Type.Equality.$fTestEqualityk:~:_closure:
         const Data.Type.Equality.$fTestEqualityk:~:_info;
 },
 Data.Type.Equality.$fTestEqualityk:~:_entry() //  [R2, R3]
         { info_tbl: [(c58w7,
                       label: Data.Type.Equality.$fTestEqualityk:~:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58w7: // global
           R3 = R3;
           R2 = R2;
           call Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality_entry(R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.385351409 UTC

[section ""data" . Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_closure" {
     Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_closure:
         const Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_info;
 },
 Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_entry() //  [R2,
                                                                    R3]
         { info_tbl: [(c58wl,
                       label: Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58wl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58wp; else goto c58wq;
       c58wp: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58wq: // global
           I64[Sp - 16] = block_c58wi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58wy; else goto c58wj;
       u58wy: // global
           call _c58wi() args: 0, res: 0, upd: 0;
       c58wj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58wi() //  []
         { info_tbl: [(c58wi,
                       label: block_c58wi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58wi: // global
           _s583B::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58wo_info;
           R1 = _s583B::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u58wx; else goto c58ws;
       u58wx: // global
           call _c58wo() args: 0, res: 0, upd: 0;
       c58ws: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58wo() //  []
         { info_tbl: [(c58wo,
                       label: block_c58wo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58wo: // global
           R1 = Data.Type.Equality.$fTestEqualityk:~:1_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.392888309 UTC

[section ""data" . Data.Type.Equality.$fTestEqualityk:~~:_closure" {
     Data.Type.Equality.$fTestEqualityk:~~:_closure:
         const Data.Type.Equality.$fTestEqualityk:~~:_info;
 },
 Data.Type.Equality.$fTestEqualityk:~~:_entry() //  [R2, R3]
         { info_tbl: [(c58wT,
                       label: Data.Type.Equality.$fTestEqualityk:~~:_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58wT: // global
           R3 = R3;
           R2 = R2;
           call Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality_entry(R3,
                                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.396932512 UTC

[section ""data" . Data.Type.Equality.$fEq:~:_$c==_closure" {
     Data.Type.Equality.$fEq:~:_$c==_closure:
         const Data.Type.Equality.$fEq:~:_$c==_info;
 },
 Data.Type.Equality.$fEq:~:_$c==_entry() //  [R2, R3]
         { info_tbl: [(c58x7,
                       label: Data.Type.Equality.$fEq:~:_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58x7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58xb; else goto c58xc;
       c58xb: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEq:~:_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58xc: // global
           I64[Sp - 16] = block_c58x4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58xk; else goto c58x5;
       u58xk: // global
           call _c58x4() args: 0, res: 0, upd: 0;
       c58x5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58x4() //  []
         { info_tbl: [(c58x4,
                       label: block_c58x4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58x4: // global
           _s583F::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58xa_info;
           R1 = _s583F::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u58xj; else goto c58xe;
       u58xj: // global
           call _c58xa() args: 0, res: 0, upd: 0;
       c58xe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58xa() //  []
         { info_tbl: [(c58xa,
                       label: block_c58xa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58xa: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.407490788 UTC

[section ""data" . Data.Type.Equality.$fEq:~:_$c/=_closure" {
     Data.Type.Equality.$fEq:~:_$c/=_closure:
         const Data.Type.Equality.$fEq:~:_$c/=_info;
 },
 Data.Type.Equality.$fEq:~:_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c58xJ,
                       label: Data.Type.Equality.$fEq:~:_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58xJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58xN; else goto c58xO;
       c58xN: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEq:~:_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58xO: // global
           I64[Sp - 16] = block_c58xG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58xW; else goto c58xH;
       u58xW: // global
           call _c58xG() args: 0, res: 0, upd: 0;
       c58xH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58xG() //  []
         { info_tbl: [(c58xG,
                       label: block_c58xG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58xG: // global
           _s583J::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58xM_info;
           R1 = _s583J::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u58xV; else goto c58xQ;
       u58xV: // global
           call _c58xM() args: 0, res: 0, upd: 0;
       c58xQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58xM() //  []
         { info_tbl: [(c58xM,
                       label: block_c58xM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58xM: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.41799035 UTC

[section ""data" . Data.Type.Equality.$fEq:~:_closure" {
     Data.Type.Equality.$fEq:~:_closure:
         const GHC.Classes.C:Eq_con_info;
         const Data.Type.Equality.$fEq:~:_$c==_closure+2;
         const Data.Type.Equality.$fEq:~:_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.420332565 UTC

[section ""cstring" . Data.Type.Equality.$fRead:~:3_bytes" {
     Data.Type.Equality.$fRead:~:3_bytes:
         I8[] [82,101,102,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.422883018 UTC

[section ""data" . Data.Type.Equality.$fRead:~:2_closure" {
     Data.Type.Equality.$fRead:~:2_closure:
         const Data.Type.Equality.$fRead:~:2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Equality.$fRead:~:2_entry() //  [R1]
         { info_tbl: [(c58ym,
                       label: Data.Type.Equality.$fRead:~:2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58ym: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58yn; else goto c58yo;
       c58yn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58yo: // global
           (_c58yj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c58yj::I64 == 0) goto c58yl; else goto c58yk;
       c58yl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c58yk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c58yj::I64;
           R2 = Data.Type.Equality.$fRead:~:3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.427653995 UTC

[section ""data" . Data.Type.Equality.$fShow:~:_$cshowsPrec_closure" {
     Data.Type.Equality.$fShow:~:_$cshowsPrec_closure:
         const Data.Type.Equality.$fShow:~:_$cshowsPrec_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~:_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c58yE,
                       label: Data.Type.Equality.$fShow:~:_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58yE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58yF; else goto c58yG;
       c58yF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~:_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c58yG: // global
           I64[Sp - 16] = block_c58yB_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58yK; else goto c58yC;
       u58yK: // global
           call _c58yB() args: 0, res: 0, upd: 0;
       c58yC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58yB() //  []
         { info_tbl: [(c58yB,
                       label: block_c58yB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58yB: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~:2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.434097933 UTC

[section ""data" . Data.Type.Equality.$fShow:~:_$cshow_closure" {
     Data.Type.Equality.$fShow:~:_$cshow_closure:
         const Data.Type.Equality.$fShow:~:_$cshow_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~:_$cshow_entry() //  [R2]
         { info_tbl: [(c58z2,
                       label: Data.Type.Equality.$fShow:~:_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58z2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c58z3; else goto c58z4;
       c58z3: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~:_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58z4: // global
           I64[Sp - 8] = block_c58yZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u58z8; else goto c58z0;
       u58z8: // global
           call _c58yZ() args: 0, res: 0, upd: 0;
       c58z0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58yZ() //  []
         { info_tbl: [(c58yZ,
                       label: block_c58yZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58yZ: // global
           R1 = Data.Type.Equality.$fRead:~:2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.439809514 UTC

[section ""data" . Data.Type.Equality.$fShow:~:1_closure" {
     Data.Type.Equality.$fShow:~:1_closure:
         const Data.Type.Equality.$fShow:~:1_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~:1_entry() //  [R2, R3]
         { info_tbl: [(c58zr,
                       label: Data.Type.Equality.$fShow:~:1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58zr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58zs; else goto c58zt;
       c58zs: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~:1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58zt: // global
           I64[Sp - 16] = block_c58zo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58zx; else goto c58zp;
       u58zx: // global
           call _c58zo() args: 0, res: 0, upd: 0;
       c58zp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58zo() //  []
         { info_tbl: [(c58zo,
                       label: block_c58zo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58zo: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~:2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.44642706 UTC

[section ""data" . Data.Type.Equality.$fShow:~:_$cshowList_closure" {
     Data.Type.Equality.$fShow:~:_$cshowList_closure:
         const Data.Type.Equality.$fShow:~:_$cshowList_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~:_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c58zM,
                       label: Data.Type.Equality.$fShow:~:_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58zM: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Type.Equality.$fShow:~:1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.449741653 UTC

[section ""data" . Data.Type.Equality.$fShow:~:_closure" {
     Data.Type.Equality.$fShow:~:_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Type.Equality.$fShow:~:_$cshowsPrec_closure+3;
         const Data.Type.Equality.$fShow:~:_$cshow_closure+1;
         const Data.Type.Equality.$fShow:~:_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.451841932 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$c<_closure" {
     Data.Type.Equality.$fOrd:~:_$c<_closure:
         const Data.Type.Equality.$fOrd:~:_$c<_info;
 },
 Data.Type.Equality.$fOrd:~:_$c<_entry() //  [R2, R3]
         { info_tbl: [(c58A1,
                       label: Data.Type.Equality.$fOrd:~:_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58A1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58A5; else goto c58A6;
       c58A5: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58A6: // global
           I64[Sp - 16] = block_c58zY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58Ae; else goto c58zZ;
       u58Ae: // global
           call _c58zY() args: 0, res: 0, upd: 0;
       c58zZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58zY() //  []
         { info_tbl: [(c58zY,
                       label: block_c58zY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58zY: // global
           _s583Y::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58A4_info;
           R1 = _s583Y::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u58Ad; else goto c58A8;
       u58Ad: // global
           call _c58A4() args: 0, res: 0, upd: 0;
       c58A8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58A4() //  []
         { info_tbl: [(c58A4,
                       label: block_c58A4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58A4: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.459101789 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$ccompare_closure" {
     Data.Type.Equality.$fOrd:~:_$ccompare_closure:
         const Data.Type.Equality.$fOrd:~:_$ccompare_info;
 },
 Data.Type.Equality.$fOrd:~:_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c58AD,
                       label: Data.Type.Equality.$fOrd:~:_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58AD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58AH; else goto c58AI;
       c58AH: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58AI: // global
           I64[Sp - 16] = block_c58AA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58AQ; else goto c58AB;
       u58AQ: // global
           call _c58AA() args: 0, res: 0, upd: 0;
       c58AB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58AA() //  []
         { info_tbl: [(c58AA,
                       label: block_c58AA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58AA: // global
           _s5842::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58AG_info;
           R1 = _s5842::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u58AP; else goto c58AK;
       u58AP: // global
           call _c58AG() args: 0, res: 0, upd: 0;
       c58AK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58AG() //  []
         { info_tbl: [(c58AG,
                       label: block_c58AG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58AG: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.467234953 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$c<=_closure" {
     Data.Type.Equality.$fOrd:~:_$c<=_closure:
         const Data.Type.Equality.$fOrd:~:_$c<=_info;
 },
 Data.Type.Equality.$fOrd:~:_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c58Bf,
                       label: Data.Type.Equality.$fOrd:~:_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Bf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58Bj; else goto c58Bk;
       c58Bj: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58Bk: // global
           I64[Sp - 16] = block_c58Bc_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58Bs; else goto c58Bd;
       u58Bs: // global
           call _c58Bc() args: 0, res: 0, upd: 0;
       c58Bd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58Bc() //  []
         { info_tbl: [(c58Bc,
                       label: block_c58Bc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Bc: // global
           _s5845::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58Bi_info;
           R1 = _s5845::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u58Br; else goto c58Bm;
       u58Br: // global
           call _c58Bi() args: 0, res: 0, upd: 0;
       c58Bm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58Bi() //  []
         { info_tbl: [(c58Bi,
                       label: block_c58Bi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Bi: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.475110957 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$cmax_closure" {
     Data.Type.Equality.$fOrd:~:_$cmax_closure:
         const Data.Type.Equality.$fOrd:~:_$cmax_info;
 },
 Data.Type.Equality.$fOrd:~:_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c58BR,
                       label: Data.Type.Equality.$fOrd:~:_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58BR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58BS; else goto c58BT;
       c58BS: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58BT: // global
           I64[Sp - 16] = block_c58BO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58BX; else goto c58BP;
       u58BX: // global
           call _c58BO() args: 0, res: 0, upd: 0;
       c58BP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58BO() //  []
         { info_tbl: [(c58BO,
                       label: block_c58BO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58BO: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.481548488 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$c>_closure" {
     Data.Type.Equality.$fOrd:~:_$c>_closure:
         const Data.Type.Equality.$fOrd:~:_$c>_info;
 },
 Data.Type.Equality.$fOrd:~:_$c>_entry() //  [R2, R3]
         { info_tbl: [(c58Ch,
                       label: Data.Type.Equality.$fOrd:~:_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Ch: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58Cl; else goto c58Cm;
       c58Cl: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58Cm: // global
           I64[Sp - 16] = block_c58Ce_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58Cu; else goto c58Cf;
       u58Cu: // global
           call _c58Ce() args: 0, res: 0, upd: 0;
       c58Cf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58Ce() //  []
         { info_tbl: [(c58Ce,
                       label: block_c58Ce_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Ce: // global
           _s584c::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58Ck_info;
           R1 = _s584c::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u58Ct; else goto c58Co;
       u58Ct: // global
           call _c58Ck() args: 0, res: 0, upd: 0;
       c58Co: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58Ck() //  []
         { info_tbl: [(c58Ck,
                       label: block_c58Ck_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Ck: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.488568813 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_$cmin_closure" {
     Data.Type.Equality.$fOrd:~:_$cmin_closure:
         const Data.Type.Equality.$fOrd:~:_$cmin_info;
 },
 Data.Type.Equality.$fOrd:~:_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c58CT,
                       label: Data.Type.Equality.$fOrd:~:_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58CT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58CU; else goto c58CV;
       c58CU: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~:_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58CV: // global
           I64[Sp - 16] = block_c58CQ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58CZ; else goto c58CR;
       u58CZ: // global
           call _c58CQ() args: 0, res: 0, upd: 0;
       c58CR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58CQ() //  []
         { info_tbl: [(c58CQ,
                       label: block_c58CQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58CQ: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.494302501 UTC

[section ""data" . Data.Type.Equality.$fOrd:~:_closure" {
     Data.Type.Equality.$fOrd:~:_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Type.Equality.$fEq:~:_closure+1;
         const Data.Type.Equality.$fOrd:~:_$ccompare_closure+2;
         const Data.Type.Equality.$fOrd:~:_$c<_closure+2;
         const Data.Type.Equality.$fOrd:~:_$c<=_closure+2;
         const Data.Type.Equality.$fOrd:~:_$c>_closure+2;
         const Data.Type.Equality.$fEq:~:_$c==_closure+2;
         const Data.Type.Equality.$fOrd:~:_$cmax_closure+2;
         const Data.Type.Equality.$fOrd:~:_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.496171584 UTC

[section ""data" . Data.Type.Equality.$fRead:~:_lexeme_closure" {
     Data.Type.Equality.$fRead:~:_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Type.Equality.$fRead:~:2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.498343908 UTC

[section ""data" . Data.Type.Equality.$fRead:~:1_closure" {
     Data.Type.Equality.$fRead:~:1_closure:
         const Data.Type.Equality.$fRead:~:1_info;
         const 0;
 },
 sat_s584m_entry() //  [R1]
         { info_tbl: [(c58Dn,
                       label: sat_s584m_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Dn: // global
           R2 = Data.Type.Equality.$WRefl_closure+1;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~:1_entry() //  [R2, R3]
         { info_tbl: [(c58Dt,
                       label: Data.Type.Equality.$fRead:~:1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Dt: // global
           _s584k::P64 = R3;
           _s584j::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c58Du; else goto c58Dv;
       c58Dv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c58Dx; else goto c58Dw;
       c58Dx: // global
           HpAlloc = 16;
           goto c58Du;
       c58Du: // global
           R3 = _s584k::P64;
           R2 = _s584j::P64;
           R1 = Data.Type.Equality.$fRead:~:1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58Dw: // global
           I64[Hp - 8] = sat_s584m_info;
           P64[Hp] = _s584k::P64;
           I64[Sp - 8] = block_c58Dq_info;
           R3 = Hp - 7;
           R2 = Data.Type.Equality.$fRead:~:_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58Dq() //  [R1]
         { info_tbl: [(c58Dq,
                       label: block_c58Dq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Dq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c58DA; else goto c58Dz;
       c58DA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c58Dz: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.506346681 UTC

[section ""data" . Data.Type.Equality.$fRead:~:4_closure" {
     Data.Type.Equality.$fRead:~:4_closure:
         const Data.Type.Equality.$fRead:~:4_info;
         const 0;
 },
 Data.Type.Equality.$fRead:~:4_entry() //  [R2, R3, R4]
         { info_tbl: [(c58DW,
                       label: Data.Type.Equality.$fRead:~:4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58DW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c58DX; else goto c58DY;
       c58DX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~:4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c58DY: // global
           I64[Sp - 24] = block_c58DU_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58DU() //  []
         { info_tbl: [(c58DU,
                       label: block_c58DU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58DU: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~:1_closure+2;
           Sp = Sp + 24;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.51323018 UTC

[section ""data" . Data.Type.Equality.$fRead:~:_$creadsPrec_closure" {
     Data.Type.Equality.$fRead:~:_$creadsPrec_closure:
         const Data.Type.Equality.$fRead:~:_$creadsPrec_info;
         const 0;
 },
 sat_s584u_entry() //  [R1]
         { info_tbl: [(c58El,
                       label: sat_s584u_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58El: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c58Em; else goto c58En;
       c58Em: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58En: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c58Ej_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c58Ej() //  []
         { info_tbl: [(c58Ej,
                       label: block_c58Ej_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Ej: // global
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~:1_closure+2;
           Sp = Sp + 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fRead:~:_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c58Ep,
                       label: Data.Type.Equality.$fRead:~:_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Ep: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c58Eq; else goto c58Er;
       c58Eq: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~:_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58Er: // global
           I64[Sp - 24] = block_c58Ed_info;
           _s584s::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s584s::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58Ed() //  []
         { info_tbl: [(c58Ed,
                       label: block_c58Ed_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Ed: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c58Eu; else goto c58Et;
       c58Eu: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c58Et: // global
           I64[Hp - 24] = sat_s584u_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.525093771 UTC

[section ""data" . Data.Type.Equality.$fRead:~:_$creadListPrec_closure" {
     Data.Type.Equality.$fRead:~:_$creadListPrec_closure:
         const Data.Type.Equality.$fRead:~:_$creadListPrec_info;
         const 0;
 },
 sat_s584y_entry() //  [R1, R2, R3]
         { info_tbl: [(c58F6,
                       label: sat_s584y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58F6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c58F7; else goto c58F8;
       c58F7: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58F8: // global
           I64[Sp - 24] = block_c58F4_info;
           _s584w::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = _s584w::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58F4() //  []
         { info_tbl: [(c58F4,
                       label: block_c58F4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58F4: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~:1_closure+2;
           Sp = Sp + 24;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~:_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c58Fa,
                       label: Data.Type.Equality.$fRead:~:_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Fa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58Fb; else goto c58Fc;
       c58Fb: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~:_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58Fc: // global
           I64[Sp - 16] = block_c58EX_info;
           _s584v::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s584v::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58EX() //  []
         { info_tbl: [(c58EX,
                       label: block_c58EX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58EX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c58Ff; else goto c58Fe;
       c58Ff: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c58Fe: // global
           I64[Hp - 8] = sat_s584y_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 6;
           Sp = Sp + 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.535558617 UTC

[section ""data" . Data.Type.Equality.$fRead:~:_$creadList_closure" {
     Data.Type.Equality.$fRead:~:_$creadList_closure:
         const Data.Type.Equality.$fRead:~:_$creadList_info;
         const 0;
 },
 sat_s584C_entry() //  [R2, R3]
         { info_tbl: [(c58FQ,
                       label: sat_s584C_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58FQ: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Type.Equality.$fRead:~:1_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s584D_entry() //  [R1]
         { info_tbl: [(c58FT,
                       label: sat_s584D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58FT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c58FU; else goto c58FV;
       c58FU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58FV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c58FJ_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c58FJ() //  []
         { info_tbl: [(c58FJ,
                       label: block_c58FJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58FJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c58FY; else goto c58FX;
       c58FY: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c58FX: // global
           I64[Hp - 8] = sat_s584C_info;
           R2 = Hp - 6;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = GHC.Read.$fRead()7_closure;
           P64[Sp] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fRead:~:_$creadList_entry() //  [R2]
         { info_tbl: [(c58FZ,
                       label: Data.Type.Equality.$fRead:~:_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58FZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58G0; else goto c58G1;
       c58G0: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~:_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58G1: // global
           I64[Sp - 16] = block_c58FD_info;
           _s584z::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s584z::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58FD() //  []
         { info_tbl: [(c58FD,
                       label: block_c58FD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58FD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c58G4; else goto c58G3;
       c58G4: // global
           HpAlloc = 24;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c58G3: // global
           I64[Hp - 16] = sat_s584D_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.548368887 UTC

[section ""data" . Data.Type.Equality.$fRead:~:_closure" {
     Data.Type.Equality.$fRead:~:_closure:
         const Data.Type.Equality.$fRead:~:_info;
         const 0;
 },
 sat_s584I_entry() //  [R1]
         { info_tbl: [(c58GG,
                       label: sat_s584I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58GG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58GH; else goto c58GI;
       c58GH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58GI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fRead:~:_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s584H_entry() //  [R1, R2, R3]
         { info_tbl: [(c58GO,
                       label: sat_s584H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58GO: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fRead:~:4_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s584G_entry() //  [R1]
         { info_tbl: [(c58GV,
                       label: sat_s584G_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58GV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58GW; else goto c58GX;
       c58GW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58GX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fRead:~:_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s584F_entry() //  [R1, R2]
         { info_tbl: [(c58H3,
                       label: sat_s584F_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58H3: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fRead:~:_$creadsPrec_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~:_entry() //  [R2]
         { info_tbl: [(c58H7,
                       label: Data.Type.Equality.$fRead:~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58H7: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c58Hb; else goto c58Ha;
       c58Hb: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58Ha: // global
           I64[Hp - 112] = sat_s584I_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s584H_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s584G_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s584F_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 112;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.561208654 UTC

[section ""data" . Data.Type.Equality.$fBounded:~:_$cmaxBound_closure" {
     Data.Type.Equality.$fBounded:~:_$cmaxBound_closure:
         const Data.Type.Equality.$fBounded:~:_$cmaxBound_info;
 },
 Data.Type.Equality.$fBounded:~:_$cmaxBound_entry() //  [R2]
         { info_tbl: [(c58HM,
                       label: Data.Type.Equality.$fBounded:~:_$cmaxBound_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58HM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c58HN; else goto c58HO;
       c58HN: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fBounded:~:_$cmaxBound_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58HO: // global
           I64[Sp - 8] = block_c58HK_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58HK() //  []
         { info_tbl: [(c58HK,
                       label: block_c58HK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58HK: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.567352268 UTC

[section ""data" . Data.Type.Equality.$fBounded:~:_closure" {
     Data.Type.Equality.$fBounded:~:_closure:
         const Data.Type.Equality.$fBounded:~:_info;
 },
 sat_s584M_entry() //  [R1]
         { info_tbl: [(c58I8,
                       label: sat_s584M_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58I8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58I9; else goto c58Ia;
       c58I9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58Ia: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fBounded:~:_$cmaxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s584L_entry() //  [R1]
         { info_tbl: [(c58If,
                       label: sat_s584L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58If: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58Ig; else goto c58Ih;
       c58Ig: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58Ih: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fBounded:~:_$cmaxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fBounded:~:_entry() //  [R2]
         { info_tbl: [(c58Ij,
                       label: Data.Type.Equality.$fBounded:~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Ij: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c58In; else goto c58Im;
       c58In: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Type.Equality.$fBounded:~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58Im: // global
           I64[Hp - 64] = sat_s584M_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s584L_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.575328946 UTC

[section ""data" . Data.Type.Equality.$fEq:~~:_$c==_closure" {
     Data.Type.Equality.$fEq:~~:_$c==_closure:
         const Data.Type.Equality.$fEq:~~:_$c==_info;
 },
 Data.Type.Equality.$fEq:~~:_$c==_entry() //  [R2, R3]
         { info_tbl: [(c58IP,
                       label: Data.Type.Equality.$fEq:~~:_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58IP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58IT; else goto c58IU;
       c58IT: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEq:~~:_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58IU: // global
           I64[Sp - 16] = block_c58IM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58J2; else goto c58IN;
       u58J2: // global
           call _c58IM() args: 0, res: 0, upd: 0;
       c58IN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58IM() //  []
         { info_tbl: [(c58IM,
                       label: block_c58IM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58IM: // global
           _s584O::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58IS_info;
           R1 = _s584O::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u58J1; else goto c58IW;
       u58J1: // global
           call _c58IS() args: 0, res: 0, upd: 0;
       c58IW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58IS() //  []
         { info_tbl: [(c58IS,
                       label: block_c58IS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58IS: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.582694794 UTC

[section ""data" . Data.Type.Equality.$fEq:~~:_$c/=_closure" {
     Data.Type.Equality.$fEq:~~:_$c/=_closure:
         const Data.Type.Equality.$fEq:~~:_$c/=_info;
 },
 Data.Type.Equality.$fEq:~~:_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c58Jr,
                       label: Data.Type.Equality.$fEq:~~:_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Jr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58Jv; else goto c58Jw;
       c58Jv: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fEq:~~:_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58Jw: // global
           I64[Sp - 16] = block_c58Jo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58JE; else goto c58Jp;
       u58JE: // global
           call _c58Jo() args: 0, res: 0, upd: 0;
       c58Jp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58Jo() //  []
         { info_tbl: [(c58Jo,
                       label: block_c58Jo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Jo: // global
           _s584S::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58Ju_info;
           R1 = _s584S::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u58JD; else goto c58Jy;
       u58JD: // global
           call _c58Ju() args: 0, res: 0, upd: 0;
       c58Jy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58Ju() //  []
         { info_tbl: [(c58Ju,
                       label: block_c58Ju_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Ju: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.590230641 UTC

[section ""data" . Data.Type.Equality.$fEq:~~:_closure" {
     Data.Type.Equality.$fEq:~~:_closure:
         const GHC.Classes.C:Eq_con_info;
         const Data.Type.Equality.$fEq:~~:_$c==_closure+2;
         const Data.Type.Equality.$fEq:~~:_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.592485469 UTC

[section ""cstring" . Data.Type.Equality.$fRead:~~:3_bytes" {
     Data.Type.Equality.$fRead:~~:3_bytes:
         I8[] [72,82,101,102,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.596366494 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:2_closure" {
     Data.Type.Equality.$fRead:~~:2_closure:
         const Data.Type.Equality.$fRead:~~:2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Type.Equality.$fRead:~~:2_entry() //  [R1]
         { info_tbl: [(c58K4,
                       label: Data.Type.Equality.$fRead:~~:2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58K4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58K5; else goto c58K6;
       c58K5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58K6: // global
           (_c58K1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c58K1::I64 == 0) goto c58K3; else goto c58K2;
       c58K3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c58K2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c58K1::I64;
           R2 = Data.Type.Equality.$fRead:~~:3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.602929536 UTC

[section ""data" . Data.Type.Equality.$fShow:~~:_$cshowsPrec_closure" {
     Data.Type.Equality.$fShow:~~:_$cshowsPrec_closure:
         const Data.Type.Equality.$fShow:~~:_$cshowsPrec_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~~:_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c58Km,
                       label: Data.Type.Equality.$fShow:~~:_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Km: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58Kn; else goto c58Ko;
       c58Kn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~~:_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c58Ko: // global
           I64[Sp - 16] = block_c58Kj_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58Ks; else goto c58Kk;
       u58Ks: // global
           call _c58Kj() args: 0, res: 0, upd: 0;
       c58Kk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58Kj() //  []
         { info_tbl: [(c58Kj,
                       label: block_c58Kj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Kj: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~~:2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.612951293 UTC

[section ""data" . Data.Type.Equality.$fShow:~~:_$cshow_closure" {
     Data.Type.Equality.$fShow:~~:_$cshow_closure:
         const Data.Type.Equality.$fShow:~~:_$cshow_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~~:_$cshow_entry() //  [R2]
         { info_tbl: [(c58KK,
                       label: Data.Type.Equality.$fShow:~~:_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58KK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c58KL; else goto c58KM;
       c58KL: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~~:_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58KM: // global
           I64[Sp - 8] = block_c58KH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u58KQ; else goto c58KI;
       u58KQ: // global
           call _c58KH() args: 0, res: 0, upd: 0;
       c58KI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58KH() //  []
         { info_tbl: [(c58KH,
                       label: block_c58KH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58KH: // global
           R1 = Data.Type.Equality.$fRead:~~:2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.622554873 UTC

[section ""data" . Data.Type.Equality.$fShow:~~:1_closure" {
     Data.Type.Equality.$fShow:~~:1_closure:
         const Data.Type.Equality.$fShow:~~:1_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~~:1_entry() //  [R2, R3]
         { info_tbl: [(c58L9,
                       label: Data.Type.Equality.$fShow:~~:1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58L9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58La; else goto c58Lb;
       c58La: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fShow:~~:1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58Lb: // global
           I64[Sp - 16] = block_c58L6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58Lf; else goto c58L7;
       u58Lf: // global
           call _c58L6() args: 0, res: 0, upd: 0;
       c58L7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58L6() //  []
         { info_tbl: [(c58L6,
                       label: block_c58L6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58L6: // global
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~~:2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.629555615 UTC

[section ""data" . Data.Type.Equality.$fShow:~~:_$cshowList_closure" {
     Data.Type.Equality.$fShow:~~:_$cshowList_closure:
         const Data.Type.Equality.$fShow:~~:_$cshowList_info;
         const 0;
 },
 Data.Type.Equality.$fShow:~~:_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c58Lu,
                       label: Data.Type.Equality.$fShow:~~:_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Lu: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Type.Equality.$fShow:~~:1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.633141641 UTC

[section ""data" . Data.Type.Equality.$fShow:~~:_closure" {
     Data.Type.Equality.$fShow:~~:_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Type.Equality.$fShow:~~:_$cshowsPrec_closure+3;
         const Data.Type.Equality.$fShow:~~:_$cshow_closure+1;
         const Data.Type.Equality.$fShow:~~:_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.635458366 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$c<_closure" {
     Data.Type.Equality.$fOrd:~~:_$c<_closure:
         const Data.Type.Equality.$fOrd:~~:_$c<_info;
 },
 Data.Type.Equality.$fOrd:~~:_$c<_entry() //  [R2, R3]
         { info_tbl: [(c58LJ,
                       label: Data.Type.Equality.$fOrd:~~:_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58LJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58LN; else goto c58LO;
       c58LN: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58LO: // global
           I64[Sp - 16] = block_c58LG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58LW; else goto c58LH;
       u58LW: // global
           call _c58LG() args: 0, res: 0, upd: 0;
       c58LH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58LG() //  []
         { info_tbl: [(c58LG,
                       label: block_c58LG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58LG: // global
           _s5857::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58LM_info;
           R1 = _s5857::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u58LV; else goto c58LQ;
       u58LV: // global
           call _c58LM() args: 0, res: 0, upd: 0;
       c58LQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58LM() //  []
         { info_tbl: [(c58LM,
                       label: block_c58LM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58LM: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.644237437 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$ccompare_closure" {
     Data.Type.Equality.$fOrd:~~:_$ccompare_closure:
         const Data.Type.Equality.$fOrd:~~:_$ccompare_info;
 },
 Data.Type.Equality.$fOrd:~~:_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c58Ml,
                       label: Data.Type.Equality.$fOrd:~~:_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Ml: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58Mp; else goto c58Mq;
       c58Mp: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58Mq: // global
           I64[Sp - 16] = block_c58Mi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58My; else goto c58Mj;
       u58My: // global
           call _c58Mi() args: 0, res: 0, upd: 0;
       c58Mj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58Mi() //  []
         { info_tbl: [(c58Mi,
                       label: block_c58Mi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Mi: // global
           _s585b::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58Mo_info;
           R1 = _s585b::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u58Mx; else goto c58Ms;
       u58Mx: // global
           call _c58Mo() args: 0, res: 0, upd: 0;
       c58Ms: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58Mo() //  []
         { info_tbl: [(c58Mo,
                       label: block_c58Mo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Mo: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.652134986 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$c<=_closure" {
     Data.Type.Equality.$fOrd:~~:_$c<=_closure:
         const Data.Type.Equality.$fOrd:~~:_$c<=_info;
 },
 Data.Type.Equality.$fOrd:~~:_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c58MX,
                       label: Data.Type.Equality.$fOrd:~~:_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58MX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58N1; else goto c58N2;
       c58N1: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58N2: // global
           I64[Sp - 16] = block_c58MU_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58Na; else goto c58MV;
       u58Na: // global
           call _c58MU() args: 0, res: 0, upd: 0;
       c58MV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58MU() //  []
         { info_tbl: [(c58MU,
                       label: block_c58MU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58MU: // global
           _s585e::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58N0_info;
           R1 = _s585e::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u58N9; else goto c58N4;
       u58N9: // global
           call _c58N0() args: 0, res: 0, upd: 0;
       c58N4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58N0() //  []
         { info_tbl: [(c58N0,
                       label: block_c58N0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58N0: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.660053476 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$cmax_closure" {
     Data.Type.Equality.$fOrd:~~:_$cmax_closure:
         const Data.Type.Equality.$fOrd:~~:_$cmax_info;
 },
 Data.Type.Equality.$fOrd:~~:_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c58Nz,
                       label: Data.Type.Equality.$fOrd:~~:_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Nz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58NA; else goto c58NB;
       c58NA: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58NB: // global
           I64[Sp - 16] = block_c58Nw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58NF; else goto c58Nx;
       u58NF: // global
           call _c58Nw() args: 0, res: 0, upd: 0;
       c58Nx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58Nw() //  []
         { info_tbl: [(c58Nw,
                       label: block_c58Nw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Nw: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.667174746 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$c>_closure" {
     Data.Type.Equality.$fOrd:~~:_$c>_closure:
         const Data.Type.Equality.$fOrd:~~:_$c>_info;
 },
 Data.Type.Equality.$fOrd:~~:_$c>_entry() //  [R2, R3]
         { info_tbl: [(c58NZ,
                       label: Data.Type.Equality.$fOrd:~~:_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58NZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58O3; else goto c58O4;
       c58O3: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58O4: // global
           I64[Sp - 16] = block_c58NW_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58Oc; else goto c58NX;
       u58Oc: // global
           call _c58NW() args: 0, res: 0, upd: 0;
       c58NX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58NW() //  []
         { info_tbl: [(c58NW,
                       label: block_c58NW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58NW: // global
           _s585l::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58O2_info;
           R1 = _s585l::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u58Ob; else goto c58O6;
       u58Ob: // global
           call _c58O2() args: 0, res: 0, upd: 0;
       c58O6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58O2() //  []
         { info_tbl: [(c58O2,
                       label: block_c58O2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58O2: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.674838743 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_$cmin_closure" {
     Data.Type.Equality.$fOrd:~~:_$cmin_closure:
         const Data.Type.Equality.$fOrd:~~:_$cmin_info;
 },
 Data.Type.Equality.$fOrd:~~:_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c58OB,
                       label: Data.Type.Equality.$fOrd:~~:_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58OB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58OC; else goto c58OD;
       c58OC: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fOrd:~~:_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58OD: // global
           I64[Sp - 16] = block_c58Oy_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58OH; else goto c58Oz;
       u58OH: // global
           call _c58Oy() args: 0, res: 0, upd: 0;
       c58Oz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58Oy() //  []
         { info_tbl: [(c58Oy,
                       label: block_c58Oy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Oy: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.680741631 UTC

[section ""data" . Data.Type.Equality.$fOrd:~~:_closure" {
     Data.Type.Equality.$fOrd:~~:_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Type.Equality.$fEq:~~:_closure+1;
         const Data.Type.Equality.$fOrd:~~:_$ccompare_closure+2;
         const Data.Type.Equality.$fOrd:~~:_$c<_closure+2;
         const Data.Type.Equality.$fOrd:~~:_$c<=_closure+2;
         const Data.Type.Equality.$fOrd:~~:_$c>_closure+2;
         const Data.Type.Equality.$fEq:~~:_$c==_closure+2;
         const Data.Type.Equality.$fOrd:~~:_$cmax_closure+2;
         const Data.Type.Equality.$fOrd:~~:_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.684995073 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:_lexeme_closure" {
     Data.Type.Equality.$fRead:~~:_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Type.Equality.$fRead:~~:2_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.688490034 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:1_closure" {
     Data.Type.Equality.$fRead:~~:1_closure:
         const Data.Type.Equality.$fRead:~~:1_info;
         const 0;
 },
 sat_s585v_entry() //  [R1]
         { info_tbl: [(c58P5,
                       label: sat_s585v_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58P5: // global
           R2 = Data.Type.Equality.$WHRefl_closure+1;
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~~:1_entry() //  [R2, R3]
         { info_tbl: [(c58Pb,
                       label: Data.Type.Equality.$fRead:~~:1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Pb: // global
           _s585t::P64 = R3;
           _s585s::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c58Pc; else goto c58Pd;
       c58Pd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c58Pf; else goto c58Pe;
       c58Pf: // global
           HpAlloc = 16;
           goto c58Pc;
       c58Pc: // global
           R3 = _s585t::P64;
           R2 = _s585s::P64;
           R1 = Data.Type.Equality.$fRead:~~:1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58Pe: // global
           I64[Hp - 8] = sat_s585v_info;
           P64[Hp] = _s585t::P64;
           I64[Sp - 8] = block_c58P8_info;
           R3 = Hp - 7;
           R2 = Data.Type.Equality.$fRead:~~:_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58P8() //  [R1]
         { info_tbl: [(c58P8,
                       label: block_c58P8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58P8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c58Pi; else goto c58Ph;
       c58Pi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c58Ph: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.700152977 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:4_closure" {
     Data.Type.Equality.$fRead:~~:4_closure:
         const Data.Type.Equality.$fRead:~~:4_info;
         const 0;
 },
 Data.Type.Equality.$fRead:~~:4_entry() //  [R2, R3, R4]
         { info_tbl: [(c58PE,
                       label: Data.Type.Equality.$fRead:~~:4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58PE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c58PF; else goto c58PG;
       c58PF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~~:4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c58PG: // global
           I64[Sp - 24] = block_c58PC_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58PC() //  []
         { info_tbl: [(c58PC,
                       label: block_c58PC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58PC: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~~:1_closure+2;
           Sp = Sp + 24;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.706605886 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:_$creadsPrec_closure" {
     Data.Type.Equality.$fRead:~~:_$creadsPrec_closure:
         const Data.Type.Equality.$fRead:~~:_$creadsPrec_info;
         const 0;
 },
 sat_s585D_entry() //  [R1]
         { info_tbl: [(c58Q3,
                       label: sat_s585D_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Q3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c58Q4; else goto c58Q5;
       c58Q4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58Q5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c58Q1_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c58Q1() //  []
         { info_tbl: [(c58Q1,
                       label: block_c58Q1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Q1: // global
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~~:1_closure+2;
           Sp = Sp + 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fRead:~~:_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c58Q7,
                       label: Data.Type.Equality.$fRead:~~:_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Q7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c58Q8; else goto c58Q9;
       c58Q8: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~~:_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58Q9: // global
           I64[Sp - 24] = block_c58PV_info;
           _s585B::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s585B::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58PV() //  []
         { info_tbl: [(c58PV,
                       label: block_c58PV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58PV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c58Qc; else goto c58Qb;
       c58Qc: // global
           HpAlloc = 32;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c58Qb: // global
           I64[Hp - 24] = sat_s585D_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.717145787 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:_$creadListPrec_closure" {
     Data.Type.Equality.$fRead:~~:_$creadListPrec_closure:
         const Data.Type.Equality.$fRead:~~:_$creadListPrec_info;
         const 0;
 },
 sat_s585H_entry() //  [R1, R2, R3]
         { info_tbl: [(c58QO,
                       label: sat_s585H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58QO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c58QP; else goto c58QQ;
       c58QP: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58QQ: // global
           I64[Sp - 24] = block_c58QM_info;
           _s585F::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = _s585F::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58QM() //  []
         { info_tbl: [(c58QM,
                       label: block_c58QM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58QM: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = Data.Type.Equality.$fRead:~~:1_closure+2;
           Sp = Sp + 24;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~~:_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c58QS,
                       label: Data.Type.Equality.$fRead:~~:_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58QS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58QT; else goto c58QU;
       c58QT: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~~:_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58QU: // global
           I64[Sp - 16] = block_c58QF_info;
           _s585E::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s585E::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58QF() //  []
         { info_tbl: [(c58QF,
                       label: block_c58QF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58QF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c58QX; else goto c58QW;
       c58QX: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c58QW: // global
           I64[Hp - 8] = sat_s585H_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 6;
           Sp = Sp + 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.728181092 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:_$creadList_closure" {
     Data.Type.Equality.$fRead:~~:_$creadList_closure:
         const Data.Type.Equality.$fRead:~~:_$creadList_info;
         const 0;
 },
 sat_s585L_entry() //  [R2, R3]
         { info_tbl: [(c58Ry,
                       label: sat_s585L_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Ry: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Type.Equality.$fRead:~~:1_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s585M_entry() //  [R1]
         { info_tbl: [(c58RB,
                       label: sat_s585M_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58RB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c58RC; else goto c58RD;
       c58RC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58RD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c58Rr_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c58Rr() //  []
         { info_tbl: [(c58Rr,
                       label: block_c58Rr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Rr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c58RG; else goto c58RF;
       c58RG: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c58RF: // global
           I64[Hp - 8] = sat_s585L_info;
           R2 = Hp - 6;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = GHC.Read.$fRead()7_closure;
           P64[Sp] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fRead:~~:_$creadList_entry() //  [R2]
         { info_tbl: [(c58RH,
                       label: Data.Type.Equality.$fRead:~~:_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58RH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58RI; else goto c58RJ;
       c58RI: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~~:_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58RJ: // global
           I64[Sp - 16] = block_c58Rl_info;
           _s585I::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s585I::P64;
           Sp = Sp - 16;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58Rl() //  []
         { info_tbl: [(c58Rl,
                       label: block_c58Rl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Rl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c58RM; else goto c58RL;
       c58RM: // global
           HpAlloc = 24;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c58RL: // global
           I64[Hp - 16] = sat_s585M_info;
           P64[Hp] = P64[Sp + 8];
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.741595531 UTC

[section ""data" . Data.Type.Equality.$fRead:~~:_closure" {
     Data.Type.Equality.$fRead:~~:_closure:
         const Data.Type.Equality.$fRead:~~:_info;
         const 0;
 },
 sat_s585R_entry() //  [R1]
         { info_tbl: [(c58So,
                       label: sat_s585R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58So: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58Sp; else goto c58Sq;
       c58Sp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58Sq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fRead:~~:_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s585Q_entry() //  [R1, R2, R3]
         { info_tbl: [(c58Sw,
                       label: sat_s585Q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Sw: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Type.Equality.$fRead:~~:4_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s585P_entry() //  [R1]
         { info_tbl: [(c58SD,
                       label: sat_s585P_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58SD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58SE; else goto c58SF;
       c58SE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58SF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fRead:~~:_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s585O_entry() //  [R1, R2]
         { info_tbl: [(c58SL,
                       label: sat_s585O_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58SL: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Type.Equality.$fRead:~~:_$creadsPrec_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Type.Equality.$fRead:~~:_entry() //  [R2]
         { info_tbl: [(c58SP,
                       label: Data.Type.Equality.$fRead:~~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58SP: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c58ST; else goto c58SS;
       c58ST: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Type.Equality.$fRead:~~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58SS: // global
           I64[Hp - 112] = sat_s585R_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s585Q_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s585P_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s585O_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 112;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.752992192 UTC

[section ""data" . Data.Type.Equality.$fBounded:~~:_$cmaxBound_closure" {
     Data.Type.Equality.$fBounded:~~:_$cmaxBound_closure:
         const Data.Type.Equality.$fBounded:~~:_$cmaxBound_info;
 },
 Data.Type.Equality.$fBounded:~~:_$cmaxBound_entry() //  [R2]
         { info_tbl: [(c58Tu,
                       label: Data.Type.Equality.$fBounded:~~:_$cmaxBound_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Tu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c58Tv; else goto c58Tw;
       c58Tv: // global
           R2 = R2;
           R1 = Data.Type.Equality.$fBounded:~~:_$cmaxBound_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58Tw: // global
           I64[Sp - 8] = block_c58Ts_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Types.heq_sel_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c58Ts() //  []
         { info_tbl: [(c58Ts,
                       label: block_c58Ts_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Ts: // global
           R1 = Data.Type.Equality.$WHRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.759147536 UTC

[section ""data" . Data.Type.Equality.$fBounded:~~:_closure" {
     Data.Type.Equality.$fBounded:~~:_closure:
         const Data.Type.Equality.$fBounded:~~:_info;
 },
 sat_s585V_entry() //  [R1]
         { info_tbl: [(c58TQ,
                       label: sat_s585V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58TQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58TR; else goto c58TS;
       c58TR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58TS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fBounded:~~:_$cmaxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s585U_entry() //  [R1]
         { info_tbl: [(c58TX,
                       label: sat_s585U_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58TX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58TY; else goto c58TZ;
       c58TY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c58TZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Type.Equality.$fBounded:~~:_$cmaxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Type.Equality.$fBounded:~~:_entry() //  [R2]
         { info_tbl: [(c58U1,
                       label: Data.Type.Equality.$fBounded:~~:_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58U1: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c58U5; else goto c58U4;
       c58U5: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Type.Equality.$fBounded:~~:_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58U4: // global
           I64[Hp - 64] = sat_s585V_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s585U_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.767114938 UTC

[section ""data" . Data.Type.Equality.sym_closure" {
     Data.Type.Equality.sym_closure:
         const Data.Type.Equality.sym_info;
 },
 Data.Type.Equality.sym_entry() //  [R2]
         { info_tbl: [(c58Ux,
                       label: Data.Type.Equality.sym_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Ux: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c58Uy; else goto c58Uz;
       c58Uy: // global
           R2 = R2;
           R1 = Data.Type.Equality.sym_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58Uz: // global
           I64[Sp - 8] = block_c58Uu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u58UD; else goto c58Uv;
       u58UD: // global
           call _c58Uu() args: 0, res: 0, upd: 0;
       c58Uv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58Uu() //  []
         { info_tbl: [(c58Uu,
                       label: block_c58Uu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Uu: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.773458532 UTC

[section ""data" . Data.Type.Equality.trans_closure" {
     Data.Type.Equality.trans_closure:
         const Data.Type.Equality.trans_info;
 },
 Data.Type.Equality.trans_entry() //  [R2, R3]
         { info_tbl: [(c58UW,
                       label: Data.Type.Equality.trans_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58UW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58V0; else goto c58V1;
       c58V0: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.trans_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58V1: // global
           I64[Sp - 16] = block_c58UT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58V9; else goto c58UU;
       u58V9: // global
           call _c58UT() args: 0, res: 0, upd: 0;
       c58UU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58UT() //  []
         { info_tbl: [(c58UT,
                       label: block_c58UT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58UT: // global
           _s585Z::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58UZ_info;
           R1 = _s585Z::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u58V8; else goto c58V3;
       u58V8: // global
           call _c58UZ() args: 0, res: 0, upd: 0;
       c58V3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58UZ() //  []
         { info_tbl: [(c58UZ,
                       label: block_c58UZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58UZ: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.781454805 UTC

[section ""data" . Data.Type.Equality.castWith_closure" {
     Data.Type.Equality.castWith_closure:
         const Data.Type.Equality.castWith_info;
 },
 Data.Type.Equality.castWith_entry() //  [R2, R3]
         { info_tbl: [(c58Vx,
                       label: Data.Type.Equality.castWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Vx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58Vy; else goto c58Vz;
       c58Vy: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.castWith_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58Vz: // global
           I64[Sp - 16] = block_c58Vu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58VD; else goto c58Vv;
       u58VD: // global
           call _c58Vu() args: 0, res: 0, upd: 0;
       c58Vv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58Vu() //  []
         { info_tbl: [(c58Vu,
                       label: block_c58Vu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Vu: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.787359483 UTC

[section ""data" . Data.Type.Equality.gcastWith_closure" {
     Data.Type.Equality.gcastWith_closure:
         const Data.Type.Equality.gcastWith_info;
 },
 Data.Type.Equality.gcastWith_entry() //  [R2, R3]
         { info_tbl: [(c58VV,
                       label: Data.Type.Equality.gcastWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58VV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58VZ; else goto c58W0;
       c58VZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.gcastWith_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58W0: // global
           I64[Sp - 16] = block_c58VS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58W4; else goto c58VT;
       u58W4: // global
           call _c58VS(R1) args: 0, res: 0, upd: 0;
       c58VT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58VS() //  [R1]
         { info_tbl: [(c58VS,
                       label: block_c58VS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58VS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c58W3; else goto c58W2;
       c58W3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c58W2: // global
           I64[Hp - 8] = GHC.Types.Eq#_con_info;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.794474554 UTC

[section ""data" . Data.Type.Equality.apply_closure" {
     Data.Type.Equality.apply_closure:
         const Data.Type.Equality.apply_info;
 },
 Data.Type.Equality.apply_entry() //  [R2, R3]
         { info_tbl: [(c58Wn,
                       label: Data.Type.Equality.apply_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Wn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c58Wr; else goto c58Ws;
       c58Wr: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Type.Equality.apply_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c58Ws: // global
           I64[Sp - 16] = block_c58Wk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u58WA; else goto c58Wl;
       u58WA: // global
           call _c58Wk() args: 0, res: 0, upd: 0;
       c58Wl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58Wk() //  []
         { info_tbl: [(c58Wk,
                       label: block_c58Wk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Wk: // global
           _s586a::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c58Wq_info;
           R1 = _s586a::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u58Wz; else goto c58Wu;
       u58Wz: // global
           call _c58Wq() args: 0, res: 0, upd: 0;
       c58Wu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58Wq() //  []
         { info_tbl: [(c58Wq,
                       label: block_c58Wq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Wq: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.805456449 UTC

[section ""data" . Data.Type.Equality.inner_closure" {
     Data.Type.Equality.inner_closure:
         const Data.Type.Equality.inner_info;
 },
 Data.Type.Equality.inner_entry() //  [R2]
         { info_tbl: [(c58WY,
                       label: Data.Type.Equality.inner_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58WY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c58WZ; else goto c58X0;
       c58WZ: // global
           R2 = R2;
           R1 = Data.Type.Equality.inner_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58X0: // global
           I64[Sp - 8] = block_c58WV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u58X4; else goto c58WW;
       u58X4: // global
           call _c58WV() args: 0, res: 0, upd: 0;
       c58WW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58WV() //  []
         { info_tbl: [(c58WV,
                       label: block_c58WV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58WV: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.813650293 UTC

[section ""data" . Data.Type.Equality.outer_closure" {
     Data.Type.Equality.outer_closure:
         const Data.Type.Equality.outer_info;
 },
 Data.Type.Equality.outer_entry() //  [R2]
         { info_tbl: [(c58Xn,
                       label: Data.Type.Equality.outer_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Xn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c58Xo; else goto c58Xp;
       c58Xo: // global
           R2 = R2;
           R1 = Data.Type.Equality.outer_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c58Xp: // global
           I64[Sp - 8] = block_c58Xk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u58Xt; else goto c58Xl;
       u58Xt: // global
           call _c58Xk() args: 0, res: 0, upd: 0;
       c58Xl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c58Xk() //  []
         { info_tbl: [(c58Xk,
                       label: block_c58Xk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Xk: // global
           R1 = Data.Type.Equality.$WRefl_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.821706876 UTC

[section ""cstring" . Data.Type.Equality.$trModule4_bytes" {
     Data.Type.Equality.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.824166386 UTC

[section ""data" . Data.Type.Equality.$trModule3_closure" {
     Data.Type.Equality.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.826745565 UTC

[section ""cstring" . Data.Type.Equality.$trModule2_bytes" {
     Data.Type.Equality.$trModule2_bytes:
         I8[] [68,97,116,97,46,84,121,112,101,46,69,113,117,97,108,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.829225981 UTC

[section ""data" . Data.Type.Equality.$trModule1_closure" {
     Data.Type.Equality.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.832277403 UTC

[section ""data" . Data.Type.Equality.$trModule_closure" {
     Data.Type.Equality.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Type.Equality.$trModule3_closure+1;
         const Data.Type.Equality.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.834865335 UTC

[section ""data" . $krep_r568a_closure" {
     $krep_r568a_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.837399657 UTC

[section ""data" . $krep1_r568b_closure" {
     $krep1_r568b_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.839874632 UTC

[section ""data" . $krep2_r568c_closure" {
     $krep2_r568c_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r568b_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.842333328 UTC

[section ""data" . $krep3_r568d_closure" {
     $krep3_r568d_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.84466258 UTC

[section ""data" . Data.Type.Equality.$tc:~~:1_closure" {
     Data.Type.Equality.$tc:~~:1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r568d_closure+2;
         const $krep2_r568c_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.847231358 UTC

[section ""data" . $krep4_r568e_closure" {
     $krep4_r568e_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r568d_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.850247615 UTC

[section ""data" . Data.Type.Equality.$tc:~:1_closure" {
     Data.Type.Equality.$tc:~:1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r568d_closure+2;
         const $krep4_r568e_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.852083264 UTC

[section ""data" . Data.Type.Equality.$tcTestEquality1_closure" {
     Data.Type.Equality.$tcTestEquality1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r568e_closure+4;
         const $krep_r568a_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.854432888 UTC

[section ""data" . $krep5_r568f_closure" {
     $krep5_r568f_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r568d_closure+2;
         const $krep_r568a_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.856150065 UTC

[section ""data" . Data.Type.Equality.$tc~1_closure" {
     Data.Type.Equality.$tc~1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r568d_closure+2;
         const $krep5_r568f_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.858288039 UTC

[section ""data" . $krep6_r568g_closure" {
     $krep6_r568g_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.859936534 UTC

[section ""data" . $krep7_r568h_closure" {
     $krep7_r568h_closure:
         const :_con_info;
         const $krep6_r568g_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.861667502 UTC

[section ""data" . $krep8_r568i_closure" {
     $krep8_r568i_closure:
         const :_con_info;
         const $krep1_r568b_closure+2;
         const $krep7_r568h_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.863418476 UTC

[section ""data" . $krep9_r568j_closure" {
     $krep9_r568j_closure:
         const :_con_info;
         const $krep3_r568d_closure+2;
         const $krep8_r568i_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.865140322 UTC

[section ""data" . $krep10_r568k_closure" {
     $krep10_r568k_closure:
         const :_con_info;
         const $krep3_r568d_closure+2;
         const $krep9_r568j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.866939021 UTC

[section ""data" . $krep11_r568l_closure" {
     $krep11_r568l_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc~~_closure;
         const $krep10_r568k_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.86869604 UTC

[section ""cstring" . Data.Type.Equality.$tc~3_bytes" {
     Data.Type.Equality.$tc~3_bytes:
         I8[] [126]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.870459117 UTC

[section ""data" . Data.Type.Equality.$tc~2_closure" {
     Data.Type.Equality.$tc~2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc~3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.872165948 UTC

[section ""data" . Data.Type.Equality.$tc~_closure" {
     Data.Type.Equality.$tc~_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc~2_closure+1;
         const Data.Type.Equality.$tc~1_closure+4;
         const 11470827771536267938;
         const 3625512399163125290;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.874096849 UTC

[section ""data" . $krep12_r568m_closure" {
     $krep12_r568m_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Type.Equality.$tc~_closure+1;
         const $krep9_r568j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.875760737 UTC

[section ""data" . Data.Type.Equality.$tc'C:~1_closure" {
     Data.Type.Equality.$tc'C:~1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r568l_closure+1;
         const $krep12_r568m_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.878849093 UTC

[section ""cstring" . Data.Type.Equality.$tc'C:~3_bytes" {
     Data.Type.Equality.$tc'C:~3_bytes:
         I8[] [39,67,58,126]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.880446457 UTC

[section ""data" . Data.Type.Equality.$tc'C:~2_closure" {
     Data.Type.Equality.$tc'C:~2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc'C:~3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.882241735 UTC

[section ""data" . Data.Type.Equality.$tc'C:~_closure" {
     Data.Type.Equality.$tc'C:~_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc'C:~2_closure+1;
         const Data.Type.Equality.$tc'C:~1_closure+4;
         const 6023002849810837484;
         const 5427525916893308990;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.884023739 UTC

[section ""cstring" . Data.Type.Equality.$tc:~:3_bytes" {
     Data.Type.Equality.$tc:~:3_bytes:
         I8[] [58,126,58]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.88592536 UTC

[section ""data" . Data.Type.Equality.$tc:~:2_closure" {
     Data.Type.Equality.$tc:~:2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc:~:3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.887597137 UTC

[section ""data" . Data.Type.Equality.$tc:~:_closure" {
     Data.Type.Equality.$tc:~:_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc:~:2_closure+1;
         const Data.Type.Equality.$tc:~:1_closure+4;
         const 10597498348876412676;
         const 16281320961088145472;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.889371675 UTC

[section ""data" . $krep13_r568n_closure" {
     $krep13_r568n_closure:
         const :_con_info;
         const $krep1_r568b_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.891046801 UTC

[section ""data" . $krep14_r568o_closure" {
     $krep14_r568o_closure:
         const :_con_info;
         const $krep1_r568b_closure+2;
         const $krep13_r568n_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.892757935 UTC

[section ""data" . $krep15_r568p_closure" {
     $krep15_r568p_closure:
         const :_con_info;
         const $krep3_r568d_closure+2;
         const $krep14_r568o_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.894594448 UTC

[section ""data" . Data.Type.Equality.$tc'Refl1_closure" {
     Data.Type.Equality.$tc'Refl1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Type.Equality.$tc:~:_closure+1;
         const $krep15_r568p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.896297841 UTC

[section ""cstring" . Data.Type.Equality.$tc'Refl3_bytes" {
     Data.Type.Equality.$tc'Refl3_bytes:
         I8[] [39,82,101,102,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.897980302 UTC

[section ""data" . Data.Type.Equality.$tc'Refl2_closure" {
     Data.Type.Equality.$tc'Refl2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc'Refl3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.899619623 UTC

[section ""data" . Data.Type.Equality.$tc'Refl_closure" {
     Data.Type.Equality.$tc'Refl_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc'Refl2_closure+1;
         const Data.Type.Equality.$tc'Refl1_closure+1;
         const 16680242040484769242;
         const 2864388906562808793;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.901557089 UTC

[section ""cstring" . Data.Type.Equality.$tc:~~:3_bytes" {
     Data.Type.Equality.$tc:~~:3_bytes:
         I8[] [58,126,126,58]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.903926448 UTC

[section ""data" . Data.Type.Equality.$tc:~~:2_closure" {
     Data.Type.Equality.$tc:~~:2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc:~~:3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.906611379 UTC

[section ""data" . Data.Type.Equality.$tc:~~:_closure" {
     Data.Type.Equality.$tc:~~:_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc:~~:2_closure+1;
         const Data.Type.Equality.$tc:~~:1_closure+4;
         const 4361259188665111259;
         const 11706467685470543992;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.908581072 UTC

[section ""data" . $krep16_r568q_closure" {
     $krep16_r568q_closure:
         const :_con_info;
         const $krep3_r568d_closure+2;
         const $krep15_r568p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.910379097 UTC

[section ""data" . Data.Type.Equality.$tc'HRefl1_closure" {
     Data.Type.Equality.$tc'HRefl1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Type.Equality.$tc:~~:_closure+1;
         const $krep16_r568q_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.912109733 UTC

[section ""cstring" . Data.Type.Equality.$tc'HRefl3_bytes" {
     Data.Type.Equality.$tc'HRefl3_bytes:
         I8[] [39,72,82,101,102,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.913806098 UTC

[section ""data" . Data.Type.Equality.$tc'HRefl2_closure" {
     Data.Type.Equality.$tc'HRefl2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tc'HRefl3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.915521582 UTC

[section ""data" . Data.Type.Equality.$tc'HRefl_closure" {
     Data.Type.Equality.$tc'HRefl_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tc'HRefl2_closure+1;
         const Data.Type.Equality.$tc'HRefl1_closure+1;
         const 4486133906173668740;
         const 6341741464738386857;
         const 2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.917348546 UTC

[section ""cstring" . Data.Type.Equality.$tcTestEquality3_bytes" {
     Data.Type.Equality.$tcTestEquality3_bytes:
         I8[] [84,101,115,116,69,113,117,97,108,105,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.919011787 UTC

[section ""data" . Data.Type.Equality.$tcTestEquality2_closure" {
     Data.Type.Equality.$tcTestEquality2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Type.Equality.$tcTestEquality3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.920719106 UTC

[section ""data" . Data.Type.Equality.$tcTestEquality_closure" {
     Data.Type.Equality.$tcTestEquality_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Type.Equality.$trModule_closure+1;
         const Data.Type.Equality.$tcTestEquality2_closure+1;
         const Data.Type.Equality.$tcTestEquality1_closure+4;
         const 2944680549948432194;
         const 17791533211054855448;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.922872712 UTC

[section ""data" . Data.Type.Equality.HRefl_closure" {
     Data.Type.Equality.HRefl_closure:
         const Data.Type.Equality.HRefl_info;
 },
 Data.Type.Equality.HRefl_entry() //  []
         { info_tbl: [(c58Yy,
                       label: Data.Type.Equality.HRefl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Yy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c58YC; else goto c58YB;
       c58YC: // global
           HpAlloc = 16;
           R1 = Data.Type.Equality.HRefl_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c58YB: // global
           I64[Hp - 8] = Data.Type.Equality.HRefl_con_info;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.92729688 UTC

[section ""data" . Data.Type.Equality.Refl_closure" {
     Data.Type.Equality.Refl_closure:
         const Data.Type.Equality.Refl_info;
 },
 Data.Type.Equality.Refl_entry() //  []
         { info_tbl: [(c58YO,
                       label: Data.Type.Equality.Refl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58YO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c58YS; else goto c58YR;
       c58YS: // global
           HpAlloc = 16;
           R1 = Data.Type.Equality.Refl_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c58YR: // global
           I64[Hp - 8] = Data.Type.Equality.Refl_con_info;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.931019987 UTC

[Data.Type.Equality.HRefl_con_entry() //  [R1]
         { info_tbl: [(c58YZ,
                       label: Data.Type.Equality.HRefl_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,84,121,112,101,46,69,113,117,97,108,105,116,121,46,72,82,101,102,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58YZ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.935069212 UTC

[Data.Type.Equality.Refl_con_entry() //  [R1]
         { info_tbl: [(c58Z6,
                       label: Data.Type.Equality.Refl_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,84,121,112,101,46,69,113,117,97,108,105,116,121,46,82,101,102,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c58Z6: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:00:05.938248442 UTC

[section ""relreadonly" . S587Z_srt" {
     S587Z_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Type.Equality.$fEnum:~:1_closure;
         const Data.Type.Equality.$fEnum:~:_$ctoEnum_closure;
         const Data.Type.Equality.$fEnum:~:_$csucc_closure;
         const Data.Type.Equality.$w$cenumFromTo_closure;
         const Data.Type.Equality.$fEnum:~:_$cenumFromTo_closure;
         const Data.Type.Equality.$w$cenumFromThen_closure;
         const Data.Type.Equality.$fEnum:~:2_closure;
         const Data.Type.Equality.$fEnum:~:_$cenumFromThen_closure;
         const Data.Type.Equality.$w$cenumFrom_closure;
         const Data.Type.Equality.$fEnum:~:_$cenumFrom_closure;
         const Data.Type.Equality.$w$cenumFromThenTo_closure;
         const Data.Type.Equality.$fEnum:~:_$cenumFromThenTo_closure;
         const Data.Type.Equality.$fEnum:~:_closure;
         const Data.Type.Equality.$fEnum:~~:1_closure;
         const Data.Type.Equality.$fEnum:~~:_$ctoEnum_closure;
         const Data.Type.Equality.$fEnum:~~:_$csucc_closure;
         const Data.Type.Equality.$w$cenumFromTo1_closure;
         const Data.Type.Equality.$fEnum:~~:_$cenumFromTo_closure;
         const Data.Type.Equality.$w$cenumFromThen1_closure;
         const Data.Type.Equality.$fEnum:~~:_$cenumFromThen_closure;
         const Data.Type.Equality.$w$cenumFrom1_closure;
         const Data.Type.Equality.$fEnum:~~:_$cenumFrom_closure;
         const Data.Type.Equality.$w$cenumFromThenTo1_closure;
         const Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo_closure;
         const Data.Type.Equality.$fEnum:~~:_closure;
         const Data.Type.Equality.$fRead:~:2_closure;
         const Data.Type.Equality.$fShow:~:_$cshowsPrec_closure;
         const Data.Type.Equality.$fShow:~:_$cshow_closure;
         const Data.Type.Equality.$fShow:~:1_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Type.Equality.$fRead:~:1_closure;
         const Data.Type.Equality.$fRead:~:_lexeme_closure;
         const GHC.Read.list3_closure;
         const Data.Type.Equality.$fRead:~:4_closure;
         const Data.Type.Equality.$fRead:~:_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Type.Equality.$fRead:~:_$creadListPrec_closure;
         const Data.Type.Equality.$fRead:~:_$creadList_closure;
         const Data.Type.Equality.$fRead:~:_closure;
         const Data.Type.Equality.$fRead:~~:2_closure;
         const Data.Type.Equality.$fShow:~~:_$cshowsPrec_closure;
         const Data.Type.Equality.$fShow:~~:_$cshow_closure;
         const Data.Type.Equality.$fShow:~~:1_closure;
         const Data.Type.Equality.$fRead:~~:1_closure;
         const Data.Type.Equality.$fRead:~~:_lexeme_closure;
         const Data.Type.Equality.$fRead:~~:4_closure;
         const Data.Type.Equality.$fRead:~~:_$creadsPrec_closure;
         const Data.Type.Equality.$fRead:~~:_$creadListPrec_closure;
         const Data.Type.Equality.$fRead:~~:_$creadList_closure;
         const Data.Type.Equality.$fRead:~~:_closure;
 }]

