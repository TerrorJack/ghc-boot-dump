
==================== Pre unarise: ====================
2018-03-16 16:00:06.167988317 UTC

Data.Type.Coercion.testCoercion [InlPrag=INLINE]
  :: forall k (f :: k -> *).
     Data.Type.Coercion.TestCoercion f =>
     forall (a :: k) (b :: k).
     f a -> f b -> GHC.Base.Maybe (Data.Type.Coercion.Coercion a b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_s59Br] v_s59Br;

lvl_r59Bb :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Type.Coercion.toEnum: bad argument"#;

Data.Type.Coercion.$fEnumCoercion1
  :: forall k (a :: k) (b :: k). Data.Type.Coercion.Coercion a b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_r59Bb of sat_s59Bs {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s59Bs;
        };

Data.Type.Coercion.$fEnumCoercion_$ctoEnum
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     GHC.Types.Int -> Data.Type.Coercion.Coercion a b
[GblId, Arity=2, Str=<L,U><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [$dCoercible_s59Bt ds_s59Bu]
        case ds_s59Bu of {
          GHC.Types.I# ds1_s59Bw [Occ=Once!] ->
              case ds1_s59Bw of {
                __DEFAULT -> Data.Type.Coercion.$fEnumCoercion1;
                0# -> Data.Type.Coercion.Coercion [$dCoercible_s59Bt];
              };
        };

Data.Type.Coercion.$w$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId, Arity=3, Str=<L,U><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s59By w1_s59Bz w2_s59BA]
        let {
          lvl5_s59BB [Occ=OnceL]
            :: Data.Type.Coercion.Coercion a_s59q1 b_s59q2
          [LclId, Unf=OtherCon []] =
              CCCS Data.Type.Coercion.Coercion! [w_s59By]; } in
        let {
          go_s59BC [Occ=LoopBreaker]
            :: GHC.Prim.Int# -> [Data.Type.Coercion.Coercion a_s59q1 b_s59q2]
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [lvl5_s59BB go_s59BC] \r [x_s59BD]
                  let {
                    sat_s59BI [Occ=Once]
                      :: [Data.Type.Coercion.Coercion a_s59q1 b_s59q2]
                    [LclId] =
                        [go_s59BC x_s59BD] \u []
                            case x_s59BD of wild_s59BG {
                              __DEFAULT ->
                                  case +# [wild_s59BG 1#] of sat_s59BH {
                                    __DEFAULT -> go_s59BC sat_s59BH;
                                  };
                              0# -> [] [];
                            }; } in
                  let {
                    sat_s59BF [Occ=Once] :: Data.Type.Coercion.Coercion a_s59q1 b_s59q2
                    [LclId] =
                        [lvl5_s59BB x_s59BD] \u []
                            case x_s59BD of {
                              __DEFAULT -> Data.Type.Coercion.$fEnumCoercion1;
                              0# -> lvl5_s59BB;
                            };
                  } in  : [sat_s59BF sat_s59BI];
        } in  go_s59BC 0#;

Data.Type.Coercion.$fEnumCoercion_$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId, Arity=3, Str=<L,U><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s59BJ w1_s59BK w2_s59BL]
        case w1_s59BK of w3_s59BM {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case w2_s59BL of w4_s59BO {
                Data.Type.Coercion.Coercion _ [Occ=Dead] ->
                    Data.Type.Coercion.$w$cenumFromTo w_s59BJ w3_s59BM w4_s59BO;
              };
        };

lvl1_r59Bc :: [GHC.Types.Int]
[GblId] =
    [] \u [] GHC.Enum.efdInt 0# 0#;

Data.Type.Coercion.$fEnumCoercion_$cenumFromThen
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId, Arity=3, Str=<L,U><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [$dCoercible_s59BQ x_s59BR y_s59BS]
        case x_s59BR of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case y_s59BS of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] ->
                    let {
                      sat_s59BX [Occ=Once]
                        :: GHC.Types.Int -> Data.Type.Coercion.Coercion a_a598Z b_a5990
                      [LclId] =
                          [$dCoercible_s59BQ] \r [eta_B1]
                              Data.Type.Coercion.$fEnumCoercion_$ctoEnum
                                  $dCoercible_s59BQ eta_B1;
                    } in  GHC.Base.map sat_s59BX lvl1_r59Bc;
              };
        };

Data.Type.Coercion.$w$cenumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId, Arity=2, Str=<L,U><L,A>, Unf=OtherCon []] =
    [] \r [w_s59BY w1_s59BZ]
        let {
          lvl5_s59C0 [Occ=OnceL]
            :: Data.Type.Coercion.Coercion a_s59q9 b_s59qa
          [LclId, Unf=OtherCon []] =
              CCCS Data.Type.Coercion.Coercion! [w_s59BY]; } in
        let {
          go_s59C1 [Occ=LoopBreaker]
            :: GHC.Prim.Int# -> [Data.Type.Coercion.Coercion a_s59q9 b_s59qa]
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [lvl5_s59C0 go_s59C1] \r [x_s59C2]
                  let {
                    sat_s59C7 [Occ=Once]
                      :: [Data.Type.Coercion.Coercion a_s59q9 b_s59qa]
                    [LclId] =
                        [go_s59C1 x_s59C2] \u []
                            case x_s59C2 of wild_s59C5 {
                              __DEFAULT ->
                                  case +# [wild_s59C5 1#] of sat_s59C6 {
                                    __DEFAULT -> go_s59C1 sat_s59C6;
                                  };
                              9223372036854775807# -> [] [];
                            }; } in
                  let {
                    sat_s59C4 [Occ=Once] :: Data.Type.Coercion.Coercion a_s59q9 b_s59qa
                    [LclId] =
                        [lvl5_s59C0 x_s59C2] \u []
                            case x_s59C2 of {
                              __DEFAULT -> Data.Type.Coercion.$fEnumCoercion1;
                              0# -> lvl5_s59C0;
                            };
                  } in  : [sat_s59C4 sat_s59C7];
        } in  go_s59C1 0#;

Data.Type.Coercion.$fEnumCoercion_$cenumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId, Arity=2, Str=<L,U><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s59C8 w1_s59C9]
        case w1_s59C9 of w2_s59Ca {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              Data.Type.Coercion.$w$cenumFrom w_s59C8 w2_s59Ca;
        };

Data.Type.Coercion.$w$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> (# Data.Type.Coercion.Coercion a b,
           [Data.Type.Coercion.Coercion a b] #)
[GblId, Arity=4, Str=<L,U><L,A><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s59Cc w1_s59Cd w2_s59Ce w3_s59Cf]
        let {
          lvl5_s59Cg :: Data.Type.Coercion.Coercion a_s59qg b_s59qh
          [LclId, Unf=OtherCon []] =
              CCCS Data.Type.Coercion.Coercion! [w_s59Cc]; } in
        let {
          sat_s59Cp [Occ=Once]
            :: [Data.Type.Coercion.Coercion a_s59qg b_s59qh]
          [LclId] =
              [lvl5_s59Cg] \u []
                  let {
                    go_up_s59Ch [Occ=LoopBreaker]
                      :: GHC.Prim.Int# -> [Data.Type.Coercion.Coercion a_s59qg b_s59qh]
                    [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                        sat-only [lvl5_s59Cg go_up_s59Ch] \r [x_s59Ci]
                            case ># [x_s59Ci 0#] of {
                              __DEFAULT ->
                                  let {
                                    sat_s59Cm [Occ=Once]
                                      :: [Data.Type.Coercion.Coercion a_s59qg b_s59qh]
                                    [LclId] =
                                        [go_up_s59Ch x_s59Ci] \u [] go_up_s59Ch x_s59Ci; } in
                                  let {
                                    sat_s59Cl [Occ=Once]
                                      :: Data.Type.Coercion.Coercion a_s59qg b_s59qh
                                    [LclId] =
                                        [lvl5_s59Cg x_s59Ci] \u []
                                            case x_s59Ci of {
                                              __DEFAULT -> Data.Type.Coercion.$fEnumCoercion1;
                                              0# -> lvl5_s59Cg;
                                            };
                                  } in  : [sat_s59Cl sat_s59Cm];
                              1# ->
                                  let {
                                    sat_s59Co [Occ=Once]
                                      :: Data.Type.Coercion.Coercion a_s59qg b_s59qh
                                    [LclId] =
                                        [lvl5_s59Cg x_s59Ci] \u []
                                            case x_s59Ci of {
                                              __DEFAULT -> Data.Type.Coercion.$fEnumCoercion1;
                                              0# -> lvl5_s59Cg;
                                            };
                                  } in  : [sat_s59Co GHC.Types.[]];
                            };
                  } in  go_up_s59Ch 0#;
        } in  (#,#) [lvl5_s59Cg sat_s59Cp];

Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId,
 Arity=4,
 Str=<L,U><S,1*H><S,1*H><S,1*H>m2,
 Unf=OtherCon []] =
    [] \r [w_s59Cq w1_s59Cr w2_s59Cs w3_s59Ct]
        case w1_s59Cr of w4_s59Cu {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case w2_s59Cs of w5_s59Cw {
                Data.Type.Coercion.Coercion _ [Occ=Dead] ->
                    case w3_s59Ct of w6_s59Cy {
                      Data.Type.Coercion.Coercion _ [Occ=Dead] ->
                          case
                              Data.Type.Coercion.$w$cenumFromThenTo
                                  w_s59Cq w4_s59Cu w5_s59Cw w6_s59Cy
                          of
                          { (#,#) ww1_s59CB [Occ=Once] ww2_s59CC [Occ=Once] ->
                                : [ww1_s59CB ww2_s59CC];
                          };
                    };
              };
        };

lvl2_r59Bd :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

lvl3_r59Be
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [ds_s59CD]
        case ds_s59CD of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] -> lvl2_r59Bd;
        };

lvl4_r59Bf
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b -> Data.Type.Coercion.Coercion a b
[GblId, Arity=1, Str=<B,1*H>x, Unf=OtherCon []] =
    [] \r [x_s59CG]
        case x_s59CG of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              Data.Type.Coercion.$fEnumCoercion1;
        };

Data.Type.Coercion.$fEnumCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     GHC.Enum.Enum (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Arity=1, Str=<L,U>m] =
    [] \r [$dCoercible_s59CJ]
        let {
          sat_s59CO [Occ=Once]
            :: Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> [Data.Type.Coercion.Coercion a_a598Z b_a5990]
          [LclId] =
              [$dCoercible_s59CJ] \r [eta_B3 eta_B2 eta_B1]
                  Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo
                      $dCoercible_s59CJ eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s59CN [Occ=Once]
            :: Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> [Data.Type.Coercion.Coercion a_a598Z b_a5990]
          [LclId] =
              [$dCoercible_s59CJ] \r [eta_B2 eta_B1]
                  Data.Type.Coercion.$fEnumCoercion_$cenumFromTo
                      $dCoercible_s59CJ eta_B2 eta_B1; } in
        let {
          sat_s59CM [Occ=Once]
            :: Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> [Data.Type.Coercion.Coercion a_a598Z b_a5990]
          [LclId] =
              [$dCoercible_s59CJ] \r [eta_B2 eta_B1]
                  Data.Type.Coercion.$fEnumCoercion_$cenumFromThen
                      $dCoercible_s59CJ eta_B2 eta_B1; } in
        let {
          sat_s59CL [Occ=Once]
            :: Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> [Data.Type.Coercion.Coercion a_a598Z b_a5990]
          [LclId] =
              [$dCoercible_s59CJ] \r [eta_B1]
                  Data.Type.Coercion.$fEnumCoercion_$cenumFrom
                      $dCoercible_s59CJ eta_B1; } in
        let {
          sat_s59CK [Occ=Once]
            :: GHC.Types.Int -> Data.Type.Coercion.Coercion a_a598Z b_a5990
          [LclId] =
              [$dCoercible_s59CJ] \r [eta_B1]
                  Data.Type.Coercion.$fEnumCoercion_$ctoEnum
                      $dCoercible_s59CJ eta_B1;
        } in 
          GHC.Enum.C:Enum [lvl4_r59Bf
                           lvl4_r59Bf
                           sat_s59CK
                           lvl3_r59Be
                           sat_s59CL
                           sat_s59CM
                           sat_s59CN
                           sat_s59CO];

Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion
  :: forall k (a1 :: k) (a2 :: k) (b :: k).
     (a1 Data.Type.Equality.:~: a2)
     -> (a1 Data.Type.Equality.:~: b)
     -> GHC.Base.Maybe (Data.Type.Coercion.Coercion a2 b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_s59CP ds1_s59CQ]
        case ds_s59CP of {
          Data.Type.Equality.Refl co_a598M ->
              case ds1_s59CQ of {
                Data.Type.Equality.Refl co1_a598N ->
                    let {
                      sat_s59CT [Occ=Once] :: GHC.Types.Coercible a1_a598J b_a598K
                      [LclId] =
                          CCCS GHC.Types.MkCoercible! [GHC.Prim.coercionToken#]; } in
                    let {
                      sat_s59CU [Occ=Once]
                        :: Data.Type.Coercion.Coercion a1_a598J b_a598K
                      [LclId] =
                          CCCS Data.Type.Coercion.Coercion! [sat_s59CT];
                    } in  GHC.Base.Just [sat_s59CU];
              };
        };

Data.Type.Coercion.$fTestCoercionk:~: [InlPrag=INLINE (sat-args=0)]
  :: forall k (a :: k).
     Data.Type.Coercion.TestCoercion ((Data.Type.Equality.:~:) a)
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion eta_B2 eta_B1;

Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion
  :: forall k k1 (a1 :: k1) (a2 :: k) (b :: k).
     (a1 Data.Type.Equality.:~~: a2)
     -> (a1 Data.Type.Equality.:~~: b)
     -> GHC.Base.Maybe (Data.Type.Coercion.Coercion a2 b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)><S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_s59CV ds1_s59CW]
        case ds_s59CV of {
          Data.Type.Equality.HRefl co_a598q co1_a598r ->
              case ds1_s59CW of {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>] co3_a598t ->
                    let {
                      sat_s59CZ [Occ=Once] :: GHC.Types.Coercible a1_a598n b_a598o
                      [LclId] =
                          CCCS GHC.Types.MkCoercible! [GHC.Prim.coercionToken#]; } in
                    let {
                      sat_s59D0 [Occ=Once]
                        :: Data.Type.Coercion.Coercion a1_a598n b_a598o
                      [LclId] =
                          CCCS Data.Type.Coercion.Coercion! [sat_s59CZ];
                    } in  GHC.Base.Just [sat_s59D0];
              };
        };

Data.Type.Coercion.$fTestCoercionk:~~: [InlPrag=INLINE (sat-args=0)]
  :: forall k k1 (a :: k1).
     Data.Type.Coercion.TestCoercion ((Data.Type.Equality.:~~:) a)
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)><S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion
            eta_B2 eta_B1;

Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion [InlPrag=NOUSERINLINE[0]]
  :: forall k (a1 :: k) (a2 :: k) (b :: k).
     Data.Type.Coercion.Coercion a1 a2
     -> Data.Type.Coercion.Coercion a1 b
     -> GHC.Base.Maybe (Data.Type.Coercion.Coercion a2 b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)),1*U(1*U(1*U))><S(S(S)),1*U(1*U(1*U))>m2,
 Unf=OtherCon []] =
    [] \r [w_s59D1 w1_s59D2]
        case w_s59D1 of {
          Data.Type.Coercion.Coercion ww1_s59D4 [Occ=Once] ->
              case w1_s59D2 of {
                Data.Type.Coercion.Coercion ww3_s59D6 [Occ=Once] ->
                    case GHC.Types.coercible_sel ww1_s59D4 of {
                      __DEFAULT ->
                          case GHC.Types.coercible_sel ww3_s59D6 of {
                            __DEFAULT ->
                                let {
                                  sat_s59D7 [Occ=Once] :: GHC.Types.Coercible a1_s59qs b_s59qt
                                  [LclId] =
                                      CCCS GHC.Types.MkCoercible! [GHC.Prim.coercionToken#]; } in
                                let {
                                  sat_s59D8 [Occ=Once]
                                    :: Data.Type.Coercion.Coercion a1_s59qs b_s59qt
                                  [LclId] =
                                      CCCS Data.Type.Coercion.Coercion! [sat_s59D7];
                                } in  GHC.Base.Just [sat_s59D8];
                          };
                    };
              };
        };

Data.Type.Coercion.$fTestCoercionkCoercion [InlPrag=INLINE (sat-args=0)]
  :: forall k (a :: k).
     Data.Type.Coercion.TestCoercion (Data.Type.Coercion.Coercion a)
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)),1*U(1*U(1*U))><S(S(S)),1*U(1*U(1*U))>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion
            eta_B2 eta_B1;

Data.Type.Coercion.$fEqCoercion_$c==
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [ds_s59D9 ds1_s59Da]
        case ds_s59D9 of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case ds1_s59Da of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.True [];
              };
        };

Data.Type.Coercion.$fEqCoercion_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [eta_s59Df eta1_s59Dg]
        case eta_s59Df of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case eta1_s59Dg of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.False [];
              };
        };

Data.Type.Coercion.$fEqCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Classes.Eq (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [Data.Type.Coercion.$fEqCoercion_$c==
                                     Data.Type.Coercion.$fEqCoercion_$c/=];

Data.Type.Coercion.$fReadCoercion3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Coercion"#;

Data.Type.Coercion.$fReadCoercion2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Type.Coercion.$fReadCoercion3;

Data.Type.Coercion.$fShowCoercion_$cshowsPrec
  :: forall k (a :: k) (b :: k).
     GHC.Types.Int -> Data.Type.Coercion.Coercion a b -> GHC.Show.ShowS
[GblId, Arity=3, Str=<L,A><S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s59Dl ds1_s59Dm eta_s59Dn]
        case ds1_s59Dm of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              GHC.Base.++ Data.Type.Coercion.$fReadCoercion2 eta_s59Dn;
        };

Data.Type.Coercion.$fShowCoercion_$cshow
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b -> GHC.Base.String
[GblId, Arity=1, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [x_s59Dq]
        case x_s59Dq of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              Data.Type.Coercion.$fReadCoercion2;
        };

Data.Type.Coercion.$fShowCoercion1
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s59Dt eta_s59Du]
        case ds_s59Dt of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              GHC.Base.++ Data.Type.Coercion.$fReadCoercion2 eta_s59Du;
        };

Data.Type.Coercion.$fShowCoercion_$cshowList
  :: forall k (a :: k) (b :: k).
     [Data.Type.Coercion.Coercion a b] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s59Dx s_s59Dy]
        GHC.Show.showList__
            Data.Type.Coercion.$fShowCoercion1 ls_s59Dx s_s59Dy;

Data.Type.Coercion.$fShowCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Show.Show (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Type.Coercion.$fShowCoercion_$cshowsPrec
                                    Data.Type.Coercion.$fShowCoercion_$cshow
                                    Data.Type.Coercion.$fShowCoercion_$cshowList];

Data.Type.Coercion.$fOrdCoercion_$c<
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s59Dz b1_s59DA]
        case a1_s59Dz of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case b1_s59DA of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.False [];
              };
        };

Data.Type.Coercion.$fOrdCoercion_$ccompare
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s59DF b1_s59DG]
        case a1_s59DF of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case b1_s59DG of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.EQ [];
              };
        };

Data.Type.Coercion.$fOrdCoercion_$c<=
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s59DL b1_s59DM]
        case b1_s59DM of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case a1_s59DL of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.True [];
              };
        };

Data.Type.Coercion.$fOrdCoercion_$cmax
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [x_s59DR y_s59DS]
        case x_s59DR of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] -> y_s59DS;
        };

Data.Type.Coercion.$fOrdCoercion_$c>
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s59DV b1_s59DW]
        case b1_s59DW of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case a1_s59DV of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.False [];
              };
        };

Data.Type.Coercion.$fOrdCoercion_$cmin
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [x_s59E1 y_s59E2]
        case y_s59E2 of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] -> x_s59E1;
        };

Data.Type.Coercion.$fOrdCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Classes.Ord (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Type.Coercion.$fEqCoercion
                                      Data.Type.Coercion.$fOrdCoercion_$ccompare
                                      Data.Type.Coercion.$fOrdCoercion_$c<
                                      Data.Type.Coercion.$fOrdCoercion_$c<=
                                      Data.Type.Coercion.$fOrdCoercion_$c>
                                      Data.Type.Coercion.$fEqCoercion_$c==
                                      Data.Type.Coercion.$fOrdCoercion_$cmax
                                      Data.Type.Coercion.$fOrdCoercion_$cmin];

Data.Type.Coercion.$fReadCoercion_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Type.Coercion.$fReadCoercion2];

Data.Type.Coercion.$fReadCoercion1
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Type.Coercion.Coercion a b
         -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
    [] \r [$dCoercible_s59E5 eta_s59E6 eta1_s59E7]
        let {
          x_s59E8 [Occ=OnceL] :: Data.Type.Coercion.Coercion a_a595J b_a595K
          [LclId, Unf=OtherCon []] =
              CCCS Data.Type.Coercion.Coercion! [$dCoercible_s59E5]; } in
        let {
          sat_s59Ef [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Type.Coercion.Coercion a_a595J b_a595K)
          [LclId] =
              [x_s59E8] \r [n_s59E9 eta2_s59Ea]
                  let {
                    sat_s59Ec [Occ=Once]
                      :: () -> Text.ParserCombinators.ReadP.P b2_X3ngt
                    [LclId] =
                        [x_s59E8 eta2_s59Ea] \r [a1_s59Eb] eta2_s59Ea x_s59E8;
                  } in 
                    case
                        Text.Read.Lex.$wexpect
                            Data.Type.Coercion.$fReadCoercion_lexeme sat_s59Ec
                    of
                    { Unit# ww1_s59Ee [Occ=Once] ->
                          Text.ParserCombinators.ReadP.Look [ww1_s59Ee];
                    };
        } in  GHC.Read.list3 sat_s59Ef eta_s59E6 eta1_s59E7;

Data.Type.Coercion.$fReadCoercion_$creadsPrec
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Type.Coercion.Coercion a b)
[GblId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
    [] \r [$dCoercible_s59Eg n_s59Eh]
        let {
          sat_s59Ei [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Type.Coercion.Coercion a_X597h b_X597j)
          [LclId] =
              [$dCoercible_s59Eg n_s59Eh] \u []
                  Data.Type.Coercion.$fReadCoercion1
                      $dCoercible_s59Eg
                      n_s59Eh
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s59Ei;

Data.Type.Coercion.$fReadCoercion_$creadListPrec
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Type.Coercion.Coercion a b]
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dCoercible_s59Ej]
        let {
          sat_s59Ek [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Type.Coercion.Coercion a_X597f b_X597h)
          [LclId] =
              [$dCoercible_s59Ej] \r [eta_B2 eta_B1]
                  Data.Type.Coercion.$fReadCoercion1 $dCoercible_s59Ej eta_B2 eta_B1;
        } in  GHC.Read.list sat_s59Ek;

Data.Type.Coercion.$fReadCoercion_$creadList
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Type.Coercion.Coercion a b]
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dCoercible_s59El]
        let {
          sat_s59En [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Type.Coercion.Coercion a_X597g b_X597i]
          [LclId] =
              [$dCoercible_s59El] \u []
                  let {
                    sat_s59Em [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Type.Coercion.Coercion a_X597g b_X597i)
                    [LclId] =
                        [$dCoercible_s59El] \r [eta_B2 eta_B1]
                            Data.Type.Coercion.$fReadCoercion1 $dCoercible_s59El eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_s59Em
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s59En;

Data.Type.Coercion.$fReadCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     GHC.Read.Read (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Arity=1, Str=<L,U>m] =
    [] \r [$dCoercible_s59Eo]
        let {
          sat_s59Es [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Type.Coercion.Coercion a_X597e b_X597g]
          [LclId] =
              [$dCoercible_s59Eo] \u []
                  Data.Type.Coercion.$fReadCoercion_$creadListPrec
                      $dCoercible_s59Eo; } in
        let {
          sat_s59Er [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Type.Coercion.Coercion a_X597e b_X597g)
          [LclId] =
              [$dCoercible_s59Eo] \r [eta_B2 eta_B1]
                  Data.Type.Coercion.$fReadCoercion1
                      $dCoercible_s59Eo eta_B2 eta_B1; } in
        let {
          sat_s59Eq [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Type.Coercion.Coercion a_X597e b_X597g]
          [LclId] =
              [$dCoercible_s59Eo] \u []
                  Data.Type.Coercion.$fReadCoercion_$creadList
                      $dCoercible_s59Eo; } in
        let {
          sat_s59Ep [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Type.Coercion.Coercion a_X597e b_X597g)
          [LclId] =
              [$dCoercible_s59Eo] \r [eta_B1]
                  Data.Type.Coercion.$fReadCoercion_$creadsPrec
                      $dCoercible_s59Eo eta_B1;
        } in  GHC.Read.C:Read [sat_s59Ep sat_s59Eq sat_s59Er sat_s59Es];

Data.Type.Coercion.$fBoundedCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     GHC.Enum.Bounded (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U>m] =
    [] \r [$dCoercible_s59Et]
        let {
          sat_s59Ev [Occ=Once] :: Data.Type.Coercion.Coercion a_a595n b_a595o
          [LclId] =
              CCCS Data.Type.Coercion.Coercion! [$dCoercible_s59Et];
        } in  GHC.Enum.C:Bounded [sat_s59Ev sat_s59Ev];

Data.Type.Coercion.coerceWith
  :: forall a b. Data.Type.Coercion.Coercion a b -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s59Ew x_s59Ex]
        case ds_s59Ew of {
          Data.Type.Coercion.Coercion $dCoercible_s59Ez [Occ=Once!] ->
              case $dCoercible_s59Ez of {
                GHC.Types.MkCoercible v_B3 -> x_s59Ex;
              };
        };

Data.Type.Coercion.gcoerceWith
  :: forall k0 (a :: k0) (b :: k0) r.
     Data.Type.Coercion.Coercion a b
     -> (GHC.Types.Coercible a b => r) -> r
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s59EB x_s59EC]
        case ds_s59EB of {
          Data.Type.Coercion.Coercion $dCoercible_s59EE [Occ=Once] ->
              x_s59EC $dCoercible_s59EE;
        };

Data.Type.Coercion.sym
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b -> Data.Type.Coercion.Coercion b a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)),1*U(1*U(1*U))>m,
 Unf=OtherCon []] =
    [] \r [ds_s59EF]
        case ds_s59EF of {
          Data.Type.Coercion.Coercion $dCoercible_s59EH [Occ=Once] ->
              case GHC.Types.coercible_sel $dCoercible_s59EH of {
                __DEFAULT ->
                    let {
                      sat_s59EI [Occ=Once] :: GHC.Types.Coercible b_a594U a_a594T
                      [LclId] =
                          CCCS GHC.Types.MkCoercible! [GHC.Prim.coercionToken#];
                    } in  Data.Type.Coercion.Coercion [sat_s59EI];
              };
        };

Data.Type.Coercion.trans
  :: forall k (a :: k) (b :: k) (c :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion b c
     -> Data.Type.Coercion.Coercion a c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)),1*U(1*U(1*U))><S(S(S)),1*U(1*U(1*U))>m,
 Unf=OtherCon []] =
    [] \r [ds_s59EJ ds1_s59EK]
        case ds_s59EJ of {
          Data.Type.Coercion.Coercion $dCoercible_s59EM [Occ=Once] ->
              case GHC.Types.coercible_sel $dCoercible_s59EM of {
                __DEFAULT ->
                    case ds1_s59EK of {
                      Data.Type.Coercion.Coercion $dCoercible1_s59EO [Occ=Once] ->
                          case GHC.Types.coercible_sel $dCoercible1_s59EO of {
                            __DEFAULT ->
                                let {
                                  sat_s59EP [Occ=Once] :: GHC.Types.Coercible a_a594F c_a594H
                                  [LclId] =
                                      CCCS GHC.Types.MkCoercible! [GHC.Prim.coercionToken#];
                                } in  Data.Type.Coercion.Coercion [sat_s59EP];
                          };
                    };
              };
        };

Data.Type.Coercion.repr
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b) -> Data.Type.Coercion.Coercion a b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U(U)>m, Unf=OtherCon []] =
    [] \r [ds_s59EQ]
        case ds_s59EQ of {
          Data.Type.Equality.Refl co_a594x ->
              let {
                sat_s59ES [Occ=Once] :: GHC.Types.Coercible a_a594u b_a594v
                [LclId] =
                    CCCS GHC.Types.MkCoercible! [GHC.Prim.coercionToken#];
              } in  Data.Type.Coercion.Coercion [sat_s59ES];
        };

Data.Type.Coercion.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Type.Coercion.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Coercion.$trModule4];

Data.Type.Coercion.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Type.Coercion"#;

Data.Type.Coercion.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Coercion.$trModule2];

Data.Type.Coercion.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Type.Coercion.$trModule3
                                     Data.Type.Coercion.$trModule1];

$krep_r59Bg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

$krep1_r59Bh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_r59Bi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r59Bh
                                         GHC.Types.krep$*];

Data.Type.Coercion.$tcCoercion1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r59Bh $krep2_r59Bi];

Data.Type.Coercion.$tcTestCoercion1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r59Bi $krep_r59Bg];

$krep3_r59Bj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep4_r59Bk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep5_r59Bl :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r59Bj GHC.Types.[]];

$krep6_r59Bm :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_r59Bk $krep5_r59Bl];

$krep7_r59Bn :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r59Bh $krep6_r59Bm];

$krep8_r59Bo :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcCoercible
                                              $krep7_r59Bn];

Data.Type.Coercion.$tcCoercion2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Coercion.$fReadCoercion3];

Data.Type.Coercion.$tcCoercion :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14885566513674463733##
                                    8268940906925368652##
                                    Data.Type.Coercion.$trModule
                                    Data.Type.Coercion.$tcCoercion2
                                    1#
                                    Data.Type.Coercion.$tcCoercion1];

$krep9_r59Bp :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Type.Coercion.$tcCoercion
                                              $krep7_r59Bn];

Data.Type.Coercion.$tc'Coercion1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_r59Bo $krep9_r59Bp];

Data.Type.Coercion.$tc'Coercion3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Coercion"#;

Data.Type.Coercion.$tc'Coercion2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Coercion.$tc'Coercion3];

Data.Type.Coercion.$tc'Coercion :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16177208673276072700##
                                    13187043378465993605##
                                    Data.Type.Coercion.$trModule
                                    Data.Type.Coercion.$tc'Coercion2
                                    3#
                                    Data.Type.Coercion.$tc'Coercion1];

Data.Type.Coercion.$tcTestCoercion3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "TestCoercion"#;

Data.Type.Coercion.$tcTestCoercion2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Coercion.$tcTestCoercion3];

Data.Type.Coercion.$tcTestCoercion :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14520160333183018944##
                                    2439357669602544154##
                                    Data.Type.Coercion.$trModule
                                    Data.Type.Coercion.$tcTestCoercion2
                                    1#
                                    Data.Type.Coercion.$tcTestCoercion1];

Data.Type.Coercion.Coercion
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Type.Coercion.Coercion [eta_B1];


==================== STG syntax: ====================
2018-03-16 16:00:06.184965313 UTC

Data.Type.Coercion.testCoercion [InlPrag=INLINE]
  :: forall k (f :: k -> *).
     Data.Type.Coercion.TestCoercion f =>
     forall (a :: k) (b :: k).
     f a -> f b -> GHC.Base.Maybe (Data.Type.Coercion.Coercion a b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_s59Br] v_s59Br;

lvl_r59Bb :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Type.Coercion.toEnum: bad argument"#;

Data.Type.Coercion.$fEnumCoercion1
  :: forall k (a :: k) (b :: k). Data.Type.Coercion.Coercion a b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_r59Bb of sat_s59Bs {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s59Bs;
        };

Data.Type.Coercion.$fEnumCoercion_$ctoEnum
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     GHC.Types.Int -> Data.Type.Coercion.Coercion a b
[GblId, Arity=2, Str=<L,U><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [$dCoercible_s59Bt ds_s59Bu]
        case ds_s59Bu of {
          GHC.Types.I# ds1_s59Bw [Occ=Once!] ->
              case ds1_s59Bw of {
                __DEFAULT -> Data.Type.Coercion.$fEnumCoercion1;
                0# -> Data.Type.Coercion.Coercion [$dCoercible_s59Bt];
              };
        };

Data.Type.Coercion.$w$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId, Arity=3, Str=<L,U><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s59By w1_s59Bz w2_s59BA]
        let {
          lvl5_s59BB [Occ=OnceL]
            :: Data.Type.Coercion.Coercion a_s59q1 b_s59q2
          [LclId, Unf=OtherCon []] =
              CCCS Data.Type.Coercion.Coercion! [w_s59By]; } in
        let {
          go_s59BC [Occ=LoopBreaker]
            :: GHC.Prim.Int# -> [Data.Type.Coercion.Coercion a_s59q1 b_s59q2]
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [lvl5_s59BB go_s59BC] \r [x_s59BD]
                  let {
                    sat_s59BI [Occ=Once]
                      :: [Data.Type.Coercion.Coercion a_s59q1 b_s59q2]
                    [LclId] =
                        [go_s59BC x_s59BD] \u []
                            case x_s59BD of wild_s59BG {
                              __DEFAULT ->
                                  case +# [wild_s59BG 1#] of sat_s59BH {
                                    __DEFAULT -> go_s59BC sat_s59BH;
                                  };
                              0# -> [] [];
                            }; } in
                  let {
                    sat_s59BF [Occ=Once] :: Data.Type.Coercion.Coercion a_s59q1 b_s59q2
                    [LclId] =
                        [lvl5_s59BB x_s59BD] \u []
                            case x_s59BD of {
                              __DEFAULT -> Data.Type.Coercion.$fEnumCoercion1;
                              0# -> lvl5_s59BB;
                            };
                  } in  : [sat_s59BF sat_s59BI];
        } in  go_s59BC 0#;

Data.Type.Coercion.$fEnumCoercion_$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId, Arity=3, Str=<L,U><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s59BJ w1_s59BK w2_s59BL]
        case w1_s59BK of w3_s59BM {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case w2_s59BL of w4_s59BO {
                Data.Type.Coercion.Coercion _ [Occ=Dead] ->
                    Data.Type.Coercion.$w$cenumFromTo w_s59BJ w3_s59BM w4_s59BO;
              };
        };

lvl1_r59Bc :: [GHC.Types.Int]
[GblId] =
    [] \u [] GHC.Enum.efdInt 0# 0#;

Data.Type.Coercion.$fEnumCoercion_$cenumFromThen
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId, Arity=3, Str=<L,U><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [$dCoercible_s59BQ x_s59BR y_s59BS]
        case x_s59BR of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case y_s59BS of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] ->
                    let {
                      sat_s59BX [Occ=Once]
                        :: GHC.Types.Int -> Data.Type.Coercion.Coercion a_a598Z b_a5990
                      [LclId] =
                          [$dCoercible_s59BQ] \r [eta_B1]
                              Data.Type.Coercion.$fEnumCoercion_$ctoEnum
                                  $dCoercible_s59BQ eta_B1;
                    } in  GHC.Base.map sat_s59BX lvl1_r59Bc;
              };
        };

Data.Type.Coercion.$w$cenumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId, Arity=2, Str=<L,U><L,A>, Unf=OtherCon []] =
    [] \r [w_s59BY w1_s59BZ]
        let {
          lvl5_s59C0 [Occ=OnceL]
            :: Data.Type.Coercion.Coercion a_s59q9 b_s59qa
          [LclId, Unf=OtherCon []] =
              CCCS Data.Type.Coercion.Coercion! [w_s59BY]; } in
        let {
          go_s59C1 [Occ=LoopBreaker]
            :: GHC.Prim.Int# -> [Data.Type.Coercion.Coercion a_s59q9 b_s59qa]
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [lvl5_s59C0 go_s59C1] \r [x_s59C2]
                  let {
                    sat_s59C7 [Occ=Once]
                      :: [Data.Type.Coercion.Coercion a_s59q9 b_s59qa]
                    [LclId] =
                        [go_s59C1 x_s59C2] \u []
                            case x_s59C2 of wild_s59C5 {
                              __DEFAULT ->
                                  case +# [wild_s59C5 1#] of sat_s59C6 {
                                    __DEFAULT -> go_s59C1 sat_s59C6;
                                  };
                              9223372036854775807# -> [] [];
                            }; } in
                  let {
                    sat_s59C4 [Occ=Once] :: Data.Type.Coercion.Coercion a_s59q9 b_s59qa
                    [LclId] =
                        [lvl5_s59C0 x_s59C2] \u []
                            case x_s59C2 of {
                              __DEFAULT -> Data.Type.Coercion.$fEnumCoercion1;
                              0# -> lvl5_s59C0;
                            };
                  } in  : [sat_s59C4 sat_s59C7];
        } in  go_s59C1 0#;

Data.Type.Coercion.$fEnumCoercion_$cenumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId, Arity=2, Str=<L,U><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s59C8 w1_s59C9]
        case w1_s59C9 of w2_s59Ca {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              Data.Type.Coercion.$w$cenumFrom w_s59C8 w2_s59Ca;
        };

Data.Type.Coercion.$w$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> (# Data.Type.Coercion.Coercion a b,
           [Data.Type.Coercion.Coercion a b] #)
[GblId, Arity=4, Str=<L,U><L,A><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s59Cc w1_s59Cd w2_s59Ce w3_s59Cf]
        let {
          lvl5_s59Cg :: Data.Type.Coercion.Coercion a_s59qg b_s59qh
          [LclId, Unf=OtherCon []] =
              CCCS Data.Type.Coercion.Coercion! [w_s59Cc]; } in
        let {
          sat_s59Cp [Occ=Once]
            :: [Data.Type.Coercion.Coercion a_s59qg b_s59qh]
          [LclId] =
              [lvl5_s59Cg] \u []
                  let {
                    go_up_s59Ch [Occ=LoopBreaker]
                      :: GHC.Prim.Int# -> [Data.Type.Coercion.Coercion a_s59qg b_s59qh]
                    [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                        sat-only [lvl5_s59Cg go_up_s59Ch] \r [x_s59Ci]
                            case ># [x_s59Ci 0#] of {
                              __DEFAULT ->
                                  let {
                                    sat_s59Cm [Occ=Once]
                                      :: [Data.Type.Coercion.Coercion a_s59qg b_s59qh]
                                    [LclId] =
                                        [go_up_s59Ch x_s59Ci] \u [] go_up_s59Ch x_s59Ci; } in
                                  let {
                                    sat_s59Cl [Occ=Once]
                                      :: Data.Type.Coercion.Coercion a_s59qg b_s59qh
                                    [LclId] =
                                        [lvl5_s59Cg x_s59Ci] \u []
                                            case x_s59Ci of {
                                              __DEFAULT -> Data.Type.Coercion.$fEnumCoercion1;
                                              0# -> lvl5_s59Cg;
                                            };
                                  } in  : [sat_s59Cl sat_s59Cm];
                              1# ->
                                  let {
                                    sat_s59Co [Occ=Once]
                                      :: Data.Type.Coercion.Coercion a_s59qg b_s59qh
                                    [LclId] =
                                        [lvl5_s59Cg x_s59Ci] \u []
                                            case x_s59Ci of {
                                              __DEFAULT -> Data.Type.Coercion.$fEnumCoercion1;
                                              0# -> lvl5_s59Cg;
                                            };
                                  } in  : [sat_s59Co GHC.Types.[]];
                            };
                  } in  go_up_s59Ch 0#;
        } in  (#,#) [lvl5_s59Cg sat_s59Cp];

Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId,
 Arity=4,
 Str=<L,U><S,1*H><S,1*H><S,1*H>m2,
 Unf=OtherCon []] =
    [] \r [w_s59Cq w1_s59Cr w2_s59Cs w3_s59Ct]
        case w1_s59Cr of w4_s59Cu {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case w2_s59Cs of w5_s59Cw {
                Data.Type.Coercion.Coercion _ [Occ=Dead] ->
                    case w3_s59Ct of w6_s59Cy {
                      Data.Type.Coercion.Coercion _ [Occ=Dead] ->
                          case
                              Data.Type.Coercion.$w$cenumFromThenTo
                                  w_s59Cq w4_s59Cu w5_s59Cw w6_s59Cy
                          of
                          { (#,#) ww1_s59CB [Occ=Once] ww2_s59CC [Occ=Once] ->
                                : [ww1_s59CB ww2_s59CC];
                          };
                    };
              };
        };

lvl2_r59Bd :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

lvl3_r59Be
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [ds_s59CD]
        case ds_s59CD of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] -> lvl2_r59Bd;
        };

lvl4_r59Bf
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b -> Data.Type.Coercion.Coercion a b
[GblId, Arity=1, Str=<B,1*H>x, Unf=OtherCon []] =
    [] \r [x_s59CG]
        case x_s59CG of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              Data.Type.Coercion.$fEnumCoercion1;
        };

Data.Type.Coercion.$fEnumCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     GHC.Enum.Enum (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Arity=1, Str=<L,U>m] =
    [] \r [$dCoercible_s59CJ]
        let {
          sat_s59CO [Occ=Once]
            :: Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> [Data.Type.Coercion.Coercion a_a598Z b_a5990]
          [LclId] =
              [$dCoercible_s59CJ] \r [eta_B3 eta_B2 eta_B1]
                  Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo
                      $dCoercible_s59CJ eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s59CN [Occ=Once]
            :: Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> [Data.Type.Coercion.Coercion a_a598Z b_a5990]
          [LclId] =
              [$dCoercible_s59CJ] \r [eta_B2 eta_B1]
                  Data.Type.Coercion.$fEnumCoercion_$cenumFromTo
                      $dCoercible_s59CJ eta_B2 eta_B1; } in
        let {
          sat_s59CM [Occ=Once]
            :: Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> [Data.Type.Coercion.Coercion a_a598Z b_a5990]
          [LclId] =
              [$dCoercible_s59CJ] \r [eta_B2 eta_B1]
                  Data.Type.Coercion.$fEnumCoercion_$cenumFromThen
                      $dCoercible_s59CJ eta_B2 eta_B1; } in
        let {
          sat_s59CL [Occ=Once]
            :: Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> [Data.Type.Coercion.Coercion a_a598Z b_a5990]
          [LclId] =
              [$dCoercible_s59CJ] \r [eta_B1]
                  Data.Type.Coercion.$fEnumCoercion_$cenumFrom
                      $dCoercible_s59CJ eta_B1; } in
        let {
          sat_s59CK [Occ=Once]
            :: GHC.Types.Int -> Data.Type.Coercion.Coercion a_a598Z b_a5990
          [LclId] =
              [$dCoercible_s59CJ] \r [eta_B1]
                  Data.Type.Coercion.$fEnumCoercion_$ctoEnum
                      $dCoercible_s59CJ eta_B1;
        } in 
          GHC.Enum.C:Enum [lvl4_r59Bf
                           lvl4_r59Bf
                           sat_s59CK
                           lvl3_r59Be
                           sat_s59CL
                           sat_s59CM
                           sat_s59CN
                           sat_s59CO];

Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion
  :: forall k (a1 :: k) (a2 :: k) (b :: k).
     (a1 Data.Type.Equality.:~: a2)
     -> (a1 Data.Type.Equality.:~: b)
     -> GHC.Base.Maybe (Data.Type.Coercion.Coercion a2 b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_s59CP ds1_s59CQ]
        case ds_s59CP of {
          Data.Type.Equality.Refl ->
              case ds1_s59CQ of {
                Data.Type.Equality.Refl ->
                    let {
                      sat_s59CT [Occ=Once] :: GHC.Types.Coercible a1_a598J b_a598K
                      [LclId] =
                          CCCS GHC.Types.MkCoercible! []; } in
                    let {
                      sat_s59CU [Occ=Once]
                        :: Data.Type.Coercion.Coercion a1_a598J b_a598K
                      [LclId] =
                          CCCS Data.Type.Coercion.Coercion! [sat_s59CT];
                    } in  GHC.Base.Just [sat_s59CU];
              };
        };

Data.Type.Coercion.$fTestCoercionk:~: [InlPrag=INLINE (sat-args=0)]
  :: forall k (a :: k).
     Data.Type.Coercion.TestCoercion ((Data.Type.Equality.:~:) a)
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion eta_B2 eta_B1;

Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion
  :: forall k k1 (a1 :: k1) (a2 :: k) (b :: k).
     (a1 Data.Type.Equality.:~~: a2)
     -> (a1 Data.Type.Equality.:~~: b)
     -> GHC.Base.Maybe (Data.Type.Coercion.Coercion a2 b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)><S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_s59CV ds1_s59CW]
        case ds_s59CV of {
          Data.Type.Equality.HRefl ->
              case ds1_s59CW of {
                Data.Type.Equality.HRefl ->
                    let {
                      sat_s59CZ [Occ=Once] :: GHC.Types.Coercible a1_a598n b_a598o
                      [LclId] =
                          CCCS GHC.Types.MkCoercible! []; } in
                    let {
                      sat_s59D0 [Occ=Once]
                        :: Data.Type.Coercion.Coercion a1_a598n b_a598o
                      [LclId] =
                          CCCS Data.Type.Coercion.Coercion! [sat_s59CZ];
                    } in  GHC.Base.Just [sat_s59D0];
              };
        };

Data.Type.Coercion.$fTestCoercionk:~~: [InlPrag=INLINE (sat-args=0)]
  :: forall k k1 (a :: k1).
     Data.Type.Coercion.TestCoercion ((Data.Type.Equality.:~~:) a)
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)><S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion
            eta_B2 eta_B1;

Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion [InlPrag=NOUSERINLINE[0]]
  :: forall k (a1 :: k) (a2 :: k) (b :: k).
     Data.Type.Coercion.Coercion a1 a2
     -> Data.Type.Coercion.Coercion a1 b
     -> GHC.Base.Maybe (Data.Type.Coercion.Coercion a2 b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)),1*U(1*U(1*U))><S(S(S)),1*U(1*U(1*U))>m2,
 Unf=OtherCon []] =
    [] \r [w_s59D1 w1_s59D2]
        case w_s59D1 of {
          Data.Type.Coercion.Coercion ww1_s59D4 [Occ=Once] ->
              case w1_s59D2 of {
                Data.Type.Coercion.Coercion ww3_s59D6 [Occ=Once] ->
                    case GHC.Types.coercible_sel ww1_s59D4 of {
                      (##) ->
                          case GHC.Types.coercible_sel ww3_s59D6 of {
                            (##) ->
                                let {
                                  sat_s59D7 [Occ=Once] :: GHC.Types.Coercible a1_s59qs b_s59qt
                                  [LclId] =
                                      CCCS GHC.Types.MkCoercible! []; } in
                                let {
                                  sat_s59D8 [Occ=Once]
                                    :: Data.Type.Coercion.Coercion a1_s59qs b_s59qt
                                  [LclId] =
                                      CCCS Data.Type.Coercion.Coercion! [sat_s59D7];
                                } in  GHC.Base.Just [sat_s59D8];
                          };
                    };
              };
        };

Data.Type.Coercion.$fTestCoercionkCoercion [InlPrag=INLINE (sat-args=0)]
  :: forall k (a :: k).
     Data.Type.Coercion.TestCoercion (Data.Type.Coercion.Coercion a)
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)),1*U(1*U(1*U))><S(S(S)),1*U(1*U(1*U))>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion
            eta_B2 eta_B1;

Data.Type.Coercion.$fEqCoercion_$c==
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [ds_s59D9 ds1_s59Da]
        case ds_s59D9 of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case ds1_s59Da of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.True [];
              };
        };

Data.Type.Coercion.$fEqCoercion_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [eta_s59Df eta1_s59Dg]
        case eta_s59Df of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case eta1_s59Dg of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.False [];
              };
        };

Data.Type.Coercion.$fEqCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Classes.Eq (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [Data.Type.Coercion.$fEqCoercion_$c==
                                     Data.Type.Coercion.$fEqCoercion_$c/=];

Data.Type.Coercion.$fReadCoercion3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Coercion"#;

Data.Type.Coercion.$fReadCoercion2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Type.Coercion.$fReadCoercion3;

Data.Type.Coercion.$fShowCoercion_$cshowsPrec
  :: forall k (a :: k) (b :: k).
     GHC.Types.Int -> Data.Type.Coercion.Coercion a b -> GHC.Show.ShowS
[GblId, Arity=3, Str=<L,A><S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s59Dl ds1_s59Dm eta_s59Dn]
        case ds1_s59Dm of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              GHC.Base.++ Data.Type.Coercion.$fReadCoercion2 eta_s59Dn;
        };

Data.Type.Coercion.$fShowCoercion_$cshow
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b -> GHC.Base.String
[GblId, Arity=1, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [x_s59Dq]
        case x_s59Dq of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              Data.Type.Coercion.$fReadCoercion2;
        };

Data.Type.Coercion.$fShowCoercion1
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s59Dt eta_s59Du]
        case ds_s59Dt of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              GHC.Base.++ Data.Type.Coercion.$fReadCoercion2 eta_s59Du;
        };

Data.Type.Coercion.$fShowCoercion_$cshowList
  :: forall k (a :: k) (b :: k).
     [Data.Type.Coercion.Coercion a b] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s59Dx s_s59Dy]
        GHC.Show.showList__
            Data.Type.Coercion.$fShowCoercion1 ls_s59Dx s_s59Dy;

Data.Type.Coercion.$fShowCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Show.Show (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Type.Coercion.$fShowCoercion_$cshowsPrec
                                    Data.Type.Coercion.$fShowCoercion_$cshow
                                    Data.Type.Coercion.$fShowCoercion_$cshowList];

Data.Type.Coercion.$fOrdCoercion_$c<
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s59Dz b1_s59DA]
        case a1_s59Dz of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case b1_s59DA of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.False [];
              };
        };

Data.Type.Coercion.$fOrdCoercion_$ccompare
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s59DF b1_s59DG]
        case a1_s59DF of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case b1_s59DG of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.EQ [];
              };
        };

Data.Type.Coercion.$fOrdCoercion_$c<=
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s59DL b1_s59DM]
        case b1_s59DM of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case a1_s59DL of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.True [];
              };
        };

Data.Type.Coercion.$fOrdCoercion_$cmax
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [x_s59DR y_s59DS]
        case x_s59DR of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] -> y_s59DS;
        };

Data.Type.Coercion.$fOrdCoercion_$c>
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s59DV b1_s59DW]
        case b1_s59DW of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case a1_s59DV of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.False [];
              };
        };

Data.Type.Coercion.$fOrdCoercion_$cmin
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [x_s59E1 y_s59E2]
        case y_s59E2 of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] -> x_s59E1;
        };

Data.Type.Coercion.$fOrdCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Classes.Ord (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Type.Coercion.$fEqCoercion
                                      Data.Type.Coercion.$fOrdCoercion_$ccompare
                                      Data.Type.Coercion.$fOrdCoercion_$c<
                                      Data.Type.Coercion.$fOrdCoercion_$c<=
                                      Data.Type.Coercion.$fOrdCoercion_$c>
                                      Data.Type.Coercion.$fEqCoercion_$c==
                                      Data.Type.Coercion.$fOrdCoercion_$cmax
                                      Data.Type.Coercion.$fOrdCoercion_$cmin];

Data.Type.Coercion.$fReadCoercion_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Type.Coercion.$fReadCoercion2];

Data.Type.Coercion.$fReadCoercion1
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Type.Coercion.Coercion a b
         -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
    [] \r [$dCoercible_s59E5 eta_s59E6 eta1_s59E7]
        let {
          x_s59E8 [Occ=OnceL] :: Data.Type.Coercion.Coercion a_a595J b_a595K
          [LclId, Unf=OtherCon []] =
              CCCS Data.Type.Coercion.Coercion! [$dCoercible_s59E5]; } in
        let {
          sat_s59Ef [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Type.Coercion.Coercion a_a595J b_a595K)
          [LclId] =
              [x_s59E8] \r [n_s59E9 eta2_s59Ea]
                  let {
                    sat_s59Ec [Occ=Once]
                      :: () -> Text.ParserCombinators.ReadP.P b2_X3ngt
                    [LclId] =
                        [x_s59E8 eta2_s59Ea] \r [a1_s59Eb] eta2_s59Ea x_s59E8;
                  } in 
                    case
                        Text.Read.Lex.$wexpect
                            Data.Type.Coercion.$fReadCoercion_lexeme sat_s59Ec
                    of
                    { Unit# ww1_s59Ee [Occ=Once] ->
                          Text.ParserCombinators.ReadP.Look [ww1_s59Ee];
                    };
        } in  GHC.Read.list3 sat_s59Ef eta_s59E6 eta1_s59E7;

Data.Type.Coercion.$fReadCoercion_$creadsPrec
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Type.Coercion.Coercion a b)
[GblId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
    [] \r [$dCoercible_s59Eg n_s59Eh]
        let {
          sat_s59Ei [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Type.Coercion.Coercion a_X597h b_X597j)
          [LclId] =
              [$dCoercible_s59Eg n_s59Eh] \u []
                  Data.Type.Coercion.$fReadCoercion1
                      $dCoercible_s59Eg
                      n_s59Eh
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s59Ei;

Data.Type.Coercion.$fReadCoercion_$creadListPrec
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Type.Coercion.Coercion a b]
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dCoercible_s59Ej]
        let {
          sat_s59Ek [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Type.Coercion.Coercion a_X597f b_X597h)
          [LclId] =
              [$dCoercible_s59Ej] \r [eta_B2 eta_B1]
                  Data.Type.Coercion.$fReadCoercion1 $dCoercible_s59Ej eta_B2 eta_B1;
        } in  GHC.Read.list sat_s59Ek;

Data.Type.Coercion.$fReadCoercion_$creadList
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Type.Coercion.Coercion a b]
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dCoercible_s59El]
        let {
          sat_s59En [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Type.Coercion.Coercion a_X597g b_X597i]
          [LclId] =
              [$dCoercible_s59El] \u []
                  let {
                    sat_s59Em [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Type.Coercion.Coercion a_X597g b_X597i)
                    [LclId] =
                        [$dCoercible_s59El] \r [eta_B2 eta_B1]
                            Data.Type.Coercion.$fReadCoercion1 $dCoercible_s59El eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_s59Em
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s59En;

Data.Type.Coercion.$fReadCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     GHC.Read.Read (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Arity=1, Str=<L,U>m] =
    [] \r [$dCoercible_s59Eo]
        let {
          sat_s59Es [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Type.Coercion.Coercion a_X597e b_X597g]
          [LclId] =
              [$dCoercible_s59Eo] \u []
                  Data.Type.Coercion.$fReadCoercion_$creadListPrec
                      $dCoercible_s59Eo; } in
        let {
          sat_s59Er [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Type.Coercion.Coercion a_X597e b_X597g)
          [LclId] =
              [$dCoercible_s59Eo] \r [eta_B2 eta_B1]
                  Data.Type.Coercion.$fReadCoercion1
                      $dCoercible_s59Eo eta_B2 eta_B1; } in
        let {
          sat_s59Eq [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Type.Coercion.Coercion a_X597e b_X597g]
          [LclId] =
              [$dCoercible_s59Eo] \u []
                  Data.Type.Coercion.$fReadCoercion_$creadList
                      $dCoercible_s59Eo; } in
        let {
          sat_s59Ep [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Type.Coercion.Coercion a_X597e b_X597g)
          [LclId] =
              [$dCoercible_s59Eo] \r [eta_B1]
                  Data.Type.Coercion.$fReadCoercion_$creadsPrec
                      $dCoercible_s59Eo eta_B1;
        } in  GHC.Read.C:Read [sat_s59Ep sat_s59Eq sat_s59Er sat_s59Es];

Data.Type.Coercion.$fBoundedCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     GHC.Enum.Bounded (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U>m] =
    [] \r [$dCoercible_s59Et]
        let {
          sat_s59Ev [Occ=Once] :: Data.Type.Coercion.Coercion a_a595n b_a595o
          [LclId] =
              CCCS Data.Type.Coercion.Coercion! [$dCoercible_s59Et];
        } in  GHC.Enum.C:Bounded [sat_s59Ev sat_s59Ev];

Data.Type.Coercion.coerceWith
  :: forall a b. Data.Type.Coercion.Coercion a b -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s59Ew x_s59Ex]
        case ds_s59Ew of {
          Data.Type.Coercion.Coercion $dCoercible_s59Ez [Occ=Once!] ->
              case $dCoercible_s59Ez of { GHC.Types.MkCoercible -> x_s59Ex; };
        };

Data.Type.Coercion.gcoerceWith
  :: forall k0 (a :: k0) (b :: k0) r.
     Data.Type.Coercion.Coercion a b
     -> (GHC.Types.Coercible a b => r) -> r
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s59EB x_s59EC]
        case ds_s59EB of {
          Data.Type.Coercion.Coercion $dCoercible_s59EE [Occ=Once] ->
              x_s59EC $dCoercible_s59EE;
        };

Data.Type.Coercion.sym
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b -> Data.Type.Coercion.Coercion b a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)),1*U(1*U(1*U))>m,
 Unf=OtherCon []] =
    [] \r [ds_s59EF]
        case ds_s59EF of {
          Data.Type.Coercion.Coercion $dCoercible_s59EH [Occ=Once] ->
              case GHC.Types.coercible_sel $dCoercible_s59EH of {
                (##) ->
                    let {
                      sat_s59EI [Occ=Once] :: GHC.Types.Coercible b_a594U a_a594T
                      [LclId] =
                          CCCS GHC.Types.MkCoercible! [];
                    } in  Data.Type.Coercion.Coercion [sat_s59EI];
              };
        };

Data.Type.Coercion.trans
  :: forall k (a :: k) (b :: k) (c :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion b c
     -> Data.Type.Coercion.Coercion a c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)),1*U(1*U(1*U))><S(S(S)),1*U(1*U(1*U))>m,
 Unf=OtherCon []] =
    [] \r [ds_s59EJ ds1_s59EK]
        case ds_s59EJ of {
          Data.Type.Coercion.Coercion $dCoercible_s59EM [Occ=Once] ->
              case GHC.Types.coercible_sel $dCoercible_s59EM of {
                (##) ->
                    case ds1_s59EK of {
                      Data.Type.Coercion.Coercion $dCoercible1_s59EO [Occ=Once] ->
                          case GHC.Types.coercible_sel $dCoercible1_s59EO of {
                            (##) ->
                                let {
                                  sat_s59EP [Occ=Once] :: GHC.Types.Coercible a_a594F c_a594H
                                  [LclId] =
                                      CCCS GHC.Types.MkCoercible! [];
                                } in  Data.Type.Coercion.Coercion [sat_s59EP];
                          };
                    };
              };
        };

Data.Type.Coercion.repr
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b) -> Data.Type.Coercion.Coercion a b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U(U)>m, Unf=OtherCon []] =
    [] \r [ds_s59EQ]
        case ds_s59EQ of {
          Data.Type.Equality.Refl ->
              let {
                sat_s59ES [Occ=Once] :: GHC.Types.Coercible a_a594u b_a594v
                [LclId] =
                    CCCS GHC.Types.MkCoercible! [];
              } in  Data.Type.Coercion.Coercion [sat_s59ES];
        };

Data.Type.Coercion.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Type.Coercion.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Coercion.$trModule4];

Data.Type.Coercion.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Type.Coercion"#;

Data.Type.Coercion.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Coercion.$trModule2];

Data.Type.Coercion.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Type.Coercion.$trModule3
                                     Data.Type.Coercion.$trModule1];

$krep_r59Bg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

$krep1_r59Bh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_r59Bi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r59Bh
                                         GHC.Types.krep$*];

Data.Type.Coercion.$tcCoercion1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r59Bh $krep2_r59Bi];

Data.Type.Coercion.$tcTestCoercion1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r59Bi $krep_r59Bg];

$krep3_r59Bj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep4_r59Bk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep5_r59Bl :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r59Bj GHC.Types.[]];

$krep6_r59Bm :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_r59Bk $krep5_r59Bl];

$krep7_r59Bn :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r59Bh $krep6_r59Bm];

$krep8_r59Bo :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcCoercible
                                              $krep7_r59Bn];

Data.Type.Coercion.$tcCoercion2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Coercion.$fReadCoercion3];

Data.Type.Coercion.$tcCoercion :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14885566513674463733##
                                    8268940906925368652##
                                    Data.Type.Coercion.$trModule
                                    Data.Type.Coercion.$tcCoercion2
                                    1#
                                    Data.Type.Coercion.$tcCoercion1];

$krep9_r59Bp :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Type.Coercion.$tcCoercion
                                              $krep7_r59Bn];

Data.Type.Coercion.$tc'Coercion1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_r59Bo $krep9_r59Bp];

Data.Type.Coercion.$tc'Coercion3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Coercion"#;

Data.Type.Coercion.$tc'Coercion2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Coercion.$tc'Coercion3];

Data.Type.Coercion.$tc'Coercion :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16177208673276072700##
                                    13187043378465993605##
                                    Data.Type.Coercion.$trModule
                                    Data.Type.Coercion.$tc'Coercion2
                                    3#
                                    Data.Type.Coercion.$tc'Coercion1];

Data.Type.Coercion.$tcTestCoercion3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "TestCoercion"#;

Data.Type.Coercion.$tcTestCoercion2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Coercion.$tcTestCoercion3];

Data.Type.Coercion.$tcTestCoercion :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14520160333183018944##
                                    2439357669602544154##
                                    Data.Type.Coercion.$trModule
                                    Data.Type.Coercion.$tcTestCoercion2
                                    1#
                                    Data.Type.Coercion.$tcTestCoercion1];

Data.Type.Coercion.Coercion
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Type.Coercion.Coercion [eta_B1];


==================== Pre unarise: ====================
2018-03-16 16:00:07.676970112 UTC

Data.Type.Coercion.testCoercion [InlPrag=INLINE]
  :: forall k (f :: k -> *).
     Data.Type.Coercion.TestCoercion f =>
     forall (a :: k) (b :: k).
     f a -> f b -> GHC.Base.Maybe (Data.Type.Coercion.Coercion a b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_s5azs] v_s5azs;

lvl_r59Bb :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Type.Coercion.toEnum: bad argument"#;

Data.Type.Coercion.$fEnumCoercion1
  :: forall k (a :: k) (b :: k). Data.Type.Coercion.Coercion a b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_r59Bb of sat_s5azt {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s5azt;
        };

Data.Type.Coercion.$fEnumCoercion_$ctoEnum
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     GHC.Types.Int -> Data.Type.Coercion.Coercion a b
[GblId, Arity=2, Str=<L,U><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [$dCoercible_s5azu ds_s5azv]
        case ds_s5azv of {
          GHC.Types.I# ds1_s5azx [Occ=Once!] ->
              case ds1_s5azx of {
                __DEFAULT -> Data.Type.Coercion.$fEnumCoercion1;
                0# -> Data.Type.Coercion.Coercion [$dCoercible_s5azu];
              };
        };

Data.Type.Coercion.$w$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId, Arity=3, Str=<L,U><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s5azz w1_s5azA w2_s5azB]
        let {
          lvl5_s5azC [Occ=OnceL]
            :: Data.Type.Coercion.Coercion a_s59q1 b_s59q2
          [LclId, Unf=OtherCon []] =
              CCCS Data.Type.Coercion.Coercion! [w_s5azz]; } in
        let {
          go_s5azD [Occ=LoopBreaker]
            :: GHC.Prim.Int# -> [Data.Type.Coercion.Coercion a_s59q1 b_s59q2]
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [lvl5_s5azC go_s5azD] \r [x_s5azE]
                  let {
                    sat_s5azJ [Occ=Once]
                      :: [Data.Type.Coercion.Coercion a_s59q1 b_s59q2]
                    [LclId] =
                        [go_s5azD x_s5azE] \u []
                            case x_s5azE of wild_s5azH {
                              __DEFAULT ->
                                  case +# [wild_s5azH 1#] of sat_s5azI {
                                    __DEFAULT -> go_s5azD sat_s5azI;
                                  };
                              0# -> [] [];
                            }; } in
                  let {
                    sat_s5azG [Occ=Once] :: Data.Type.Coercion.Coercion a_s59q1 b_s59q2
                    [LclId] =
                        [lvl5_s5azC x_s5azE] \u []
                            case x_s5azE of {
                              __DEFAULT -> Data.Type.Coercion.$fEnumCoercion1;
                              0# -> lvl5_s5azC;
                            };
                  } in  : [sat_s5azG sat_s5azJ];
        } in  go_s5azD 0#;

Data.Type.Coercion.$fEnumCoercion_$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId, Arity=3, Str=<L,U><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s5azK w1_s5azL w2_s5azM]
        case w1_s5azL of w3_s5azN {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case w2_s5azM of w4_s5azP {
                Data.Type.Coercion.Coercion _ [Occ=Dead] ->
                    Data.Type.Coercion.$w$cenumFromTo w_s5azK w3_s5azN w4_s5azP;
              };
        };

lvl1_r59Bc :: [GHC.Types.Int]
[GblId] =
    [] \u [] GHC.Enum.efdInt 0# 0#;

Data.Type.Coercion.$fEnumCoercion_$cenumFromThen
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId, Arity=3, Str=<L,U><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [$dCoercible_s5azR x_s5azS y_s5azT]
        case x_s5azS of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case y_s5azT of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] ->
                    let {
                      sat_s5azY [Occ=Once]
                        :: GHC.Types.Int -> Data.Type.Coercion.Coercion a_a598Z b_a5990
                      [LclId] =
                          [$dCoercible_s5azR] \r [eta_B1]
                              Data.Type.Coercion.$fEnumCoercion_$ctoEnum
                                  $dCoercible_s5azR eta_B1;
                    } in  GHC.Base.map sat_s5azY lvl1_r59Bc;
              };
        };

Data.Type.Coercion.$w$cenumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId, Arity=2, Str=<L,U><L,A>, Unf=OtherCon []] =
    [] \r [w_s5azZ w1_s5aA0]
        let {
          lvl5_s5aA1 [Occ=OnceL]
            :: Data.Type.Coercion.Coercion a_s59q9 b_s59qa
          [LclId, Unf=OtherCon []] =
              CCCS Data.Type.Coercion.Coercion! [w_s5azZ]; } in
        let {
          go_s5aA2 [Occ=LoopBreaker]
            :: GHC.Prim.Int# -> [Data.Type.Coercion.Coercion a_s59q9 b_s59qa]
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [lvl5_s5aA1 go_s5aA2] \r [x_s5aA3]
                  let {
                    sat_s5aA8 [Occ=Once]
                      :: [Data.Type.Coercion.Coercion a_s59q9 b_s59qa]
                    [LclId] =
                        [go_s5aA2 x_s5aA3] \u []
                            case x_s5aA3 of wild_s5aA6 {
                              __DEFAULT ->
                                  case +# [wild_s5aA6 1#] of sat_s5aA7 {
                                    __DEFAULT -> go_s5aA2 sat_s5aA7;
                                  };
                              9223372036854775807# -> [] [];
                            }; } in
                  let {
                    sat_s5aA5 [Occ=Once] :: Data.Type.Coercion.Coercion a_s59q9 b_s59qa
                    [LclId] =
                        [lvl5_s5aA1 x_s5aA3] \u []
                            case x_s5aA3 of {
                              __DEFAULT -> Data.Type.Coercion.$fEnumCoercion1;
                              0# -> lvl5_s5aA1;
                            };
                  } in  : [sat_s5aA5 sat_s5aA8];
        } in  go_s5aA2 0#;

Data.Type.Coercion.$fEnumCoercion_$cenumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId, Arity=2, Str=<L,U><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s5aA9 w1_s5aAa]
        case w1_s5aAa of w2_s5aAb {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              Data.Type.Coercion.$w$cenumFrom w_s5aA9 w2_s5aAb;
        };

Data.Type.Coercion.$w$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> (# Data.Type.Coercion.Coercion a b,
           [Data.Type.Coercion.Coercion a b] #)
[GblId, Arity=4, Str=<L,U><L,A><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s5aAd w1_s5aAe w2_s5aAf w3_s5aAg]
        let {
          lvl5_s5aAh :: Data.Type.Coercion.Coercion a_s59qg b_s59qh
          [LclId, Unf=OtherCon []] =
              CCCS Data.Type.Coercion.Coercion! [w_s5aAd]; } in
        let {
          sat_s5aAq [Occ=Once]
            :: [Data.Type.Coercion.Coercion a_s59qg b_s59qh]
          [LclId] =
              [lvl5_s5aAh] \u []
                  let {
                    go_up_s5aAi [Occ=LoopBreaker]
                      :: GHC.Prim.Int# -> [Data.Type.Coercion.Coercion a_s59qg b_s59qh]
                    [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                        sat-only [lvl5_s5aAh go_up_s5aAi] \r [x_s5aAj]
                            case ># [x_s5aAj 0#] of {
                              __DEFAULT ->
                                  let {
                                    sat_s5aAn [Occ=Once]
                                      :: [Data.Type.Coercion.Coercion a_s59qg b_s59qh]
                                    [LclId] =
                                        [go_up_s5aAi x_s5aAj] \u [] go_up_s5aAi x_s5aAj; } in
                                  let {
                                    sat_s5aAm [Occ=Once]
                                      :: Data.Type.Coercion.Coercion a_s59qg b_s59qh
                                    [LclId] =
                                        [lvl5_s5aAh x_s5aAj] \u []
                                            case x_s5aAj of {
                                              __DEFAULT -> Data.Type.Coercion.$fEnumCoercion1;
                                              0# -> lvl5_s5aAh;
                                            };
                                  } in  : [sat_s5aAm sat_s5aAn];
                              1# ->
                                  let {
                                    sat_s5aAp [Occ=Once]
                                      :: Data.Type.Coercion.Coercion a_s59qg b_s59qh
                                    [LclId] =
                                        [lvl5_s5aAh x_s5aAj] \u []
                                            case x_s5aAj of {
                                              __DEFAULT -> Data.Type.Coercion.$fEnumCoercion1;
                                              0# -> lvl5_s5aAh;
                                            };
                                  } in  : [sat_s5aAp GHC.Types.[]];
                            };
                  } in  go_up_s5aAi 0#;
        } in  (#,#) [lvl5_s5aAh sat_s5aAq];

Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId,
 Arity=4,
 Str=<L,U><S,1*H><S,1*H><S,1*H>m2,
 Unf=OtherCon []] =
    [] \r [w_s5aAr w1_s5aAs w2_s5aAt w3_s5aAu]
        case w1_s5aAs of w4_s5aAv {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case w2_s5aAt of w5_s5aAx {
                Data.Type.Coercion.Coercion _ [Occ=Dead] ->
                    case w3_s5aAu of w6_s5aAz {
                      Data.Type.Coercion.Coercion _ [Occ=Dead] ->
                          case
                              Data.Type.Coercion.$w$cenumFromThenTo
                                  w_s5aAr w4_s5aAv w5_s5aAx w6_s5aAz
                          of
                          { (#,#) ww1_s5aAC [Occ=Once] ww2_s5aAD [Occ=Once] ->
                                : [ww1_s5aAC ww2_s5aAD];
                          };
                    };
              };
        };

lvl2_r59Bd :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

lvl3_r59Be
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [ds_s5aAE]
        case ds_s5aAE of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] -> lvl2_r59Bd;
        };

lvl4_r59Bf
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b -> Data.Type.Coercion.Coercion a b
[GblId, Arity=1, Str=<B,1*H>x, Unf=OtherCon []] =
    [] \r [x_s5aAH]
        case x_s5aAH of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              Data.Type.Coercion.$fEnumCoercion1;
        };

Data.Type.Coercion.$fEnumCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     GHC.Enum.Enum (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Arity=1, Str=<L,U>m] =
    [] \r [$dCoercible_s5aAK]
        let {
          sat_s5aAP [Occ=Once]
            :: Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> [Data.Type.Coercion.Coercion a_a598Z b_a5990]
          [LclId] =
              [$dCoercible_s5aAK] \r [eta_B3 eta_B2 eta_B1]
                  Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo
                      $dCoercible_s5aAK eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s5aAO [Occ=Once]
            :: Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> [Data.Type.Coercion.Coercion a_a598Z b_a5990]
          [LclId] =
              [$dCoercible_s5aAK] \r [eta_B2 eta_B1]
                  Data.Type.Coercion.$fEnumCoercion_$cenumFromTo
                      $dCoercible_s5aAK eta_B2 eta_B1; } in
        let {
          sat_s5aAN [Occ=Once]
            :: Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> [Data.Type.Coercion.Coercion a_a598Z b_a5990]
          [LclId] =
              [$dCoercible_s5aAK] \r [eta_B2 eta_B1]
                  Data.Type.Coercion.$fEnumCoercion_$cenumFromThen
                      $dCoercible_s5aAK eta_B2 eta_B1; } in
        let {
          sat_s5aAM [Occ=Once]
            :: Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> [Data.Type.Coercion.Coercion a_a598Z b_a5990]
          [LclId] =
              [$dCoercible_s5aAK] \r [eta_B1]
                  Data.Type.Coercion.$fEnumCoercion_$cenumFrom
                      $dCoercible_s5aAK eta_B1; } in
        let {
          sat_s5aAL [Occ=Once]
            :: GHC.Types.Int -> Data.Type.Coercion.Coercion a_a598Z b_a5990
          [LclId] =
              [$dCoercible_s5aAK] \r [eta_B1]
                  Data.Type.Coercion.$fEnumCoercion_$ctoEnum
                      $dCoercible_s5aAK eta_B1;
        } in 
          GHC.Enum.C:Enum [lvl4_r59Bf
                           lvl4_r59Bf
                           sat_s5aAL
                           lvl3_r59Be
                           sat_s5aAM
                           sat_s5aAN
                           sat_s5aAO
                           sat_s5aAP];

Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion
  :: forall k (a1 :: k) (a2 :: k) (b :: k).
     (a1 Data.Type.Equality.:~: a2)
     -> (a1 Data.Type.Equality.:~: b)
     -> GHC.Base.Maybe (Data.Type.Coercion.Coercion a2 b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_s5aAQ ds1_s5aAR]
        case ds_s5aAQ of {
          Data.Type.Equality.Refl co_a598M ->
              case ds1_s5aAR of {
                Data.Type.Equality.Refl co1_a598N ->
                    let {
                      sat_s5aAU [Occ=Once] :: GHC.Types.Coercible a1_a598J b_a598K
                      [LclId] =
                          CCCS GHC.Types.MkCoercible! [GHC.Prim.coercionToken#]; } in
                    let {
                      sat_s5aAV [Occ=Once]
                        :: Data.Type.Coercion.Coercion a1_a598J b_a598K
                      [LclId] =
                          CCCS Data.Type.Coercion.Coercion! [sat_s5aAU];
                    } in  GHC.Base.Just [sat_s5aAV];
              };
        };

Data.Type.Coercion.$fTestCoercionk:~: [InlPrag=INLINE (sat-args=0)]
  :: forall k (a :: k).
     Data.Type.Coercion.TestCoercion ((Data.Type.Equality.:~:) a)
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion eta_B2 eta_B1;

Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion
  :: forall k k1 (a1 :: k1) (a2 :: k) (b :: k).
     (a1 Data.Type.Equality.:~~: a2)
     -> (a1 Data.Type.Equality.:~~: b)
     -> GHC.Base.Maybe (Data.Type.Coercion.Coercion a2 b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)><S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_s5aAW ds1_s5aAX]
        case ds_s5aAW of {
          Data.Type.Equality.HRefl co_a598q co1_a598r ->
              case ds1_s5aAX of {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>] co3_a598t ->
                    let {
                      sat_s5aB0 [Occ=Once] :: GHC.Types.Coercible a1_a598n b_a598o
                      [LclId] =
                          CCCS GHC.Types.MkCoercible! [GHC.Prim.coercionToken#]; } in
                    let {
                      sat_s5aB1 [Occ=Once]
                        :: Data.Type.Coercion.Coercion a1_a598n b_a598o
                      [LclId] =
                          CCCS Data.Type.Coercion.Coercion! [sat_s5aB0];
                    } in  GHC.Base.Just [sat_s5aB1];
              };
        };

Data.Type.Coercion.$fTestCoercionk:~~: [InlPrag=INLINE (sat-args=0)]
  :: forall k k1 (a :: k1).
     Data.Type.Coercion.TestCoercion ((Data.Type.Equality.:~~:) a)
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)><S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion
            eta_B2 eta_B1;

Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion [InlPrag=NOUSERINLINE[0]]
  :: forall k (a1 :: k) (a2 :: k) (b :: k).
     Data.Type.Coercion.Coercion a1 a2
     -> Data.Type.Coercion.Coercion a1 b
     -> GHC.Base.Maybe (Data.Type.Coercion.Coercion a2 b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)),1*U(1*U(1*U))><S(S(S)),1*U(1*U(1*U))>m2,
 Unf=OtherCon []] =
    [] \r [w_s5aB2 w1_s5aB3]
        case w_s5aB2 of {
          Data.Type.Coercion.Coercion ww1_s5aB5 [Occ=Once] ->
              case w1_s5aB3 of {
                Data.Type.Coercion.Coercion ww3_s5aB7 [Occ=Once] ->
                    case GHC.Types.coercible_sel ww1_s5aB5 of {
                      __DEFAULT ->
                          case GHC.Types.coercible_sel ww3_s5aB7 of {
                            __DEFAULT ->
                                let {
                                  sat_s5aB8 [Occ=Once] :: GHC.Types.Coercible a1_s59qs b_s59qt
                                  [LclId] =
                                      CCCS GHC.Types.MkCoercible! [GHC.Prim.coercionToken#]; } in
                                let {
                                  sat_s5aB9 [Occ=Once]
                                    :: Data.Type.Coercion.Coercion a1_s59qs b_s59qt
                                  [LclId] =
                                      CCCS Data.Type.Coercion.Coercion! [sat_s5aB8];
                                } in  GHC.Base.Just [sat_s5aB9];
                          };
                    };
              };
        };

Data.Type.Coercion.$fTestCoercionkCoercion [InlPrag=INLINE (sat-args=0)]
  :: forall k (a :: k).
     Data.Type.Coercion.TestCoercion (Data.Type.Coercion.Coercion a)
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)),1*U(1*U(1*U))><S(S(S)),1*U(1*U(1*U))>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion
            eta_B2 eta_B1;

Data.Type.Coercion.$fEqCoercion_$c==
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [ds_s5aBa ds1_s5aBb]
        case ds_s5aBa of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case ds1_s5aBb of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.True [];
              };
        };

Data.Type.Coercion.$fEqCoercion_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [eta_s5aBg eta1_s5aBh]
        case eta_s5aBg of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case eta1_s5aBh of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.False [];
              };
        };

Data.Type.Coercion.$fEqCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Classes.Eq (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [Data.Type.Coercion.$fEqCoercion_$c==
                                     Data.Type.Coercion.$fEqCoercion_$c/=];

Data.Type.Coercion.$fReadCoercion3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Coercion"#;

Data.Type.Coercion.$fReadCoercion2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Type.Coercion.$fReadCoercion3;

Data.Type.Coercion.$fShowCoercion_$cshowsPrec
  :: forall k (a :: k) (b :: k).
     GHC.Types.Int -> Data.Type.Coercion.Coercion a b -> GHC.Show.ShowS
[GblId, Arity=3, Str=<L,A><S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s5aBm ds1_s5aBn eta_s5aBo]
        case ds1_s5aBn of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              GHC.Base.++ Data.Type.Coercion.$fReadCoercion2 eta_s5aBo;
        };

Data.Type.Coercion.$fShowCoercion_$cshow
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b -> GHC.Base.String
[GblId, Arity=1, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [x_s5aBr]
        case x_s5aBr of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              Data.Type.Coercion.$fReadCoercion2;
        };

Data.Type.Coercion.$fShowCoercion1
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s5aBu eta_s5aBv]
        case ds_s5aBu of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              GHC.Base.++ Data.Type.Coercion.$fReadCoercion2 eta_s5aBv;
        };

Data.Type.Coercion.$fShowCoercion_$cshowList
  :: forall k (a :: k) (b :: k).
     [Data.Type.Coercion.Coercion a b] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s5aBy s_s5aBz]
        GHC.Show.showList__
            Data.Type.Coercion.$fShowCoercion1 ls_s5aBy s_s5aBz;

Data.Type.Coercion.$fShowCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Show.Show (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Type.Coercion.$fShowCoercion_$cshowsPrec
                                    Data.Type.Coercion.$fShowCoercion_$cshow
                                    Data.Type.Coercion.$fShowCoercion_$cshowList];

Data.Type.Coercion.$fOrdCoercion_$c<
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s5aBA b1_s5aBB]
        case a1_s5aBA of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case b1_s5aBB of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.False [];
              };
        };

Data.Type.Coercion.$fOrdCoercion_$ccompare
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s5aBG b1_s5aBH]
        case a1_s5aBG of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case b1_s5aBH of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.EQ [];
              };
        };

Data.Type.Coercion.$fOrdCoercion_$c<=
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s5aBM b1_s5aBN]
        case b1_s5aBN of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case a1_s5aBM of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.True [];
              };
        };

Data.Type.Coercion.$fOrdCoercion_$cmax
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [x_s5aBS y_s5aBT]
        case x_s5aBS of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] -> y_s5aBT;
        };

Data.Type.Coercion.$fOrdCoercion_$c>
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s5aBW b1_s5aBX]
        case b1_s5aBX of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case a1_s5aBW of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.False [];
              };
        };

Data.Type.Coercion.$fOrdCoercion_$cmin
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [x_s5aC2 y_s5aC3]
        case y_s5aC3 of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] -> x_s5aC2;
        };

Data.Type.Coercion.$fOrdCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Classes.Ord (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Type.Coercion.$fEqCoercion
                                      Data.Type.Coercion.$fOrdCoercion_$ccompare
                                      Data.Type.Coercion.$fOrdCoercion_$c<
                                      Data.Type.Coercion.$fOrdCoercion_$c<=
                                      Data.Type.Coercion.$fOrdCoercion_$c>
                                      Data.Type.Coercion.$fEqCoercion_$c==
                                      Data.Type.Coercion.$fOrdCoercion_$cmax
                                      Data.Type.Coercion.$fOrdCoercion_$cmin];

Data.Type.Coercion.$fReadCoercion_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Type.Coercion.$fReadCoercion2];

Data.Type.Coercion.$fReadCoercion1
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Type.Coercion.Coercion a b
         -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
    [] \r [$dCoercible_s5aC6 eta_s5aC7 eta1_s5aC8]
        let {
          x_s5aC9 [Occ=OnceL] :: Data.Type.Coercion.Coercion a_a595J b_a595K
          [LclId, Unf=OtherCon []] =
              CCCS Data.Type.Coercion.Coercion! [$dCoercible_s5aC6]; } in
        let {
          sat_s5aCg [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Type.Coercion.Coercion a_a595J b_a595K)
          [LclId] =
              [x_s5aC9] \r [n_s5aCa eta2_s5aCb]
                  let {
                    sat_s5aCd [Occ=Once]
                      :: () -> Text.ParserCombinators.ReadP.P b2_X3ngt
                    [LclId] =
                        [x_s5aC9 eta2_s5aCb] \r [a1_s5aCc] eta2_s5aCb x_s5aC9;
                  } in 
                    case
                        Text.Read.Lex.$wexpect
                            Data.Type.Coercion.$fReadCoercion_lexeme sat_s5aCd
                    of
                    { Unit# ww1_s5aCf [Occ=Once] ->
                          Text.ParserCombinators.ReadP.Look [ww1_s5aCf];
                    };
        } in  GHC.Read.list3 sat_s5aCg eta_s5aC7 eta1_s5aC8;

Data.Type.Coercion.$fReadCoercion_$creadsPrec
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Type.Coercion.Coercion a b)
[GblId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
    [] \r [$dCoercible_s5aCh n_s5aCi]
        let {
          sat_s5aCj [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Type.Coercion.Coercion a_X597h b_X597j)
          [LclId] =
              [$dCoercible_s5aCh n_s5aCi] \u []
                  Data.Type.Coercion.$fReadCoercion1
                      $dCoercible_s5aCh
                      n_s5aCi
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s5aCj;

Data.Type.Coercion.$fReadCoercion_$creadListPrec
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Type.Coercion.Coercion a b]
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dCoercible_s5aCk]
        let {
          sat_s5aCl [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Type.Coercion.Coercion a_X597f b_X597h)
          [LclId] =
              [$dCoercible_s5aCk] \r [eta_B2 eta_B1]
                  Data.Type.Coercion.$fReadCoercion1 $dCoercible_s5aCk eta_B2 eta_B1;
        } in  GHC.Read.list sat_s5aCl;

Data.Type.Coercion.$fReadCoercion_$creadList
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Type.Coercion.Coercion a b]
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dCoercible_s5aCm]
        let {
          sat_s5aCo [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Type.Coercion.Coercion a_X597g b_X597i]
          [LclId] =
              [$dCoercible_s5aCm] \u []
                  let {
                    sat_s5aCn [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Type.Coercion.Coercion a_X597g b_X597i)
                    [LclId] =
                        [$dCoercible_s5aCm] \r [eta_B2 eta_B1]
                            Data.Type.Coercion.$fReadCoercion1 $dCoercible_s5aCm eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_s5aCn
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s5aCo;

Data.Type.Coercion.$fReadCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     GHC.Read.Read (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Arity=1, Str=<L,U>m] =
    [] \r [$dCoercible_s5aCp]
        let {
          sat_s5aCt [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Type.Coercion.Coercion a_X597e b_X597g]
          [LclId] =
              [$dCoercible_s5aCp] \u []
                  Data.Type.Coercion.$fReadCoercion_$creadListPrec
                      $dCoercible_s5aCp; } in
        let {
          sat_s5aCs [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Type.Coercion.Coercion a_X597e b_X597g)
          [LclId] =
              [$dCoercible_s5aCp] \r [eta_B2 eta_B1]
                  Data.Type.Coercion.$fReadCoercion1
                      $dCoercible_s5aCp eta_B2 eta_B1; } in
        let {
          sat_s5aCr [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Type.Coercion.Coercion a_X597e b_X597g]
          [LclId] =
              [$dCoercible_s5aCp] \u []
                  Data.Type.Coercion.$fReadCoercion_$creadList
                      $dCoercible_s5aCp; } in
        let {
          sat_s5aCq [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Type.Coercion.Coercion a_X597e b_X597g)
          [LclId] =
              [$dCoercible_s5aCp] \r [eta_B1]
                  Data.Type.Coercion.$fReadCoercion_$creadsPrec
                      $dCoercible_s5aCp eta_B1;
        } in  GHC.Read.C:Read [sat_s5aCq sat_s5aCr sat_s5aCs sat_s5aCt];

Data.Type.Coercion.$fBoundedCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     GHC.Enum.Bounded (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U>m] =
    [] \r [$dCoercible_s5aCu]
        let {
          sat_s5aCw [Occ=Once] :: Data.Type.Coercion.Coercion a_a595n b_a595o
          [LclId] =
              CCCS Data.Type.Coercion.Coercion! [$dCoercible_s5aCu];
        } in  GHC.Enum.C:Bounded [sat_s5aCw sat_s5aCw];

Data.Type.Coercion.coerceWith
  :: forall a b. Data.Type.Coercion.Coercion a b -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5aCx x_s5aCy]
        case ds_s5aCx of {
          Data.Type.Coercion.Coercion $dCoercible_s5aCA [Occ=Once!] ->
              case $dCoercible_s5aCA of {
                GHC.Types.MkCoercible v_B3 -> x_s5aCy;
              };
        };

Data.Type.Coercion.gcoerceWith
  :: forall k0 (a :: k0) (b :: k0) r.
     Data.Type.Coercion.Coercion a b
     -> (GHC.Types.Coercible a b => r) -> r
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s5aCC x_s5aCD]
        case ds_s5aCC of {
          Data.Type.Coercion.Coercion $dCoercible_s5aCF [Occ=Once] ->
              x_s5aCD $dCoercible_s5aCF;
        };

Data.Type.Coercion.sym
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b -> Data.Type.Coercion.Coercion b a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)),1*U(1*U(1*U))>m,
 Unf=OtherCon []] =
    [] \r [ds_s5aCG]
        case ds_s5aCG of {
          Data.Type.Coercion.Coercion $dCoercible_s5aCI [Occ=Once] ->
              case GHC.Types.coercible_sel $dCoercible_s5aCI of {
                __DEFAULT ->
                    let {
                      sat_s5aCJ [Occ=Once] :: GHC.Types.Coercible b_a594U a_a594T
                      [LclId] =
                          CCCS GHC.Types.MkCoercible! [GHC.Prim.coercionToken#];
                    } in  Data.Type.Coercion.Coercion [sat_s5aCJ];
              };
        };

Data.Type.Coercion.trans
  :: forall k (a :: k) (b :: k) (c :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion b c
     -> Data.Type.Coercion.Coercion a c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)),1*U(1*U(1*U))><S(S(S)),1*U(1*U(1*U))>m,
 Unf=OtherCon []] =
    [] \r [ds_s5aCK ds1_s5aCL]
        case ds_s5aCK of {
          Data.Type.Coercion.Coercion $dCoercible_s5aCN [Occ=Once] ->
              case GHC.Types.coercible_sel $dCoercible_s5aCN of {
                __DEFAULT ->
                    case ds1_s5aCL of {
                      Data.Type.Coercion.Coercion $dCoercible1_s5aCP [Occ=Once] ->
                          case GHC.Types.coercible_sel $dCoercible1_s5aCP of {
                            __DEFAULT ->
                                let {
                                  sat_s5aCQ [Occ=Once] :: GHC.Types.Coercible a_a594F c_a594H
                                  [LclId] =
                                      CCCS GHC.Types.MkCoercible! [GHC.Prim.coercionToken#];
                                } in  Data.Type.Coercion.Coercion [sat_s5aCQ];
                          };
                    };
              };
        };

Data.Type.Coercion.repr
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b) -> Data.Type.Coercion.Coercion a b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U(U)>m, Unf=OtherCon []] =
    [] \r [ds_s5aCR]
        case ds_s5aCR of {
          Data.Type.Equality.Refl co_a594x ->
              let {
                sat_s5aCT [Occ=Once] :: GHC.Types.Coercible a_a594u b_a594v
                [LclId] =
                    CCCS GHC.Types.MkCoercible! [GHC.Prim.coercionToken#];
              } in  Data.Type.Coercion.Coercion [sat_s5aCT];
        };

Data.Type.Coercion.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Type.Coercion.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Coercion.$trModule4];

Data.Type.Coercion.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Type.Coercion"#;

Data.Type.Coercion.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Coercion.$trModule2];

Data.Type.Coercion.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Type.Coercion.$trModule3
                                     Data.Type.Coercion.$trModule1];

$krep_r59Bg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

$krep1_r59Bh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_r59Bi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r59Bh
                                         GHC.Types.krep$*];

Data.Type.Coercion.$tcCoercion1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r59Bh $krep2_r59Bi];

Data.Type.Coercion.$tcTestCoercion1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r59Bi $krep_r59Bg];

$krep3_r59Bj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep4_r59Bk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep5_r59Bl :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r59Bj GHC.Types.[]];

$krep6_r59Bm :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_r59Bk $krep5_r59Bl];

$krep7_r59Bn :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r59Bh $krep6_r59Bm];

$krep8_r59Bo :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcCoercible
                                              $krep7_r59Bn];

Data.Type.Coercion.$tcCoercion2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Coercion.$fReadCoercion3];

Data.Type.Coercion.$tcCoercion :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14885566513674463733##
                                    8268940906925368652##
                                    Data.Type.Coercion.$trModule
                                    Data.Type.Coercion.$tcCoercion2
                                    1#
                                    Data.Type.Coercion.$tcCoercion1];

$krep9_r59Bp :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Type.Coercion.$tcCoercion
                                              $krep7_r59Bn];

Data.Type.Coercion.$tc'Coercion1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_r59Bo $krep9_r59Bp];

Data.Type.Coercion.$tc'Coercion3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Coercion"#;

Data.Type.Coercion.$tc'Coercion2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Coercion.$tc'Coercion3];

Data.Type.Coercion.$tc'Coercion :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16177208673276072700##
                                    13187043378465993605##
                                    Data.Type.Coercion.$trModule
                                    Data.Type.Coercion.$tc'Coercion2
                                    3#
                                    Data.Type.Coercion.$tc'Coercion1];

Data.Type.Coercion.$tcTestCoercion3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "TestCoercion"#;

Data.Type.Coercion.$tcTestCoercion2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Coercion.$tcTestCoercion3];

Data.Type.Coercion.$tcTestCoercion :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14520160333183018944##
                                    2439357669602544154##
                                    Data.Type.Coercion.$trModule
                                    Data.Type.Coercion.$tcTestCoercion2
                                    1#
                                    Data.Type.Coercion.$tcTestCoercion1];

Data.Type.Coercion.Coercion
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Type.Coercion.Coercion [eta_B1];


==================== STG syntax: ====================
2018-03-16 16:00:07.701138575 UTC

Data.Type.Coercion.testCoercion [InlPrag=INLINE]
  :: forall k (f :: k -> *).
     Data.Type.Coercion.TestCoercion f =>
     forall (a :: k) (b :: k).
     f a -> f b -> GHC.Base.Maybe (Data.Type.Coercion.Coercion a b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_s5azs] v_s5azs;

lvl_r59Bb :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Type.Coercion.toEnum: bad argument"#;

Data.Type.Coercion.$fEnumCoercion1
  :: forall k (a :: k) (b :: k). Data.Type.Coercion.Coercion a b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_r59Bb of sat_s5azt {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s5azt;
        };

Data.Type.Coercion.$fEnumCoercion_$ctoEnum
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     GHC.Types.Int -> Data.Type.Coercion.Coercion a b
[GblId, Arity=2, Str=<L,U><S(S),1*U(1*U)>m, Unf=OtherCon []] =
    [] \r [$dCoercible_s5azu ds_s5azv]
        case ds_s5azv of {
          GHC.Types.I# ds1_s5azx [Occ=Once!] ->
              case ds1_s5azx of {
                __DEFAULT -> Data.Type.Coercion.$fEnumCoercion1;
                0# -> Data.Type.Coercion.Coercion [$dCoercible_s5azu];
              };
        };

Data.Type.Coercion.$w$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId, Arity=3, Str=<L,U><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s5azz w1_s5azA w2_s5azB]
        let {
          lvl5_s5azC [Occ=OnceL]
            :: Data.Type.Coercion.Coercion a_s59q1 b_s59q2
          [LclId, Unf=OtherCon []] =
              CCCS Data.Type.Coercion.Coercion! [w_s5azz]; } in
        let {
          go_s5azD [Occ=LoopBreaker]
            :: GHC.Prim.Int# -> [Data.Type.Coercion.Coercion a_s59q1 b_s59q2]
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [lvl5_s5azC go_s5azD] \r [x_s5azE]
                  let {
                    sat_s5azJ [Occ=Once]
                      :: [Data.Type.Coercion.Coercion a_s59q1 b_s59q2]
                    [LclId] =
                        [go_s5azD x_s5azE] \u []
                            case x_s5azE of wild_s5azH {
                              __DEFAULT ->
                                  case +# [wild_s5azH 1#] of sat_s5azI {
                                    __DEFAULT -> go_s5azD sat_s5azI;
                                  };
                              0# -> [] [];
                            }; } in
                  let {
                    sat_s5azG [Occ=Once] :: Data.Type.Coercion.Coercion a_s59q1 b_s59q2
                    [LclId] =
                        [lvl5_s5azC x_s5azE] \u []
                            case x_s5azE of {
                              __DEFAULT -> Data.Type.Coercion.$fEnumCoercion1;
                              0# -> lvl5_s5azC;
                            };
                  } in  : [sat_s5azG sat_s5azJ];
        } in  go_s5azD 0#;

Data.Type.Coercion.$fEnumCoercion_$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId, Arity=3, Str=<L,U><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s5azK w1_s5azL w2_s5azM]
        case w1_s5azL of w3_s5azN {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case w2_s5azM of w4_s5azP {
                Data.Type.Coercion.Coercion _ [Occ=Dead] ->
                    Data.Type.Coercion.$w$cenumFromTo w_s5azK w3_s5azN w4_s5azP;
              };
        };

lvl1_r59Bc :: [GHC.Types.Int]
[GblId] =
    [] \u [] GHC.Enum.efdInt 0# 0#;

Data.Type.Coercion.$fEnumCoercion_$cenumFromThen
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId, Arity=3, Str=<L,U><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [$dCoercible_s5azR x_s5azS y_s5azT]
        case x_s5azS of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case y_s5azT of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] ->
                    let {
                      sat_s5azY [Occ=Once]
                        :: GHC.Types.Int -> Data.Type.Coercion.Coercion a_a598Z b_a5990
                      [LclId] =
                          [$dCoercible_s5azR] \r [eta_B1]
                              Data.Type.Coercion.$fEnumCoercion_$ctoEnum
                                  $dCoercible_s5azR eta_B1;
                    } in  GHC.Base.map sat_s5azY lvl1_r59Bc;
              };
        };

Data.Type.Coercion.$w$cenumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId, Arity=2, Str=<L,U><L,A>, Unf=OtherCon []] =
    [] \r [w_s5azZ w1_s5aA0]
        let {
          lvl5_s5aA1 [Occ=OnceL]
            :: Data.Type.Coercion.Coercion a_s59q9 b_s59qa
          [LclId, Unf=OtherCon []] =
              CCCS Data.Type.Coercion.Coercion! [w_s5azZ]; } in
        let {
          go_s5aA2 [Occ=LoopBreaker]
            :: GHC.Prim.Int# -> [Data.Type.Coercion.Coercion a_s59q9 b_s59qa]
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [lvl5_s5aA1 go_s5aA2] \r [x_s5aA3]
                  let {
                    sat_s5aA8 [Occ=Once]
                      :: [Data.Type.Coercion.Coercion a_s59q9 b_s59qa]
                    [LclId] =
                        [go_s5aA2 x_s5aA3] \u []
                            case x_s5aA3 of wild_s5aA6 {
                              __DEFAULT ->
                                  case +# [wild_s5aA6 1#] of sat_s5aA7 {
                                    __DEFAULT -> go_s5aA2 sat_s5aA7;
                                  };
                              9223372036854775807# -> [] [];
                            }; } in
                  let {
                    sat_s5aA5 [Occ=Once] :: Data.Type.Coercion.Coercion a_s59q9 b_s59qa
                    [LclId] =
                        [lvl5_s5aA1 x_s5aA3] \u []
                            case x_s5aA3 of {
                              __DEFAULT -> Data.Type.Coercion.$fEnumCoercion1;
                              0# -> lvl5_s5aA1;
                            };
                  } in  : [sat_s5aA5 sat_s5aA8];
        } in  go_s5aA2 0#;

Data.Type.Coercion.$fEnumCoercion_$cenumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId, Arity=2, Str=<L,U><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s5aA9 w1_s5aAa]
        case w1_s5aAa of w2_s5aAb {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              Data.Type.Coercion.$w$cenumFrom w_s5aA9 w2_s5aAb;
        };

Data.Type.Coercion.$w$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> (# Data.Type.Coercion.Coercion a b,
           [Data.Type.Coercion.Coercion a b] #)
[GblId, Arity=4, Str=<L,U><L,A><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s5aAd w1_s5aAe w2_s5aAf w3_s5aAg]
        let {
          lvl5_s5aAh :: Data.Type.Coercion.Coercion a_s59qg b_s59qh
          [LclId, Unf=OtherCon []] =
              CCCS Data.Type.Coercion.Coercion! [w_s5aAd]; } in
        let {
          sat_s5aAq [Occ=Once]
            :: [Data.Type.Coercion.Coercion a_s59qg b_s59qh]
          [LclId] =
              [lvl5_s5aAh] \u []
                  let {
                    go_up_s5aAi [Occ=LoopBreaker]
                      :: GHC.Prim.Int# -> [Data.Type.Coercion.Coercion a_s59qg b_s59qh]
                    [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                        sat-only [lvl5_s5aAh go_up_s5aAi] \r [x_s5aAj]
                            case ># [x_s5aAj 0#] of {
                              __DEFAULT ->
                                  let {
                                    sat_s5aAn [Occ=Once]
                                      :: [Data.Type.Coercion.Coercion a_s59qg b_s59qh]
                                    [LclId] =
                                        [go_up_s5aAi x_s5aAj] \u [] go_up_s5aAi x_s5aAj; } in
                                  let {
                                    sat_s5aAm [Occ=Once]
                                      :: Data.Type.Coercion.Coercion a_s59qg b_s59qh
                                    [LclId] =
                                        [lvl5_s5aAh x_s5aAj] \u []
                                            case x_s5aAj of {
                                              __DEFAULT -> Data.Type.Coercion.$fEnumCoercion1;
                                              0# -> lvl5_s5aAh;
                                            };
                                  } in  : [sat_s5aAm sat_s5aAn];
                              1# ->
                                  let {
                                    sat_s5aAp [Occ=Once]
                                      :: Data.Type.Coercion.Coercion a_s59qg b_s59qh
                                    [LclId] =
                                        [lvl5_s5aAh x_s5aAj] \u []
                                            case x_s5aAj of {
                                              __DEFAULT -> Data.Type.Coercion.$fEnumCoercion1;
                                              0# -> lvl5_s5aAh;
                                            };
                                  } in  : [sat_s5aAp GHC.Types.[]];
                            };
                  } in  go_up_s5aAi 0#;
        } in  (#,#) [lvl5_s5aAh sat_s5aAq];

Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> [Data.Type.Coercion.Coercion a b]
[GblId,
 Arity=4,
 Str=<L,U><S,1*H><S,1*H><S,1*H>m2,
 Unf=OtherCon []] =
    [] \r [w_s5aAr w1_s5aAs w2_s5aAt w3_s5aAu]
        case w1_s5aAs of w4_s5aAv {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case w2_s5aAt of w5_s5aAx {
                Data.Type.Coercion.Coercion _ [Occ=Dead] ->
                    case w3_s5aAu of w6_s5aAz {
                      Data.Type.Coercion.Coercion _ [Occ=Dead] ->
                          case
                              Data.Type.Coercion.$w$cenumFromThenTo
                                  w_s5aAr w4_s5aAv w5_s5aAx w6_s5aAz
                          of
                          { (#,#) ww1_s5aAC [Occ=Once] ww2_s5aAD [Occ=Once] ->
                                : [ww1_s5aAC ww2_s5aAD];
                          };
                    };
              };
        };

lvl2_r59Bd :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

lvl3_r59Be
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*H>m, Unf=OtherCon []] =
    [] \r [ds_s5aAE]
        case ds_s5aAE of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] -> lvl2_r59Bd;
        };

lvl4_r59Bf
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b -> Data.Type.Coercion.Coercion a b
[GblId, Arity=1, Str=<B,1*H>x, Unf=OtherCon []] =
    [] \r [x_s5aAH]
        case x_s5aAH of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              Data.Type.Coercion.$fEnumCoercion1;
        };

Data.Type.Coercion.$fEnumCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     GHC.Enum.Enum (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Arity=1, Str=<L,U>m] =
    [] \r [$dCoercible_s5aAK]
        let {
          sat_s5aAP [Occ=Once]
            :: Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> [Data.Type.Coercion.Coercion a_a598Z b_a5990]
          [LclId] =
              [$dCoercible_s5aAK] \r [eta_B3 eta_B2 eta_B1]
                  Data.Type.Coercion.$fEnumCoercion_$cenumFromThenTo
                      $dCoercible_s5aAK eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s5aAO [Occ=Once]
            :: Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> [Data.Type.Coercion.Coercion a_a598Z b_a5990]
          [LclId] =
              [$dCoercible_s5aAK] \r [eta_B2 eta_B1]
                  Data.Type.Coercion.$fEnumCoercion_$cenumFromTo
                      $dCoercible_s5aAK eta_B2 eta_B1; } in
        let {
          sat_s5aAN [Occ=Once]
            :: Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> [Data.Type.Coercion.Coercion a_a598Z b_a5990]
          [LclId] =
              [$dCoercible_s5aAK] \r [eta_B2 eta_B1]
                  Data.Type.Coercion.$fEnumCoercion_$cenumFromThen
                      $dCoercible_s5aAK eta_B2 eta_B1; } in
        let {
          sat_s5aAM [Occ=Once]
            :: Data.Type.Coercion.Coercion a_a598Z b_a5990
               -> [Data.Type.Coercion.Coercion a_a598Z b_a5990]
          [LclId] =
              [$dCoercible_s5aAK] \r [eta_B1]
                  Data.Type.Coercion.$fEnumCoercion_$cenumFrom
                      $dCoercible_s5aAK eta_B1; } in
        let {
          sat_s5aAL [Occ=Once]
            :: GHC.Types.Int -> Data.Type.Coercion.Coercion a_a598Z b_a5990
          [LclId] =
              [$dCoercible_s5aAK] \r [eta_B1]
                  Data.Type.Coercion.$fEnumCoercion_$ctoEnum
                      $dCoercible_s5aAK eta_B1;
        } in 
          GHC.Enum.C:Enum [lvl4_r59Bf
                           lvl4_r59Bf
                           sat_s5aAL
                           lvl3_r59Be
                           sat_s5aAM
                           sat_s5aAN
                           sat_s5aAO
                           sat_s5aAP];

Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion
  :: forall k (a1 :: k) (a2 :: k) (b :: k).
     (a1 Data.Type.Equality.:~: a2)
     -> (a1 Data.Type.Equality.:~: b)
     -> GHC.Base.Maybe (Data.Type.Coercion.Coercion a2 b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_s5aAQ ds1_s5aAR]
        case ds_s5aAQ of {
          Data.Type.Equality.Refl ->
              case ds1_s5aAR of {
                Data.Type.Equality.Refl ->
                    let {
                      sat_s5aAU [Occ=Once] :: GHC.Types.Coercible a1_a598J b_a598K
                      [LclId] =
                          CCCS GHC.Types.MkCoercible! []; } in
                    let {
                      sat_s5aAV [Occ=Once]
                        :: Data.Type.Coercion.Coercion a1_a598J b_a598K
                      [LclId] =
                          CCCS Data.Type.Coercion.Coercion! [sat_s5aAU];
                    } in  GHC.Base.Just [sat_s5aAV];
              };
        };

Data.Type.Coercion.$fTestCoercionk:~: [InlPrag=INLINE (sat-args=0)]
  :: forall k (a :: k).
     Data.Type.Coercion.TestCoercion ((Data.Type.Equality.:~:) a)
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Type.Coercion.$fTestCoercionk:~:_$ctestCoercion eta_B2 eta_B1;

Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion
  :: forall k k1 (a1 :: k1) (a2 :: k) (b :: k).
     (a1 Data.Type.Equality.:~~: a2)
     -> (a1 Data.Type.Equality.:~~: b)
     -> GHC.Base.Maybe (Data.Type.Coercion.Coercion a2 b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)><S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_s5aAW ds1_s5aAX]
        case ds_s5aAW of {
          Data.Type.Equality.HRefl ->
              case ds1_s5aAX of {
                Data.Type.Equality.HRefl ->
                    let {
                      sat_s5aB0 [Occ=Once] :: GHC.Types.Coercible a1_a598n b_a598o
                      [LclId] =
                          CCCS GHC.Types.MkCoercible! []; } in
                    let {
                      sat_s5aB1 [Occ=Once]
                        :: Data.Type.Coercion.Coercion a1_a598n b_a598o
                      [LclId] =
                          CCCS Data.Type.Coercion.Coercion! [sat_s5aB0];
                    } in  GHC.Base.Just [sat_s5aB1];
              };
        };

Data.Type.Coercion.$fTestCoercionk:~~: [InlPrag=INLINE (sat-args=0)]
  :: forall k k1 (a :: k1).
     Data.Type.Coercion.TestCoercion ((Data.Type.Equality.:~~:) a)
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)><S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Type.Coercion.$fTestCoercionk:~~:_$ctestCoercion
            eta_B2 eta_B1;

Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion [InlPrag=NOUSERINLINE[0]]
  :: forall k (a1 :: k) (a2 :: k) (b :: k).
     Data.Type.Coercion.Coercion a1 a2
     -> Data.Type.Coercion.Coercion a1 b
     -> GHC.Base.Maybe (Data.Type.Coercion.Coercion a2 b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)),1*U(1*U(1*U))><S(S(S)),1*U(1*U(1*U))>m2,
 Unf=OtherCon []] =
    [] \r [w_s5aB2 w1_s5aB3]
        case w_s5aB2 of {
          Data.Type.Coercion.Coercion ww1_s5aB5 [Occ=Once] ->
              case w1_s5aB3 of {
                Data.Type.Coercion.Coercion ww3_s5aB7 [Occ=Once] ->
                    case GHC.Types.coercible_sel ww1_s5aB5 of {
                      (##) ->
                          case GHC.Types.coercible_sel ww3_s5aB7 of {
                            (##) ->
                                let {
                                  sat_s5aB8 [Occ=Once] :: GHC.Types.Coercible a1_s59qs b_s59qt
                                  [LclId] =
                                      CCCS GHC.Types.MkCoercible! []; } in
                                let {
                                  sat_s5aB9 [Occ=Once]
                                    :: Data.Type.Coercion.Coercion a1_s59qs b_s59qt
                                  [LclId] =
                                      CCCS Data.Type.Coercion.Coercion! [sat_s5aB8];
                                } in  GHC.Base.Just [sat_s5aB9];
                          };
                    };
              };
        };

Data.Type.Coercion.$fTestCoercionkCoercion [InlPrag=INLINE (sat-args=0)]
  :: forall k (a :: k).
     Data.Type.Coercion.TestCoercion (Data.Type.Coercion.Coercion a)
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)),1*U(1*U(1*U))><S(S(S)),1*U(1*U(1*U))>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Type.Coercion.$fTestCoercionkCoercion_$ctestCoercion
            eta_B2 eta_B1;

Data.Type.Coercion.$fEqCoercion_$c==
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [ds_s5aBa ds1_s5aBb]
        case ds_s5aBa of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case ds1_s5aBb of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.True [];
              };
        };

Data.Type.Coercion.$fEqCoercion_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [eta_s5aBg eta1_s5aBh]
        case eta_s5aBg of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case eta1_s5aBh of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.False [];
              };
        };

Data.Type.Coercion.$fEqCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Classes.Eq (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [Data.Type.Coercion.$fEqCoercion_$c==
                                     Data.Type.Coercion.$fEqCoercion_$c/=];

Data.Type.Coercion.$fReadCoercion3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Coercion"#;

Data.Type.Coercion.$fReadCoercion2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Type.Coercion.$fReadCoercion3;

Data.Type.Coercion.$fShowCoercion_$cshowsPrec
  :: forall k (a :: k) (b :: k).
     GHC.Types.Int -> Data.Type.Coercion.Coercion a b -> GHC.Show.ShowS
[GblId, Arity=3, Str=<L,A><S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s5aBm ds1_s5aBn eta_s5aBo]
        case ds1_s5aBn of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              GHC.Base.++ Data.Type.Coercion.$fReadCoercion2 eta_s5aBo;
        };

Data.Type.Coercion.$fShowCoercion_$cshow
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b -> GHC.Base.String
[GblId, Arity=1, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [x_s5aBr]
        case x_s5aBr of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              Data.Type.Coercion.$fReadCoercion2;
        };

Data.Type.Coercion.$fShowCoercion1
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s5aBu eta_s5aBv]
        case ds_s5aBu of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              GHC.Base.++ Data.Type.Coercion.$fReadCoercion2 eta_s5aBv;
        };

Data.Type.Coercion.$fShowCoercion_$cshowList
  :: forall k (a :: k) (b :: k).
     [Data.Type.Coercion.Coercion a b] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s5aBy s_s5aBz]
        GHC.Show.showList__
            Data.Type.Coercion.$fShowCoercion1 ls_s5aBy s_s5aBz;

Data.Type.Coercion.$fShowCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Show.Show (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Type.Coercion.$fShowCoercion_$cshowsPrec
                                    Data.Type.Coercion.$fShowCoercion_$cshow
                                    Data.Type.Coercion.$fShowCoercion_$cshowList];

Data.Type.Coercion.$fOrdCoercion_$c<
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s5aBA b1_s5aBB]
        case a1_s5aBA of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case b1_s5aBB of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.False [];
              };
        };

Data.Type.Coercion.$fOrdCoercion_$ccompare
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s5aBG b1_s5aBH]
        case a1_s5aBG of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case b1_s5aBH of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.EQ [];
              };
        };

Data.Type.Coercion.$fOrdCoercion_$c<=
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s5aBM b1_s5aBN]
        case b1_s5aBN of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case a1_s5aBM of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.True [];
              };
        };

Data.Type.Coercion.$fOrdCoercion_$cmax
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [x_s5aBS y_s5aBT]
        case x_s5aBS of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] -> y_s5aBT;
        };

Data.Type.Coercion.$fOrdCoercion_$c>
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s5aBW b1_s5aBX]
        case b1_s5aBX of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] ->
              case a1_s5aBW of {
                Data.Type.Coercion.Coercion _ [Occ=Dead] -> GHC.Types.False [];
              };
        };

Data.Type.Coercion.$fOrdCoercion_$cmin
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [x_s5aC2 y_s5aC3]
        case y_s5aC3 of {
          Data.Type.Coercion.Coercion _ [Occ=Dead] -> x_s5aC2;
        };

Data.Type.Coercion.$fOrdCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Classes.Ord (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Type.Coercion.$fEqCoercion
                                      Data.Type.Coercion.$fOrdCoercion_$ccompare
                                      Data.Type.Coercion.$fOrdCoercion_$c<
                                      Data.Type.Coercion.$fOrdCoercion_$c<=
                                      Data.Type.Coercion.$fOrdCoercion_$c>
                                      Data.Type.Coercion.$fEqCoercion_$c==
                                      Data.Type.Coercion.$fOrdCoercion_$cmax
                                      Data.Type.Coercion.$fOrdCoercion_$cmin];

Data.Type.Coercion.$fReadCoercion_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Type.Coercion.$fReadCoercion2];

Data.Type.Coercion.$fReadCoercion1
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Data.Type.Coercion.Coercion a b
         -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []] =
    [] \r [$dCoercible_s5aC6 eta_s5aC7 eta1_s5aC8]
        let {
          x_s5aC9 [Occ=OnceL] :: Data.Type.Coercion.Coercion a_a595J b_a595K
          [LclId, Unf=OtherCon []] =
              CCCS Data.Type.Coercion.Coercion! [$dCoercible_s5aC6]; } in
        let {
          sat_s5aCg [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Type.Coercion.Coercion a_a595J b_a595K)
          [LclId] =
              [x_s5aC9] \r [n_s5aCa eta2_s5aCb]
                  let {
                    sat_s5aCd [Occ=Once]
                      :: () -> Text.ParserCombinators.ReadP.P b2_X3ngt
                    [LclId] =
                        [x_s5aC9 eta2_s5aCb] \r [a1_s5aCc] eta2_s5aCb x_s5aC9;
                  } in 
                    case
                        Text.Read.Lex.$wexpect
                            Data.Type.Coercion.$fReadCoercion_lexeme sat_s5aCd
                    of
                    { Unit# ww1_s5aCf [Occ=Once] ->
                          Text.ParserCombinators.ReadP.Look [ww1_s5aCf];
                    };
        } in  GHC.Read.list3 sat_s5aCg eta_s5aC7 eta1_s5aC8;

Data.Type.Coercion.$fReadCoercion_$creadsPrec
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Type.Coercion.Coercion a b)
[GblId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
    [] \r [$dCoercible_s5aCh n_s5aCi]
        let {
          sat_s5aCj [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 (Data.Type.Coercion.Coercion a_X597h b_X597j)
          [LclId] =
              [$dCoercible_s5aCh n_s5aCi] \u []
                  Data.Type.Coercion.$fReadCoercion1
                      $dCoercible_s5aCh
                      n_s5aCi
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s5aCj;

Data.Type.Coercion.$fReadCoercion_$creadListPrec
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Type.Coercion.Coercion a b]
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dCoercible_s5aCk]
        let {
          sat_s5aCl [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Type.Coercion.Coercion a_X597f b_X597h)
          [LclId] =
              [$dCoercible_s5aCk] \r [eta_B2 eta_B1]
                  Data.Type.Coercion.$fReadCoercion1 $dCoercible_s5aCk eta_B2 eta_B1;
        } in  GHC.Read.list sat_s5aCl;

Data.Type.Coercion.$fReadCoercion_$creadList
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Type.Coercion.Coercion a b]
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dCoercible_s5aCm]
        let {
          sat_s5aCo [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Type.Coercion.Coercion a_X597g b_X597i]
          [LclId] =
              [$dCoercible_s5aCm] \u []
                  let {
                    sat_s5aCn [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Type.Coercion.Coercion a_X597g b_X597i)
                    [LclId] =
                        [$dCoercible_s5aCm] \r [eta_B2 eta_B1]
                            Data.Type.Coercion.$fReadCoercion1 $dCoercible_s5aCm eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_s5aCn
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s5aCo;

Data.Type.Coercion.$fReadCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     GHC.Read.Read (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Arity=1, Str=<L,U>m] =
    [] \r [$dCoercible_s5aCp]
        let {
          sat_s5aCt [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Type.Coercion.Coercion a_X597e b_X597g]
          [LclId] =
              [$dCoercible_s5aCp] \u []
                  Data.Type.Coercion.$fReadCoercion_$creadListPrec
                      $dCoercible_s5aCp; } in
        let {
          sat_s5aCs [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Type.Coercion.Coercion a_X597e b_X597g)
          [LclId] =
              [$dCoercible_s5aCp] \r [eta_B2 eta_B1]
                  Data.Type.Coercion.$fReadCoercion1
                      $dCoercible_s5aCp eta_B2 eta_B1; } in
        let {
          sat_s5aCr [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Type.Coercion.Coercion a_X597e b_X597g]
          [LclId] =
              [$dCoercible_s5aCp] \u []
                  Data.Type.Coercion.$fReadCoercion_$creadList
                      $dCoercible_s5aCp; } in
        let {
          sat_s5aCq [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Type.Coercion.Coercion a_X597e b_X597g)
          [LclId] =
              [$dCoercible_s5aCp] \r [eta_B1]
                  Data.Type.Coercion.$fReadCoercion_$creadsPrec
                      $dCoercible_s5aCp eta_B1;
        } in  GHC.Read.C:Read [sat_s5aCq sat_s5aCr sat_s5aCs sat_s5aCt];

Data.Type.Coercion.$fBoundedCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     GHC.Enum.Bounded (Data.Type.Coercion.Coercion a b)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U>m] =
    [] \r [$dCoercible_s5aCu]
        let {
          sat_s5aCw [Occ=Once] :: Data.Type.Coercion.Coercion a_a595n b_a595o
          [LclId] =
              CCCS Data.Type.Coercion.Coercion! [$dCoercible_s5aCu];
        } in  GHC.Enum.C:Bounded [sat_s5aCw sat_s5aCw];

Data.Type.Coercion.coerceWith
  :: forall a b. Data.Type.Coercion.Coercion a b -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5aCx x_s5aCy]
        case ds_s5aCx of {
          Data.Type.Coercion.Coercion $dCoercible_s5aCA [Occ=Once!] ->
              case $dCoercible_s5aCA of { GHC.Types.MkCoercible -> x_s5aCy; };
        };

Data.Type.Coercion.gcoerceWith
  :: forall k0 (a :: k0) (b :: k0) r.
     Data.Type.Coercion.Coercion a b
     -> (GHC.Types.Coercible a b => r) -> r
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s5aCC x_s5aCD]
        case ds_s5aCC of {
          Data.Type.Coercion.Coercion $dCoercible_s5aCF [Occ=Once] ->
              x_s5aCD $dCoercible_s5aCF;
        };

Data.Type.Coercion.sym
  :: forall k (a :: k) (b :: k).
     Data.Type.Coercion.Coercion a b -> Data.Type.Coercion.Coercion b a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(S)),1*U(1*U(1*U))>m,
 Unf=OtherCon []] =
    [] \r [ds_s5aCG]
        case ds_s5aCG of {
          Data.Type.Coercion.Coercion $dCoercible_s5aCI [Occ=Once] ->
              case GHC.Types.coercible_sel $dCoercible_s5aCI of {
                (##) ->
                    let {
                      sat_s5aCJ [Occ=Once] :: GHC.Types.Coercible b_a594U a_a594T
                      [LclId] =
                          CCCS GHC.Types.MkCoercible! [];
                    } in  Data.Type.Coercion.Coercion [sat_s5aCJ];
              };
        };

Data.Type.Coercion.trans
  :: forall k (a :: k) (b :: k) (c :: k).
     Data.Type.Coercion.Coercion a b
     -> Data.Type.Coercion.Coercion b c
     -> Data.Type.Coercion.Coercion a c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S)),1*U(1*U(1*U))><S(S(S)),1*U(1*U(1*U))>m,
 Unf=OtherCon []] =
    [] \r [ds_s5aCK ds1_s5aCL]
        case ds_s5aCK of {
          Data.Type.Coercion.Coercion $dCoercible_s5aCN [Occ=Once] ->
              case GHC.Types.coercible_sel $dCoercible_s5aCN of {
                (##) ->
                    case ds1_s5aCL of {
                      Data.Type.Coercion.Coercion $dCoercible1_s5aCP [Occ=Once] ->
                          case GHC.Types.coercible_sel $dCoercible1_s5aCP of {
                            (##) ->
                                let {
                                  sat_s5aCQ [Occ=Once] :: GHC.Types.Coercible a_a594F c_a594H
                                  [LclId] =
                                      CCCS GHC.Types.MkCoercible! [];
                                } in  Data.Type.Coercion.Coercion [sat_s5aCQ];
                          };
                    };
              };
        };

Data.Type.Coercion.repr
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b) -> Data.Type.Coercion.Coercion a b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U(U)>m, Unf=OtherCon []] =
    [] \r [ds_s5aCR]
        case ds_s5aCR of {
          Data.Type.Equality.Refl ->
              let {
                sat_s5aCT [Occ=Once] :: GHC.Types.Coercible a_a594u b_a594v
                [LclId] =
                    CCCS GHC.Types.MkCoercible! [];
              } in  Data.Type.Coercion.Coercion [sat_s5aCT];
        };

Data.Type.Coercion.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Type.Coercion.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Coercion.$trModule4];

Data.Type.Coercion.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Type.Coercion"#;

Data.Type.Coercion.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Coercion.$trModule2];

Data.Type.Coercion.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Type.Coercion.$trModule3
                                     Data.Type.Coercion.$trModule1];

$krep_r59Bg :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

$krep1_r59Bh :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_r59Bi :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r59Bh
                                         GHC.Types.krep$*];

Data.Type.Coercion.$tcCoercion1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r59Bh $krep2_r59Bi];

Data.Type.Coercion.$tcTestCoercion1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r59Bi $krep_r59Bg];

$krep3_r59Bj :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep4_r59Bk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep5_r59Bl :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r59Bj GHC.Types.[]];

$krep6_r59Bm :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_r59Bk $krep5_r59Bl];

$krep7_r59Bn :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r59Bh $krep6_r59Bm];

$krep8_r59Bo :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcCoercible
                                              $krep7_r59Bn];

Data.Type.Coercion.$tcCoercion2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Coercion.$fReadCoercion3];

Data.Type.Coercion.$tcCoercion :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14885566513674463733##
                                    8268940906925368652##
                                    Data.Type.Coercion.$trModule
                                    Data.Type.Coercion.$tcCoercion2
                                    1#
                                    Data.Type.Coercion.$tcCoercion1];

$krep9_r59Bp :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Type.Coercion.$tcCoercion
                                              $krep7_r59Bn];

Data.Type.Coercion.$tc'Coercion1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep8_r59Bo $krep9_r59Bp];

Data.Type.Coercion.$tc'Coercion3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Coercion"#;

Data.Type.Coercion.$tc'Coercion2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Coercion.$tc'Coercion3];

Data.Type.Coercion.$tc'Coercion :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16177208673276072700##
                                    13187043378465993605##
                                    Data.Type.Coercion.$trModule
                                    Data.Type.Coercion.$tc'Coercion2
                                    3#
                                    Data.Type.Coercion.$tc'Coercion1];

Data.Type.Coercion.$tcTestCoercion3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "TestCoercion"#;

Data.Type.Coercion.$tcTestCoercion2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Coercion.$tcTestCoercion3];

Data.Type.Coercion.$tcTestCoercion :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14520160333183018944##
                                    2439357669602544154##
                                    Data.Type.Coercion.$trModule
                                    Data.Type.Coercion.$tcTestCoercion2
                                    1#
                                    Data.Type.Coercion.$tcTestCoercion1];

Data.Type.Coercion.Coercion
  :: forall k (a :: k) (b :: k).
     GHC.Types.Coercible a b =>
     Data.Type.Coercion.Coercion a b
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Type.Coercion.Coercion [eta_B1];

