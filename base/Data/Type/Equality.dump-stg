
==================== Pre unarise: ====================
2018-03-16 16:00:01.495719775 UTC

Data.Type.Equality.$p1~ [InlPrag=INLINE]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a :: k) GHC.Types.~~ (b :: k)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_s568s] v_s568s;

Data.Type.Equality.testEquality [InlPrag=INLINE]
  :: forall k (f :: k -> *).
     Data.Type.Equality.TestEquality f =>
     forall (a :: k) (b :: k).
     f a -> f b -> GHC.Base.Maybe (a Data.Type.Equality.:~: b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_s568t] v_s568t;

Data.Type.Equality.$WHRefl [InlPrag=INLINE[2]]
  :: forall k2 (a :: k2). a Data.Type.Equality.:~~: a
[GblId[DataConWrapper], Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Type.Equality.HRefl! [GHC.Prim.coercionToken#
                                             GHC.Prim.coercionToken#];

Data.Type.Equality.$WRefl [InlPrag=INLINE[2]]
  :: forall k (a :: k). a Data.Type.Equality.:~: a
[GblId[DataConWrapper], Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Type.Equality.Refl! [GHC.Prim.coercionToken#];

Data.Type.Equality.$f~kab_$cp1~
  :: forall k (a :: k) (b :: k).
     ((a :: k) GHC.Types.~~ (b :: k)) =>
     (a :: k) GHC.Types.~~ (b :: k)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S(S),U(U)>, Unf=OtherCon []] =
    [] \r [$d~~_s568u]
        case GHC.Types.heq_sel $d~~_s568u of { __DEFAULT -> $d~~_s568u; };

Data.Type.Equality.$f~kab [InlPrag=INLINE (sat-args=0)]
  :: forall k (a :: k) (b :: k).
     ((a :: k) GHC.Types.~~ (b :: k)) =>
     (a :: k) Data.Type.Equality.~ (b :: k)
[GblId[DFunId(nt)],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),U(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Type.Equality.$f~kab_$cp1~ eta_B1;

Data.Type.Equality.$fEnum:~:3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Type.Equality.$fEnum:~:_$cfromEnum
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b) -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [$d~_s568v eta_s568w]
        case GHC.Types.heq_sel $d~_s568v of {
          __DEFAULT ->
              case eta_s568w of {
                Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
                    Data.Type.Equality.$fEnum:~:3;
              };
        };

lvl_r5689 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Type.Equality.toEnum: bad argument"#;

Data.Type.Equality.$fEnum:~:1
  :: forall k (a :: k) (b :: k). a Data.Type.Equality.:~: b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_r5689 of sat_s568y {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s568y;
        };

Data.Type.Equality.$fEnum:~:_$ctoEnum
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     GHC.Types.Int -> a Data.Type.Equality.:~: b
[GblId,
 Arity=2,
 Str=<S(S),1*U(1*U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [$d~_s568z eta_s568A]
        case GHC.Types.heq_sel $d~_s568z of {
          __DEFAULT ->
              case eta_s568A of {
                GHC.Types.I# ds_s568C [Occ=Once!] ->
                    case ds_s568C of {
                      __DEFAULT -> Data.Type.Equality.$fEnum:~:1;
                      0# -> Data.Type.Equality.$WRefl;
                    };
              };
        };

Data.Type.Equality.$fEnum:~:_$csucc
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b) -> a Data.Type.Equality.:~: b
[GblId, Arity=2, Str=<B,U(U)><B,A>x, Unf=OtherCon []] =
    [] \r [$d~_s568E eta_s568F]
        case GHC.Types.heq_sel $d~_s568E of {
          __DEFAULT ->
              case GHC.Types.heq_sel $d~_s568E of {
                __DEFAULT -> Data.Type.Equality.$fEnum:~:1;
              };
        };

Data.Type.Equality.$w$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=3, Str=<S(S),U(U)><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s568G w1_s568H w2_s568I]
        case GHC.Types.heq_sel w_s568G of {
          __DEFAULT ->
              case GHC.Types.heq_sel w_s568G of {
                __DEFAULT ->
                    let {
                      go_s568J [Occ=LoopBreaker]
                        :: GHC.Prim.Int# -> [a_s55JT Data.Type.Equality.:~: b_s55JU]
                      [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                          sat-only [go_s568J] \r [x_s568K]
                              let {
                                sat_s568P [Occ=Once] :: [a_s55JT Data.Type.Equality.:~: b_s55JU]
                                [LclId] =
                                    [go_s568J x_s568K] \u []
                                        case x_s568K of wild_s568N {
                                          __DEFAULT ->
                                              case +# [wild_s568N 1#] of sat_s568O {
                                                __DEFAULT -> go_s568J sat_s568O;
                                              };
                                          0# -> [] [];
                                        }; } in
                              let {
                                sat_s568M [Occ=Once] :: a_s55JT Data.Type.Equality.:~: b_s55JU
                                [LclId] =
                                    [x_s568K] \u []
                                        case x_s568K of {
                                          __DEFAULT -> Data.Type.Equality.$fEnum:~:1;
                                          0# -> Data.Type.Equality.$WRefl;
                                        };
                              } in  : [sat_s568M sat_s568P];
                    } in  go_s568J 0#;
              };
        };

Data.Type.Equality.$fEnum:~:_$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=3, Str=<S(S),U(U)><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s568Q w1_s568R w2_s568S]
        case w1_s568R of w3_s568T {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              case w2_s568S of w4_s568U {
                Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
                    Data.Type.Equality.$w$cenumFromTo w_s568Q w3_s568T w4_s568U;
              };
        };

Data.Type.Equality.$fEnum:~:2 :: [GHC.Types.Int]
[GblId] =
    [] \u [] GHC.Enum.efdInt 0# 0#;

Data.Type.Equality.$w$cenumFromThen [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=3, Str=<S(S),U(U)><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s568V w1_s568W w2_s568X]
        case GHC.Types.heq_sel w_s568V of {
          __DEFAULT ->
              case GHC.Types.heq_sel w_s568V of {
                __DEFAULT ->
                    let {
                      sat_s568Y [Occ=Once]
                        :: GHC.Types.Int -> a_s55K0 Data.Type.Equality.:~: b_s55K1
                      [LclId] =
                          [w_s568V] \r [eta_B1]
                              Data.Type.Equality.$fEnum:~:_$ctoEnum w_s568V eta_B1;
                    } in  GHC.Base.map sat_s568Y Data.Type.Equality.$fEnum:~:2;
              };
        };

Data.Type.Equality.$fEnum:~:_$cenumFromThen [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=3, Str=<S(S),U(U)><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s568Z w1_s5690 w2_s5691]
        case w1_s5690 of w3_s5692 {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              case w2_s5691 of w4_s5693 {
                Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
                    Data.Type.Equality.$w$cenumFromThen w_s568Z w3_s5692 w4_s5693;
              };
        };

Data.Type.Equality.$w$cenumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=2, Str=<S(S),U(U)><L,A>, Unf=OtherCon []] =
    [] \r [w_s5694 w1_s5695]
        case GHC.Types.heq_sel w_s5694 of {
          __DEFAULT ->
              case GHC.Types.heq_sel w_s5694 of {
                __DEFAULT ->
                    let {
                      go_s5696 [Occ=LoopBreaker]
                        :: GHC.Prim.Int# -> [a_s55K8 Data.Type.Equality.:~: b_s55K9]
                      [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                          sat-only [go_s5696] \r [x_s5697]
                              let {
                                sat_s569c [Occ=Once] :: [a_s55K8 Data.Type.Equality.:~: b_s55K9]
                                [LclId] =
                                    [go_s5696 x_s5697] \u []
                                        case x_s5697 of wild_s569a {
                                          __DEFAULT ->
                                              case +# [wild_s569a 1#] of sat_s569b {
                                                __DEFAULT -> go_s5696 sat_s569b;
                                              };
                                          9223372036854775807# -> [] [];
                                        }; } in
                              let {
                                sat_s5699 [Occ=Once] :: a_s55K8 Data.Type.Equality.:~: b_s55K9
                                [LclId] =
                                    [x_s5697] \u []
                                        case x_s5697 of {
                                          __DEFAULT -> Data.Type.Equality.$fEnum:~:1;
                                          0# -> Data.Type.Equality.$WRefl;
                                        };
                              } in  : [sat_s5699 sat_s569c];
                    } in  go_s5696 0#;
              };
        };

Data.Type.Equality.$fEnum:~:_$cenumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=2, Str=<S(S),U(U)><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s569d w1_s569e]
        case w1_s569e of w2_s569f {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              Data.Type.Equality.$w$cenumFrom w_s569d w2_s569f;
        };

Data.Type.Equality.$w$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b)
     -> (# a Data.Type.Equality.:~: b, [a Data.Type.Equality.:~: b] #)
[GblId, Arity=4, Str=<S(S),U(U)><L,A><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s569g w1_s569h w2_s569i w3_s569j]
        case GHC.Types.heq_sel w_s569g of {
          __DEFAULT ->
              case GHC.Types.heq_sel w_s569g of {
                __DEFAULT ->
                    let {
                      sat_s569s [Occ=Once] :: [a_s55Kk Data.Type.Equality.:~: b_s55Kl]
                      [LclId] =
                          [] \u []
                              let {
                                go_up_s569k [Occ=LoopBreaker]
                                  :: GHC.Prim.Int# -> [a_s55Kk Data.Type.Equality.:~: b_s55Kl]
                                [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                    sat-only [go_up_s569k] \r [x_s569l]
                                        case ># [x_s569l 0#] of {
                                          __DEFAULT ->
                                              let {
                                                sat_s569p [Occ=Once]
                                                  :: [a_s55Kk Data.Type.Equality.:~: b_s55Kl]
                                                [LclId] =
                                                    [go_up_s569k x_s569l] \u []
                                                        go_up_s569k x_s569l; } in
                                              let {
                                                sat_s569o [Occ=Once]
                                                  :: a_s55Kk Data.Type.Equality.:~: b_s55Kl
                                                [LclId] =
                                                    [x_s569l] \u []
                                                        case x_s569l of {
                                                          __DEFAULT ->
                                                              Data.Type.Equality.$fEnum:~:1;
                                                          0# -> Data.Type.Equality.$WRefl;
                                                        };
                                              } in  : [sat_s569o sat_s569p];
                                          1# ->
                                              let {
                                                sat_s569r [Occ=Once]
                                                  :: a_s55Kk Data.Type.Equality.:~: b_s55Kl
                                                [LclId] =
                                                    [x_s569l] \u []
                                                        case x_s569l of {
                                                          __DEFAULT ->
                                                              Data.Type.Equality.$fEnum:~:1;
                                                          0# -> Data.Type.Equality.$WRefl;
                                                        };
                                              } in  : [sat_s569r GHC.Types.[]];
                                        };
                              } in  go_up_s569k 0#;
                    } in  (#,#) [Data.Type.Equality.$WRefl sat_s569s];
              };
        };

Data.Type.Equality.$fEnum:~:_$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b)
     -> [a Data.Type.Equality.:~: b]
[GblId,
 Arity=4,
 Str=<S(S),U(U)><S,1*H><S,1*H><S,1*H>m2,
 Unf=OtherCon []] =
    [] \r [w_s569t w1_s569u w2_s569v w3_s569w]
        case w1_s569u of w4_s569x {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              case w2_s569v of w5_s569y {
                Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
                    case w3_s569w of w6_s569z {
                      Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
                          case
                              Data.Type.Equality.$w$cenumFromThenTo
                                  w_s569t w4_s569x w5_s569y w6_s569z
                          of
                          { (#,#) ww1_s569B [Occ=Once] ww2_s569C [Occ=Once] ->
                                : [ww1_s569B ww2_s569C];
                          };
                    };
              };
        };

Data.Type.Equality.$fEnum:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     GHC.Enum.Enum (a Data.Type.Equality.:~: b)
[GblId[DFunId], Arity=1, Str=<L,U(U)>m] =
    [] \r [$d~_s569D]
        let {
          sat_s569L [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> [a_a5560 Data.Type.Equality.:~: b_a5561]
          [LclId] =
              [$d~_s569D] \r [eta_B3 eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~:_$cenumFromThenTo
                      $d~_s569D eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s569K [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> [a_a5560 Data.Type.Equality.:~: b_a5561]
          [LclId] =
              [$d~_s569D] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~:_$cenumFromTo
                      $d~_s569D eta_B2 eta_B1; } in
        let {
          sat_s569J [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> [a_a5560 Data.Type.Equality.:~: b_a5561]
          [LclId] =
              [$d~_s569D] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~:_$cenumFromThen
                      $d~_s569D eta_B2 eta_B1; } in
        let {
          sat_s569I [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> [a_a5560 Data.Type.Equality.:~: b_a5561]
          [LclId] =
              [$d~_s569D] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~:_$cenumFrom $d~_s569D eta_B1; } in
        let {
          sat_s569H [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561) -> GHC.Types.Int
          [LclId] =
              [$d~_s569D] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~:_$cfromEnum $d~_s569D eta_B1; } in
        let {
          sat_s569G [Occ=Once]
            :: GHC.Types.Int -> a_a5560 Data.Type.Equality.:~: b_a5561
          [LclId] =
              [$d~_s569D] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~:_$ctoEnum $d~_s569D eta_B1; } in
        let {
          sat_s569F [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> a_a5560 Data.Type.Equality.:~: b_a5561
          [LclId] =
              [$d~_s569D] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~:_$csucc $d~_s569D eta_B1; } in
        let {
          sat_s569E [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> a_a5560 Data.Type.Equality.:~: b_a5561
          [LclId] =
              [$d~_s569D] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~:_$csucc $d~_s569D eta_B1;
        } in 
          GHC.Enum.C:Enum [sat_s569E
                           sat_s569F
                           sat_s569G
                           sat_s569H
                           sat_s569I
                           sat_s569J
                           sat_s569K
                           sat_s569L];

Data.Type.Equality.$fEnum:~~:_$cfromEnum
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b) -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [$d~~_s569M eta_s569N]
        case GHC.Types.heq_sel $d~~_s569M of {
          __DEFAULT ->
              case eta_s569N of {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                         _ [Occ=Dead, Dmd=<L,A>] ->
                    Data.Type.Equality.$fEnum:~:3;
              };
        };

Data.Type.Equality.$fEnum:~~:1
  :: forall k1 (a :: k1) k2 (b :: k2). a Data.Type.Equality.:~~: b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_r5689 of sat_s569P {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s569P;
        };

Data.Type.Equality.$fEnum:~~:_$ctoEnum
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     GHC.Types.Int -> a Data.Type.Equality.:~~: b
[GblId,
 Arity=2,
 Str=<S(S),1*U(1*U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [$d~~_s569Q eta_s569R]
        case GHC.Types.heq_sel $d~~_s569Q of {
          __DEFAULT ->
              case eta_s569R of {
                GHC.Types.I# ds_s569T [Occ=Once!] ->
                    case ds_s569T of {
                      __DEFAULT -> Data.Type.Equality.$fEnum:~~:1;
                      0# -> Data.Type.Equality.$WHRefl;
                    };
              };
        };

Data.Type.Equality.$fEnum:~~:_$csucc
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b) -> a Data.Type.Equality.:~~: b
[GblId, Arity=2, Str=<B,U(U)><B,A>x, Unf=OtherCon []] =
    [] \r [$d~~_s569V eta_s569W]
        case GHC.Types.heq_sel $d~~_s569V of {
          __DEFAULT ->
              case GHC.Types.heq_sel $d~~_s569V of {
                __DEFAULT -> Data.Type.Equality.$fEnum:~~:1;
              };
        };

Data.Type.Equality.$w$cenumFromTo1 [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=3, Str=<S(S),U(U)><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s569X w1_s569Y w2_s569Z]
        case GHC.Types.heq_sel w_s569X of {
          __DEFAULT ->
              case GHC.Types.heq_sel w_s569X of {
                __DEFAULT ->
                    let {
                      go_s56a0 [Occ=LoopBreaker]
                        :: GHC.Prim.Int# -> [a_s55KD Data.Type.Equality.:~~: b_s55KE]
                      [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                          sat-only [go_s56a0] \r [x_s56a1]
                              let {
                                sat_s56a6 [Occ=Once] :: [a_s55KD Data.Type.Equality.:~~: b_s55KE]
                                [LclId] =
                                    [go_s56a0 x_s56a1] \u []
                                        case x_s56a1 of wild_s56a4 {
                                          __DEFAULT ->
                                              case +# [wild_s56a4 1#] of sat_s56a5 {
                                                __DEFAULT -> go_s56a0 sat_s56a5;
                                              };
                                          0# -> [] [];
                                        }; } in
                              let {
                                sat_s56a3 [Occ=Once] :: a_s55KD Data.Type.Equality.:~~: b_s55KE
                                [LclId] =
                                    [x_s56a1] \u []
                                        case x_s56a1 of {
                                          __DEFAULT -> Data.Type.Equality.$fEnum:~~:1;
                                          0# -> Data.Type.Equality.$WHRefl;
                                        };
                              } in  : [sat_s56a3 sat_s56a6];
                    } in  go_s56a0 0#;
              };
        };

Data.Type.Equality.$fEnum:~~:_$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=3, Str=<S(S),U(U)><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s56a7 w1_s56a8 w2_s56a9]
        case w1_s56a8 of w3_s56aa {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              case w2_s56a9 of w4_s56ab {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                         _ [Occ=Dead, Dmd=<L,A>] ->
                    Data.Type.Equality.$w$cenumFromTo1 w_s56a7 w3_s56aa w4_s56ab;
              };
        };

Data.Type.Equality.$w$cenumFromThen1 [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=3, Str=<S(S),U(U)><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s56ac w1_s56ad w2_s56ae]
        case GHC.Types.heq_sel w_s56ac of {
          __DEFAULT ->
              case GHC.Types.heq_sel w_s56ac of {
                __DEFAULT ->
                    let {
                      sat_s56af [Occ=Once]
                        :: GHC.Types.Int -> a_s55KL Data.Type.Equality.:~~: b_s55KM
                      [LclId] =
                          [w_s56ac] \r [eta_B1]
                              Data.Type.Equality.$fEnum:~~:_$ctoEnum w_s56ac eta_B1;
                    } in  GHC.Base.map sat_s56af Data.Type.Equality.$fEnum:~:2;
              };
        };

Data.Type.Equality.$fEnum:~~:_$cenumFromThen [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=3, Str=<S(S),U(U)><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s56ag w1_s56ah w2_s56ai]
        case w1_s56ah of w3_s56aj {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              case w2_s56ai of w4_s56ak {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                         _ [Occ=Dead, Dmd=<L,A>] ->
                    Data.Type.Equality.$w$cenumFromThen1 w_s56ag w3_s56aj w4_s56ak;
              };
        };

Data.Type.Equality.$w$cenumFrom1 [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=2, Str=<S(S),U(U)><L,A>, Unf=OtherCon []] =
    [] \r [w_s56al w1_s56am]
        case GHC.Types.heq_sel w_s56al of {
          __DEFAULT ->
              case GHC.Types.heq_sel w_s56al of {
                __DEFAULT ->
                    let {
                      go_s56an [Occ=LoopBreaker]
                        :: GHC.Prim.Int# -> [a_s55KU Data.Type.Equality.:~~: b_s55KV]
                      [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                          sat-only [go_s56an] \r [x_s56ao]
                              let {
                                sat_s56at [Occ=Once] :: [a_s55KU Data.Type.Equality.:~~: b_s55KV]
                                [LclId] =
                                    [go_s56an x_s56ao] \u []
                                        case x_s56ao of wild_s56ar {
                                          __DEFAULT ->
                                              case +# [wild_s56ar 1#] of sat_s56as {
                                                __DEFAULT -> go_s56an sat_s56as;
                                              };
                                          9223372036854775807# -> [] [];
                                        }; } in
                              let {
                                sat_s56aq [Occ=Once] :: a_s55KU Data.Type.Equality.:~~: b_s55KV
                                [LclId] =
                                    [x_s56ao] \u []
                                        case x_s56ao of {
                                          __DEFAULT -> Data.Type.Equality.$fEnum:~~:1;
                                          0# -> Data.Type.Equality.$WHRefl;
                                        };
                              } in  : [sat_s56aq sat_s56at];
                    } in  go_s56an 0#;
              };
        };

Data.Type.Equality.$fEnum:~~:_$cenumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=2, Str=<S(S),U(U)><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s56au w1_s56av]
        case w1_s56av of w2_s56aw {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              Data.Type.Equality.$w$cenumFrom1 w_s56au w2_s56aw;
        };

Data.Type.Equality.$w$cenumFromThenTo1 [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b)
     -> (# a Data.Type.Equality.:~~: b, [a Data.Type.Equality.:~~: b] #)
[GblId, Arity=4, Str=<S(S),U(U)><L,A><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s56ax w1_s56ay w2_s56az w3_s56aA]
        case GHC.Types.heq_sel w_s56ax of {
          __DEFAULT ->
              case GHC.Types.heq_sel w_s56ax of {
                __DEFAULT ->
                    let {
                      sat_s56aJ [Occ=Once] :: [a_s55L8 Data.Type.Equality.:~~: b_s55L9]
                      [LclId] =
                          [] \u []
                              let {
                                go_up_s56aB [Occ=LoopBreaker]
                                  :: GHC.Prim.Int# -> [a_s55L8 Data.Type.Equality.:~~: b_s55L9]
                                [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                    sat-only [go_up_s56aB] \r [x_s56aC]
                                        case ># [x_s56aC 0#] of {
                                          __DEFAULT ->
                                              let {
                                                sat_s56aG [Occ=Once]
                                                  :: [a_s55L8 Data.Type.Equality.:~~: b_s55L9]
                                                [LclId] =
                                                    [go_up_s56aB x_s56aC] \u []
                                                        go_up_s56aB x_s56aC; } in
                                              let {
                                                sat_s56aF [Occ=Once]
                                                  :: a_s55L8 Data.Type.Equality.:~~: b_s55L9
                                                [LclId] =
                                                    [x_s56aC] \u []
                                                        case x_s56aC of {
                                                          __DEFAULT ->
                                                              Data.Type.Equality.$fEnum:~~:1;
                                                          0# -> Data.Type.Equality.$WHRefl;
                                                        };
                                              } in  : [sat_s56aF sat_s56aG];
                                          1# ->
                                              let {
                                                sat_s56aI [Occ=Once]
                                                  :: a_s55L8 Data.Type.Equality.:~~: b_s55L9
                                                [LclId] =
                                                    [x_s56aC] \u []
                                                        case x_s56aC of {
                                                          __DEFAULT ->
                                                              Data.Type.Equality.$fEnum:~~:1;
                                                          0# -> Data.Type.Equality.$WHRefl;
                                                        };
                                              } in  : [sat_s56aI GHC.Types.[]];
                                        };
                              } in  go_up_s56aB 0#;
                    } in  (#,#) [Data.Type.Equality.$WHRefl sat_s56aJ];
              };
        };

Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b)
     -> [a Data.Type.Equality.:~~: b]
[GblId,
 Arity=4,
 Str=<S(S),U(U)><S,1*H><S,1*H><S,1*H>m2,
 Unf=OtherCon []] =
    [] \r [w_s56aK w1_s56aL w2_s56aM w3_s56aN]
        case w1_s56aL of w4_s56aO {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              case w2_s56aM of w5_s56aP {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                         _ [Occ=Dead, Dmd=<L,A>] ->
                    case w3_s56aN of w6_s56aQ {
                      Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                               _ [Occ=Dead, Dmd=<L,A>] ->
                          case
                              Data.Type.Equality.$w$cenumFromThenTo1
                                  w_s56aK w4_s56aO w5_s56aP w6_s56aQ
                          of
                          { (#,#) ww1_s56aS [Occ=Once] ww2_s56aT [Occ=Once] ->
                                : [ww1_s56aS ww2_s56aT];
                          };
                    };
              };
        };

Data.Type.Equality.$fEnum:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     GHC.Enum.Enum (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Arity=1, Str=<L,U(U)>m] =
    [] \r [$d~~_s56aU]
        let {
          sat_s56b2 [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> [a_a554X Data.Type.Equality.:~~: b_a554Y]
          [LclId] =
              [$d~~_s56aU] \r [eta_B3 eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo
                      $d~~_s56aU eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s56b1 [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> [a_a554X Data.Type.Equality.:~~: b_a554Y]
          [LclId] =
              [$d~~_s56aU] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$cenumFromTo
                      $d~~_s56aU eta_B2 eta_B1; } in
        let {
          sat_s56b0 [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> [a_a554X Data.Type.Equality.:~~: b_a554Y]
          [LclId] =
              [$d~~_s56aU] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$cenumFromThen
                      $d~~_s56aU eta_B2 eta_B1; } in
        let {
          sat_s56aZ [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> [a_a554X Data.Type.Equality.:~~: b_a554Y]
          [LclId] =
              [$d~~_s56aU] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$cenumFrom $d~~_s56aU eta_B1; } in
        let {
          sat_s56aY [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y) -> GHC.Types.Int
          [LclId] =
              [$d~~_s56aU] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$cfromEnum $d~~_s56aU eta_B1; } in
        let {
          sat_s56aX [Occ=Once]
            :: GHC.Types.Int -> a_a554X Data.Type.Equality.:~~: b_a554Y
          [LclId] =
              [$d~~_s56aU] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$ctoEnum $d~~_s56aU eta_B1; } in
        let {
          sat_s56aW [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> a_a554X Data.Type.Equality.:~~: b_a554Y
          [LclId] =
              [$d~~_s56aU] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$csucc $d~~_s56aU eta_B1; } in
        let {
          sat_s56aV [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> a_a554X Data.Type.Equality.:~~: b_a554Y
          [LclId] =
              [$d~~_s56aU] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$csucc $d~~_s56aU eta_B1;
        } in 
          GHC.Enum.C:Enum [sat_s56aV
                           sat_s56aW
                           sat_s56aX
                           sat_s56aY
                           sat_s56aZ
                           sat_s56b0
                           sat_s56b1
                           sat_s56b2];

Data.Type.Equality.$fTestEqualityk:~:1
  :: forall k (a :: k). GHC.Base.Maybe (a Data.Type.Equality.:~: a)
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [Data.Type.Equality.$WRefl];

Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality
  :: forall k (a1 :: k) (a2 :: k) (b :: k).
     (a1 Data.Type.Equality.:~: a2)
     -> (a1 Data.Type.Equality.:~: b)
     -> GHC.Base.Maybe (a2 Data.Type.Equality.:~: b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_s56b3 ds1_s56b4]
        case ds_s56b3 of {
          Data.Type.Equality.Refl co_a554K ->
              case ds1_s56b4 of {
                Data.Type.Equality.Refl co1_a554L ->
                    Data.Type.Equality.$fTestEqualityk:~:1;
              };
        };

Data.Type.Equality.$fTestEqualityk:~: [InlPrag=INLINE (sat-args=0)]
  :: forall k (a :: k).
     Data.Type.Equality.TestEquality ((Data.Type.Equality.:~:) a)
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality eta_B2 eta_B1;

Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality
  :: forall k k1 (a1 :: k1) (a2 :: k) (b :: k).
     (a1 Data.Type.Equality.:~~: a2)
     -> (a1 Data.Type.Equality.:~~: b)
     -> GHC.Base.Maybe (a2 Data.Type.Equality.:~: b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(A,U)><S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_s56b7 ds1_s56b8]
        case ds_s56b7 of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>] co1_a554q ->
              case ds1_s56b8 of {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>] co3_a554s ->
                    Data.Type.Equality.$fTestEqualityk:~:1;
              };
        };

Data.Type.Equality.$fTestEqualityk:~~: [InlPrag=INLINE (sat-args=0)]
  :: forall k k1 (a :: k1).
     Data.Type.Equality.TestEquality ((Data.Type.Equality.:~~:) a)
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(A,U)><S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality
            eta_B2 eta_B1;

Data.Type.Equality.$fEq:~:_$c==
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [ds_s56bb ds1_s56bc]
        case ds_s56bb of {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              case ds1_s56bc of {
                Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
                    GHC.Types.True [];
              };
        };

Data.Type.Equality.$fEq:~:_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [eta_s56bf eta1_s56bg]
        case eta_s56bf of {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              case eta1_s56bg of {
                Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
                    GHC.Types.False [];
              };
        };

Data.Type.Equality.$fEq:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Classes.Eq (a Data.Type.Equality.:~: b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [Data.Type.Equality.$fEq:~:_$c==
                                     Data.Type.Equality.$fEq:~:_$c/=];

Data.Type.Equality.$fRead:~:3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Refl"#;

Data.Type.Equality.$fRead:~:2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Type.Equality.$fRead:~:3;

Data.Type.Equality.$fShow:~:_$cshowsPrec
  :: forall k (a :: k) (b :: k).
     GHC.Types.Int -> (a Data.Type.Equality.:~: b) -> GHC.Show.ShowS
[GblId, Arity=3, Str=<L,A><S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s56bj ds1_s56bk eta_s56bl]
        case ds1_s56bk of {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              GHC.Base.++ Data.Type.Equality.$fRead:~:2 eta_s56bl;
        };

Data.Type.Equality.$fShow:~:_$cshow
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b) -> GHC.Base.String
[GblId, Arity=1, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [x_s56bn]
        case x_s56bn of {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              Data.Type.Equality.$fRead:~:2;
        };

Data.Type.Equality.$fShow:~:1
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b) -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s56bp eta_s56bq]
        case ds_s56bp of {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              GHC.Base.++ Data.Type.Equality.$fRead:~:2 eta_s56bq;
        };

Data.Type.Equality.$fShow:~:_$cshowList
  :: forall k (a :: k) (b :: k).
     [a Data.Type.Equality.:~: b] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s56bs s_s56bt]
        GHC.Show.showList__ Data.Type.Equality.$fShow:~:1 ls_s56bs s_s56bt;

Data.Type.Equality.$fShow:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Show.Show (a Data.Type.Equality.:~: b)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Type.Equality.$fShow:~:_$cshowsPrec
                                    Data.Type.Equality.$fShow:~:_$cshow
                                    Data.Type.Equality.$fShow:~:_$cshowList];

Data.Type.Equality.$fOrd:~:_$c<
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s56bu b1_s56bv]
        case a1_s56bu of {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              case b1_s56bv of {
                Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
                    GHC.Types.False [];
              };
        };

Data.Type.Equality.$fOrd:~:_$ccompare
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s56by b1_s56bz]
        case a1_s56by of {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              case b1_s56bz of {
                Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] -> GHC.Types.EQ [];
              };
        };

Data.Type.Equality.$fOrd:~:_$c<=
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s56bC b1_s56bD]
        case b1_s56bD of {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              case a1_s56bC of {
                Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
                    GHC.Types.True [];
              };
        };

Data.Type.Equality.$fOrd:~:_$cmax
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> a Data.Type.Equality.:~: b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [x_s56bG y_s56bH]
        case x_s56bG of {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] -> y_s56bH;
        };

Data.Type.Equality.$fOrd:~:_$c>
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s56bJ b1_s56bK]
        case b1_s56bK of {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              case a1_s56bJ of {
                Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
                    GHC.Types.False [];
              };
        };

Data.Type.Equality.$fOrd:~:_$cmin
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> a Data.Type.Equality.:~: b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [x_s56bN y_s56bO]
        case y_s56bO of {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] -> x_s56bN;
        };

Data.Type.Equality.$fOrd:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Classes.Ord (a Data.Type.Equality.:~: b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Type.Equality.$fEq:~:
                                      Data.Type.Equality.$fOrd:~:_$ccompare
                                      Data.Type.Equality.$fOrd:~:_$c<
                                      Data.Type.Equality.$fOrd:~:_$c<=
                                      Data.Type.Equality.$fOrd:~:_$c>
                                      Data.Type.Equality.$fEq:~:_$c==
                                      Data.Type.Equality.$fOrd:~:_$cmax
                                      Data.Type.Equality.$fOrd:~:_$cmin];

Data.Type.Equality.$fRead:~:_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Type.Equality.$fRead:~:2];

Data.Type.Equality.$fRead:~:1
  :: forall k (a :: k).
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ((a Data.Type.Equality.:~: a) -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,A><L,1*C1(U)>m2, Unf=OtherCon []] =
    [] \r [n_s56bQ eta_s56bR]
        let {
          sat_s56bT [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b_X3nkn
          [LclId] =
              [eta_s56bR] \r [a1_s56bS] eta_s56bR Data.Type.Equality.$WRefl;
        } in 
          case
              Text.Read.Lex.$wexpect
                  Data.Type.Equality.$fRead:~:_lexeme sat_s56bT
          of
          { Unit# ww1_s56bV [Occ=Once] ->
                Text.ParserCombinators.ReadP.Look [ww1_s56bV];
          };

Data.Type.Equality.$fRead:~:4
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        ((a Data.Type.Equality.:~: b) -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId, Arity=3, Str=<S(S),1*U(1*U)><L,U><L,U>, Unf=OtherCon []] =
    [] \r [$d~_s56bW eta_s56bX eta1_s56bY]
        case GHC.Types.heq_sel $d~_s56bW of {
          __DEFAULT ->
              GHC.Read.list3 Data.Type.Equality.$fRead:~:1 eta_s56bX eta1_s56bY;
        };

Data.Type.Equality.$fRead:~:_$creadsPrec
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (a Data.Type.Equality.:~: b)
[GblId, Arity=2, Str=<S(S),U(U)><L,U>, Unf=OtherCon []] =
    [] \r [$d~_s56bZ eta_s56c0]
        case GHC.Types.heq_sel $d~_s56bZ of {
          __DEFAULT ->
              let {
                sat_s56c1 [Occ=Once]
                  :: Text.ParserCombinators.ReadP.P
                       (a_X555E Data.Type.Equality.:~: b_X555G)
                [LclId] =
                    [$d~_s56bZ eta_s56c0] \u []
                        case GHC.Types.heq_sel $d~_s56bZ of {
                          __DEFAULT ->
                              GHC.Read.list3
                                  Data.Type.Equality.$fRead:~:1
                                  eta_s56c0
                                  Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                        };
              } in  Text.ParserCombinators.ReadP.run sat_s56c1;
        };

Data.Type.Equality.$fRead:~:_$creadListPrec
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [a Data.Type.Equality.:~: b]
[GblId, Arity=1, Str=<S(S),U(U)>, Unf=OtherCon []] =
    [] \r [$d~_s56c2]
        case GHC.Types.heq_sel $d~_s56c2 of {
          __DEFAULT ->
              let {
                sat_s56c5 [Occ=Once]
                  :: Text.ParserCombinators.ReadPrec.ReadPrec
                       (a_X555F Data.Type.Equality.:~: b_X555H)
                [LclId] =
                    [$d~_s56c2] \r [eta_s56c3 eta1_s56c4]
                        case GHC.Types.heq_sel $d~_s56c2 of {
                          __DEFAULT ->
                              GHC.Read.list3 Data.Type.Equality.$fRead:~:1 eta_s56c3 eta1_s56c4;
                        };
              } in  GHC.Read.list sat_s56c5;
        };

Data.Type.Equality.$fRead:~:_$creadList
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     Text.ParserCombinators.ReadP.ReadS [a Data.Type.Equality.:~: b]
[GblId, Arity=1, Str=<S(S),U(U)>, Unf=OtherCon []] =
    [] \r [$d~_s56c6]
        case GHC.Types.heq_sel $d~_s56c6 of {
          __DEFAULT ->
              let {
                sat_s56ca [Occ=Once]
                  :: Text.ParserCombinators.ReadP.P
                       [a_X555G Data.Type.Equality.:~: b_X555I]
                [LclId] =
                    [$d~_s56c6] \u []
                        case GHC.Types.heq_sel $d~_s56c6 of {
                          __DEFAULT ->
                              let {
                                sat_s56c9 [Occ=Once]
                                  :: Text.ParserCombinators.ReadPrec.ReadPrec
                                       (b_X555I Data.Type.Equality.:~: b_X555I)
                                [LclId] =
                                    [] \r [eta_s56c7 eta1_s56c8]
                                        GHC.Read.list3
                                            Data.Type.Equality.$fRead:~:1 eta_s56c7 eta1_s56c8;
                              } in 
                                GHC.Read.list
                                    sat_s56c9
                                    GHC.Read.$fRead()7
                                    Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                        };
              } in  Text.ParserCombinators.ReadP.run sat_s56ca;
        };

Data.Type.Equality.$fRead:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     GHC.Read.Read (a Data.Type.Equality.:~: b)
[GblId[DFunId], Arity=1, Str=<L,U(U)>m] =
    [] \r [$d~_s56cb]
        let {
          sat_s56cf [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [a_X555H Data.Type.Equality.:~: b_X555J]
          [LclId] =
              [$d~_s56cb] \u []
                  Data.Type.Equality.$fRead:~:_$creadListPrec $d~_s56cb; } in
        let {
          sat_s56ce [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (a_X555H Data.Type.Equality.:~: b_X555J)
          [LclId] =
              [$d~_s56cb] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fRead:~:4 $d~_s56cb eta_B2 eta_B1; } in
        let {
          sat_s56cd [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [a_X555H Data.Type.Equality.:~: b_X555J]
          [LclId] =
              [$d~_s56cb] \u []
                  Data.Type.Equality.$fRead:~:_$creadList $d~_s56cb; } in
        let {
          sat_s56cc [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (a_X555H Data.Type.Equality.:~: b_X555J)
          [LclId] =
              [$d~_s56cb] \r [eta_B1]
                  Data.Type.Equality.$fRead:~:_$creadsPrec $d~_s56cb eta_B1;
        } in  GHC.Read.C:Read [sat_s56cc sat_s56cd sat_s56ce sat_s56cf];

Data.Type.Equality.$fBounded:~:_$cmaxBound
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     a Data.Type.Equality.:~: b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [$d~_s56cg]
        case GHC.Types.heq_sel $d~_s56cg of {
          __DEFAULT -> Data.Type.Equality.$WRefl;
        };

Data.Type.Equality.$fBounded:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     GHC.Enum.Bounded (a Data.Type.Equality.:~: b)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(U)>m] =
    [] \r [$d~_s56ch]
        let {
          sat_s56cj [Occ=Once] :: a_a551J Data.Type.Equality.:~: b_a551K
          [LclId] =
              [$d~_s56ch] \u []
                  Data.Type.Equality.$fBounded:~:_$cmaxBound $d~_s56ch; } in
        let {
          sat_s56ci [Occ=Once] :: a_a551J Data.Type.Equality.:~: b_a551K
          [LclId] =
              [$d~_s56ch] \u []
                  Data.Type.Equality.$fBounded:~:_$cmaxBound $d~_s56ch;
        } in  GHC.Enum.C:Bounded [sat_s56ci sat_s56cj];

Data.Type.Equality.$fEq:~~:_$c==
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [ds_s56ck ds1_s56cl]
        case ds_s56ck of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              case ds1_s56cl of {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                         _ [Occ=Dead, Dmd=<L,A>] ->
                    GHC.Types.True [];
              };
        };

Data.Type.Equality.$fEq:~~:_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [eta_s56co eta1_s56cp]
        case eta_s56co of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              case eta1_s56cp of {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                         _ [Occ=Dead, Dmd=<L,A>] ->
                    GHC.Types.False [];
              };
        };

Data.Type.Equality.$fEq:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     GHC.Classes.Eq (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [Data.Type.Equality.$fEq:~~:_$c==
                                     Data.Type.Equality.$fEq:~~:_$c/=];

Data.Type.Equality.$fRead:~~:3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "HRefl"#;

Data.Type.Equality.$fRead:~~:2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Type.Equality.$fRead:~~:3;

Data.Type.Equality.$fShow:~~:_$cshowsPrec
  :: forall k2 k1 (a :: k1) (b :: k2).
     GHC.Types.Int -> (a Data.Type.Equality.:~~: b) -> GHC.Show.ShowS
[GblId, Arity=3, Str=<L,A><S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s56cs ds1_s56ct eta_s56cu]
        case ds1_s56ct of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              GHC.Base.++ Data.Type.Equality.$fRead:~~:2 eta_s56cu;
        };

Data.Type.Equality.$fShow:~~:_$cshow
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b) -> GHC.Base.String
[GblId, Arity=1, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [x_s56cw]
        case x_s56cw of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              Data.Type.Equality.$fRead:~~:2;
        };

Data.Type.Equality.$fShow:~~:1
  :: forall k2 (b :: k2) k1 (a :: k1).
     (a Data.Type.Equality.:~~: b) -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s56cy eta_s56cz]
        case ds_s56cy of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              GHC.Base.++ Data.Type.Equality.$fRead:~~:2 eta_s56cz;
        };

Data.Type.Equality.$fShow:~~:_$cshowList
  :: forall k2 k1 (a :: k1) (b :: k2).
     [a Data.Type.Equality.:~~: b] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s56cB s_s56cC]
        GHC.Show.showList__
            Data.Type.Equality.$fShow:~~:1 ls_s56cB s_s56cC;

Data.Type.Equality.$fShow:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     GHC.Show.Show (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Type.Equality.$fShow:~~:_$cshowsPrec
                                    Data.Type.Equality.$fShow:~~:_$cshow
                                    Data.Type.Equality.$fShow:~~:_$cshowList];

Data.Type.Equality.$fOrd:~~:_$c<
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s56cD b1_s56cE]
        case a1_s56cD of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              case b1_s56cE of {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                         _ [Occ=Dead, Dmd=<L,A>] ->
                    GHC.Types.False [];
              };
        };

Data.Type.Equality.$fOrd:~~:_$ccompare
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s56cH b1_s56cI]
        case a1_s56cH of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              case b1_s56cI of {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                         _ [Occ=Dead, Dmd=<L,A>] ->
                    GHC.Types.EQ [];
              };
        };

Data.Type.Equality.$fOrd:~~:_$c<=
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s56cL b1_s56cM]
        case b1_s56cM of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              case a1_s56cL of {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                         _ [Occ=Dead, Dmd=<L,A>] ->
                    GHC.Types.True [];
              };
        };

Data.Type.Equality.$fOrd:~~:_$cmax
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> a Data.Type.Equality.:~~: b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_s56cP y_s56cQ]
        case x_s56cP of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              y_s56cQ;
        };

Data.Type.Equality.$fOrd:~~:_$c>
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s56cS b1_s56cT]
        case b1_s56cT of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              case a1_s56cS of {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                         _ [Occ=Dead, Dmd=<L,A>] ->
                    GHC.Types.False [];
              };
        };

Data.Type.Equality.$fOrd:~~:_$cmin
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> a Data.Type.Equality.:~~: b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [x_s56cW y_s56cX]
        case y_s56cX of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              x_s56cW;
        };

Data.Type.Equality.$fOrd:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     GHC.Classes.Ord (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Type.Equality.$fEq:~~:
                                      Data.Type.Equality.$fOrd:~~:_$ccompare
                                      Data.Type.Equality.$fOrd:~~:_$c<
                                      Data.Type.Equality.$fOrd:~~:_$c<=
                                      Data.Type.Equality.$fOrd:~~:_$c>
                                      Data.Type.Equality.$fEq:~~:_$c==
                                      Data.Type.Equality.$fOrd:~~:_$cmax
                                      Data.Type.Equality.$fOrd:~~:_$cmin];

Data.Type.Equality.$fRead:~~:_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Type.Equality.$fRead:~~:2];

Data.Type.Equality.$fRead:~~:1
  :: forall k1 (a :: k1).
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ((a Data.Type.Equality.:~~: a) -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,A><L,1*C1(U)>m2, Unf=OtherCon []] =
    [] \r [n_s56cZ eta_s56d0]
        let {
          sat_s56d2 [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b_X3nkW
          [LclId] =
              [eta_s56d0] \r [a1_s56d1] eta_s56d0 Data.Type.Equality.$WHRefl;
        } in 
          case
              Text.Read.Lex.$wexpect
                  Data.Type.Equality.$fRead:~~:_lexeme sat_s56d2
          of
          { Unit# ww1_s56d4 [Occ=Once] ->
                Text.ParserCombinators.ReadP.Look [ww1_s56d4];
          };

Data.Type.Equality.$fRead:~~:4
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        ((a Data.Type.Equality.:~~: b)
         -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId, Arity=3, Str=<S(S),1*U(1*U)><L,U><L,U>, Unf=OtherCon []] =
    [] \r [$d~~_s56d5 eta_s56d6 eta1_s56d7]
        case GHC.Types.heq_sel $d~~_s56d5 of {
          __DEFAULT ->
              GHC.Read.list3 Data.Type.Equality.$fRead:~~:1 eta_s56d6 eta1_s56d7;
        };

Data.Type.Equality.$fRead:~~:_$creadsPrec
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (a Data.Type.Equality.:~~: b)
[GblId, Arity=2, Str=<S(S),U(U)><L,U>, Unf=OtherCon []] =
    [] \r [$d~~_s56d8 eta_s56d9]
        case GHC.Types.heq_sel $d~~_s56d8 of {
          __DEFAULT ->
              let {
                sat_s56da [Occ=Once]
                  :: Text.ParserCombinators.ReadP.P
                       (a_X553z Data.Type.Equality.:~~: b_X553B)
                [LclId] =
                    [$d~~_s56d8 eta_s56d9] \u []
                        case GHC.Types.heq_sel $d~~_s56d8 of {
                          __DEFAULT ->
                              GHC.Read.list3
                                  Data.Type.Equality.$fRead:~~:1
                                  eta_s56d9
                                  Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                        };
              } in  Text.ParserCombinators.ReadP.run sat_s56da;
        };

Data.Type.Equality.$fRead:~~:_$creadListPrec
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [a Data.Type.Equality.:~~: b]
[GblId, Arity=1, Str=<S(S),U(U)>, Unf=OtherCon []] =
    [] \r [$d~~_s56db]
        case GHC.Types.heq_sel $d~~_s56db of {
          __DEFAULT ->
              let {
                sat_s56de [Occ=Once]
                  :: Text.ParserCombinators.ReadPrec.ReadPrec
                       (a_X553A Data.Type.Equality.:~~: b_X553C)
                [LclId] =
                    [$d~~_s56db] \r [eta_s56dc eta1_s56dd]
                        case GHC.Types.heq_sel $d~~_s56db of {
                          __DEFAULT ->
                              GHC.Read.list3 Data.Type.Equality.$fRead:~~:1 eta_s56dc eta1_s56dd;
                        };
              } in  GHC.Read.list sat_s56de;
        };

Data.Type.Equality.$fRead:~~:_$creadList
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     Text.ParserCombinators.ReadP.ReadS [a Data.Type.Equality.:~~: b]
[GblId, Arity=1, Str=<S(S),U(U)>, Unf=OtherCon []] =
    [] \r [$d~~_s56df]
        case GHC.Types.heq_sel $d~~_s56df of {
          __DEFAULT ->
              let {
                sat_s56dj [Occ=Once]
                  :: Text.ParserCombinators.ReadP.P
                       [a_X553B Data.Type.Equality.:~~: b_X553D]
                [LclId] =
                    [$d~~_s56df] \u []
                        case GHC.Types.heq_sel $d~~_s56df of {
                          __DEFAULT ->
                              let {
                                sat_s56di [Occ=Once]
                                  :: Text.ParserCombinators.ReadPrec.ReadPrec
                                       (b_X553D Data.Type.Equality.:~~: b_X553D)
                                [LclId] =
                                    [] \r [eta_s56dg eta1_s56dh]
                                        GHC.Read.list3
                                            Data.Type.Equality.$fRead:~~:1 eta_s56dg eta1_s56dh;
                              } in 
                                GHC.Read.list
                                    sat_s56di
                                    GHC.Read.$fRead()7
                                    Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                        };
              } in  Text.ParserCombinators.ReadP.run sat_s56dj;
        };

Data.Type.Equality.$fRead:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     GHC.Read.Read (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Arity=1, Str=<L,U(U)>m] =
    [] \r [$d~~_s56dk]
        let {
          sat_s56do [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [a_X553C Data.Type.Equality.:~~: b_X553E]
          [LclId] =
              [$d~~_s56dk] \u []
                  Data.Type.Equality.$fRead:~~:_$creadListPrec $d~~_s56dk; } in
        let {
          sat_s56dn [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (a_X553C Data.Type.Equality.:~~: b_X553E)
          [LclId] =
              [$d~~_s56dk] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fRead:~~:4 $d~~_s56dk eta_B2 eta_B1; } in
        let {
          sat_s56dm [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [a_X553C Data.Type.Equality.:~~: b_X553E]
          [LclId] =
              [$d~~_s56dk] \u []
                  Data.Type.Equality.$fRead:~~:_$creadList $d~~_s56dk; } in
        let {
          sat_s56dl [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (a_X553C Data.Type.Equality.:~~: b_X553E)
          [LclId] =
              [$d~~_s56dk] \r [eta_B1]
                  Data.Type.Equality.$fRead:~~:_$creadsPrec $d~~_s56dk eta_B1;
        } in  GHC.Read.C:Read [sat_s56dl sat_s56dm sat_s56dn sat_s56do];

Data.Type.Equality.$fBounded:~~:_$cmaxBound
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     a Data.Type.Equality.:~~: b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [$d~~_s56dp]
        case GHC.Types.heq_sel $d~~_s56dp of {
          __DEFAULT -> Data.Type.Equality.$WHRefl;
        };

Data.Type.Equality.$fBounded:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     GHC.Enum.Bounded (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(U)>m] =
    [] \r [$d~~_s56dq]
        let {
          sat_s56ds [Occ=Once] :: a_a54YX Data.Type.Equality.:~~: b_a54YY
          [LclId] =
              [$d~~_s56dq] \u []
                  Data.Type.Equality.$fBounded:~~:_$cmaxBound $d~~_s56dq; } in
        let {
          sat_s56dr [Occ=Once] :: a_a54YX Data.Type.Equality.:~~: b_a54YY
          [LclId] =
              [$d~~_s56dq] \u []
                  Data.Type.Equality.$fBounded:~~:_$cmaxBound $d~~_s56dq;
        } in  GHC.Enum.C:Bounded [sat_s56dr sat_s56ds];

Data.Type.Equality.sym
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b) -> b Data.Type.Equality.:~: a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U(U)>m, Unf=OtherCon []] =
    [] \r [ds_s56dt]
        case ds_s56dt of {
          Data.Type.Equality.Refl co_a54YN -> Data.Type.Equality.$WRefl;
        };

Data.Type.Equality.trans
  :: forall k (a :: k) (b :: k) (c :: k).
     (a Data.Type.Equality.:~: b)
     -> (b Data.Type.Equality.:~: c) -> a Data.Type.Equality.:~: c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s56dv ds1_s56dw]
        case ds_s56dv of {
          Data.Type.Equality.Refl co_a54YB ->
              case ds1_s56dw of {
                Data.Type.Equality.Refl co1_a54YC -> Data.Type.Equality.$WRefl;
              };
        };

Data.Type.Equality.castWith
  :: forall a b. (a Data.Type.Equality.:~: b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s56dz x_s56dA]
        case ds_s56dz of { Data.Type.Equality.Refl co_a54Ys -> x_s56dA; };

Data.Type.Equality.gcastWith
  :: forall k (a :: k) (b :: k) r.
     (a Data.Type.Equality.:~: b)
     -> (((a :: k) Data.Type.Equality.~ (b :: k)) => r) -> r
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s56dC x_s56dD]
        case ds_s56dC of {
          Data.Type.Equality.Refl co_a54Yl ->
              let {
                sat_s56dF [Occ=Once]
                  :: (a_a54Yh :: k_a54Yg) Data.Type.Equality.~ (b_a54Yi :: k_a54Yg)
                [LclId] =
                    CCCS GHC.Types.Eq#! [GHC.Prim.coercionToken#];
              } in  x_s56dD sat_s56dF;
        };

Data.Type.Equality.apply
  :: forall k1 k2 (f :: k1 -> k2) (g :: k1
                                        -> k2) (a :: k1) (b :: k1).
     (f Data.Type.Equality.:~: g)
     -> (a Data.Type.Equality.:~: b) -> f a Data.Type.Equality.:~: g b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s56dG ds1_s56dH]
        case ds_s56dG of {
          Data.Type.Equality.Refl co_a54Y7 ->
              case ds1_s56dH of {
                Data.Type.Equality.Refl co1_a54Y8 -> Data.Type.Equality.$WRefl;
              };
        };

Data.Type.Equality.inner
  :: forall k1 k2 (f :: k1 -> k2) (a :: k1) (g :: k1
                                                  -> k2) (b :: k1).
     (f a Data.Type.Equality.:~: g b) -> a Data.Type.Equality.:~: b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U(U)>m, Unf=OtherCon []] =
    [] \r [ds_s56dK]
        case ds_s56dK of {
          Data.Type.Equality.Refl co_a54XU -> Data.Type.Equality.$WRefl;
        };

Data.Type.Equality.outer
  :: forall k1 k2 (f :: k1 -> k2) (a :: k1) (g :: k1
                                                  -> k2) (b :: k1).
     (f a Data.Type.Equality.:~: g b) -> f Data.Type.Equality.:~: g
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U(U)>m, Unf=OtherCon []] =
    [] \r [ds_s56dM]
        case ds_s56dM of {
          Data.Type.Equality.Refl co_a54XH -> Data.Type.Equality.$WRefl;
        };

Data.Type.Equality.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Type.Equality.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$trModule4];

Data.Type.Equality.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Type.Equality"#;

Data.Type.Equality.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$trModule2];

Data.Type.Equality.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Type.Equality.$trModule3
                                     Data.Type.Equality.$trModule1];

$krep_r568a :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

$krep1_r568b :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep2_r568c :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r568b
                                         GHC.Types.krep$*];

$krep3_r568d :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

Data.Type.Equality.$tc:~~:1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r568d $krep2_r568c];

$krep4_r568e :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r568d
                                         GHC.Types.krep$*];

Data.Type.Equality.$tc:~:1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r568d $krep4_r568e];

Data.Type.Equality.$tcTestEquality1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r568e $krep_r568a];

$krep5_r568f :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r568d $krep_r568a];

Data.Type.Equality.$tc~1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r568d $krep5_r568f];

$krep6_r568g :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep7_r568h :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep6_r568g GHC.Types.[]];

$krep8_r568i :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r568b $krep7_r568h];

$krep9_r568j :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r568d $krep8_r568i];

$krep10_r568k :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r568d $krep9_r568j];

$krep11_r568l :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tc~~
                                              $krep10_r568k];

Data.Type.Equality.$tc~3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "~"#;

Data.Type.Equality.$tc~2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc~3];

Data.Type.Equality.$tc~ :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11470827771536267938##
                                    3625512399163125290##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc~2
                                    1#
                                    Data.Type.Equality.$tc~1];

$krep12_r568m :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Type.Equality.$tc~
                                              $krep9_r568j];

Data.Type.Equality.$tc'C:~1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r568l $krep12_r568m];

Data.Type.Equality.$tc'C:~3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:~"#;

Data.Type.Equality.$tc'C:~2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc'C:~3];

Data.Type.Equality.$tc'C:~ :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6023002849810837484##
                                    5427525916893308990##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc'C:~2
                                    3#
                                    Data.Type.Equality.$tc'C:~1];

Data.Type.Equality.$tc:~:3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ":~:"#;

Data.Type.Equality.$tc:~:2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc:~:3];

Data.Type.Equality.$tc:~: :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10597498348876412676##
                                    16281320961088145472##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc:~:2
                                    1#
                                    Data.Type.Equality.$tc:~:1];

$krep13_r568n :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r568b GHC.Types.[]];

$krep14_r568o :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r568b $krep13_r568n];

$krep15_r568p :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r568d $krep14_r568o];

Data.Type.Equality.$tc'Refl1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Type.Equality.$tc:~:
                                              $krep15_r568p];

Data.Type.Equality.$tc'Refl3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Refl"#;

Data.Type.Equality.$tc'Refl2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc'Refl3];

Data.Type.Equality.$tc'Refl :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16680242040484769242##
                                    2864388906562808793##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc'Refl2
                                    2#
                                    Data.Type.Equality.$tc'Refl1];

Data.Type.Equality.$tc:~~:3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ":~~:"#;

Data.Type.Equality.$tc:~~:2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc:~~:3];

Data.Type.Equality.$tc:~~: :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4361259188665111259##
                                    11706467685470543992##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc:~~:2
                                    2#
                                    Data.Type.Equality.$tc:~~:1];

$krep16_r568q :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r568d $krep15_r568p];

Data.Type.Equality.$tc'HRefl1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Type.Equality.$tc:~~:
                                              $krep16_r568q];

Data.Type.Equality.$tc'HRefl3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'HRefl"#;

Data.Type.Equality.$tc'HRefl2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc'HRefl3];

Data.Type.Equality.$tc'HRefl :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4486133906173668740##
                                    6341741464738386857##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc'HRefl2
                                    2#
                                    Data.Type.Equality.$tc'HRefl1];

Data.Type.Equality.$tcTestEquality3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "TestEquality"#;

Data.Type.Equality.$tcTestEquality2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tcTestEquality3];

Data.Type.Equality.$tcTestEquality :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2944680549948432194##
                                    17791533211054855448##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tcTestEquality2
                                    1#
                                    Data.Type.Equality.$tcTestEquality1];

Data.Type.Equality.HRefl
  :: forall k2 k2 (a :: k2) (b :: k2).
     ((k2 :: *) GHC.Prim.~# (k2 :: *),
      (b :: k2) GHC.Prim.~# (a :: k2)) =>
     a Data.Type.Equality.:~~: b
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Type.Equality.HRefl [GHC.Prim.coercionToken#
                                  GHC.Prim.coercionToken#];

Data.Type.Equality.Refl
  :: forall k (a :: k) (b :: k).
     ((b :: k) GHC.Prim.~# (a :: k)) =>
     a Data.Type.Equality.:~: b
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Type.Equality.Refl [GHC.Prim.coercionToken#];


==================== STG syntax: ====================
2018-03-16 16:00:01.529490191 UTC

Data.Type.Equality.$p1~ [InlPrag=INLINE]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a :: k) GHC.Types.~~ (b :: k)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_s568s] v_s568s;

Data.Type.Equality.testEquality [InlPrag=INLINE]
  :: forall k (f :: k -> *).
     Data.Type.Equality.TestEquality f =>
     forall (a :: k) (b :: k).
     f a -> f b -> GHC.Base.Maybe (a Data.Type.Equality.:~: b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_s568t] v_s568t;

Data.Type.Equality.$WHRefl [InlPrag=INLINE[2]]
  :: forall k2 (a :: k2). a Data.Type.Equality.:~~: a
[GblId[DataConWrapper], Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Type.Equality.HRefl! [];

Data.Type.Equality.$WRefl [InlPrag=INLINE[2]]
  :: forall k (a :: k). a Data.Type.Equality.:~: a
[GblId[DataConWrapper], Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Type.Equality.Refl! [];

Data.Type.Equality.$f~kab_$cp1~
  :: forall k (a :: k) (b :: k).
     ((a :: k) GHC.Types.~~ (b :: k)) =>
     (a :: k) GHC.Types.~~ (b :: k)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S(S),U(U)>, Unf=OtherCon []] =
    [] \r [$d~~_s568u]
        case GHC.Types.heq_sel $d~~_s568u of { (##) -> $d~~_s568u; };

Data.Type.Equality.$f~kab [InlPrag=INLINE (sat-args=0)]
  :: forall k (a :: k) (b :: k).
     ((a :: k) GHC.Types.~~ (b :: k)) =>
     (a :: k) Data.Type.Equality.~ (b :: k)
[GblId[DFunId(nt)],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),U(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Type.Equality.$f~kab_$cp1~ eta_B1;

Data.Type.Equality.$fEnum:~:3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Type.Equality.$fEnum:~:_$cfromEnum
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b) -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [$d~_s568v eta_s568w]
        case GHC.Types.heq_sel $d~_s568v of {
          (##) ->
              case eta_s568w of {
                Data.Type.Equality.Refl -> Data.Type.Equality.$fEnum:~:3;
              };
        };

lvl_r5689 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Type.Equality.toEnum: bad argument"#;

Data.Type.Equality.$fEnum:~:1
  :: forall k (a :: k) (b :: k). a Data.Type.Equality.:~: b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_r5689 of sat_s568y {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s568y;
        };

Data.Type.Equality.$fEnum:~:_$ctoEnum
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     GHC.Types.Int -> a Data.Type.Equality.:~: b
[GblId,
 Arity=2,
 Str=<S(S),1*U(1*U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [$d~_s568z eta_s568A]
        case GHC.Types.heq_sel $d~_s568z of {
          (##) ->
              case eta_s568A of {
                GHC.Types.I# ds_s568C [Occ=Once!] ->
                    case ds_s568C of {
                      __DEFAULT -> Data.Type.Equality.$fEnum:~:1;
                      0# -> Data.Type.Equality.$WRefl;
                    };
              };
        };

Data.Type.Equality.$fEnum:~:_$csucc
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b) -> a Data.Type.Equality.:~: b
[GblId, Arity=2, Str=<B,U(U)><B,A>x, Unf=OtherCon []] =
    [] \r [$d~_s568E eta_s568F]
        case GHC.Types.heq_sel $d~_s568E of {
          (##) ->
              case GHC.Types.heq_sel $d~_s568E of {
                (##) -> Data.Type.Equality.$fEnum:~:1;
              };
        };

Data.Type.Equality.$w$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=3, Str=<S(S),U(U)><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s568G w1_s568H w2_s568I]
        case GHC.Types.heq_sel w_s568G of {
          (##) ->
              case GHC.Types.heq_sel w_s568G of {
                (##) ->
                    let {
                      go_s568J [Occ=LoopBreaker]
                        :: GHC.Prim.Int# -> [a_s55JT Data.Type.Equality.:~: b_s55JU]
                      [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                          sat-only [go_s568J] \r [x_s568K]
                              let {
                                sat_s568P [Occ=Once] :: [a_s55JT Data.Type.Equality.:~: b_s55JU]
                                [LclId] =
                                    [go_s568J x_s568K] \u []
                                        case x_s568K of wild_s568N {
                                          __DEFAULT ->
                                              case +# [wild_s568N 1#] of sat_s568O {
                                                __DEFAULT -> go_s568J sat_s568O;
                                              };
                                          0# -> [] [];
                                        }; } in
                              let {
                                sat_s568M [Occ=Once] :: a_s55JT Data.Type.Equality.:~: b_s55JU
                                [LclId] =
                                    [x_s568K] \u []
                                        case x_s568K of {
                                          __DEFAULT -> Data.Type.Equality.$fEnum:~:1;
                                          0# -> Data.Type.Equality.$WRefl;
                                        };
                              } in  : [sat_s568M sat_s568P];
                    } in  go_s568J 0#;
              };
        };

Data.Type.Equality.$fEnum:~:_$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=3, Str=<S(S),U(U)><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s568Q w1_s568R w2_s568S]
        case w1_s568R of w3_s568T {
          Data.Type.Equality.Refl ->
              case w2_s568S of w4_s568U {
                Data.Type.Equality.Refl ->
                    Data.Type.Equality.$w$cenumFromTo w_s568Q w3_s568T w4_s568U;
              };
        };

Data.Type.Equality.$fEnum:~:2 :: [GHC.Types.Int]
[GblId] =
    [] \u [] GHC.Enum.efdInt 0# 0#;

Data.Type.Equality.$w$cenumFromThen [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=3, Str=<S(S),U(U)><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s568V w1_s568W w2_s568X]
        case GHC.Types.heq_sel w_s568V of {
          (##) ->
              case GHC.Types.heq_sel w_s568V of {
                (##) ->
                    let {
                      sat_s568Y [Occ=Once]
                        :: GHC.Types.Int -> a_s55K0 Data.Type.Equality.:~: b_s55K1
                      [LclId] =
                          [w_s568V] \r [eta_B1]
                              Data.Type.Equality.$fEnum:~:_$ctoEnum w_s568V eta_B1;
                    } in  GHC.Base.map sat_s568Y Data.Type.Equality.$fEnum:~:2;
              };
        };

Data.Type.Equality.$fEnum:~:_$cenumFromThen [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=3, Str=<S(S),U(U)><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s568Z w1_s5690 w2_s5691]
        case w1_s5690 of w3_s5692 {
          Data.Type.Equality.Refl ->
              case w2_s5691 of w4_s5693 {
                Data.Type.Equality.Refl ->
                    Data.Type.Equality.$w$cenumFromThen w_s568Z w3_s5692 w4_s5693;
              };
        };

Data.Type.Equality.$w$cenumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=2, Str=<S(S),U(U)><L,A>, Unf=OtherCon []] =
    [] \r [w_s5694 w1_s5695]
        case GHC.Types.heq_sel w_s5694 of {
          (##) ->
              case GHC.Types.heq_sel w_s5694 of {
                (##) ->
                    let {
                      go_s5696 [Occ=LoopBreaker]
                        :: GHC.Prim.Int# -> [a_s55K8 Data.Type.Equality.:~: b_s55K9]
                      [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                          sat-only [go_s5696] \r [x_s5697]
                              let {
                                sat_s569c [Occ=Once] :: [a_s55K8 Data.Type.Equality.:~: b_s55K9]
                                [LclId] =
                                    [go_s5696 x_s5697] \u []
                                        case x_s5697 of wild_s569a {
                                          __DEFAULT ->
                                              case +# [wild_s569a 1#] of sat_s569b {
                                                __DEFAULT -> go_s5696 sat_s569b;
                                              };
                                          9223372036854775807# -> [] [];
                                        }; } in
                              let {
                                sat_s5699 [Occ=Once] :: a_s55K8 Data.Type.Equality.:~: b_s55K9
                                [LclId] =
                                    [x_s5697] \u []
                                        case x_s5697 of {
                                          __DEFAULT -> Data.Type.Equality.$fEnum:~:1;
                                          0# -> Data.Type.Equality.$WRefl;
                                        };
                              } in  : [sat_s5699 sat_s569c];
                    } in  go_s5696 0#;
              };
        };

Data.Type.Equality.$fEnum:~:_$cenumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=2, Str=<S(S),U(U)><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s569d w1_s569e]
        case w1_s569e of w2_s569f {
          Data.Type.Equality.Refl ->
              Data.Type.Equality.$w$cenumFrom w_s569d w2_s569f;
        };

Data.Type.Equality.$w$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b)
     -> (# a Data.Type.Equality.:~: b, [a Data.Type.Equality.:~: b] #)
[GblId, Arity=4, Str=<S(S),U(U)><L,A><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s569g w1_s569h w2_s569i w3_s569j]
        case GHC.Types.heq_sel w_s569g of {
          (##) ->
              case GHC.Types.heq_sel w_s569g of {
                (##) ->
                    let {
                      sat_s569s [Occ=Once] :: [a_s55Kk Data.Type.Equality.:~: b_s55Kl]
                      [LclId] =
                          [] \u []
                              let {
                                go_up_s569k [Occ=LoopBreaker]
                                  :: GHC.Prim.Int# -> [a_s55Kk Data.Type.Equality.:~: b_s55Kl]
                                [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                    sat-only [go_up_s569k] \r [x_s569l]
                                        case ># [x_s569l 0#] of {
                                          __DEFAULT ->
                                              let {
                                                sat_s569p [Occ=Once]
                                                  :: [a_s55Kk Data.Type.Equality.:~: b_s55Kl]
                                                [LclId] =
                                                    [go_up_s569k x_s569l] \u []
                                                        go_up_s569k x_s569l; } in
                                              let {
                                                sat_s569o [Occ=Once]
                                                  :: a_s55Kk Data.Type.Equality.:~: b_s55Kl
                                                [LclId] =
                                                    [x_s569l] \u []
                                                        case x_s569l of {
                                                          __DEFAULT ->
                                                              Data.Type.Equality.$fEnum:~:1;
                                                          0# -> Data.Type.Equality.$WRefl;
                                                        };
                                              } in  : [sat_s569o sat_s569p];
                                          1# ->
                                              let {
                                                sat_s569r [Occ=Once]
                                                  :: a_s55Kk Data.Type.Equality.:~: b_s55Kl
                                                [LclId] =
                                                    [x_s569l] \u []
                                                        case x_s569l of {
                                                          __DEFAULT ->
                                                              Data.Type.Equality.$fEnum:~:1;
                                                          0# -> Data.Type.Equality.$WRefl;
                                                        };
                                              } in  : [sat_s569r GHC.Types.[]];
                                        };
                              } in  go_up_s569k 0#;
                    } in  (#,#) [Data.Type.Equality.$WRefl sat_s569s];
              };
        };

Data.Type.Equality.$fEnum:~:_$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b)
     -> [a Data.Type.Equality.:~: b]
[GblId,
 Arity=4,
 Str=<S(S),U(U)><S,1*H><S,1*H><S,1*H>m2,
 Unf=OtherCon []] =
    [] \r [w_s569t w1_s569u w2_s569v w3_s569w]
        case w1_s569u of w4_s569x {
          Data.Type.Equality.Refl ->
              case w2_s569v of w5_s569y {
                Data.Type.Equality.Refl ->
                    case w3_s569w of w6_s569z {
                      Data.Type.Equality.Refl ->
                          case
                              Data.Type.Equality.$w$cenumFromThenTo
                                  w_s569t w4_s569x w5_s569y w6_s569z
                          of
                          { (#,#) ww1_s569B [Occ=Once] ww2_s569C [Occ=Once] ->
                                : [ww1_s569B ww2_s569C];
                          };
                    };
              };
        };

Data.Type.Equality.$fEnum:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     GHC.Enum.Enum (a Data.Type.Equality.:~: b)
[GblId[DFunId], Arity=1, Str=<L,U(U)>m] =
    [] \r [$d~_s569D]
        let {
          sat_s569L [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> [a_a5560 Data.Type.Equality.:~: b_a5561]
          [LclId] =
              [$d~_s569D] \r [eta_B3 eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~:_$cenumFromThenTo
                      $d~_s569D eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s569K [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> [a_a5560 Data.Type.Equality.:~: b_a5561]
          [LclId] =
              [$d~_s569D] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~:_$cenumFromTo
                      $d~_s569D eta_B2 eta_B1; } in
        let {
          sat_s569J [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> [a_a5560 Data.Type.Equality.:~: b_a5561]
          [LclId] =
              [$d~_s569D] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~:_$cenumFromThen
                      $d~_s569D eta_B2 eta_B1; } in
        let {
          sat_s569I [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> [a_a5560 Data.Type.Equality.:~: b_a5561]
          [LclId] =
              [$d~_s569D] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~:_$cenumFrom $d~_s569D eta_B1; } in
        let {
          sat_s569H [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561) -> GHC.Types.Int
          [LclId] =
              [$d~_s569D] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~:_$cfromEnum $d~_s569D eta_B1; } in
        let {
          sat_s569G [Occ=Once]
            :: GHC.Types.Int -> a_a5560 Data.Type.Equality.:~: b_a5561
          [LclId] =
              [$d~_s569D] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~:_$ctoEnum $d~_s569D eta_B1; } in
        let {
          sat_s569F [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> a_a5560 Data.Type.Equality.:~: b_a5561
          [LclId] =
              [$d~_s569D] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~:_$csucc $d~_s569D eta_B1; } in
        let {
          sat_s569E [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> a_a5560 Data.Type.Equality.:~: b_a5561
          [LclId] =
              [$d~_s569D] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~:_$csucc $d~_s569D eta_B1;
        } in 
          GHC.Enum.C:Enum [sat_s569E
                           sat_s569F
                           sat_s569G
                           sat_s569H
                           sat_s569I
                           sat_s569J
                           sat_s569K
                           sat_s569L];

Data.Type.Equality.$fEnum:~~:_$cfromEnum
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b) -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [$d~~_s569M eta_s569N]
        case GHC.Types.heq_sel $d~~_s569M of {
          (##) ->
              case eta_s569N of {
                Data.Type.Equality.HRefl -> Data.Type.Equality.$fEnum:~:3;
              };
        };

Data.Type.Equality.$fEnum:~~:1
  :: forall k1 (a :: k1) k2 (b :: k2). a Data.Type.Equality.:~~: b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_r5689 of sat_s569P {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s569P;
        };

Data.Type.Equality.$fEnum:~~:_$ctoEnum
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     GHC.Types.Int -> a Data.Type.Equality.:~~: b
[GblId,
 Arity=2,
 Str=<S(S),1*U(1*U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [$d~~_s569Q eta_s569R]
        case GHC.Types.heq_sel $d~~_s569Q of {
          (##) ->
              case eta_s569R of {
                GHC.Types.I# ds_s569T [Occ=Once!] ->
                    case ds_s569T of {
                      __DEFAULT -> Data.Type.Equality.$fEnum:~~:1;
                      0# -> Data.Type.Equality.$WHRefl;
                    };
              };
        };

Data.Type.Equality.$fEnum:~~:_$csucc
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b) -> a Data.Type.Equality.:~~: b
[GblId, Arity=2, Str=<B,U(U)><B,A>x, Unf=OtherCon []] =
    [] \r [$d~~_s569V eta_s569W]
        case GHC.Types.heq_sel $d~~_s569V of {
          (##) ->
              case GHC.Types.heq_sel $d~~_s569V of {
                (##) -> Data.Type.Equality.$fEnum:~~:1;
              };
        };

Data.Type.Equality.$w$cenumFromTo1 [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=3, Str=<S(S),U(U)><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s569X w1_s569Y w2_s569Z]
        case GHC.Types.heq_sel w_s569X of {
          (##) ->
              case GHC.Types.heq_sel w_s569X of {
                (##) ->
                    let {
                      go_s56a0 [Occ=LoopBreaker]
                        :: GHC.Prim.Int# -> [a_s55KD Data.Type.Equality.:~~: b_s55KE]
                      [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                          sat-only [go_s56a0] \r [x_s56a1]
                              let {
                                sat_s56a6 [Occ=Once] :: [a_s55KD Data.Type.Equality.:~~: b_s55KE]
                                [LclId] =
                                    [go_s56a0 x_s56a1] \u []
                                        case x_s56a1 of wild_s56a4 {
                                          __DEFAULT ->
                                              case +# [wild_s56a4 1#] of sat_s56a5 {
                                                __DEFAULT -> go_s56a0 sat_s56a5;
                                              };
                                          0# -> [] [];
                                        }; } in
                              let {
                                sat_s56a3 [Occ=Once] :: a_s55KD Data.Type.Equality.:~~: b_s55KE
                                [LclId] =
                                    [x_s56a1] \u []
                                        case x_s56a1 of {
                                          __DEFAULT -> Data.Type.Equality.$fEnum:~~:1;
                                          0# -> Data.Type.Equality.$WHRefl;
                                        };
                              } in  : [sat_s56a3 sat_s56a6];
                    } in  go_s56a0 0#;
              };
        };

Data.Type.Equality.$fEnum:~~:_$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=3, Str=<S(S),U(U)><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s56a7 w1_s56a8 w2_s56a9]
        case w1_s56a8 of w3_s56aa {
          Data.Type.Equality.HRefl ->
              case w2_s56a9 of w4_s56ab {
                Data.Type.Equality.HRefl ->
                    Data.Type.Equality.$w$cenumFromTo1 w_s56a7 w3_s56aa w4_s56ab;
              };
        };

Data.Type.Equality.$w$cenumFromThen1 [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=3, Str=<S(S),U(U)><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s56ac w1_s56ad w2_s56ae]
        case GHC.Types.heq_sel w_s56ac of {
          (##) ->
              case GHC.Types.heq_sel w_s56ac of {
                (##) ->
                    let {
                      sat_s56af [Occ=Once]
                        :: GHC.Types.Int -> a_s55KL Data.Type.Equality.:~~: b_s55KM
                      [LclId] =
                          [w_s56ac] \r [eta_B1]
                              Data.Type.Equality.$fEnum:~~:_$ctoEnum w_s56ac eta_B1;
                    } in  GHC.Base.map sat_s56af Data.Type.Equality.$fEnum:~:2;
              };
        };

Data.Type.Equality.$fEnum:~~:_$cenumFromThen [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=3, Str=<S(S),U(U)><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s56ag w1_s56ah w2_s56ai]
        case w1_s56ah of w3_s56aj {
          Data.Type.Equality.HRefl ->
              case w2_s56ai of w4_s56ak {
                Data.Type.Equality.HRefl ->
                    Data.Type.Equality.$w$cenumFromThen1 w_s56ag w3_s56aj w4_s56ak;
              };
        };

Data.Type.Equality.$w$cenumFrom1 [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=2, Str=<S(S),U(U)><L,A>, Unf=OtherCon []] =
    [] \r [w_s56al w1_s56am]
        case GHC.Types.heq_sel w_s56al of {
          (##) ->
              case GHC.Types.heq_sel w_s56al of {
                (##) ->
                    let {
                      go_s56an [Occ=LoopBreaker]
                        :: GHC.Prim.Int# -> [a_s55KU Data.Type.Equality.:~~: b_s55KV]
                      [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                          sat-only [go_s56an] \r [x_s56ao]
                              let {
                                sat_s56at [Occ=Once] :: [a_s55KU Data.Type.Equality.:~~: b_s55KV]
                                [LclId] =
                                    [go_s56an x_s56ao] \u []
                                        case x_s56ao of wild_s56ar {
                                          __DEFAULT ->
                                              case +# [wild_s56ar 1#] of sat_s56as {
                                                __DEFAULT -> go_s56an sat_s56as;
                                              };
                                          9223372036854775807# -> [] [];
                                        }; } in
                              let {
                                sat_s56aq [Occ=Once] :: a_s55KU Data.Type.Equality.:~~: b_s55KV
                                [LclId] =
                                    [x_s56ao] \u []
                                        case x_s56ao of {
                                          __DEFAULT -> Data.Type.Equality.$fEnum:~~:1;
                                          0# -> Data.Type.Equality.$WHRefl;
                                        };
                              } in  : [sat_s56aq sat_s56at];
                    } in  go_s56an 0#;
              };
        };

Data.Type.Equality.$fEnum:~~:_$cenumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=2, Str=<S(S),U(U)><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s56au w1_s56av]
        case w1_s56av of w2_s56aw {
          Data.Type.Equality.HRefl ->
              Data.Type.Equality.$w$cenumFrom1 w_s56au w2_s56aw;
        };

Data.Type.Equality.$w$cenumFromThenTo1 [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b)
     -> (# a Data.Type.Equality.:~~: b, [a Data.Type.Equality.:~~: b] #)
[GblId, Arity=4, Str=<S(S),U(U)><L,A><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s56ax w1_s56ay w2_s56az w3_s56aA]
        case GHC.Types.heq_sel w_s56ax of {
          (##) ->
              case GHC.Types.heq_sel w_s56ax of {
                (##) ->
                    let {
                      sat_s56aJ [Occ=Once] :: [a_s55L8 Data.Type.Equality.:~~: b_s55L9]
                      [LclId] =
                          [] \u []
                              let {
                                go_up_s56aB [Occ=LoopBreaker]
                                  :: GHC.Prim.Int# -> [a_s55L8 Data.Type.Equality.:~~: b_s55L9]
                                [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                    sat-only [go_up_s56aB] \r [x_s56aC]
                                        case ># [x_s56aC 0#] of {
                                          __DEFAULT ->
                                              let {
                                                sat_s56aG [Occ=Once]
                                                  :: [a_s55L8 Data.Type.Equality.:~~: b_s55L9]
                                                [LclId] =
                                                    [go_up_s56aB x_s56aC] \u []
                                                        go_up_s56aB x_s56aC; } in
                                              let {
                                                sat_s56aF [Occ=Once]
                                                  :: a_s55L8 Data.Type.Equality.:~~: b_s55L9
                                                [LclId] =
                                                    [x_s56aC] \u []
                                                        case x_s56aC of {
                                                          __DEFAULT ->
                                                              Data.Type.Equality.$fEnum:~~:1;
                                                          0# -> Data.Type.Equality.$WHRefl;
                                                        };
                                              } in  : [sat_s56aF sat_s56aG];
                                          1# ->
                                              let {
                                                sat_s56aI [Occ=Once]
                                                  :: a_s55L8 Data.Type.Equality.:~~: b_s55L9
                                                [LclId] =
                                                    [x_s56aC] \u []
                                                        case x_s56aC of {
                                                          __DEFAULT ->
                                                              Data.Type.Equality.$fEnum:~~:1;
                                                          0# -> Data.Type.Equality.$WHRefl;
                                                        };
                                              } in  : [sat_s56aI GHC.Types.[]];
                                        };
                              } in  go_up_s56aB 0#;
                    } in  (#,#) [Data.Type.Equality.$WHRefl sat_s56aJ];
              };
        };

Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b)
     -> [a Data.Type.Equality.:~~: b]
[GblId,
 Arity=4,
 Str=<S(S),U(U)><S,1*H><S,1*H><S,1*H>m2,
 Unf=OtherCon []] =
    [] \r [w_s56aK w1_s56aL w2_s56aM w3_s56aN]
        case w1_s56aL of w4_s56aO {
          Data.Type.Equality.HRefl ->
              case w2_s56aM of w5_s56aP {
                Data.Type.Equality.HRefl ->
                    case w3_s56aN of w6_s56aQ {
                      Data.Type.Equality.HRefl ->
                          case
                              Data.Type.Equality.$w$cenumFromThenTo1
                                  w_s56aK w4_s56aO w5_s56aP w6_s56aQ
                          of
                          { (#,#) ww1_s56aS [Occ=Once] ww2_s56aT [Occ=Once] ->
                                : [ww1_s56aS ww2_s56aT];
                          };
                    };
              };
        };

Data.Type.Equality.$fEnum:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     GHC.Enum.Enum (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Arity=1, Str=<L,U(U)>m] =
    [] \r [$d~~_s56aU]
        let {
          sat_s56b2 [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> [a_a554X Data.Type.Equality.:~~: b_a554Y]
          [LclId] =
              [$d~~_s56aU] \r [eta_B3 eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo
                      $d~~_s56aU eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s56b1 [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> [a_a554X Data.Type.Equality.:~~: b_a554Y]
          [LclId] =
              [$d~~_s56aU] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$cenumFromTo
                      $d~~_s56aU eta_B2 eta_B1; } in
        let {
          sat_s56b0 [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> [a_a554X Data.Type.Equality.:~~: b_a554Y]
          [LclId] =
              [$d~~_s56aU] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$cenumFromThen
                      $d~~_s56aU eta_B2 eta_B1; } in
        let {
          sat_s56aZ [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> [a_a554X Data.Type.Equality.:~~: b_a554Y]
          [LclId] =
              [$d~~_s56aU] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$cenumFrom $d~~_s56aU eta_B1; } in
        let {
          sat_s56aY [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y) -> GHC.Types.Int
          [LclId] =
              [$d~~_s56aU] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$cfromEnum $d~~_s56aU eta_B1; } in
        let {
          sat_s56aX [Occ=Once]
            :: GHC.Types.Int -> a_a554X Data.Type.Equality.:~~: b_a554Y
          [LclId] =
              [$d~~_s56aU] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$ctoEnum $d~~_s56aU eta_B1; } in
        let {
          sat_s56aW [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> a_a554X Data.Type.Equality.:~~: b_a554Y
          [LclId] =
              [$d~~_s56aU] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$csucc $d~~_s56aU eta_B1; } in
        let {
          sat_s56aV [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> a_a554X Data.Type.Equality.:~~: b_a554Y
          [LclId] =
              [$d~~_s56aU] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$csucc $d~~_s56aU eta_B1;
        } in 
          GHC.Enum.C:Enum [sat_s56aV
                           sat_s56aW
                           sat_s56aX
                           sat_s56aY
                           sat_s56aZ
                           sat_s56b0
                           sat_s56b1
                           sat_s56b2];

Data.Type.Equality.$fTestEqualityk:~:1
  :: forall k (a :: k). GHC.Base.Maybe (a Data.Type.Equality.:~: a)
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [Data.Type.Equality.$WRefl];

Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality
  :: forall k (a1 :: k) (a2 :: k) (b :: k).
     (a1 Data.Type.Equality.:~: a2)
     -> (a1 Data.Type.Equality.:~: b)
     -> GHC.Base.Maybe (a2 Data.Type.Equality.:~: b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_s56b3 ds1_s56b4]
        case ds_s56b3 of {
          Data.Type.Equality.Refl ->
              case ds1_s56b4 of {
                Data.Type.Equality.Refl -> Data.Type.Equality.$fTestEqualityk:~:1;
              };
        };

Data.Type.Equality.$fTestEqualityk:~: [InlPrag=INLINE (sat-args=0)]
  :: forall k (a :: k).
     Data.Type.Equality.TestEquality ((Data.Type.Equality.:~:) a)
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality eta_B2 eta_B1;

Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality
  :: forall k k1 (a1 :: k1) (a2 :: k) (b :: k).
     (a1 Data.Type.Equality.:~~: a2)
     -> (a1 Data.Type.Equality.:~~: b)
     -> GHC.Base.Maybe (a2 Data.Type.Equality.:~: b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(A,U)><S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_s56b7 ds1_s56b8]
        case ds_s56b7 of {
          Data.Type.Equality.HRefl ->
              case ds1_s56b8 of {
                Data.Type.Equality.HRefl -> Data.Type.Equality.$fTestEqualityk:~:1;
              };
        };

Data.Type.Equality.$fTestEqualityk:~~: [InlPrag=INLINE (sat-args=0)]
  :: forall k k1 (a :: k1).
     Data.Type.Equality.TestEquality ((Data.Type.Equality.:~~:) a)
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(A,U)><S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality
            eta_B2 eta_B1;

Data.Type.Equality.$fEq:~:_$c==
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [ds_s56bb ds1_s56bc]
        case ds_s56bb of {
          Data.Type.Equality.Refl ->
              case ds1_s56bc of {
                Data.Type.Equality.Refl -> GHC.Types.True [];
              };
        };

Data.Type.Equality.$fEq:~:_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [eta_s56bf eta1_s56bg]
        case eta_s56bf of {
          Data.Type.Equality.Refl ->
              case eta1_s56bg of {
                Data.Type.Equality.Refl -> GHC.Types.False [];
              };
        };

Data.Type.Equality.$fEq:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Classes.Eq (a Data.Type.Equality.:~: b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [Data.Type.Equality.$fEq:~:_$c==
                                     Data.Type.Equality.$fEq:~:_$c/=];

Data.Type.Equality.$fRead:~:3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Refl"#;

Data.Type.Equality.$fRead:~:2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Type.Equality.$fRead:~:3;

Data.Type.Equality.$fShow:~:_$cshowsPrec
  :: forall k (a :: k) (b :: k).
     GHC.Types.Int -> (a Data.Type.Equality.:~: b) -> GHC.Show.ShowS
[GblId, Arity=3, Str=<L,A><S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s56bj ds1_s56bk eta_s56bl]
        case ds1_s56bk of {
          Data.Type.Equality.Refl ->
              GHC.Base.++ Data.Type.Equality.$fRead:~:2 eta_s56bl;
        };

Data.Type.Equality.$fShow:~:_$cshow
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b) -> GHC.Base.String
[GblId, Arity=1, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [x_s56bn]
        case x_s56bn of {
          Data.Type.Equality.Refl -> Data.Type.Equality.$fRead:~:2;
        };

Data.Type.Equality.$fShow:~:1
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b) -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s56bp eta_s56bq]
        case ds_s56bp of {
          Data.Type.Equality.Refl ->
              GHC.Base.++ Data.Type.Equality.$fRead:~:2 eta_s56bq;
        };

Data.Type.Equality.$fShow:~:_$cshowList
  :: forall k (a :: k) (b :: k).
     [a Data.Type.Equality.:~: b] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s56bs s_s56bt]
        GHC.Show.showList__ Data.Type.Equality.$fShow:~:1 ls_s56bs s_s56bt;

Data.Type.Equality.$fShow:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Show.Show (a Data.Type.Equality.:~: b)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Type.Equality.$fShow:~:_$cshowsPrec
                                    Data.Type.Equality.$fShow:~:_$cshow
                                    Data.Type.Equality.$fShow:~:_$cshowList];

Data.Type.Equality.$fOrd:~:_$c<
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s56bu b1_s56bv]
        case a1_s56bu of {
          Data.Type.Equality.Refl ->
              case b1_s56bv of {
                Data.Type.Equality.Refl -> GHC.Types.False [];
              };
        };

Data.Type.Equality.$fOrd:~:_$ccompare
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s56by b1_s56bz]
        case a1_s56by of {
          Data.Type.Equality.Refl ->
              case b1_s56bz of { Data.Type.Equality.Refl -> GHC.Types.EQ []; };
        };

Data.Type.Equality.$fOrd:~:_$c<=
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s56bC b1_s56bD]
        case b1_s56bD of {
          Data.Type.Equality.Refl ->
              case a1_s56bC of { Data.Type.Equality.Refl -> GHC.Types.True []; };
        };

Data.Type.Equality.$fOrd:~:_$cmax
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> a Data.Type.Equality.:~: b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [x_s56bG y_s56bH]
        case x_s56bG of { Data.Type.Equality.Refl -> y_s56bH; };

Data.Type.Equality.$fOrd:~:_$c>
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s56bJ b1_s56bK]
        case b1_s56bK of {
          Data.Type.Equality.Refl ->
              case a1_s56bJ of {
                Data.Type.Equality.Refl -> GHC.Types.False [];
              };
        };

Data.Type.Equality.$fOrd:~:_$cmin
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> a Data.Type.Equality.:~: b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [x_s56bN y_s56bO]
        case y_s56bO of { Data.Type.Equality.Refl -> x_s56bN; };

Data.Type.Equality.$fOrd:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Classes.Ord (a Data.Type.Equality.:~: b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Type.Equality.$fEq:~:
                                      Data.Type.Equality.$fOrd:~:_$ccompare
                                      Data.Type.Equality.$fOrd:~:_$c<
                                      Data.Type.Equality.$fOrd:~:_$c<=
                                      Data.Type.Equality.$fOrd:~:_$c>
                                      Data.Type.Equality.$fEq:~:_$c==
                                      Data.Type.Equality.$fOrd:~:_$cmax
                                      Data.Type.Equality.$fOrd:~:_$cmin];

Data.Type.Equality.$fRead:~:_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Type.Equality.$fRead:~:2];

Data.Type.Equality.$fRead:~:1
  :: forall k (a :: k).
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ((a Data.Type.Equality.:~: a) -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,A><L,1*C1(U)>m2, Unf=OtherCon []] =
    [] \r [n_s56bQ eta_s56bR]
        let {
          sat_s56bT [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b_X3nkn
          [LclId] =
              [eta_s56bR] \r [a1_s56bS] eta_s56bR Data.Type.Equality.$WRefl;
        } in 
          case
              Text.Read.Lex.$wexpect
                  Data.Type.Equality.$fRead:~:_lexeme sat_s56bT
          of
          { Unit# ww1_s56bV [Occ=Once] ->
                Text.ParserCombinators.ReadP.Look [ww1_s56bV];
          };

Data.Type.Equality.$fRead:~:4
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        ((a Data.Type.Equality.:~: b) -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId, Arity=3, Str=<S(S),1*U(1*U)><L,U><L,U>, Unf=OtherCon []] =
    [] \r [$d~_s56bW eta_s56bX eta1_s56bY]
        case GHC.Types.heq_sel $d~_s56bW of {
          (##) ->
              GHC.Read.list3 Data.Type.Equality.$fRead:~:1 eta_s56bX eta1_s56bY;
        };

Data.Type.Equality.$fRead:~:_$creadsPrec
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (a Data.Type.Equality.:~: b)
[GblId, Arity=2, Str=<S(S),U(U)><L,U>, Unf=OtherCon []] =
    [] \r [$d~_s56bZ eta_s56c0]
        case GHC.Types.heq_sel $d~_s56bZ of {
          (##) ->
              let {
                sat_s56c1 [Occ=Once]
                  :: Text.ParserCombinators.ReadP.P
                       (a_X555E Data.Type.Equality.:~: b_X555G)
                [LclId] =
                    [$d~_s56bZ eta_s56c0] \u []
                        case GHC.Types.heq_sel $d~_s56bZ of {
                          (##) ->
                              GHC.Read.list3
                                  Data.Type.Equality.$fRead:~:1
                                  eta_s56c0
                                  Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                        };
              } in  Text.ParserCombinators.ReadP.run sat_s56c1;
        };

Data.Type.Equality.$fRead:~:_$creadListPrec
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [a Data.Type.Equality.:~: b]
[GblId, Arity=1, Str=<S(S),U(U)>, Unf=OtherCon []] =
    [] \r [$d~_s56c2]
        case GHC.Types.heq_sel $d~_s56c2 of {
          (##) ->
              let {
                sat_s56c5 [Occ=Once]
                  :: Text.ParserCombinators.ReadPrec.ReadPrec
                       (a_X555F Data.Type.Equality.:~: b_X555H)
                [LclId] =
                    [$d~_s56c2] \r [eta_s56c3 eta1_s56c4]
                        case GHC.Types.heq_sel $d~_s56c2 of {
                          (##) ->
                              GHC.Read.list3 Data.Type.Equality.$fRead:~:1 eta_s56c3 eta1_s56c4;
                        };
              } in  GHC.Read.list sat_s56c5;
        };

Data.Type.Equality.$fRead:~:_$creadList
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     Text.ParserCombinators.ReadP.ReadS [a Data.Type.Equality.:~: b]
[GblId, Arity=1, Str=<S(S),U(U)>, Unf=OtherCon []] =
    [] \r [$d~_s56c6]
        case GHC.Types.heq_sel $d~_s56c6 of {
          (##) ->
              let {
                sat_s56ca [Occ=Once]
                  :: Text.ParserCombinators.ReadP.P
                       [a_X555G Data.Type.Equality.:~: b_X555I]
                [LclId] =
                    [$d~_s56c6] \u []
                        case GHC.Types.heq_sel $d~_s56c6 of {
                          (##) ->
                              let {
                                sat_s56c9 [Occ=Once]
                                  :: Text.ParserCombinators.ReadPrec.ReadPrec
                                       (b_X555I Data.Type.Equality.:~: b_X555I)
                                [LclId] =
                                    [] \r [eta_s56c7 eta1_s56c8]
                                        GHC.Read.list3
                                            Data.Type.Equality.$fRead:~:1 eta_s56c7 eta1_s56c8;
                              } in 
                                GHC.Read.list
                                    sat_s56c9
                                    GHC.Read.$fRead()7
                                    Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                        };
              } in  Text.ParserCombinators.ReadP.run sat_s56ca;
        };

Data.Type.Equality.$fRead:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     GHC.Read.Read (a Data.Type.Equality.:~: b)
[GblId[DFunId], Arity=1, Str=<L,U(U)>m] =
    [] \r [$d~_s56cb]
        let {
          sat_s56cf [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [a_X555H Data.Type.Equality.:~: b_X555J]
          [LclId] =
              [$d~_s56cb] \u []
                  Data.Type.Equality.$fRead:~:_$creadListPrec $d~_s56cb; } in
        let {
          sat_s56ce [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (a_X555H Data.Type.Equality.:~: b_X555J)
          [LclId] =
              [$d~_s56cb] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fRead:~:4 $d~_s56cb eta_B2 eta_B1; } in
        let {
          sat_s56cd [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [a_X555H Data.Type.Equality.:~: b_X555J]
          [LclId] =
              [$d~_s56cb] \u []
                  Data.Type.Equality.$fRead:~:_$creadList $d~_s56cb; } in
        let {
          sat_s56cc [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (a_X555H Data.Type.Equality.:~: b_X555J)
          [LclId] =
              [$d~_s56cb] \r [eta_B1]
                  Data.Type.Equality.$fRead:~:_$creadsPrec $d~_s56cb eta_B1;
        } in  GHC.Read.C:Read [sat_s56cc sat_s56cd sat_s56ce sat_s56cf];

Data.Type.Equality.$fBounded:~:_$cmaxBound
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     a Data.Type.Equality.:~: b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [$d~_s56cg]
        case GHC.Types.heq_sel $d~_s56cg of {
          (##) -> Data.Type.Equality.$WRefl;
        };

Data.Type.Equality.$fBounded:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     GHC.Enum.Bounded (a Data.Type.Equality.:~: b)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(U)>m] =
    [] \r [$d~_s56ch]
        let {
          sat_s56cj [Occ=Once] :: a_a551J Data.Type.Equality.:~: b_a551K
          [LclId] =
              [$d~_s56ch] \u []
                  Data.Type.Equality.$fBounded:~:_$cmaxBound $d~_s56ch; } in
        let {
          sat_s56ci [Occ=Once] :: a_a551J Data.Type.Equality.:~: b_a551K
          [LclId] =
              [$d~_s56ch] \u []
                  Data.Type.Equality.$fBounded:~:_$cmaxBound $d~_s56ch;
        } in  GHC.Enum.C:Bounded [sat_s56ci sat_s56cj];

Data.Type.Equality.$fEq:~~:_$c==
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [ds_s56ck ds1_s56cl]
        case ds_s56ck of {
          Data.Type.Equality.HRefl ->
              case ds1_s56cl of {
                Data.Type.Equality.HRefl -> GHC.Types.True [];
              };
        };

Data.Type.Equality.$fEq:~~:_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [eta_s56co eta1_s56cp]
        case eta_s56co of {
          Data.Type.Equality.HRefl ->
              case eta1_s56cp of {
                Data.Type.Equality.HRefl -> GHC.Types.False [];
              };
        };

Data.Type.Equality.$fEq:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     GHC.Classes.Eq (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [Data.Type.Equality.$fEq:~~:_$c==
                                     Data.Type.Equality.$fEq:~~:_$c/=];

Data.Type.Equality.$fRead:~~:3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "HRefl"#;

Data.Type.Equality.$fRead:~~:2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Type.Equality.$fRead:~~:3;

Data.Type.Equality.$fShow:~~:_$cshowsPrec
  :: forall k2 k1 (a :: k1) (b :: k2).
     GHC.Types.Int -> (a Data.Type.Equality.:~~: b) -> GHC.Show.ShowS
[GblId, Arity=3, Str=<L,A><S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s56cs ds1_s56ct eta_s56cu]
        case ds1_s56ct of {
          Data.Type.Equality.HRefl ->
              GHC.Base.++ Data.Type.Equality.$fRead:~~:2 eta_s56cu;
        };

Data.Type.Equality.$fShow:~~:_$cshow
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b) -> GHC.Base.String
[GblId, Arity=1, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [x_s56cw]
        case x_s56cw of {
          Data.Type.Equality.HRefl -> Data.Type.Equality.$fRead:~~:2;
        };

Data.Type.Equality.$fShow:~~:1
  :: forall k2 (b :: k2) k1 (a :: k1).
     (a Data.Type.Equality.:~~: b) -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s56cy eta_s56cz]
        case ds_s56cy of {
          Data.Type.Equality.HRefl ->
              GHC.Base.++ Data.Type.Equality.$fRead:~~:2 eta_s56cz;
        };

Data.Type.Equality.$fShow:~~:_$cshowList
  :: forall k2 k1 (a :: k1) (b :: k2).
     [a Data.Type.Equality.:~~: b] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s56cB s_s56cC]
        GHC.Show.showList__
            Data.Type.Equality.$fShow:~~:1 ls_s56cB s_s56cC;

Data.Type.Equality.$fShow:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     GHC.Show.Show (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Type.Equality.$fShow:~~:_$cshowsPrec
                                    Data.Type.Equality.$fShow:~~:_$cshow
                                    Data.Type.Equality.$fShow:~~:_$cshowList];

Data.Type.Equality.$fOrd:~~:_$c<
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s56cD b1_s56cE]
        case a1_s56cD of {
          Data.Type.Equality.HRefl ->
              case b1_s56cE of {
                Data.Type.Equality.HRefl -> GHC.Types.False [];
              };
        };

Data.Type.Equality.$fOrd:~~:_$ccompare
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s56cH b1_s56cI]
        case a1_s56cH of {
          Data.Type.Equality.HRefl ->
              case b1_s56cI of { Data.Type.Equality.HRefl -> GHC.Types.EQ []; };
        };

Data.Type.Equality.$fOrd:~~:_$c<=
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s56cL b1_s56cM]
        case b1_s56cM of {
          Data.Type.Equality.HRefl ->
              case a1_s56cL of {
                Data.Type.Equality.HRefl -> GHC.Types.True [];
              };
        };

Data.Type.Equality.$fOrd:~~:_$cmax
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> a Data.Type.Equality.:~~: b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_s56cP y_s56cQ]
        case x_s56cP of { Data.Type.Equality.HRefl -> y_s56cQ; };

Data.Type.Equality.$fOrd:~~:_$c>
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s56cS b1_s56cT]
        case b1_s56cT of {
          Data.Type.Equality.HRefl ->
              case a1_s56cS of {
                Data.Type.Equality.HRefl -> GHC.Types.False [];
              };
        };

Data.Type.Equality.$fOrd:~~:_$cmin
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> a Data.Type.Equality.:~~: b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [x_s56cW y_s56cX]
        case y_s56cX of { Data.Type.Equality.HRefl -> x_s56cW; };

Data.Type.Equality.$fOrd:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     GHC.Classes.Ord (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Type.Equality.$fEq:~~:
                                      Data.Type.Equality.$fOrd:~~:_$ccompare
                                      Data.Type.Equality.$fOrd:~~:_$c<
                                      Data.Type.Equality.$fOrd:~~:_$c<=
                                      Data.Type.Equality.$fOrd:~~:_$c>
                                      Data.Type.Equality.$fEq:~~:_$c==
                                      Data.Type.Equality.$fOrd:~~:_$cmax
                                      Data.Type.Equality.$fOrd:~~:_$cmin];

Data.Type.Equality.$fRead:~~:_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Type.Equality.$fRead:~~:2];

Data.Type.Equality.$fRead:~~:1
  :: forall k1 (a :: k1).
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ((a Data.Type.Equality.:~~: a) -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,A><L,1*C1(U)>m2, Unf=OtherCon []] =
    [] \r [n_s56cZ eta_s56d0]
        let {
          sat_s56d2 [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b_X3nkW
          [LclId] =
              [eta_s56d0] \r [a1_s56d1] eta_s56d0 Data.Type.Equality.$WHRefl;
        } in 
          case
              Text.Read.Lex.$wexpect
                  Data.Type.Equality.$fRead:~~:_lexeme sat_s56d2
          of
          { Unit# ww1_s56d4 [Occ=Once] ->
                Text.ParserCombinators.ReadP.Look [ww1_s56d4];
          };

Data.Type.Equality.$fRead:~~:4
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        ((a Data.Type.Equality.:~~: b)
         -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId, Arity=3, Str=<S(S),1*U(1*U)><L,U><L,U>, Unf=OtherCon []] =
    [] \r [$d~~_s56d5 eta_s56d6 eta1_s56d7]
        case GHC.Types.heq_sel $d~~_s56d5 of {
          (##) ->
              GHC.Read.list3 Data.Type.Equality.$fRead:~~:1 eta_s56d6 eta1_s56d7;
        };

Data.Type.Equality.$fRead:~~:_$creadsPrec
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (a Data.Type.Equality.:~~: b)
[GblId, Arity=2, Str=<S(S),U(U)><L,U>, Unf=OtherCon []] =
    [] \r [$d~~_s56d8 eta_s56d9]
        case GHC.Types.heq_sel $d~~_s56d8 of {
          (##) ->
              let {
                sat_s56da [Occ=Once]
                  :: Text.ParserCombinators.ReadP.P
                       (a_X553z Data.Type.Equality.:~~: b_X553B)
                [LclId] =
                    [$d~~_s56d8 eta_s56d9] \u []
                        case GHC.Types.heq_sel $d~~_s56d8 of {
                          (##) ->
                              GHC.Read.list3
                                  Data.Type.Equality.$fRead:~~:1
                                  eta_s56d9
                                  Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                        };
              } in  Text.ParserCombinators.ReadP.run sat_s56da;
        };

Data.Type.Equality.$fRead:~~:_$creadListPrec
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [a Data.Type.Equality.:~~: b]
[GblId, Arity=1, Str=<S(S),U(U)>, Unf=OtherCon []] =
    [] \r [$d~~_s56db]
        case GHC.Types.heq_sel $d~~_s56db of {
          (##) ->
              let {
                sat_s56de [Occ=Once]
                  :: Text.ParserCombinators.ReadPrec.ReadPrec
                       (a_X553A Data.Type.Equality.:~~: b_X553C)
                [LclId] =
                    [$d~~_s56db] \r [eta_s56dc eta1_s56dd]
                        case GHC.Types.heq_sel $d~~_s56db of {
                          (##) ->
                              GHC.Read.list3 Data.Type.Equality.$fRead:~~:1 eta_s56dc eta1_s56dd;
                        };
              } in  GHC.Read.list sat_s56de;
        };

Data.Type.Equality.$fRead:~~:_$creadList
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     Text.ParserCombinators.ReadP.ReadS [a Data.Type.Equality.:~~: b]
[GblId, Arity=1, Str=<S(S),U(U)>, Unf=OtherCon []] =
    [] \r [$d~~_s56df]
        case GHC.Types.heq_sel $d~~_s56df of {
          (##) ->
              let {
                sat_s56dj [Occ=Once]
                  :: Text.ParserCombinators.ReadP.P
                       [a_X553B Data.Type.Equality.:~~: b_X553D]
                [LclId] =
                    [$d~~_s56df] \u []
                        case GHC.Types.heq_sel $d~~_s56df of {
                          (##) ->
                              let {
                                sat_s56di [Occ=Once]
                                  :: Text.ParserCombinators.ReadPrec.ReadPrec
                                       (b_X553D Data.Type.Equality.:~~: b_X553D)
                                [LclId] =
                                    [] \r [eta_s56dg eta1_s56dh]
                                        GHC.Read.list3
                                            Data.Type.Equality.$fRead:~~:1 eta_s56dg eta1_s56dh;
                              } in 
                                GHC.Read.list
                                    sat_s56di
                                    GHC.Read.$fRead()7
                                    Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                        };
              } in  Text.ParserCombinators.ReadP.run sat_s56dj;
        };

Data.Type.Equality.$fRead:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     GHC.Read.Read (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Arity=1, Str=<L,U(U)>m] =
    [] \r [$d~~_s56dk]
        let {
          sat_s56do [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [a_X553C Data.Type.Equality.:~~: b_X553E]
          [LclId] =
              [$d~~_s56dk] \u []
                  Data.Type.Equality.$fRead:~~:_$creadListPrec $d~~_s56dk; } in
        let {
          sat_s56dn [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (a_X553C Data.Type.Equality.:~~: b_X553E)
          [LclId] =
              [$d~~_s56dk] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fRead:~~:4 $d~~_s56dk eta_B2 eta_B1; } in
        let {
          sat_s56dm [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [a_X553C Data.Type.Equality.:~~: b_X553E]
          [LclId] =
              [$d~~_s56dk] \u []
                  Data.Type.Equality.$fRead:~~:_$creadList $d~~_s56dk; } in
        let {
          sat_s56dl [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (a_X553C Data.Type.Equality.:~~: b_X553E)
          [LclId] =
              [$d~~_s56dk] \r [eta_B1]
                  Data.Type.Equality.$fRead:~~:_$creadsPrec $d~~_s56dk eta_B1;
        } in  GHC.Read.C:Read [sat_s56dl sat_s56dm sat_s56dn sat_s56do];

Data.Type.Equality.$fBounded:~~:_$cmaxBound
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     a Data.Type.Equality.:~~: b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [$d~~_s56dp]
        case GHC.Types.heq_sel $d~~_s56dp of {
          (##) -> Data.Type.Equality.$WHRefl;
        };

Data.Type.Equality.$fBounded:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     GHC.Enum.Bounded (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(U)>m] =
    [] \r [$d~~_s56dq]
        let {
          sat_s56ds [Occ=Once] :: a_a54YX Data.Type.Equality.:~~: b_a54YY
          [LclId] =
              [$d~~_s56dq] \u []
                  Data.Type.Equality.$fBounded:~~:_$cmaxBound $d~~_s56dq; } in
        let {
          sat_s56dr [Occ=Once] :: a_a54YX Data.Type.Equality.:~~: b_a54YY
          [LclId] =
              [$d~~_s56dq] \u []
                  Data.Type.Equality.$fBounded:~~:_$cmaxBound $d~~_s56dq;
        } in  GHC.Enum.C:Bounded [sat_s56dr sat_s56ds];

Data.Type.Equality.sym
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b) -> b Data.Type.Equality.:~: a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U(U)>m, Unf=OtherCon []] =
    [] \r [ds_s56dt]
        case ds_s56dt of {
          Data.Type.Equality.Refl -> Data.Type.Equality.$WRefl;
        };

Data.Type.Equality.trans
  :: forall k (a :: k) (b :: k) (c :: k).
     (a Data.Type.Equality.:~: b)
     -> (b Data.Type.Equality.:~: c) -> a Data.Type.Equality.:~: c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s56dv ds1_s56dw]
        case ds_s56dv of {
          Data.Type.Equality.Refl ->
              case ds1_s56dw of {
                Data.Type.Equality.Refl -> Data.Type.Equality.$WRefl;
              };
        };

Data.Type.Equality.castWith
  :: forall a b. (a Data.Type.Equality.:~: b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s56dz x_s56dA]
        case ds_s56dz of { Data.Type.Equality.Refl -> x_s56dA; };

Data.Type.Equality.gcastWith
  :: forall k (a :: k) (b :: k) r.
     (a Data.Type.Equality.:~: b)
     -> (((a :: k) Data.Type.Equality.~ (b :: k)) => r) -> r
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s56dC x_s56dD]
        case ds_s56dC of {
          Data.Type.Equality.Refl ->
              let {
                sat_s56dF [Occ=Once]
                  :: (a_a54Yh :: k_a54Yg) Data.Type.Equality.~ (b_a54Yi :: k_a54Yg)
                [LclId] =
                    CCCS GHC.Types.Eq#! [];
              } in  x_s56dD sat_s56dF;
        };

Data.Type.Equality.apply
  :: forall k1 k2 (f :: k1 -> k2) (g :: k1
                                        -> k2) (a :: k1) (b :: k1).
     (f Data.Type.Equality.:~: g)
     -> (a Data.Type.Equality.:~: b) -> f a Data.Type.Equality.:~: g b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s56dG ds1_s56dH]
        case ds_s56dG of {
          Data.Type.Equality.Refl ->
              case ds1_s56dH of {
                Data.Type.Equality.Refl -> Data.Type.Equality.$WRefl;
              };
        };

Data.Type.Equality.inner
  :: forall k1 k2 (f :: k1 -> k2) (a :: k1) (g :: k1
                                                  -> k2) (b :: k1).
     (f a Data.Type.Equality.:~: g b) -> a Data.Type.Equality.:~: b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U(U)>m, Unf=OtherCon []] =
    [] \r [ds_s56dK]
        case ds_s56dK of {
          Data.Type.Equality.Refl -> Data.Type.Equality.$WRefl;
        };

Data.Type.Equality.outer
  :: forall k1 k2 (f :: k1 -> k2) (a :: k1) (g :: k1
                                                  -> k2) (b :: k1).
     (f a Data.Type.Equality.:~: g b) -> f Data.Type.Equality.:~: g
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U(U)>m, Unf=OtherCon []] =
    [] \r [ds_s56dM]
        case ds_s56dM of {
          Data.Type.Equality.Refl -> Data.Type.Equality.$WRefl;
        };

Data.Type.Equality.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Type.Equality.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$trModule4];

Data.Type.Equality.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Type.Equality"#;

Data.Type.Equality.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$trModule2];

Data.Type.Equality.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Type.Equality.$trModule3
                                     Data.Type.Equality.$trModule1];

$krep_r568a :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

$krep1_r568b :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep2_r568c :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r568b
                                         GHC.Types.krep$*];

$krep3_r568d :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

Data.Type.Equality.$tc:~~:1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r568d $krep2_r568c];

$krep4_r568e :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r568d
                                         GHC.Types.krep$*];

Data.Type.Equality.$tc:~:1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r568d $krep4_r568e];

Data.Type.Equality.$tcTestEquality1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r568e $krep_r568a];

$krep5_r568f :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r568d $krep_r568a];

Data.Type.Equality.$tc~1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r568d $krep5_r568f];

$krep6_r568g :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep7_r568h :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep6_r568g GHC.Types.[]];

$krep8_r568i :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r568b $krep7_r568h];

$krep9_r568j :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r568d $krep8_r568i];

$krep10_r568k :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r568d $krep9_r568j];

$krep11_r568l :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tc~~
                                              $krep10_r568k];

Data.Type.Equality.$tc~3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "~"#;

Data.Type.Equality.$tc~2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc~3];

Data.Type.Equality.$tc~ :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11470827771536267938##
                                    3625512399163125290##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc~2
                                    1#
                                    Data.Type.Equality.$tc~1];

$krep12_r568m :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Type.Equality.$tc~
                                              $krep9_r568j];

Data.Type.Equality.$tc'C:~1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r568l $krep12_r568m];

Data.Type.Equality.$tc'C:~3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:~"#;

Data.Type.Equality.$tc'C:~2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc'C:~3];

Data.Type.Equality.$tc'C:~ :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6023002849810837484##
                                    5427525916893308990##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc'C:~2
                                    3#
                                    Data.Type.Equality.$tc'C:~1];

Data.Type.Equality.$tc:~:3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ":~:"#;

Data.Type.Equality.$tc:~:2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc:~:3];

Data.Type.Equality.$tc:~: :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10597498348876412676##
                                    16281320961088145472##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc:~:2
                                    1#
                                    Data.Type.Equality.$tc:~:1];

$krep13_r568n :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r568b GHC.Types.[]];

$krep14_r568o :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r568b $krep13_r568n];

$krep15_r568p :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r568d $krep14_r568o];

Data.Type.Equality.$tc'Refl1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Type.Equality.$tc:~:
                                              $krep15_r568p];

Data.Type.Equality.$tc'Refl3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Refl"#;

Data.Type.Equality.$tc'Refl2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc'Refl3];

Data.Type.Equality.$tc'Refl :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16680242040484769242##
                                    2864388906562808793##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc'Refl2
                                    2#
                                    Data.Type.Equality.$tc'Refl1];

Data.Type.Equality.$tc:~~:3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ":~~:"#;

Data.Type.Equality.$tc:~~:2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc:~~:3];

Data.Type.Equality.$tc:~~: :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4361259188665111259##
                                    11706467685470543992##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc:~~:2
                                    2#
                                    Data.Type.Equality.$tc:~~:1];

$krep16_r568q :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r568d $krep15_r568p];

Data.Type.Equality.$tc'HRefl1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Type.Equality.$tc:~~:
                                              $krep16_r568q];

Data.Type.Equality.$tc'HRefl3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'HRefl"#;

Data.Type.Equality.$tc'HRefl2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc'HRefl3];

Data.Type.Equality.$tc'HRefl :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4486133906173668740##
                                    6341741464738386857##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc'HRefl2
                                    2#
                                    Data.Type.Equality.$tc'HRefl1];

Data.Type.Equality.$tcTestEquality3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "TestEquality"#;

Data.Type.Equality.$tcTestEquality2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tcTestEquality3];

Data.Type.Equality.$tcTestEquality :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2944680549948432194##
                                    17791533211054855448##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tcTestEquality2
                                    1#
                                    Data.Type.Equality.$tcTestEquality1];

Data.Type.Equality.HRefl
  :: forall k2 k2 (a :: k2) (b :: k2).
     ((k2 :: *) GHC.Prim.~# (k2 :: *),
      (b :: k2) GHC.Prim.~# (a :: k2)) =>
     a Data.Type.Equality.:~~: b
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [void_0E void_0E] Data.Type.Equality.HRefl [];

Data.Type.Equality.Refl
  :: forall k (a :: k) (b :: k).
     ((b :: k) GHC.Prim.~# (a :: k)) =>
     a Data.Type.Equality.:~: b
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m,
 Unf=OtherCon []] =
    [] \r [void_0E] Data.Type.Equality.Refl [];


==================== Pre unarise: ====================
2018-03-16 16:00:04.896732211 UTC

Data.Type.Equality.$p1~ [InlPrag=INLINE]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a :: k) GHC.Types.~~ (b :: k)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_s580V] v_s580V;

Data.Type.Equality.testEquality [InlPrag=INLINE]
  :: forall k (f :: k -> *).
     Data.Type.Equality.TestEquality f =>
     forall (a :: k) (b :: k).
     f a -> f b -> GHC.Base.Maybe (a Data.Type.Equality.:~: b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_s580W] v_s580W;

Data.Type.Equality.$WHRefl [InlPrag=INLINE[2]]
  :: forall k2 (a :: k2). a Data.Type.Equality.:~~: a
[GblId[DataConWrapper], Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Type.Equality.HRefl! [GHC.Prim.coercionToken#
                                             GHC.Prim.coercionToken#];

Data.Type.Equality.$WRefl [InlPrag=INLINE[2]]
  :: forall k (a :: k). a Data.Type.Equality.:~: a
[GblId[DataConWrapper], Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Type.Equality.Refl! [GHC.Prim.coercionToken#];

Data.Type.Equality.$f~kab_$cp1~
  :: forall k (a :: k) (b :: k).
     ((a :: k) GHC.Types.~~ (b :: k)) =>
     (a :: k) GHC.Types.~~ (b :: k)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S(S),U(U)>, Unf=OtherCon []] =
    [] \r [$d~~_s580X]
        case GHC.Types.heq_sel $d~~_s580X of { __DEFAULT -> $d~~_s580X; };

Data.Type.Equality.$f~kab [InlPrag=INLINE (sat-args=0)]
  :: forall k (a :: k) (b :: k).
     ((a :: k) GHC.Types.~~ (b :: k)) =>
     (a :: k) Data.Type.Equality.~ (b :: k)
[GblId[DFunId(nt)],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),U(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Type.Equality.$f~kab_$cp1~ eta_B1;

Data.Type.Equality.$fEnum:~:3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Type.Equality.$fEnum:~:_$cfromEnum
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b) -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [$d~_s580Y eta_s580Z]
        case GHC.Types.heq_sel $d~_s580Y of {
          __DEFAULT ->
              case eta_s580Z of {
                Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
                    Data.Type.Equality.$fEnum:~:3;
              };
        };

lvl_r5689 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Type.Equality.toEnum: bad argument"#;

Data.Type.Equality.$fEnum:~:1
  :: forall k (a :: k) (b :: k). a Data.Type.Equality.:~: b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_r5689 of sat_s5811 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s5811;
        };

Data.Type.Equality.$fEnum:~:_$ctoEnum
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     GHC.Types.Int -> a Data.Type.Equality.:~: b
[GblId,
 Arity=2,
 Str=<S(S),1*U(1*U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [$d~_s5812 eta_s5813]
        case GHC.Types.heq_sel $d~_s5812 of {
          __DEFAULT ->
              case eta_s5813 of {
                GHC.Types.I# ds_s5815 [Occ=Once!] ->
                    case ds_s5815 of {
                      __DEFAULT -> Data.Type.Equality.$fEnum:~:1;
                      0# -> Data.Type.Equality.$WRefl;
                    };
              };
        };

Data.Type.Equality.$fEnum:~:_$csucc
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b) -> a Data.Type.Equality.:~: b
[GblId, Arity=2, Str=<B,U(U)><B,A>x, Unf=OtherCon []] =
    [] \r [$d~_s5817 eta_s5818]
        case GHC.Types.heq_sel $d~_s5817 of {
          __DEFAULT ->
              case GHC.Types.heq_sel $d~_s5817 of {
                __DEFAULT -> Data.Type.Equality.$fEnum:~:1;
              };
        };

Data.Type.Equality.$w$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=3, Str=<S(S),U(U)><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s5819 w1_s581a w2_s581b]
        case GHC.Types.heq_sel w_s5819 of {
          __DEFAULT ->
              case GHC.Types.heq_sel w_s5819 of {
                __DEFAULT ->
                    let {
                      go_s581c [Occ=LoopBreaker]
                        :: GHC.Prim.Int# -> [a_s55JT Data.Type.Equality.:~: b_s55JU]
                      [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                          sat-only [go_s581c] \r [x_s581d]
                              let {
                                sat_s581i [Occ=Once] :: [a_s55JT Data.Type.Equality.:~: b_s55JU]
                                [LclId] =
                                    [go_s581c x_s581d] \u []
                                        case x_s581d of wild_s581g {
                                          __DEFAULT ->
                                              case +# [wild_s581g 1#] of sat_s581h {
                                                __DEFAULT -> go_s581c sat_s581h;
                                              };
                                          0# -> [] [];
                                        }; } in
                              let {
                                sat_s581f [Occ=Once] :: a_s55JT Data.Type.Equality.:~: b_s55JU
                                [LclId] =
                                    [x_s581d] \u []
                                        case x_s581d of {
                                          __DEFAULT -> Data.Type.Equality.$fEnum:~:1;
                                          0# -> Data.Type.Equality.$WRefl;
                                        };
                              } in  : [sat_s581f sat_s581i];
                    } in  go_s581c 0#;
              };
        };

Data.Type.Equality.$fEnum:~:_$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=3, Str=<S(S),U(U)><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s581j w1_s581k w2_s581l]
        case w1_s581k of w3_s581m {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              case w2_s581l of w4_s581n {
                Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
                    Data.Type.Equality.$w$cenumFromTo w_s581j w3_s581m w4_s581n;
              };
        };

Data.Type.Equality.$fEnum:~:2 :: [GHC.Types.Int]
[GblId] =
    [] \u [] GHC.Enum.efdInt 0# 0#;

Data.Type.Equality.$w$cenumFromThen [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=3, Str=<S(S),U(U)><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s581o w1_s581p w2_s581q]
        case GHC.Types.heq_sel w_s581o of {
          __DEFAULT ->
              case GHC.Types.heq_sel w_s581o of {
                __DEFAULT ->
                    let {
                      sat_s581r [Occ=Once]
                        :: GHC.Types.Int -> a_s55K0 Data.Type.Equality.:~: b_s55K1
                      [LclId] =
                          [w_s581o] \r [eta_B1]
                              Data.Type.Equality.$fEnum:~:_$ctoEnum w_s581o eta_B1;
                    } in  GHC.Base.map sat_s581r Data.Type.Equality.$fEnum:~:2;
              };
        };

Data.Type.Equality.$fEnum:~:_$cenumFromThen [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=3, Str=<S(S),U(U)><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s581s w1_s581t w2_s581u]
        case w1_s581t of w3_s581v {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              case w2_s581u of w4_s581w {
                Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
                    Data.Type.Equality.$w$cenumFromThen w_s581s w3_s581v w4_s581w;
              };
        };

Data.Type.Equality.$w$cenumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=2, Str=<S(S),U(U)><L,A>, Unf=OtherCon []] =
    [] \r [w_s581x w1_s581y]
        case GHC.Types.heq_sel w_s581x of {
          __DEFAULT ->
              case GHC.Types.heq_sel w_s581x of {
                __DEFAULT ->
                    let {
                      go_s581z [Occ=LoopBreaker]
                        :: GHC.Prim.Int# -> [a_s55K8 Data.Type.Equality.:~: b_s55K9]
                      [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                          sat-only [go_s581z] \r [x_s581A]
                              let {
                                sat_s581F [Occ=Once] :: [a_s55K8 Data.Type.Equality.:~: b_s55K9]
                                [LclId] =
                                    [go_s581z x_s581A] \u []
                                        case x_s581A of wild_s581D {
                                          __DEFAULT ->
                                              case +# [wild_s581D 1#] of sat_s581E {
                                                __DEFAULT -> go_s581z sat_s581E;
                                              };
                                          9223372036854775807# -> [] [];
                                        }; } in
                              let {
                                sat_s581C [Occ=Once] :: a_s55K8 Data.Type.Equality.:~: b_s55K9
                                [LclId] =
                                    [x_s581A] \u []
                                        case x_s581A of {
                                          __DEFAULT -> Data.Type.Equality.$fEnum:~:1;
                                          0# -> Data.Type.Equality.$WRefl;
                                        };
                              } in  : [sat_s581C sat_s581F];
                    } in  go_s581z 0#;
              };
        };

Data.Type.Equality.$fEnum:~:_$cenumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=2, Str=<S(S),U(U)><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s581G w1_s581H]
        case w1_s581H of w2_s581I {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              Data.Type.Equality.$w$cenumFrom w_s581G w2_s581I;
        };

Data.Type.Equality.$w$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b)
     -> (# a Data.Type.Equality.:~: b, [a Data.Type.Equality.:~: b] #)
[GblId, Arity=4, Str=<S(S),U(U)><L,A><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s581J w1_s581K w2_s581L w3_s581M]
        case GHC.Types.heq_sel w_s581J of {
          __DEFAULT ->
              case GHC.Types.heq_sel w_s581J of {
                __DEFAULT ->
                    let {
                      sat_s581V [Occ=Once] :: [a_s55Kk Data.Type.Equality.:~: b_s55Kl]
                      [LclId] =
                          [] \u []
                              let {
                                go_up_s581N [Occ=LoopBreaker]
                                  :: GHC.Prim.Int# -> [a_s55Kk Data.Type.Equality.:~: b_s55Kl]
                                [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                    sat-only [go_up_s581N] \r [x_s581O]
                                        case ># [x_s581O 0#] of {
                                          __DEFAULT ->
                                              let {
                                                sat_s581S [Occ=Once]
                                                  :: [a_s55Kk Data.Type.Equality.:~: b_s55Kl]
                                                [LclId] =
                                                    [go_up_s581N x_s581O] \u []
                                                        go_up_s581N x_s581O; } in
                                              let {
                                                sat_s581R [Occ=Once]
                                                  :: a_s55Kk Data.Type.Equality.:~: b_s55Kl
                                                [LclId] =
                                                    [x_s581O] \u []
                                                        case x_s581O of {
                                                          __DEFAULT ->
                                                              Data.Type.Equality.$fEnum:~:1;
                                                          0# -> Data.Type.Equality.$WRefl;
                                                        };
                                              } in  : [sat_s581R sat_s581S];
                                          1# ->
                                              let {
                                                sat_s581U [Occ=Once]
                                                  :: a_s55Kk Data.Type.Equality.:~: b_s55Kl
                                                [LclId] =
                                                    [x_s581O] \u []
                                                        case x_s581O of {
                                                          __DEFAULT ->
                                                              Data.Type.Equality.$fEnum:~:1;
                                                          0# -> Data.Type.Equality.$WRefl;
                                                        };
                                              } in  : [sat_s581U GHC.Types.[]];
                                        };
                              } in  go_up_s581N 0#;
                    } in  (#,#) [Data.Type.Equality.$WRefl sat_s581V];
              };
        };

Data.Type.Equality.$fEnum:~:_$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b)
     -> [a Data.Type.Equality.:~: b]
[GblId,
 Arity=4,
 Str=<S(S),U(U)><S,1*H><S,1*H><S,1*H>m2,
 Unf=OtherCon []] =
    [] \r [w_s581W w1_s581X w2_s581Y w3_s581Z]
        case w1_s581X of w4_s5820 {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              case w2_s581Y of w5_s5821 {
                Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
                    case w3_s581Z of w6_s5822 {
                      Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
                          case
                              Data.Type.Equality.$w$cenumFromThenTo
                                  w_s581W w4_s5820 w5_s5821 w6_s5822
                          of
                          { (#,#) ww1_s5824 [Occ=Once] ww2_s5825 [Occ=Once] ->
                                : [ww1_s5824 ww2_s5825];
                          };
                    };
              };
        };

Data.Type.Equality.$fEnum:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     GHC.Enum.Enum (a Data.Type.Equality.:~: b)
[GblId[DFunId], Arity=1, Str=<L,U(U)>m] =
    [] \r [$d~_s5826]
        let {
          sat_s582e [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> [a_a5560 Data.Type.Equality.:~: b_a5561]
          [LclId] =
              [$d~_s5826] \r [eta_B3 eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~:_$cenumFromThenTo
                      $d~_s5826 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s582d [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> [a_a5560 Data.Type.Equality.:~: b_a5561]
          [LclId] =
              [$d~_s5826] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~:_$cenumFromTo
                      $d~_s5826 eta_B2 eta_B1; } in
        let {
          sat_s582c [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> [a_a5560 Data.Type.Equality.:~: b_a5561]
          [LclId] =
              [$d~_s5826] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~:_$cenumFromThen
                      $d~_s5826 eta_B2 eta_B1; } in
        let {
          sat_s582b [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> [a_a5560 Data.Type.Equality.:~: b_a5561]
          [LclId] =
              [$d~_s5826] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~:_$cenumFrom $d~_s5826 eta_B1; } in
        let {
          sat_s582a [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561) -> GHC.Types.Int
          [LclId] =
              [$d~_s5826] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~:_$cfromEnum $d~_s5826 eta_B1; } in
        let {
          sat_s5829 [Occ=Once]
            :: GHC.Types.Int -> a_a5560 Data.Type.Equality.:~: b_a5561
          [LclId] =
              [$d~_s5826] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~:_$ctoEnum $d~_s5826 eta_B1; } in
        let {
          sat_s5828 [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> a_a5560 Data.Type.Equality.:~: b_a5561
          [LclId] =
              [$d~_s5826] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~:_$csucc $d~_s5826 eta_B1; } in
        let {
          sat_s5827 [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> a_a5560 Data.Type.Equality.:~: b_a5561
          [LclId] =
              [$d~_s5826] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~:_$csucc $d~_s5826 eta_B1;
        } in 
          GHC.Enum.C:Enum [sat_s5827
                           sat_s5828
                           sat_s5829
                           sat_s582a
                           sat_s582b
                           sat_s582c
                           sat_s582d
                           sat_s582e];

Data.Type.Equality.$fEnum:~~:_$cfromEnum
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b) -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [$d~~_s582f eta_s582g]
        case GHC.Types.heq_sel $d~~_s582f of {
          __DEFAULT ->
              case eta_s582g of {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                         _ [Occ=Dead, Dmd=<L,A>] ->
                    Data.Type.Equality.$fEnum:~:3;
              };
        };

Data.Type.Equality.$fEnum:~~:1
  :: forall k1 (a :: k1) k2 (b :: k2). a Data.Type.Equality.:~~: b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_r5689 of sat_s582i {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s582i;
        };

Data.Type.Equality.$fEnum:~~:_$ctoEnum
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     GHC.Types.Int -> a Data.Type.Equality.:~~: b
[GblId,
 Arity=2,
 Str=<S(S),1*U(1*U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [$d~~_s582j eta_s582k]
        case GHC.Types.heq_sel $d~~_s582j of {
          __DEFAULT ->
              case eta_s582k of {
                GHC.Types.I# ds_s582m [Occ=Once!] ->
                    case ds_s582m of {
                      __DEFAULT -> Data.Type.Equality.$fEnum:~~:1;
                      0# -> Data.Type.Equality.$WHRefl;
                    };
              };
        };

Data.Type.Equality.$fEnum:~~:_$csucc
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b) -> a Data.Type.Equality.:~~: b
[GblId, Arity=2, Str=<B,U(U)><B,A>x, Unf=OtherCon []] =
    [] \r [$d~~_s582o eta_s582p]
        case GHC.Types.heq_sel $d~~_s582o of {
          __DEFAULT ->
              case GHC.Types.heq_sel $d~~_s582o of {
                __DEFAULT -> Data.Type.Equality.$fEnum:~~:1;
              };
        };

Data.Type.Equality.$w$cenumFromTo1 [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=3, Str=<S(S),U(U)><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s582q w1_s582r w2_s582s]
        case GHC.Types.heq_sel w_s582q of {
          __DEFAULT ->
              case GHC.Types.heq_sel w_s582q of {
                __DEFAULT ->
                    let {
                      go_s582t [Occ=LoopBreaker]
                        :: GHC.Prim.Int# -> [a_s55KD Data.Type.Equality.:~~: b_s55KE]
                      [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                          sat-only [go_s582t] \r [x_s582u]
                              let {
                                sat_s582z [Occ=Once] :: [a_s55KD Data.Type.Equality.:~~: b_s55KE]
                                [LclId] =
                                    [go_s582t x_s582u] \u []
                                        case x_s582u of wild_s582x {
                                          __DEFAULT ->
                                              case +# [wild_s582x 1#] of sat_s582y {
                                                __DEFAULT -> go_s582t sat_s582y;
                                              };
                                          0# -> [] [];
                                        }; } in
                              let {
                                sat_s582w [Occ=Once] :: a_s55KD Data.Type.Equality.:~~: b_s55KE
                                [LclId] =
                                    [x_s582u] \u []
                                        case x_s582u of {
                                          __DEFAULT -> Data.Type.Equality.$fEnum:~~:1;
                                          0# -> Data.Type.Equality.$WHRefl;
                                        };
                              } in  : [sat_s582w sat_s582z];
                    } in  go_s582t 0#;
              };
        };

Data.Type.Equality.$fEnum:~~:_$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=3, Str=<S(S),U(U)><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s582A w1_s582B w2_s582C]
        case w1_s582B of w3_s582D {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              case w2_s582C of w4_s582E {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                         _ [Occ=Dead, Dmd=<L,A>] ->
                    Data.Type.Equality.$w$cenumFromTo1 w_s582A w3_s582D w4_s582E;
              };
        };

Data.Type.Equality.$w$cenumFromThen1 [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=3, Str=<S(S),U(U)><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s582F w1_s582G w2_s582H]
        case GHC.Types.heq_sel w_s582F of {
          __DEFAULT ->
              case GHC.Types.heq_sel w_s582F of {
                __DEFAULT ->
                    let {
                      sat_s582I [Occ=Once]
                        :: GHC.Types.Int -> a_s55KL Data.Type.Equality.:~~: b_s55KM
                      [LclId] =
                          [w_s582F] \r [eta_B1]
                              Data.Type.Equality.$fEnum:~~:_$ctoEnum w_s582F eta_B1;
                    } in  GHC.Base.map sat_s582I Data.Type.Equality.$fEnum:~:2;
              };
        };

Data.Type.Equality.$fEnum:~~:_$cenumFromThen [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=3, Str=<S(S),U(U)><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s582J w1_s582K w2_s582L]
        case w1_s582K of w3_s582M {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              case w2_s582L of w4_s582N {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                         _ [Occ=Dead, Dmd=<L,A>] ->
                    Data.Type.Equality.$w$cenumFromThen1 w_s582J w3_s582M w4_s582N;
              };
        };

Data.Type.Equality.$w$cenumFrom1 [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=2, Str=<S(S),U(U)><L,A>, Unf=OtherCon []] =
    [] \r [w_s582O w1_s582P]
        case GHC.Types.heq_sel w_s582O of {
          __DEFAULT ->
              case GHC.Types.heq_sel w_s582O of {
                __DEFAULT ->
                    let {
                      go_s582Q [Occ=LoopBreaker]
                        :: GHC.Prim.Int# -> [a_s55KU Data.Type.Equality.:~~: b_s55KV]
                      [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                          sat-only [go_s582Q] \r [x_s582R]
                              let {
                                sat_s582W [Occ=Once] :: [a_s55KU Data.Type.Equality.:~~: b_s55KV]
                                [LclId] =
                                    [go_s582Q x_s582R] \u []
                                        case x_s582R of wild_s582U {
                                          __DEFAULT ->
                                              case +# [wild_s582U 1#] of sat_s582V {
                                                __DEFAULT -> go_s582Q sat_s582V;
                                              };
                                          9223372036854775807# -> [] [];
                                        }; } in
                              let {
                                sat_s582T [Occ=Once] :: a_s55KU Data.Type.Equality.:~~: b_s55KV
                                [LclId] =
                                    [x_s582R] \u []
                                        case x_s582R of {
                                          __DEFAULT -> Data.Type.Equality.$fEnum:~~:1;
                                          0# -> Data.Type.Equality.$WHRefl;
                                        };
                              } in  : [sat_s582T sat_s582W];
                    } in  go_s582Q 0#;
              };
        };

Data.Type.Equality.$fEnum:~~:_$cenumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=2, Str=<S(S),U(U)><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s582X w1_s582Y]
        case w1_s582Y of w2_s582Z {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              Data.Type.Equality.$w$cenumFrom1 w_s582X w2_s582Z;
        };

Data.Type.Equality.$w$cenumFromThenTo1 [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b)
     -> (# a Data.Type.Equality.:~~: b, [a Data.Type.Equality.:~~: b] #)
[GblId, Arity=4, Str=<S(S),U(U)><L,A><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s5830 w1_s5831 w2_s5832 w3_s5833]
        case GHC.Types.heq_sel w_s5830 of {
          __DEFAULT ->
              case GHC.Types.heq_sel w_s5830 of {
                __DEFAULT ->
                    let {
                      sat_s583c [Occ=Once] :: [a_s55L8 Data.Type.Equality.:~~: b_s55L9]
                      [LclId] =
                          [] \u []
                              let {
                                go_up_s5834 [Occ=LoopBreaker]
                                  :: GHC.Prim.Int# -> [a_s55L8 Data.Type.Equality.:~~: b_s55L9]
                                [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                    sat-only [go_up_s5834] \r [x_s5835]
                                        case ># [x_s5835 0#] of {
                                          __DEFAULT ->
                                              let {
                                                sat_s5839 [Occ=Once]
                                                  :: [a_s55L8 Data.Type.Equality.:~~: b_s55L9]
                                                [LclId] =
                                                    [go_up_s5834 x_s5835] \u []
                                                        go_up_s5834 x_s5835; } in
                                              let {
                                                sat_s5838 [Occ=Once]
                                                  :: a_s55L8 Data.Type.Equality.:~~: b_s55L9
                                                [LclId] =
                                                    [x_s5835] \u []
                                                        case x_s5835 of {
                                                          __DEFAULT ->
                                                              Data.Type.Equality.$fEnum:~~:1;
                                                          0# -> Data.Type.Equality.$WHRefl;
                                                        };
                                              } in  : [sat_s5838 sat_s5839];
                                          1# ->
                                              let {
                                                sat_s583b [Occ=Once]
                                                  :: a_s55L8 Data.Type.Equality.:~~: b_s55L9
                                                [LclId] =
                                                    [x_s5835] \u []
                                                        case x_s5835 of {
                                                          __DEFAULT ->
                                                              Data.Type.Equality.$fEnum:~~:1;
                                                          0# -> Data.Type.Equality.$WHRefl;
                                                        };
                                              } in  : [sat_s583b GHC.Types.[]];
                                        };
                              } in  go_up_s5834 0#;
                    } in  (#,#) [Data.Type.Equality.$WHRefl sat_s583c];
              };
        };

Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b)
     -> [a Data.Type.Equality.:~~: b]
[GblId,
 Arity=4,
 Str=<S(S),U(U)><S,1*H><S,1*H><S,1*H>m2,
 Unf=OtherCon []] =
    [] \r [w_s583d w1_s583e w2_s583f w3_s583g]
        case w1_s583e of w4_s583h {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              case w2_s583f of w5_s583i {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                         _ [Occ=Dead, Dmd=<L,A>] ->
                    case w3_s583g of w6_s583j {
                      Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                               _ [Occ=Dead, Dmd=<L,A>] ->
                          case
                              Data.Type.Equality.$w$cenumFromThenTo1
                                  w_s583d w4_s583h w5_s583i w6_s583j
                          of
                          { (#,#) ww1_s583l [Occ=Once] ww2_s583m [Occ=Once] ->
                                : [ww1_s583l ww2_s583m];
                          };
                    };
              };
        };

Data.Type.Equality.$fEnum:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     GHC.Enum.Enum (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Arity=1, Str=<L,U(U)>m] =
    [] \r [$d~~_s583n]
        let {
          sat_s583v [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> [a_a554X Data.Type.Equality.:~~: b_a554Y]
          [LclId] =
              [$d~~_s583n] \r [eta_B3 eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo
                      $d~~_s583n eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s583u [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> [a_a554X Data.Type.Equality.:~~: b_a554Y]
          [LclId] =
              [$d~~_s583n] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$cenumFromTo
                      $d~~_s583n eta_B2 eta_B1; } in
        let {
          sat_s583t [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> [a_a554X Data.Type.Equality.:~~: b_a554Y]
          [LclId] =
              [$d~~_s583n] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$cenumFromThen
                      $d~~_s583n eta_B2 eta_B1; } in
        let {
          sat_s583s [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> [a_a554X Data.Type.Equality.:~~: b_a554Y]
          [LclId] =
              [$d~~_s583n] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$cenumFrom $d~~_s583n eta_B1; } in
        let {
          sat_s583r [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y) -> GHC.Types.Int
          [LclId] =
              [$d~~_s583n] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$cfromEnum $d~~_s583n eta_B1; } in
        let {
          sat_s583q [Occ=Once]
            :: GHC.Types.Int -> a_a554X Data.Type.Equality.:~~: b_a554Y
          [LclId] =
              [$d~~_s583n] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$ctoEnum $d~~_s583n eta_B1; } in
        let {
          sat_s583p [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> a_a554X Data.Type.Equality.:~~: b_a554Y
          [LclId] =
              [$d~~_s583n] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$csucc $d~~_s583n eta_B1; } in
        let {
          sat_s583o [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> a_a554X Data.Type.Equality.:~~: b_a554Y
          [LclId] =
              [$d~~_s583n] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$csucc $d~~_s583n eta_B1;
        } in 
          GHC.Enum.C:Enum [sat_s583o
                           sat_s583p
                           sat_s583q
                           sat_s583r
                           sat_s583s
                           sat_s583t
                           sat_s583u
                           sat_s583v];

Data.Type.Equality.$fTestEqualityk:~:1
  :: forall k (a :: k). GHC.Base.Maybe (a Data.Type.Equality.:~: a)
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [Data.Type.Equality.$WRefl];

Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality
  :: forall k (a1 :: k) (a2 :: k) (b :: k).
     (a1 Data.Type.Equality.:~: a2)
     -> (a1 Data.Type.Equality.:~: b)
     -> GHC.Base.Maybe (a2 Data.Type.Equality.:~: b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_s583w ds1_s583x]
        case ds_s583w of {
          Data.Type.Equality.Refl co_a554K ->
              case ds1_s583x of {
                Data.Type.Equality.Refl co1_a554L ->
                    Data.Type.Equality.$fTestEqualityk:~:1;
              };
        };

Data.Type.Equality.$fTestEqualityk:~: [InlPrag=INLINE (sat-args=0)]
  :: forall k (a :: k).
     Data.Type.Equality.TestEquality ((Data.Type.Equality.:~:) a)
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality eta_B2 eta_B1;

Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality
  :: forall k k1 (a1 :: k1) (a2 :: k) (b :: k).
     (a1 Data.Type.Equality.:~~: a2)
     -> (a1 Data.Type.Equality.:~~: b)
     -> GHC.Base.Maybe (a2 Data.Type.Equality.:~: b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(A,U)><S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_s583A ds1_s583B]
        case ds_s583A of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>] co1_a554q ->
              case ds1_s583B of {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>] co3_a554s ->
                    Data.Type.Equality.$fTestEqualityk:~:1;
              };
        };

Data.Type.Equality.$fTestEqualityk:~~: [InlPrag=INLINE (sat-args=0)]
  :: forall k k1 (a :: k1).
     Data.Type.Equality.TestEquality ((Data.Type.Equality.:~~:) a)
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(A,U)><S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality
            eta_B2 eta_B1;

Data.Type.Equality.$fEq:~:_$c==
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [ds_s583E ds1_s583F]
        case ds_s583E of {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              case ds1_s583F of {
                Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
                    GHC.Types.True [];
              };
        };

Data.Type.Equality.$fEq:~:_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [eta_s583I eta1_s583J]
        case eta_s583I of {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              case eta1_s583J of {
                Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
                    GHC.Types.False [];
              };
        };

Data.Type.Equality.$fEq:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Classes.Eq (a Data.Type.Equality.:~: b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [Data.Type.Equality.$fEq:~:_$c==
                                     Data.Type.Equality.$fEq:~:_$c/=];

Data.Type.Equality.$fRead:~:3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Refl"#;

Data.Type.Equality.$fRead:~:2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Type.Equality.$fRead:~:3;

Data.Type.Equality.$fShow:~:_$cshowsPrec
  :: forall k (a :: k) (b :: k).
     GHC.Types.Int -> (a Data.Type.Equality.:~: b) -> GHC.Show.ShowS
[GblId, Arity=3, Str=<L,A><S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s583M ds1_s583N eta_s583O]
        case ds1_s583N of {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              GHC.Base.++ Data.Type.Equality.$fRead:~:2 eta_s583O;
        };

Data.Type.Equality.$fShow:~:_$cshow
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b) -> GHC.Base.String
[GblId, Arity=1, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [x_s583Q]
        case x_s583Q of {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              Data.Type.Equality.$fRead:~:2;
        };

Data.Type.Equality.$fShow:~:1
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b) -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s583S eta_s583T]
        case ds_s583S of {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              GHC.Base.++ Data.Type.Equality.$fRead:~:2 eta_s583T;
        };

Data.Type.Equality.$fShow:~:_$cshowList
  :: forall k (a :: k) (b :: k).
     [a Data.Type.Equality.:~: b] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s583V s_s583W]
        GHC.Show.showList__ Data.Type.Equality.$fShow:~:1 ls_s583V s_s583W;

Data.Type.Equality.$fShow:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Show.Show (a Data.Type.Equality.:~: b)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Type.Equality.$fShow:~:_$cshowsPrec
                                    Data.Type.Equality.$fShow:~:_$cshow
                                    Data.Type.Equality.$fShow:~:_$cshowList];

Data.Type.Equality.$fOrd:~:_$c<
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s583X b1_s583Y]
        case a1_s583X of {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              case b1_s583Y of {
                Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
                    GHC.Types.False [];
              };
        };

Data.Type.Equality.$fOrd:~:_$ccompare
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s5841 b1_s5842]
        case a1_s5841 of {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              case b1_s5842 of {
                Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] -> GHC.Types.EQ [];
              };
        };

Data.Type.Equality.$fOrd:~:_$c<=
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s5845 b1_s5846]
        case b1_s5846 of {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              case a1_s5845 of {
                Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
                    GHC.Types.True [];
              };
        };

Data.Type.Equality.$fOrd:~:_$cmax
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> a Data.Type.Equality.:~: b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [x_s5849 y_s584a]
        case x_s5849 of {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] -> y_s584a;
        };

Data.Type.Equality.$fOrd:~:_$c>
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s584c b1_s584d]
        case b1_s584d of {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
              case a1_s584c of {
                Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] ->
                    GHC.Types.False [];
              };
        };

Data.Type.Equality.$fOrd:~:_$cmin
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> a Data.Type.Equality.:~: b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [x_s584g y_s584h]
        case y_s584h of {
          Data.Type.Equality.Refl _ [Occ=Dead, Dmd=<L,A>] -> x_s584g;
        };

Data.Type.Equality.$fOrd:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Classes.Ord (a Data.Type.Equality.:~: b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Type.Equality.$fEq:~:
                                      Data.Type.Equality.$fOrd:~:_$ccompare
                                      Data.Type.Equality.$fOrd:~:_$c<
                                      Data.Type.Equality.$fOrd:~:_$c<=
                                      Data.Type.Equality.$fOrd:~:_$c>
                                      Data.Type.Equality.$fEq:~:_$c==
                                      Data.Type.Equality.$fOrd:~:_$cmax
                                      Data.Type.Equality.$fOrd:~:_$cmin];

Data.Type.Equality.$fRead:~:_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Type.Equality.$fRead:~:2];

Data.Type.Equality.$fRead:~:1
  :: forall k (a :: k).
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ((a Data.Type.Equality.:~: a) -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,A><L,1*C1(U)>m2, Unf=OtherCon []] =
    [] \r [n_s584j eta_s584k]
        let {
          sat_s584m [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b_X3nkn
          [LclId] =
              [eta_s584k] \r [a1_s584l] eta_s584k Data.Type.Equality.$WRefl;
        } in 
          case
              Text.Read.Lex.$wexpect
                  Data.Type.Equality.$fRead:~:_lexeme sat_s584m
          of
          { Unit# ww1_s584o [Occ=Once] ->
                Text.ParserCombinators.ReadP.Look [ww1_s584o];
          };

Data.Type.Equality.$fRead:~:4
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        ((a Data.Type.Equality.:~: b) -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId, Arity=3, Str=<S(S),1*U(1*U)><L,U><L,U>, Unf=OtherCon []] =
    [] \r [$d~_s584p eta_s584q eta1_s584r]
        case GHC.Types.heq_sel $d~_s584p of {
          __DEFAULT ->
              GHC.Read.list3 Data.Type.Equality.$fRead:~:1 eta_s584q eta1_s584r;
        };

Data.Type.Equality.$fRead:~:_$creadsPrec
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (a Data.Type.Equality.:~: b)
[GblId, Arity=2, Str=<S(S),U(U)><L,U>, Unf=OtherCon []] =
    [] \r [$d~_s584s eta_s584t]
        case GHC.Types.heq_sel $d~_s584s of {
          __DEFAULT ->
              let {
                sat_s584u [Occ=Once]
                  :: Text.ParserCombinators.ReadP.P
                       (a_X555E Data.Type.Equality.:~: b_X555G)
                [LclId] =
                    [$d~_s584s eta_s584t] \u []
                        case GHC.Types.heq_sel $d~_s584s of {
                          __DEFAULT ->
                              GHC.Read.list3
                                  Data.Type.Equality.$fRead:~:1
                                  eta_s584t
                                  Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                        };
              } in  Text.ParserCombinators.ReadP.run sat_s584u;
        };

Data.Type.Equality.$fRead:~:_$creadListPrec
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [a Data.Type.Equality.:~: b]
[GblId, Arity=1, Str=<S(S),U(U)>, Unf=OtherCon []] =
    [] \r [$d~_s584v]
        case GHC.Types.heq_sel $d~_s584v of {
          __DEFAULT ->
              let {
                sat_s584y [Occ=Once]
                  :: Text.ParserCombinators.ReadPrec.ReadPrec
                       (a_X555F Data.Type.Equality.:~: b_X555H)
                [LclId] =
                    [$d~_s584v] \r [eta_s584w eta1_s584x]
                        case GHC.Types.heq_sel $d~_s584v of {
                          __DEFAULT ->
                              GHC.Read.list3 Data.Type.Equality.$fRead:~:1 eta_s584w eta1_s584x;
                        };
              } in  GHC.Read.list sat_s584y;
        };

Data.Type.Equality.$fRead:~:_$creadList
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     Text.ParserCombinators.ReadP.ReadS [a Data.Type.Equality.:~: b]
[GblId, Arity=1, Str=<S(S),U(U)>, Unf=OtherCon []] =
    [] \r [$d~_s584z]
        case GHC.Types.heq_sel $d~_s584z of {
          __DEFAULT ->
              let {
                sat_s584D [Occ=Once]
                  :: Text.ParserCombinators.ReadP.P
                       [a_X555G Data.Type.Equality.:~: b_X555I]
                [LclId] =
                    [$d~_s584z] \u []
                        case GHC.Types.heq_sel $d~_s584z of {
                          __DEFAULT ->
                              let {
                                sat_s584C [Occ=Once]
                                  :: Text.ParserCombinators.ReadPrec.ReadPrec
                                       (b_X555I Data.Type.Equality.:~: b_X555I)
                                [LclId] =
                                    [] \r [eta_s584A eta1_s584B]
                                        GHC.Read.list3
                                            Data.Type.Equality.$fRead:~:1 eta_s584A eta1_s584B;
                              } in 
                                GHC.Read.list
                                    sat_s584C
                                    GHC.Read.$fRead()7
                                    Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                        };
              } in  Text.ParserCombinators.ReadP.run sat_s584D;
        };

Data.Type.Equality.$fRead:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     GHC.Read.Read (a Data.Type.Equality.:~: b)
[GblId[DFunId], Arity=1, Str=<L,U(U)>m] =
    [] \r [$d~_s584E]
        let {
          sat_s584I [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [a_X555H Data.Type.Equality.:~: b_X555J]
          [LclId] =
              [$d~_s584E] \u []
                  Data.Type.Equality.$fRead:~:_$creadListPrec $d~_s584E; } in
        let {
          sat_s584H [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (a_X555H Data.Type.Equality.:~: b_X555J)
          [LclId] =
              [$d~_s584E] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fRead:~:4 $d~_s584E eta_B2 eta_B1; } in
        let {
          sat_s584G [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [a_X555H Data.Type.Equality.:~: b_X555J]
          [LclId] =
              [$d~_s584E] \u []
                  Data.Type.Equality.$fRead:~:_$creadList $d~_s584E; } in
        let {
          sat_s584F [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (a_X555H Data.Type.Equality.:~: b_X555J)
          [LclId] =
              [$d~_s584E] \r [eta_B1]
                  Data.Type.Equality.$fRead:~:_$creadsPrec $d~_s584E eta_B1;
        } in  GHC.Read.C:Read [sat_s584F sat_s584G sat_s584H sat_s584I];

Data.Type.Equality.$fBounded:~:_$cmaxBound
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     a Data.Type.Equality.:~: b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [$d~_s584J]
        case GHC.Types.heq_sel $d~_s584J of {
          __DEFAULT -> Data.Type.Equality.$WRefl;
        };

Data.Type.Equality.$fBounded:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     GHC.Enum.Bounded (a Data.Type.Equality.:~: b)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(U)>m] =
    [] \r [$d~_s584K]
        let {
          sat_s584M [Occ=Once] :: a_a551J Data.Type.Equality.:~: b_a551K
          [LclId] =
              [$d~_s584K] \u []
                  Data.Type.Equality.$fBounded:~:_$cmaxBound $d~_s584K; } in
        let {
          sat_s584L [Occ=Once] :: a_a551J Data.Type.Equality.:~: b_a551K
          [LclId] =
              [$d~_s584K] \u []
                  Data.Type.Equality.$fBounded:~:_$cmaxBound $d~_s584K;
        } in  GHC.Enum.C:Bounded [sat_s584L sat_s584M];

Data.Type.Equality.$fEq:~~:_$c==
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [ds_s584N ds1_s584O]
        case ds_s584N of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              case ds1_s584O of {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                         _ [Occ=Dead, Dmd=<L,A>] ->
                    GHC.Types.True [];
              };
        };

Data.Type.Equality.$fEq:~~:_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [eta_s584R eta1_s584S]
        case eta_s584R of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              case eta1_s584S of {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                         _ [Occ=Dead, Dmd=<L,A>] ->
                    GHC.Types.False [];
              };
        };

Data.Type.Equality.$fEq:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     GHC.Classes.Eq (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [Data.Type.Equality.$fEq:~~:_$c==
                                     Data.Type.Equality.$fEq:~~:_$c/=];

Data.Type.Equality.$fRead:~~:3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "HRefl"#;

Data.Type.Equality.$fRead:~~:2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Type.Equality.$fRead:~~:3;

Data.Type.Equality.$fShow:~~:_$cshowsPrec
  :: forall k2 k1 (a :: k1) (b :: k2).
     GHC.Types.Int -> (a Data.Type.Equality.:~~: b) -> GHC.Show.ShowS
[GblId, Arity=3, Str=<L,A><S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s584V ds1_s584W eta_s584X]
        case ds1_s584W of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              GHC.Base.++ Data.Type.Equality.$fRead:~~:2 eta_s584X;
        };

Data.Type.Equality.$fShow:~~:_$cshow
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b) -> GHC.Base.String
[GblId, Arity=1, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [x_s584Z]
        case x_s584Z of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              Data.Type.Equality.$fRead:~~:2;
        };

Data.Type.Equality.$fShow:~~:1
  :: forall k2 (b :: k2) k1 (a :: k1).
     (a Data.Type.Equality.:~~: b) -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s5851 eta_s5852]
        case ds_s5851 of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              GHC.Base.++ Data.Type.Equality.$fRead:~~:2 eta_s5852;
        };

Data.Type.Equality.$fShow:~~:_$cshowList
  :: forall k2 k1 (a :: k1) (b :: k2).
     [a Data.Type.Equality.:~~: b] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s5854 s_s5855]
        GHC.Show.showList__
            Data.Type.Equality.$fShow:~~:1 ls_s5854 s_s5855;

Data.Type.Equality.$fShow:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     GHC.Show.Show (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Type.Equality.$fShow:~~:_$cshowsPrec
                                    Data.Type.Equality.$fShow:~~:_$cshow
                                    Data.Type.Equality.$fShow:~~:_$cshowList];

Data.Type.Equality.$fOrd:~~:_$c<
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s5856 b1_s5857]
        case a1_s5856 of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              case b1_s5857 of {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                         _ [Occ=Dead, Dmd=<L,A>] ->
                    GHC.Types.False [];
              };
        };

Data.Type.Equality.$fOrd:~~:_$ccompare
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s585a b1_s585b]
        case a1_s585a of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              case b1_s585b of {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                         _ [Occ=Dead, Dmd=<L,A>] ->
                    GHC.Types.EQ [];
              };
        };

Data.Type.Equality.$fOrd:~~:_$c<=
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s585e b1_s585f]
        case b1_s585f of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              case a1_s585e of {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                         _ [Occ=Dead, Dmd=<L,A>] ->
                    GHC.Types.True [];
              };
        };

Data.Type.Equality.$fOrd:~~:_$cmax
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> a Data.Type.Equality.:~~: b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_s585i y_s585j]
        case x_s585i of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              y_s585j;
        };

Data.Type.Equality.$fOrd:~~:_$c>
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s585l b1_s585m]
        case b1_s585m of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              case a1_s585l of {
                Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                         _ [Occ=Dead, Dmd=<L,A>] ->
                    GHC.Types.False [];
              };
        };

Data.Type.Equality.$fOrd:~~:_$cmin
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> a Data.Type.Equality.:~~: b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [x_s585p y_s585q]
        case y_s585q of {
          Data.Type.Equality.HRefl _ [Occ=Dead, Dmd=<L,A>]
                                   _ [Occ=Dead, Dmd=<L,A>] ->
              x_s585p;
        };

Data.Type.Equality.$fOrd:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     GHC.Classes.Ord (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Type.Equality.$fEq:~~:
                                      Data.Type.Equality.$fOrd:~~:_$ccompare
                                      Data.Type.Equality.$fOrd:~~:_$c<
                                      Data.Type.Equality.$fOrd:~~:_$c<=
                                      Data.Type.Equality.$fOrd:~~:_$c>
                                      Data.Type.Equality.$fEq:~~:_$c==
                                      Data.Type.Equality.$fOrd:~~:_$cmax
                                      Data.Type.Equality.$fOrd:~~:_$cmin];

Data.Type.Equality.$fRead:~~:_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Type.Equality.$fRead:~~:2];

Data.Type.Equality.$fRead:~~:1
  :: forall k1 (a :: k1).
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ((a Data.Type.Equality.:~~: a) -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,A><L,1*C1(U)>m2, Unf=OtherCon []] =
    [] \r [n_s585s eta_s585t]
        let {
          sat_s585v [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b_X3nkW
          [LclId] =
              [eta_s585t] \r [a1_s585u] eta_s585t Data.Type.Equality.$WHRefl;
        } in 
          case
              Text.Read.Lex.$wexpect
                  Data.Type.Equality.$fRead:~~:_lexeme sat_s585v
          of
          { Unit# ww1_s585x [Occ=Once] ->
                Text.ParserCombinators.ReadP.Look [ww1_s585x];
          };

Data.Type.Equality.$fRead:~~:4
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        ((a Data.Type.Equality.:~~: b)
         -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId, Arity=3, Str=<S(S),1*U(1*U)><L,U><L,U>, Unf=OtherCon []] =
    [] \r [$d~~_s585y eta_s585z eta1_s585A]
        case GHC.Types.heq_sel $d~~_s585y of {
          __DEFAULT ->
              GHC.Read.list3 Data.Type.Equality.$fRead:~~:1 eta_s585z eta1_s585A;
        };

Data.Type.Equality.$fRead:~~:_$creadsPrec
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (a Data.Type.Equality.:~~: b)
[GblId, Arity=2, Str=<S(S),U(U)><L,U>, Unf=OtherCon []] =
    [] \r [$d~~_s585B eta_s585C]
        case GHC.Types.heq_sel $d~~_s585B of {
          __DEFAULT ->
              let {
                sat_s585D [Occ=Once]
                  :: Text.ParserCombinators.ReadP.P
                       (a_X553z Data.Type.Equality.:~~: b_X553B)
                [LclId] =
                    [$d~~_s585B eta_s585C] \u []
                        case GHC.Types.heq_sel $d~~_s585B of {
                          __DEFAULT ->
                              GHC.Read.list3
                                  Data.Type.Equality.$fRead:~~:1
                                  eta_s585C
                                  Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                        };
              } in  Text.ParserCombinators.ReadP.run sat_s585D;
        };

Data.Type.Equality.$fRead:~~:_$creadListPrec
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [a Data.Type.Equality.:~~: b]
[GblId, Arity=1, Str=<S(S),U(U)>, Unf=OtherCon []] =
    [] \r [$d~~_s585E]
        case GHC.Types.heq_sel $d~~_s585E of {
          __DEFAULT ->
              let {
                sat_s585H [Occ=Once]
                  :: Text.ParserCombinators.ReadPrec.ReadPrec
                       (a_X553A Data.Type.Equality.:~~: b_X553C)
                [LclId] =
                    [$d~~_s585E] \r [eta_s585F eta1_s585G]
                        case GHC.Types.heq_sel $d~~_s585E of {
                          __DEFAULT ->
                              GHC.Read.list3 Data.Type.Equality.$fRead:~~:1 eta_s585F eta1_s585G;
                        };
              } in  GHC.Read.list sat_s585H;
        };

Data.Type.Equality.$fRead:~~:_$creadList
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     Text.ParserCombinators.ReadP.ReadS [a Data.Type.Equality.:~~: b]
[GblId, Arity=1, Str=<S(S),U(U)>, Unf=OtherCon []] =
    [] \r [$d~~_s585I]
        case GHC.Types.heq_sel $d~~_s585I of {
          __DEFAULT ->
              let {
                sat_s585M [Occ=Once]
                  :: Text.ParserCombinators.ReadP.P
                       [a_X553B Data.Type.Equality.:~~: b_X553D]
                [LclId] =
                    [$d~~_s585I] \u []
                        case GHC.Types.heq_sel $d~~_s585I of {
                          __DEFAULT ->
                              let {
                                sat_s585L [Occ=Once]
                                  :: Text.ParserCombinators.ReadPrec.ReadPrec
                                       (b_X553D Data.Type.Equality.:~~: b_X553D)
                                [LclId] =
                                    [] \r [eta_s585J eta1_s585K]
                                        GHC.Read.list3
                                            Data.Type.Equality.$fRead:~~:1 eta_s585J eta1_s585K;
                              } in 
                                GHC.Read.list
                                    sat_s585L
                                    GHC.Read.$fRead()7
                                    Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                        };
              } in  Text.ParserCombinators.ReadP.run sat_s585M;
        };

Data.Type.Equality.$fRead:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     GHC.Read.Read (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Arity=1, Str=<L,U(U)>m] =
    [] \r [$d~~_s585N]
        let {
          sat_s585R [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [a_X553C Data.Type.Equality.:~~: b_X553E]
          [LclId] =
              [$d~~_s585N] \u []
                  Data.Type.Equality.$fRead:~~:_$creadListPrec $d~~_s585N; } in
        let {
          sat_s585Q [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (a_X553C Data.Type.Equality.:~~: b_X553E)
          [LclId] =
              [$d~~_s585N] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fRead:~~:4 $d~~_s585N eta_B2 eta_B1; } in
        let {
          sat_s585P [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [a_X553C Data.Type.Equality.:~~: b_X553E]
          [LclId] =
              [$d~~_s585N] \u []
                  Data.Type.Equality.$fRead:~~:_$creadList $d~~_s585N; } in
        let {
          sat_s585O [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (a_X553C Data.Type.Equality.:~~: b_X553E)
          [LclId] =
              [$d~~_s585N] \r [eta_B1]
                  Data.Type.Equality.$fRead:~~:_$creadsPrec $d~~_s585N eta_B1;
        } in  GHC.Read.C:Read [sat_s585O sat_s585P sat_s585Q sat_s585R];

Data.Type.Equality.$fBounded:~~:_$cmaxBound
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     a Data.Type.Equality.:~~: b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [$d~~_s585S]
        case GHC.Types.heq_sel $d~~_s585S of {
          __DEFAULT -> Data.Type.Equality.$WHRefl;
        };

Data.Type.Equality.$fBounded:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     GHC.Enum.Bounded (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(U)>m] =
    [] \r [$d~~_s585T]
        let {
          sat_s585V [Occ=Once] :: a_a54YX Data.Type.Equality.:~~: b_a54YY
          [LclId] =
              [$d~~_s585T] \u []
                  Data.Type.Equality.$fBounded:~~:_$cmaxBound $d~~_s585T; } in
        let {
          sat_s585U [Occ=Once] :: a_a54YX Data.Type.Equality.:~~: b_a54YY
          [LclId] =
              [$d~~_s585T] \u []
                  Data.Type.Equality.$fBounded:~~:_$cmaxBound $d~~_s585T;
        } in  GHC.Enum.C:Bounded [sat_s585U sat_s585V];

Data.Type.Equality.sym
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b) -> b Data.Type.Equality.:~: a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U(U)>m, Unf=OtherCon []] =
    [] \r [ds_s585W]
        case ds_s585W of {
          Data.Type.Equality.Refl co_a54YN -> Data.Type.Equality.$WRefl;
        };

Data.Type.Equality.trans
  :: forall k (a :: k) (b :: k) (c :: k).
     (a Data.Type.Equality.:~: b)
     -> (b Data.Type.Equality.:~: c) -> a Data.Type.Equality.:~: c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s585Y ds1_s585Z]
        case ds_s585Y of {
          Data.Type.Equality.Refl co_a54YB ->
              case ds1_s585Z of {
                Data.Type.Equality.Refl co1_a54YC -> Data.Type.Equality.$WRefl;
              };
        };

Data.Type.Equality.castWith
  :: forall a b. (a Data.Type.Equality.:~: b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5862 x_s5863]
        case ds_s5862 of { Data.Type.Equality.Refl co_a54Ys -> x_s5863; };

Data.Type.Equality.gcastWith
  :: forall k (a :: k) (b :: k) r.
     (a Data.Type.Equality.:~: b)
     -> (((a :: k) Data.Type.Equality.~ (b :: k)) => r) -> r
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s5865 x_s5866]
        case ds_s5865 of {
          Data.Type.Equality.Refl co_a54Yl ->
              let {
                sat_s5868 [Occ=Once]
                  :: (a_a54Yh :: k_a54Yg) Data.Type.Equality.~ (b_a54Yi :: k_a54Yg)
                [LclId] =
                    CCCS GHC.Types.Eq#! [GHC.Prim.coercionToken#];
              } in  x_s5866 sat_s5868;
        };

Data.Type.Equality.apply
  :: forall k1 k2 (f :: k1 -> k2) (g :: k1
                                        -> k2) (a :: k1) (b :: k1).
     (f Data.Type.Equality.:~: g)
     -> (a Data.Type.Equality.:~: b) -> f a Data.Type.Equality.:~: g b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s5869 ds1_s586a]
        case ds_s5869 of {
          Data.Type.Equality.Refl co_a54Y7 ->
              case ds1_s586a of {
                Data.Type.Equality.Refl co1_a54Y8 -> Data.Type.Equality.$WRefl;
              };
        };

Data.Type.Equality.inner
  :: forall k1 k2 (f :: k1 -> k2) (a :: k1) (g :: k1
                                                  -> k2) (b :: k1).
     (f a Data.Type.Equality.:~: g b) -> a Data.Type.Equality.:~: b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U(U)>m, Unf=OtherCon []] =
    [] \r [ds_s586d]
        case ds_s586d of {
          Data.Type.Equality.Refl co_a54XU -> Data.Type.Equality.$WRefl;
        };

Data.Type.Equality.outer
  :: forall k1 k2 (f :: k1 -> k2) (a :: k1) (g :: k1
                                                  -> k2) (b :: k1).
     (f a Data.Type.Equality.:~: g b) -> f Data.Type.Equality.:~: g
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U(U)>m, Unf=OtherCon []] =
    [] \r [ds_s586f]
        case ds_s586f of {
          Data.Type.Equality.Refl co_a54XH -> Data.Type.Equality.$WRefl;
        };

Data.Type.Equality.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Type.Equality.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$trModule4];

Data.Type.Equality.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Type.Equality"#;

Data.Type.Equality.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$trModule2];

Data.Type.Equality.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Type.Equality.$trModule3
                                     Data.Type.Equality.$trModule1];

$krep_r568a :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

$krep1_r568b :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep2_r568c :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r568b
                                         GHC.Types.krep$*];

$krep3_r568d :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

Data.Type.Equality.$tc:~~:1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r568d $krep2_r568c];

$krep4_r568e :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r568d
                                         GHC.Types.krep$*];

Data.Type.Equality.$tc:~:1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r568d $krep4_r568e];

Data.Type.Equality.$tcTestEquality1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r568e $krep_r568a];

$krep5_r568f :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r568d $krep_r568a];

Data.Type.Equality.$tc~1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r568d $krep5_r568f];

$krep6_r568g :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep7_r568h :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep6_r568g GHC.Types.[]];

$krep8_r568i :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r568b $krep7_r568h];

$krep9_r568j :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r568d $krep8_r568i];

$krep10_r568k :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r568d $krep9_r568j];

$krep11_r568l :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tc~~
                                              $krep10_r568k];

Data.Type.Equality.$tc~3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "~"#;

Data.Type.Equality.$tc~2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc~3];

Data.Type.Equality.$tc~ :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11470827771536267938##
                                    3625512399163125290##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc~2
                                    1#
                                    Data.Type.Equality.$tc~1];

$krep12_r568m :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Type.Equality.$tc~
                                              $krep9_r568j];

Data.Type.Equality.$tc'C:~1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r568l $krep12_r568m];

Data.Type.Equality.$tc'C:~3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:~"#;

Data.Type.Equality.$tc'C:~2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc'C:~3];

Data.Type.Equality.$tc'C:~ :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6023002849810837484##
                                    5427525916893308990##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc'C:~2
                                    3#
                                    Data.Type.Equality.$tc'C:~1];

Data.Type.Equality.$tc:~:3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ":~:"#;

Data.Type.Equality.$tc:~:2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc:~:3];

Data.Type.Equality.$tc:~: :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10597498348876412676##
                                    16281320961088145472##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc:~:2
                                    1#
                                    Data.Type.Equality.$tc:~:1];

$krep13_r568n :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r568b GHC.Types.[]];

$krep14_r568o :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r568b $krep13_r568n];

$krep15_r568p :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r568d $krep14_r568o];

Data.Type.Equality.$tc'Refl1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Type.Equality.$tc:~:
                                              $krep15_r568p];

Data.Type.Equality.$tc'Refl3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Refl"#;

Data.Type.Equality.$tc'Refl2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc'Refl3];

Data.Type.Equality.$tc'Refl :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16680242040484769242##
                                    2864388906562808793##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc'Refl2
                                    2#
                                    Data.Type.Equality.$tc'Refl1];

Data.Type.Equality.$tc:~~:3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ":~~:"#;

Data.Type.Equality.$tc:~~:2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc:~~:3];

Data.Type.Equality.$tc:~~: :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4361259188665111259##
                                    11706467685470543992##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc:~~:2
                                    2#
                                    Data.Type.Equality.$tc:~~:1];

$krep16_r568q :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r568d $krep15_r568p];

Data.Type.Equality.$tc'HRefl1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Type.Equality.$tc:~~:
                                              $krep16_r568q];

Data.Type.Equality.$tc'HRefl3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'HRefl"#;

Data.Type.Equality.$tc'HRefl2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc'HRefl3];

Data.Type.Equality.$tc'HRefl :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4486133906173668740##
                                    6341741464738386857##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc'HRefl2
                                    2#
                                    Data.Type.Equality.$tc'HRefl1];

Data.Type.Equality.$tcTestEquality3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "TestEquality"#;

Data.Type.Equality.$tcTestEquality2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tcTestEquality3];

Data.Type.Equality.$tcTestEquality :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2944680549948432194##
                                    17791533211054855448##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tcTestEquality2
                                    1#
                                    Data.Type.Equality.$tcTestEquality1];

Data.Type.Equality.HRefl
  :: forall k2 k2 (a :: k2) (b :: k2).
     ((k2 :: *) GHC.Prim.~# (k2 :: *),
      (b :: k2) GHC.Prim.~# (a :: k2)) =>
     a Data.Type.Equality.:~~: b
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Type.Equality.HRefl [GHC.Prim.coercionToken#
                                  GHC.Prim.coercionToken#];

Data.Type.Equality.Refl
  :: forall k (a :: k) (b :: k).
     ((b :: k) GHC.Prim.~# (a :: k)) =>
     a Data.Type.Equality.:~: b
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Type.Equality.Refl [GHC.Prim.coercionToken#];


==================== STG syntax: ====================
2018-03-16 16:00:04.930294547 UTC

Data.Type.Equality.$p1~ [InlPrag=INLINE]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a :: k) GHC.Types.~~ (b :: k)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_s580V] v_s580V;

Data.Type.Equality.testEquality [InlPrag=INLINE]
  :: forall k (f :: k -> *).
     Data.Type.Equality.TestEquality f =>
     forall (a :: k) (b :: k).
     f a -> f b -> GHC.Base.Maybe (a Data.Type.Equality.:~: b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_s580W] v_s580W;

Data.Type.Equality.$WHRefl [InlPrag=INLINE[2]]
  :: forall k2 (a :: k2). a Data.Type.Equality.:~~: a
[GblId[DataConWrapper], Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Type.Equality.HRefl! [];

Data.Type.Equality.$WRefl [InlPrag=INLINE[2]]
  :: forall k (a :: k). a Data.Type.Equality.:~: a
[GblId[DataConWrapper], Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Type.Equality.Refl! [];

Data.Type.Equality.$f~kab_$cp1~
  :: forall k (a :: k) (b :: k).
     ((a :: k) GHC.Types.~~ (b :: k)) =>
     (a :: k) GHC.Types.~~ (b :: k)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S(S),U(U)>, Unf=OtherCon []] =
    [] \r [$d~~_s580X]
        case GHC.Types.heq_sel $d~~_s580X of { (##) -> $d~~_s580X; };

Data.Type.Equality.$f~kab [InlPrag=INLINE (sat-args=0)]
  :: forall k (a :: k) (b :: k).
     ((a :: k) GHC.Types.~~ (b :: k)) =>
     (a :: k) Data.Type.Equality.~ (b :: k)
[GblId[DFunId(nt)],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),U(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Type.Equality.$f~kab_$cp1~ eta_B1;

Data.Type.Equality.$fEnum:~:3 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Type.Equality.$fEnum:~:_$cfromEnum
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b) -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [$d~_s580Y eta_s580Z]
        case GHC.Types.heq_sel $d~_s580Y of {
          (##) ->
              case eta_s580Z of {
                Data.Type.Equality.Refl -> Data.Type.Equality.$fEnum:~:3;
              };
        };

lvl_r5689 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Type.Equality.toEnum: bad argument"#;

Data.Type.Equality.$fEnum:~:1
  :: forall k (a :: k) (b :: k). a Data.Type.Equality.:~: b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_r5689 of sat_s5811 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s5811;
        };

Data.Type.Equality.$fEnum:~:_$ctoEnum
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     GHC.Types.Int -> a Data.Type.Equality.:~: b
[GblId,
 Arity=2,
 Str=<S(S),1*U(1*U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [$d~_s5812 eta_s5813]
        case GHC.Types.heq_sel $d~_s5812 of {
          (##) ->
              case eta_s5813 of {
                GHC.Types.I# ds_s5815 [Occ=Once!] ->
                    case ds_s5815 of {
                      __DEFAULT -> Data.Type.Equality.$fEnum:~:1;
                      0# -> Data.Type.Equality.$WRefl;
                    };
              };
        };

Data.Type.Equality.$fEnum:~:_$csucc
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b) -> a Data.Type.Equality.:~: b
[GblId, Arity=2, Str=<B,U(U)><B,A>x, Unf=OtherCon []] =
    [] \r [$d~_s5817 eta_s5818]
        case GHC.Types.heq_sel $d~_s5817 of {
          (##) ->
              case GHC.Types.heq_sel $d~_s5817 of {
                (##) -> Data.Type.Equality.$fEnum:~:1;
              };
        };

Data.Type.Equality.$w$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=3, Str=<S(S),U(U)><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s5819 w1_s581a w2_s581b]
        case GHC.Types.heq_sel w_s5819 of {
          (##) ->
              case GHC.Types.heq_sel w_s5819 of {
                (##) ->
                    let {
                      go_s581c [Occ=LoopBreaker]
                        :: GHC.Prim.Int# -> [a_s55JT Data.Type.Equality.:~: b_s55JU]
                      [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                          sat-only [go_s581c] \r [x_s581d]
                              let {
                                sat_s581i [Occ=Once] :: [a_s55JT Data.Type.Equality.:~: b_s55JU]
                                [LclId] =
                                    [go_s581c x_s581d] \u []
                                        case x_s581d of wild_s581g {
                                          __DEFAULT ->
                                              case +# [wild_s581g 1#] of sat_s581h {
                                                __DEFAULT -> go_s581c sat_s581h;
                                              };
                                          0# -> [] [];
                                        }; } in
                              let {
                                sat_s581f [Occ=Once] :: a_s55JT Data.Type.Equality.:~: b_s55JU
                                [LclId] =
                                    [x_s581d] \u []
                                        case x_s581d of {
                                          __DEFAULT -> Data.Type.Equality.$fEnum:~:1;
                                          0# -> Data.Type.Equality.$WRefl;
                                        };
                              } in  : [sat_s581f sat_s581i];
                    } in  go_s581c 0#;
              };
        };

Data.Type.Equality.$fEnum:~:_$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=3, Str=<S(S),U(U)><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s581j w1_s581k w2_s581l]
        case w1_s581k of w3_s581m {
          Data.Type.Equality.Refl ->
              case w2_s581l of w4_s581n {
                Data.Type.Equality.Refl ->
                    Data.Type.Equality.$w$cenumFromTo w_s581j w3_s581m w4_s581n;
              };
        };

Data.Type.Equality.$fEnum:~:2 :: [GHC.Types.Int]
[GblId] =
    [] \u [] GHC.Enum.efdInt 0# 0#;

Data.Type.Equality.$w$cenumFromThen [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=3, Str=<S(S),U(U)><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s581o w1_s581p w2_s581q]
        case GHC.Types.heq_sel w_s581o of {
          (##) ->
              case GHC.Types.heq_sel w_s581o of {
                (##) ->
                    let {
                      sat_s581r [Occ=Once]
                        :: GHC.Types.Int -> a_s55K0 Data.Type.Equality.:~: b_s55K1
                      [LclId] =
                          [w_s581o] \r [eta_B1]
                              Data.Type.Equality.$fEnum:~:_$ctoEnum w_s581o eta_B1;
                    } in  GHC.Base.map sat_s581r Data.Type.Equality.$fEnum:~:2;
              };
        };

Data.Type.Equality.$fEnum:~:_$cenumFromThen [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=3, Str=<S(S),U(U)><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s581s w1_s581t w2_s581u]
        case w1_s581t of w3_s581v {
          Data.Type.Equality.Refl ->
              case w2_s581u of w4_s581w {
                Data.Type.Equality.Refl ->
                    Data.Type.Equality.$w$cenumFromThen w_s581s w3_s581v w4_s581w;
              };
        };

Data.Type.Equality.$w$cenumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=2, Str=<S(S),U(U)><L,A>, Unf=OtherCon []] =
    [] \r [w_s581x w1_s581y]
        case GHC.Types.heq_sel w_s581x of {
          (##) ->
              case GHC.Types.heq_sel w_s581x of {
                (##) ->
                    let {
                      go_s581z [Occ=LoopBreaker]
                        :: GHC.Prim.Int# -> [a_s55K8 Data.Type.Equality.:~: b_s55K9]
                      [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                          sat-only [go_s581z] \r [x_s581A]
                              let {
                                sat_s581F [Occ=Once] :: [a_s55K8 Data.Type.Equality.:~: b_s55K9]
                                [LclId] =
                                    [go_s581z x_s581A] \u []
                                        case x_s581A of wild_s581D {
                                          __DEFAULT ->
                                              case +# [wild_s581D 1#] of sat_s581E {
                                                __DEFAULT -> go_s581z sat_s581E;
                                              };
                                          9223372036854775807# -> [] [];
                                        }; } in
                              let {
                                sat_s581C [Occ=Once] :: a_s55K8 Data.Type.Equality.:~: b_s55K9
                                [LclId] =
                                    [x_s581A] \u []
                                        case x_s581A of {
                                          __DEFAULT -> Data.Type.Equality.$fEnum:~:1;
                                          0# -> Data.Type.Equality.$WRefl;
                                        };
                              } in  : [sat_s581C sat_s581F];
                    } in  go_s581z 0#;
              };
        };

Data.Type.Equality.$fEnum:~:_$cenumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b) -> [a Data.Type.Equality.:~: b]
[GblId, Arity=2, Str=<S(S),U(U)><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s581G w1_s581H]
        case w1_s581H of w2_s581I {
          Data.Type.Equality.Refl ->
              Data.Type.Equality.$w$cenumFrom w_s581G w2_s581I;
        };

Data.Type.Equality.$w$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b)
     -> (# a Data.Type.Equality.:~: b, [a Data.Type.Equality.:~: b] #)
[GblId, Arity=4, Str=<S(S),U(U)><L,A><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s581J w1_s581K w2_s581L w3_s581M]
        case GHC.Types.heq_sel w_s581J of {
          (##) ->
              case GHC.Types.heq_sel w_s581J of {
                (##) ->
                    let {
                      sat_s581V [Occ=Once] :: [a_s55Kk Data.Type.Equality.:~: b_s55Kl]
                      [LclId] =
                          [] \u []
                              let {
                                go_up_s581N [Occ=LoopBreaker]
                                  :: GHC.Prim.Int# -> [a_s55Kk Data.Type.Equality.:~: b_s55Kl]
                                [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                    sat-only [go_up_s581N] \r [x_s581O]
                                        case ># [x_s581O 0#] of {
                                          __DEFAULT ->
                                              let {
                                                sat_s581S [Occ=Once]
                                                  :: [a_s55Kk Data.Type.Equality.:~: b_s55Kl]
                                                [LclId] =
                                                    [go_up_s581N x_s581O] \u []
                                                        go_up_s581N x_s581O; } in
                                              let {
                                                sat_s581R [Occ=Once]
                                                  :: a_s55Kk Data.Type.Equality.:~: b_s55Kl
                                                [LclId] =
                                                    [x_s581O] \u []
                                                        case x_s581O of {
                                                          __DEFAULT ->
                                                              Data.Type.Equality.$fEnum:~:1;
                                                          0# -> Data.Type.Equality.$WRefl;
                                                        };
                                              } in  : [sat_s581R sat_s581S];
                                          1# ->
                                              let {
                                                sat_s581U [Occ=Once]
                                                  :: a_s55Kk Data.Type.Equality.:~: b_s55Kl
                                                [LclId] =
                                                    [x_s581O] \u []
                                                        case x_s581O of {
                                                          __DEFAULT ->
                                                              Data.Type.Equality.$fEnum:~:1;
                                                          0# -> Data.Type.Equality.$WRefl;
                                                        };
                                              } in  : [sat_s581U GHC.Types.[]];
                                        };
                              } in  go_up_s581N 0#;
                    } in  (#,#) [Data.Type.Equality.$WRefl sat_s581V];
              };
        };

Data.Type.Equality.$fEnum:~:_$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b)
     -> [a Data.Type.Equality.:~: b]
[GblId,
 Arity=4,
 Str=<S(S),U(U)><S,1*H><S,1*H><S,1*H>m2,
 Unf=OtherCon []] =
    [] \r [w_s581W w1_s581X w2_s581Y w3_s581Z]
        case w1_s581X of w4_s5820 {
          Data.Type.Equality.Refl ->
              case w2_s581Y of w5_s5821 {
                Data.Type.Equality.Refl ->
                    case w3_s581Z of w6_s5822 {
                      Data.Type.Equality.Refl ->
                          case
                              Data.Type.Equality.$w$cenumFromThenTo
                                  w_s581W w4_s5820 w5_s5821 w6_s5822
                          of
                          { (#,#) ww1_s5824 [Occ=Once] ww2_s5825 [Occ=Once] ->
                                : [ww1_s5824 ww2_s5825];
                          };
                    };
              };
        };

Data.Type.Equality.$fEnum:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     GHC.Enum.Enum (a Data.Type.Equality.:~: b)
[GblId[DFunId], Arity=1, Str=<L,U(U)>m] =
    [] \r [$d~_s5826]
        let {
          sat_s582e [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> [a_a5560 Data.Type.Equality.:~: b_a5561]
          [LclId] =
              [$d~_s5826] \r [eta_B3 eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~:_$cenumFromThenTo
                      $d~_s5826 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s582d [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> [a_a5560 Data.Type.Equality.:~: b_a5561]
          [LclId] =
              [$d~_s5826] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~:_$cenumFromTo
                      $d~_s5826 eta_B2 eta_B1; } in
        let {
          sat_s582c [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> [a_a5560 Data.Type.Equality.:~: b_a5561]
          [LclId] =
              [$d~_s5826] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~:_$cenumFromThen
                      $d~_s5826 eta_B2 eta_B1; } in
        let {
          sat_s582b [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> [a_a5560 Data.Type.Equality.:~: b_a5561]
          [LclId] =
              [$d~_s5826] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~:_$cenumFrom $d~_s5826 eta_B1; } in
        let {
          sat_s582a [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561) -> GHC.Types.Int
          [LclId] =
              [$d~_s5826] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~:_$cfromEnum $d~_s5826 eta_B1; } in
        let {
          sat_s5829 [Occ=Once]
            :: GHC.Types.Int -> a_a5560 Data.Type.Equality.:~: b_a5561
          [LclId] =
              [$d~_s5826] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~:_$ctoEnum $d~_s5826 eta_B1; } in
        let {
          sat_s5828 [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> a_a5560 Data.Type.Equality.:~: b_a5561
          [LclId] =
              [$d~_s5826] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~:_$csucc $d~_s5826 eta_B1; } in
        let {
          sat_s5827 [Occ=Once]
            :: (a_a5560 Data.Type.Equality.:~: b_a5561)
               -> a_a5560 Data.Type.Equality.:~: b_a5561
          [LclId] =
              [$d~_s5826] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~:_$csucc $d~_s5826 eta_B1;
        } in 
          GHC.Enum.C:Enum [sat_s5827
                           sat_s5828
                           sat_s5829
                           sat_s582a
                           sat_s582b
                           sat_s582c
                           sat_s582d
                           sat_s582e];

Data.Type.Equality.$fEnum:~~:_$cfromEnum
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b) -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [$d~~_s582f eta_s582g]
        case GHC.Types.heq_sel $d~~_s582f of {
          (##) ->
              case eta_s582g of {
                Data.Type.Equality.HRefl -> Data.Type.Equality.$fEnum:~:3;
              };
        };

Data.Type.Equality.$fEnum:~~:1
  :: forall k1 (a :: k1) k2 (b :: k2). a Data.Type.Equality.:~~: b
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_r5689 of sat_s582i {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s582i;
        };

Data.Type.Equality.$fEnum:~~:_$ctoEnum
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     GHC.Types.Int -> a Data.Type.Equality.:~~: b
[GblId,
 Arity=2,
 Str=<S(S),1*U(1*U)><S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [$d~~_s582j eta_s582k]
        case GHC.Types.heq_sel $d~~_s582j of {
          (##) ->
              case eta_s582k of {
                GHC.Types.I# ds_s582m [Occ=Once!] ->
                    case ds_s582m of {
                      __DEFAULT -> Data.Type.Equality.$fEnum:~~:1;
                      0# -> Data.Type.Equality.$WHRefl;
                    };
              };
        };

Data.Type.Equality.$fEnum:~~:_$csucc
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b) -> a Data.Type.Equality.:~~: b
[GblId, Arity=2, Str=<B,U(U)><B,A>x, Unf=OtherCon []] =
    [] \r [$d~~_s582o eta_s582p]
        case GHC.Types.heq_sel $d~~_s582o of {
          (##) ->
              case GHC.Types.heq_sel $d~~_s582o of {
                (##) -> Data.Type.Equality.$fEnum:~~:1;
              };
        };

Data.Type.Equality.$w$cenumFromTo1 [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=3, Str=<S(S),U(U)><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s582q w1_s582r w2_s582s]
        case GHC.Types.heq_sel w_s582q of {
          (##) ->
              case GHC.Types.heq_sel w_s582q of {
                (##) ->
                    let {
                      go_s582t [Occ=LoopBreaker]
                        :: GHC.Prim.Int# -> [a_s55KD Data.Type.Equality.:~~: b_s55KE]
                      [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                          sat-only [go_s582t] \r [x_s582u]
                              let {
                                sat_s582z [Occ=Once] :: [a_s55KD Data.Type.Equality.:~~: b_s55KE]
                                [LclId] =
                                    [go_s582t x_s582u] \u []
                                        case x_s582u of wild_s582x {
                                          __DEFAULT ->
                                              case +# [wild_s582x 1#] of sat_s582y {
                                                __DEFAULT -> go_s582t sat_s582y;
                                              };
                                          0# -> [] [];
                                        }; } in
                              let {
                                sat_s582w [Occ=Once] :: a_s55KD Data.Type.Equality.:~~: b_s55KE
                                [LclId] =
                                    [x_s582u] \u []
                                        case x_s582u of {
                                          __DEFAULT -> Data.Type.Equality.$fEnum:~~:1;
                                          0# -> Data.Type.Equality.$WHRefl;
                                        };
                              } in  : [sat_s582w sat_s582z];
                    } in  go_s582t 0#;
              };
        };

Data.Type.Equality.$fEnum:~~:_$cenumFromTo [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=3, Str=<S(S),U(U)><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s582A w1_s582B w2_s582C]
        case w1_s582B of w3_s582D {
          Data.Type.Equality.HRefl ->
              case w2_s582C of w4_s582E {
                Data.Type.Equality.HRefl ->
                    Data.Type.Equality.$w$cenumFromTo1 w_s582A w3_s582D w4_s582E;
              };
        };

Data.Type.Equality.$w$cenumFromThen1 [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=3, Str=<S(S),U(U)><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s582F w1_s582G w2_s582H]
        case GHC.Types.heq_sel w_s582F of {
          (##) ->
              case GHC.Types.heq_sel w_s582F of {
                (##) ->
                    let {
                      sat_s582I [Occ=Once]
                        :: GHC.Types.Int -> a_s55KL Data.Type.Equality.:~~: b_s55KM
                      [LclId] =
                          [w_s582F] \r [eta_B1]
                              Data.Type.Equality.$fEnum:~~:_$ctoEnum w_s582F eta_B1;
                    } in  GHC.Base.map sat_s582I Data.Type.Equality.$fEnum:~:2;
              };
        };

Data.Type.Equality.$fEnum:~~:_$cenumFromThen [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=3, Str=<S(S),U(U)><S,1*H><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s582J w1_s582K w2_s582L]
        case w1_s582K of w3_s582M {
          Data.Type.Equality.HRefl ->
              case w2_s582L of w4_s582N {
                Data.Type.Equality.HRefl ->
                    Data.Type.Equality.$w$cenumFromThen1 w_s582J w3_s582M w4_s582N;
              };
        };

Data.Type.Equality.$w$cenumFrom1 [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=2, Str=<S(S),U(U)><L,A>, Unf=OtherCon []] =
    [] \r [w_s582O w1_s582P]
        case GHC.Types.heq_sel w_s582O of {
          (##) ->
              case GHC.Types.heq_sel w_s582O of {
                (##) ->
                    let {
                      go_s582Q [Occ=LoopBreaker]
                        :: GHC.Prim.Int# -> [a_s55KU Data.Type.Equality.:~~: b_s55KV]
                      [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                          sat-only [go_s582Q] \r [x_s582R]
                              let {
                                sat_s582W [Occ=Once] :: [a_s55KU Data.Type.Equality.:~~: b_s55KV]
                                [LclId] =
                                    [go_s582Q x_s582R] \u []
                                        case x_s582R of wild_s582U {
                                          __DEFAULT ->
                                              case +# [wild_s582U 1#] of sat_s582V {
                                                __DEFAULT -> go_s582Q sat_s582V;
                                              };
                                          9223372036854775807# -> [] [];
                                        }; } in
                              let {
                                sat_s582T [Occ=Once] :: a_s55KU Data.Type.Equality.:~~: b_s55KV
                                [LclId] =
                                    [x_s582R] \u []
                                        case x_s582R of {
                                          __DEFAULT -> Data.Type.Equality.$fEnum:~~:1;
                                          0# -> Data.Type.Equality.$WHRefl;
                                        };
                              } in  : [sat_s582T sat_s582W];
                    } in  go_s582Q 0#;
              };
        };

Data.Type.Equality.$fEnum:~~:_$cenumFrom [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b) -> [a Data.Type.Equality.:~~: b]
[GblId, Arity=2, Str=<S(S),U(U)><S,1*H>, Unf=OtherCon []] =
    [] \r [w_s582X w1_s582Y]
        case w1_s582Y of w2_s582Z {
          Data.Type.Equality.HRefl ->
              Data.Type.Equality.$w$cenumFrom1 w_s582X w2_s582Z;
        };

Data.Type.Equality.$w$cenumFromThenTo1 [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b)
     -> (# a Data.Type.Equality.:~~: b, [a Data.Type.Equality.:~~: b] #)
[GblId, Arity=4, Str=<S(S),U(U)><L,A><L,A><L,A>, Unf=OtherCon []] =
    [] \r [w_s5830 w1_s5831 w2_s5832 w3_s5833]
        case GHC.Types.heq_sel w_s5830 of {
          (##) ->
              case GHC.Types.heq_sel w_s5830 of {
                (##) ->
                    let {
                      sat_s583c [Occ=Once] :: [a_s55L8 Data.Type.Equality.:~~: b_s55L9]
                      [LclId] =
                          [] \u []
                              let {
                                go_up_s5834 [Occ=LoopBreaker]
                                  :: GHC.Prim.Int# -> [a_s55L8 Data.Type.Equality.:~~: b_s55L9]
                                [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                                    sat-only [go_up_s5834] \r [x_s5835]
                                        case ># [x_s5835 0#] of {
                                          __DEFAULT ->
                                              let {
                                                sat_s5839 [Occ=Once]
                                                  :: [a_s55L8 Data.Type.Equality.:~~: b_s55L9]
                                                [LclId] =
                                                    [go_up_s5834 x_s5835] \u []
                                                        go_up_s5834 x_s5835; } in
                                              let {
                                                sat_s5838 [Occ=Once]
                                                  :: a_s55L8 Data.Type.Equality.:~~: b_s55L9
                                                [LclId] =
                                                    [x_s5835] \u []
                                                        case x_s5835 of {
                                                          __DEFAULT ->
                                                              Data.Type.Equality.$fEnum:~~:1;
                                                          0# -> Data.Type.Equality.$WHRefl;
                                                        };
                                              } in  : [sat_s5838 sat_s5839];
                                          1# ->
                                              let {
                                                sat_s583b [Occ=Once]
                                                  :: a_s55L8 Data.Type.Equality.:~~: b_s55L9
                                                [LclId] =
                                                    [x_s5835] \u []
                                                        case x_s5835 of {
                                                          __DEFAULT ->
                                                              Data.Type.Equality.$fEnum:~~:1;
                                                          0# -> Data.Type.Equality.$WHRefl;
                                                        };
                                              } in  : [sat_s583b GHC.Types.[]];
                                        };
                              } in  go_up_s5834 0#;
                    } in  (#,#) [Data.Type.Equality.$WHRefl sat_s583c];
              };
        };

Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo [InlPrag=NOUSERINLINE[0]]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b)
     -> [a Data.Type.Equality.:~~: b]
[GblId,
 Arity=4,
 Str=<S(S),U(U)><S,1*H><S,1*H><S,1*H>m2,
 Unf=OtherCon []] =
    [] \r [w_s583d w1_s583e w2_s583f w3_s583g]
        case w1_s583e of w4_s583h {
          Data.Type.Equality.HRefl ->
              case w2_s583f of w5_s583i {
                Data.Type.Equality.HRefl ->
                    case w3_s583g of w6_s583j {
                      Data.Type.Equality.HRefl ->
                          case
                              Data.Type.Equality.$w$cenumFromThenTo1
                                  w_s583d w4_s583h w5_s583i w6_s583j
                          of
                          { (#,#) ww1_s583l [Occ=Once] ww2_s583m [Occ=Once] ->
                                : [ww1_s583l ww2_s583m];
                          };
                    };
              };
        };

Data.Type.Equality.$fEnum:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     GHC.Enum.Enum (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Arity=1, Str=<L,U(U)>m] =
    [] \r [$d~~_s583n]
        let {
          sat_s583v [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> [a_a554X Data.Type.Equality.:~~: b_a554Y]
          [LclId] =
              [$d~~_s583n] \r [eta_B3 eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$cenumFromThenTo
                      $d~~_s583n eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s583u [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> [a_a554X Data.Type.Equality.:~~: b_a554Y]
          [LclId] =
              [$d~~_s583n] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$cenumFromTo
                      $d~~_s583n eta_B2 eta_B1; } in
        let {
          sat_s583t [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> [a_a554X Data.Type.Equality.:~~: b_a554Y]
          [LclId] =
              [$d~~_s583n] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$cenumFromThen
                      $d~~_s583n eta_B2 eta_B1; } in
        let {
          sat_s583s [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> [a_a554X Data.Type.Equality.:~~: b_a554Y]
          [LclId] =
              [$d~~_s583n] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$cenumFrom $d~~_s583n eta_B1; } in
        let {
          sat_s583r [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y) -> GHC.Types.Int
          [LclId] =
              [$d~~_s583n] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$cfromEnum $d~~_s583n eta_B1; } in
        let {
          sat_s583q [Occ=Once]
            :: GHC.Types.Int -> a_a554X Data.Type.Equality.:~~: b_a554Y
          [LclId] =
              [$d~~_s583n] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$ctoEnum $d~~_s583n eta_B1; } in
        let {
          sat_s583p [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> a_a554X Data.Type.Equality.:~~: b_a554Y
          [LclId] =
              [$d~~_s583n] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$csucc $d~~_s583n eta_B1; } in
        let {
          sat_s583o [Occ=Once]
            :: (a_a554X Data.Type.Equality.:~~: b_a554Y)
               -> a_a554X Data.Type.Equality.:~~: b_a554Y
          [LclId] =
              [$d~~_s583n] \r [eta_B1]
                  Data.Type.Equality.$fEnum:~~:_$csucc $d~~_s583n eta_B1;
        } in 
          GHC.Enum.C:Enum [sat_s583o
                           sat_s583p
                           sat_s583q
                           sat_s583r
                           sat_s583s
                           sat_s583t
                           sat_s583u
                           sat_s583v];

Data.Type.Equality.$fTestEqualityk:~:1
  :: forall k (a :: k). GHC.Base.Maybe (a Data.Type.Equality.:~: a)
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [Data.Type.Equality.$WRefl];

Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality
  :: forall k (a1 :: k) (a2 :: k) (b :: k).
     (a1 Data.Type.Equality.:~: a2)
     -> (a1 Data.Type.Equality.:~: b)
     -> GHC.Base.Maybe (a2 Data.Type.Equality.:~: b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_s583w ds1_s583x]
        case ds_s583w of {
          Data.Type.Equality.Refl ->
              case ds1_s583x of {
                Data.Type.Equality.Refl -> Data.Type.Equality.$fTestEqualityk:~:1;
              };
        };

Data.Type.Equality.$fTestEqualityk:~: [InlPrag=INLINE (sat-args=0)]
  :: forall k (a :: k).
     Data.Type.Equality.TestEquality ((Data.Type.Equality.:~:) a)
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Type.Equality.$fTestEqualityk:~:_$ctestEquality eta_B2 eta_B1;

Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality
  :: forall k k1 (a1 :: k1) (a2 :: k) (b :: k).
     (a1 Data.Type.Equality.:~~: a2)
     -> (a1 Data.Type.Equality.:~~: b)
     -> GHC.Base.Maybe (a2 Data.Type.Equality.:~: b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(A,U)><S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_s583A ds1_s583B]
        case ds_s583A of {
          Data.Type.Equality.HRefl ->
              case ds1_s583B of {
                Data.Type.Equality.HRefl -> Data.Type.Equality.$fTestEqualityk:~:1;
              };
        };

Data.Type.Equality.$fTestEqualityk:~~: [InlPrag=INLINE (sat-args=0)]
  :: forall k k1 (a :: k1).
     Data.Type.Equality.TestEquality ((Data.Type.Equality.:~~:) a)
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(A,U)><S,1*U(A,U)>m2,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Type.Equality.$fTestEqualityk:~~:_$ctestEquality
            eta_B2 eta_B1;

Data.Type.Equality.$fEq:~:_$c==
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [ds_s583E ds1_s583F]
        case ds_s583E of {
          Data.Type.Equality.Refl ->
              case ds1_s583F of {
                Data.Type.Equality.Refl -> GHC.Types.True [];
              };
        };

Data.Type.Equality.$fEq:~:_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [eta_s583I eta1_s583J]
        case eta_s583I of {
          Data.Type.Equality.Refl ->
              case eta1_s583J of {
                Data.Type.Equality.Refl -> GHC.Types.False [];
              };
        };

Data.Type.Equality.$fEq:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Classes.Eq (a Data.Type.Equality.:~: b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [Data.Type.Equality.$fEq:~:_$c==
                                     Data.Type.Equality.$fEq:~:_$c/=];

Data.Type.Equality.$fRead:~:3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Refl"#;

Data.Type.Equality.$fRead:~:2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Type.Equality.$fRead:~:3;

Data.Type.Equality.$fShow:~:_$cshowsPrec
  :: forall k (a :: k) (b :: k).
     GHC.Types.Int -> (a Data.Type.Equality.:~: b) -> GHC.Show.ShowS
[GblId, Arity=3, Str=<L,A><S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s583M ds1_s583N eta_s583O]
        case ds1_s583N of {
          Data.Type.Equality.Refl ->
              GHC.Base.++ Data.Type.Equality.$fRead:~:2 eta_s583O;
        };

Data.Type.Equality.$fShow:~:_$cshow
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b) -> GHC.Base.String
[GblId, Arity=1, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [x_s583Q]
        case x_s583Q of {
          Data.Type.Equality.Refl -> Data.Type.Equality.$fRead:~:2;
        };

Data.Type.Equality.$fShow:~:1
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b) -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s583S eta_s583T]
        case ds_s583S of {
          Data.Type.Equality.Refl ->
              GHC.Base.++ Data.Type.Equality.$fRead:~:2 eta_s583T;
        };

Data.Type.Equality.$fShow:~:_$cshowList
  :: forall k (a :: k) (b :: k).
     [a Data.Type.Equality.:~: b] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s583V s_s583W]
        GHC.Show.showList__ Data.Type.Equality.$fShow:~:1 ls_s583V s_s583W;

Data.Type.Equality.$fShow:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Show.Show (a Data.Type.Equality.:~: b)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Type.Equality.$fShow:~:_$cshowsPrec
                                    Data.Type.Equality.$fShow:~:_$cshow
                                    Data.Type.Equality.$fShow:~:_$cshowList];

Data.Type.Equality.$fOrd:~:_$c<
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s583X b1_s583Y]
        case a1_s583X of {
          Data.Type.Equality.Refl ->
              case b1_s583Y of {
                Data.Type.Equality.Refl -> GHC.Types.False [];
              };
        };

Data.Type.Equality.$fOrd:~:_$ccompare
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s5841 b1_s5842]
        case a1_s5841 of {
          Data.Type.Equality.Refl ->
              case b1_s5842 of { Data.Type.Equality.Refl -> GHC.Types.EQ []; };
        };

Data.Type.Equality.$fOrd:~:_$c<=
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s5845 b1_s5846]
        case b1_s5846 of {
          Data.Type.Equality.Refl ->
              case a1_s5845 of { Data.Type.Equality.Refl -> GHC.Types.True []; };
        };

Data.Type.Equality.$fOrd:~:_$cmax
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> a Data.Type.Equality.:~: b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [x_s5849 y_s584a]
        case x_s5849 of { Data.Type.Equality.Refl -> y_s584a; };

Data.Type.Equality.$fOrd:~:_$c>
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s584c b1_s584d]
        case b1_s584d of {
          Data.Type.Equality.Refl ->
              case a1_s584c of {
                Data.Type.Equality.Refl -> GHC.Types.False [];
              };
        };

Data.Type.Equality.$fOrd:~:_$cmin
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b)
     -> (a Data.Type.Equality.:~: b) -> a Data.Type.Equality.:~: b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [x_s584g y_s584h]
        case y_s584h of { Data.Type.Equality.Refl -> x_s584g; };

Data.Type.Equality.$fOrd:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     GHC.Classes.Ord (a Data.Type.Equality.:~: b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Type.Equality.$fEq:~:
                                      Data.Type.Equality.$fOrd:~:_$ccompare
                                      Data.Type.Equality.$fOrd:~:_$c<
                                      Data.Type.Equality.$fOrd:~:_$c<=
                                      Data.Type.Equality.$fOrd:~:_$c>
                                      Data.Type.Equality.$fEq:~:_$c==
                                      Data.Type.Equality.$fOrd:~:_$cmax
                                      Data.Type.Equality.$fOrd:~:_$cmin];

Data.Type.Equality.$fRead:~:_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Type.Equality.$fRead:~:2];

Data.Type.Equality.$fRead:~:1
  :: forall k (a :: k).
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ((a Data.Type.Equality.:~: a) -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,A><L,1*C1(U)>m2, Unf=OtherCon []] =
    [] \r [n_s584j eta_s584k]
        let {
          sat_s584m [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b_X3nkn
          [LclId] =
              [eta_s584k] \r [a1_s584l] eta_s584k Data.Type.Equality.$WRefl;
        } in 
          case
              Text.Read.Lex.$wexpect
                  Data.Type.Equality.$fRead:~:_lexeme sat_s584m
          of
          { Unit# ww1_s584o [Occ=Once] ->
                Text.ParserCombinators.ReadP.Look [ww1_s584o];
          };

Data.Type.Equality.$fRead:~:4
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        ((a Data.Type.Equality.:~: b) -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId, Arity=3, Str=<S(S),1*U(1*U)><L,U><L,U>, Unf=OtherCon []] =
    [] \r [$d~_s584p eta_s584q eta1_s584r]
        case GHC.Types.heq_sel $d~_s584p of {
          (##) ->
              GHC.Read.list3 Data.Type.Equality.$fRead:~:1 eta_s584q eta1_s584r;
        };

Data.Type.Equality.$fRead:~:_$creadsPrec
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (a Data.Type.Equality.:~: b)
[GblId, Arity=2, Str=<S(S),U(U)><L,U>, Unf=OtherCon []] =
    [] \r [$d~_s584s eta_s584t]
        case GHC.Types.heq_sel $d~_s584s of {
          (##) ->
              let {
                sat_s584u [Occ=Once]
                  :: Text.ParserCombinators.ReadP.P
                       (a_X555E Data.Type.Equality.:~: b_X555G)
                [LclId] =
                    [$d~_s584s eta_s584t] \u []
                        case GHC.Types.heq_sel $d~_s584s of {
                          (##) ->
                              GHC.Read.list3
                                  Data.Type.Equality.$fRead:~:1
                                  eta_s584t
                                  Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                        };
              } in  Text.ParserCombinators.ReadP.run sat_s584u;
        };

Data.Type.Equality.$fRead:~:_$creadListPrec
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [a Data.Type.Equality.:~: b]
[GblId, Arity=1, Str=<S(S),U(U)>, Unf=OtherCon []] =
    [] \r [$d~_s584v]
        case GHC.Types.heq_sel $d~_s584v of {
          (##) ->
              let {
                sat_s584y [Occ=Once]
                  :: Text.ParserCombinators.ReadPrec.ReadPrec
                       (a_X555F Data.Type.Equality.:~: b_X555H)
                [LclId] =
                    [$d~_s584v] \r [eta_s584w eta1_s584x]
                        case GHC.Types.heq_sel $d~_s584v of {
                          (##) ->
                              GHC.Read.list3 Data.Type.Equality.$fRead:~:1 eta_s584w eta1_s584x;
                        };
              } in  GHC.Read.list sat_s584y;
        };

Data.Type.Equality.$fRead:~:_$creadList
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     Text.ParserCombinators.ReadP.ReadS [a Data.Type.Equality.:~: b]
[GblId, Arity=1, Str=<S(S),U(U)>, Unf=OtherCon []] =
    [] \r [$d~_s584z]
        case GHC.Types.heq_sel $d~_s584z of {
          (##) ->
              let {
                sat_s584D [Occ=Once]
                  :: Text.ParserCombinators.ReadP.P
                       [a_X555G Data.Type.Equality.:~: b_X555I]
                [LclId] =
                    [$d~_s584z] \u []
                        case GHC.Types.heq_sel $d~_s584z of {
                          (##) ->
                              let {
                                sat_s584C [Occ=Once]
                                  :: Text.ParserCombinators.ReadPrec.ReadPrec
                                       (b_X555I Data.Type.Equality.:~: b_X555I)
                                [LclId] =
                                    [] \r [eta_s584A eta1_s584B]
                                        GHC.Read.list3
                                            Data.Type.Equality.$fRead:~:1 eta_s584A eta1_s584B;
                              } in 
                                GHC.Read.list
                                    sat_s584C
                                    GHC.Read.$fRead()7
                                    Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                        };
              } in  Text.ParserCombinators.ReadP.run sat_s584D;
        };

Data.Type.Equality.$fRead:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     GHC.Read.Read (a Data.Type.Equality.:~: b)
[GblId[DFunId], Arity=1, Str=<L,U(U)>m] =
    [] \r [$d~_s584E]
        let {
          sat_s584I [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [a_X555H Data.Type.Equality.:~: b_X555J]
          [LclId] =
              [$d~_s584E] \u []
                  Data.Type.Equality.$fRead:~:_$creadListPrec $d~_s584E; } in
        let {
          sat_s584H [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (a_X555H Data.Type.Equality.:~: b_X555J)
          [LclId] =
              [$d~_s584E] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fRead:~:4 $d~_s584E eta_B2 eta_B1; } in
        let {
          sat_s584G [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [a_X555H Data.Type.Equality.:~: b_X555J]
          [LclId] =
              [$d~_s584E] \u []
                  Data.Type.Equality.$fRead:~:_$creadList $d~_s584E; } in
        let {
          sat_s584F [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (a_X555H Data.Type.Equality.:~: b_X555J)
          [LclId] =
              [$d~_s584E] \r [eta_B1]
                  Data.Type.Equality.$fRead:~:_$creadsPrec $d~_s584E eta_B1;
        } in  GHC.Read.C:Read [sat_s584F sat_s584G sat_s584H sat_s584I];

Data.Type.Equality.$fBounded:~:_$cmaxBound
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     a Data.Type.Equality.:~: b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [$d~_s584J]
        case GHC.Types.heq_sel $d~_s584J of {
          (##) -> Data.Type.Equality.$WRefl;
        };

Data.Type.Equality.$fBounded:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (a :: k) (b :: k).
     ((a :: k) Data.Type.Equality.~ (b :: k)) =>
     GHC.Enum.Bounded (a Data.Type.Equality.:~: b)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(U)>m] =
    [] \r [$d~_s584K]
        let {
          sat_s584M [Occ=Once] :: a_a551J Data.Type.Equality.:~: b_a551K
          [LclId] =
              [$d~_s584K] \u []
                  Data.Type.Equality.$fBounded:~:_$cmaxBound $d~_s584K; } in
        let {
          sat_s584L [Occ=Once] :: a_a551J Data.Type.Equality.:~: b_a551K
          [LclId] =
              [$d~_s584K] \u []
                  Data.Type.Equality.$fBounded:~:_$cmaxBound $d~_s584K;
        } in  GHC.Enum.C:Bounded [sat_s584L sat_s584M];

Data.Type.Equality.$fEq:~~:_$c==
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [ds_s584N ds1_s584O]
        case ds_s584N of {
          Data.Type.Equality.HRefl ->
              case ds1_s584O of {
                Data.Type.Equality.HRefl -> GHC.Types.True [];
              };
        };

Data.Type.Equality.$fEq:~~:_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [eta_s584R eta1_s584S]
        case eta_s584R of {
          Data.Type.Equality.HRefl ->
              case eta1_s584S of {
                Data.Type.Equality.HRefl -> GHC.Types.False [];
              };
        };

Data.Type.Equality.$fEq:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     GHC.Classes.Eq (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [Data.Type.Equality.$fEq:~~:_$c==
                                     Data.Type.Equality.$fEq:~~:_$c/=];

Data.Type.Equality.$fRead:~~:3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "HRefl"#;

Data.Type.Equality.$fRead:~~:2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Type.Equality.$fRead:~~:3;

Data.Type.Equality.$fShow:~~:_$cshowsPrec
  :: forall k2 k1 (a :: k1) (b :: k2).
     GHC.Types.Int -> (a Data.Type.Equality.:~~: b) -> GHC.Show.ShowS
[GblId, Arity=3, Str=<L,A><S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s584V ds1_s584W eta_s584X]
        case ds1_s584W of {
          Data.Type.Equality.HRefl ->
              GHC.Base.++ Data.Type.Equality.$fRead:~~:2 eta_s584X;
        };

Data.Type.Equality.$fShow:~~:_$cshow
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b) -> GHC.Base.String
[GblId, Arity=1, Str=<S,1*H>, Unf=OtherCon []] =
    [] \r [x_s584Z]
        case x_s584Z of {
          Data.Type.Equality.HRefl -> Data.Type.Equality.$fRead:~~:2;
        };

Data.Type.Equality.$fShow:~~:1
  :: forall k2 (b :: k2) k1 (a :: k1).
     (a Data.Type.Equality.:~~: b) -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*H><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s5851 eta_s5852]
        case ds_s5851 of {
          Data.Type.Equality.HRefl ->
              GHC.Base.++ Data.Type.Equality.$fRead:~~:2 eta_s5852;
        };

Data.Type.Equality.$fShow:~~:_$cshowList
  :: forall k2 k1 (a :: k1) (b :: k2).
     [a Data.Type.Equality.:~~: b] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s5854 s_s5855]
        GHC.Show.showList__
            Data.Type.Equality.$fShow:~~:1 ls_s5854 s_s5855;

Data.Type.Equality.$fShow:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     GHC.Show.Show (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Type.Equality.$fShow:~~:_$cshowsPrec
                                    Data.Type.Equality.$fShow:~~:_$cshow
                                    Data.Type.Equality.$fShow:~~:_$cshowList];

Data.Type.Equality.$fOrd:~~:_$c<
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s5856 b1_s5857]
        case a1_s5856 of {
          Data.Type.Equality.HRefl ->
              case b1_s5857 of {
                Data.Type.Equality.HRefl -> GHC.Types.False [];
              };
        };

Data.Type.Equality.$fOrd:~~:_$ccompare
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s585a b1_s585b]
        case a1_s585a of {
          Data.Type.Equality.HRefl ->
              case b1_s585b of { Data.Type.Equality.HRefl -> GHC.Types.EQ []; };
        };

Data.Type.Equality.$fOrd:~~:_$c<=
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s585e b1_s585f]
        case b1_s585f of {
          Data.Type.Equality.HRefl ->
              case a1_s585e of {
                Data.Type.Equality.HRefl -> GHC.Types.True [];
              };
        };

Data.Type.Equality.$fOrd:~~:_$cmax
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> a Data.Type.Equality.:~~: b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [x_s585i y_s585j]
        case x_s585i of { Data.Type.Equality.HRefl -> y_s585j; };

Data.Type.Equality.$fOrd:~~:_$c>
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*H><S,1*H>,
 Unf=OtherCon []] =
    [] \r [a1_s585l b1_s585m]
        case b1_s585m of {
          Data.Type.Equality.HRefl ->
              case a1_s585l of {
                Data.Type.Equality.HRefl -> GHC.Types.False [];
              };
        };

Data.Type.Equality.$fOrd:~~:_$cmin
  :: forall k2 k1 (a :: k1) (b :: k2).
     (a Data.Type.Equality.:~~: b)
     -> (a Data.Type.Equality.:~~: b) -> a Data.Type.Equality.:~~: b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)><S,1*H>m,
 Unf=OtherCon []] =
    [] \r [x_s585p y_s585q]
        case y_s585q of { Data.Type.Equality.HRefl -> x_s585p; };

Data.Type.Equality.$fOrd:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     GHC.Classes.Ord (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Type.Equality.$fEq:~~:
                                      Data.Type.Equality.$fOrd:~~:_$ccompare
                                      Data.Type.Equality.$fOrd:~~:_$c<
                                      Data.Type.Equality.$fOrd:~~:_$c<=
                                      Data.Type.Equality.$fOrd:~~:_$c>
                                      Data.Type.Equality.$fEq:~~:_$c==
                                      Data.Type.Equality.$fOrd:~~:_$cmax
                                      Data.Type.Equality.$fOrd:~~:_$cmin];

Data.Type.Equality.$fRead:~~:_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Type.Equality.$fRead:~~:2];

Data.Type.Equality.$fRead:~~:1
  :: forall k1 (a :: k1).
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        ((a Data.Type.Equality.:~~: a) -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,A><L,1*C1(U)>m2, Unf=OtherCon []] =
    [] \r [n_s585s eta_s585t]
        let {
          sat_s585v [Occ=Once]
            :: () -> Text.ParserCombinators.ReadP.P b_X3nkW
          [LclId] =
              [eta_s585t] \r [a1_s585u] eta_s585t Data.Type.Equality.$WHRefl;
        } in 
          case
              Text.Read.Lex.$wexpect
                  Data.Type.Equality.$fRead:~~:_lexeme sat_s585v
          of
          { Unit# ww1_s585x [Occ=Once] ->
                Text.ParserCombinators.ReadP.Look [ww1_s585x];
          };

Data.Type.Equality.$fRead:~~:4
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        ((a Data.Type.Equality.:~~: b)
         -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId, Arity=3, Str=<S(S),1*U(1*U)><L,U><L,U>, Unf=OtherCon []] =
    [] \r [$d~~_s585y eta_s585z eta1_s585A]
        case GHC.Types.heq_sel $d~~_s585y of {
          (##) ->
              GHC.Read.list3 Data.Type.Equality.$fRead:~~:1 eta_s585z eta1_s585A;
        };

Data.Type.Equality.$fRead:~~:_$creadsPrec
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (a Data.Type.Equality.:~~: b)
[GblId, Arity=2, Str=<S(S),U(U)><L,U>, Unf=OtherCon []] =
    [] \r [$d~~_s585B eta_s585C]
        case GHC.Types.heq_sel $d~~_s585B of {
          (##) ->
              let {
                sat_s585D [Occ=Once]
                  :: Text.ParserCombinators.ReadP.P
                       (a_X553z Data.Type.Equality.:~~: b_X553B)
                [LclId] =
                    [$d~~_s585B eta_s585C] \u []
                        case GHC.Types.heq_sel $d~~_s585B of {
                          (##) ->
                              GHC.Read.list3
                                  Data.Type.Equality.$fRead:~~:1
                                  eta_s585C
                                  Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                        };
              } in  Text.ParserCombinators.ReadP.run sat_s585D;
        };

Data.Type.Equality.$fRead:~~:_$creadListPrec
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [a Data.Type.Equality.:~~: b]
[GblId, Arity=1, Str=<S(S),U(U)>, Unf=OtherCon []] =
    [] \r [$d~~_s585E]
        case GHC.Types.heq_sel $d~~_s585E of {
          (##) ->
              let {
                sat_s585H [Occ=Once]
                  :: Text.ParserCombinators.ReadPrec.ReadPrec
                       (a_X553A Data.Type.Equality.:~~: b_X553C)
                [LclId] =
                    [$d~~_s585E] \r [eta_s585F eta1_s585G]
                        case GHC.Types.heq_sel $d~~_s585E of {
                          (##) ->
                              GHC.Read.list3 Data.Type.Equality.$fRead:~~:1 eta_s585F eta1_s585G;
                        };
              } in  GHC.Read.list sat_s585H;
        };

Data.Type.Equality.$fRead:~~:_$creadList
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     Text.ParserCombinators.ReadP.ReadS [a Data.Type.Equality.:~~: b]
[GblId, Arity=1, Str=<S(S),U(U)>, Unf=OtherCon []] =
    [] \r [$d~~_s585I]
        case GHC.Types.heq_sel $d~~_s585I of {
          (##) ->
              let {
                sat_s585M [Occ=Once]
                  :: Text.ParserCombinators.ReadP.P
                       [a_X553B Data.Type.Equality.:~~: b_X553D]
                [LclId] =
                    [$d~~_s585I] \u []
                        case GHC.Types.heq_sel $d~~_s585I of {
                          (##) ->
                              let {
                                sat_s585L [Occ=Once]
                                  :: Text.ParserCombinators.ReadPrec.ReadPrec
                                       (b_X553D Data.Type.Equality.:~~: b_X553D)
                                [LclId] =
                                    [] \r [eta_s585J eta1_s585K]
                                        GHC.Read.list3
                                            Data.Type.Equality.$fRead:~~:1 eta_s585J eta1_s585K;
                              } in 
                                GHC.Read.list
                                    sat_s585L
                                    GHC.Read.$fRead()7
                                    Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                        };
              } in  Text.ParserCombinators.ReadP.run sat_s585M;
        };

Data.Type.Equality.$fRead:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     GHC.Read.Read (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Arity=1, Str=<L,U(U)>m] =
    [] \r [$d~~_s585N]
        let {
          sat_s585R [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [a_X553C Data.Type.Equality.:~~: b_X553E]
          [LclId] =
              [$d~~_s585N] \u []
                  Data.Type.Equality.$fRead:~~:_$creadListPrec $d~~_s585N; } in
        let {
          sat_s585Q [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (a_X553C Data.Type.Equality.:~~: b_X553E)
          [LclId] =
              [$d~~_s585N] \r [eta_B2 eta_B1]
                  Data.Type.Equality.$fRead:~~:4 $d~~_s585N eta_B2 eta_B1; } in
        let {
          sat_s585P [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [a_X553C Data.Type.Equality.:~~: b_X553E]
          [LclId] =
              [$d~~_s585N] \u []
                  Data.Type.Equality.$fRead:~~:_$creadList $d~~_s585N; } in
        let {
          sat_s585O [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (a_X553C Data.Type.Equality.:~~: b_X553E)
          [LclId] =
              [$d~~_s585N] \r [eta_B1]
                  Data.Type.Equality.$fRead:~~:_$creadsPrec $d~~_s585N eta_B1;
        } in  GHC.Read.C:Read [sat_s585O sat_s585P sat_s585Q sat_s585R];

Data.Type.Equality.$fBounded:~~:_$cmaxBound
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     a Data.Type.Equality.:~~: b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>m,
 Unf=OtherCon []] =
    [] \r [$d~~_s585S]
        case GHC.Types.heq_sel $d~~_s585S of {
          (##) -> Data.Type.Equality.$WHRefl;
        };

Data.Type.Equality.$fBounded:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k2 k1 (a :: k1) (b :: k2).
     ((a :: k1) GHC.Types.~~ (b :: k2)) =>
     GHC.Enum.Bounded (a Data.Type.Equality.:~~: b)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(U)>m] =
    [] \r [$d~~_s585T]
        let {
          sat_s585V [Occ=Once] :: a_a54YX Data.Type.Equality.:~~: b_a54YY
          [LclId] =
              [$d~~_s585T] \u []
                  Data.Type.Equality.$fBounded:~~:_$cmaxBound $d~~_s585T; } in
        let {
          sat_s585U [Occ=Once] :: a_a54YX Data.Type.Equality.:~~: b_a54YY
          [LclId] =
              [$d~~_s585T] \u []
                  Data.Type.Equality.$fBounded:~~:_$cmaxBound $d~~_s585T;
        } in  GHC.Enum.C:Bounded [sat_s585U sat_s585V];

Data.Type.Equality.sym
  :: forall k (a :: k) (b :: k).
     (a Data.Type.Equality.:~: b) -> b Data.Type.Equality.:~: a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U(U)>m, Unf=OtherCon []] =
    [] \r [ds_s585W]
        case ds_s585W of {
          Data.Type.Equality.Refl -> Data.Type.Equality.$WRefl;
        };

Data.Type.Equality.trans
  :: forall k (a :: k) (b :: k) (c :: k).
     (a Data.Type.Equality.:~: b)
     -> (b Data.Type.Equality.:~: c) -> a Data.Type.Equality.:~: c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s585Y ds1_s585Z]
        case ds_s585Y of {
          Data.Type.Equality.Refl ->
              case ds1_s585Z of {
                Data.Type.Equality.Refl -> Data.Type.Equality.$WRefl;
              };
        };

Data.Type.Equality.castWith
  :: forall a b. (a Data.Type.Equality.:~: b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s5862 x_s5863]
        case ds_s5862 of { Data.Type.Equality.Refl -> x_s5863; };

Data.Type.Equality.gcastWith
  :: forall k (a :: k) (b :: k) r.
     (a Data.Type.Equality.:~: b)
     -> (((a :: k) Data.Type.Equality.~ (b :: k)) => r) -> r
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s5865 x_s5866]
        case ds_s5865 of {
          Data.Type.Equality.Refl ->
              let {
                sat_s5868 [Occ=Once]
                  :: (a_a54Yh :: k_a54Yg) Data.Type.Equality.~ (b_a54Yi :: k_a54Yg)
                [LclId] =
                    CCCS GHC.Types.Eq#! [];
              } in  x_s5866 sat_s5868;
        };

Data.Type.Equality.apply
  :: forall k1 k2 (f :: k1 -> k2) (g :: k1
                                        -> k2) (a :: k1) (b :: k1).
     (f Data.Type.Equality.:~: g)
     -> (a Data.Type.Equality.:~: b) -> f a Data.Type.Equality.:~: g b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U)><S,1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s5869 ds1_s586a]
        case ds_s5869 of {
          Data.Type.Equality.Refl ->
              case ds1_s586a of {
                Data.Type.Equality.Refl -> Data.Type.Equality.$WRefl;
              };
        };

Data.Type.Equality.inner
  :: forall k1 k2 (f :: k1 -> k2) (a :: k1) (g :: k1
                                                  -> k2) (b :: k1).
     (f a Data.Type.Equality.:~: g b) -> a Data.Type.Equality.:~: b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U(U)>m, Unf=OtherCon []] =
    [] \r [ds_s586d]
        case ds_s586d of {
          Data.Type.Equality.Refl -> Data.Type.Equality.$WRefl;
        };

Data.Type.Equality.outer
  :: forall k1 k2 (f :: k1 -> k2) (a :: k1) (g :: k1
                                                  -> k2) (b :: k1).
     (f a Data.Type.Equality.:~: g b) -> f Data.Type.Equality.:~: g
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U(U)>m, Unf=OtherCon []] =
    [] \r [ds_s586f]
        case ds_s586f of {
          Data.Type.Equality.Refl -> Data.Type.Equality.$WRefl;
        };

Data.Type.Equality.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Type.Equality.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$trModule4];

Data.Type.Equality.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Type.Equality"#;

Data.Type.Equality.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$trModule2];

Data.Type.Equality.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Type.Equality.$trModule3
                                     Data.Type.Equality.$trModule1];

$krep_r568a :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

$krep1_r568b :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep2_r568c :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r568b
                                         GHC.Types.krep$*];

$krep3_r568d :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

Data.Type.Equality.$tc:~~:1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r568d $krep2_r568c];

$krep4_r568e :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r568d
                                         GHC.Types.krep$*];

Data.Type.Equality.$tc:~:1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r568d $krep4_r568e];

Data.Type.Equality.$tcTestEquality1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r568e $krep_r568a];

$krep5_r568f :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r568d $krep_r568a];

Data.Type.Equality.$tc~1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r568d $krep5_r568f];

$krep6_r568g :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep7_r568h :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep6_r568g GHC.Types.[]];

$krep8_r568i :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r568b $krep7_r568h];

$krep9_r568j :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r568d $krep8_r568i];

$krep10_r568k :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r568d $krep9_r568j];

$krep11_r568l :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tc~~
                                              $krep10_r568k];

Data.Type.Equality.$tc~3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "~"#;

Data.Type.Equality.$tc~2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc~3];

Data.Type.Equality.$tc~ :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11470827771536267938##
                                    3625512399163125290##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc~2
                                    1#
                                    Data.Type.Equality.$tc~1];

$krep12_r568m :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Type.Equality.$tc~
                                              $krep9_r568j];

Data.Type.Equality.$tc'C:~1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep11_r568l $krep12_r568m];

Data.Type.Equality.$tc'C:~3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:~"#;

Data.Type.Equality.$tc'C:~2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc'C:~3];

Data.Type.Equality.$tc'C:~ :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6023002849810837484##
                                    5427525916893308990##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc'C:~2
                                    3#
                                    Data.Type.Equality.$tc'C:~1];

Data.Type.Equality.$tc:~:3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ":~:"#;

Data.Type.Equality.$tc:~:2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc:~:3];

Data.Type.Equality.$tc:~: :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [10597498348876412676##
                                    16281320961088145472##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc:~:2
                                    1#
                                    Data.Type.Equality.$tc:~:1];

$krep13_r568n :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r568b GHC.Types.[]];

$krep14_r568o :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r568b $krep13_r568n];

$krep15_r568p :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r568d $krep14_r568o];

Data.Type.Equality.$tc'Refl1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Type.Equality.$tc:~:
                                              $krep15_r568p];

Data.Type.Equality.$tc'Refl3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Refl"#;

Data.Type.Equality.$tc'Refl2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc'Refl3];

Data.Type.Equality.$tc'Refl :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16680242040484769242##
                                    2864388906562808793##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc'Refl2
                                    2#
                                    Data.Type.Equality.$tc'Refl1];

Data.Type.Equality.$tc:~~:3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ":~~:"#;

Data.Type.Equality.$tc:~~:2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc:~~:3];

Data.Type.Equality.$tc:~~: :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4361259188665111259##
                                    11706467685470543992##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc:~~:2
                                    2#
                                    Data.Type.Equality.$tc:~~:1];

$krep16_r568q :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep3_r568d $krep15_r568p];

Data.Type.Equality.$tc'HRefl1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Type.Equality.$tc:~~:
                                              $krep16_r568q];

Data.Type.Equality.$tc'HRefl3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'HRefl"#;

Data.Type.Equality.$tc'HRefl2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tc'HRefl3];

Data.Type.Equality.$tc'HRefl :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [4486133906173668740##
                                    6341741464738386857##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tc'HRefl2
                                    2#
                                    Data.Type.Equality.$tc'HRefl1];

Data.Type.Equality.$tcTestEquality3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "TestEquality"#;

Data.Type.Equality.$tcTestEquality2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Type.Equality.$tcTestEquality3];

Data.Type.Equality.$tcTestEquality :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2944680549948432194##
                                    17791533211054855448##
                                    Data.Type.Equality.$trModule
                                    Data.Type.Equality.$tcTestEquality2
                                    1#
                                    Data.Type.Equality.$tcTestEquality1];

Data.Type.Equality.HRefl
  :: forall k2 k2 (a :: k2) (b :: k2).
     ((k2 :: *) GHC.Prim.~# (k2 :: *),
      (b :: k2) GHC.Prim.~# (a :: k2)) =>
     a Data.Type.Equality.:~~: b
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [void_0E void_0E] Data.Type.Equality.HRefl [];

Data.Type.Equality.Refl
  :: forall k (a :: k) (b :: k).
     ((b :: k) GHC.Prim.~# (a :: k)) =>
     a Data.Type.Equality.:~: b
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m,
 Unf=OtherCon []] =
    [] \r [void_0E] Data.Type.Equality.Refl [];

