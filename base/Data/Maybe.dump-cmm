
==================== Output Cmm ====================
2018-03-16 15:55:05.044697647 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:05.04582188 UTC

[section ""data" . Data.Maybe.maybe_closure" {
     Data.Maybe.maybe_closure:
         const Data.Maybe.maybe_info;
 },
 Data.Maybe.maybe_entry() //  [R2, R3, R4]
         { info_tbl: [(crpd,
                       label: Data.Maybe.maybe_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crpd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto crpe; else goto crpf;
       crpe: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Maybe.maybe_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       crpf: // global
           I64[Sp - 24] = block_crp6_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto urpm; else goto crp7;
       urpm: // global
           call _crp6(R1) args: 0, res: 0, upd: 0;
       crp7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crp6() //  [R1]
         { info_tbl: [(crp6,
                       label: block_crp6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crp6: // global
           if (R1 & 7 == 1) goto crpa; else goto crpb;
       crpa: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       crpb: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.047580755 UTC

[section ""data" . Data.Maybe.isJust_closure" {
     Data.Maybe.isJust_closure:
         const Data.Maybe.isJust_info;
 },
 Data.Maybe.isJust_entry() //  [R2]
         { info_tbl: [(crpy,
                       label: Data.Maybe.isJust_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crpy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto crpz; else goto crpA;
       crpz: // global
           R2 = R2;
           R1 = Data.Maybe.isJust_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       crpA: // global
           I64[Sp - 8] = block_crpr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urpH; else goto crps;
       urpH: // global
           call _crpr(R1) args: 0, res: 0, upd: 0;
       crps: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crpr() //  [R1]
         { info_tbl: [(crpr,
                       label: block_crpr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crpr: // global
           if (R1 & 7 == 1) goto crpv; else goto crpw;
       crpv: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       crpw: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.048825547 UTC

[section ""data" . Data.Maybe.isNothing_closure" {
     Data.Maybe.isNothing_closure:
         const Data.Maybe.isNothing_info;
 },
 Data.Maybe.isNothing_entry() //  [R2]
         { info_tbl: [(crpT,
                       label: Data.Maybe.isNothing_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crpT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto crpU; else goto crpV;
       crpU: // global
           R2 = R2;
           R1 = Data.Maybe.isNothing_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       crpV: // global
           I64[Sp - 8] = block_crpM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urq2; else goto crpN;
       urq2: // global
           call _crpM(R1) args: 0, res: 0, upd: 0;
       crpN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crpM() //  [R1]
         { info_tbl: [(crpM,
                       label: block_crpM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crpM: // global
           if (R1 & 7 == 1) goto crpQ; else goto crpR;
       crpQ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       crpR: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.049875997 UTC

[section ""cstring" . lvl_rrod_bytes" {
     lvl_rrod_bytes:
         I8[] [77,97,121,98,101,46,102,114,111,109,74,117,115,116,58,32,78,111,116,104,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.050626521 UTC

[section ""data" . Data.Maybe.fromJust1_closure" {
     Data.Maybe.fromJust1_closure:
         const Data.Maybe.fromJust1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Maybe.fromJust1_entry() //  [R1]
         { info_tbl: [(crqb,
                       label: Data.Maybe.fromJust1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crqb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto crqc; else goto crqd;
       crqc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       crqd: // global
           (_crq6::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_crq6::I64 == 0) goto crq8; else goto crq7;
       crq8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       crq7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _crq6::I64;
           I64[Sp - 24] = block_crq9_info;
           R2 = lvl_rrod_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _crq9() //  [R1]
         { info_tbl: [(crq9,
                       label: block_crq9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crq9: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.051922109 UTC

[section ""data" . Data.Maybe.fromJust_closure" {
     Data.Maybe.fromJust_closure:
         const Data.Maybe.fromJust_info;
         const 0;
 },
 Data.Maybe.fromJust_entry() //  [R2]
         { info_tbl: [(crqt,
                       label: Data.Maybe.fromJust_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crqt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto crqu; else goto crqv;
       crqu: // global
           R2 = R2;
           R1 = Data.Maybe.fromJust_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       crqv: // global
           I64[Sp - 8] = block_crqm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urqC; else goto crqn;
       urqC: // global
           call _crqm(R1) args: 0, res: 0, upd: 0;
       crqn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crqm() //  [R1]
         { info_tbl: [(crqm,
                       label: block_crqm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crqm: // global
           if (R1 & 7 == 1) goto crqq; else goto crqr;
       crqq: // global
           R1 = Data.Maybe.fromJust1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       crqr: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.05331119 UTC

[section ""data" . Data.Maybe.fromMaybe_closure" {
     Data.Maybe.fromMaybe_closure:
         const Data.Maybe.fromMaybe_info;
 },
 Data.Maybe.fromMaybe_entry() //  [R2, R3]
         { info_tbl: [(crqO,
                       label: Data.Maybe.fromMaybe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crqO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto crqP; else goto crqQ;
       crqP: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Maybe.fromMaybe_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       crqQ: // global
           I64[Sp - 16] = block_crqH_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto urqX; else goto crqI;
       urqX: // global
           call _crqH(R1) args: 0, res: 0, upd: 0;
       crqI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crqH() //  [R1]
         { info_tbl: [(crqH,
                       label: block_crqH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crqH: // global
           if (R1 & 7 == 1) goto crqL; else goto crqM;
       crqL: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       crqM: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.055182785 UTC

[section ""data" . Data.Maybe.maybeToList_closure" {
     Data.Maybe.maybeToList_closure:
         const Data.Maybe.maybeToList_info;
 },
 Data.Maybe.maybeToList_entry() //  [R2]
         { info_tbl: [(crr9,
                       label: Data.Maybe.maybeToList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crr9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto crra; else goto crrb;
       crra: // global
           R2 = R2;
           R1 = Data.Maybe.maybeToList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       crrb: // global
           I64[Sp - 8] = block_crr2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urrl; else goto crr3;
       urrl: // global
           call _crr2(R1) args: 0, res: 0, upd: 0;
       crr3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crr2() //  [R1]
         { info_tbl: [(crr2,
                       label: block_crr2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crr2: // global
           if (R1 & 7 == 1) goto crr6; else goto crr7;
       crr6: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       crr7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto crrk; else goto crrj;
       crrk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       crrj: // global
           _sroB::P64 = P64[R1 + 6];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sroB::P64;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.056656345 UTC

[section ""data" . go_rroe_closure" {
     go_rroe_closure:
         const go_rroe_info;
 },
 go_rroe_entry() //  [R2]
         { info_tbl: [(crrx,
                       label: go_rroe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crrx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto crry; else goto crrz;
       crry: // global
           R2 = R2;
           R1 = go_rroe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       crrz: // global
           I64[Sp - 8] = block_crrq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urrJ; else goto crrr;
       urrJ: // global
           call _crrq(R1) args: 0, res: 0, upd: 0;
       crrr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crrq() //  [R1]
         { info_tbl: [(crrq,
                       label: block_crrq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crrq: // global
           if (R1 & 7 == 1) goto crru; else goto crrv;
       crru: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       crrv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto crrI; else goto crrH;
       crrI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       crrH: // global
           _sroE::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sroE::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.058051373 UTC

[section ""data" . Data.Maybe.listToMaybe_closure" {
     Data.Maybe.listToMaybe_closure:
         const Data.Maybe.listToMaybe_info;
 },
 Data.Maybe.listToMaybe_entry() //  [R2]
         { info_tbl: [(crrO,
                       label: Data.Maybe.listToMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crrO: // global
           R2 = R2;
           call go_rroe_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.059401405 UTC

[section ""data" . Data.Maybe.catMaybes1_closure" {
     Data.Maybe.catMaybes1_closure:
         const Data.Maybe.catMaybes1_info;
 },
 sat_sroM_entry() //  [R1]
         { info_tbl: [(crsb,
                       label: sat_sroM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crsb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto crsc; else goto crsd;
       crsc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       crsd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Maybe.catMaybes1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Maybe.catMaybes1_entry() //  [R2]
         { info_tbl: [(crsi,
                       label: Data.Maybe.catMaybes1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crsi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto crsj; else goto ursy;
       crsj: // global
           R2 = R2;
           R1 = Data.Maybe.catMaybes1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ursy: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _crrS() args: 0, res: 0, upd: 0;
     }
 },
 _crrS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crrS: // global
           _sroG::P64 = P64[Sp];
           I64[Sp] = block_crrV_info;
           R1 = _sroG::P64;
           if (R1 & 7 != 0) goto ursA; else goto crrW;
       ursA: // global
           call _crrV(R1) args: 0, res: 0, upd: 0;
       crrW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crrV() //  [R1]
         { info_tbl: [(crrV,
                       label: block_crrV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crrV: // global
           if (R1 & 7 == 1) goto crsf; else goto crsg;
       crsf: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       crsg: // global
           I64[Sp - 8] = block_crs1_info;
           _sroJ::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sroJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ursB; else goto crs2;
       ursB: // global
           call _crs1(R1) args: 0, res: 0, upd: 0;
       crs2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crs1() //  [R1]
         { info_tbl: [(crs1,
                       label: block_crs1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crs1: // global
           _sroJ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto crsr; else goto crst;
       crsr: // global
           P64[Sp + 8] = _sroJ::P64;
           Sp = Sp + 8;
           call _crrS() args: 0, res: 0, upd: 0;
       crst: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto crsw; else goto crsv;
       crsw: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       crsv: // global
           _sroL::P64 = P64[R1 + 6];
           I64[Hp - 40] = sat_sroM_info;
           P64[Hp - 24] = _sroJ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sroL::P64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.061283484 UTC

[section ""data" . Data.Maybe.catMaybes_closure" {
     Data.Maybe.catMaybes_closure:
         const Data.Maybe.catMaybes_info;
 },
 Data.Maybe.catMaybes_entry() //  [R2]
         { info_tbl: [(crsI,
                       label: Data.Maybe.catMaybes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crsI: // global
           R2 = R2;
           call Data.Maybe.catMaybes1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.062287565 UTC

[section ""data" . Data.Maybe.mapMaybeFB_closure" {
     Data.Maybe.mapMaybeFB_closure:
         const Data.Maybe.mapMaybeFB_info;
 },
 Data.Maybe.mapMaybeFB_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(crsV,
                       label: Data.Maybe.mapMaybeFB_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crsV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto crsW; else goto crsX;
       crsW: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Maybe.mapMaybeFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       crsX: // global
           I64[Sp - 24] = block_crsP_info;
           _sroO::P64 = R2;
           R2 = R4;
           R1 = R3;
           P64[Sp - 16] = _sroO::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _crsP() //  [R1]
         { info_tbl: [(crsP,
                       label: block_crsP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crsP: // global
           _sroR::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto crsS; else goto crsT;
       crsS: // global
           R1 = _sroR::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       crsT: // global
           R3 = _sroR::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.064510508 UTC

[section ""data" . Data.Maybe.mapMaybe_closure" {
     Data.Maybe.mapMaybe_closure:
         const Data.Maybe.mapMaybe_info;
 },
 sat_srp1_entry() //  [R1]
         { info_tbl: [(crtn,
                       label: sat_srp1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crtn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto crto; else goto crtp;
       crto: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       crtp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Maybe.mapMaybe_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Maybe.mapMaybe_entry() //  [R2, R3]
         { info_tbl: [(crtu,
                       label: Data.Maybe.mapMaybe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crtu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto crtv; else goto urtK;
       crtv: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Maybe.mapMaybe_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       urtK: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _crt5() args: 0, res: 0, upd: 0;
     }
 },
 _crt5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crt5: // global
           I64[Sp - 8] = block_crt8_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urtM; else goto crt9;
       urtM: // global
           call _crt8(R1) args: 0, res: 0, upd: 0;
       crt9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crt8() //  [R1]
         { info_tbl: [(crt8,
                       label: block_crt8_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crt8: // global
           if (R1 & 7 == 1) goto crtr; else goto crts;
       crtr: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       crts: // global
           I64[Sp] = block_crte_info;
           R2 = P64[R1 + 6];
           _sroY::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 16] = _sroY::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _crte() //  [R1]
         { info_tbl: [(crte,
                       label: block_crte_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crte: // global
           _sroU::P64 = P64[Sp + 8];
           _sroY::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto crtD; else goto crtF;
       crtD: // global
           P64[Sp + 8] = _sroU::P64;
           P64[Sp + 16] = _sroY::P64;
           Sp = Sp + 8;
           call _crt5() args: 0, res: 0, upd: 0;
       crtF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto crtI; else goto crtH;
       crtI: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       crtH: // global
           _srp0::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_srp1_info;
           P64[Hp - 32] = _sroU::P64;
           P64[Hp - 24] = _sroY::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _srp0::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.066368926 UTC

[section ""cstring" . Data.Maybe.$trModule2_bytes" {
     Data.Maybe.$trModule2_bytes:
         I8[] [68,97,116,97,46,77,97,121,98,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.066938114 UTC

[section ""data" . Data.Maybe.$trModule1_closure" {
     Data.Maybe.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Maybe.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.067490951 UTC

[section ""cstring" . Data.Maybe.$trModule4_bytes" {
     Data.Maybe.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.068033387 UTC

[section ""data" . Data.Maybe.$trModule3_closure" {
     Data.Maybe.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Maybe.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.068584585 UTC

[section ""data" . Data.Maybe.$trModule_closure" {
     Data.Maybe.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Maybe.$trModule3_closure+1;
         const Data.Maybe.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.069180254 UTC

[section ""relreadonly" . Srqh_srt" {
     Srqh_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Maybe.fromJust_closure;
         const Data.Maybe.fromJust1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.070397965 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:05.071340627 UTC

[section ""data" . Data.Maybe.maybe_closure" {
     Data.Maybe.maybe_closure:
         const Data.Maybe.maybe_info;
 },
 Data.Maybe.maybe_entry() //  [R2, R3, R4]
         { info_tbl: [(cru0,
                       label: Data.Maybe.maybe_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cru0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cru1; else goto cru2;
       cru1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Maybe.maybe_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cru2: // global
           I64[Sp - 24] = block_crtT_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uru9; else goto crtU;
       uru9: // global
           call _crtT(R1) args: 0, res: 0, upd: 0;
       crtU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crtT() //  [R1]
         { info_tbl: [(crtT,
                       label: block_crtT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crtT: // global
           if (R1 & 7 == 1) goto crtX; else goto crtY;
       crtX: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       crtY: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.072696351 UTC

[section ""data" . Data.Maybe.isJust_closure" {
     Data.Maybe.isJust_closure:
         const Data.Maybe.isJust_info;
 },
 Data.Maybe.isJust_entry() //  [R2]
         { info_tbl: [(crul,
                       label: Data.Maybe.isJust_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crul: // global
           if ((Sp + -8) < SpLim) (likely: False) goto crum; else goto crun;
       crum: // global
           R2 = R2;
           R1 = Data.Maybe.isJust_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       crun: // global
           I64[Sp - 8] = block_crue_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uruu; else goto cruf;
       uruu: // global
           call _crue(R1) args: 0, res: 0, upd: 0;
       cruf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crue() //  [R1]
         { info_tbl: [(crue,
                       label: block_crue_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crue: // global
           if (R1 & 7 == 1) goto crui; else goto cruj;
       crui: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cruj: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.074011774 UTC

[section ""data" . Data.Maybe.isNothing_closure" {
     Data.Maybe.isNothing_closure:
         const Data.Maybe.isNothing_info;
 },
 Data.Maybe.isNothing_entry() //  [R2]
         { info_tbl: [(cruG,
                       label: Data.Maybe.isNothing_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cruG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cruH; else goto cruI;
       cruH: // global
           R2 = R2;
           R1 = Data.Maybe.isNothing_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cruI: // global
           I64[Sp - 8] = block_cruz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uruP; else goto cruA;
       uruP: // global
           call _cruz(R1) args: 0, res: 0, upd: 0;
       cruA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cruz() //  [R1]
         { info_tbl: [(cruz,
                       label: block_cruz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cruz: // global
           if (R1 & 7 == 1) goto cruD; else goto cruE;
       cruD: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cruE: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.07502285 UTC

[section ""cstring" . lvl_rrod_bytes" {
     lvl_rrod_bytes:
         I8[] [77,97,121,98,101,46,102,114,111,109,74,117,115,116,58,32,78,111,116,104,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.075829114 UTC

[section ""data" . Data.Maybe.fromJust1_closure" {
     Data.Maybe.fromJust1_closure:
         const Data.Maybe.fromJust1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Maybe.fromJust1_entry() //  [R1]
         { info_tbl: [(cruY,
                       label: Data.Maybe.fromJust1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cruY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cruZ; else goto crv0;
       cruZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       crv0: // global
           (_cruT::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cruT::I64 == 0) goto cruV; else goto cruU;
       cruV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cruU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cruT::I64;
           I64[Sp - 24] = block_cruW_info;
           R2 = lvl_rrod_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cruW() //  [R1]
         { info_tbl: [(cruW,
                       label: block_cruW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cruW: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.077159238 UTC

[section ""data" . Data.Maybe.fromJust_closure" {
     Data.Maybe.fromJust_closure:
         const Data.Maybe.fromJust_info;
         const 0;
 },
 Data.Maybe.fromJust_entry() //  [R2]
         { info_tbl: [(crvf,
                       label: Data.Maybe.fromJust_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crvf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto crvg; else goto crvh;
       crvg: // global
           R2 = R2;
           R1 = Data.Maybe.fromJust_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       crvh: // global
           I64[Sp - 8] = block_crv8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urvo; else goto crv9;
       urvo: // global
           call _crv8(R1) args: 0, res: 0, upd: 0;
       crv9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crv8() //  [R1]
         { info_tbl: [(crv8,
                       label: block_crv8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crv8: // global
           if (R1 & 7 == 1) goto crvc; else goto crvd;
       crvc: // global
           R1 = Data.Maybe.fromJust1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       crvd: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.07908212 UTC

[section ""data" . Data.Maybe.fromMaybe_closure" {
     Data.Maybe.fromMaybe_closure:
         const Data.Maybe.fromMaybe_info;
 },
 Data.Maybe.fromMaybe_entry() //  [R2, R3]
         { info_tbl: [(crvA,
                       label: Data.Maybe.fromMaybe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crvA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto crvB; else goto crvC;
       crvB: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Maybe.fromMaybe_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       crvC: // global
           I64[Sp - 16] = block_crvt_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto urvJ; else goto crvu;
       urvJ: // global
           call _crvt(R1) args: 0, res: 0, upd: 0;
       crvu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crvt() //  [R1]
         { info_tbl: [(crvt,
                       label: block_crvt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crvt: // global
           if (R1 & 7 == 1) goto crvx; else goto crvy;
       crvx: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       crvy: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.080438885 UTC

[section ""data" . Data.Maybe.maybeToList_closure" {
     Data.Maybe.maybeToList_closure:
         const Data.Maybe.maybeToList_info;
 },
 Data.Maybe.maybeToList_entry() //  [R2]
         { info_tbl: [(crvV,
                       label: Data.Maybe.maybeToList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crvV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto crvW; else goto crvX;
       crvW: // global
           R2 = R2;
           R1 = Data.Maybe.maybeToList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       crvX: // global
           I64[Sp - 8] = block_crvO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urw7; else goto crvP;
       urw7: // global
           call _crvO(R1) args: 0, res: 0, upd: 0;
       crvP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crvO() //  [R1]
         { info_tbl: [(crvO,
                       label: block_crvO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crvO: // global
           if (R1 & 7 == 1) goto crvS; else goto crvT;
       crvS: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       crvT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto crw6; else goto crw5;
       crw6: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       crw5: // global
           _sroB::P64 = P64[R1 + 6];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sroB::P64;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.081889054 UTC

[section ""data" . go_rroe_closure" {
     go_rroe_closure:
         const go_rroe_info;
 },
 go_rroe_entry() //  [R2]
         { info_tbl: [(crwj,
                       label: go_rroe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crwj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto crwk; else goto crwl;
       crwk: // global
           R2 = R2;
           R1 = go_rroe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       crwl: // global
           I64[Sp - 8] = block_crwc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urwv; else goto crwd;
       urwv: // global
           call _crwc(R1) args: 0, res: 0, upd: 0;
       crwd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crwc() //  [R1]
         { info_tbl: [(crwc,
                       label: block_crwc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crwc: // global
           if (R1 & 7 == 1) goto crwg; else goto crwh;
       crwg: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       crwh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto crwu; else goto crwt;
       crwu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       crwt: // global
           _sroE::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sroE::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.083145517 UTC

[section ""data" . Data.Maybe.listToMaybe_closure" {
     Data.Maybe.listToMaybe_closure:
         const Data.Maybe.listToMaybe_info;
 },
 Data.Maybe.listToMaybe_entry() //  [R2]
         { info_tbl: [(crwA,
                       label: Data.Maybe.listToMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crwA: // global
           R2 = R2;
           call go_rroe_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.084428115 UTC

[section ""data" . Data.Maybe.catMaybes1_closure" {
     Data.Maybe.catMaybes1_closure:
         const Data.Maybe.catMaybes1_info;
 },
 sat_sroM_entry() //  [R1]
         { info_tbl: [(crwX,
                       label: sat_sroM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crwX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto crwY; else goto crwZ;
       crwY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       crwZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Maybe.catMaybes1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Maybe.catMaybes1_entry() //  [R2]
         { info_tbl: [(crx4,
                       label: Data.Maybe.catMaybes1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crx4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto crx5; else goto urxk;
       crx5: // global
           R2 = R2;
           R1 = Data.Maybe.catMaybes1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       urxk: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _crwE() args: 0, res: 0, upd: 0;
     }
 },
 _crwE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crwE: // global
           _sroG::P64 = P64[Sp];
           I64[Sp] = block_crwH_info;
           R1 = _sroG::P64;
           if (R1 & 7 != 0) goto urxm; else goto crwI;
       urxm: // global
           call _crwH(R1) args: 0, res: 0, upd: 0;
       crwI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crwH() //  [R1]
         { info_tbl: [(crwH,
                       label: block_crwH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crwH: // global
           if (R1 & 7 == 1) goto crx1; else goto crx2;
       crx1: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       crx2: // global
           I64[Sp - 8] = block_crwN_info;
           _sroJ::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sroJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urxn; else goto crwO;
       urxn: // global
           call _crwN(R1) args: 0, res: 0, upd: 0;
       crwO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crwN() //  [R1]
         { info_tbl: [(crwN,
                       label: block_crwN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crwN: // global
           _sroJ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto crxd; else goto crxf;
       crxd: // global
           P64[Sp + 8] = _sroJ::P64;
           Sp = Sp + 8;
           call _crwE() args: 0, res: 0, upd: 0;
       crxf: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto crxi; else goto crxh;
       crxi: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       crxh: // global
           _sroL::P64 = P64[R1 + 6];
           I64[Hp - 40] = sat_sroM_info;
           P64[Hp - 24] = _sroJ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sroL::P64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.086828096 UTC

[section ""data" . Data.Maybe.catMaybes_closure" {
     Data.Maybe.catMaybes_closure:
         const Data.Maybe.catMaybes_info;
 },
 Data.Maybe.catMaybes_entry() //  [R2]
         { info_tbl: [(crxu,
                       label: Data.Maybe.catMaybes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crxu: // global
           R2 = R2;
           call Data.Maybe.catMaybes1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.08783577 UTC

[section ""data" . Data.Maybe.mapMaybeFB_closure" {
     Data.Maybe.mapMaybeFB_closure:
         const Data.Maybe.mapMaybeFB_info;
 },
 Data.Maybe.mapMaybeFB_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(crxH,
                       label: Data.Maybe.mapMaybeFB_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crxH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto crxI; else goto crxJ;
       crxI: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Maybe.mapMaybeFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       crxJ: // global
           I64[Sp - 24] = block_crxB_info;
           _sroO::P64 = R2;
           R2 = R4;
           R1 = R3;
           P64[Sp - 16] = _sroO::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _crxB() //  [R1]
         { info_tbl: [(crxB,
                       label: block_crxB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crxB: // global
           _sroR::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto crxE; else goto crxF;
       crxE: // global
           R1 = _sroR::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       crxF: // global
           R3 = _sroR::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.089646931 UTC

[section ""data" . Data.Maybe.mapMaybe_closure" {
     Data.Maybe.mapMaybe_closure:
         const Data.Maybe.mapMaybe_info;
 },
 sat_srp1_entry() //  [R1]
         { info_tbl: [(cry9,
                       label: sat_srp1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cry9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto crya; else goto cryb;
       crya: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cryb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Maybe.mapMaybe_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Maybe.mapMaybe_entry() //  [R2, R3]
         { info_tbl: [(cryg,
                       label: Data.Maybe.mapMaybe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cryg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cryh; else goto uryw;
       cryh: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Maybe.mapMaybe_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uryw: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _crxR() args: 0, res: 0, upd: 0;
     }
 },
 _crxR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crxR: // global
           I64[Sp - 8] = block_crxU_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uryy; else goto crxV;
       uryy: // global
           call _crxU(R1) args: 0, res: 0, upd: 0;
       crxV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crxU() //  [R1]
         { info_tbl: [(crxU,
                       label: block_crxU_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crxU: // global
           if (R1 & 7 == 1) goto cryd; else goto crye;
       cryd: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       crye: // global
           I64[Sp] = block_cry0_info;
           R2 = P64[R1 + 6];
           _sroY::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 16] = _sroY::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cry0() //  [R1]
         { info_tbl: [(cry0,
                       label: block_cry0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cry0: // global
           _sroU::P64 = P64[Sp + 8];
           _sroY::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cryp; else goto cryr;
       cryp: // global
           P64[Sp + 8] = _sroU::P64;
           P64[Sp + 16] = _sroY::P64;
           Sp = Sp + 8;
           call _crxR() args: 0, res: 0, upd: 0;
       cryr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cryu; else goto cryt;
       cryu: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cryt: // global
           _srp0::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_srp1_info;
           P64[Hp - 32] = _sroU::P64;
           P64[Hp - 24] = _sroY::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _srp0::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.091493113 UTC

[section ""cstring" . Data.Maybe.$trModule2_bytes" {
     Data.Maybe.$trModule2_bytes:
         I8[] [68,97,116,97,46,77,97,121,98,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.09208107 UTC

[section ""data" . Data.Maybe.$trModule1_closure" {
     Data.Maybe.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Maybe.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.092624306 UTC

[section ""cstring" . Data.Maybe.$trModule4_bytes" {
     Data.Maybe.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.09319842 UTC

[section ""data" . Data.Maybe.$trModule3_closure" {
     Data.Maybe.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Maybe.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.094228978 UTC

[section ""data" . Data.Maybe.$trModule_closure" {
     Data.Maybe.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Maybe.$trModule3_closure+1;
         const Data.Maybe.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.09481659 UTC

[section ""relreadonly" . Srqh_srt" {
     Srqh_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Maybe.fromJust_closure;
         const Data.Maybe.fromJust1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.095549449 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:05.097130501 UTC

[section ""data" . Data.Maybe.maybe_closure" {
     Data.Maybe.maybe_closure:
         const Data.Maybe.maybe_info;
 },
 Data.Maybe.maybe_entry() //  [R2, R3, R4]
         { info_tbl: [(cryM,
                       label: Data.Maybe.maybe_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cryM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cryN; else goto cryO;
       cryN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Maybe.maybe_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cryO: // global
           I64[Sp - 24] = block_cryF_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uryV; else goto cryG;
       uryV: // global
           call _cryF(R1) args: 0, res: 0, upd: 0;
       cryG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cryF() //  [R1]
         { info_tbl: [(cryF,
                       label: block_cryF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cryF: // global
           if (R1 & 7 == 1) goto cryJ; else goto cryK;
       cryJ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cryK: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.103567396 UTC

[section ""data" . Data.Maybe.isJust_closure" {
     Data.Maybe.isJust_closure:
         const Data.Maybe.isJust_info;
 },
 Data.Maybe.isJust_entry() //  [R2]
         { info_tbl: [(crzi,
                       label: Data.Maybe.isJust_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crzi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto crzj; else goto crzk;
       crzj: // global
           R2 = R2;
           R1 = Data.Maybe.isJust_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       crzk: // global
           I64[Sp - 8] = block_crzb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urzr; else goto crzc;
       urzr: // global
           call _crzb(R1) args: 0, res: 0, upd: 0;
       crzc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crzb() //  [R1]
         { info_tbl: [(crzb,
                       label: block_crzb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crzb: // global
           if (R1 & 7 == 1) goto crzf; else goto crzg;
       crzf: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       crzg: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.109580017 UTC

[section ""data" . Data.Maybe.isNothing_closure" {
     Data.Maybe.isNothing_closure:
         const Data.Maybe.isNothing_info;
 },
 Data.Maybe.isNothing_entry() //  [R2]
         { info_tbl: [(crzQ,
                       label: Data.Maybe.isNothing_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crzQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto crzR; else goto crzS;
       crzR: // global
           R2 = R2;
           R1 = Data.Maybe.isNothing_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       crzS: // global
           I64[Sp - 8] = block_crzJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urzZ; else goto crzK;
       urzZ: // global
           call _crzJ(R1) args: 0, res: 0, upd: 0;
       crzK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crzJ() //  [R1]
         { info_tbl: [(crzJ,
                       label: block_crzJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crzJ: // global
           if (R1 & 7 == 1) goto crzN; else goto crzO;
       crzN: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       crzO: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.115091884 UTC

[section ""cstring" . lvl_rrod_bytes" {
     lvl_rrod_bytes:
         I8[] [77,97,121,98,101,46,102,114,111,109,74,117,115,116,58,32,78,111,116,104,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.117430283 UTC

[section ""data" . Data.Maybe.fromJust1_closure" {
     Data.Maybe.fromJust1_closure:
         const Data.Maybe.fromJust1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Maybe.fromJust1_entry() //  [R1]
         { info_tbl: [(crAm,
                       label: Data.Maybe.fromJust1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crAm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto crAn; else goto crAo;
       crAn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       crAo: // global
           (_crAh::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_crAh::I64 == 0) goto crAj; else goto crAi;
       crAj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       crAi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _crAh::I64;
           I64[Sp - 24] = block_crAk_info;
           R2 = lvl_rrod_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _crAk() //  [R1]
         { info_tbl: [(crAk,
                       label: block_crAk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crAk: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.123645938 UTC

[section ""data" . Data.Maybe.fromJust_closure" {
     Data.Maybe.fromJust_closure:
         const Data.Maybe.fromJust_info;
         const 0;
 },
 Data.Maybe.fromJust_entry() //  [R2]
         { info_tbl: [(crAN,
                       label: Data.Maybe.fromJust_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crAN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto crAO; else goto crAP;
       crAO: // global
           R2 = R2;
           R1 = Data.Maybe.fromJust_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       crAP: // global
           I64[Sp - 8] = block_crAG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urAW; else goto crAH;
       urAW: // global
           call _crAG(R1) args: 0, res: 0, upd: 0;
       crAH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crAG() //  [R1]
         { info_tbl: [(crAG,
                       label: block_crAG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crAG: // global
           if (R1 & 7 == 1) goto crAK; else goto crAL;
       crAK: // global
           R1 = Data.Maybe.fromJust1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       crAL: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.129630558 UTC

[section ""data" . Data.Maybe.fromMaybe_closure" {
     Data.Maybe.fromMaybe_closure:
         const Data.Maybe.fromMaybe_info;
 },
 Data.Maybe.fromMaybe_entry() //  [R2, R3]
         { info_tbl: [(crBj,
                       label: Data.Maybe.fromMaybe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crBj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto crBk; else goto crBl;
       crBk: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Maybe.fromMaybe_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       crBl: // global
           I64[Sp - 16] = block_crBc_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto urBs; else goto crBd;
       urBs: // global
           call _crBc(R1) args: 0, res: 0, upd: 0;
       crBd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crBc() //  [R1]
         { info_tbl: [(crBc,
                       label: block_crBc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crBc: // global
           if (R1 & 7 == 1) goto crBg; else goto crBh;
       crBg: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       crBh: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.138276853 UTC

[section ""data" . Data.Maybe.maybeToList_closure" {
     Data.Maybe.maybeToList_closure:
         const Data.Maybe.maybeToList_info;
 },
 Data.Maybe.maybeToList_entry() //  [R2]
         { info_tbl: [(crBP,
                       label: Data.Maybe.maybeToList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crBP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto crBQ; else goto crBR;
       crBQ: // global
           R2 = R2;
           R1 = Data.Maybe.maybeToList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       crBR: // global
           I64[Sp - 8] = block_crBI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urC1; else goto crBJ;
       urC1: // global
           call _crBI(R1) args: 0, res: 0, upd: 0;
       crBJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crBI() //  [R1]
         { info_tbl: [(crBI,
                       label: block_crBI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crBI: // global
           if (R1 & 7 == 1) goto crBM; else goto crBN;
       crBM: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       crBN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto crC0; else goto crBZ;
       crC0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       crBZ: // global
           _sroB::P64 = P64[R1 + 6];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sroB::P64;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.146996672 UTC

[section ""data" . go_rroe_closure" {
     go_rroe_closure:
         const go_rroe_info;
 },
 go_rroe_entry() //  [R2]
         { info_tbl: [(crCq,
                       label: go_rroe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crCq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto crCr; else goto crCs;
       crCr: // global
           R2 = R2;
           R1 = go_rroe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       crCs: // global
           I64[Sp - 8] = block_crCj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urCC; else goto crCk;
       urCC: // global
           call _crCj(R1) args: 0, res: 0, upd: 0;
       crCk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crCj() //  [R1]
         { info_tbl: [(crCj,
                       label: block_crCj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crCj: // global
           if (R1 & 7 == 1) goto crCn; else goto crCo;
       crCn: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       crCo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto crCB; else goto crCA;
       crCB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       crCA: // global
           _sroE::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sroE::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.153287876 UTC

[section ""data" . Data.Maybe.listToMaybe_closure" {
     Data.Maybe.listToMaybe_closure:
         const Data.Maybe.listToMaybe_info;
 },
 Data.Maybe.listToMaybe_entry() //  [R2]
         { info_tbl: [(crCU,
                       label: Data.Maybe.listToMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crCU: // global
           R2 = R2;
           call go_rroe_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.157377347 UTC

[section ""data" . Data.Maybe.catMaybes1_closure" {
     Data.Maybe.catMaybes1_closure:
         const Data.Maybe.catMaybes1_info;
 },
 sat_sroM_entry() //  [R1]
         { info_tbl: [(crDl,
                       label: sat_sroM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crDl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto crDm; else goto crDn;
       crDm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       crDn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Maybe.catMaybes1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Maybe.catMaybes1_entry() //  [R2]
         { info_tbl: [(crDs,
                       label: Data.Maybe.catMaybes1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crDs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto crDt; else goto urDI;
       crDt: // global
           R2 = R2;
           R1 = Data.Maybe.catMaybes1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       urDI: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _crD2() args: 0, res: 0, upd: 0;
     }
 },
 _crD2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crD2: // global
           _sroG::P64 = P64[Sp];
           I64[Sp] = block_crD5_info;
           R1 = _sroG::P64;
           if (R1 & 7 != 0) goto urDK; else goto crD6;
       urDK: // global
           call _crD5(R1) args: 0, res: 0, upd: 0;
       crD6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crD5() //  [R1]
         { info_tbl: [(crD5,
                       label: block_crD5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crD5: // global
           if (R1 & 7 == 1) goto crDp; else goto crDq;
       crDp: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       crDq: // global
           I64[Sp - 8] = block_crDb_info;
           _sroJ::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sroJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urDL; else goto crDc;
       urDL: // global
           call _crDb(R1) args: 0, res: 0, upd: 0;
       crDc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crDb() //  [R1]
         { info_tbl: [(crDb,
                       label: block_crDb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crDb: // global
           _sroJ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto crDB; else goto crDD;
       crDB: // global
           P64[Sp + 8] = _sroJ::P64;
           Sp = Sp + 8;
           call _crD2() args: 0, res: 0, upd: 0;
       crDD: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto crDG; else goto crDF;
       crDG: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       crDF: // global
           _sroL::P64 = P64[R1 + 6];
           I64[Hp - 40] = sat_sroM_info;
           P64[Hp - 24] = _sroJ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sroL::P64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.168066166 UTC

[section ""data" . Data.Maybe.catMaybes_closure" {
     Data.Maybe.catMaybes_closure:
         const Data.Maybe.catMaybes_info;
 },
 Data.Maybe.catMaybes_entry() //  [R2]
         { info_tbl: [(crEi,
                       label: Data.Maybe.catMaybes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crEi: // global
           R2 = R2;
           call Data.Maybe.catMaybes1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.171893613 UTC

[section ""data" . Data.Maybe.mapMaybeFB_closure" {
     Data.Maybe.mapMaybeFB_closure:
         const Data.Maybe.mapMaybeFB_info;
 },
 Data.Maybe.mapMaybeFB_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(crEz,
                       label: Data.Maybe.mapMaybeFB_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crEz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto crEA; else goto crEB;
       crEA: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Maybe.mapMaybeFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       crEB: // global
           I64[Sp - 24] = block_crEt_info;
           _sroO::P64 = R2;
           R2 = R4;
           R1 = R3;
           P64[Sp - 16] = _sroO::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _crEt() //  [R1]
         { info_tbl: [(crEt,
                       label: block_crEt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crEt: // global
           _sroR::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto crEw; else goto crEx;
       crEw: // global
           R1 = _sroR::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       crEx: // global
           R3 = _sroR::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.178422715 UTC

[section ""data" . Data.Maybe.mapMaybe_closure" {
     Data.Maybe.mapMaybe_closure:
         const Data.Maybe.mapMaybe_info;
 },
 sat_srp1_entry() //  [R1]
         { info_tbl: [(crFb,
                       label: sat_srp1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crFb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto crFc; else goto crFd;
       crFc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       crFd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Maybe.mapMaybe_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Maybe.mapMaybe_entry() //  [R2, R3]
         { info_tbl: [(crFi,
                       label: Data.Maybe.mapMaybe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crFi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto crFj; else goto urFy;
       crFj: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Maybe.mapMaybe_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       urFy: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _crET() args: 0, res: 0, upd: 0;
     }
 },
 _crET() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crET: // global
           I64[Sp - 8] = block_crEW_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urFA; else goto crEX;
       urFA: // global
           call _crEW(R1) args: 0, res: 0, upd: 0;
       crEX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crEW() //  [R1]
         { info_tbl: [(crEW,
                       label: block_crEW_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crEW: // global
           if (R1 & 7 == 1) goto crFf; else goto crFg;
       crFf: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       crFg: // global
           I64[Sp] = block_crF2_info;
           R2 = P64[R1 + 6];
           _sroY::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 16] = _sroY::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _crF2() //  [R1]
         { info_tbl: [(crF2,
                       label: block_crF2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crF2: // global
           _sroU::P64 = P64[Sp + 8];
           _sroY::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto crFr; else goto crFt;
       crFr: // global
           P64[Sp + 8] = _sroU::P64;
           P64[Sp + 16] = _sroY::P64;
           Sp = Sp + 8;
           call _crET() args: 0, res: 0, upd: 0;
       crFt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto crFw; else goto crFv;
       crFw: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       crFv: // global
           _srp0::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_srp1_info;
           P64[Hp - 32] = _sroU::P64;
           P64[Hp - 24] = _sroY::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _srp0::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.189364228 UTC

[section ""cstring" . Data.Maybe.$trModule2_bytes" {
     Data.Maybe.$trModule2_bytes:
         I8[] [68,97,116,97,46,77,97,121,98,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.191163952 UTC

[section ""data" . Data.Maybe.$trModule1_closure" {
     Data.Maybe.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Maybe.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.193103176 UTC

[section ""cstring" . Data.Maybe.$trModule4_bytes" {
     Data.Maybe.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.194647536 UTC

[section ""data" . Data.Maybe.$trModule3_closure" {
     Data.Maybe.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Maybe.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.19627839 UTC

[section ""data" . Data.Maybe.$trModule_closure" {
     Data.Maybe.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Maybe.$trModule3_closure+1;
         const Data.Maybe.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.198263983 UTC

[section ""relreadonly" . Srqh_srt" {
     Srqh_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Maybe.fromJust_closure;
         const Data.Maybe.fromJust1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.412265984 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:05.414383085 UTC

[section ""data" . Data.Maybe.maybe_closure" {
     Data.Maybe.maybe_closure:
         const Data.Maybe.maybe_info;
 },
 Data.Maybe.maybe_entry() //  [R2, R3, R4]
         { info_tbl: [(crH5,
                       label: Data.Maybe.maybe_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crH5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto crH6; else goto crH7;
       crH6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Maybe.maybe_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       crH7: // global
           I64[Sp - 24] = block_crGY_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto urHe; else goto crGZ;
       urHe: // global
           call _crGY(R1) args: 0, res: 0, upd: 0;
       crGZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crGY() //  [R1]
         { info_tbl: [(crGY,
                       label: block_crGY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crGY: // global
           if (R1 & 7 == 1) goto crH2; else goto crH3;
       crH2: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       crH3: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.425871886 UTC

[section ""data" . Data.Maybe.isJust_closure" {
     Data.Maybe.isJust_closure:
         const Data.Maybe.isJust_info;
 },
 Data.Maybe.isJust_entry() //  [R2]
         { info_tbl: [(crHC,
                       label: Data.Maybe.isJust_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crHC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto crHD; else goto crHE;
       crHD: // global
           R2 = R2;
           R1 = Data.Maybe.isJust_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       crHE: // global
           I64[Sp - 8] = block_crHv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urHL; else goto crHw;
       urHL: // global
           call _crHv(R1) args: 0, res: 0, upd: 0;
       crHw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crHv() //  [R1]
         { info_tbl: [(crHv,
                       label: block_crHv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crHv: // global
           if (R1 & 7 == 1) goto crHz; else goto crHA;
       crHz: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       crHA: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.434592147 UTC

[section ""data" . Data.Maybe.isNothing_closure" {
     Data.Maybe.isNothing_closure:
         const Data.Maybe.isNothing_info;
 },
 Data.Maybe.isNothing_entry() //  [R2]
         { info_tbl: [(crId,
                       label: Data.Maybe.isNothing_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crId: // global
           if ((Sp + -8) < SpLim) (likely: False) goto crIe; else goto crIf;
       crIe: // global
           R2 = R2;
           R1 = Data.Maybe.isNothing_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       crIf: // global
           I64[Sp - 8] = block_crI6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urIm; else goto crI7;
       urIm: // global
           call _crI6(R1) args: 0, res: 0, upd: 0;
       crI7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crI6() //  [R1]
         { info_tbl: [(crI6,
                       label: block_crI6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crI6: // global
           if (R1 & 7 == 1) goto crIa; else goto crIb;
       crIa: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       crIb: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.442620203 UTC

[section ""cstring" . lvl_rrod_bytes" {
     lvl_rrod_bytes:
         I8[] [77,97,121,98,101,46,102,114,111,109,74,117,115,116,58,32,78,111,116,104,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.445647914 UTC

[section ""data" . Data.Maybe.fromJust1_closure" {
     Data.Maybe.fromJust1_closure:
         const Data.Maybe.fromJust1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Maybe.fromJust1_entry() //  [R1]
         { info_tbl: [(crIM,
                       label: Data.Maybe.fromJust1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crIM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto crIN; else goto crIO;
       crIN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       crIO: // global
           (_crIH::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_crIH::I64 == 0) goto crIJ; else goto crII;
       crIJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       crII: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _crIH::I64;
           I64[Sp - 24] = block_crIK_info;
           R2 = lvl_rrod_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _crIK() //  [R1]
         { info_tbl: [(crIK,
                       label: block_crIK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crIK: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.452688507 UTC

[section ""data" . Data.Maybe.fromJust_closure" {
     Data.Maybe.fromJust_closure:
         const Data.Maybe.fromJust_info;
         const 0;
 },
 Data.Maybe.fromJust_entry() //  [R2]
         { info_tbl: [(crJg,
                       label: Data.Maybe.fromJust_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crJg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto crJh; else goto crJi;
       crJh: // global
           R2 = R2;
           R1 = Data.Maybe.fromJust_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       crJi: // global
           I64[Sp - 8] = block_crJ9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urJp; else goto crJa;
       urJp: // global
           call _crJ9(R1) args: 0, res: 0, upd: 0;
       crJa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crJ9() //  [R1]
         { info_tbl: [(crJ9,
                       label: block_crJ9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crJ9: // global
           if (R1 & 7 == 1) goto crJd; else goto crJe;
       crJd: // global
           R1 = Data.Maybe.fromJust1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       crJe: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.458920393 UTC

[section ""data" . Data.Maybe.fromMaybe_closure" {
     Data.Maybe.fromMaybe_closure:
         const Data.Maybe.fromMaybe_info;
 },
 Data.Maybe.fromMaybe_entry() //  [R2, R3]
         { info_tbl: [(crJN,
                       label: Data.Maybe.fromMaybe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crJN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto crJO; else goto crJP;
       crJO: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Maybe.fromMaybe_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       crJP: // global
           I64[Sp - 16] = block_crJG_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto urJW; else goto crJH;
       urJW: // global
           call _crJG(R1) args: 0, res: 0, upd: 0;
       crJH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crJG() //  [R1]
         { info_tbl: [(crJG,
                       label: block_crJG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crJG: // global
           if (R1 & 7 == 1) goto crJK; else goto crJL;
       crJK: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       crJL: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.464607065 UTC

[section ""data" . Data.Maybe.maybeToList_closure" {
     Data.Maybe.maybeToList_closure:
         const Data.Maybe.maybeToList_info;
 },
 Data.Maybe.maybeToList_entry() //  [R2]
         { info_tbl: [(crKk,
                       label: Data.Maybe.maybeToList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crKk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto crKl; else goto crKm;
       crKl: // global
           R2 = R2;
           R1 = Data.Maybe.maybeToList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       crKm: // global
           I64[Sp - 8] = block_crKd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urKw; else goto crKe;
       urKw: // global
           call _crKd(R1) args: 0, res: 0, upd: 0;
       crKe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crKd() //  [R1]
         { info_tbl: [(crKd,
                       label: block_crKd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crKd: // global
           if (R1 & 7 == 1) goto crKh; else goto crKi;
       crKh: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       crKi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto crKv; else goto crKu;
       crKv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       crKu: // global
           _srGt::P64 = P64[R1 + 6];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _srGt::P64;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.471327612 UTC

[section ""data" . go_rroe_closure" {
     go_rroe_closure:
         const go_rroe_info;
 },
 go_rroe_entry() //  [R2]
         { info_tbl: [(crL0,
                       label: go_rroe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crL0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto crL1; else goto crL2;
       crL1: // global
           R2 = R2;
           R1 = go_rroe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       crL2: // global
           I64[Sp - 8] = block_crKT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urLc; else goto crKU;
       urLc: // global
           call _crKT(R1) args: 0, res: 0, upd: 0;
       crKU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crKT() //  [R1]
         { info_tbl: [(crKT,
                       label: block_crKT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crKT: // global
           if (R1 & 7 == 1) goto crKX; else goto crKY;
       crKX: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       crKY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto crLb; else goto crLa;
       crLb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       crLa: // global
           _srGw::P64 = P64[R1 + 6];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _srGw::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.477201018 UTC

[section ""data" . Data.Maybe.listToMaybe_closure" {
     Data.Maybe.listToMaybe_closure:
         const Data.Maybe.listToMaybe_info;
 },
 Data.Maybe.listToMaybe_entry() //  [R2]
         { info_tbl: [(crLx,
                       label: Data.Maybe.listToMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crLx: // global
           R2 = R2;
           call go_rroe_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.480962197 UTC

[section ""data" . Data.Maybe.catMaybes1_closure" {
     Data.Maybe.catMaybes1_closure:
         const Data.Maybe.catMaybes1_info;
 },
 sat_srGE_entry() //  [R1]
         { info_tbl: [(crLY,
                       label: sat_srGE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crLY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto crLZ; else goto crM0;
       crLZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       crM0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Maybe.catMaybes1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Maybe.catMaybes1_entry() //  [R2]
         { info_tbl: [(crM5,
                       label: Data.Maybe.catMaybes1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crM5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto crM6; else goto urMl;
       crM6: // global
           R2 = R2;
           R1 = Data.Maybe.catMaybes1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       urMl: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _crLF() args: 0, res: 0, upd: 0;
     }
 },
 _crLF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crLF: // global
           _srGy::P64 = P64[Sp];
           I64[Sp] = block_crLI_info;
           R1 = _srGy::P64;
           if (R1 & 7 != 0) goto urMn; else goto crLJ;
       urMn: // global
           call _crLI(R1) args: 0, res: 0, upd: 0;
       crLJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crLI() //  [R1]
         { info_tbl: [(crLI,
                       label: block_crLI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crLI: // global
           if (R1 & 7 == 1) goto crM2; else goto crM3;
       crM2: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       crM3: // global
           I64[Sp - 8] = block_crLO_info;
           _srGB::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _srGB::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urMo; else goto crLP;
       urMo: // global
           call _crLO(R1) args: 0, res: 0, upd: 0;
       crLP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crLO() //  [R1]
         { info_tbl: [(crLO,
                       label: block_crLO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crLO: // global
           _srGB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto crMe; else goto crMg;
       crMe: // global
           P64[Sp + 8] = _srGB::P64;
           Sp = Sp + 8;
           call _crLF() args: 0, res: 0, upd: 0;
       crMg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto crMj; else goto crMi;
       crMj: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       crMi: // global
           _srGD::P64 = P64[R1 + 6];
           I64[Hp - 40] = sat_srGE_info;
           P64[Hp - 24] = _srGB::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _srGD::P64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.49216224 UTC

[section ""data" . Data.Maybe.catMaybes_closure" {
     Data.Maybe.catMaybes_closure:
         const Data.Maybe.catMaybes_info;
 },
 Data.Maybe.catMaybes_entry() //  [R2]
         { info_tbl: [(crN1,
                       label: Data.Maybe.catMaybes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crN1: // global
           R2 = R2;
           call Data.Maybe.catMaybes1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.495885411 UTC

[section ""data" . Data.Maybe.mapMaybeFB_closure" {
     Data.Maybe.mapMaybeFB_closure:
         const Data.Maybe.mapMaybeFB_info;
 },
 Data.Maybe.mapMaybeFB_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(crNi,
                       label: Data.Maybe.mapMaybeFB_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crNi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto crNj; else goto crNk;
       crNj: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Maybe.mapMaybeFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       crNk: // global
           I64[Sp - 24] = block_crNc_info;
           _srGG::P64 = R2;
           R2 = R4;
           R1 = R3;
           P64[Sp - 16] = _srGG::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _crNc() //  [R1]
         { info_tbl: [(crNc,
                       label: block_crNc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crNc: // global
           _srGJ::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto crNf; else goto crNg;
       crNf: // global
           R1 = _srGJ::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       crNg: // global
           R3 = _srGJ::P64;
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.502421288 UTC

[section ""data" . Data.Maybe.mapMaybe_closure" {
     Data.Maybe.mapMaybe_closure:
         const Data.Maybe.mapMaybe_info;
 },
 sat_srGT_entry() //  [R1]
         { info_tbl: [(crNV,
                       label: sat_srGT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crNV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto crNW; else goto crNX;
       crNW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       crNX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Maybe.mapMaybe_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Maybe.mapMaybe_entry() //  [R2, R3]
         { info_tbl: [(crO2,
                       label: Data.Maybe.mapMaybe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crO2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto crO3; else goto urOi;
       crO3: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Maybe.mapMaybe_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       urOi: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _crND() args: 0, res: 0, upd: 0;
     }
 },
 _crND() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crND: // global
           I64[Sp - 8] = block_crNG_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto urOk; else goto crNH;
       urOk: // global
           call _crNG(R1) args: 0, res: 0, upd: 0;
       crNH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _crNG() //  [R1]
         { info_tbl: [(crNG,
                       label: block_crNG_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crNG: // global
           if (R1 & 7 == 1) goto crNZ; else goto crO0;
       crNZ: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       crO0: // global
           I64[Sp] = block_crNM_info;
           R2 = P64[R1 + 6];
           _srGQ::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 16] = _srGQ::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _crNM() //  [R1]
         { info_tbl: [(crNM,
                       label: block_crNM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       crNM: // global
           _srGM::P64 = P64[Sp + 8];
           _srGQ::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto crOb; else goto crOd;
       crOb: // global
           P64[Sp + 8] = _srGM::P64;
           P64[Sp + 16] = _srGQ::P64;
           Sp = Sp + 8;
           call _crND() args: 0, res: 0, upd: 0;
       crOd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto crOg; else goto crOf;
       crOg: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       crOf: // global
           _srGS::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_srGT_info;
           P64[Hp - 32] = _srGM::P64;
           P64[Hp - 24] = _srGQ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _srGS::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.513743554 UTC

[section ""cstring" . Data.Maybe.$trModule2_bytes" {
     Data.Maybe.$trModule2_bytes:
         I8[] [68,97,116,97,46,77,97,121,98,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.515420664 UTC

[section ""data" . Data.Maybe.$trModule1_closure" {
     Data.Maybe.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Maybe.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.517070673 UTC

[section ""cstring" . Data.Maybe.$trModule4_bytes" {
     Data.Maybe.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.518701999 UTC

[section ""data" . Data.Maybe.$trModule3_closure" {
     Data.Maybe.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Maybe.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.520367887 UTC

[section ""data" . Data.Maybe.$trModule_closure" {
     Data.Maybe.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Maybe.$trModule3_closure+1;
         const Data.Maybe.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:05.5224946 UTC

[section ""relreadonly" . SrIS_srt" {
     SrIS_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Maybe.fromJust_closure;
         const Data.Maybe.fromJust1_closure;
 }]

