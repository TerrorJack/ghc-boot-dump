
==================== Tidy Core ====================
2018-03-16 16:09:29.622721337 UTC

Result size of Tidy Core
  = {terms: 30,072, types: 79,897, coercions: 6,044, joins: 3/480}

-- RHS size: {terms: 6, types: 228, coercions: 0, joins: 0/0}
Data.Data.$p1Data :: forall a. Data a => Typeable a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLLLLLLLLL),U(U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for Data.Data.$p1Data: "Class op $p1Data"]
Data.Data.$p1Data
  = \ (@ a_ae1S5) (v_B1 :: Data a_ae1S5) ->
      case v_B1 of v_B1
      { Data.Data.C:Data v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg ->
      v_B2
      }

-- RHS size: {terms: 6, types: 228, coercions: 0, joins: 0/0}
gfoldl
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> a -> c a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLLLLLLLLL),U(A,U,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for gfoldl: "Class op gfoldl"]
gfoldl
  = \ (@ a_ae1S5) (v_B1 :: Data a_ae1S5) ->
      case v_B1 of v_B1
      { Data.Data.C:Data v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg ->
      v_B3
      }

-- RHS size: {terms: 6, types: 228, coercions: 0, joins: 0/0}
gunfold
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLLLLLLLLL),U(A,A,U,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for gunfold: "Class op gunfold"]
gunfold
  = \ (@ a_ae1S5) (v_B1 :: Data a_ae1S5) ->
      case v_B1 of v_B1
      { Data.Data.C:Data v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg ->
      v_B4
      }

-- RHS size: {terms: 6, types: 228, coercions: 0, joins: 0/0}
toConstr :: forall a. Data a => a -> Constr
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLLLLLLLLL),U(A,A,A,U,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for toConstr: "Class op toConstr"]
toConstr
  = \ (@ a_ae1S5) (v_B1 :: Data a_ae1S5) ->
      case v_B1 of v_B1
      { Data.Data.C:Data v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg ->
      v_B5
      }

-- RHS size: {terms: 6, types: 228, coercions: 0, joins: 0/0}
dataTypeOf :: forall a. Data a => a -> DataType
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLLLLLLLLL),U(A,A,A,A,U,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for dataTypeOf: "Class op dataTypeOf"]
dataTypeOf
  = \ (@ a_ae1S5) (v_B1 :: Data a_ae1S5) ->
      case v_B1 of v_B1
      { Data.Data.C:Data v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg ->
      v_B6
      }

-- RHS size: {terms: 6, types: 228, coercions: 0, joins: 0/0}
dataCast1
  :: forall a.
     Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLLLLLLLLL),U(A,A,A,A,A,U,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for dataCast1: "Class op dataCast1"]
dataCast1
  = \ (@ a_ae1S5) (v_B1 :: Data a_ae1S5) ->
      case v_B1 of v_B1
      { Data.Data.C:Data v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg ->
      v_B7
      }

-- RHS size: {terms: 6, types: 228, coercions: 0, joins: 0/0}
dataCast2
  :: forall a.
     Data a =>
     forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSLLLLLLLL),U(A,A,A,A,A,A,U,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for dataCast2: "Class op dataCast2"]
dataCast2
  = \ (@ a_ae1S5) (v_B1 :: Data a_ae1S5) ->
      case v_B1 of v_B1
      { Data.Data.C:Data v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg ->
      v_B8
      }

-- RHS size: {terms: 6, types: 228, coercions: 0, joins: 0/0}
gmapT :: forall a. Data a => (forall b. Data b => b -> b) -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLSLLLLLLL),U(A,A,A,A,A,A,A,U,A,A,A,A,A,A,A)>,
 RULES: Built in rule for gmapT: "Class op gmapT"]
gmapT
  = \ (@ a_ae1S5) (v_B1 :: Data a_ae1S5) ->
      case v_B1 of v_B1
      { Data.Data.C:Data v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg ->
      v_B9
      }

-- RHS size: {terms: 6, types: 228, coercions: 0, joins: 0/0}
gmapQl
  :: forall a.
     Data a =>
     forall r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLSLLLLLL),U(A,A,A,A,A,A,A,A,U,A,A,A,A,A,A)>,
 RULES: Built in rule for gmapQl: "Class op gmapQl"]
gmapQl
  = \ (@ a_ae1S5) (v_B1 :: Data a_ae1S5) ->
      case v_B1 of v_B1
      { Data.Data.C:Data v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg ->
      v_Ba
      }

-- RHS size: {terms: 6, types: 228, coercions: 0, joins: 0/0}
gmapQr
  :: forall a.
     Data a =>
     forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLSLLLLL),U(A,A,A,A,A,A,A,A,A,U,A,A,A,A,A)>,
 RULES: Built in rule for gmapQr: "Class op gmapQr"]
gmapQr
  = \ (@ a_ae1S5) (v_B1 :: Data a_ae1S5) ->
      case v_B1 of v_B1
      { Data.Data.C:Data v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg ->
      v_Bb
      }

-- RHS size: {terms: 6, types: 228, coercions: 0, joins: 0/0}
gmapQ
  :: forall a.
     Data a =>
     forall u. (forall d. Data d => d -> u) -> a -> [u]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLSLLLL),U(A,A,A,A,A,A,A,A,A,A,U,A,A,A,A)>,
 RULES: Built in rule for gmapQ: "Class op gmapQ"]
gmapQ
  = \ (@ a_ae1S5) (v_B1 :: Data a_ae1S5) ->
      case v_B1 of v_B1
      { Data.Data.C:Data v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg ->
      v_Bc
      }

-- RHS size: {terms: 6, types: 228, coercions: 0, joins: 0/0}
gmapQi
  :: forall a.
     Data a =>
     forall u. Int -> (forall d. Data d => d -> u) -> a -> u
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLSLLL),U(A,A,A,A,A,A,A,A,A,A,A,U,A,A,A)>,
 RULES: Built in rule for gmapQi: "Class op gmapQi"]
gmapQi
  = \ (@ a_ae1S5) (v_B1 :: Data a_ae1S5) ->
      case v_B1 of v_B1
      { Data.Data.C:Data v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg ->
      v_Bd
      }

-- RHS size: {terms: 6, types: 228, coercions: 0, joins: 0/0}
gmapM
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> a -> m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLSLL),U(A,A,A,A,A,A,A,A,A,A,A,A,U,A,A)>,
 RULES: Built in rule for gmapM: "Class op gmapM"]
gmapM
  = \ (@ a_ae1S5) (v_B1 :: Data a_ae1S5) ->
      case v_B1 of v_B1
      { Data.Data.C:Data v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg ->
      v_Be
      }

-- RHS size: {terms: 6, types: 228, coercions: 0, joins: 0/0}
gmapMp
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> a -> m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLSL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,U,A)>,
 RULES: Built in rule for gmapMp: "Class op gmapMp"]
gmapMp
  = \ (@ a_ae1S5) (v_B1 :: Data a_ae1S5) ->
      case v_B1 of v_B1
      { Data.Data.C:Data v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg ->
      v_Bf
      }

-- RHS size: {terms: 6, types: 228, coercions: 0, joins: 0/0}
gmapMo
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> a -> m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLS),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,U)>,
 RULES: Built in rule for gmapMo: "Class op gmapMo"]
gmapMo
  = \ (@ a_ae1S5) (v_B1 :: Data a_ae1S5) ->
      case v_B1 of v_B1
      { Data.Data.C:Data v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9 v_Ba
                         v_Bb v_Bc v_Bd v_Be v_Bf v_Bg ->
      v_Bg
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_rejM8 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl_rejM8 = " is not of type Char."#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl1_rejM9 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl1_rejM9 = "Data.Data.gunfold: Constructor "#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl2_rejMa :: [Char]
[GblId]
lvl2_rejMa = unpackCString# lvl_rejM8

-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
Data.Data.$wlvl1 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *). String -> c Char
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
Data.Data.$wlvl1
  = \ (@ (c_sefJU :: * -> *)) (ww_sefJZ :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ (c_sefJU Char)
        (unpackAppendCString# lvl1_rejM9 (++ @ Char ww_sefJZ lvl2_rejMa))

-- RHS size: {terms: 7, types: 13, coercions: 0, joins: 0/0}
Data.Data.$fDataChar6 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *). Constr -> c Char
[GblId,
 Arity=1,
 Str=<B,1*U(A,1*U,A,A,A)>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_sefJU :: * -> *)) (w_sefJV [Occ=Once!] :: Constr) ->
                 case w_sefJV of
                 { Constr _ [Occ=Dead] ww2_sefJZ [Occ=Once] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Data.$wlvl1 @ c_sefJU ww2_sefJZ
                 }}]
Data.Data.$fDataChar6
  = \ (@ (c_sefJU :: * -> *)) (w_sefJV :: Constr) ->
      case w_sefJV of
      { Constr ww1_sefJY ww2_sefJZ ww3_sefK0 ww4_sefK1 ww5_sefK2 ->
      Data.Data.$wlvl1 @ c_sefJU ww2_sefJZ
      }

-- RHS size: {terms: 15, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataChar_$cgunfold
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c Char
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,1*U,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_ae6ry :: * -> *))
                 _ [Occ=Dead]
                 (z_ae1Vp [Occ=Once!] :: forall r. r -> c_ae6ry r)
                 (c1_ae1Vq [Occ=Once!] :: Constr) ->
                 case c1_ae1Vq of wild_Xrf
                 { Constr ds1_de7lX [Occ=Once!] _ [Occ=Dead] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 case ds1_de7lX of {
                   __DEFAULT -> Data.Data.$fDataChar6 @ c_ae6ry wild_Xrf;
                   CharConstr x_ae1Vr [Occ=Once] -> z_ae1Vp @ Char x_ae1Vr
                 }
                 }}]
Data.Data.$fDataChar_$cgunfold
  = \ (@ (c_ae6ry :: * -> *))
      _ [Occ=Dead]
      (z_ae1Vp :: forall r. r -> c_ae6ry r)
      (c1_ae1Vq :: Constr) ->
      case c1_ae1Vq of
      { Constr ds1_de7lX ds2_de7lY ds3_de7lZ ds4_de7m0 ds5_de7m1 ->
      case ds1_de7lX of {
        __DEFAULT -> Data.Data.$wlvl1 @ c_ae6ry ds2_de7lY;
        CharConstr x_ae1Vr -> z_ae1Vp @ Char x_ae1Vr
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataChar3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Data.$fDataChar3 = "Prelude.Char"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataChar2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataChar2 = unpackCString# Data.Data.$fDataChar3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
charType :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
charType
  = Data.Data.DataType Data.Data.$fDataChar2 Data.Data.CharRep

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataChar_$cdataTypeOf :: Char -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> charType}]
Data.Data.$fDataChar_$cdataTypeOf = \ _ [Occ=Dead] -> charType

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataInt3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Data.$fDataInt3 = "Prelude.Int"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataInt2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataInt2 = unpackCString# Data.Data.$fDataInt3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
intType :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
intType = Data.Data.DataType Data.Data.$fDataInt2 Data.Data.IntRep

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataInt_$cdataTypeOf :: Int -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> intType}]
Data.Data.$fDataInt_$cdataTypeOf = \ _ [Occ=Dead] -> intType

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl3_rejMb :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl3_rejMb = ", as it is not an Char data type."#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl4_rejMc :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl4_rejMc = "Data.Data.mkCharConstr is not supported for "#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl5_rejMd :: [Char]
[GblId]
lvl5_rejMd = unpackCString# lvl3_rejMb

-- RHS size: {terms: 7, types: 4, coercions: 0, joins: 0/0}
Data.Data.$wlvl19 [InlPrag=NOUSERINLINE[0]] :: String -> Constr
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
Data.Data.$wlvl19
  = \ (ww_sefK8 :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ Constr
        (unpackAppendCString# lvl4_rejMc (++ @ Char ww_sefK8 lvl5_rejMd))

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
Data.Data.mkCharConstr1 [InlPrag=NOUSERINLINE[0]]
  :: DataType -> Constr
[GblId,
 Arity=1,
 Str=<B,1*U(1*U,A)>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sefK5 [Occ=Once!] :: DataType) ->
                 case w_sefK5 of { DataType ww1_sefK8 [Occ=Once] _ [Occ=Dead] ->
                 Data.Data.$wlvl19 ww1_sefK8
                 }}]
Data.Data.mkCharConstr1
  = \ (w_sefK5 :: DataType) ->
      case w_sefK5 of { DataType ww1_sefK8 ww2_sefK9 ->
      Data.Data.$wlvl19 ww1_sefK8
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl6_rejMe :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl6_rejMe = "Data.Data.confixity"#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataChar4 :: Fixity
[GblId, Str=x]
Data.Data.$fDataChar4
  = errorWithoutStackTrace
      @ 'LiftedRep @ Fixity (unpackCString# lvl6_rejMe)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl7_rejMf :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl7_rejMf = "Data.Data.confields"#

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
Data.Data.$fDataChar5 :: [String]
[GblId, Str=x]
Data.Data.$fDataChar5
  = errorWithoutStackTrace
      @ 'LiftedRep @ [String] (unpackCString# lvl7_rejMf)

-- RHS size: {terms: 19, types: 6, coercions: 0, joins: 0/0}
mkCharConstr :: DataType -> Char -> Constr
[GblId,
 Arity=2,
 Str=<S(LS),1*U(U,U)><L,U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (dt_ae1WE [Occ=Once!] :: DataType) (c_ae1WF :: Char) ->
                 case dt_ae1WE of wild_XqY
                 { DataType _ [Occ=Dead] ds1_de7mv [Occ=Once!] ->
                 case ds1_de7mv of {
                   __DEFAULT -> Data.Data.mkCharConstr1 wild_XqY;
                   CharRep ->
                     Data.Data.Constr
                       (Data.Data.CharConstr c_ae1WF)
                       (GHC.Show.$fShowChar_$cshow c_ae1WF)
                       Data.Data.$fDataChar5
                       Data.Data.$fDataChar4
                       wild_XqY
                 }
                 }}]
mkCharConstr
  = \ (dt_ae1WE :: DataType) (c_ae1WF :: Char) ->
      case dt_ae1WE of wild_XqY { DataType ds_de7mu ds1_de7mv ->
      case ds1_de7mv of {
        __DEFAULT -> Data.Data.$wlvl19 ds_de7mu;
        CharRep ->
          Data.Data.Constr
            (Data.Data.CharConstr c_ae1WF)
            (GHC.Show.$fShowChar_$cshow c_ae1WF)
            Data.Data.$fDataChar5
            Data.Data.$fDataChar4
            wild_XqY
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataChar_$ctoConstr :: Char -> Constr
[GblId,
 Arity=1,
 Str=<L,U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_ae1Vo :: Char) ->
                 Data.Data.Constr
                   (Data.Data.CharConstr x_ae1Vo)
                   (GHC.Show.$fShowChar_$cshow x_ae1Vo)
                   Data.Data.$fDataChar5
                   Data.Data.$fDataChar4
                   charType}]
Data.Data.$fDataChar_$ctoConstr
  = \ (x_ae1Vo :: Char) ->
      Data.Data.Constr
        (Data.Data.CharConstr x_ae1Vo)
        (GHC.Show.$fShowChar_$cshow x_ae1Vo)
        Data.Data.$fDataChar5
        Data.Data.$fDataChar4
        charType

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataChar_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c Char)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae6sg :: * -> * -> *))
                 (@ (c_ae6sh :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae6sh Char)}]
Data.Data.$fDataChar_$cdataCast2
  = \ (@ (t_ae6sg :: * -> * -> *))
      (@ (c_ae6sh :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae6sh Char)

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataChar_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c Char)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae6rX :: * -> *))
                 (@ (c_ae6rY :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae6rY Char)}]
Data.Data.$fDataChar_$cdataCast1
  = \ (@ (t_ae6rX :: * -> *))
      (@ (c_ae6rY :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae6rY Char)

-- RHS size: {terms: 4, types: 22, coercions: 0, joins: 0/0}
Data.Data.$fDataChar_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Char -> c Char
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (c_ae6rf :: * -> *))
                 _ [Occ=Dead]
                 (ds1_de7Ss [Occ=Once] :: forall g. g -> c_ae6rf g) ->
                 ds1_de7Ss @ Char}]
Data.Data.$fDataChar_$cgfoldl
  = \ (@ (c_ae6rf :: * -> *))
      _ [Occ=Dead]
      (ds1_de7Ss :: forall g. g -> c_ae6rf g) ->
      ds1_de7Ss @ Char

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fDataChar1
  :: (forall b. Data b => b -> b) -> Char -> Char
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (x0_Xe2Rz [Occ=Once] :: Char) -> x0_Xe2Rz}]
Data.Data.$fDataChar1
  = \ _ [Occ=Dead] (x0_Xe2Rz :: Char) -> x0_Xe2Rz

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataChar_$cgmapQl
  :: forall r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> Char -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae6sO)
                 (@ r'_ae6sP)
                 _ [Occ=Dead]
                 (ds1_de7SS [Occ=Once] :: r_ae6sO)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7SS}]
Data.Data.$fDataChar_$cgmapQl
  = \ (@ r_ae6sO)
      (@ r'_ae6sP)
      _ [Occ=Dead]
      (ds1_de7SS :: r_ae6sO)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7SS

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataChar_$cgmapQr
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> Char -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae6t5)
                 (@ r'_ae6t6)
                 _ [Occ=Dead]
                 (ds1_de7SV [Occ=Once] :: r_ae6t5)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7SV}]
Data.Data.$fDataChar_$cgmapQr
  = \ (@ r_ae6t5)
      (@ r'_ae6t6)
      _ [Occ=Dead]
      (ds1_de7SV :: r_ae6t5)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7SV

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
Data.Data.$fDataChar_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> Char -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae6tm) _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.[] @ u_ae6tm}]
Data.Data.$fDataChar_$cgmapQ
  = \ (@ u_ae6tm) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.[] @ u_ae6tm

-- RHS size: {terms: 5, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataChar_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Char -> m Char
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLSL),1*U(A,A,A,1*U,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_ae6tO :: * -> *))
                 ($dMonad_ae6tQ [Occ=Once] :: Monad m_ae6tO)
                 _ [Occ=Dead] ->
                 return @ m_ae6tO $dMonad_ae6tQ @ Char}]
Data.Data.$fDataChar_$cgmapM
  = \ (@ (m_ae6tO :: * -> *))
      ($dMonad_ae6tQ :: Monad m_ae6tO)
      _ [Occ=Dead] ->
      return @ m_ae6tO $dMonad_ae6tQ @ Char

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp9 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Char -> m Char
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMp9
  = \ (@ (m_sefKc :: * -> *))
      (w_sefKd :: MonadPlus m_sefKc)
      (w1_sefKf :: Char) ->
      let {
        lvl270_se9xk :: m_sefKc Char
        [LclId]
        lvl270_se9xk = mzero @ m_sefKc w_sefKd @ Char } in
      let {
        $dMonad_se9tR [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_sefKc
        [LclId]
        $dMonad_se9tR = GHC.Base.$p2MonadPlus @ m_sefKc w_sefKd } in
      >>=
        @ m_sefKc
        $dMonad_se9tR
        @ (Char, Bool)
        @ Char
        (return
           @ m_sefKc $dMonad_se9tR @ (Char, Bool) (w1_sefKf, GHC.Types.False))
        (\ (ds_de7oa :: (Char, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9xk;
             True -> return @ m_sefKc $dMonad_se9tR @ Char x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataChar_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Char -> m Char
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_sefKc :: * -> *))
                 (w_sefKd [Occ=Once] :: MonadPlus m_sefKc)
                 _ [Occ=Dead]
                 (w2_sefKf [Occ=Once] :: Char) ->
                 Data.Data.$w$cgmapMp9 @ m_sefKc w_sefKd w2_sefKf}]
Data.Data.$fDataChar_$cgmapMp
  = \ (@ (m_sefKc :: * -> *))
      (w_sefKd :: MonadPlus m_sefKc)
      _ [Occ=Dead]
      (w2_sefKf :: Char) ->
      Data.Data.$w$cgmapMp9 @ m_sefKc w_sefKd w2_sefKf

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataChar_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> Char -> u
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae6tA) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Maybe.fromJust1 @ u_ae6tA}]
Data.Data.$fDataChar_$cgmapQi
  = \ (@ u_ae6tA) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Maybe.fromJust1 @ u_ae6tA

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo8 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Char -> m Char
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMo8
  = \ (@ (m_sefKh :: * -> *))
      (w_sefKi :: MonadPlus m_sefKh)
      (w1_sefKk :: Char) ->
      let {
        lvl270_se9xj :: m_sefKh Char
        [LclId]
        lvl270_se9xj = mzero @ m_sefKh w_sefKi @ Char } in
      let {
        $dMonad_se9tP [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_sefKh
        [LclId]
        $dMonad_se9tP = GHC.Base.$p2MonadPlus @ m_sefKh w_sefKi } in
      >>=
        @ m_sefKh
        $dMonad_se9tP
        @ (Char, Bool)
        @ Char
        (return
           @ m_sefKh $dMonad_se9tP @ (Char, Bool) (w1_sefKk, GHC.Types.False))
        (\ (ds_de7pa :: (Char, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9xj;
             True -> return @ m_sefKh $dMonad_se9tP @ Char x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataChar_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Char -> m Char
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_sefKh :: * -> *))
                 (w_sefKi [Occ=Once] :: MonadPlus m_sefKh)
                 _ [Occ=Dead]
                 (w2_sefKk [Occ=Once] :: Char) ->
                 Data.Data.$w$cgmapMo8 @ m_sefKh w_sefKi w2_sefKk}]
Data.Data.$fDataChar_$cgmapMo
  = \ (@ (m_sefKh :: * -> *))
      (w_sefKi :: MonadPlus m_sefKh)
      _ [Occ=Dead]
      (w2_sefKk :: Char) ->
      Data.Data.$w$cgmapMo8 @ m_sefKh w_sefKi w2_sefKk

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl8_rejMg :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl8_rejMg = " is not of type Int."#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl9_rejMh :: [Char]
[GblId]
lvl9_rejMh = unpackCString# lvl8_rejMg

-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
Data.Data.$wlvl2 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *). String -> c Int
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
Data.Data.$wlvl2
  = \ (@ (c_sefKm :: * -> *)) (ww_sefKr :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ (c_sefKm Int)
        (unpackAppendCString# lvl1_rejM9 (++ @ Char ww_sefKr lvl9_rejMh))

-- RHS size: {terms: 17, types: 16, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold5 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r) -> ConstrRep -> String -> c Int
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 50 0] 100 0}]
Data.Data.$w$cgunfold5
  = \ (@ (c_sefKx :: * -> *))
      (w_sefKz :: forall r. r -> c_sefKx r)
      (ww_sefKD :: ConstrRep)
      (ww1_sefKE :: String) ->
      case ww_sefKD of {
        __DEFAULT -> Data.Data.$wlvl2 @ c_sefKx ww1_sefKE;
        IntConstr x_ae1Vh ->
          w_sefKz
            @ Int
            (case integerToInt x_ae1Vh of wild1_i7Vf0 { __DEFAULT ->
             GHC.Types.I# wild1_i7Vf0
             })
      }

-- RHS size: {terms: 11, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataInt_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c Int
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,1*U,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_sefKx :: * -> *))
                 _ [Occ=Dead]
                 (w1_sefKz [Occ=Once] :: forall r. r -> c_sefKx r)
                 (w2_sefKA [Occ=Once!] :: Constr) ->
                 case w2_sefKA of
                 { Constr ww1_sefKD [Occ=Once] ww2_sefKE [Occ=Once] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Data.$w$cgunfold5 @ c_sefKx w1_sefKz ww1_sefKD ww2_sefKE
                 }}]
Data.Data.$fDataInt_$cgunfold
  = \ (@ (c_sefKx :: * -> *))
      _ [Occ=Dead]
      (w1_sefKz :: forall r. r -> c_sefKx r)
      (w2_sefKA :: Constr) ->
      case w2_sefKA of
      { Constr ww1_sefKD ww2_sefKE ww3_sefKF ww4_sefKG ww5_sefKH ->
      Data.Data.$w$cgunfold5 @ c_sefKx w1_sefKz ww1_sefKD ww2_sefKE
      }

-- RHS size: {terms: 4, types: 22, coercions: 0, joins: 0/0}
Data.Data.$fDataInt_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Int -> c Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (c_ae6gy :: * -> *))
                 _ [Occ=Dead]
                 (ds1_de7Qx [Occ=Once] :: forall g. g -> c_ae6gy g) ->
                 ds1_de7Qx @ Int}]
Data.Data.$fDataInt_$cgfoldl
  = \ (@ (c_ae6gy :: * -> *))
      _ [Occ=Dead]
      (ds1_de7Qx :: forall g. g -> c_ae6gy g) ->
      ds1_de7Qx @ Int

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp10 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Int -> m Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMp10
  = \ (@ (m_sefKK :: * -> *))
      (w_sefKL :: MonadPlus m_sefKK)
      (w1_sefKN :: Int) ->
      let {
        lvl270_se9xf :: m_sefKK Int
        [LclId]
        lvl270_se9xf = mzero @ m_sefKK w_sefKL @ Int } in
      let {
        $dMonad_se9tN [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_sefKK
        [LclId]
        $dMonad_se9tN = GHC.Base.$p2MonadPlus @ m_sefKK w_sefKL } in
      >>=
        @ m_sefKK
        $dMonad_se9tN
        @ (Int, Bool)
        @ Int
        (return
           @ m_sefKK $dMonad_se9tN @ (Int, Bool) (w1_sefKN, GHC.Types.False))
        (\ (ds_de7oa :: (Int, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9xf;
             True -> return @ m_sefKK $dMonad_se9tN @ Int x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Int -> m Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_sefKK :: * -> *))
                 (w_sefKL [Occ=Once] :: MonadPlus m_sefKK)
                 _ [Occ=Dead]
                 (w2_sefKN [Occ=Once] :: Int) ->
                 Data.Data.$w$cgmapMp10 @ m_sefKK w_sefKL w2_sefKN}]
Data.Data.$fDataInt_$cgmapMp
  = \ (@ (m_sefKK :: * -> *))
      (w_sefKL :: MonadPlus m_sefKK)
      _ [Occ=Dead]
      (w2_sefKN :: Int) ->
      Data.Data.$w$cgmapMp10 @ m_sefKK w_sefKL w2_sefKN

-- RHS size: {terms: 5, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Int -> m Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLSL),1*U(A,A,A,1*U,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_ae6je :: * -> *))
                 ($dMonad_ae6jg [Occ=Once] :: Monad m_ae6je)
                 _ [Occ=Dead] ->
                 return @ m_ae6je $dMonad_ae6jg @ Int}]
Data.Data.$fDataInt_$cgmapM
  = \ (@ (m_ae6je :: * -> *))
      ($dMonad_ae6jg :: Monad m_ae6je)
      _ [Occ=Dead] ->
      return @ m_ae6je $dMonad_ae6jg @ Int

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataInt_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> Int -> u
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae6j0) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Maybe.fromJust1 @ u_ae6j0}]
Data.Data.$fDataInt_$cgmapQi
  = \ (@ u_ae6j0) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Maybe.fromJust1 @ u_ae6j0

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt_$cgmapQr
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> Int -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae6iv)
                 (@ r'_ae6iw)
                 _ [Occ=Dead]
                 (ds1_de7R0 [Occ=Once] :: r_ae6iv)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7R0}]
Data.Data.$fDataInt_$cgmapQr
  = \ (@ r_ae6iv)
      (@ r'_ae6iw)
      _ [Occ=Dead]
      (ds1_de7R0 :: r_ae6iv)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7R0

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
Data.Data.$fDataInt_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> Int -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae6iM) _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.[] @ u_ae6iM}]
Data.Data.$fDataInt_$cgmapQ
  = \ (@ u_ae6iM) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.[] @ u_ae6iM

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt_$cgmapQl
  :: forall r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> Int -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae6ie)
                 (@ r'_ae6if)
                 _ [Occ=Dead]
                 (ds1_de7QX [Occ=Once] :: r_ae6ie)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7QX}]
Data.Data.$fDataInt_$cgmapQl
  = \ (@ r_ae6ie)
      (@ r'_ae6if)
      _ [Occ=Dead]
      (ds1_de7QX :: r_ae6ie)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7QX

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fDataInt1 :: (forall b. Data b => b -> b) -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (x0_Xe2RU [Occ=Once] :: Int) -> x0_Xe2RU}]
Data.Data.$fDataInt1 = \ _ [Occ=Dead] (x0_Xe2RU :: Int) -> x0_Xe2RU

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataInt_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c Int)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae6hG :: * -> * -> *))
                 (@ (c_ae6hH :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae6hH Int)}]
Data.Data.$fDataInt_$cdataCast2
  = \ (@ (t_ae6hG :: * -> * -> *))
      (@ (c_ae6hH :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae6hH Int)

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataInt_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c Int)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae6hn :: * -> *))
                 (@ (c_ae6ho :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae6ho Int)}]
Data.Data.$fDataInt_$cdataCast1
  = \ (@ (t_ae6hn :: * -> *))
      (@ (c_ae6ho :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae6ho Int)

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo9 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Int -> m Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMo9
  = \ (@ (m_sefKP :: * -> *))
      (w_sefKQ :: MonadPlus m_sefKP)
      (w1_sefKS :: Int) ->
      let {
        lvl270_se9xe :: m_sefKP Int
        [LclId]
        lvl270_se9xe = mzero @ m_sefKP w_sefKQ @ Int } in
      let {
        $dMonad_se9tL [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_sefKP
        [LclId]
        $dMonad_se9tL = GHC.Base.$p2MonadPlus @ m_sefKP w_sefKQ } in
      >>=
        @ m_sefKP
        $dMonad_se9tL
        @ (Int, Bool)
        @ Int
        (return
           @ m_sefKP $dMonad_se9tL @ (Int, Bool) (w1_sefKS, GHC.Types.False))
        (\ (ds_de7pa :: (Int, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9xe;
             True -> return @ m_sefKP $dMonad_se9tL @ Int x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Int -> m Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_sefKP :: * -> *))
                 (w_sefKQ [Occ=Once] :: MonadPlus m_sefKP)
                 _ [Occ=Dead]
                 (w2_sefKS [Occ=Once] :: Int) ->
                 Data.Data.$w$cgmapMo9 @ m_sefKP w_sefKQ w2_sefKS}]
Data.Data.$fDataInt_$cgmapMo
  = \ (@ (m_sefKP :: * -> *))
      (w_sefKQ :: MonadPlus m_sefKP)
      _ [Occ=Dead]
      (w2_sefKS :: Int) ->
      Data.Data.$w$cgmapMo9 @ m_sefKP w_sefKQ w2_sefKS

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataChar7 :: Data.Typeable.Internal.TypeRep Char
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataChar7
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Char
           8424092006618324671##
           2724268014499746065##
           GHC.Types.$trModule
           GHC.Types.$tcChar1
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ Char ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 16, types: 1, coercions: 5, joins: 0/0}
Data.Data.$fDataChar [InlPrag=NOUSERINLINE CONLIKE] :: Data Char
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: Char
                        Data.Data.$fDataChar7
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Char>_N
                                :: (Data.Typeable.Internal.TypeRep Char :: *)
                                   ~R# (Typeable Char :: Constraint))
                        Data.Data.$fDataChar_$cgfoldl
                        Data.Data.$fDataChar_$cgunfold
                        Data.Data.$fDataChar_$ctoConstr
                        Data.Data.$fDataChar_$cdataTypeOf
                        Data.Data.$fDataChar_$cdataCast1
                        Data.Data.$fDataChar_$cdataCast2
                        Data.Data.$fDataChar1
                        Data.Data.$fDataChar_$cgmapQl
                        Data.Data.$fDataChar_$cgmapQr
                        Data.Data.$fDataChar_$cgmapQ
                        Data.Data.$fDataChar_$cgmapQi
                        Data.Data.$fDataChar_$cgmapM
                        Data.Data.$fDataChar_$cgmapMp
                        Data.Data.$fDataChar_$cgmapMo]
Data.Data.$fDataChar
  = Data.Data.C:Data
      @ Char
      (Data.Data.$fDataChar7
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Char>_N
               :: (Data.Typeable.Internal.TypeRep Char :: *)
                  ~R# (Typeable Char :: Constraint)))
      Data.Data.$fDataChar_$cgfoldl
      Data.Data.$fDataChar_$cgunfold
      Data.Data.$fDataChar_$ctoConstr
      Data.Data.$fDataChar_$cdataTypeOf
      Data.Data.$fDataChar_$cdataCast1
      Data.Data.$fDataChar_$cdataCast2
      Data.Data.$fDataChar1
      Data.Data.$fDataChar_$cgmapQl
      Data.Data.$fDataChar_$cgmapQr
      Data.Data.$fDataChar_$cgmapQ
      Data.Data.$fDataChar_$cgmapQi
      Data.Data.$fDataChar_$cgmapM
      Data.Data.$fDataChar_$cgmapMp
      Data.Data.$fDataChar_$cgmapMo

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataFloat4 :: Data.Typeable.Internal.TypeRep Float
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataFloat4
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Float
           9402587279369878392##
           18275781787481388674##
           GHC.Types.$trModule
           GHC.Types.$tcFloat1
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ Float ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataDouble4 :: Data.Typeable.Internal.TypeRep Double
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataDouble4
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Double
           1001516997883380745##
           15743804272740824943##
           GHC.Types.$trModule
           GHC.Types.$tcDouble1
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ Double ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataInt4 :: Data.Typeable.Internal.TypeRep Int
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataInt4
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Int
           5193196903533114208##
           8143820745237564347##
           GHC.Types.$trModule
           GHC.Types.$tcInt1
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ Int ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl10_rejMi :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl10_rejMi = ", as it is not an Integral data type."#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl11_rejMj :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl11_rejMj = "Data.Data.mkIntegralConstr is not supported for "#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl12_rejMk :: [Char]
[GblId]
lvl12_rejMk = unpackCString# lvl10_rejMi

-- RHS size: {terms: 7, types: 4, coercions: 0, joins: 0/0}
Data.Data.$wlvl20 [InlPrag=NOUSERINLINE[0]] :: String -> Constr
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
Data.Data.$wlvl20
  = \ (ww_sefKX :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ Constr
        (unpackAppendCString# lvl11_rejMj (++ @ Char ww_sefKX lvl12_rejMk))

-- RHS size: {terms: 27, types: 14, coercions: 0, joins: 0/0}
mkIntegralConstr [InlPrag=NOUSERINLINE[0]]
  :: forall a. (Integral a, Show a) => DataType -> a -> Constr
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,A,A,A,A,A,A,1*C1(U))><L,1*U(A,1*C1(U),A)><S(LS),1*U(U,1*U)><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sefO9)
                 (w_sefOa [Occ=Once] :: Integral a_sefO9)
                 (w1_sefOb [Occ=Once] :: Show a_sefO9)
                 (w2_sefOc [Occ=Once!] :: DataType)
                 (w3_sefOd :: a_sefO9) ->
                 case w2_sefOc of
                 { DataType ww1_sefOg [Occ=Once*] ww2_sefOh [Occ=Once!] ->
                 case ww2_sefOh of {
                   __DEFAULT -> Data.Data.$wlvl20 ww1_sefOg;
                   IntRep ->
                     Data.Data.Constr
                       (Data.Data.IntConstr (toInteger @ a_sefO9 w_sefOa w3_sefOd))
                       (show @ a_sefO9 w1_sefOb w3_sefOd)
                       Data.Data.$fDataChar5
                       Data.Data.$fDataChar4
                       (Data.Data.DataType ww1_sefOg Data.Data.IntRep)
                 }
                 }}]
mkIntegralConstr
  = \ (@ a_sefO9)
      (w_sefOa :: Integral a_sefO9)
      (w1_sefOb :: Show a_sefO9)
      (w2_sefOc :: DataType)
      (w3_sefOd :: a_sefO9) ->
      case w2_sefOc of { DataType ww1_sefOg ww2_sefOh ->
      case ww2_sefOh of {
        __DEFAULT -> Data.Data.$wlvl20 ww1_sefOg;
        IntRep ->
          Data.Data.Constr
            (Data.Data.IntConstr (toInteger @ a_sefO9 w_sefOa w3_sefOd))
            (show @ a_sefO9 w1_sefOb w3_sefOd)
            Data.Data.$fDataChar5
            Data.Data.$fDataChar4
            (Data.Data.DataType ww1_sefOg Data.Data.IntRep)
      }
      }

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataInt_$ctoConstr :: Int -> Constr
[GblId,
 Arity=1,
 Str=<L,U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_ae1Ve :: Int) ->
                 Data.Data.Constr
                   (Data.Data.IntConstr (GHC.Real.$fIntegralInt_$ctoInteger x_ae1Ve))
                   (GHC.Show.$fShowInt_$cshow x_ae1Ve)
                   Data.Data.$fDataChar5
                   Data.Data.$fDataChar4
                   intType}]
Data.Data.$fDataInt_$ctoConstr
  = \ (x_ae1Ve :: Int) ->
      Data.Data.Constr
        (Data.Data.IntConstr (GHC.Real.$fIntegralInt_$ctoInteger x_ae1Ve))
        (GHC.Show.$fShowInt_$cshow x_ae1Ve)
        Data.Data.$fDataChar5
        Data.Data.$fDataChar4
        intType

-- RHS size: {terms: 16, types: 1, coercions: 5, joins: 0/0}
Data.Data.$fDataInt [InlPrag=NOUSERINLINE CONLIKE] :: Data Int
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: Int
                        Data.Data.$fDataInt4
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Int>_N
                                :: (Data.Typeable.Internal.TypeRep Int :: *)
                                   ~R# (Typeable Int :: Constraint))
                        Data.Data.$fDataInt_$cgfoldl
                        Data.Data.$fDataInt_$cgunfold
                        Data.Data.$fDataInt_$ctoConstr
                        Data.Data.$fDataInt_$cdataTypeOf
                        Data.Data.$fDataInt_$cdataCast1
                        Data.Data.$fDataInt_$cdataCast2
                        Data.Data.$fDataInt1
                        Data.Data.$fDataInt_$cgmapQl
                        Data.Data.$fDataInt_$cgmapQr
                        Data.Data.$fDataInt_$cgmapQ
                        Data.Data.$fDataInt_$cgmapQi
                        Data.Data.$fDataInt_$cgmapM
                        Data.Data.$fDataInt_$cgmapMp
                        Data.Data.$fDataInt_$cgmapMo]
Data.Data.$fDataInt
  = Data.Data.C:Data
      @ Int
      (Data.Data.$fDataInt4
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Int>_N
               :: (Data.Typeable.Internal.TypeRep Int :: *)
                  ~R# (Typeable Int :: Constraint)))
      Data.Data.$fDataInt_$cgfoldl
      Data.Data.$fDataInt_$cgunfold
      Data.Data.$fDataInt_$ctoConstr
      Data.Data.$fDataInt_$cdataTypeOf
      Data.Data.$fDataInt_$cdataCast1
      Data.Data.$fDataInt_$cdataCast2
      Data.Data.$fDataInt1
      Data.Data.$fDataInt_$cgmapQl
      Data.Data.$fDataInt_$cgmapQr
      Data.Data.$fDataInt_$cgmapQ
      Data.Data.$fDataInt_$cgmapQi
      Data.Data.$fDataInt_$cgmapM
      Data.Data.$fDataInt_$cgmapMp
      Data.Data.$fDataInt_$cgmapMo

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataInteger5 :: Data.Typeable.Internal.TypeRep Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataInteger5
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Integer
           12260413788024328428##
           9583620696682509916##
           integer-simple-0.1.1.1:GHC.Integer.Type.$trModule
           integer-simple-0.1.1.1:GHC.Integer.Type.$tcInteger1
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ Integer ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataNatural5 :: Data.Typeable.Internal.TypeRep Natural
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataNatural5
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Natural
           18275189520134122949##
           2097940004095541788##
           GHC.Natural.$trModule
           GHC.Natural.$tcNatural1
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ Natural ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataInt22 :: Data.Typeable.Internal.TypeRep Int8
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataInt22
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Int8
           1422706860619545536##
           2126344328513082648##
           GHC.Int.$trModule
           GHC.Int.$tcInt7
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ Int8 ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataInt9 :: Data.Typeable.Internal.TypeRep Int16
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataInt9
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Int16
           16329117591681623238##
           13363230803330610095##
           GHC.Int.$trModule
           GHC.Int.$tcInt1
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ Int16 ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataInt13 :: Data.Typeable.Internal.TypeRep Int32
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataInt13
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Int32
           5115671124548181797##
           6203735229629729265##
           GHC.Int.$trModule
           GHC.Int.$tcInt3
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ Int32 ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataInt18 :: Data.Typeable.Internal.TypeRep Int64
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataInt18
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Int64
           15049343324344240059##
           14445320765379163718##
           GHC.Int.$trModule
           GHC.Int.$tcInt5
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ Int64 ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataWord4 :: Data.Typeable.Internal.TypeRep Word
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataWord4
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Word
           8376323076812926367##
           11971203854817560424##
           GHC.Types.$trModule
           GHC.Types.$tcWord1
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ Word ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataWord22 :: Data.Typeable.Internal.TypeRep Word8
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataWord22
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Word8
           2052113150978616866##
           10393726928463219846##
           GHC.Word.$trModule
           GHC.Word.$tcWord7
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ Word8 ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataWord9 :: Data.Typeable.Internal.TypeRep Word16
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataWord9
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Word16
           1884349046328127494##
           12602100146125136909##
           GHC.Word.$trModule
           GHC.Word.$tcWord1
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ Word16 ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataWord13 :: Data.Typeable.Internal.TypeRep Word32
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataWord13
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Word32
           3293767376230595825##
           2424786049275339072##
           GHC.Word.$trModule
           GHC.Word.$tcWord3
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ Word32 ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataWord18 :: Data.Typeable.Internal.TypeRep Word64
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataWord18
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Word64
           3342358330123258062##
           10610880953247303810##
           GHC.Word.$trModule
           GHC.Word.$tcWord5
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ Word64 ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 19, types: 45, coercions: 0, joins: 0/0}
Data.Data.$fDataRatio_$cgfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Data a, Integral a) =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Ratio a -> c (Ratio a)
[GblId,
 Arity=5,
 Str=<L,U><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sefOn)
                 (w_sefOo :: Data a_sefOn)
                 (w1_sefOp [Occ=Once] :: Integral a_sefOn)
                 (@ (c_sefOq :: * -> *))
                 (w2_sefOr
                    :: forall d b. Data d => c_sefOq (d -> b) -> d -> c_sefOq b)
                 (w3_sefOs [Occ=Once!] :: forall g. g -> c_sefOq g)
                 (w4_sefOt [Occ=Once!] :: Ratio a_sefOn) ->
                 case w4_sefOt of { :% ww1_sefOw [Occ=Once] ww2_sefOx [Occ=Once] ->
                 w2_sefOr
                   @ a_sefOn
                   @ (Ratio a_sefOn)
                   w_sefOo
                   (w2_sefOr
                      @ a_sefOn
                      @ (a_sefOn -> Ratio a_sefOn)
                      w_sefOo
                      (w3_sefOs
                         @ (a_sefOn -> a_sefOn -> Ratio a_sefOn) (% @ a_sefOn w1_sefOp))
                      ww1_sefOw)
                   ww2_sefOx
                 }}]
Data.Data.$fDataRatio_$cgfoldl
  = \ (@ a_sefOn)
      (w_sefOo :: Data a_sefOn)
      (w1_sefOp :: Integral a_sefOn)
      (@ (c_sefOq :: * -> *))
      (w2_sefOr
         :: forall d b. Data d => c_sefOq (d -> b) -> d -> c_sefOq b)
      (w3_sefOs :: forall g. g -> c_sefOq g)
      (w4_sefOt :: Ratio a_sefOn) ->
      case w4_sefOt of { :% ww1_sefOw ww2_sefOx ->
      w2_sefOr
        @ a_sefOn
        @ (Ratio a_sefOn)
        w_sefOo
        (w2_sefOr
           @ a_sefOn
           @ (a_sefOn -> Ratio a_sefOn)
           w_sefOo
           (w3_sefOs
              @ (a_sefOn -> a_sefOn -> Ratio a_sefOn) (% @ a_sefOn w1_sefOp))
           ww1_sefOw)
        ww2_sefOx
      }

-- RHS size: {terms: 16, types: 41, coercions: 0, joins: 0/0}
Data.Data.$fDataRatio9 :: Data.Typeable.Internal.TypeRep Ratio
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataRatio9
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ Ratio
           17658523810845794968##
           1271393732863050253##
           GHC.Real.$trModule
           GHC.Real.$tcRatio1
           0#
           GHC.Types.krep$*Arr*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ Ratio
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 7, types: 13, coercions: 4, joins: 0/0}
Data.Data.$fDataRatio8
  :: forall a.
     (Data a, Integral a) =>
     Data.Typeable.Internal.TypeRep (Ratio a)
[GblId,
 Arity=2,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae5zZ)
                 ($dData_ae5A0 [Occ=Once] :: Data a_ae5zZ)
                 _ [Occ=Dead] ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Ratio
                   @ a_ae5zZ
                   Data.Data.$fDataRatio9
                   ((Data.Data.$p1Data @ a_ae5zZ $dData_ae5A0)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae5zZ>_N
                            :: (Typeable a_ae5zZ :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep a_ae5zZ :: *)))}]
Data.Data.$fDataRatio8
  = \ (@ a_ae5zZ) ($dData_ae5A0 :: Data a_ae5zZ) _ [Occ=Dead] ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ Ratio
        @ a_ae5zZ
        Data.Data.$fDataRatio9
        ((Data.Data.$p1Data @ a_ae5zZ $dData_ae5A0)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae5zZ>_N
                 :: (Typeable a_ae5zZ :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep a_ae5zZ :: *)))

-- RHS size: {terms: 16, types: 41, coercions: 0, joins: 0/0}
Data.Data.$fData[]2 :: Data.Typeable.Internal.TypeRep []
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fData[]2
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ []
           15300440589168157478##
           15016221815972113379##
           GHC.Types.$trModule
           GHC.Types.$tc[]1
           0#
           GHC.Types.krep$*Arr*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ []
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 16, types: 40, coercions: 12, joins: 0/1}
Data.Data.$fData[]_$s$cdataCast2
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c [Int])
[GblId,
 Arity=1,
 Str=<L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 100 60}]
Data.Data.$fData[]_$s$cdataCast2
  = \ (@ (t_ae5xj :: * -> *))
      (@ (c_ae5xk :: * -> *))
      ($dTypeable_ae5xm :: Typeable t_ae5xj) ->
      let {
        lvl270_se9yh :: Bool
        [LclId]
        lvl270_se9yh
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_ae5xj
              @ []
              ($dTypeable_ae5xm
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_ae5xj>_N
                       :: (Typeable t_ae5xj :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_ae5xj :: *)))
              Data.Data.$fData[]2 } in
      \ (f_ae1Ud :: forall d. Data d => c_ae5xk (t_ae5xj d)) ->
        case lvl270_se9yh of {
          False -> GHC.Base.Nothing @ (c_ae5xk [Int]);
          True ->
            GHC.Base.Just
              @ (c_ae5xk [Int])
              ((f_ae1Ud @ Int Data.Data.$fDataInt)
               `cast` (<c_ae5xk>_R (UnsafeCo nominal t_ae5xj [] <Int>_N)
                       :: (c_ae5xk (t_ae5xj Int) :: *) ~R# (c_ae5xk [Int] :: *)))
        }

-- RHS size: {terms: 16, types: 40, coercions: 12, joins: 0/1}
Data.Data.$fData[]_$s$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c [Char])
[GblId,
 Arity=1,
 Str=<L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 100 60}]
Data.Data.$fData[]_$s$cdataCast1
  = \ (@ (t_ae5xj :: * -> *))
      (@ (c_ae5xk :: * -> *))
      ($dTypeable_ae5xm :: Typeable t_ae5xj) ->
      let {
        lvl270_se9yk :: Bool
        [LclId]
        lvl270_se9yk
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_ae5xj
              @ []
              ($dTypeable_ae5xm
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_ae5xj>_N
                       :: (Typeable t_ae5xj :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_ae5xj :: *)))
              Data.Data.$fData[]2 } in
      \ (f_ae1Ud :: forall d. Data d => c_ae5xk (t_ae5xj d)) ->
        case lvl270_se9yk of {
          False -> GHC.Base.Nothing @ (c_ae5xk [Char]);
          True ->
            GHC.Base.Just
              @ (c_ae5xk [Char])
              ((f_ae1Ud @ Char Data.Data.$fDataChar)
               `cast` (<c_ae5xk>_R (UnsafeCo nominal t_ae5xj [] <Char>_N)
                       :: (c_ae5xk (t_ae5xj Char) :: *) ~R# (c_ae5xk [Char] :: *)))
        }

-- RHS size: {terms: 18, types: 44, coercions: 12, joins: 0/1}
Data.Data.$fData[]_$cdataCast1
  :: forall a.
     Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c [a])
[GblId,
 Arity=2,
 Str=<L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 100 60}]
Data.Data.$fData[]_$cdataCast1
  = \ (@ a_ae5wk)
      ($dData_ae5wl :: Data a_ae5wk)
      (@ (t_ae5xj :: * -> *))
      (@ (c_ae5xk :: * -> *))
      ($dTypeable_ae5xm :: Typeable t_ae5xj) ->
      let {
        lvl270_se9yn :: Bool
        [LclId]
        lvl270_se9yn
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_ae5xj
              @ []
              ($dTypeable_ae5xm
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_ae5xj>_N
                       :: (Typeable t_ae5xj :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_ae5xj :: *)))
              Data.Data.$fData[]2 } in
      \ (f_ae1Ud :: forall d. Data d => c_ae5xk (t_ae5xj d)) ->
        case lvl270_se9yn of {
          False -> GHC.Base.Nothing @ (c_ae5xk [a_ae5wk]);
          True ->
            GHC.Base.Just
              @ (c_ae5xk [a_ae5wk])
              ((f_ae1Ud @ a_ae5wk $dData_ae5wl)
               `cast` (<c_ae5xk>_R (UnsafeCo nominal t_ae5xj [] <a_ae5wk>_N)
                       :: (c_ae5xk (t_ae5xj a_ae5wk) :: *) ~R# (c_ae5xk [a_ae5wk] :: *)))
        }

-- RHS size: {terms: 6, types: 11, coercions: 4, joins: 0/0}
Data.Data.$fData[]6
  :: forall a. Data a => Data.Typeable.Internal.TypeRep [a]
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae5wk) ($dData_ae5wl [Occ=Once] :: Data a_ae5wk) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ []
                   @ a_ae5wk
                   Data.Data.$fData[]2
                   ((Data.Data.$p1Data @ a_ae5wk $dData_ae5wl)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae5wk>_N
                            :: (Typeable a_ae5wk :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep a_ae5wk :: *)))}]
Data.Data.$fData[]6
  = \ (@ a_ae5wk) ($dData_ae5wl :: Data a_ae5wk) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ []
        @ a_ae5wk
        Data.Data.$fData[]2
        ((Data.Data.$p1Data @ a_ae5wk $dData_ae5wl)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae5wk>_N
                 :: (Typeable a_ae5wk :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep a_ae5wk :: *)))

-- RHS size: {terms: 16, types: 41, coercions: 0, joins: 0/0}
Data.Data.$fDataPtr1 :: Data.Typeable.Internal.TypeRep Ptr
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataPtr1
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ Ptr
           13939499724423561315##
           16316673677148652216##
           GHC.Ptr.$trModule
           GHC.Ptr.$tcPtr1
           0#
           GHC.Types.krep$*Arr*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ Ptr
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 18, types: 44, coercions: 12, joins: 0/1}
Data.Data.$fDataPtr_$cdataCast1
  :: forall a.
     Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Ptr a))
[GblId,
 Arity=2,
 Str=<L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 100 60}]
Data.Data.$fDataPtr_$cdataCast1
  = \ (@ a_ae5t0)
      ($dData_ae5t1 :: Data a_ae5t0)
      (@ (t_ae5tJ :: * -> *))
      (@ (c_ae5tK :: * -> *))
      ($dTypeable_ae5tM :: Typeable t_ae5tJ) ->
      let {
        lvl270_se9yr :: Bool
        [LclId]
        lvl270_se9yr
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_ae5tJ
              @ Ptr
              ($dTypeable_ae5tM
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_ae5tJ>_N
                       :: (Typeable t_ae5tJ :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_ae5tJ :: *)))
              Data.Data.$fDataPtr1 } in
      \ (x_ae1U3 :: forall d. Data d => c_ae5tK (t_ae5tJ d)) ->
        case lvl270_se9yr of {
          False -> GHC.Base.Nothing @ (c_ae5tK (Ptr a_ae5t0));
          True ->
            GHC.Base.Just
              @ (c_ae5tK (Ptr a_ae5t0))
              ((x_ae1U3 @ a_ae5t0 $dData_ae5t1)
               `cast` (<c_ae5tK>_R (UnsafeCo nominal t_ae5tJ Ptr <a_ae5t0>_N)
                       :: (c_ae5tK (t_ae5tJ a_ae5t0) :: *)
                          ~R# (c_ae5tK (Ptr a_ae5t0) :: *)))
        }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataPtr6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 0}]
Data.Data.$fDataPtr6 = "Data.Data.toConstr(Ptr)"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataPtr5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataPtr5 = unpackCString# Data.Data.$fDataPtr6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataPtr8 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 0}]
Data.Data.$fDataPtr8 = "Data.Data.gunfold(Ptr)"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataPtr7 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataPtr7 = unpackCString# Data.Data.$fDataPtr8

-- RHS size: {terms: 6, types: 11, coercions: 4, joins: 0/0}
Data.Data.$fDataPtr9
  :: forall a. Data a => Data.Typeable.Internal.TypeRep (Ptr a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae5t0) ($dData_ae5t1 [Occ=Once] :: Data a_ae5t0) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Ptr
                   @ a_ae5t0
                   Data.Data.$fDataPtr1
                   ((Data.Data.$p1Data @ a_ae5t0 $dData_ae5t1)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae5t0>_N
                            :: (Typeable a_ae5t0 :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep a_ae5t0 :: *)))}]
Data.Data.$fDataPtr9
  = \ (@ a_ae5t0) ($dData_ae5t1 :: Data a_ae5t0) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ Ptr
        @ a_ae5t0
        Data.Data.$fDataPtr1
        ((Data.Data.$p1Data @ a_ae5t0 $dData_ae5t1)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae5t0>_N
                 :: (Typeable a_ae5t0 :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep a_ae5t0 :: *)))

-- RHS size: {terms: 16, types: 41, coercions: 0, joins: 0/0}
Data.Data.$fDataForeignPtr1
  :: Data.Typeable.Internal.TypeRep ForeignPtr
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataForeignPtr1
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ ForeignPtr
           13645276010227069957##
           424768606850180054##
           GHC.ForeignPtr.$trModule
           GHC.ForeignPtr.$tcForeignPtr1
           0#
           GHC.Types.krep$*Arr*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ ForeignPtr
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 18, types: 44, coercions: 12, joins: 0/1}
Data.Data.$fDataForeignPtr_$cdataCast1
  :: forall a.
     Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (ForeignPtr a))
[GblId,
 Arity=2,
 Str=<L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 100 60}]
Data.Data.$fDataForeignPtr_$cdataCast1
  = \ (@ a_ae5pG)
      ($dData_ae5pH :: Data a_ae5pG)
      (@ (t_ae5qp :: * -> *))
      (@ (c_ae5qq :: * -> *))
      ($dTypeable_ae5qs :: Typeable t_ae5qp) ->
      let {
        lvl270_se9yB :: Bool
        [LclId]
        lvl270_se9yB
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_ae5qp
              @ ForeignPtr
              ($dTypeable_ae5qs
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_ae5qp>_N
                       :: (Typeable t_ae5qp :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_ae5qp :: *)))
              Data.Data.$fDataForeignPtr1 } in
      \ (x_ae1U1 :: forall d. Data d => c_ae5qq (t_ae5qp d)) ->
        case lvl270_se9yB of {
          False -> GHC.Base.Nothing @ (c_ae5qq (ForeignPtr a_ae5pG));
          True ->
            GHC.Base.Just
              @ (c_ae5qq (ForeignPtr a_ae5pG))
              ((x_ae1U1 @ a_ae5pG $dData_ae5pH)
               `cast` (<c_ae5qq>_R (UnsafeCo nominal t_ae5qp ForeignPtr <a_ae5pG>_N)
                       :: (c_ae5qq (t_ae5qp a_ae5pG) :: *)
                          ~R# (c_ae5qq (ForeignPtr a_ae5pG) :: *)))
        }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataForeignPtr6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 90 0}]
Data.Data.$fDataForeignPtr6 = "Data.Data.toConstr(ForeignPtr)"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataForeignPtr5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataForeignPtr5
  = unpackCString# Data.Data.$fDataForeignPtr6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataForeignPtr8 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 90 0}]
Data.Data.$fDataForeignPtr8 = "Data.Data.gunfold(ForeignPtr)"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataForeignPtr7 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataForeignPtr7
  = unpackCString# Data.Data.$fDataForeignPtr8

-- RHS size: {terms: 6, types: 11, coercions: 4, joins: 0/0}
Data.Data.$fDataForeignPtr9
  :: forall a.
     Data a =>
     Data.Typeable.Internal.TypeRep (ForeignPtr a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae5pG) ($dData_ae5pH [Occ=Once] :: Data a_ae5pG) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ ForeignPtr
                   @ a_ae5pG
                   Data.Data.$fDataForeignPtr1
                   ((Data.Data.$p1Data @ a_ae5pG $dData_ae5pH)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae5pG>_N
                            :: (Typeable a_ae5pG :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep a_ae5pG :: *)))}]
Data.Data.$fDataForeignPtr9
  = \ (@ a_ae5pG) ($dData_ae5pH :: Data a_ae5pG) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ ForeignPtr
        @ a_ae5pG
        Data.Data.$fDataForeignPtr1
        ((Data.Data.$p1Data @ a_ae5pG $dData_ae5pH)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae5pG>_N
                 :: (Typeable a_ae5pG :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep a_ae5pG :: *)))

-- RHS size: {terms: 16, types: 49, coercions: 0, joins: 0/0}
Data.Data.$fDataArray2 :: Data.Typeable.Internal.TypeRep Array
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataArray2
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> * -> *)
           @ Array
           10788835947821237041##
           14169157647019398948##
           GHC.Arr.$trModule
           GHC.Arr.$tcArray1
           0#
           GHC.Types.krep$*->*->*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> * -> *)
      @ Array
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 22, types: 66, coercions: 15, joins: 0/1}
Data.Data.$fDataArray_$cdataCast2
  :: forall a b.
     (Data a, Data b, Ix a) =>
     forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e))
     -> Maybe (c (Array a b))
[GblId,
 Arity=4,
 Str=<L,U><L,U><L,A><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae5ml)
                 (@ b_ae5mm)
                 ($dData_ae5mn [Occ=OnceL] :: Data a_ae5ml)
                 ($dData1_ae5mo [Occ=OnceL] :: Data b_ae5mm)
                 _ [Occ=Dead]
                 (@ (t_ae5no :: * -> * -> *))
                 (@ (c_ae5np :: * -> *))
                 ($dTypeable_ae5nr [Occ=Once] :: Typeable t_ae5no) ->
                 let {
                   lvl270_se9yL [Occ=OnceL!] :: Bool
                   [LclId]
                   lvl270_se9yL
                     = Data.Typeable.Internal.sameTypeRep
                         @ (* -> * -> *)
                         @ (* -> * -> *)
                         @ t_ae5no
                         @ Array
                         ($dTypeable_ae5nr
                          `cast` (Data.Typeable.Internal.N:Typeable[0] <*
                                                                        -> * -> *>_N <t_ae5no>_N
                                  :: (Typeable t_ae5no :: Constraint)
                                     ~R# (Data.Typeable.Internal.TypeRep t_ae5no :: *)))
                         Data.Data.$fDataArray2 } in
                 \ (x_ae1TZ [Occ=Once!]
                      :: forall d e. (Data d, Data e) => c_ae5np (t_ae5no d e)) ->
                   case lvl270_se9yL of {
                     False -> GHC.Base.Nothing @ (c_ae5np (Array a_ae5ml b_ae5mm));
                     True ->
                       GHC.Base.Just
                         @ (c_ae5np (Array a_ae5ml b_ae5mm))
                         ((x_ae1TZ @ a_ae5ml @ b_ae5mm $dData_ae5mn $dData1_ae5mo)
                          `cast` (<c_ae5np>_R (UnsafeCo nominal t_ae5no Array <a_ae5ml>_N <b_ae5mm>_N)
                                  :: (c_ae5np (t_ae5no a_ae5ml b_ae5mm) :: *)
                                     ~R# (c_ae5np (Array a_ae5ml b_ae5mm) :: *)))
                   }}]
Data.Data.$fDataArray_$cdataCast2
  = \ (@ a_ae5ml)
      (@ b_ae5mm)
      ($dData_ae5mn :: Data a_ae5ml)
      ($dData1_ae5mo :: Data b_ae5mm)
      _ [Occ=Dead]
      (@ (t_ae5no :: * -> * -> *))
      (@ (c_ae5np :: * -> *))
      ($dTypeable_ae5nr :: Typeable t_ae5no) ->
      let {
        lvl270_se9yL :: Bool
        [LclId]
        lvl270_se9yL
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> * -> *)
              @ (* -> * -> *)
              @ t_ae5no
              @ Array
              ($dTypeable_ae5nr
               `cast` (Data.Typeable.Internal.N:Typeable[0] <*
                                                             -> * -> *>_N <t_ae5no>_N
                       :: (Typeable t_ae5no :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_ae5no :: *)))
              Data.Data.$fDataArray2 } in
      \ (x_ae1TZ
           :: forall d e. (Data d, Data e) => c_ae5np (t_ae5no d e)) ->
        case lvl270_se9yL of {
          False -> GHC.Base.Nothing @ (c_ae5np (Array a_ae5ml b_ae5mm));
          True ->
            GHC.Base.Just
              @ (c_ae5np (Array a_ae5ml b_ae5mm))
              ((x_ae1TZ @ a_ae5ml @ b_ae5mm $dData_ae5mn $dData1_ae5mo)
               `cast` (<c_ae5np>_R (UnsafeCo nominal t_ae5no Array <a_ae5ml>_N <b_ae5mm>_N)
                       :: (c_ae5np (t_ae5no a_ae5ml b_ae5mm) :: *)
                          ~R# (c_ae5np (Array a_ae5ml b_ae5mm) :: *)))
        }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataArray7 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 80 0}]
Data.Data.$fDataArray7 = "Data.Data.toConstr(Array)"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataArray6 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataArray6 = unpackCString# Data.Data.$fDataArray7

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataArray9 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 0}]
Data.Data.$fDataArray9 = "Data.Data.gunfold(Array)"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataArray8 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataArray8 = unpackCString# Data.Data.$fDataArray9

-- RHS size: {terms: 12, types: 27, coercions: 8, joins: 0/0}
Data.Data.$fDataArray10
  :: forall a b.
     (Data a, Data b, Ix a) =>
     Data.Typeable.Internal.TypeRep (Array a b)
[GblId,
 Arity=3,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae5ml)
                 (@ b_ae5mm)
                 ($dData_ae5mn [Occ=Once] :: Data a_ae5ml)
                 ($dData1_ae5mo [Occ=Once] :: Data b_ae5mm)
                 _ [Occ=Dead] ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ (Array a_ae5ml)
                   @ b_ae5mm
                   (Data.Typeable.Internal.mkTrApp
                      @ *
                      @ (* -> *)
                      @ Array
                      @ a_ae5ml
                      Data.Data.$fDataArray2
                      ((Data.Data.$p1Data @ a_ae5ml $dData_ae5mn)
                       `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae5ml>_N
                               :: (Typeable a_ae5ml :: Constraint)
                                  ~R# (Data.Typeable.Internal.TypeRep a_ae5ml :: *))))
                   ((Data.Data.$p1Data @ b_ae5mm $dData1_ae5mo)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <b_ae5mm>_N
                            :: (Typeable b_ae5mm :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep b_ae5mm :: *)))}]
Data.Data.$fDataArray10
  = \ (@ a_ae5ml)
      (@ b_ae5mm)
      ($dData_ae5mn :: Data a_ae5ml)
      ($dData1_ae5mo :: Data b_ae5mm)
      _ [Occ=Dead] ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ (Array a_ae5ml)
        @ b_ae5mm
        (Data.Typeable.Internal.mkTrApp
           @ *
           @ (* -> *)
           @ Array
           @ a_ae5ml
           Data.Data.$fDataArray2
           ((Data.Data.$p1Data @ a_ae5ml $dData_ae5mn)
            `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae5ml>_N
                    :: (Typeable a_ae5ml :: Constraint)
                       ~R# (Data.Typeable.Internal.TypeRep a_ae5ml :: *))))
        ((Data.Data.$p1Data @ b_ae5mm $dData1_ae5mo)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <b_ae5mm>_N
                 :: (Typeable b_ae5mm :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep b_ae5mm :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fShowFixity5 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fShowFixity5 = "Prefix"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fShowFixity4 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fShowFixity4 = unpackCString# Data.Data.$fShowFixity5

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fShowFixity3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fShowFixity3 = "Infix"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fShowFixity2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fShowFixity2 = unpackCString# Data.Data.$fShowFixity3

-- RHS size: {terms: 13, types: 6, coercions: 0, joins: 0/0}
Data.Data.$fShowFixity_$cshowsPrec :: Int -> Fixity -> ShowS
[GblId,
 Arity=3,
 Str=<L,A><S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ _ [Occ=Dead]
                 (ds1_de7Fx [Occ=Once!] :: Fixity)
                 (eta_B1 [Occ=Once*] :: String) ->
                 case ds1_de7Fx of {
                   Prefix ->
                     augment
                       @ Char
                       (\ (@ b_i7JbU)
                          (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                          (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                          foldr @ Char @ b_i7JbU c_i7JbV n_i7JbW Data.Data.$fShowFixity4)
                       eta_B1;
                   Infix ->
                     augment
                       @ Char
                       (\ (@ b_i7JbU)
                          (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                          (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                          foldr @ Char @ b_i7JbU c_i7JbV n_i7JbW Data.Data.$fShowFixity2)
                       eta_B1
                 }}]
Data.Data.$fShowFixity_$cshowsPrec
  = \ _ [Occ=Dead] (ds1_de7Fx :: Fixity) (eta_B1 :: String) ->
      case ds1_de7Fx of {
        Prefix -> ++ @ Char Data.Data.$fShowFixity4 eta_B1;
        Infix -> ++ @ Char Data.Data.$fShowFixity2 eta_B1
      }

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fShowFixity_$cshow :: Fixity -> String
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i7Jay [Occ=Once!] :: Fixity) ->
                 case x_i7Jay of {
                   Prefix -> Data.Data.$fShowFixity4;
                   Infix -> Data.Data.$fShowFixity2
                 }}]
Data.Data.$fShowFixity_$cshow
  = \ (x_i7Jay :: Fixity) ->
      case x_i7Jay of {
        Prefix -> Data.Data.$fShowFixity4;
        Infix -> Data.Data.$fShowFixity2
      }

-- RHS size: {terms: 12, types: 5, coercions: 0, joins: 0/0}
Data.Data.$fShowFixity1 :: Fixity -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_de7Fx [Occ=Once!] :: Fixity)
                 (eta_B1 [Occ=Once*] :: String) ->
                 case ds_de7Fx of {
                   Prefix ->
                     augment
                       @ Char
                       (\ (@ b_i7JbU)
                          (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                          (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                          foldr @ Char @ b_i7JbU c_i7JbV n_i7JbW Data.Data.$fShowFixity4)
                       eta_B1;
                   Infix ->
                     augment
                       @ Char
                       (\ (@ b_i7JbU)
                          (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                          (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                          foldr @ Char @ b_i7JbU c_i7JbV n_i7JbW Data.Data.$fShowFixity2)
                       eta_B1
                 }}]
Data.Data.$fShowFixity1
  = \ (ds_de7Fx :: Fixity) (eta_B1 :: String) ->
      case ds_de7Fx of {
        Prefix -> ++ @ Char Data.Data.$fShowFixity4 eta_B1;
        Infix -> ++ @ Char Data.Data.$fShowFixity2 eta_B1
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
Data.Data.$fShowFixity_$cshowList :: [Fixity] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [Fixity])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__ @ Fixity Data.Data.$fShowFixity1 ls_i7JaB s_i7JaC}]
Data.Data.$fShowFixity_$cshowList
  = \ (ls_i7JaB :: [Fixity]) (s_i7JaC :: String) ->
      showList__ @ Fixity Data.Data.$fShowFixity1 ls_i7JaB s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fShowFixity [InlPrag=NOUSERINLINE CONLIKE]
  :: Show Fixity
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: Fixity
                       Data.Data.$fShowFixity_$cshowsPrec
                       Data.Data.$fShowFixity_$cshow
                       Data.Data.$fShowFixity_$cshowList]
Data.Data.$fShowFixity
  = GHC.Show.C:Show
      @ Fixity
      Data.Data.$fShowFixity_$cshowsPrec
      Data.Data.$fShowFixity_$cshow
      Data.Data.$fShowFixity_$cshowList

-- RHS size: {terms: 18, types: 5, coercions: 0, joins: 0/0}
Data.Data.$fEqFixity_$c== :: Fixity -> Fixity -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_de7Fs [Occ=Once!] :: Fixity)
                 (ds1_de7Ft [Occ=Once*!] :: Fixity) ->
                 case ds_de7Fs of {
                   Prefix ->
                     case ds1_de7Ft of {
                       Prefix -> GHC.Types.True;
                       Infix -> GHC.Types.False
                     };
                   Infix ->
                     case ds1_de7Ft of {
                       Prefix -> GHC.Types.False;
                       Infix -> GHC.Types.True
                     }
                 }}]
Data.Data.$fEqFixity_$c==
  = \ (ds_de7Fs :: Fixity) (ds1_de7Ft :: Fixity) ->
      case ds_de7Fs of {
        Prefix ->
          case ds1_de7Ft of {
            Prefix -> GHC.Types.True;
            Infix -> GHC.Types.False
          };
        Infix ->
          case ds1_de7Ft of {
            Prefix -> GHC.Types.False;
            Infix -> GHC.Types.True
          }
      }

-- RHS size: {terms: 18, types: 5, coercions: 0, joins: 0/0}
Data.Data.$fEqFixity_$c/= [InlPrag=INLINE (sat-args=2)]
  :: Fixity -> Fixity -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a22b [Occ=Once!] :: Fixity)
                 (y_a22c [Occ=Once*!] :: Fixity) ->
                 case x_a22b of {
                   Prefix ->
                     case y_a22c of {
                       Prefix -> GHC.Types.False;
                       Infix -> GHC.Types.True
                     };
                   Infix ->
                     case y_a22c of {
                       Prefix -> GHC.Types.True;
                       Infix -> GHC.Types.False
                     }
                 }}]
Data.Data.$fEqFixity_$c/=
  = \ (eta_B2 :: Fixity) (eta1_B1 :: Fixity) ->
      case eta_B2 of {
        Prefix ->
          case eta1_B1 of {
            Prefix -> GHC.Types.False;
            Infix -> GHC.Types.True
          };
        Infix ->
          case eta1_B1 of {
            Prefix -> GHC.Types.True;
            Infix -> GHC.Types.False
          }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fEqFixity [InlPrag=NOUSERINLINE CONLIKE] :: Eq Fixity
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: Fixity
                        Data.Data.$fEqFixity_$c==
                        Data.Data.$fEqFixity_$c/=]
Data.Data.$fEqFixity
  = GHC.Classes.C:Eq
      @ Fixity Data.Data.$fEqFixity_$c== Data.Data.$fEqFixity_$c/=

-- RHS size: {terms: 12, types: 25, coercions: 0, joins: 0/0}
Data.Data.$fDataBool_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Bool -> c Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_ae5gF :: * -> *))
                 _ [Occ=Dead]
                 (z_ae2qV [Occ=Once*!] :: forall g. g -> c_ae5gF g)
                 (ds_de7F0 [Occ=Once!] :: Bool) ->
                 case ds_de7F0 of {
                   False -> z_ae2qV @ Bool GHC.Types.False;
                   True -> z_ae2qV @ Bool GHC.Types.True
                 }}]
Data.Data.$fDataBool_$cgfoldl
  = \ (@ (c_ae5gF :: * -> *))
      _ [Occ=Dead]
      (z_ae2qV :: forall g. g -> c_ae5gF g)
      (ds_de7F0 :: Bool) ->
      case ds_de7F0 of {
        False -> z_ae2qV @ Bool GHC.Types.False;
        True -> z_ae2qV @ Bool GHC.Types.True
      }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataBool5 :: Data.Typeable.Internal.TypeRep Bool
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataBool5
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Bool
           14182099612280475667##
           2734577064602454082##
           GHC.Types.$trModule
           GHC.Types.$tcBool1
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ Bool ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 16, types: 41, coercions: 0, joins: 0/0}
Data.Data.$fDataNonEmpty2
  :: Data.Typeable.Internal.TypeRep NonEmpty
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataNonEmpty2
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ NonEmpty
           13207016872645468285##
           3455542966739695982##
           GHC.Base.$trModule
           GHC.Base.$tcNonEmpty1
           0#
           GHC.Types.krep$*Arr*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ NonEmpty
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 18, types: 44, coercions: 12, joins: 0/1}
Data.Data.$fDataNonEmpty_$cdataCast1
  :: forall a.
     Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (NonEmpty a))
[GblId,
 Arity=2,
 Str=<L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 100 60}]
Data.Data.$fDataNonEmpty_$cdataCast1
  = \ (@ a_ae5de)
      ($dData_ae5df :: Data a_ae5de)
      (@ (t_ae5dX :: * -> *))
      (@ (c_ae5dY :: * -> *))
      ($dTypeable_ae5e0 :: Typeable t_ae5dX) ->
      let {
        lvl270_se9zd :: Bool
        [LclId]
        lvl270_se9zd
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_ae5dX
              @ NonEmpty
              ($dTypeable_ae5e0
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_ae5dX>_N
                       :: (Typeable t_ae5dX :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_ae5dX :: *)))
              Data.Data.$fDataNonEmpty2 } in
      \ (f_ae2qT :: forall d. Data d => c_ae5dY (t_ae5dX d)) ->
        case lvl270_se9zd of {
          False -> GHC.Base.Nothing @ (c_ae5dY (NonEmpty a_ae5de));
          True ->
            GHC.Base.Just
              @ (c_ae5dY (NonEmpty a_ae5de))
              ((f_ae2qT @ a_ae5de $dData_ae5df)
               `cast` (<c_ae5dY>_R (UnsafeCo nominal t_ae5dX NonEmpty <a_ae5de>_N)
                       :: (c_ae5dY (t_ae5dX a_ae5de) :: *)
                          ~R# (c_ae5dY (NonEmpty a_ae5de) :: *)))
        }

-- RHS size: {terms: 6, types: 11, coercions: 4, joins: 0/0}
Data.Data.$fDataNonEmpty7
  :: forall a. Data a => Data.Typeable.Internal.TypeRep (NonEmpty a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae5de) ($dData_ae5df [Occ=Once] :: Data a_ae5de) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ NonEmpty
                   @ a_ae5de
                   Data.Data.$fDataNonEmpty2
                   ((Data.Data.$p1Data @ a_ae5de $dData_ae5df)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae5de>_N
                            :: (Typeable a_ae5de :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep a_ae5de :: *)))}]
Data.Data.$fDataNonEmpty7
  = \ (@ a_ae5de) ($dData_ae5df :: Data a_ae5de) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ NonEmpty
        @ a_ae5de
        Data.Data.$fDataNonEmpty2
        ((Data.Data.$p1Data @ a_ae5de $dData_ae5df)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae5de>_N
                 :: (Typeable a_ae5de :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep a_ae5de :: *)))

-- RHS size: {terms: 16, types: 41, coercions: 0, joins: 0/0}
Data.Data.$fDataMaybe5 :: Data.Typeable.Internal.TypeRep Maybe
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataMaybe5
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ Maybe
           625655543500963593##
           6391758309165051762##
           GHC.Base.$trModule
           GHC.Base.$tcMaybe1
           0#
           GHC.Types.krep$*Arr*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ Maybe
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 18, types: 44, coercions: 12, joins: 0/1}
Data.Data.$fDataMaybe_$cdataCast1
  :: forall a.
     Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Maybe a))
[GblId,
 Arity=2,
 Str=<L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 100 60}]
Data.Data.$fDataMaybe_$cdataCast1
  = \ (@ a_ae59U)
      ($dData_ae59V :: Data a_ae59U)
      (@ (t_ae5aD :: * -> *))
      (@ (c_ae5aE :: * -> *))
      ($dTypeable_ae5aG :: Typeable t_ae5aD) ->
      let {
        lvl270_se9zh :: Bool
        [LclId]
        lvl270_se9zh
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_ae5aD
              @ Maybe
              ($dTypeable_ae5aG
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_ae5aD>_N
                       :: (Typeable t_ae5aD :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_ae5aD :: *)))
              Data.Data.$fDataMaybe5 } in
      \ (f_ae2qM :: forall d. Data d => c_ae5aE (t_ae5aD d)) ->
        case lvl270_se9zh of {
          False -> GHC.Base.Nothing @ (c_ae5aE (Maybe a_ae59U));
          True ->
            GHC.Base.Just
              @ (c_ae5aE (Maybe a_ae59U))
              ((f_ae2qM @ a_ae59U $dData_ae59V)
               `cast` (<c_ae5aE>_R (UnsafeCo nominal t_ae5aD Maybe <a_ae59U>_N)
                       :: (c_ae5aE (t_ae5aD a_ae59U) :: *)
                          ~R# (c_ae5aE (Maybe a_ae59U) :: *)))
        }

-- RHS size: {terms: 17, types: 40, coercions: 0, joins: 0/0}
Data.Data.$fDataMaybe_$cgfoldl
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Maybe a -> c (Maybe a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae59U)
                 ($dData_ae59V [Occ=Once] :: Data a_ae59U)
                 (@ (c_ae5a3 :: * -> *))
                 (k_ae2qE [Occ=Once!]
                    :: forall d b. Data d => c_ae5a3 (d -> b) -> d -> c_ae5a3 b)
                 (z_ae2qF [Occ=Once*!] :: forall g. g -> c_ae5a3 g)
                 (ds_de7Ej [Occ=Once!] :: Maybe a_ae59U) ->
                 case ds_de7Ej of {
                   Nothing -> z_ae2qF @ (Maybe a_ae59U) (GHC.Base.Nothing @ a_ae59U);
                   Just a1_ae2qI [Occ=Once] ->
                     k_ae2qE
                       @ a_ae59U
                       @ (Maybe a_ae59U)
                       $dData_ae59V
                       (z_ae2qF @ (a_ae59U -> Maybe a_ae59U) (GHC.Base.Just @ a_ae59U))
                       a1_ae2qI
                 }}]
Data.Data.$fDataMaybe_$cgfoldl
  = \ (@ a_ae59U)
      ($dData_ae59V :: Data a_ae59U)
      (@ (c_ae5a3 :: * -> *))
      (k_ae2qE
         :: forall d b. Data d => c_ae5a3 (d -> b) -> d -> c_ae5a3 b)
      (z_ae2qF :: forall g. g -> c_ae5a3 g)
      (ds_de7Ej :: Maybe a_ae59U) ->
      case ds_de7Ej of {
        Nothing -> z_ae2qF @ (Maybe a_ae59U) (GHC.Base.Nothing @ a_ae59U);
        Just a1_ae2qI ->
          k_ae2qE
            @ a_ae59U
            @ (Maybe a_ae59U)
            $dData_ae59V
            (z_ae2qF @ (a_ae59U -> Maybe a_ae59U) (GHC.Base.Just @ a_ae59U))
            a1_ae2qI
      }

-- RHS size: {terms: 6, types: 11, coercions: 4, joins: 0/0}
Data.Data.$fDataMaybe6
  :: forall a. Data a => Data.Typeable.Internal.TypeRep (Maybe a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae59U) ($dData_ae59V [Occ=Once] :: Data a_ae59U) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Maybe
                   @ a_ae59U
                   Data.Data.$fDataMaybe5
                   ((Data.Data.$p1Data @ a_ae59U $dData_ae59V)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae59U>_N
                            :: (Typeable a_ae59U :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep a_ae59U :: *)))}]
Data.Data.$fDataMaybe6
  = \ (@ a_ae59U) ($dData_ae59V :: Data a_ae59U) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ Maybe
        @ a_ae59U
        Data.Data.$fDataMaybe5
        ((Data.Data.$p1Data @ a_ae59U $dData_ae59V)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae59U>_N
                 :: (Typeable a_ae59U :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep a_ae59U :: *)))

-- RHS size: {terms: 15, types: 26, coercions: 0, joins: 0/0}
Data.Data.$fDataOrdering_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Ordering -> c Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_ae56S :: * -> *))
                 _ [Occ=Dead]
                 (z_ae2qw [Occ=Once*!] :: forall g. g -> c_ae56S g)
                 (ds_de7DW [Occ=Once!] :: Ordering) ->
                 case ds_de7DW of {
                   LT -> z_ae2qw @ Ordering GHC.Types.LT;
                   EQ -> z_ae2qw @ Ordering GHC.Types.EQ;
                   GT -> z_ae2qw @ Ordering GHC.Types.GT
                 }}]
Data.Data.$fDataOrdering_$cgfoldl
  = \ (@ (c_ae56S :: * -> *))
      _ [Occ=Dead]
      (z_ae2qw :: forall g. g -> c_ae56S g)
      (ds_de7DW :: Ordering) ->
      case ds_de7DW of {
        LT -> z_ae2qw @ Ordering GHC.Types.LT;
        EQ -> z_ae2qw @ Ordering GHC.Types.EQ;
        GT -> z_ae2qw @ Ordering GHC.Types.GT
      }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataOrdering6
  :: Data.Typeable.Internal.TypeRep Ordering
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataOrdering6
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Ordering
           11418063759305334995##
           298511964381165782##
           GHC.Types.$trModule
           GHC.Types.$tcOrdering1
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ Ordering ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 16, types: 49, coercions: 0, joins: 0/0}
Data.Data.$fDataEither5 :: Data.Typeable.Internal.TypeRep Either
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataEither5
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> * -> *)
           @ Either
           16074290893719807138##
           14958199358864670905##
           Data.Either.$trModule
           Data.Either.$tcEither1
           0#
           GHC.Types.krep$*->*->*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> * -> *)
      @ Either
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 21, types: 64, coercions: 15, joins: 0/1}
Data.Data.$fDataEither_$cdataCast2
  :: forall a b.
     (Data a, Data b) =>
     forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e))
     -> Maybe (c (Either a b))
[GblId,
 Arity=3,
 Str=<L,U><L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 110 60}]
Data.Data.$fDataEither_$cdataCast2
  = \ (@ a_ae53f)
      (@ b_ae53g)
      ($dData_ae53h :: Data a_ae53f)
      ($dData1_ae53i :: Data b_ae53g)
      (@ (t_ae54t :: * -> * -> *))
      (@ (c_ae54u :: * -> *))
      ($dTypeable_ae54w :: Typeable t_ae54t) ->
      let {
        lvl270_se9zl :: Bool
        [LclId]
        lvl270_se9zl
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> * -> *)
              @ (* -> * -> *)
              @ t_ae54t
              @ Either
              ($dTypeable_ae54w
               `cast` (Data.Typeable.Internal.N:Typeable[0] <*
                                                             -> * -> *>_N <t_ae54t>_N
                       :: (Typeable t_ae54t :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_ae54t :: *)))
              Data.Data.$fDataEither5 } in
      \ (f_ae2qu
           :: forall d e. (Data d, Data e) => c_ae54u (t_ae54t d e)) ->
        case lvl270_se9zl of {
          False -> GHC.Base.Nothing @ (c_ae54u (Either a_ae53f b_ae53g));
          True ->
            GHC.Base.Just
              @ (c_ae54u (Either a_ae53f b_ae53g))
              ((f_ae2qu @ a_ae53f @ b_ae53g $dData_ae53h $dData1_ae53i)
               `cast` (<c_ae54u>_R (UnsafeCo nominal t_ae54t Either <a_ae53f>_N <b_ae53g>_N)
                       :: (c_ae54u (t_ae54t a_ae53f b_ae53g) :: *)
                          ~R# (c_ae54u (Either a_ae53f b_ae53g) :: *)))
        }

-- RHS size: {terms: 22, types: 57, coercions: 0, joins: 0/0}
Data.Data.$fDataEither_$cgfoldl
  :: forall a b.
     (Data a, Data b) =>
     forall (c :: * -> *).
     (forall d b1. Data d => c (d -> b1) -> d -> c b1)
     -> (forall g. g -> c g) -> Either a b -> c (Either a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 120 120 90] 140 0}]
Data.Data.$fDataEither_$cgfoldl
  = \ (@ a_ae53f)
      (@ b_ae53g)
      ($dData_ae53h :: Data a_ae53f)
      ($dData1_ae53i :: Data b_ae53g)
      (@ (c_ae53q :: * -> *))
      (k_ae2ql
         :: forall d b1. Data d => c_ae53q (d -> b1) -> d -> c_ae53q b1)
      (z_ae2qm :: forall g. g -> c_ae53q g)
      (ds_de7Dy :: Either a_ae53f b_ae53g) ->
      case ds_de7Dy of {
        Left a1_ae2qn ->
          k_ae2ql
            @ a_ae53f
            @ (Either a_ae53f b_ae53g)
            $dData_ae53h
            (z_ae2qm
               @ (a_ae53f -> Either a_ae53f b_ae53g)
               (Data.Either.Left @ a_ae53f @ b_ae53g))
            a1_ae2qn;
        Right a1_ae2qq ->
          k_ae2ql
            @ b_ae53g
            @ (Either a_ae53f b_ae53g)
            $dData1_ae53i
            (z_ae2qm
               @ (b_ae53g -> Either a_ae53f b_ae53g)
               (Data.Either.Right @ a_ae53f @ b_ae53g))
            a1_ae2qq
      }

-- RHS size: {terms: 11, types: 25, coercions: 8, joins: 0/0}
Data.Data.$fDataEither6
  :: forall a b.
     (Data a, Data b) =>
     Data.Typeable.Internal.TypeRep (Either a b)
[GblId,
 Arity=2,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30] 100 0}]
Data.Data.$fDataEither6
  = \ (@ a_ae53f)
      (@ b_ae53g)
      ($dData_ae53h :: Data a_ae53f)
      ($dData1_ae53i :: Data b_ae53g) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ (Either a_ae53f)
        @ b_ae53g
        (Data.Typeable.Internal.mkTrApp
           @ *
           @ (* -> *)
           @ Either
           @ a_ae53f
           Data.Data.$fDataEither5
           ((Data.Data.$p1Data @ a_ae53f $dData_ae53h)
            `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae53f>_N
                    :: (Typeable a_ae53f :: Constraint)
                       ~R# (Data.Typeable.Internal.TypeRep a_ae53f :: *))))
        ((Data.Data.$p1Data @ b_ae53g $dData1_ae53i)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <b_ae53g>_N
                 :: (Typeable b_ae53g :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep b_ae53g :: *)))

-- RHS size: {terms: 6, types: 22, coercions: 0, joins: 0/0}
Data.Data.$fData()_$cgunfold
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (c_ae50p :: * -> *))
                 _ [Occ=Dead]
                 (z_ae2qk [Occ=Once!] :: forall r. r -> c_ae50p r)
                 _ [Occ=Dead] ->
                 z_ae2qk @ () GHC.Tuple.()}]
Data.Data.$fData()_$cgunfold
  = \ (@ (c_ae50p :: * -> *))
      _ [Occ=Dead]
      (z_ae2qk :: forall r. r -> c_ae50p r)
      _ [Occ=Dead] ->
      z_ae2qk @ () GHC.Tuple.()

-- RHS size: {terms: 9, types: 24, coercions: 0, joins: 0/0}
Data.Data.$fData()_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> () -> c ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_ae50j :: * -> *))
                 _ [Occ=Dead]
                 (z_ae2qi [Occ=Once!] :: forall g. g -> c_ae50j g)
                 (ds_de7Df [Occ=Once!] :: ()) ->
                 case ds_de7Df of { () -> z_ae2qi @ () GHC.Tuple.() }}]
Data.Data.$fData()_$cgfoldl
  = \ (@ (c_ae50j :: * -> *))
      _ [Occ=Dead]
      (z_ae2qi :: forall g. g -> c_ae50j g)
      (ds_de7Df :: ()) ->
      case ds_de7Df of { () -> z_ae2qi @ () GHC.Tuple.() }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fData()8 :: Data.Typeable.Internal.TypeRep ()
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fData()8
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ ()
           2684808367141291271##
           14290630168515401665##
           GHC.Tuple.$trModule
           GHC.Tuple.$tc()1
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ () ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 16, types: 49, coercions: 0, joins: 0/0}
Data.Data.$fData(,)4 :: Data.Typeable.Internal.TypeRep (,)
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fData(,)4
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> * -> *)
           @ (,)
           3966139188614386852##
           2108306554504130472##
           GHC.Tuple.$trModule
           GHC.Tuple.$tc(,)1
           0#
           GHC.Types.krep$*->*->*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> * -> *)
      @ (,)
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 21, types: 64, coercions: 15, joins: 0/1}
Data.Data.$fData(,)_$cdataCast2
  :: forall a b.
     (Data a, Data b) =>
     forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c (a, b))
[GblId,
 Arity=3,
 Str=<L,U><L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 110 60}]
Data.Data.$fData(,)_$cdataCast2
  = \ (@ a_ae4WF)
      (@ b_ae4WG)
      ($dData_ae4WH :: Data a_ae4WF)
      ($dData1_ae4WI :: Data b_ae4WG)
      (@ (t_ae4XL :: * -> * -> *))
      (@ (c_ae4XM :: * -> *))
      ($dTypeable_ae4XO :: Typeable t_ae4XL) ->
      let {
        lvl270_se9zp :: Bool
        [LclId]
        lvl270_se9zp
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> * -> *)
              @ (* -> * -> *)
              @ t_ae4XL
              @ (,)
              ($dTypeable_ae4XO
               `cast` (Data.Typeable.Internal.N:Typeable[0] <*
                                                             -> * -> *>_N <t_ae4XL>_N
                       :: (Typeable t_ae4XL :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_ae4XL :: *)))
              Data.Data.$fData(,)4 } in
      \ (f_ae2qg
           :: forall d e. (Data d, Data e) => c_ae4XM (t_ae4XL d e)) ->
        case lvl270_se9zp of {
          False -> GHC.Base.Nothing @ (c_ae4XM (a_ae4WF, b_ae4WG));
          True ->
            GHC.Base.Just
              @ (c_ae4XM (a_ae4WF, b_ae4WG))
              ((f_ae2qg @ a_ae4WF @ b_ae4WG $dData_ae4WH $dData1_ae4WI)
               `cast` (<c_ae4XM>_R (UnsafeCo nominal t_ae4XL (,) <a_ae4WF>_N <b_ae4WG>_N)
                       :: (c_ae4XM (t_ae4XL a_ae4WF b_ae4WG) :: *)
                          ~R# (c_ae4XM (a_ae4WF, b_ae4WG) :: *)))
        }

-- RHS size: {terms: 14, types: 45, coercions: 0, joins: 0/0}
Data.Data.$fData(,)_$cgunfold
  :: forall a b.
     (Data a, Data b) =>
     forall (c :: * -> *).
     (forall b1 r. Data b1 => c (b1 -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c (a, b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae4WF)
                 (@ b_ae4WG)
                 ($dData_ae4WH [Occ=Once] :: Data a_ae4WF)
                 ($dData1_ae4WI [Occ=Once] :: Data b_ae4WG)
                 (@ (c_ae4X5 :: * -> *))
                 (k_ae2qe :: forall b1 r. Data b1 => c_ae4X5 (b1 -> r) -> c_ae4X5 r)
                 (z_ae2qf [Occ=Once!] :: forall r. r -> c_ae4X5 r)
                 _ [Occ=Dead] ->
                 k_ae2qe
                   @ b_ae4WG
                   @ (a_ae4WF, b_ae4WG)
                   $dData1_ae4WI
                   (k_ae2qe
                      @ a_ae4WF
                      @ (b_ae4WG -> (a_ae4WF, b_ae4WG))
                      $dData_ae4WH
                      (z_ae2qf
                         @ (a_ae4WF -> b_ae4WG -> (a_ae4WF, b_ae4WG))
                         (GHC.Tuple.(,) @ a_ae4WF @ b_ae4WG)))}]
Data.Data.$fData(,)_$cgunfold
  = \ (@ a_ae4WF)
      (@ b_ae4WG)
      ($dData_ae4WH :: Data a_ae4WF)
      ($dData1_ae4WI :: Data b_ae4WG)
      (@ (c_ae4X5 :: * -> *))
      (k_ae2qe :: forall b1 r. Data b1 => c_ae4X5 (b1 -> r) -> c_ae4X5 r)
      (z_ae2qf :: forall r. r -> c_ae4X5 r)
      _ [Occ=Dead] ->
      k_ae2qe
        @ b_ae4WG
        @ (a_ae4WF, b_ae4WG)
        $dData1_ae4WI
        (k_ae2qe
           @ a_ae4WF
           @ (b_ae4WG -> (a_ae4WF, b_ae4WG))
           $dData_ae4WH
           (z_ae2qf
              @ (a_ae4WF -> b_ae4WG -> (a_ae4WF, b_ae4WG))
              (GHC.Tuple.(,) @ a_ae4WF @ b_ae4WG)))

-- RHS size: {terms: 19, types: 53, coercions: 0, joins: 0/0}
Data.Data.$fData(,)_$cgfoldl
  :: forall a b.
     (Data a, Data b) =>
     forall (c :: * -> *).
     (forall d b1. Data d => c (d -> b1) -> d -> c b1)
     -> (forall g. g -> c g) -> (a, b) -> c (a, b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae4WF)
                 (@ b_ae4WG)
                 ($dData_ae4WH [Occ=Once] :: Data a_ae4WF)
                 ($dData1_ae4WI [Occ=Once] :: Data b_ae4WG)
                 (@ (c_ae4WQ :: * -> *))
                 (k_ae2qa
                    :: forall d b1. Data d => c_ae4WQ (d -> b1) -> d -> c_ae4WQ b1)
                 (z_ae2qb [Occ=Once!] :: forall g. g -> c_ae4WQ g)
                 (ds_de7CG [Occ=Once!] :: (a_ae4WF, b_ae4WG)) ->
                 case ds_de7CG of { (a1_ae2qc [Occ=Once], a2_ae2qd [Occ=Once]) ->
                 k_ae2qa
                   @ b_ae4WG
                   @ (a_ae4WF, b_ae4WG)
                   $dData1_ae4WI
                   (k_ae2qa
                      @ a_ae4WF
                      @ (b_ae4WG -> (a_ae4WF, b_ae4WG))
                      $dData_ae4WH
                      (z_ae2qb
                         @ (a_ae4WF -> b_ae4WG -> (a_ae4WF, b_ae4WG))
                         (GHC.Tuple.(,) @ a_ae4WF @ b_ae4WG))
                      a1_ae2qc)
                   a2_ae2qd
                 }}]
Data.Data.$fData(,)_$cgfoldl
  = \ (@ a_ae4WF)
      (@ b_ae4WG)
      ($dData_ae4WH :: Data a_ae4WF)
      ($dData1_ae4WI :: Data b_ae4WG)
      (@ (c_ae4WQ :: * -> *))
      (k_ae2qa
         :: forall d b1. Data d => c_ae4WQ (d -> b1) -> d -> c_ae4WQ b1)
      (z_ae2qb :: forall g. g -> c_ae4WQ g)
      (ds_de7CG :: (a_ae4WF, b_ae4WG)) ->
      case ds_de7CG of { (a1_ae2qc, a2_ae2qd) ->
      k_ae2qa
        @ b_ae4WG
        @ (a_ae4WF, b_ae4WG)
        $dData1_ae4WI
        (k_ae2qa
           @ a_ae4WF
           @ (b_ae4WG -> (a_ae4WF, b_ae4WG))
           $dData_ae4WH
           (z_ae2qb
              @ (a_ae4WF -> b_ae4WG -> (a_ae4WF, b_ae4WG))
              (GHC.Tuple.(,) @ a_ae4WF @ b_ae4WG))
           a1_ae2qc)
        a2_ae2qd
      }

-- RHS size: {terms: 11, types: 25, coercions: 8, joins: 0/0}
Data.Data.$fData(,)9
  :: forall a b.
     (Data a, Data b) =>
     Data.Typeable.Internal.TypeRep (a, b)
[GblId,
 Arity=2,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30] 100 0}]
Data.Data.$fData(,)9
  = \ (@ a_ae4WF)
      (@ b_ae4WG)
      ($dData_ae4WH :: Data a_ae4WF)
      ($dData1_ae4WI :: Data b_ae4WG) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ ((,) a_ae4WF)
        @ b_ae4WG
        (Data.Typeable.Internal.mkTrApp
           @ *
           @ (* -> *)
           @ (,)
           @ a_ae4WF
           Data.Data.$fData(,)4
           ((Data.Data.$p1Data @ a_ae4WF $dData_ae4WH)
            `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae4WF>_N
                    :: (Typeable a_ae4WF :: Constraint)
                       ~R# (Data.Typeable.Internal.TypeRep a_ae4WF :: *))))
        ((Data.Data.$p1Data @ b_ae4WG $dData1_ae4WI)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <b_ae4WG>_N
                 :: (Typeable b_ae4WG :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep b_ae4WG :: *)))

-- RHS size: {terms: 18, types: 61, coercions: 0, joins: 0/0}
Data.Data.$fData(,,)_$cgunfold
  :: forall a b c.
     (Data a, Data b, Data c) =>
     forall (c1 :: * -> *).
     (forall b1 r. Data b1 => c1 (b1 -> r) -> c1 r)
     -> (forall r. r -> c1 r) -> Constr -> c1 (a, b, c)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae4T6)
                 (@ b_ae4T7)
                 (@ c_ae4T8)
                 ($dData_ae4T9 [Occ=Once] :: Data a_ae4T6)
                 ($dData1_ae4Ta [Occ=Once] :: Data b_ae4T7)
                 ($dData2_ae4Tb [Occ=Once] :: Data c_ae4T8)
                 (@ (c1_ae4TC :: * -> *))
                 (k_ae2q8
                    :: forall b1 r. Data b1 => c1_ae4TC (b1 -> r) -> c1_ae4TC r)
                 (z_ae2q9 [Occ=Once!] :: forall r. r -> c1_ae4TC r)
                 _ [Occ=Dead] ->
                 k_ae2q8
                   @ c_ae4T8
                   @ (a_ae4T6, b_ae4T7, c_ae4T8)
                   $dData2_ae4Tb
                   (k_ae2q8
                      @ b_ae4T7
                      @ (c_ae4T8 -> (a_ae4T6, b_ae4T7, c_ae4T8))
                      $dData1_ae4Ta
                      (k_ae2q8
                         @ a_ae4T6
                         @ (b_ae4T7 -> c_ae4T8 -> (a_ae4T6, b_ae4T7, c_ae4T8))
                         $dData_ae4T9
                         (z_ae2q9
                            @ (a_ae4T6 -> b_ae4T7 -> c_ae4T8 -> (a_ae4T6, b_ae4T7, c_ae4T8))
                            (GHC.Tuple.(,,) @ a_ae4T6 @ b_ae4T7 @ c_ae4T8))))}]
Data.Data.$fData(,,)_$cgunfold
  = \ (@ a_ae4T6)
      (@ b_ae4T7)
      (@ c_ae4T8)
      ($dData_ae4T9 :: Data a_ae4T6)
      ($dData1_ae4Ta :: Data b_ae4T7)
      ($dData2_ae4Tb :: Data c_ae4T8)
      (@ (c1_ae4TC :: * -> *))
      (k_ae2q8
         :: forall b1 r. Data b1 => c1_ae4TC (b1 -> r) -> c1_ae4TC r)
      (z_ae2q9 :: forall r. r -> c1_ae4TC r)
      _ [Occ=Dead] ->
      k_ae2q8
        @ c_ae4T8
        @ (a_ae4T6, b_ae4T7, c_ae4T8)
        $dData2_ae4Tb
        (k_ae2q8
           @ b_ae4T7
           @ (c_ae4T8 -> (a_ae4T6, b_ae4T7, c_ae4T8))
           $dData1_ae4Ta
           (k_ae2q8
              @ a_ae4T6
              @ (b_ae4T7 -> c_ae4T8 -> (a_ae4T6, b_ae4T7, c_ae4T8))
              $dData_ae4T9
              (z_ae2q9
                 @ (a_ae4T6 -> b_ae4T7 -> c_ae4T8 -> (a_ae4T6, b_ae4T7, c_ae4T8))
                 (GHC.Tuple.(,,) @ a_ae4T6 @ b_ae4T7 @ c_ae4T8))))

-- RHS size: {terms: 23, types: 64, coercions: 0, joins: 0/0}
Data.Data.$w$cgfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (Data a, Data b, Data c) =>
     forall (c1 :: * -> *).
     (forall d b1. Data d => c1 (d -> b1) -> d -> c1 b1)
     -> (forall g. g -> c1 g) -> a -> b -> c -> c1 (a, b, c)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 180 60 0 0 0] 140 0}]
Data.Data.$w$cgfoldl
  = \ (@ a_sefPz)
      (@ b_sefPA)
      (@ c_sefPB)
      (w_sefPC :: Data a_sefPz)
      (w1_sefPD :: Data b_sefPA)
      (w2_sefPE :: Data c_sefPB)
      (@ (c1_sefPF :: * -> *))
      (w3_sefPG
         :: forall d b1. Data d => c1_sefPF (d -> b1) -> d -> c1_sefPF b1)
      (w4_sefPH :: forall g. g -> c1_sefPF g)
      (ww_sefPL :: a_sefPz)
      (ww1_sefPM :: b_sefPA)
      (ww2_sefPN :: c_sefPB) ->
      w3_sefPG
        @ c_sefPB
        @ (a_sefPz, b_sefPA, c_sefPB)
        w2_sefPE
        (w3_sefPG
           @ b_sefPA
           @ (c_sefPB -> (a_sefPz, b_sefPA, c_sefPB))
           w1_sefPD
           (w3_sefPG
              @ a_sefPz
              @ (b_sefPA -> c_sefPB -> (a_sefPz, b_sefPA, c_sefPB))
              w_sefPC
              (w4_sefPH
                 @ (a_sefPz -> b_sefPA -> c_sefPB -> (a_sefPz, b_sefPA, c_sefPB))
                 (GHC.Tuple.(,,) @ a_sefPz @ b_sefPA @ c_sefPB))
              ww_sefPL)
           ww1_sefPM)
        ww2_sefPN

-- RHS size: {terms: 22, types: 48, coercions: 0, joins: 0/0}
Data.Data.$fData(,,)_$cgfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (Data a, Data b, Data c) =>
     forall (c1 :: * -> *).
     (forall d b1. Data d => c1 (d -> b1) -> d -> c1 b1)
     -> (forall g. g -> c1 g) -> (a, b, c) -> c1 (a, b, c)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sefPz)
                 (@ b_sefPA)
                 (@ c_sefPB)
                 (w_sefPC [Occ=Once] :: Data a_sefPz)
                 (w1_sefPD [Occ=Once] :: Data b_sefPA)
                 (w2_sefPE [Occ=Once] :: Data c_sefPB)
                 (@ (c1_sefPF :: * -> *))
                 (w3_sefPG [Occ=Once]
                    :: forall d b1. Data d => c1_sefPF (d -> b1) -> d -> c1_sefPF b1)
                 (w4_sefPH [Occ=Once] :: forall g. g -> c1_sefPF g)
                 (w5_sefPI [Occ=Once!] :: (a_sefPz, b_sefPA, c_sefPB)) ->
                 case w5_sefPI of
                 { (ww1_sefPL [Occ=Once], ww2_sefPM [Occ=Once],
                    ww3_sefPN [Occ=Once]) ->
                 Data.Data.$w$cgfoldl
                   @ a_sefPz
                   @ b_sefPA
                   @ c_sefPB
                   w_sefPC
                   w1_sefPD
                   w2_sefPE
                   @ c1_sefPF
                   w3_sefPG
                   w4_sefPH
                   ww1_sefPL
                   ww2_sefPM
                   ww3_sefPN
                 }}]
Data.Data.$fData(,,)_$cgfoldl
  = \ (@ a_sefPz)
      (@ b_sefPA)
      (@ c_sefPB)
      (w_sefPC :: Data a_sefPz)
      (w1_sefPD :: Data b_sefPA)
      (w2_sefPE :: Data c_sefPB)
      (@ (c1_sefPF :: * -> *))
      (w3_sefPG
         :: forall d b1. Data d => c1_sefPF (d -> b1) -> d -> c1_sefPF b1)
      (w4_sefPH :: forall g. g -> c1_sefPF g)
      (w5_sefPI :: (a_sefPz, b_sefPA, c_sefPB)) ->
      case w5_sefPI of { (ww1_sefPL, ww2_sefPM, ww3_sefPN) ->
      Data.Data.$w$cgfoldl
        @ a_sefPz
        @ b_sefPA
        @ c_sefPB
        w_sefPC
        w1_sefPD
        w2_sefPE
        @ c1_sefPF
        w3_sefPG
        w4_sefPH
        ww1_sefPL
        ww2_sefPM
        ww3_sefPN
      }

-- RHS size: {terms: 16, types: 57, coercions: 0, joins: 0/0}
Data.Data.$fData(,,)9 :: Data.Typeable.Internal.TypeRep (,,)
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fData(,,)9
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> * -> * -> *)
           @ (,,)
           16761935148902514387##
           563489141779473397##
           GHC.Tuple.$trModule
           GHC.Tuple.$tc(,,)2
           0#
           GHC.Tuple.$tc(,,)1
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> * -> * -> *)
      @ (,,)
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 16, types: 42, coercions: 12, joins: 0/0}
Data.Data.$fData(,,)8
  :: forall a b c.
     (Data a, Data b, Data c) =>
     Data.Typeable.Internal.TypeRep (a, b, c)
[GblId,
 Arity=3,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30 30] 150 0}]
Data.Data.$fData(,,)8
  = \ (@ a_ae4T6)
      (@ b_ae4T7)
      (@ c_ae4T8)
      ($dData_ae4T9 :: Data a_ae4T6)
      ($dData1_ae4Ta :: Data b_ae4T7)
      ($dData2_ae4Tb :: Data c_ae4T8) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ ((,,) a_ae4T6 b_ae4T7)
        @ c_ae4T8
        (Data.Typeable.Internal.mkTrApp
           @ *
           @ (* -> *)
           @ ((,,) a_ae4T6)
           @ b_ae4T7
           (Data.Typeable.Internal.mkTrApp
              @ *
              @ (* -> * -> *)
              @ (,,)
              @ a_ae4T6
              Data.Data.$fData(,,)9
              ((Data.Data.$p1Data @ a_ae4T6 $dData_ae4T9)
               `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae4T6>_N
                       :: (Typeable a_ae4T6 :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep a_ae4T6 :: *))))
           ((Data.Data.$p1Data @ b_ae4T7 $dData1_ae4Ta)
            `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <b_ae4T7>_N
                    :: (Typeable b_ae4T7 :: Constraint)
                       ~R# (Data.Typeable.Internal.TypeRep b_ae4T7 :: *))))
        ((Data.Data.$p1Data @ c_ae4T8 $dData2_ae4Tb)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <c_ae4T8>_N
                 :: (Typeable c_ae4T8 :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep c_ae4T8 :: *)))

-- RHS size: {terms: 22, types: 80, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,)_$cgunfold
  :: forall a b c d.
     (Data a, Data b, Data c, Data d) =>
     forall (c1 :: * -> *).
     (forall b1 r. Data b1 => c1 (b1 -> r) -> c1 r)
     -> (forall r. r -> c1 r) -> Constr -> c1 (a, b, c, d)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=7,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae4Pn)
                 (@ b_ae4Po)
                 (@ c_ae4Pp)
                 (@ d_ae4Pq)
                 ($dData_ae4Pr [Occ=Once] :: Data a_ae4Pn)
                 ($dData1_ae4Ps [Occ=Once] :: Data b_ae4Po)
                 ($dData2_ae4Pt [Occ=Once] :: Data c_ae4Pp)
                 ($dData3_ae4Pu [Occ=Once] :: Data d_ae4Pq)
                 (@ (c1_ae4PZ :: * -> *))
                 (k_ae2q1
                    :: forall b1 r. Data b1 => c1_ae4PZ (b1 -> r) -> c1_ae4PZ r)
                 (z_ae2q2 [Occ=Once!] :: forall r. r -> c1_ae4PZ r)
                 _ [Occ=Dead] ->
                 k_ae2q1
                   @ d_ae4Pq
                   @ (a_ae4Pn, b_ae4Po, c_ae4Pp, d_ae4Pq)
                   $dData3_ae4Pu
                   (k_ae2q1
                      @ c_ae4Pp
                      @ (d_ae4Pq -> (a_ae4Pn, b_ae4Po, c_ae4Pp, d_ae4Pq))
                      $dData2_ae4Pt
                      (k_ae2q1
                         @ b_ae4Po
                         @ (c_ae4Pp -> d_ae4Pq -> (a_ae4Pn, b_ae4Po, c_ae4Pp, d_ae4Pq))
                         $dData1_ae4Ps
                         (k_ae2q1
                            @ a_ae4Pn
                            @ (b_ae4Po
                               -> c_ae4Pp -> d_ae4Pq -> (a_ae4Pn, b_ae4Po, c_ae4Pp, d_ae4Pq))
                            $dData_ae4Pr
                            (z_ae2q2
                               @ (a_ae4Pn
                                  -> b_ae4Po
                                  -> c_ae4Pp
                                  -> d_ae4Pq
                                  -> (a_ae4Pn, b_ae4Po, c_ae4Pp, d_ae4Pq))
                               (GHC.Tuple.(,,,) @ a_ae4Pn @ b_ae4Po @ c_ae4Pp @ d_ae4Pq)))))}]
Data.Data.$fData(,,,)_$cgunfold
  = \ (@ a_ae4Pn)
      (@ b_ae4Po)
      (@ c_ae4Pp)
      (@ d_ae4Pq)
      ($dData_ae4Pr :: Data a_ae4Pn)
      ($dData1_ae4Ps :: Data b_ae4Po)
      ($dData2_ae4Pt :: Data c_ae4Pp)
      ($dData3_ae4Pu :: Data d_ae4Pq)
      (@ (c1_ae4PZ :: * -> *))
      (k_ae2q1
         :: forall b1 r. Data b1 => c1_ae4PZ (b1 -> r) -> c1_ae4PZ r)
      (z_ae2q2 :: forall r. r -> c1_ae4PZ r)
      _ [Occ=Dead] ->
      k_ae2q1
        @ d_ae4Pq
        @ (a_ae4Pn, b_ae4Po, c_ae4Pp, d_ae4Pq)
        $dData3_ae4Pu
        (k_ae2q1
           @ c_ae4Pp
           @ (d_ae4Pq -> (a_ae4Pn, b_ae4Po, c_ae4Pp, d_ae4Pq))
           $dData2_ae4Pt
           (k_ae2q1
              @ b_ae4Po
              @ (c_ae4Pp -> d_ae4Pq -> (a_ae4Pn, b_ae4Po, c_ae4Pp, d_ae4Pq))
              $dData1_ae4Ps
              (k_ae2q1
                 @ a_ae4Pn
                 @ (b_ae4Po
                    -> c_ae4Pp -> d_ae4Pq -> (a_ae4Pn, b_ae4Po, c_ae4Pp, d_ae4Pq))
                 $dData_ae4Pr
                 (z_ae2q2
                    @ (a_ae4Pn
                       -> b_ae4Po
                       -> c_ae4Pp
                       -> d_ae4Pq
                       -> (a_ae4Pn, b_ae4Po, c_ae4Pp, d_ae4Pq))
                    (GHC.Tuple.(,,,) @ a_ae4Pn @ b_ae4Po @ c_ae4Pp @ d_ae4Pq)))))

-- RHS size: {terms: 29, types: 84, coercions: 0, joins: 0/0}
Data.Data.$w$cgfoldl1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (Data a, Data b, Data c, Data d) =>
     forall (c1 :: * -> *).
     (forall d1 b1. Data d1 => c1 (d1 -> b1) -> d1 -> c1 b1)
     -> (forall g. g -> c1 g) -> a -> b -> c -> d -> c1 (a, b, c, d)
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 240 60 0 0 0 0] 180 0}]
Data.Data.$w$cgfoldl1
  = \ (@ a_sefPW)
      (@ b_sefPX)
      (@ c_sefPY)
      (@ d_sefPZ)
      (w_sefQ0 :: Data a_sefPW)
      (w1_sefQ1 :: Data b_sefPX)
      (w2_sefQ2 :: Data c_sefPY)
      (w3_sefQ3 :: Data d_sefPZ)
      (@ (c1_sefQ4 :: * -> *))
      (w4_sefQ5
         :: forall d1 b1.
            Data d1 =>
            c1_sefQ4 (d1 -> b1) -> d1 -> c1_sefQ4 b1)
      (w5_sefQ6 :: forall g. g -> c1_sefQ4 g)
      (ww_sefQa :: a_sefPW)
      (ww1_sefQb :: b_sefPX)
      (ww2_sefQc :: c_sefPY)
      (ww3_sefQd :: d_sefPZ) ->
      w4_sefQ5
        @ d_sefPZ
        @ (a_sefPW, b_sefPX, c_sefPY, d_sefPZ)
        w3_sefQ3
        (w4_sefQ5
           @ c_sefPY
           @ (d_sefPZ -> (a_sefPW, b_sefPX, c_sefPY, d_sefPZ))
           w2_sefQ2
           (w4_sefQ5
              @ b_sefPX
              @ (c_sefPY -> d_sefPZ -> (a_sefPW, b_sefPX, c_sefPY, d_sefPZ))
              w1_sefQ1
              (w4_sefQ5
                 @ a_sefPW
                 @ (b_sefPX
                    -> c_sefPY -> d_sefPZ -> (a_sefPW, b_sefPX, c_sefPY, d_sefPZ))
                 w_sefQ0
                 (w5_sefQ6
                    @ (a_sefPW
                       -> b_sefPX
                       -> c_sefPY
                       -> d_sefPZ
                       -> (a_sefPW, b_sefPX, c_sefPY, d_sefPZ))
                    (GHC.Tuple.(,,,) @ a_sefPW @ b_sefPX @ c_sefPY @ d_sefPZ))
                 ww_sefQa)
              ww1_sefQb)
           ww2_sefQc)
        ww3_sefQd

-- RHS size: {terms: 26, types: 56, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,)_$cgfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (Data a, Data b, Data c, Data d) =>
     forall (c1 :: * -> *).
     (forall d1 b1. Data d1 => c1 (d1 -> b1) -> d1 -> c1 b1)
     -> (forall g. g -> c1 g) -> (a, b, c, d) -> c1 (a, b, c, d)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=7,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sefPW)
                 (@ b_sefPX)
                 (@ c_sefPY)
                 (@ d_sefPZ)
                 (w_sefQ0 [Occ=Once] :: Data a_sefPW)
                 (w1_sefQ1 [Occ=Once] :: Data b_sefPX)
                 (w2_sefQ2 [Occ=Once] :: Data c_sefPY)
                 (w3_sefQ3 [Occ=Once] :: Data d_sefPZ)
                 (@ (c1_sefQ4 :: * -> *))
                 (w4_sefQ5 [Occ=Once]
                    :: forall d1 b1.
                       Data d1 =>
                       c1_sefQ4 (d1 -> b1) -> d1 -> c1_sefQ4 b1)
                 (w5_sefQ6 [Occ=Once] :: forall g. g -> c1_sefQ4 g)
                 (w6_sefQ7 [Occ=Once!] :: (a_sefPW, b_sefPX, c_sefPY, d_sefPZ)) ->
                 case w6_sefQ7 of
                 { (ww1_sefQa [Occ=Once], ww2_sefQb [Occ=Once],
                    ww3_sefQc [Occ=Once], ww4_sefQd [Occ=Once]) ->
                 Data.Data.$w$cgfoldl1
                   @ a_sefPW
                   @ b_sefPX
                   @ c_sefPY
                   @ d_sefPZ
                   w_sefQ0
                   w1_sefQ1
                   w2_sefQ2
                   w3_sefQ3
                   @ c1_sefQ4
                   w4_sefQ5
                   w5_sefQ6
                   ww1_sefQa
                   ww2_sefQb
                   ww3_sefQc
                   ww4_sefQd
                 }}]
Data.Data.$fData(,,,)_$cgfoldl
  = \ (@ a_sefPW)
      (@ b_sefPX)
      (@ c_sefPY)
      (@ d_sefPZ)
      (w_sefQ0 :: Data a_sefPW)
      (w1_sefQ1 :: Data b_sefPX)
      (w2_sefQ2 :: Data c_sefPY)
      (w3_sefQ3 :: Data d_sefPZ)
      (@ (c1_sefQ4 :: * -> *))
      (w4_sefQ5
         :: forall d1 b1.
            Data d1 =>
            c1_sefQ4 (d1 -> b1) -> d1 -> c1_sefQ4 b1)
      (w5_sefQ6 :: forall g. g -> c1_sefQ4 g)
      (w6_sefQ7 :: (a_sefPW, b_sefPX, c_sefPY, d_sefPZ)) ->
      case w6_sefQ7 of { (ww1_sefQa, ww2_sefQb, ww3_sefQc, ww4_sefQd) ->
      Data.Data.$w$cgfoldl1
        @ a_sefPW
        @ b_sefPX
        @ c_sefPY
        @ d_sefPZ
        w_sefQ0
        w1_sefQ1
        w2_sefQ2
        w3_sefQ3
        @ c1_sefQ4
        w4_sefQ5
        w5_sefQ6
        ww1_sefQa
        ww2_sefQb
        ww3_sefQc
        ww4_sefQd
      }

-- RHS size: {terms: 16, types: 65, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,)9 :: Data.Typeable.Internal.TypeRep (,,,)
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fData(,,,)9
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> * -> * -> * -> *)
           @ (,,,)
           8246304219145906156##
           6511313691515418340##
           GHC.Tuple.$trModule
           GHC.Tuple.$tc(,,,)2
           0#
           GHC.Tuple.$tc(,,,)1
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> * -> * -> * -> *)
      @ (,,,)
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 21, types: 62, coercions: 16, joins: 0/0}
Data.Data.$fData(,,,)8
  :: forall a b c d.
     (Data a, Data b, Data c, Data d) =>
     Data.Typeable.Internal.TypeRep (a, b, c, d)
[GblId,
 Arity=4,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 30] 200 0}]
Data.Data.$fData(,,,)8
  = \ (@ a_ae4Pn)
      (@ b_ae4Po)
      (@ c_ae4Pp)
      (@ d_ae4Pq)
      ($dData_ae4Pr :: Data a_ae4Pn)
      ($dData1_ae4Ps :: Data b_ae4Po)
      ($dData2_ae4Pt :: Data c_ae4Pp)
      ($dData3_ae4Pu :: Data d_ae4Pq) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ ((,,,) a_ae4Pn b_ae4Po c_ae4Pp)
        @ d_ae4Pq
        (Data.Typeable.Internal.mkTrApp
           @ *
           @ (* -> *)
           @ ((,,,) a_ae4Pn b_ae4Po)
           @ c_ae4Pp
           (Data.Typeable.Internal.mkTrApp
              @ *
              @ (* -> * -> *)
              @ ((,,,) a_ae4Pn)
              @ b_ae4Po
              (Data.Typeable.Internal.mkTrApp
                 @ *
                 @ (* -> * -> * -> *)
                 @ (,,,)
                 @ a_ae4Pn
                 Data.Data.$fData(,,,)9
                 ((Data.Data.$p1Data @ a_ae4Pn $dData_ae4Pr)
                  `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae4Pn>_N
                          :: (Typeable a_ae4Pn :: Constraint)
                             ~R# (Data.Typeable.Internal.TypeRep a_ae4Pn :: *))))
              ((Data.Data.$p1Data @ b_ae4Po $dData1_ae4Ps)
               `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <b_ae4Po>_N
                       :: (Typeable b_ae4Po :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep b_ae4Po :: *))))
           ((Data.Data.$p1Data @ c_ae4Pp $dData2_ae4Pt)
            `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <c_ae4Pp>_N
                    :: (Typeable c_ae4Pp :: Constraint)
                       ~R# (Data.Typeable.Internal.TypeRep c_ae4Pp :: *))))
        ((Data.Data.$p1Data @ d_ae4Pq $dData3_ae4Pu)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <d_ae4Pq>_N
                 :: (Typeable d_ae4Pq :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep d_ae4Pq :: *)))

-- RHS size: {terms: 25, types: 101, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e.
     (Data a, Data b, Data c, Data d, Data e) =>
     forall (c1 :: * -> *).
     (forall b1 r. Data b1 => c1 (b1 -> r) -> c1 r)
     -> (forall r. r -> c1 r) -> c1 (a, b, c, d, e)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><C(C(S)),C(C1(U))><L,1*C1(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 300 60] 170 0}]
Data.Data.$w$cgunfold
  = \ (@ a_sefQo)
      (@ b_sefQp)
      (@ c_sefQq)
      (@ d_sefQr)
      (@ e_sefQs)
      (w_sefQt :: Data a_sefQo)
      (w1_sefQu :: Data b_sefQp)
      (w2_sefQv :: Data c_sefQq)
      (w3_sefQw :: Data d_sefQr)
      (w4_sefQx :: Data e_sefQs)
      (@ (c1_sefQy :: * -> *))
      (w5_sefQz
         :: forall b1 r. Data b1 => c1_sefQy (b1 -> r) -> c1_sefQy r)
      (w6_sefQA :: forall r. r -> c1_sefQy r) ->
      w5_sefQz
        @ e_sefQs
        @ (a_sefQo, b_sefQp, c_sefQq, d_sefQr, e_sefQs)
        w4_sefQx
        (w5_sefQz
           @ d_sefQr
           @ (e_sefQs -> (a_sefQo, b_sefQp, c_sefQq, d_sefQr, e_sefQs))
           w3_sefQw
           (w5_sefQz
              @ c_sefQq
              @ (d_sefQr
                 -> e_sefQs -> (a_sefQo, b_sefQp, c_sefQq, d_sefQr, e_sefQs))
              w2_sefQv
              (w5_sefQz
                 @ b_sefQp
                 @ (c_sefQq
                    -> d_sefQr
                    -> e_sefQs
                    -> (a_sefQo, b_sefQp, c_sefQq, d_sefQr, e_sefQs))
                 w1_sefQu
                 (w5_sefQz
                    @ a_sefQo
                    @ (b_sefQp
                       -> c_sefQq
                       -> d_sefQr
                       -> e_sefQs
                       -> (a_sefQo, b_sefQp, c_sefQq, d_sefQr, e_sefQs))
                    w_sefQt
                    (w6_sefQA
                       @ (a_sefQo
                          -> b_sefQp
                          -> c_sefQq
                          -> d_sefQr
                          -> e_sefQs
                          -> (a_sefQo, b_sefQp, c_sefQq, d_sefQr, e_sefQs))
                       (GHC.Tuple.(,,,,)
                          @ a_sefQo @ b_sefQp @ c_sefQq @ d_sefQr @ e_sefQs))))))

-- RHS size: {terms: 22, types: 47, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,)_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e.
     (Data a, Data b, Data c, Data d, Data e) =>
     forall (c1 :: * -> *).
     (forall b1 r. Data b1 => c1 (b1 -> r) -> c1 r)
     -> (forall r. r -> c1 r) -> Constr -> c1 (a, b, c, d, e)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=8,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sefQo)
                 (@ b_sefQp)
                 (@ c_sefQq)
                 (@ d_sefQr)
                 (@ e_sefQs)
                 (w_sefQt [Occ=Once] :: Data a_sefQo)
                 (w1_sefQu [Occ=Once] :: Data b_sefQp)
                 (w2_sefQv [Occ=Once] :: Data c_sefQq)
                 (w3_sefQw [Occ=Once] :: Data d_sefQr)
                 (w4_sefQx [Occ=Once] :: Data e_sefQs)
                 (@ (c1_sefQy :: * -> *))
                 (w5_sefQz [Occ=Once]
                    :: forall b1 r. Data b1 => c1_sefQy (b1 -> r) -> c1_sefQy r)
                 (w6_sefQA [Occ=Once] :: forall r. r -> c1_sefQy r)
                 _ [Occ=Dead] ->
                 Data.Data.$w$cgunfold
                   @ a_sefQo
                   @ b_sefQp
                   @ c_sefQq
                   @ d_sefQr
                   @ e_sefQs
                   w_sefQt
                   w1_sefQu
                   w2_sefQv
                   w3_sefQw
                   w4_sefQx
                   @ c1_sefQy
                   w5_sefQz
                   w6_sefQA}]
Data.Data.$fData(,,,,)_$cgunfold
  = \ (@ a_sefQo)
      (@ b_sefQp)
      (@ c_sefQq)
      (@ d_sefQr)
      (@ e_sefQs)
      (w_sefQt :: Data a_sefQo)
      (w1_sefQu :: Data b_sefQp)
      (w2_sefQv :: Data c_sefQq)
      (w3_sefQw :: Data d_sefQr)
      (w4_sefQx :: Data e_sefQs)
      (@ (c1_sefQy :: * -> *))
      (w5_sefQz
         :: forall b1 r. Data b1 => c1_sefQy (b1 -> r) -> c1_sefQy r)
      (w6_sefQA :: forall r. r -> c1_sefQy r)
      _ [Occ=Dead] ->
      Data.Data.$w$cgunfold
        @ a_sefQo
        @ b_sefQp
        @ c_sefQq
        @ d_sefQr
        @ e_sefQs
        w_sefQt
        w1_sefQu
        w2_sefQv
        w3_sefQw
        w4_sefQx
        @ c1_sefQy
        w5_sefQz
        w6_sefQA

-- RHS size: {terms: 34, types: 119, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,)_$cgfoldl
  :: forall a b c d e.
     (Data a, Data b, Data c, Data d, Data e) =>
     forall (c1 :: * -> *).
     (forall d1 b1. Data d1 => c1 (d1 -> b1) -> d1 -> c1 b1)
     -> (forall g. g -> c1 g) -> (a, b, c, d, e) -> c1 (a, b, c, d, e)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 300 60 20] 230 0}]
Data.Data.$fData(,,,,)_$cgfoldl
  = \ (@ a_ae4Lu)
      (@ b_ae4Lv)
      (@ c_ae4Lw)
      (@ d_ae4Lx)
      (@ e_ae4Ly)
      ($dData_ae4Lz :: Data a_ae4Lu)
      ($dData1_ae4LA :: Data b_ae4Lv)
      ($dData2_ae4LB :: Data c_ae4Lw)
      ($dData3_ae4LC :: Data d_ae4Lx)
      ($dData4_ae4LD :: Data e_ae4Ly)
      (@ (c1_ae4LL :: * -> *))
      (k_ae2pM
         :: forall d1 b1.
            Data d1 =>
            c1_ae4LL (d1 -> b1) -> d1 -> c1_ae4LL b1)
      (z_ae2pN :: forall g. g -> c1_ae4LL g)
      (ds_de7Bz :: (a_ae4Lu, b_ae4Lv, c_ae4Lw, d_ae4Lx, e_ae4Ly)) ->
      case ds_de7Bz of
      { (a1_ae2pO, a2_ae2pP, a3_ae2pQ, a4_ae2pR, a5_ae2pS) ->
      k_ae2pM
        @ e_ae4Ly
        @ (a_ae4Lu, b_ae4Lv, c_ae4Lw, d_ae4Lx, e_ae4Ly)
        $dData4_ae4LD
        (k_ae2pM
           @ d_ae4Lx
           @ (e_ae4Ly -> (a_ae4Lu, b_ae4Lv, c_ae4Lw, d_ae4Lx, e_ae4Ly))
           $dData3_ae4LC
           (k_ae2pM
              @ c_ae4Lw
              @ (d_ae4Lx
                 -> e_ae4Ly -> (a_ae4Lu, b_ae4Lv, c_ae4Lw, d_ae4Lx, e_ae4Ly))
              $dData2_ae4LB
              (k_ae2pM
                 @ b_ae4Lv
                 @ (c_ae4Lw
                    -> d_ae4Lx
                    -> e_ae4Ly
                    -> (a_ae4Lu, b_ae4Lv, c_ae4Lw, d_ae4Lx, e_ae4Ly))
                 $dData1_ae4LA
                 (k_ae2pM
                    @ a_ae4Lu
                    @ (b_ae4Lv
                       -> c_ae4Lw
                       -> d_ae4Lx
                       -> e_ae4Ly
                       -> (a_ae4Lu, b_ae4Lv, c_ae4Lw, d_ae4Lx, e_ae4Ly))
                    $dData_ae4Lz
                    (z_ae2pN
                       @ (a_ae4Lu
                          -> b_ae4Lv
                          -> c_ae4Lw
                          -> d_ae4Lx
                          -> e_ae4Ly
                          -> (a_ae4Lu, b_ae4Lv, c_ae4Lw, d_ae4Lx, e_ae4Ly))
                       (GHC.Tuple.(,,,,)
                          @ a_ae4Lu @ b_ae4Lv @ c_ae4Lw @ d_ae4Lx @ e_ae4Ly))
                    a1_ae2pO)
                 a2_ae2pP)
              a3_ae2pQ)
           a4_ae2pR)
        a5_ae2pS
      }

-- RHS size: {terms: 16, types: 73, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,)8 :: Data.Typeable.Internal.TypeRep (,,,,)
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fData(,,,,)8
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> * -> * -> * -> * -> *)
           @ (,,,,)
           4324751680672201985##
           2655271461240509990##
           GHC.Tuple.$trModule
           GHC.Tuple.$tc(,,,,)2
           0#
           GHC.Tuple.$tc(,,,,)1
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> * -> * -> * -> * -> *)
      @ (,,,,)
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 26, types: 85, coercions: 20, joins: 0/0}
Data.Data.$fData(,,,,)7
  :: forall a b c d e.
     (Data a, Data b, Data c, Data d, Data e) =>
     Data.Typeable.Internal.TypeRep (a, b, c, d, e)
[GblId,
 Arity=5,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 30 30] 250 0}]
Data.Data.$fData(,,,,)7
  = \ (@ a_ae4Lu)
      (@ b_ae4Lv)
      (@ c_ae4Lw)
      (@ d_ae4Lx)
      (@ e_ae4Ly)
      ($dData_ae4Lz :: Data a_ae4Lu)
      ($dData1_ae4LA :: Data b_ae4Lv)
      ($dData2_ae4LB :: Data c_ae4Lw)
      ($dData3_ae4LC :: Data d_ae4Lx)
      ($dData4_ae4LD :: Data e_ae4Ly) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ ((,,,,) a_ae4Lu b_ae4Lv c_ae4Lw d_ae4Lx)
        @ e_ae4Ly
        (Data.Typeable.Internal.mkTrApp
           @ *
           @ (* -> *)
           @ ((,,,,) a_ae4Lu b_ae4Lv c_ae4Lw)
           @ d_ae4Lx
           (Data.Typeable.Internal.mkTrApp
              @ *
              @ (* -> * -> *)
              @ ((,,,,) a_ae4Lu b_ae4Lv)
              @ c_ae4Lw
              (Data.Typeable.Internal.mkTrApp
                 @ *
                 @ (* -> * -> * -> *)
                 @ ((,,,,) a_ae4Lu)
                 @ b_ae4Lv
                 (Data.Typeable.Internal.mkTrApp
                    @ *
                    @ (* -> * -> * -> * -> *)
                    @ (,,,,)
                    @ a_ae4Lu
                    Data.Data.$fData(,,,,)8
                    ((Data.Data.$p1Data @ a_ae4Lu $dData_ae4Lz)
                     `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae4Lu>_N
                             :: (Typeable a_ae4Lu :: Constraint)
                                ~R# (Data.Typeable.Internal.TypeRep a_ae4Lu :: *))))
                 ((Data.Data.$p1Data @ b_ae4Lv $dData1_ae4LA)
                  `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <b_ae4Lv>_N
                          :: (Typeable b_ae4Lv :: Constraint)
                             ~R# (Data.Typeable.Internal.TypeRep b_ae4Lv :: *))))
              ((Data.Data.$p1Data @ c_ae4Lw $dData2_ae4LB)
               `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <c_ae4Lw>_N
                       :: (Typeable c_ae4Lw :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep c_ae4Lw :: *))))
           ((Data.Data.$p1Data @ d_ae4Lx $dData3_ae4LC)
            `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <d_ae4Lx>_N
                    :: (Typeable d_ae4Lx :: Constraint)
                       ~R# (Data.Typeable.Internal.TypeRep d_ae4Lx :: *))))
        ((Data.Data.$p1Data @ e_ae4Ly $dData4_ae4LD)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e_ae4Ly>_N
                 :: (Typeable e_ae4Ly :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep e_ae4Ly :: *)))

-- RHS size: {terms: 29, types: 126, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e f.
     (Data a, Data b, Data c, Data d, Data e, Data f) =>
     forall (c1 :: * -> *).
     (forall b1 r. Data b1 => c1 (b1 -> r) -> c1 r)
     -> (forall r. r -> c1 r) -> c1 (a, b, c, d, e, f)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><C(C(S)),C(C1(U))><L,1*C1(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 360 60] 200 0}]
Data.Data.$w$cgunfold1
  = \ (@ a_sefR9)
      (@ b_sefRa)
      (@ c_sefRb)
      (@ d_sefRc)
      (@ e_sefRd)
      (@ f_sefRe)
      (w_sefRf :: Data a_sefR9)
      (w1_sefRg :: Data b_sefRa)
      (w2_sefRh :: Data c_sefRb)
      (w3_sefRi :: Data d_sefRc)
      (w4_sefRj :: Data e_sefRd)
      (w5_sefRk :: Data f_sefRe)
      (@ (c1_sefRl :: * -> *))
      (w6_sefRm
         :: forall b1 r. Data b1 => c1_sefRl (b1 -> r) -> c1_sefRl r)
      (w7_sefRn :: forall r. r -> c1_sefRl r) ->
      w6_sefRm
        @ f_sefRe
        @ (a_sefR9, b_sefRa, c_sefRb, d_sefRc, e_sefRd, f_sefRe)
        w5_sefRk
        (w6_sefRm
           @ e_sefRd
           @ (f_sefRe
              -> (a_sefR9, b_sefRa, c_sefRb, d_sefRc, e_sefRd, f_sefRe))
           w4_sefRj
           (w6_sefRm
              @ d_sefRc
              @ (e_sefRd
                 -> f_sefRe
                 -> (a_sefR9, b_sefRa, c_sefRb, d_sefRc, e_sefRd, f_sefRe))
              w3_sefRi
              (w6_sefRm
                 @ c_sefRb
                 @ (d_sefRc
                    -> e_sefRd
                    -> f_sefRe
                    -> (a_sefR9, b_sefRa, c_sefRb, d_sefRc, e_sefRd, f_sefRe))
                 w2_sefRh
                 (w6_sefRm
                    @ b_sefRa
                    @ (c_sefRb
                       -> d_sefRc
                       -> e_sefRd
                       -> f_sefRe
                       -> (a_sefR9, b_sefRa, c_sefRb, d_sefRc, e_sefRd, f_sefRe))
                    w1_sefRg
                    (w6_sefRm
                       @ a_sefR9
                       @ (b_sefRa
                          -> c_sefRb
                          -> d_sefRc
                          -> e_sefRd
                          -> f_sefRe
                          -> (a_sefR9, b_sefRa, c_sefRb, d_sefRc, e_sefRd, f_sefRe))
                       w_sefRf
                       (w7_sefRn
                          @ (a_sefR9
                             -> b_sefRa
                             -> c_sefRb
                             -> d_sefRc
                             -> e_sefRd
                             -> f_sefRe
                             -> (a_sefR9, b_sefRa, c_sefRb, d_sefRc, e_sefRd, f_sefRe))
                          (GHC.Tuple.(,,,,,)
                             @ a_sefR9 @ b_sefRa @ c_sefRb @ d_sefRc @ e_sefRd @ f_sefRe)))))))

-- RHS size: {terms: 25, types: 52, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,,)_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e f.
     (Data a, Data b, Data c, Data d, Data e, Data f) =>
     forall (c1 :: * -> *).
     (forall b1 r. Data b1 => c1 (b1 -> r) -> c1 r)
     -> (forall r. r -> c1 r) -> Constr -> c1 (a, b, c, d, e, f)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=9,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sefR9)
                 (@ b_sefRa)
                 (@ c_sefRb)
                 (@ d_sefRc)
                 (@ e_sefRd)
                 (@ f_sefRe)
                 (w_sefRf [Occ=Once] :: Data a_sefR9)
                 (w1_sefRg [Occ=Once] :: Data b_sefRa)
                 (w2_sefRh [Occ=Once] :: Data c_sefRb)
                 (w3_sefRi [Occ=Once] :: Data d_sefRc)
                 (w4_sefRj [Occ=Once] :: Data e_sefRd)
                 (w5_sefRk [Occ=Once] :: Data f_sefRe)
                 (@ (c1_sefRl :: * -> *))
                 (w6_sefRm [Occ=Once]
                    :: forall b1 r. Data b1 => c1_sefRl (b1 -> r) -> c1_sefRl r)
                 (w7_sefRn [Occ=Once] :: forall r. r -> c1_sefRl r)
                 _ [Occ=Dead] ->
                 Data.Data.$w$cgunfold1
                   @ a_sefR9
                   @ b_sefRa
                   @ c_sefRb
                   @ d_sefRc
                   @ e_sefRd
                   @ f_sefRe
                   w_sefRf
                   w1_sefRg
                   w2_sefRh
                   w3_sefRi
                   w4_sefRj
                   w5_sefRk
                   @ c1_sefRl
                   w6_sefRm
                   w7_sefRn}]
Data.Data.$fData(,,,,,)_$cgunfold
  = \ (@ a_sefR9)
      (@ b_sefRa)
      (@ c_sefRb)
      (@ d_sefRc)
      (@ e_sefRd)
      (@ f_sefRe)
      (w_sefRf :: Data a_sefR9)
      (w1_sefRg :: Data b_sefRa)
      (w2_sefRh :: Data c_sefRb)
      (w3_sefRi :: Data d_sefRc)
      (w4_sefRj :: Data e_sefRd)
      (w5_sefRk :: Data f_sefRe)
      (@ (c1_sefRl :: * -> *))
      (w6_sefRm
         :: forall b1 r. Data b1 => c1_sefRl (b1 -> r) -> c1_sefRl r)
      (w7_sefRn :: forall r. r -> c1_sefRl r)
      _ [Occ=Dead] ->
      Data.Data.$w$cgunfold1
        @ a_sefR9
        @ b_sefRa
        @ c_sefRb
        @ d_sefRc
        @ e_sefRd
        @ f_sefRe
        w_sefRf
        w1_sefRg
        w2_sefRh
        w3_sefRi
        w4_sefRj
        w5_sefRk
        @ c1_sefRl
        w6_sefRm
        w7_sefRn

-- RHS size: {terms: 39, types: 147, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,,)_$cgfoldl
  :: forall a b c d e f.
     (Data a, Data b, Data c, Data d, Data e, Data f) =>
     forall (c1 :: * -> *).
     (forall d1 b1. Data d1 => c1 (d1 -> b1) -> d1 -> c1 b1)
     -> (forall g. g -> c1 g)
     -> (a, b, c, d, e, f)
     -> c1 (a, b, c, d, e, f)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 360 60 20] 270 0}]
Data.Data.$fData(,,,,,)_$cgfoldl
  = \ (@ a_ae4Hr)
      (@ b_ae4Hs)
      (@ c_ae4Ht)
      (@ d_ae4Hu)
      (@ e_ae4Hv)
      (@ f_ae4Hw)
      ($dData_ae4Hx :: Data a_ae4Hr)
      ($dData1_ae4Hy :: Data b_ae4Hs)
      ($dData2_ae4Hz :: Data c_ae4Ht)
      ($dData3_ae4HA :: Data d_ae4Hu)
      ($dData4_ae4HB :: Data e_ae4Hv)
      ($dData5_ae4HC :: Data f_ae4Hw)
      (@ (c1_ae4HK :: * -> *))
      (k_ae2pC
         :: forall d1 b1.
            Data d1 =>
            c1_ae4HK (d1 -> b1) -> d1 -> c1_ae4HK b1)
      (z_ae2pD :: forall g. g -> c1_ae4HK g)
      (ds_de7Ba
         :: (a_ae4Hr, b_ae4Hs, c_ae4Ht, d_ae4Hu, e_ae4Hv, f_ae4Hw)) ->
      case ds_de7Ba of
      { (a1_ae2pE, a2_ae2pF, a3_ae2pG, a4_ae2pH, a5_ae2pI, a6_ae2pJ) ->
      k_ae2pC
        @ f_ae4Hw
        @ (a_ae4Hr, b_ae4Hs, c_ae4Ht, d_ae4Hu, e_ae4Hv, f_ae4Hw)
        $dData5_ae4HC
        (k_ae2pC
           @ e_ae4Hv
           @ (f_ae4Hw
              -> (a_ae4Hr, b_ae4Hs, c_ae4Ht, d_ae4Hu, e_ae4Hv, f_ae4Hw))
           $dData4_ae4HB
           (k_ae2pC
              @ d_ae4Hu
              @ (e_ae4Hv
                 -> f_ae4Hw
                 -> (a_ae4Hr, b_ae4Hs, c_ae4Ht, d_ae4Hu, e_ae4Hv, f_ae4Hw))
              $dData3_ae4HA
              (k_ae2pC
                 @ c_ae4Ht
                 @ (d_ae4Hu
                    -> e_ae4Hv
                    -> f_ae4Hw
                    -> (a_ae4Hr, b_ae4Hs, c_ae4Ht, d_ae4Hu, e_ae4Hv, f_ae4Hw))
                 $dData2_ae4Hz
                 (k_ae2pC
                    @ b_ae4Hs
                    @ (c_ae4Ht
                       -> d_ae4Hu
                       -> e_ae4Hv
                       -> f_ae4Hw
                       -> (a_ae4Hr, b_ae4Hs, c_ae4Ht, d_ae4Hu, e_ae4Hv, f_ae4Hw))
                    $dData1_ae4Hy
                    (k_ae2pC
                       @ a_ae4Hr
                       @ (b_ae4Hs
                          -> c_ae4Ht
                          -> d_ae4Hu
                          -> e_ae4Hv
                          -> f_ae4Hw
                          -> (a_ae4Hr, b_ae4Hs, c_ae4Ht, d_ae4Hu, e_ae4Hv, f_ae4Hw))
                       $dData_ae4Hx
                       (z_ae2pD
                          @ (a_ae4Hr
                             -> b_ae4Hs
                             -> c_ae4Ht
                             -> d_ae4Hu
                             -> e_ae4Hv
                             -> f_ae4Hw
                             -> (a_ae4Hr, b_ae4Hs, c_ae4Ht, d_ae4Hu, e_ae4Hv, f_ae4Hw))
                          (GHC.Tuple.(,,,,,)
                             @ a_ae4Hr @ b_ae4Hs @ c_ae4Ht @ d_ae4Hu @ e_ae4Hv @ f_ae4Hw))
                       a1_ae2pE)
                    a2_ae2pF)
                 a3_ae2pG)
              a4_ae2pH)
           a5_ae2pI)
        a6_ae2pJ
      }

-- RHS size: {terms: 16, types: 81, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,,)8 :: Data.Typeable.Internal.TypeRep (,,,,,)
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fData(,,,,,)8
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> * -> * -> * -> * -> * -> *)
           @ (,,,,,)
           14658697442360451123##
           2309040661398511304##
           GHC.Tuple.$trModule
           GHC.Tuple.$tc(,,,,,)2
           0#
           GHC.Tuple.$tc(,,,,,)1
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> * -> * -> * -> * -> * -> *)
      @ (,,,,,)
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 31, types: 111, coercions: 24, joins: 0/0}
Data.Data.$fData(,,,,,)7
  :: forall a b c d e f.
     (Data a, Data b, Data c, Data d, Data e, Data f) =>
     Data.Typeable.Internal.TypeRep (a, b, c, d, e, f)
[GblId,
 Arity=6,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 30 30 30] 300 0}]
Data.Data.$fData(,,,,,)7
  = \ (@ a_ae4Hr)
      (@ b_ae4Hs)
      (@ c_ae4Ht)
      (@ d_ae4Hu)
      (@ e_ae4Hv)
      (@ f_ae4Hw)
      ($dData_ae4Hx :: Data a_ae4Hr)
      ($dData1_ae4Hy :: Data b_ae4Hs)
      ($dData2_ae4Hz :: Data c_ae4Ht)
      ($dData3_ae4HA :: Data d_ae4Hu)
      ($dData4_ae4HB :: Data e_ae4Hv)
      ($dData5_ae4HC :: Data f_ae4Hw) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ ((,,,,,) a_ae4Hr b_ae4Hs c_ae4Ht d_ae4Hu e_ae4Hv)
        @ f_ae4Hw
        (Data.Typeable.Internal.mkTrApp
           @ *
           @ (* -> *)
           @ ((,,,,,) a_ae4Hr b_ae4Hs c_ae4Ht d_ae4Hu)
           @ e_ae4Hv
           (Data.Typeable.Internal.mkTrApp
              @ *
              @ (* -> * -> *)
              @ ((,,,,,) a_ae4Hr b_ae4Hs c_ae4Ht)
              @ d_ae4Hu
              (Data.Typeable.Internal.mkTrApp
                 @ *
                 @ (* -> * -> * -> *)
                 @ ((,,,,,) a_ae4Hr b_ae4Hs)
                 @ c_ae4Ht
                 (Data.Typeable.Internal.mkTrApp
                    @ *
                    @ (* -> * -> * -> * -> *)
                    @ ((,,,,,) a_ae4Hr)
                    @ b_ae4Hs
                    (Data.Typeable.Internal.mkTrApp
                       @ *
                       @ (* -> * -> * -> * -> * -> *)
                       @ (,,,,,)
                       @ a_ae4Hr
                       Data.Data.$fData(,,,,,)8
                       ((Data.Data.$p1Data @ a_ae4Hr $dData_ae4Hx)
                        `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae4Hr>_N
                                :: (Typeable a_ae4Hr :: Constraint)
                                   ~R# (Data.Typeable.Internal.TypeRep a_ae4Hr :: *))))
                    ((Data.Data.$p1Data @ b_ae4Hs $dData1_ae4Hy)
                     `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <b_ae4Hs>_N
                             :: (Typeable b_ae4Hs :: Constraint)
                                ~R# (Data.Typeable.Internal.TypeRep b_ae4Hs :: *))))
                 ((Data.Data.$p1Data @ c_ae4Ht $dData2_ae4Hz)
                  `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <c_ae4Ht>_N
                          :: (Typeable c_ae4Ht :: Constraint)
                             ~R# (Data.Typeable.Internal.TypeRep c_ae4Ht :: *))))
              ((Data.Data.$p1Data @ d_ae4Hu $dData3_ae4HA)
               `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <d_ae4Hu>_N
                       :: (Typeable d_ae4Hu :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep d_ae4Hu :: *))))
           ((Data.Data.$p1Data @ e_ae4Hv $dData4_ae4HB)
            `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e_ae4Hv>_N
                    :: (Typeable e_ae4Hv :: Constraint)
                       ~R# (Data.Typeable.Internal.TypeRep e_ae4Hv :: *))))
        ((Data.Data.$p1Data @ f_ae4Hw $dData5_ae4HC)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <f_ae4Hw>_N
                 :: (Typeable f_ae4Hw :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep f_ae4Hw :: *)))

-- RHS size: {terms: 33, types: 154, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e f g.
     (Data a, Data b, Data c, Data d, Data e, Data f, Data g) =>
     forall (c1 :: * -> *).
     (forall b1 r. Data b1 => c1 (b1 -> r) -> c1 r)
     -> (forall r. r -> c1 r) -> c1 (a, b, c, d, e, f, g)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><C(C(S)),C(C1(U))><L,1*C1(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 0 420 60] 230 0}]
Data.Data.$w$cgunfold2
  = \ (@ a_sefS1)
      (@ b_sefS2)
      (@ c_sefS3)
      (@ d_sefS4)
      (@ e_sefS5)
      (@ f_sefS6)
      (@ g_sefS7)
      (w_sefS8 :: Data a_sefS1)
      (w1_sefS9 :: Data b_sefS2)
      (w2_sefSa :: Data c_sefS3)
      (w3_sefSb :: Data d_sefS4)
      (w4_sefSc :: Data e_sefS5)
      (w5_sefSd :: Data f_sefS6)
      (w6_sefSe :: Data g_sefS7)
      (@ (c1_sefSf :: * -> *))
      (w7_sefSg
         :: forall b1 r. Data b1 => c1_sefSf (b1 -> r) -> c1_sefSf r)
      (w8_sefSh :: forall r. r -> c1_sefSf r) ->
      w7_sefSg
        @ g_sefS7
        @ (a_sefS1, b_sefS2, c_sefS3, d_sefS4, e_sefS5, f_sefS6, g_sefS7)
        w6_sefSe
        (w7_sefSg
           @ f_sefS6
           @ (g_sefS7
              -> (a_sefS1, b_sefS2, c_sefS3, d_sefS4, e_sefS5, f_sefS6, g_sefS7))
           w5_sefSd
           (w7_sefSg
              @ e_sefS5
              @ (f_sefS6
                 -> g_sefS7
                 -> (a_sefS1, b_sefS2, c_sefS3, d_sefS4, e_sefS5, f_sefS6, g_sefS7))
              w4_sefSc
              (w7_sefSg
                 @ d_sefS4
                 @ (e_sefS5
                    -> f_sefS6
                    -> g_sefS7
                    -> (a_sefS1, b_sefS2, c_sefS3, d_sefS4, e_sefS5, f_sefS6, g_sefS7))
                 w3_sefSb
                 (w7_sefSg
                    @ c_sefS3
                    @ (d_sefS4
                       -> e_sefS5
                       -> f_sefS6
                       -> g_sefS7
                       -> (a_sefS1, b_sefS2, c_sefS3, d_sefS4, e_sefS5, f_sefS6, g_sefS7))
                    w2_sefSa
                    (w7_sefSg
                       @ b_sefS2
                       @ (c_sefS3
                          -> d_sefS4
                          -> e_sefS5
                          -> f_sefS6
                          -> g_sefS7
                          -> (a_sefS1, b_sefS2, c_sefS3, d_sefS4, e_sefS5, f_sefS6, g_sefS7))
                       w1_sefS9
                       (w7_sefSg
                          @ a_sefS1
                          @ (b_sefS2
                             -> c_sefS3
                             -> d_sefS4
                             -> e_sefS5
                             -> f_sefS6
                             -> g_sefS7
                             -> (a_sefS1, b_sefS2, c_sefS3, d_sefS4, e_sefS5, f_sefS6, g_sefS7))
                          w_sefS8
                          (w8_sefSh
                             @ (a_sefS1
                                -> b_sefS2
                                -> c_sefS3
                                -> d_sefS4
                                -> e_sefS5
                                -> f_sefS6
                                -> g_sefS7
                                -> (a_sefS1, b_sefS2, c_sefS3, d_sefS4, e_sefS5, f_sefS6, g_sefS7))
                             (GHC.Tuple.(,,,,,,)
                                @ a_sefS1
                                @ b_sefS2
                                @ c_sefS3
                                @ d_sefS4
                                @ e_sefS5
                                @ f_sefS6
                                @ g_sefS7))))))))

-- RHS size: {terms: 28, types: 57, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,,,)_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e f g.
     (Data a, Data b, Data c, Data d, Data e, Data f, Data g) =>
     forall (c1 :: * -> *).
     (forall b1 r. Data b1 => c1 (b1 -> r) -> c1 r)
     -> (forall r. r -> c1 r) -> Constr -> c1 (a, b, c, d, e, f, g)
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=10,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_sefS1)
                 (@ b_sefS2)
                 (@ c_sefS3)
                 (@ d_sefS4)
                 (@ e_sefS5)
                 (@ f_sefS6)
                 (@ g_sefS7)
                 (w_sefS8 [Occ=Once] :: Data a_sefS1)
                 (w1_sefS9 [Occ=Once] :: Data b_sefS2)
                 (w2_sefSa [Occ=Once] :: Data c_sefS3)
                 (w3_sefSb [Occ=Once] :: Data d_sefS4)
                 (w4_sefSc [Occ=Once] :: Data e_sefS5)
                 (w5_sefSd [Occ=Once] :: Data f_sefS6)
                 (w6_sefSe [Occ=Once] :: Data g_sefS7)
                 (@ (c1_sefSf :: * -> *))
                 (w7_sefSg [Occ=Once]
                    :: forall b1 r. Data b1 => c1_sefSf (b1 -> r) -> c1_sefSf r)
                 (w8_sefSh [Occ=Once] :: forall r. r -> c1_sefSf r)
                 _ [Occ=Dead] ->
                 Data.Data.$w$cgunfold2
                   @ a_sefS1
                   @ b_sefS2
                   @ c_sefS3
                   @ d_sefS4
                   @ e_sefS5
                   @ f_sefS6
                   @ g_sefS7
                   w_sefS8
                   w1_sefS9
                   w2_sefSa
                   w3_sefSb
                   w4_sefSc
                   w5_sefSd
                   w6_sefSe
                   @ c1_sefSf
                   w7_sefSg
                   w8_sefSh}]
Data.Data.$fData(,,,,,,)_$cgunfold
  = \ (@ a_sefS1)
      (@ b_sefS2)
      (@ c_sefS3)
      (@ d_sefS4)
      (@ e_sefS5)
      (@ f_sefS6)
      (@ g_sefS7)
      (w_sefS8 :: Data a_sefS1)
      (w1_sefS9 :: Data b_sefS2)
      (w2_sefSa :: Data c_sefS3)
      (w3_sefSb :: Data d_sefS4)
      (w4_sefSc :: Data e_sefS5)
      (w5_sefSd :: Data f_sefS6)
      (w6_sefSe :: Data g_sefS7)
      (@ (c1_sefSf :: * -> *))
      (w7_sefSg
         :: forall b1 r. Data b1 => c1_sefSf (b1 -> r) -> c1_sefSf r)
      (w8_sefSh :: forall r. r -> c1_sefSf r)
      _ [Occ=Dead] ->
      Data.Data.$w$cgunfold2
        @ a_sefS1
        @ b_sefS2
        @ c_sefS3
        @ d_sefS4
        @ e_sefS5
        @ f_sefS6
        @ g_sefS7
        w_sefS8
        w1_sefS9
        w2_sefSa
        w3_sefSb
        w4_sefSc
        w5_sefSd
        w6_sefSe
        @ c1_sefSf
        w7_sefSg
        w8_sefSh

-- RHS size: {terms: 44, types: 178, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,,,)_$cgfoldl
  :: forall a b c d e f g.
     (Data a, Data b, Data c, Data d, Data e, Data f, Data g) =>
     forall (c1 :: * -> *).
     (forall d1 b1. Data d1 => c1 (d1 -> b1) -> d1 -> c1 b1)
     -> (forall g1. g1 -> c1 g1)
     -> (a, b, c, d, e, f, g)
     -> c1 (a, b, c, d, e, f, g)
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U,U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 0 420 60 20] 310 0}]
Data.Data.$fData(,,,,,,)_$cgfoldl
  = \ (@ a_ae4De)
      (@ b_ae4Df)
      (@ c_ae4Dg)
      (@ d_ae4Dh)
      (@ e_ae4Di)
      (@ f_ae4Dj)
      (@ g_ae4Dk)
      ($dData_ae4Dl :: Data a_ae4De)
      ($dData1_ae4Dm :: Data b_ae4Df)
      ($dData2_ae4Dn :: Data c_ae4Dg)
      ($dData3_ae4Do :: Data d_ae4Dh)
      ($dData4_ae4Dp :: Data e_ae4Di)
      ($dData5_ae4Dq :: Data f_ae4Dj)
      ($dData6_ae4Dr :: Data g_ae4Dk)
      (@ (c1_ae4Dz :: * -> *))
      (k_ae2pr
         :: forall d1 b1.
            Data d1 =>
            c1_ae4Dz (d1 -> b1) -> d1 -> c1_ae4Dz b1)
      (z_ae2ps :: forall g1. g1 -> c1_ae4Dz g1)
      (ds_de7AK
         :: (a_ae4De, b_ae4Df, c_ae4Dg, d_ae4Dh, e_ae4Di, f_ae4Dj,
             g_ae4Dk)) ->
      case ds_de7AK of
      { (a1_ae2pt, a2_ae2pu, a3_ae2pv, a4_ae2pw, a5_ae2px, a6_ae2py,
         a7_ae2pz) ->
      k_ae2pr
        @ g_ae4Dk
        @ (a_ae4De, b_ae4Df, c_ae4Dg, d_ae4Dh, e_ae4Di, f_ae4Dj, g_ae4Dk)
        $dData6_ae4Dr
        (k_ae2pr
           @ f_ae4Dj
           @ (g_ae4Dk
              -> (a_ae4De, b_ae4Df, c_ae4Dg, d_ae4Dh, e_ae4Di, f_ae4Dj, g_ae4Dk))
           $dData5_ae4Dq
           (k_ae2pr
              @ e_ae4Di
              @ (f_ae4Dj
                 -> g_ae4Dk
                 -> (a_ae4De, b_ae4Df, c_ae4Dg, d_ae4Dh, e_ae4Di, f_ae4Dj, g_ae4Dk))
              $dData4_ae4Dp
              (k_ae2pr
                 @ d_ae4Dh
                 @ (e_ae4Di
                    -> f_ae4Dj
                    -> g_ae4Dk
                    -> (a_ae4De, b_ae4Df, c_ae4Dg, d_ae4Dh, e_ae4Di, f_ae4Dj, g_ae4Dk))
                 $dData3_ae4Do
                 (k_ae2pr
                    @ c_ae4Dg
                    @ (d_ae4Dh
                       -> e_ae4Di
                       -> f_ae4Dj
                       -> g_ae4Dk
                       -> (a_ae4De, b_ae4Df, c_ae4Dg, d_ae4Dh, e_ae4Di, f_ae4Dj, g_ae4Dk))
                    $dData2_ae4Dn
                    (k_ae2pr
                       @ b_ae4Df
                       @ (c_ae4Dg
                          -> d_ae4Dh
                          -> e_ae4Di
                          -> f_ae4Dj
                          -> g_ae4Dk
                          -> (a_ae4De, b_ae4Df, c_ae4Dg, d_ae4Dh, e_ae4Di, f_ae4Dj, g_ae4Dk))
                       $dData1_ae4Dm
                       (k_ae2pr
                          @ a_ae4De
                          @ (b_ae4Df
                             -> c_ae4Dg
                             -> d_ae4Dh
                             -> e_ae4Di
                             -> f_ae4Dj
                             -> g_ae4Dk
                             -> (a_ae4De, b_ae4Df, c_ae4Dg, d_ae4Dh, e_ae4Di, f_ae4Dj, g_ae4Dk))
                          $dData_ae4Dl
                          (z_ae2ps
                             @ (a_ae4De
                                -> b_ae4Df
                                -> c_ae4Dg
                                -> d_ae4Dh
                                -> e_ae4Di
                                -> f_ae4Dj
                                -> g_ae4Dk
                                -> (a_ae4De, b_ae4Df, c_ae4Dg, d_ae4Dh, e_ae4Di, f_ae4Dj, g_ae4Dk))
                             (GHC.Tuple.(,,,,,,)
                                @ a_ae4De
                                @ b_ae4Df
                                @ c_ae4Dg
                                @ d_ae4Dh
                                @ e_ae4Di
                                @ f_ae4Dj
                                @ g_ae4Dk))
                          a1_ae2pt)
                       a2_ae2pu)
                    a3_ae2pv)
                 a4_ae2pw)
              a5_ae2px)
           a6_ae2py)
        a7_ae2pz
      }

-- RHS size: {terms: 16, types: 89, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,,,)8
  :: Data.Typeable.Internal.TypeRep (,,,,,,)
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fData(,,,,,,)8
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> * -> * -> * -> * -> * -> * -> *)
           @ (,,,,,,)
           15717406936698455762##
           885835128333027932##
           GHC.Tuple.$trModule
           GHC.Tuple.$tc(,,,,,,)2
           0#
           GHC.Tuple.$tc(,,,,,,)1
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> * -> * -> * -> * -> * -> * -> *)
      @ (,,,,,,)
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 36, types: 140, coercions: 28, joins: 0/0}
Data.Data.$fData(,,,,,,)7
  :: forall a b c d e f g.
     (Data a, Data b, Data c, Data d, Data e, Data f, Data g) =>
     Data.Typeable.Internal.TypeRep (a, b, c, d, e, f, g)
[GblId,
 Arity=7,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 30 30 30 30] 350 0}]
Data.Data.$fData(,,,,,,)7
  = \ (@ a_ae4De)
      (@ b_ae4Df)
      (@ c_ae4Dg)
      (@ d_ae4Dh)
      (@ e_ae4Di)
      (@ f_ae4Dj)
      (@ g_ae4Dk)
      ($dData_ae4Dl :: Data a_ae4De)
      ($dData1_ae4Dm :: Data b_ae4Df)
      ($dData2_ae4Dn :: Data c_ae4Dg)
      ($dData3_ae4Do :: Data d_ae4Dh)
      ($dData4_ae4Dp :: Data e_ae4Di)
      ($dData5_ae4Dq :: Data f_ae4Dj)
      ($dData6_ae4Dr :: Data g_ae4Dk) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ ((,,,,,,) a_ae4De b_ae4Df c_ae4Dg d_ae4Dh e_ae4Di f_ae4Dj)
        @ g_ae4Dk
        (Data.Typeable.Internal.mkTrApp
           @ *
           @ (* -> *)
           @ ((,,,,,,) a_ae4De b_ae4Df c_ae4Dg d_ae4Dh e_ae4Di)
           @ f_ae4Dj
           (Data.Typeable.Internal.mkTrApp
              @ *
              @ (* -> * -> *)
              @ ((,,,,,,) a_ae4De b_ae4Df c_ae4Dg d_ae4Dh)
              @ e_ae4Di
              (Data.Typeable.Internal.mkTrApp
                 @ *
                 @ (* -> * -> * -> *)
                 @ ((,,,,,,) a_ae4De b_ae4Df c_ae4Dg)
                 @ d_ae4Dh
                 (Data.Typeable.Internal.mkTrApp
                    @ *
                    @ (* -> * -> * -> * -> *)
                    @ ((,,,,,,) a_ae4De b_ae4Df)
                    @ c_ae4Dg
                    (Data.Typeable.Internal.mkTrApp
                       @ *
                       @ (* -> * -> * -> * -> * -> *)
                       @ ((,,,,,,) a_ae4De)
                       @ b_ae4Df
                       (Data.Typeable.Internal.mkTrApp
                          @ *
                          @ (* -> * -> * -> * -> * -> * -> *)
                          @ (,,,,,,)
                          @ a_ae4De
                          Data.Data.$fData(,,,,,,)8
                          ((Data.Data.$p1Data @ a_ae4De $dData_ae4Dl)
                           `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae4De>_N
                                   :: (Typeable a_ae4De :: Constraint)
                                      ~R# (Data.Typeable.Internal.TypeRep a_ae4De :: *))))
                       ((Data.Data.$p1Data @ b_ae4Df $dData1_ae4Dm)
                        `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <b_ae4Df>_N
                                :: (Typeable b_ae4Df :: Constraint)
                                   ~R# (Data.Typeable.Internal.TypeRep b_ae4Df :: *))))
                    ((Data.Data.$p1Data @ c_ae4Dg $dData2_ae4Dn)
                     `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <c_ae4Dg>_N
                             :: (Typeable c_ae4Dg :: Constraint)
                                ~R# (Data.Typeable.Internal.TypeRep c_ae4Dg :: *))))
                 ((Data.Data.$p1Data @ d_ae4Dh $dData3_ae4Do)
                  `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <d_ae4Dh>_N
                          :: (Typeable d_ae4Dh :: Constraint)
                             ~R# (Data.Typeable.Internal.TypeRep d_ae4Dh :: *))))
              ((Data.Data.$p1Data @ e_ae4Di $dData4_ae4Dp)
               `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e_ae4Di>_N
                       :: (Typeable e_ae4Di :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep e_ae4Di :: *))))
           ((Data.Data.$p1Data @ f_ae4Dj $dData5_ae4Dq)
            `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <f_ae4Dj>_N
                    :: (Typeable f_ae4Dj :: Constraint)
                       ~R# (Data.Typeable.Internal.TypeRep f_ae4Dj :: *))))
        ((Data.Data.$p1Data @ g_ae4Dk $dData6_ae4Dr)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <g_ae4Dk>_N
                 :: (Typeable g_ae4Dk :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep g_ae4Dk :: *)))

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataIntPtr8 :: Data.Typeable.Internal.TypeRep IntPtr
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataIntPtr8
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ IntPtr
           12538429555661790394##
           9943980142794044772##
           Foreign.Ptr.$trModule
           Foreign.Ptr.$tcIntPtr1
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ IntPtr ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataWordPtr8 :: Data.Typeable.Internal.TypeRep WordPtr
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataWordPtr8
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ WordPtr
           10827112719629138107##
           3588783739676187441##
           Foreign.Ptr.$trModule
           Foreign.Ptr.$tcWordPtr1
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ WordPtr ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 33, types: 71, coercions: 0, joins: 0/0}
Data.Data.$fData:*:11 :: Data.Typeable.Internal.TypeRep *
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 230 0}]
Data.Data.$fData:*:11
  = case Data.Typeable.Internal.$wmkTrCon
           @ (RuntimeRep -> *)
           @ TYPE
           16277905407886699876##
           12502576999761269576##
           GHC.Types.tr$ModuleGHCPrim
           GHC.Types.$tcTYPE2
           0#
           GHC.Types.$tcTYPE1
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    case Data.Typeable.Internal.$wmkTrCon
           @ RuntimeRep
           @ 'LiftedRep
           16105171405184389724##
           5595830777317938557##
           GHC.Types.tr$ModuleGHCPrim
           GHC.Types.$tc'LiftedRep1
           0#
           GHC.Types.$tc'AddrRep1
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww2_XdQlC, ww3_XdQlE, ww4_XdQlG, ww5_XdQlI, ww6_XdQlK #) ->
    Data.Typeable.Internal.mkTrApp
      @ RuntimeRep
      @ *
      @ TYPE
      @ 'LiftedRep
      (Data.Typeable.Internal.TrTyCon
         @ (RuntimeRep -> *)
         @ TYPE
         ww8_idPJm
         ww9_idPJn
         ww10_idPJo
         ww11_idPJp
         ww12_idPJq)
      (Data.Typeable.Internal.TrTyCon
         @ RuntimeRep
         @ 'LiftedRep
         ww2_XdQlC
         ww3_XdQlE
         ww4_XdQlG
         ww5_XdQlI
         ww6_XdQlK)
    }
    }

-- RHS size: {terms: 2, types: 4, coercions: 0, joins: 0/0}
Data.Data.$fData:*:10 :: Data.Typeable.Internal.SomeTypeRep
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fData:*:10
  = Data.Typeable.Internal.SomeTypeRep @ * @ * Data.Data.$fData:*:11

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fData:*:9 :: [Data.Typeable.Internal.SomeTypeRep]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData:*:9
  = GHC.Types.:
      @ Data.Typeable.Internal.SomeTypeRep
      Data.Data.$fData:*:10
      (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)

-- RHS size: {terms: 16, types: 44, coercions: 0, joins: 0/0}
Data.Data.$fDataProxy7 :: Data.Typeable.Internal.TypeRep Proxy
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataProxy7
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ Proxy
           11117694004322800938##
           2653577047990140727##
           Data.Proxy.$trModule
           Data.Proxy.$tcProxy2
           1#
           Data.Proxy.$tcProxy1
           Data.Data.$fData:*:9
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ Proxy
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 6, types: 13, coercions: 4, joins: 0/0}
Data.Data.$fDataProxy6
  :: forall t. Data t => Data.Typeable.Internal.TypeRep (Proxy t)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ t_ae4tJ) ($dData_ae4tK [Occ=Once] :: Data t_ae4tJ) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Proxy
                   @ t_ae4tJ
                   Data.Data.$fDataProxy7
                   ((Data.Data.$p1Data @ t_ae4tJ $dData_ae4tK)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <t_ae4tJ>_N
                            :: (Typeable t_ae4tJ :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep t_ae4tJ :: *)))}]
Data.Data.$fDataProxy6
  = \ (@ t_ae4tJ) ($dData_ae4tK :: Data t_ae4tJ) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ Proxy
        @ t_ae4tJ
        Data.Data.$fDataProxy7
        ((Data.Data.$p1Data @ t_ae4tJ $dData_ae4tK)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <t_ae4tJ>_N
                 :: (Typeable t_ae4tJ :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep t_ae4tJ :: *)))

-- RHS size: {terms: 16, types: 52, coercions: 0, joins: 0/0}
Data.Data.$fData:~:6 :: Data.Typeable.Internal.TypeRep (:~:)
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fData:~:6
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> * -> *)
           @ (:~:)
           10597498348876412676##
           16281320961088145472##
           Data.Type.Equality.$trModule
           Data.Type.Equality.$tc:~:2
           1#
           Data.Type.Equality.$tc:~:1
           Data.Data.$fData:*:9
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> * -> *)
      @ (:~:)
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 16, types: 48, coercions: 23, joins: 0/1}
Data.Data.$fData:~:_$cp1Data
  :: forall a b. ((a :: *) ~ (b :: *), Data a) => Typeable (a :~: b)
[GblId,
 Arity=2,
 Str=<S(S),1*U(1*U)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 30] 120 0}]
Data.Data.$fData:~:_$cp1Data
  = \ (@ a_ae4qq)
      (@ b_ae4qr)
      ($d~_ae4qs :: (a_ae4qq :: *) ~ (b_ae4qr :: *))
      ($dData_ae4qt :: Data a_ae4qq) ->
      case GHC.Types.heq_sel
             @ *
             @ *
             @ a_ae4qq
             @ b_ae4qr
             ($d~_ae4qs
              `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae4qq>_N <b_ae4qr>_N
                      :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                         ~R# ((a_ae4qq :: *) ~~ (b_ae4qr :: *) :: Constraint)))
      of co_ae6JW
      { __DEFAULT ->
      let {
        $dTypeable_se9wK [Dmd=<S,U>] :: Typeable a_ae4qq
        [LclId]
        $dTypeable_se9wK = Data.Data.$p1Data @ a_ae4qq $dData_ae4qt } in
      (Data.Typeable.Internal.mkTrApp
         @ *
         @ *
         @ ((:~:) b_ae4qr)
         @ b_ae4qr
         (Data.Typeable.Internal.mkTrApp
            @ *
            @ (* -> *)
            @ (:~:)
            @ b_ae4qr
            Data.Data.$fData:~:6
            ($dTypeable_se9wK
             `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N co_ae6JW
                     :: (Typeable a_ae4qq :: Constraint)
                        ~R# (Data.Typeable.Internal.TypeRep b_ae4qr :: *))))
         ($dTypeable_se9wK
          `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N co_ae6JW
                  :: (Typeable a_ae4qq :: Constraint)
                     ~R# (Data.Typeable.Internal.TypeRep b_ae4qr :: *))))
      `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N ((:~:)
                                                                  <*>_N
                                                                  (Sym co_ae6JW)
                                                                  <b_ae4qr>_N)_N
              :: (Data.Typeable.Internal.TypeRep (b_ae4qr :~: b_ae4qr) :: *)
                 ~R# (Typeable (a_ae4qq :~: b_ae4qr) :: Constraint))
      }

-- RHS size: {terms: 37, types: 96, coercions: 65, joins: 0/0}
Data.Data.$w$cp1Data [InlPrag=NOUSERINLINE[0]]
  :: forall i j (a :: i) (b :: j).
     (Typeable i, Typeable a, (a :: i) ~~ (b :: j)) =>
     Typeable (a :~~: b)
[GblId,
 Arity=3,
 Str=<L,U><S,U><S(S),1*U(1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 30] 230 0}]
Data.Data.$w$cp1Data
  = \ (@ i_sefT4)
      (@ j_sefT5)
      (@ (a_sefT6 :: i_sefT4))
      (@ (b_sefT7 :: j_sefT5))
      (w_sefT8 :: Typeable i_sefT4)
      (w1_sefTa :: Typeable a_sefT6)
      (w2_sefTc :: (a_sefT6 :: i_sefT4) ~~ (b_sefT7 :: j_sefT5)) ->
      case GHC.Types.heq_sel
             @ i_sefT4 @ j_sefT5 @ a_sefT6 @ b_sefT7 w2_sefTc
      of co_ae6J2
      { __DEFAULT ->
      case Data.Typeable.Internal.$wmkTrCon
             @ (j_sefT5 -> j_sefT5 -> *)
             @ (:~~:)
             4361259188665111259##
             11706467685470543992##
             Data.Type.Equality.$trModule
             Data.Type.Equality.$tc:~~:2
             2#
             Data.Type.Equality.$tc:~~:1
             (GHC.Types.:
                @ Data.Typeable.Internal.SomeTypeRep
                (Data.Typeable.Internal.SomeTypeRep
                   @ *
                   @ j_sefT5
                   (w_sefT8
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N (Kind co_ae6J2)
                            :: (Typeable i_sefT4 :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep j_sefT5 :: *))))
                (GHC.Types.:
                   @ Data.Typeable.Internal.SomeTypeRep
                   (Data.Typeable.Internal.SomeTypeRep
                      @ *
                      @ j_sefT5
                      (w_sefT8
                       `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N (Kind co_ae6J2)
                               :: (Typeable i_sefT4 :: Constraint)
                                  ~R# (Data.Typeable.Internal.TypeRep j_sefT5 :: *))))
                   (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)))
      of
      { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
      (Data.Typeable.Internal.mkTrApp
         @ j_sefT5
         @ *
         @ ((:~~:) b_sefT7)
         @ b_sefT7
         (Data.Typeable.Internal.mkTrApp
            @ j_sefT5
            @ (j_sefT5 -> *)
            @ (:~~:)
            @ b_sefT7
            (Data.Typeable.Internal.TrTyCon
               @ (j_sefT5 -> j_sefT5 -> *)
               @ (:~~:)
               ww8_idPJm
               ww9_idPJn
               ww10_idPJo
               ww11_idPJp
               ww12_idPJq)
            (w1_sefTa
             `cast` (Data.Typeable.Internal.N:Typeable[0] (Kind
                                                               co_ae6J2) (Sym (Coh (Sym co_ae6J2)
                                                                                   (Sym (Kind
                                                                                             co_ae6J2))) ; Coh <b_sefT7>_N
                                                                                                               (Sym (Kind
                                                                                                                         co_ae6J2)))
                     :: (Typeable a_sefT6 :: Constraint)
                        ~R# (Data.Typeable.Internal.TypeRep b_sefT7 :: *))))
         (w1_sefTa
          `cast` (Data.Typeable.Internal.N:Typeable[0] (Kind
                                                            co_ae6J2) (Sym (Coh (Sym co_ae6J2)
                                                                                (Sym (Kind
                                                                                          co_ae6J2))) ; Coh <b_sefT7>_N
                                                                                                            (Sym (Kind
                                                                                                                      co_ae6J2)))
                  :: (Typeable a_sefT6 :: Constraint)
                     ~R# (Data.Typeable.Internal.TypeRep b_sefT7 :: *))))
      `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N ((:~~:)
                                                                  (Sym (Kind co_ae6J2))
                                                                  <j_sefT5>_N
                                                                  (Sym (Coh <b_sefT7>_N
                                                                            (Sym (Kind
                                                                                      co_ae6J2))) ; Coh (Sym co_ae6J2)
                                                                                                        (Sym (Kind
                                                                                                                  co_ae6J2)))
                                                                  <b_sefT7>_N)_N
              :: (Data.Typeable.Internal.TypeRep (b_sefT7 :~~: b_sefT7) :: *)
                 ~R# (Typeable (a_sefT6 :~~: b_sefT7) :: Constraint))
      }
      }

-- RHS size: {terms: 13, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fData:~~:_$cp1Data [InlPrag=NOUSERINLINE[0]]
  :: forall i j (a :: i) (b :: j).
     (Typeable i, Typeable j, Typeable a, Typeable b,
      (a :: i) ~~ (b :: j)) =>
     Typeable (a :~~: b)
[GblId,
 Arity=5,
 Str=<L,U><L,A><S,U><L,A><S(S),1*U(1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ i_sefT4)
                 (@ j_sefT5)
                 (@ (a_sefT6 :: i_sefT4))
                 (@ (b_sefT7 :: j_sefT5))
                 (w_sefT8 [Occ=Once] :: Typeable i_sefT4)
                 _ [Occ=Dead]
                 (w2_sefTa [Occ=Once] :: Typeable a_sefT6)
                 _ [Occ=Dead]
                 (w4_sefTc [Occ=Once]
                    :: (a_sefT6 :: i_sefT4) ~~ (b_sefT7 :: j_sefT5)) ->
                 Data.Data.$w$cp1Data
                   @ i_sefT4 @ j_sefT5 @ a_sefT6 @ b_sefT7 w_sefT8 w2_sefTa w4_sefTc}]
Data.Data.$fData:~~:_$cp1Data
  = \ (@ i_sefT4)
      (@ j_sefT5)
      (@ (a_sefT6 :: i_sefT4))
      (@ (b_sefT7 :: j_sefT5))
      (w_sefT8 :: Typeable i_sefT4)
      _ [Occ=Dead]
      (w2_sefTa :: Typeable a_sefT6)
      _ [Occ=Dead]
      (w4_sefTc :: (a_sefT6 :: i_sefT4) ~~ (b_sefT7 :: j_sefT5)) ->
      Data.Data.$w$cp1Data
        @ i_sefT4 @ j_sefT5 @ a_sefT6 @ b_sefT7 w_sefT8 w2_sefTa w4_sefTc

-- RHS size: {terms: 16, types: 52, coercions: 0, joins: 0/0}
Data.Data.$fDataCoercion6
  :: Data.Typeable.Internal.TypeRep Coercion
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataCoercion6
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> * -> *)
           @ Coercion
           14885566513674463733##
           8268940906925368652##
           Data.Type.Coercion.$trModule
           Data.Type.Coercion.$tcCoercion2
           1#
           Data.Type.Coercion.$tcCoercion1
           Data.Data.$fData:*:9
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> * -> *)
      @ Coercion
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 12, types: 34, coercions: 8, joins: 0/0}
Data.Data.$fDataCoercion5
  :: forall a b.
     (Coercible a b, Data a, Data b) =>
     Data.Typeable.Internal.TypeRep (Coercion a b)
[GblId,
 Arity=3,
 Str=<L,A><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae4jC)
                 (@ b_ae4jD)
                 _ [Occ=Dead]
                 ($dData_ae4jF [Occ=Once] :: Data a_ae4jC)
                 ($dData1_ae4jG [Occ=Once] :: Data b_ae4jD) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ (Coercion a_ae4jC)
                   @ b_ae4jD
                   (Data.Typeable.Internal.mkTrApp
                      @ *
                      @ (* -> *)
                      @ Coercion
                      @ a_ae4jC
                      Data.Data.$fDataCoercion6
                      ((Data.Data.$p1Data @ a_ae4jC $dData_ae4jF)
                       `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae4jC>_N
                               :: (Typeable a_ae4jC :: Constraint)
                                  ~R# (Data.Typeable.Internal.TypeRep a_ae4jC :: *))))
                   ((Data.Data.$p1Data @ b_ae4jD $dData1_ae4jG)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <b_ae4jD>_N
                            :: (Typeable b_ae4jD :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep b_ae4jD :: *)))}]
Data.Data.$fDataCoercion5
  = \ (@ a_ae4jC)
      (@ b_ae4jD)
      _ [Occ=Dead]
      ($dData_ae4jF :: Data a_ae4jC)
      ($dData1_ae4jG :: Data b_ae4jD) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ (Coercion a_ae4jC)
        @ b_ae4jD
        (Data.Typeable.Internal.mkTrApp
           @ *
           @ (* -> *)
           @ Coercion
           @ a_ae4jC
           Data.Data.$fDataCoercion6
           ((Data.Data.$p1Data @ a_ae4jC $dData_ae4jF)
            `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae4jC>_N
                    :: (Typeable a_ae4jC :: Constraint)
                       ~R# (Data.Typeable.Internal.TypeRep a_ae4jC :: *))))
        ((Data.Data.$p1Data @ b_ae4jD $dData1_ae4jG)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <b_ae4jD>_N
                 :: (Typeable b_ae4jD :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep b_ae4jD :: *)))

-- RHS size: {terms: 16, types: 41, coercions: 0, joins: 0/0}
Data.Data.$fDataIdentity2
  :: Data.Typeable.Internal.TypeRep Identity
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataIdentity2
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ Identity
           3410104521590905987##
           16392070908630191652##
           Data.Functor.Identity.$trModule
           Data.Functor.Identity.$tcIdentity1
           0#
           GHC.Types.krep$*Arr*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ Identity
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 18, types: 44, coercions: 12, joins: 0/1}
Data.Data.$fDataIdentity_$cdataCast1
  :: forall a.
     Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Identity a))
[GblId,
 Arity=2,
 Str=<L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 100 60}]
Data.Data.$fDataIdentity_$cdataCast1
  = \ (@ a_ae4go)
      ($dData_ae4gp :: Data a_ae4go)
      (@ (t_ae4h1 :: * -> *))
      (@ (c_ae4h2 :: * -> *))
      ($dTypeable_ae4h4 :: Typeable t_ae4h1) ->
      let {
        lvl270_se9zK :: Bool
        [LclId]
        lvl270_se9zK
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_ae4h1
              @ Identity
              ($dTypeable_ae4h4
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_ae4h1>_N
                       :: (Typeable t_ae4h1 :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_ae4h1 :: *)))
              Data.Data.$fDataIdentity2 } in
      \ (f_ae2p0 :: forall d. Data d => c_ae4h2 (t_ae4h1 d)) ->
        case lvl270_se9zK of {
          False -> GHC.Base.Nothing @ (c_ae4h2 (Identity a_ae4go));
          True ->
            GHC.Base.Just
              @ (c_ae4h2 (Identity a_ae4go))
              ((f_ae2p0 @ a_ae4go $dData_ae4gp)
               `cast` (<c_ae4h2>_R (UnsafeCo nominal t_ae4h1 Identity <a_ae4go>_N)
                       :: (c_ae4h2 (t_ae4h1 a_ae4go) :: *)
                          ~R# (c_ae4h2 (Identity a_ae4go) :: *)))
        }

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
Data.Data.$fDataConst2 :: forall a. a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_ae4go) (v_B1 [Occ=Once] :: a_ae4go) -> v_B1}]
Data.Data.$fDataConst2 = \ (@ a_ae4go) (v_B1 :: a_ae4go) -> v_B1

-- RHS size: {terms: 11, types: 34, coercions: 7, joins: 0/0}
Data.Data.$fDataIdentity_$cgfoldl
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Identity a -> c (Identity a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae4go)
                 ($dData_ae4gp [Occ=Once] :: Data a_ae4go)
                 (@ (c_ae4gx :: * -> *))
                 (k_ae2oV [Occ=Once!]
                    :: forall d b. Data d => c_ae4gx (d -> b) -> d -> c_ae4gx b)
                 (z_ae2oW [Occ=Once!] :: forall g. g -> c_ae4gx g)
                 (ds_de7yv [Occ=Once] :: Identity a_ae4go) ->
                 k_ae2oV
                   @ a_ae4go
                   @ (Identity a_ae4go)
                   $dData_ae4gp
                   (z_ae2oW
                      @ (a_ae4go -> Identity a_ae4go)
                      ((Data.Data.$fDataConst2 @ a_ae4go)
                       `cast` (<a_ae4go>_R
                               ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_ae4go>_R)
                               :: (a_ae4go -> a_ae4go :: *)
                                  ~R# (a_ae4go -> Identity a_ae4go :: *))))
                   (ds_de7yv
                    `cast` (Data.Functor.Identity.N:Identity[0] <a_ae4go>_R
                            :: (Identity a_ae4go :: *) ~R# (a_ae4go :: *)))}]
Data.Data.$fDataIdentity_$cgfoldl
  = \ (@ a_ae4go)
      ($dData_ae4gp :: Data a_ae4go)
      (@ (c_ae4gx :: * -> *))
      (k_ae2oV
         :: forall d b. Data d => c_ae4gx (d -> b) -> d -> c_ae4gx b)
      (z_ae2oW :: forall g. g -> c_ae4gx g)
      (ds_de7yv :: Identity a_ae4go) ->
      k_ae2oV
        @ a_ae4go
        @ (Identity a_ae4go)
        $dData_ae4gp
        (z_ae2oW
           @ (a_ae4go -> Identity a_ae4go)
           ((Data.Data.$fDataConst2 @ a_ae4go)
            `cast` (<a_ae4go>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_ae4go>_R)
                    :: (a_ae4go -> a_ae4go :: *)
                       ~R# (a_ae4go -> Identity a_ae4go :: *))))
        (ds_de7yv
         `cast` (Data.Functor.Identity.N:Identity[0] <a_ae4go>_R
                 :: (Identity a_ae4go :: *) ~R# (a_ae4go :: *)))

-- RHS size: {terms: 6, types: 11, coercions: 4, joins: 0/0}
Data.Data.$fDataIdentity7
  :: forall a. Data a => Data.Typeable.Internal.TypeRep (Identity a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae4go) ($dData_ae4gp [Occ=Once] :: Data a_ae4go) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Identity
                   @ a_ae4go
                   Data.Data.$fDataIdentity2
                   ((Data.Data.$p1Data @ a_ae4go $dData_ae4gp)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae4go>_N
                            :: (Typeable a_ae4go :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep a_ae4go :: *)))}]
Data.Data.$fDataIdentity7
  = \ (@ a_ae4go) ($dData_ae4gp :: Data a_ae4go) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ Identity
        @ a_ae4go
        Data.Data.$fDataIdentity2
        ((Data.Data.$p1Data @ a_ae4go $dData_ae4gp)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae4go>_N
                 :: (Typeable a_ae4go :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep a_ae4go :: *)))

-- RHS size: {terms: 30, types: 81, coercions: 11, joins: 0/0}
Data.Data.$fDataConst7
  :: forall k a (b :: k).
     (Typeable k, Data a, Typeable b) =>
     Data.Typeable.Internal.TypeRep (Const a b)
[GblId,
 Arity=3,
 Str=<L,U><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 30 0] 200 0}]
Data.Data.$fDataConst7
  = \ (@ k_ae4d1)
      (@ a_ae4d2)
      (@ (b_ae4d3 :: k_ae4d1))
      ($dTypeable_ae4d4 :: Typeable k_ae4d1)
      ($dData_ae4d5 :: Data a_ae4d2)
      ($dTypeable1_ae4d6 :: Typeable b_ae4d3) ->
      case Data.Typeable.Internal.$wmkTrCon
             @ (* -> k_ae4d1 -> *)
             @ Const
             18204097321285842582##
             16882168546145866005##
             Data.Functor.Const.$trModule
             Data.Functor.Const.$tcConst2
             1#
             Data.Functor.Const.$tcConst1
             (GHC.Types.:
                @ Data.Typeable.Internal.SomeTypeRep
                (Data.Typeable.Internal.SomeTypeRep
                   @ *
                   @ k_ae4d1
                   ($dTypeable_ae4d4
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <k_ae4d1>_N
                            :: (Typeable k_ae4d1 :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep k_ae4d1 :: *))))
                (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep))
      of
      { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
      Data.Typeable.Internal.mkTrApp
        @ k_ae4d1
        @ *
        @ (Const a_ae4d2)
        @ b_ae4d3
        (Data.Typeable.Internal.mkTrApp
           @ *
           @ (k_ae4d1 -> *)
           @ Const
           @ a_ae4d2
           (Data.Typeable.Internal.TrTyCon
              @ (* -> k_ae4d1 -> *)
              @ Const
              ww8_idPJm
              ww9_idPJn
              ww10_idPJo
              ww11_idPJp
              ww12_idPJq)
           ((Data.Data.$p1Data @ a_ae4d2 $dData_ae4d5)
            `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae4d2>_N
                    :: (Typeable a_ae4d2 :: Constraint)
                       ~R# (Data.Typeable.Internal.TypeRep a_ae4d2 :: *))))
        ($dTypeable1_ae4d6
         `cast` (Data.Typeable.Internal.N:Typeable[0] <k_ae4d1>_N <b_ae4d3>_N
                 :: (Typeable b_ae4d3 :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep b_ae4d3 :: *)))
      }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataVersion8 :: Data.Typeable.Internal.TypeRep Version
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataVersion8
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Version
           18148779789861942324##
           12675349638857785520##
           Data.Version.$trModule
           Data.Version.$tcVersion1
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ Version ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 16, types: 41, coercions: 0, joins: 0/0}
Data.Data.$fDataDual2 :: Data.Typeable.Internal.TypeRep Dual
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataDual2
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ Dual
           14711416616195557841##
           10971851269997195248##
           Data.Semigroup.Internal.$trModule
           Data.Semigroup.Internal.$tcDual1
           0#
           GHC.Types.krep$*Arr*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ Dual
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 18, types: 44, coercions: 12, joins: 0/1}
Data.Data.$fDataDual_$cdataCast1
  :: forall a.
     Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Dual a))
[GblId,
 Arity=2,
 Str=<L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 100 60}]
Data.Data.$fDataDual_$cdataCast1
  = \ (@ a_ae46w)
      ($dData_ae46x :: Data a_ae46w)
      (@ (t_ae479 :: * -> *))
      (@ (c_ae47a :: * -> *))
      ($dTypeable_ae47c :: Typeable t_ae479) ->
      let {
        lvl270_se9zQ :: Bool
        [LclId]
        lvl270_se9zQ
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_ae479
              @ Dual
              ($dTypeable_ae47c
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_ae479>_N
                       :: (Typeable t_ae479 :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_ae479 :: *)))
              Data.Data.$fDataDual2 } in
      \ (f_ae2oJ :: forall d. Data d => c_ae47a (t_ae479 d)) ->
        case lvl270_se9zQ of {
          False -> GHC.Base.Nothing @ (c_ae47a (Dual a_ae46w));
          True ->
            GHC.Base.Just
              @ (c_ae47a (Dual a_ae46w))
              ((f_ae2oJ @ a_ae46w $dData_ae46x)
               `cast` (<c_ae47a>_R (UnsafeCo nominal t_ae479 Dual <a_ae46w>_N)
                       :: (c_ae47a (t_ae479 a_ae46w) :: *)
                          ~R# (c_ae47a (Dual a_ae46w) :: *)))
        }

-- RHS size: {terms: 11, types: 34, coercions: 7, joins: 0/0}
Data.Data.$fDataDual_$cgfoldl
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Dual a -> c (Dual a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae46w)
                 ($dData_ae46x [Occ=Once] :: Data a_ae46w)
                 (@ (c_ae46F :: * -> *))
                 (k_ae2oE [Occ=Once!]
                    :: forall d b. Data d => c_ae46F (d -> b) -> d -> c_ae46F b)
                 (z_ae2oF [Occ=Once!] :: forall g. g -> c_ae46F g)
                 (ds_de7xx [Occ=Once] :: Dual a_ae46w) ->
                 k_ae2oE
                   @ a_ae46w
                   @ (Dual a_ae46w)
                   $dData_ae46x
                   (z_ae2oF
                      @ (a_ae46w -> Dual a_ae46w)
                      ((Data.Data.$fDataConst2 @ a_ae46w)
                       `cast` (<a_ae46w>_R
                               ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <a_ae46w>_R)
                               :: (a_ae46w -> a_ae46w :: *) ~R# (a_ae46w -> Dual a_ae46w :: *))))
                   (ds_de7xx
                    `cast` (Data.Semigroup.Internal.N:Dual[0] <a_ae46w>_R
                            :: (Dual a_ae46w :: *) ~R# (a_ae46w :: *)))}]
Data.Data.$fDataDual_$cgfoldl
  = \ (@ a_ae46w)
      ($dData_ae46x :: Data a_ae46w)
      (@ (c_ae46F :: * -> *))
      (k_ae2oE
         :: forall d b. Data d => c_ae46F (d -> b) -> d -> c_ae46F b)
      (z_ae2oF :: forall g. g -> c_ae46F g)
      (ds_de7xx :: Dual a_ae46w) ->
      k_ae2oE
        @ a_ae46w
        @ (Dual a_ae46w)
        $dData_ae46x
        (z_ae2oF
           @ (a_ae46w -> Dual a_ae46w)
           ((Data.Data.$fDataConst2 @ a_ae46w)
            `cast` (<a_ae46w>_R
                    ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <a_ae46w>_R)
                    :: (a_ae46w -> a_ae46w :: *) ~R# (a_ae46w -> Dual a_ae46w :: *))))
        (ds_de7xx
         `cast` (Data.Semigroup.Internal.N:Dual[0] <a_ae46w>_R
                 :: (Dual a_ae46w :: *) ~R# (a_ae46w :: *)))

-- RHS size: {terms: 6, types: 11, coercions: 4, joins: 0/0}
Data.Data.$fDataDual7
  :: forall a. Data a => Data.Typeable.Internal.TypeRep (Dual a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae46w) ($dData_ae46x [Occ=Once] :: Data a_ae46w) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Dual
                   @ a_ae46w
                   Data.Data.$fDataDual2
                   ((Data.Data.$p1Data @ a_ae46w $dData_ae46x)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae46w>_N
                            :: (Typeable a_ae46w :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep a_ae46w :: *)))}]
Data.Data.$fDataDual7
  = \ (@ a_ae46w) ($dData_ae46x :: Data a_ae46w) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ Dual
        @ a_ae46w
        Data.Data.$fDataDual2
        ((Data.Data.$p1Data @ a_ae46w $dData_ae46x)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae46w>_N
                 :: (Typeable a_ae46w :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep a_ae46w :: *)))

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataAll8 :: Data.Typeable.Internal.TypeRep All
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataAll8
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ All
           14149274874874504208##
           8164254778609961234##
           Data.Semigroup.Internal.$trModule
           Data.Semigroup.Internal.$tcAll1
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ All ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataAny7 :: Data.Typeable.Internal.TypeRep Any
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataAny7
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Any
           11600287624241135668##
           17600231731807245316##
           Data.Semigroup.Internal.$trModule
           Data.Semigroup.Internal.$tcAny1
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ Any ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 16, types: 41, coercions: 0, joins: 0/0}
Data.Data.$fDataSum2 :: Data.Typeable.Internal.TypeRep Sum
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataSum2
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ Sum
           7521450980204740829##
           14029043805042477297##
           Data.Semigroup.Internal.$trModule
           Data.Semigroup.Internal.$tcSum1
           0#
           GHC.Types.krep$*Arr*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ Sum
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 18, types: 44, coercions: 12, joins: 0/1}
Data.Data.$fDataSum_$cdataCast1
  :: forall a.
     Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Sum a))
[GblId,
 Arity=2,
 Str=<L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 100 60}]
Data.Data.$fDataSum_$cdataCast1
  = \ (@ a_ae3WW)
      ($dData_ae3WX :: Data a_ae3WW)
      (@ (t_ae3Xz :: * -> *))
      (@ (c_ae3XA :: * -> *))
      ($dTypeable_ae3XC :: Typeable t_ae3Xz) ->
      let {
        lvl270_se9zW :: Bool
        [LclId]
        lvl270_se9zW
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_ae3Xz
              @ Sum
              ($dTypeable_ae3XC
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_ae3Xz>_N
                       :: (Typeable t_ae3Xz :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_ae3Xz :: *)))
              Data.Data.$fDataSum2 } in
      \ (f_ae2ot :: forall d. Data d => c_ae3XA (t_ae3Xz d)) ->
        case lvl270_se9zW of {
          False -> GHC.Base.Nothing @ (c_ae3XA (Sum a_ae3WW));
          True ->
            GHC.Base.Just
              @ (c_ae3XA (Sum a_ae3WW))
              ((f_ae2ot @ a_ae3WW $dData_ae3WX)
               `cast` (<c_ae3XA>_R (UnsafeCo nominal t_ae3Xz Sum <a_ae3WW>_N)
                       :: (c_ae3XA (t_ae3Xz a_ae3WW) :: *)
                          ~R# (c_ae3XA (Sum a_ae3WW) :: *)))
        }

-- RHS size: {terms: 11, types: 34, coercions: 7, joins: 0/0}
Data.Data.$fDataSum_$cgfoldl
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Sum a -> c (Sum a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae3WW)
                 ($dData_ae3WX [Occ=Once] :: Data a_ae3WW)
                 (@ (c_ae3X5 :: * -> *))
                 (k_ae2oo [Occ=Once!]
                    :: forall d b. Data d => c_ae3X5 (d -> b) -> d -> c_ae3X5 b)
                 (z_ae2op [Occ=Once!] :: forall g. g -> c_ae3X5 g)
                 (ds_de7wA [Occ=Once] :: Sum a_ae3WW) ->
                 k_ae2oo
                   @ a_ae3WW
                   @ (Sum a_ae3WW)
                   $dData_ae3WX
                   (z_ae2op
                      @ (a_ae3WW -> Sum a_ae3WW)
                      ((Data.Data.$fDataConst2 @ a_ae3WW)
                       `cast` (<a_ae3WW>_R
                               ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_ae3WW>_R)
                               :: (a_ae3WW -> a_ae3WW :: *) ~R# (a_ae3WW -> Sum a_ae3WW :: *))))
                   (ds_de7wA
                    `cast` (Data.Semigroup.Internal.N:Sum[0] <a_ae3WW>_R
                            :: (Sum a_ae3WW :: *) ~R# (a_ae3WW :: *)))}]
Data.Data.$fDataSum_$cgfoldl
  = \ (@ a_ae3WW)
      ($dData_ae3WX :: Data a_ae3WW)
      (@ (c_ae3X5 :: * -> *))
      (k_ae2oo
         :: forall d b. Data d => c_ae3X5 (d -> b) -> d -> c_ae3X5 b)
      (z_ae2op :: forall g. g -> c_ae3X5 g)
      (ds_de7wA :: Sum a_ae3WW) ->
      k_ae2oo
        @ a_ae3WW
        @ (Sum a_ae3WW)
        $dData_ae3WX
        (z_ae2op
           @ (a_ae3WW -> Sum a_ae3WW)
           ((Data.Data.$fDataConst2 @ a_ae3WW)
            `cast` (<a_ae3WW>_R
                    ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_ae3WW>_R)
                    :: (a_ae3WW -> a_ae3WW :: *) ~R# (a_ae3WW -> Sum a_ae3WW :: *))))
        (ds_de7wA
         `cast` (Data.Semigroup.Internal.N:Sum[0] <a_ae3WW>_R
                 :: (Sum a_ae3WW :: *) ~R# (a_ae3WW :: *)))

-- RHS size: {terms: 6, types: 11, coercions: 4, joins: 0/0}
Data.Data.$fDataSum7
  :: forall a. Data a => Data.Typeable.Internal.TypeRep (Sum a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae3WW) ($dData_ae3WX [Occ=Once] :: Data a_ae3WW) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Sum
                   @ a_ae3WW
                   Data.Data.$fDataSum2
                   ((Data.Data.$p1Data @ a_ae3WW $dData_ae3WX)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae3WW>_N
                            :: (Typeable a_ae3WW :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep a_ae3WW :: *)))}]
Data.Data.$fDataSum7
  = \ (@ a_ae3WW) ($dData_ae3WX :: Data a_ae3WW) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ Sum
        @ a_ae3WW
        Data.Data.$fDataSum2
        ((Data.Data.$p1Data @ a_ae3WW $dData_ae3WX)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae3WW>_N
                 :: (Typeable a_ae3WW :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep a_ae3WW :: *)))

-- RHS size: {terms: 16, types: 41, coercions: 0, joins: 0/0}
Data.Data.$fDataProduct2 :: Data.Typeable.Internal.TypeRep Product
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataProduct2
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ Product
           12271745360620305859##
           5747185732973757022##
           Data.Semigroup.Internal.$trModule
           Data.Semigroup.Internal.$tcProduct1
           0#
           GHC.Types.krep$*Arr*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ Product
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 18, types: 44, coercions: 12, joins: 0/1}
Data.Data.$fDataProduct_$cdataCast1
  :: forall a.
     Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Product a))
[GblId,
 Arity=2,
 Str=<L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 100 60}]
Data.Data.$fDataProduct_$cdataCast1
  = \ (@ a_ae3TI)
      ($dData_ae3TJ :: Data a_ae3TI)
      (@ (t_ae3Ul :: * -> *))
      (@ (c_ae3Um :: * -> *))
      ($dTypeable_ae3Uo :: Typeable t_ae3Ul) ->
      let {
        lvl270_se9A2 :: Bool
        [LclId]
        lvl270_se9A2
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_ae3Ul
              @ Product
              ($dTypeable_ae3Uo
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_ae3Ul>_N
                       :: (Typeable t_ae3Ul :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_ae3Ul :: *)))
              Data.Data.$fDataProduct2 } in
      \ (f_ae2on :: forall d. Data d => c_ae3Um (t_ae3Ul d)) ->
        case lvl270_se9A2 of {
          False -> GHC.Base.Nothing @ (c_ae3Um (Product a_ae3TI));
          True ->
            GHC.Base.Just
              @ (c_ae3Um (Product a_ae3TI))
              ((f_ae2on @ a_ae3TI $dData_ae3TJ)
               `cast` (<c_ae3Um>_R (UnsafeCo nominal t_ae3Ul Product <a_ae3TI>_N)
                       :: (c_ae3Um (t_ae3Ul a_ae3TI) :: *)
                          ~R# (c_ae3Um (Product a_ae3TI) :: *)))
        }

-- RHS size: {terms: 11, types: 34, coercions: 7, joins: 0/0}
Data.Data.$fDataProduct_$cgfoldl
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Product a -> c (Product a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae3TI)
                 ($dData_ae3TJ [Occ=Once] :: Data a_ae3TI)
                 (@ (c_ae3TR :: * -> *))
                 (k_ae2oi [Occ=Once!]
                    :: forall d b. Data d => c_ae3TR (d -> b) -> d -> c_ae3TR b)
                 (z_ae2oj [Occ=Once!] :: forall g. g -> c_ae3TR g)
                 (ds_de7wh [Occ=Once] :: Product a_ae3TI) ->
                 k_ae2oi
                   @ a_ae3TI
                   @ (Product a_ae3TI)
                   $dData_ae3TJ
                   (z_ae2oj
                      @ (a_ae3TI -> Product a_ae3TI)
                      ((Data.Data.$fDataConst2 @ a_ae3TI)
                       `cast` (<a_ae3TI>_R
                               ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_ae3TI>_R)
                               :: (a_ae3TI -> a_ae3TI :: *)
                                  ~R# (a_ae3TI -> Product a_ae3TI :: *))))
                   (ds_de7wh
                    `cast` (Data.Semigroup.Internal.N:Product[0] <a_ae3TI>_R
                            :: (Product a_ae3TI :: *) ~R# (a_ae3TI :: *)))}]
Data.Data.$fDataProduct_$cgfoldl
  = \ (@ a_ae3TI)
      ($dData_ae3TJ :: Data a_ae3TI)
      (@ (c_ae3TR :: * -> *))
      (k_ae2oi
         :: forall d b. Data d => c_ae3TR (d -> b) -> d -> c_ae3TR b)
      (z_ae2oj :: forall g. g -> c_ae3TR g)
      (ds_de7wh :: Product a_ae3TI) ->
      k_ae2oi
        @ a_ae3TI
        @ (Product a_ae3TI)
        $dData_ae3TJ
        (z_ae2oj
           @ (a_ae3TI -> Product a_ae3TI)
           ((Data.Data.$fDataConst2 @ a_ae3TI)
            `cast` (<a_ae3TI>_R
                    ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_ae3TI>_R)
                    :: (a_ae3TI -> a_ae3TI :: *)
                       ~R# (a_ae3TI -> Product a_ae3TI :: *))))
        (ds_de7wh
         `cast` (Data.Semigroup.Internal.N:Product[0] <a_ae3TI>_R
                 :: (Product a_ae3TI :: *) ~R# (a_ae3TI :: *)))

-- RHS size: {terms: 6, types: 11, coercions: 4, joins: 0/0}
Data.Data.$fDataProduct7
  :: forall a. Data a => Data.Typeable.Internal.TypeRep (Product a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae3TI) ($dData_ae3TJ [Occ=Once] :: Data a_ae3TI) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Product
                   @ a_ae3TI
                   Data.Data.$fDataProduct2
                   ((Data.Data.$p1Data @ a_ae3TI $dData_ae3TJ)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae3TI>_N
                            :: (Typeable a_ae3TI :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep a_ae3TI :: *)))}]
Data.Data.$fDataProduct7
  = \ (@ a_ae3TI) ($dData_ae3TJ :: Data a_ae3TI) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ Product
        @ a_ae3TI
        Data.Data.$fDataProduct2
        ((Data.Data.$p1Data @ a_ae3TI $dData_ae3TJ)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae3TI>_N
                 :: (Typeable a_ae3TI :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep a_ae3TI :: *)))

-- RHS size: {terms: 16, types: 41, coercions: 0, joins: 0/0}
Data.Data.$fDataFirst4 :: Data.Typeable.Internal.TypeRep First
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataFirst4
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ First
           12072287807032806756##
           12788244796562536401##
           Data.Monoid.$trModule
           Data.Monoid.$tcFirst1
           0#
           GHC.Types.krep$*Arr*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ First
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 18, types: 44, coercions: 12, joins: 0/1}
Data.Data.$fDataFirst_$cdataCast1
  :: forall a.
     Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (First a))
[GblId,
 Arity=2,
 Str=<L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 100 60}]
Data.Data.$fDataFirst_$cdataCast1
  = \ (@ a_ae3Qu)
      ($dData_ae3Qv :: Data a_ae3Qu)
      (@ (t_ae3R7 :: * -> *))
      (@ (c_ae3R8 :: * -> *))
      ($dTypeable_ae3Ra :: Typeable t_ae3R7) ->
      let {
        lvl270_se9A8 :: Bool
        [LclId]
        lvl270_se9A8
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_ae3R7
              @ First
              ($dTypeable_ae3Ra
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_ae3R7>_N
                       :: (Typeable t_ae3R7 :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_ae3R7 :: *)))
              Data.Data.$fDataFirst4 } in
      \ (f_ae2oh :: forall d. Data d => c_ae3R8 (t_ae3R7 d)) ->
        case lvl270_se9A8 of {
          False -> GHC.Base.Nothing @ (c_ae3R8 (First a_ae3Qu));
          True ->
            GHC.Base.Just
              @ (c_ae3R8 (First a_ae3Qu))
              ((f_ae2oh @ a_ae3Qu $dData_ae3Qv)
               `cast` (<c_ae3R8>_R (UnsafeCo nominal t_ae3R7 First <a_ae3Qu>_N)
                       :: (c_ae3R8 (t_ae3R7 a_ae3Qu) :: *)
                          ~R# (c_ae3R8 (First a_ae3Qu) :: *)))
        }

-- RHS size: {terms: 6, types: 11, coercions: 4, joins: 0/0}
Data.Data.$fDataFirst9
  :: forall a. Data a => Data.Typeable.Internal.TypeRep (First a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae3Qu) ($dData_ae3Qv [Occ=Once] :: Data a_ae3Qu) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ First
                   @ a_ae3Qu
                   Data.Data.$fDataFirst4
                   ((Data.Data.$p1Data @ a_ae3Qu $dData_ae3Qv)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae3Qu>_N
                            :: (Typeable a_ae3Qu :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep a_ae3Qu :: *)))}]
Data.Data.$fDataFirst9
  = \ (@ a_ae3Qu) ($dData_ae3Qv :: Data a_ae3Qu) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ First
        @ a_ae3Qu
        Data.Data.$fDataFirst4
        ((Data.Data.$p1Data @ a_ae3Qu $dData_ae3Qv)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae3Qu>_N
                 :: (Typeable a_ae3Qu :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep a_ae3Qu :: *)))

-- RHS size: {terms: 16, types: 41, coercions: 0, joins: 0/0}
Data.Data.$fDataLast3 :: Data.Typeable.Internal.TypeRep Last
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataLast3
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ Last
           6920195955404695016##
           2388797855174213212##
           Data.Monoid.$trModule
           Data.Monoid.$tcLast1
           0#
           GHC.Types.krep$*Arr*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ Last
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 18, types: 44, coercions: 12, joins: 0/1}
Data.Data.$fDataLast_$cdataCast1
  :: forall a.
     Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Last a))
[GblId,
 Arity=2,
 Str=<L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 100 60}]
Data.Data.$fDataLast_$cdataCast1
  = \ (@ a_ae3Ng)
      ($dData_ae3Nh :: Data a_ae3Ng)
      (@ (t_ae3NT :: * -> *))
      (@ (c_ae3NU :: * -> *))
      ($dTypeable_ae3NW :: Typeable t_ae3NT) ->
      let {
        lvl270_se9Ac :: Bool
        [LclId]
        lvl270_se9Ac
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_ae3NT
              @ Last
              ($dTypeable_ae3NW
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_ae3NT>_N
                       :: (Typeable t_ae3NT :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_ae3NT :: *)))
              Data.Data.$fDataLast3 } in
      \ (f_ae2ob :: forall d. Data d => c_ae3NU (t_ae3NT d)) ->
        case lvl270_se9Ac of {
          False -> GHC.Base.Nothing @ (c_ae3NU (Last a_ae3Ng));
          True ->
            GHC.Base.Just
              @ (c_ae3NU (Last a_ae3Ng))
              ((f_ae2ob @ a_ae3Ng $dData_ae3Nh)
               `cast` (<c_ae3NU>_R (UnsafeCo nominal t_ae3NT Last <a_ae3Ng>_N)
                       :: (c_ae3NU (t_ae3NT a_ae3Ng) :: *)
                          ~R# (c_ae3NU (Last a_ae3Ng) :: *)))
        }

-- RHS size: {terms: 6, types: 11, coercions: 4, joins: 0/0}
Data.Data.$fDataLast8
  :: forall a. Data a => Data.Typeable.Internal.TypeRep (Last a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae3Ng) ($dData_ae3Nh [Occ=Once] :: Data a_ae3Ng) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Last
                   @ a_ae3Ng
                   Data.Data.$fDataLast3
                   ((Data.Data.$p1Data @ a_ae3Ng $dData_ae3Nh)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae3Ng>_N
                            :: (Typeable a_ae3Ng :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep a_ae3Ng :: *)))}]
Data.Data.$fDataLast8
  = \ (@ a_ae3Ng) ($dData_ae3Nh :: Data a_ae3Ng) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ Last
        @ a_ae3Ng
        Data.Data.$fDataLast3
        ((Data.Data.$p1Data @ a_ae3Ng $dData_ae3Nh)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae3Ng>_N
                 :: (Typeable a_ae3Ng :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep a_ae3Ng :: *)))

-- RHS size: {terms: 16, types: 60, coercions: 0, joins: 0/0}
Data.Data.$fDataAlt8 :: Data.Typeable.Internal.TypeRep Alt
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataAlt8
  = case Data.Typeable.Internal.$wmkTrCon
           @ ((* -> *) -> * -> *)
           @ Alt
           7601313288863504805##
           2369500163797891218##
           Data.Semigroup.Internal.$trModule
           Data.Semigroup.Internal.$tcAlt2
           1#
           Data.Semigroup.Internal.$tcAlt1
           Data.Data.$fData:*:9
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ ((* -> *) -> * -> *)
      @ Alt
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 11, types: 39, coercions: 10, joins: 0/0}
Data.Data.$fDataAlt7
  :: forall (f :: * -> *) a.
     (Data (f a), Data a, Typeable f) =>
     Data.Typeable.Internal.TypeRep (Alt f a)
[GblId,
 Arity=3,
 Str=<L,A><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ae3JU :: * -> *))
                 (@ a_ae3JV)
                 _ [Occ=Dead]
                 ($dData1_ae3JX [Occ=Once] :: Data a_ae3JV)
                 ($dTypeable_ae3JY [Occ=Once] :: Typeable f_ae3JU) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ (Alt f_ae3JU)
                   @ a_ae3JV
                   (Data.Typeable.Internal.mkTrApp
                      @ (* -> *)
                      @ (* -> *)
                      @ Alt
                      @ f_ae3JU
                      Data.Data.$fDataAlt8
                      ($dTypeable_ae3JY
                       `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <f_ae3JU>_N
                               :: (Typeable f_ae3JU :: Constraint)
                                  ~R# (Data.Typeable.Internal.TypeRep f_ae3JU :: *))))
                   ((Data.Data.$p1Data @ a_ae3JV $dData1_ae3JX)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae3JV>_N
                            :: (Typeable a_ae3JV :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep a_ae3JV :: *)))}]
Data.Data.$fDataAlt7
  = \ (@ (f_ae3JU :: * -> *))
      (@ a_ae3JV)
      _ [Occ=Dead]
      ($dData1_ae3JX :: Data a_ae3JV)
      ($dTypeable_ae3JY :: Typeable f_ae3JU) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ (Alt f_ae3JU)
        @ a_ae3JV
        (Data.Typeable.Internal.mkTrApp
           @ (* -> *)
           @ (* -> *)
           @ Alt
           @ f_ae3JU
           Data.Data.$fDataAlt8
           ($dTypeable_ae3JY
            `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <f_ae3JU>_N
                    :: (Typeable f_ae3JU :: Constraint)
                       ~R# (Data.Typeable.Internal.TypeRep f_ae3JU :: *))))
        ((Data.Data.$p1Data @ a_ae3JV $dData1_ae3JX)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_ae3JV>_N
                 :: (Typeable a_ae3JV :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep a_ae3JV :: *)))

-- RHS size: {terms: 16, types: 44, coercions: 0, joins: 0/0}
Data.Data.$fDataU8 :: Data.Typeable.Internal.TypeRep U1
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataU8
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ U1
           10579575928405317284##
           7866164073370891844##
           GHC.Generics.$trModule
           GHC.Generics.$tcU2
           1#
           GHC.Generics.$tcSing1
           Data.Data.$fData:*:9
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ U1
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 6, types: 13, coercions: 4, joins: 0/0}
Data.Data.$fDataU7
  :: forall p. Data p => Data.Typeable.Internal.TypeRep (U1 p)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ p_ae3GL) ($dData_ae3GM [Occ=Once] :: Data p_ae3GL) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ U1
                   @ p_ae3GL
                   Data.Data.$fDataU8
                   ((Data.Data.$p1Data @ p_ae3GL $dData_ae3GM)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <p_ae3GL>_N
                            :: (Typeable p_ae3GL :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep p_ae3GL :: *)))}]
Data.Data.$fDataU7
  = \ (@ p_ae3GL) ($dData_ae3GM :: Data p_ae3GL) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ U1
        @ p_ae3GL
        Data.Data.$fDataU8
        ((Data.Data.$p1Data @ p_ae3GL $dData_ae3GM)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <p_ae3GL>_N
                 :: (Typeable p_ae3GL :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep p_ae3GL :: *)))

-- RHS size: {terms: 16, types: 41, coercions: 0, joins: 0/0}
Data.Data.$fDataPar3 :: Data.Typeable.Internal.TypeRep Par1
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataPar3
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ Par1
           12308177470959788863##
           10705877555367042803##
           GHC.Generics.$trModule
           GHC.Generics.$tcPar2
           0#
           GHC.Types.krep$*Arr*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ Par1
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 18, types: 44, coercions: 12, joins: 0/1}
Data.Data.$fDataPar1_$cdataCast1
  :: forall p.
     Data p =>
     forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Par1 p))
[GblId,
 Arity=2,
 Str=<L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 100 60}]
Data.Data.$fDataPar1_$cdataCast1
  = \ (@ p_ae3Dq)
      ($dData_ae3Dr :: Data p_ae3Dq)
      (@ (t_ae3E3 :: * -> *))
      (@ (c_ae3E4 :: * -> *))
      ($dTypeable_ae3E6 :: Typeable t_ae3E3) ->
      let {
        lvl270_se9Ao :: Bool
        [LclId]
        lvl270_se9Ao
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_ae3E3
              @ Par1
              ($dTypeable_ae3E6
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_ae3E3>_N
                       :: (Typeable t_ae3E3 :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_ae3E3 :: *)))
              Data.Data.$fDataPar3 } in
      \ (f_ae2nW :: forall d. Data d => c_ae3E4 (t_ae3E3 d)) ->
        case lvl270_se9Ao of {
          False -> GHC.Base.Nothing @ (c_ae3E4 (Par1 p_ae3Dq));
          True ->
            GHC.Base.Just
              @ (c_ae3E4 (Par1 p_ae3Dq))
              ((f_ae2nW @ p_ae3Dq $dData_ae3Dr)
               `cast` (<c_ae3E4>_R (UnsafeCo nominal t_ae3E3 Par1 <p_ae3Dq>_N)
                       :: (c_ae3E4 (t_ae3E3 p_ae3Dq) :: *)
                          ~R# (c_ae3E4 (Par1 p_ae3Dq) :: *)))
        }

-- RHS size: {terms: 11, types: 34, coercions: 7, joins: 0/0}
Data.Data.$fDataPar1_$cgfoldl
  :: forall p.
     Data p =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Par1 p -> c (Par1 p)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ p_ae3Dq)
                 ($dData_ae3Dr [Occ=Once] :: Data p_ae3Dq)
                 (@ (c_ae3Dz :: * -> *))
                 (k_ae2nR [Occ=Once!]
                    :: forall d b. Data d => c_ae3Dz (d -> b) -> d -> c_ae3Dz b)
                 (z_ae2nS [Occ=Once!] :: forall g. g -> c_ae3Dz g)
                 (ds_de7uw [Occ=Once] :: Par1 p_ae3Dq) ->
                 k_ae2nR
                   @ p_ae3Dq
                   @ (Par1 p_ae3Dq)
                   $dData_ae3Dr
                   (z_ae2nS
                      @ (p_ae3Dq -> Par1 p_ae3Dq)
                      ((Data.Data.$fDataConst2 @ p_ae3Dq)
                       `cast` (<p_ae3Dq>_R ->_R Sym (GHC.Generics.N:Par1[0] <p_ae3Dq>_R)
                               :: (p_ae3Dq -> p_ae3Dq :: *) ~R# (p_ae3Dq -> Par1 p_ae3Dq :: *))))
                   (ds_de7uw
                    `cast` (GHC.Generics.N:Par1[0] <p_ae3Dq>_R
                            :: (Par1 p_ae3Dq :: *) ~R# (p_ae3Dq :: *)))}]
Data.Data.$fDataPar1_$cgfoldl
  = \ (@ p_ae3Dq)
      ($dData_ae3Dr :: Data p_ae3Dq)
      (@ (c_ae3Dz :: * -> *))
      (k_ae2nR
         :: forall d b. Data d => c_ae3Dz (d -> b) -> d -> c_ae3Dz b)
      (z_ae2nS :: forall g. g -> c_ae3Dz g)
      (ds_de7uw :: Par1 p_ae3Dq) ->
      k_ae2nR
        @ p_ae3Dq
        @ (Par1 p_ae3Dq)
        $dData_ae3Dr
        (z_ae2nS
           @ (p_ae3Dq -> Par1 p_ae3Dq)
           ((Data.Data.$fDataConst2 @ p_ae3Dq)
            `cast` (<p_ae3Dq>_R ->_R Sym (GHC.Generics.N:Par1[0] <p_ae3Dq>_R)
                    :: (p_ae3Dq -> p_ae3Dq :: *) ~R# (p_ae3Dq -> Par1 p_ae3Dq :: *))))
        (ds_de7uw
         `cast` (GHC.Generics.N:Par1[0] <p_ae3Dq>_R
                 :: (Par1 p_ae3Dq :: *) ~R# (p_ae3Dq :: *)))

-- RHS size: {terms: 6, types: 11, coercions: 4, joins: 0/0}
Data.Data.$fDataPar8
  :: forall p. Data p => Data.Typeable.Internal.TypeRep (Par1 p)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ p_ae3Dq) ($dData_ae3Dr [Occ=Once] :: Data p_ae3Dq) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Par1
                   @ p_ae3Dq
                   Data.Data.$fDataPar3
                   ((Data.Data.$p1Data @ p_ae3Dq $dData_ae3Dr)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <p_ae3Dq>_N
                            :: (Typeable p_ae3Dq :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep p_ae3Dq :: *)))}]
Data.Data.$fDataPar8
  = \ (@ p_ae3Dq) ($dData_ae3Dr :: Data p_ae3Dq) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ Par1
        @ p_ae3Dq
        Data.Data.$fDataPar3
        ((Data.Data.$p1Data @ p_ae3Dq $dData_ae3Dr)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <p_ae3Dq>_N
                 :: (Typeable p_ae3Dq :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep p_ae3Dq :: *)))

-- RHS size: {terms: 16, types: 56, coercions: 0, joins: 0/0}
Data.Data.$fDataRec8 :: Data.Typeable.Internal.TypeRep Rec1
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataRec8
  = case Data.Typeable.Internal.$wmkTrCon
           @ ((* -> *) -> * -> *)
           @ Rec1
           8699582420150512451##
           5333973959763347691##
           GHC.Generics.$trModule
           GHC.Generics.$tcRec3
           1#
           GHC.Generics.$tcRec2
           Data.Data.$fData:*:9
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ ((* -> *) -> * -> *)
      @ Rec1
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 11, types: 38, coercions: 10, joins: 0/0}
Data.Data.$fDataRec7
  :: forall (f :: * -> *) p.
     (Data (f p), Typeable f, Data p) =>
     Data.Typeable.Internal.TypeRep (Rec1 f p)
[GblId,
 Arity=3,
 Str=<L,A><S,U><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ae3A4 :: * -> *))
                 (@ p_ae3A5)
                 _ [Occ=Dead]
                 ($dTypeable_ae3A7 [Occ=Once] :: Typeable f_ae3A4)
                 ($dData1_ae3A8 [Occ=Once] :: Data p_ae3A5) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ (Rec1 f_ae3A4)
                   @ p_ae3A5
                   (Data.Typeable.Internal.mkTrApp
                      @ (* -> *)
                      @ (* -> *)
                      @ Rec1
                      @ f_ae3A4
                      Data.Data.$fDataRec8
                      ($dTypeable_ae3A7
                       `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <f_ae3A4>_N
                               :: (Typeable f_ae3A4 :: Constraint)
                                  ~R# (Data.Typeable.Internal.TypeRep f_ae3A4 :: *))))
                   ((Data.Data.$p1Data @ p_ae3A5 $dData1_ae3A8)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <p_ae3A5>_N
                            :: (Typeable p_ae3A5 :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep p_ae3A5 :: *)))}]
Data.Data.$fDataRec7
  = \ (@ (f_ae3A4 :: * -> *))
      (@ p_ae3A5)
      _ [Occ=Dead]
      ($dTypeable_ae3A7 :: Typeable f_ae3A4)
      ($dData1_ae3A8 :: Data p_ae3A5) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ (Rec1 f_ae3A4)
        @ p_ae3A5
        (Data.Typeable.Internal.mkTrApp
           @ (* -> *)
           @ (* -> *)
           @ Rec1
           @ f_ae3A4
           Data.Data.$fDataRec8
           ($dTypeable_ae3A7
            `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <f_ae3A4>_N
                    :: (Typeable f_ae3A4 :: Constraint)
                       ~R# (Data.Typeable.Internal.TypeRep f_ae3A4 :: *))))
        ((Data.Data.$p1Data @ p_ae3A5 $dData1_ae3A8)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <p_ae3A5>_N
                 :: (Typeable p_ae3A5 :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep p_ae3A5 :: *)))

-- RHS size: {terms: 16, types: 56, coercions: 0, joins: 0/0}
Data.Data.$fDataK8 :: Data.Typeable.Internal.TypeRep K1
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataK8
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> * -> * -> *)
           @ K1
           16656959097387255772##
           1423016325873000693##
           GHC.Generics.$trModule
           GHC.Generics.$tcK3
           1#
           GHC.Generics.$tcK2
           Data.Data.$fData:*:9
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> * -> * -> *)
      @ K1
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 15, types: 46, coercions: 11, joins: 0/0}
Data.Data.$fDataK7
  :: forall i p c.
     (Typeable i, Data p, Data c) =>
     Data.Typeable.Internal.TypeRep (K1 i c p)
[GblId,
 Arity=3,
 Str=<S,U><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 30 30] 130 0}]
Data.Data.$fDataK7
  = \ (@ i_ae3wF)
      (@ p_ae3wG)
      (@ c_ae3wH)
      ($dTypeable_ae3wI :: Typeable i_ae3wF)
      ($dData_ae3wJ :: Data p_ae3wG)
      ($dData1_ae3wK :: Data c_ae3wH) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ (K1 i_ae3wF c_ae3wH)
        @ p_ae3wG
        (Data.Typeable.Internal.mkTrApp
           @ *
           @ (* -> *)
           @ (K1 i_ae3wF)
           @ c_ae3wH
           (Data.Typeable.Internal.mkTrApp
              @ *
              @ (* -> * -> *)
              @ K1
              @ i_ae3wF
              Data.Data.$fDataK8
              ($dTypeable_ae3wI
               `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <i_ae3wF>_N
                       :: (Typeable i_ae3wF :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep i_ae3wF :: *))))
           ((Data.Data.$p1Data @ c_ae3wH $dData1_ae3wK)
            `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <c_ae3wH>_N
                    :: (Typeable c_ae3wH :: Constraint)
                       ~R# (Data.Typeable.Internal.TypeRep c_ae3wH :: *))))
        ((Data.Data.$p1Data @ p_ae3wG $dData_ae3wJ)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <p_ae3wG>_N
                 :: (Typeable p_ae3wG :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep p_ae3wG :: *)))

-- RHS size: {terms: 16, types: 64, coercions: 0, joins: 0/0}
Data.Data.$fDataM8 :: Data.Typeable.Internal.TypeRep M1
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataM8
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> Meta -> (* -> *) -> * -> *)
           @ M1
           13343722473269292942##
           10392992488447108496##
           GHC.Generics.$trModule
           GHC.Generics.$tcM3
           1#
           GHC.Generics.$tcM2
           Data.Data.$fData:*:9
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> Meta -> (* -> *) -> * -> *)
      @ M1
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 18, types: 73, coercions: 16, joins: 0/0}
Data.Data.$w$cp1Data1 [InlPrag=NOUSERINLINE[0]]
  :: forall p (f :: * -> *) (c :: Meta) i.
     (Data p, Typeable c, Typeable i, Typeable f) =>
     Data.Typeable.Internal.TypeRep (M1 i c f p)
[GblId,
 Arity=4,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,U><S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0 0] 140 0}]
Data.Data.$w$cp1Data1
  = \ (@ p_sefTZ)
      (@ (f_sefU0 :: * -> *))
      (@ (c_sefU1 :: Meta))
      (@ i_sefU2)
      (w_sefU3 :: Data p_sefTZ)
      (w1_sefU5 :: Typeable c_sefU1)
      (w2_sefU6 :: Typeable i_sefU2)
      (w3_sefU7 :: Typeable f_sefU0) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ (M1 i_sefU2 c_sefU1 f_sefU0)
        @ p_sefTZ
        (Data.Typeable.Internal.mkTrApp
           @ (* -> *)
           @ (* -> *)
           @ (M1 i_sefU2 c_sefU1)
           @ f_sefU0
           (Data.Typeable.Internal.mkTrApp
              @ Meta
              @ ((* -> *) -> * -> *)
              @ (M1 i_sefU2)
              @ c_sefU1
              (Data.Typeable.Internal.mkTrApp
                 @ *
                 @ (Meta -> (* -> *) -> * -> *)
                 @ M1
                 @ i_sefU2
                 Data.Data.$fDataM8
                 (w2_sefU6
                  `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <i_sefU2>_N
                          :: (Typeable i_sefU2 :: Constraint)
                             ~R# (Data.Typeable.Internal.TypeRep i_sefU2 :: *))))
              (w1_sefU5
               `cast` (Data.Typeable.Internal.N:Typeable[0] <Meta>_N <c_sefU1>_N
                       :: (Typeable c_sefU1 :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep c_sefU1 :: *))))
           (w3_sefU7
            `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <f_sefU0>_N
                    :: (Typeable f_sefU0 :: Constraint)
                       ~R# (Data.Typeable.Internal.TypeRep f_sefU0 :: *))))
        ((Data.Data.$p1Data @ p_sefTZ w_sefU3)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <p_sefTZ>_N
                 :: (Typeable p_sefTZ :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep p_sefTZ :: *)))

-- RHS size: {terms: 14, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataM7 [InlPrag=NOUSERINLINE[0]]
  :: forall p (f :: * -> *) (c :: Meta) i.
     (Data p, Data (f p), Typeable c, Typeable i, Typeable f) =>
     Data.Typeable.Internal.TypeRep (M1 i c f p)
[GblId,
 Arity=5,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,A><S,U><S,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ p_sefTZ)
                 (@ (f_sefU0 :: * -> *))
                 (@ (c_sefU1 :: Meta))
                 (@ i_sefU2)
                 (w_sefU3 [Occ=Once] :: Data p_sefTZ)
                 _ [Occ=Dead]
                 (w2_sefU5 [Occ=Once] :: Typeable c_sefU1)
                 (w3_sefU6 [Occ=Once] :: Typeable i_sefU2)
                 (w4_sefU7 [Occ=Once] :: Typeable f_sefU0) ->
                 Data.Data.$w$cp1Data1
                   @ p_sefTZ
                   @ f_sefU0
                   @ c_sefU1
                   @ i_sefU2
                   w_sefU3
                   w2_sefU5
                   w3_sefU6
                   w4_sefU7}]
Data.Data.$fDataM7
  = \ (@ p_sefTZ)
      (@ (f_sefU0 :: * -> *))
      (@ (c_sefU1 :: Meta))
      (@ i_sefU2)
      (w_sefU3 :: Data p_sefTZ)
      _ [Occ=Dead]
      (w2_sefU5 :: Typeable c_sefU1)
      (w3_sefU6 :: Typeable i_sefU2)
      (w4_sefU7 :: Typeable f_sefU0) ->
      Data.Data.$w$cp1Data1
        @ p_sefTZ
        @ f_sefU0
        @ c_sefU1
        @ i_sefU2
        w_sefU3
        w2_sefU5
        w3_sefU6
        w4_sefU7

-- RHS size: {terms: 26, types: 109, coercions: 0, joins: 0/0}
Data.Data.$fData:+:_$cgfoldl
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f p), Data (g p)) =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g1. g1 -> c g1) -> (:+:) f g p -> c ((:+:) f g p)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,U><L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=8,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ae3ps :: * -> *))
                 (@ (g_ae3pt :: * -> *))
                 (@ p_ae3pu)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 ($dData1_ae3py [Occ=Once] :: Data (f_ae3ps p_ae3pu))
                 ($dData2_ae3pz [Occ=Once] :: Data (g_ae3pt p_ae3pu))
                 (@ (c_ae3pH :: * -> *))
                 (k_ae2nt [Occ=Once*!]
                    :: forall d b. Data d => c_ae3pH (d -> b) -> d -> c_ae3pH b)
                 (z_ae2nu [Occ=Once*!] :: forall g1. g1 -> c_ae3pH g1)
                 (ds_de7t9 [Occ=Once!] :: (:+:) f_ae3ps g_ae3pt p_ae3pu) ->
                 case ds_de7t9 of {
                   L1 a1_ae2nv [Occ=Once] ->
                     k_ae2nt
                       @ (f_ae3ps p_ae3pu)
                       @ ((:+:) f_ae3ps g_ae3pt p_ae3pu)
                       $dData1_ae3py
                       (z_ae2nu
                          @ (f_ae3ps p_ae3pu -> (:+:) f_ae3ps g_ae3pt p_ae3pu)
                          (GHC.Generics.L1 @ * @ f_ae3ps @ g_ae3pt @ p_ae3pu))
                       a1_ae2nv;
                   R1 a1_ae2ny [Occ=Once] ->
                     k_ae2nt
                       @ (g_ae3pt p_ae3pu)
                       @ ((:+:) f_ae3ps g_ae3pt p_ae3pu)
                       $dData2_ae3pz
                       (z_ae2nu
                          @ (g_ae3pt p_ae3pu -> (:+:) f_ae3ps g_ae3pt p_ae3pu)
                          (GHC.Generics.R1 @ * @ f_ae3ps @ g_ae3pt @ p_ae3pu))
                       a1_ae2ny
                 }}]
Data.Data.$fData:+:_$cgfoldl
  = \ (@ (f_ae3ps :: * -> *))
      (@ (g_ae3pt :: * -> *))
      (@ p_ae3pu)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      ($dData1_ae3py :: Data (f_ae3ps p_ae3pu))
      ($dData2_ae3pz :: Data (g_ae3pt p_ae3pu))
      (@ (c_ae3pH :: * -> *))
      (k_ae2nt
         :: forall d b. Data d => c_ae3pH (d -> b) -> d -> c_ae3pH b)
      (z_ae2nu :: forall g1. g1 -> c_ae3pH g1)
      (ds_de7t9 :: (:+:) f_ae3ps g_ae3pt p_ae3pu) ->
      case ds_de7t9 of {
        L1 a1_ae2nv ->
          k_ae2nt
            @ (f_ae3ps p_ae3pu)
            @ ((:+:) f_ae3ps g_ae3pt p_ae3pu)
            $dData1_ae3py
            (z_ae2nu
               @ (f_ae3ps p_ae3pu -> (:+:) f_ae3ps g_ae3pt p_ae3pu)
               (GHC.Generics.L1 @ * @ f_ae3ps @ g_ae3pt @ p_ae3pu))
            a1_ae2nv;
        R1 a1_ae2ny ->
          k_ae2nt
            @ (g_ae3pt p_ae3pu)
            @ ((:+:) f_ae3ps g_ae3pt p_ae3pu)
            $dData2_ae3pz
            (z_ae2nu
               @ (g_ae3pt p_ae3pu -> (:+:) f_ae3ps g_ae3pt p_ae3pu)
               (GHC.Generics.R1 @ * @ f_ae3ps @ g_ae3pt @ p_ae3pu))
            a1_ae2ny
      }

-- RHS size: {terms: 16, types: 68, coercions: 0, joins: 0/0}
Data.Data.$fData:+:6 :: Data.Typeable.Internal.TypeRep (:+:)
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fData:+:6
  = case Data.Typeable.Internal.$wmkTrCon
           @ ((* -> *) -> (* -> *) -> * -> *)
           @ (:+:)
           14539534129025047436##
           7046771131824201063##
           GHC.Generics.$trModule
           GHC.Generics.$tc:+:1
           1#
           GHC.Generics.$tc:*:1
           Data.Data.$fData:*:9
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ ((* -> *) -> (* -> *) -> * -> *)
      @ (:+:)
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 16, types: 67, coercions: 16, joins: 0/0}
Data.Data.$fData:+:5
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f p), Data (g p)) =>
     Data.Typeable.Internal.TypeRep ((:+:) f g p)
[GblId,
 Arity=5,
 Str=<S,U><S,U><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ae3ps :: * -> *))
                 (@ (g_ae3pt :: * -> *))
                 (@ p_ae3pu)
                 ($dTypeable_ae3pv [Occ=Once] :: Typeable f_ae3ps)
                 ($dTypeable1_ae3pw [Occ=Once] :: Typeable g_ae3pt)
                 ($dData_ae3px [Occ=Once] :: Data p_ae3pu)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ (f_ae3ps :+: g_ae3pt)
                   @ p_ae3pu
                   (Data.Typeable.Internal.mkTrApp
                      @ (* -> *)
                      @ (* -> *)
                      @ ((:+:) f_ae3ps)
                      @ g_ae3pt
                      (Data.Typeable.Internal.mkTrApp
                         @ (* -> *)
                         @ ((* -> *) -> * -> *)
                         @ (:+:)
                         @ f_ae3ps
                         Data.Data.$fData:+:6
                         ($dTypeable_ae3pv
                          `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <f_ae3ps>_N
                                  :: (Typeable f_ae3ps :: Constraint)
                                     ~R# (Data.Typeable.Internal.TypeRep f_ae3ps :: *))))
                      ($dTypeable1_ae3pw
                       `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <g_ae3pt>_N
                               :: (Typeable g_ae3pt :: Constraint)
                                  ~R# (Data.Typeable.Internal.TypeRep g_ae3pt :: *))))
                   ((Data.Data.$p1Data @ p_ae3pu $dData_ae3px)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <p_ae3pu>_N
                            :: (Typeable p_ae3pu :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep p_ae3pu :: *)))}]
Data.Data.$fData:+:5
  = \ (@ (f_ae3ps :: * -> *))
      (@ (g_ae3pt :: * -> *))
      (@ p_ae3pu)
      ($dTypeable_ae3pv :: Typeable f_ae3ps)
      ($dTypeable1_ae3pw :: Typeable g_ae3pt)
      ($dData_ae3px :: Data p_ae3pu)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ (f_ae3ps :+: g_ae3pt)
        @ p_ae3pu
        (Data.Typeable.Internal.mkTrApp
           @ (* -> *)
           @ (* -> *)
           @ ((:+:) f_ae3ps)
           @ g_ae3pt
           (Data.Typeable.Internal.mkTrApp
              @ (* -> *)
              @ ((* -> *) -> * -> *)
              @ (:+:)
              @ f_ae3ps
              Data.Data.$fData:+:6
              ($dTypeable_ae3pv
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <f_ae3ps>_N
                       :: (Typeable f_ae3ps :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep f_ae3ps :: *))))
           ($dTypeable1_ae3pw
            `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <g_ae3pt>_N
                    :: (Typeable g_ae3pt :: Constraint)
                       ~R# (Data.Typeable.Internal.TypeRep g_ae3pt :: *))))
        ((Data.Data.$p1Data @ p_ae3pu $dData_ae3px)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <p_ae3pu>_N
                 :: (Typeable p_ae3pu :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep p_ae3pu :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fData:.:10 :: [Data.Typeable.Internal.SomeTypeRep]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData:.:10
  = GHC.Types.:
      @ Data.Typeable.Internal.SomeTypeRep
      Data.Data.$fData:*:10
      Data.Data.$fData:*:9

-- RHS size: {terms: 16, types: 56, coercions: 0, joins: 0/0}
Data.Data.$fData:.:9 :: Data.Typeable.Internal.TypeRep (:.:)
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fData:.:9
  = case Data.Typeable.Internal.$wmkTrCon
           @ ((* -> *) -> (* -> *) -> * -> *)
           @ (:.:)
           8789806176127571161##
           6690830460180204262##
           GHC.Generics.$trModule
           GHC.Generics.$tc:.:2
           2#
           GHC.Generics.$tc:.:1
           Data.Data.$fData:.:10
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ ((* -> *) -> (* -> *) -> * -> *)
      @ (:.:)
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 15, types: 51, coercions: 12, joins: 0/0}
Data.Data.$fData:.:8
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f (g p))) =>
     Data.Typeable.Internal.TypeRep ((:.:) f g p)
[GblId,
 Arity=4,
 Str=<S,U><S,U><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ae3m0 :: * -> *))
                 (@ (g_ae3m1 :: * -> *))
                 (@ p_ae3m2)
                 ($dTypeable_ae3m3 [Occ=Once] :: Typeable f_ae3m0)
                 ($dTypeable1_ae3m4 [Occ=Once] :: Typeable g_ae3m1)
                 ($dData_ae3m5 [Occ=Once] :: Data p_ae3m2)
                 _ [Occ=Dead] ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ (f_ae3m0 :.: g_ae3m1)
                   @ p_ae3m2
                   (Data.Typeable.Internal.mkTrApp
                      @ (* -> *)
                      @ (* -> *)
                      @ ((:.:) f_ae3m0)
                      @ g_ae3m1
                      (Data.Typeable.Internal.mkTrApp
                         @ (* -> *)
                         @ ((* -> *) -> * -> *)
                         @ (:.:)
                         @ f_ae3m0
                         Data.Data.$fData:.:9
                         ($dTypeable_ae3m3
                          `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <f_ae3m0>_N
                                  :: (Typeable f_ae3m0 :: Constraint)
                                     ~R# (Data.Typeable.Internal.TypeRep f_ae3m0 :: *))))
                      ($dTypeable1_ae3m4
                       `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <g_ae3m1>_N
                               :: (Typeable g_ae3m1 :: Constraint)
                                  ~R# (Data.Typeable.Internal.TypeRep g_ae3m1 :: *))))
                   ((Data.Data.$p1Data @ p_ae3m2 $dData_ae3m5)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <p_ae3m2>_N
                            :: (Typeable p_ae3m2 :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep p_ae3m2 :: *)))}]
Data.Data.$fData:.:8
  = \ (@ (f_ae3m0 :: * -> *))
      (@ (g_ae3m1 :: * -> *))
      (@ p_ae3m2)
      ($dTypeable_ae3m3 :: Typeable f_ae3m0)
      ($dTypeable1_ae3m4 :: Typeable g_ae3m1)
      ($dData_ae3m5 :: Data p_ae3m2)
      _ [Occ=Dead] ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ (f_ae3m0 :.: g_ae3m1)
        @ p_ae3m2
        (Data.Typeable.Internal.mkTrApp
           @ (* -> *)
           @ (* -> *)
           @ ((:.:) f_ae3m0)
           @ g_ae3m1
           (Data.Typeable.Internal.mkTrApp
              @ (* -> *)
              @ ((* -> *) -> * -> *)
              @ (:.:)
              @ f_ae3m0
              Data.Data.$fData:.:9
              ($dTypeable_ae3m3
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <f_ae3m0>_N
                       :: (Typeable f_ae3m0 :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep f_ae3m0 :: *))))
           ($dTypeable1_ae3m4
            `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <g_ae3m1>_N
                    :: (Typeable g_ae3m1 :: Constraint)
                       ~R# (Data.Typeable.Internal.TypeRep g_ae3m1 :: *))))
        ((Data.Data.$p1Data @ p_ae3m2 $dData_ae3m5)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <p_ae3m2>_N
                 :: (Typeable p_ae3m2 :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep p_ae3m2 :: *)))

-- RHS size: {terms: 16, types: 44, coercions: 0, joins: 0/0}
Data.Data.$fDataV6 :: Data.Typeable.Internal.TypeRep V1
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataV6
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ V1
           9632074298958870877##
           12839190861712118115##
           GHC.Generics.$trModule
           GHC.Generics.$tcV2
           1#
           GHC.Generics.$tcSing1
           Data.Data.$fData:*:9
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ V1
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 6, types: 13, coercions: 4, joins: 0/0}
Data.Data.$fDataV5
  :: forall p. Data p => Data.Typeable.Internal.TypeRep (V1 p)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ p_ae3iR) ($dData_ae3iS [Occ=Once] :: Data p_ae3iR) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ V1
                   @ p_ae3iR
                   Data.Data.$fDataV6
                   ((Data.Data.$p1Data @ p_ae3iR $dData_ae3iS)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <p_ae3iR>_N
                            :: (Typeable p_ae3iR :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep p_ae3iR :: *)))}]
Data.Data.$fDataV5
  = \ (@ p_ae3iR) ($dData_ae3iS :: Data p_ae3iR) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ V1
        @ p_ae3iR
        Data.Data.$fDataV6
        ((Data.Data.$p1Data @ p_ae3iR $dData_ae3iS)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <p_ae3iR>_N
                 :: (Typeable p_ae3iR :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep p_ae3iR :: *)))

-- RHS size: {terms: 23, types: 100, coercions: 0, joins: 0/0}
Data.Data.$fData:*:_$cgfoldl
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f p), Data (g p)) =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g1. g1 -> c g1) -> (:*:) f g p -> c ((:*:) f g p)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,U><L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=8,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ae3fk :: * -> *))
                 (@ (g_ae3fl :: * -> *))
                 (@ p_ae3fm)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 ($dData1_ae3fq [Occ=Once] :: Data (f_ae3fk p_ae3fm))
                 ($dData2_ae3fr [Occ=Once] :: Data (g_ae3fl p_ae3fm))
                 (@ (c_ae3fz :: * -> *))
                 (k_ae2nd
                    :: forall d b. Data d => c_ae3fz (d -> b) -> d -> c_ae3fz b)
                 (z_ae2ne [Occ=Once!] :: forall g1. g1 -> c_ae3fz g1)
                 (ds_de7s3 [Occ=Once!] :: (:*:) f_ae3fk g_ae3fl p_ae3fm) ->
                 case ds_de7s3 of { :*: a1_ae2nf [Occ=Once] a2_ae2ng [Occ=Once] ->
                 k_ae2nd
                   @ (g_ae3fl p_ae3fm)
                   @ ((:*:) f_ae3fk g_ae3fl p_ae3fm)
                   $dData2_ae3fr
                   (k_ae2nd
                      @ (f_ae3fk p_ae3fm)
                      @ (g_ae3fl p_ae3fm -> (:*:) f_ae3fk g_ae3fl p_ae3fm)
                      $dData1_ae3fq
                      (z_ae2ne
                         @ (f_ae3fk p_ae3fm
                            -> g_ae3fl p_ae3fm -> (:*:) f_ae3fk g_ae3fl p_ae3fm)
                         (GHC.Generics.:*: @ * @ f_ae3fk @ g_ae3fl @ p_ae3fm))
                      a1_ae2nf)
                   a2_ae2ng
                 }}]
Data.Data.$fData:*:_$cgfoldl
  = \ (@ (f_ae3fk :: * -> *))
      (@ (g_ae3fl :: * -> *))
      (@ p_ae3fm)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      ($dData1_ae3fq :: Data (f_ae3fk p_ae3fm))
      ($dData2_ae3fr :: Data (g_ae3fl p_ae3fm))
      (@ (c_ae3fz :: * -> *))
      (k_ae2nd
         :: forall d b. Data d => c_ae3fz (d -> b) -> d -> c_ae3fz b)
      (z_ae2ne :: forall g1. g1 -> c_ae3fz g1)
      (ds_de7s3 :: (:*:) f_ae3fk g_ae3fl p_ae3fm) ->
      case ds_de7s3 of { :*: a1_ae2nf a2_ae2ng ->
      k_ae2nd
        @ (g_ae3fl p_ae3fm)
        @ ((:*:) f_ae3fk g_ae3fl p_ae3fm)
        $dData2_ae3fr
        (k_ae2nd
           @ (f_ae3fk p_ae3fm)
           @ (g_ae3fl p_ae3fm -> (:*:) f_ae3fk g_ae3fl p_ae3fm)
           $dData1_ae3fq
           (z_ae2ne
              @ (f_ae3fk p_ae3fm
                 -> g_ae3fl p_ae3fm -> (:*:) f_ae3fk g_ae3fl p_ae3fm)
              (GHC.Generics.:*: @ * @ f_ae3fk @ g_ae3fl @ p_ae3fm))
           a1_ae2nf)
        a2_ae2ng
      }

-- RHS size: {terms: 16, types: 68, coercions: 0, joins: 0/0}
Data.Data.$fData:*:8 :: Data.Typeable.Internal.TypeRep (:*:)
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fData:*:8
  = case Data.Typeable.Internal.$wmkTrCon
           @ ((* -> *) -> (* -> *) -> * -> *)
           @ (:*:)
           13255908348437976871##
           2298886013668999863##
           GHC.Generics.$trModule
           GHC.Generics.$tc:*:2
           1#
           GHC.Generics.$tc:*:1
           Data.Data.$fData:*:9
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ ((* -> *) -> (* -> *) -> * -> *)
      @ (:*:)
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 16, types: 67, coercions: 16, joins: 0/0}
Data.Data.$fData:*:7
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f p), Data (g p)) =>
     Data.Typeable.Internal.TypeRep ((:*:) f g p)
[GblId,
 Arity=5,
 Str=<S,U><S,U><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_ae3fk :: * -> *))
                 (@ (g_ae3fl :: * -> *))
                 (@ p_ae3fm)
                 ($dTypeable_ae3fn [Occ=Once] :: Typeable f_ae3fk)
                 ($dTypeable1_ae3fo [Occ=Once] :: Typeable g_ae3fl)
                 ($dData_ae3fp [Occ=Once] :: Data p_ae3fm)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ (f_ae3fk :*: g_ae3fl)
                   @ p_ae3fm
                   (Data.Typeable.Internal.mkTrApp
                      @ (* -> *)
                      @ (* -> *)
                      @ ((:*:) f_ae3fk)
                      @ g_ae3fl
                      (Data.Typeable.Internal.mkTrApp
                         @ (* -> *)
                         @ ((* -> *) -> * -> *)
                         @ (:*:)
                         @ f_ae3fk
                         Data.Data.$fData:*:8
                         ($dTypeable_ae3fn
                          `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <f_ae3fk>_N
                                  :: (Typeable f_ae3fk :: Constraint)
                                     ~R# (Data.Typeable.Internal.TypeRep f_ae3fk :: *))))
                      ($dTypeable1_ae3fo
                       `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <g_ae3fl>_N
                               :: (Typeable g_ae3fl :: Constraint)
                                  ~R# (Data.Typeable.Internal.TypeRep g_ae3fl :: *))))
                   ((Data.Data.$p1Data @ p_ae3fm $dData_ae3fp)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <p_ae3fm>_N
                            :: (Typeable p_ae3fm :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep p_ae3fm :: *)))}]
Data.Data.$fData:*:7
  = \ (@ (f_ae3fk :: * -> *))
      (@ (g_ae3fl :: * -> *))
      (@ p_ae3fm)
      ($dTypeable_ae3fn :: Typeable f_ae3fk)
      ($dTypeable1_ae3fo :: Typeable g_ae3fl)
      ($dData_ae3fp :: Data p_ae3fm)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ (f_ae3fk :*: g_ae3fl)
        @ p_ae3fm
        (Data.Typeable.Internal.mkTrApp
           @ (* -> *)
           @ (* -> *)
           @ ((:*:) f_ae3fk)
           @ g_ae3fl
           (Data.Typeable.Internal.mkTrApp
              @ (* -> *)
              @ ((* -> *) -> * -> *)
              @ (:*:)
              @ f_ae3fk
              Data.Data.$fData:*:8
              ($dTypeable_ae3fn
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <f_ae3fk>_N
                       :: (Typeable f_ae3fk :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep f_ae3fk :: *))))
           ($dTypeable1_ae3fo
            `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <g_ae3fl>_N
                    :: (Typeable g_ae3fl :: Constraint)
                       ~R# (Data.Typeable.Internal.TypeRep g_ae3fl :: *))))
        ((Data.Data.$p1Data @ p_ae3fm $dData_ae3fp)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <p_ae3fm>_N
                 :: (Typeable p_ae3fm :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep p_ae3fm :: *)))

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataFixity3
  :: Data.Typeable.Internal.TypeRep Generics.Fixity
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataFixity3
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Generics.Fixity
           10158122866360083471##
           8414164801158892890##
           GHC.Generics.$trModule
           GHC.Generics.$tcFixity1
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ Generics.Fixity
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 15, types: 26, coercions: 0, joins: 0/0}
Data.Data.$fDataAssociativity_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Associativity -> c Associativity
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_ae38X :: * -> *))
                 _ [Occ=Dead]
                 (z_ae2mW [Occ=Once*!] :: forall g. g -> c_ae38X g)
                 (ds_de7rh [Occ=Once!] :: Associativity) ->
                 case ds_de7rh of {
                   LeftAssociative ->
                     z_ae2mW @ Associativity GHC.Generics.LeftAssociative;
                   RightAssociative ->
                     z_ae2mW @ Associativity GHC.Generics.RightAssociative;
                   NotAssociative ->
                     z_ae2mW @ Associativity GHC.Generics.NotAssociative
                 }}]
Data.Data.$fDataAssociativity_$cgfoldl
  = \ (@ (c_ae38X :: * -> *))
      _ [Occ=Dead]
      (z_ae2mW :: forall g. g -> c_ae38X g)
      (ds_de7rh :: Associativity) ->
      case ds_de7rh of {
        LeftAssociative ->
          z_ae2mW @ Associativity GHC.Generics.LeftAssociative;
        RightAssociative ->
          z_ae2mW @ Associativity GHC.Generics.RightAssociative;
        NotAssociative ->
          z_ae2mW @ Associativity GHC.Generics.NotAssociative
      }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataAssociativity6
  :: Data.Typeable.Internal.TypeRep Associativity
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataAssociativity6
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Associativity
           12154903443467503095##
           5549444501505731770##
           GHC.Generics.$trModule
           GHC.Generics.$tcAssociativity1
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ Associativity
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 15, types: 26, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceUnpackedness_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> SourceUnpackedness
     -> c SourceUnpackedness
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_ae35O :: * -> *))
                 _ [Occ=Dead]
                 (z_ae2mN [Occ=Once*!] :: forall g. g -> c_ae35O g)
                 (ds_de7qU [Occ=Once!] :: SourceUnpackedness) ->
                 case ds_de7qU of {
                   NoSourceUnpackedness ->
                     z_ae2mN @ SourceUnpackedness GHC.Generics.NoSourceUnpackedness;
                   SourceNoUnpack ->
                     z_ae2mN @ SourceUnpackedness GHC.Generics.SourceNoUnpack;
                   SourceUnpack ->
                     z_ae2mN @ SourceUnpackedness GHC.Generics.SourceUnpack
                 }}]
Data.Data.$fDataSourceUnpackedness_$cgfoldl
  = \ (@ (c_ae35O :: * -> *))
      _ [Occ=Dead]
      (z_ae2mN :: forall g. g -> c_ae35O g)
      (ds_de7qU :: SourceUnpackedness) ->
      case ds_de7qU of {
        NoSourceUnpackedness ->
          z_ae2mN @ SourceUnpackedness GHC.Generics.NoSourceUnpackedness;
        SourceNoUnpack ->
          z_ae2mN @ SourceUnpackedness GHC.Generics.SourceNoUnpack;
        SourceUnpack ->
          z_ae2mN @ SourceUnpackedness GHC.Generics.SourceUnpack
      }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceUnpackedness6
  :: Data.Typeable.Internal.TypeRep SourceUnpackedness
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataSourceUnpackedness6
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ SourceUnpackedness
           2430401875125873516##
           18138240737126467764##
           GHC.Generics.$trModule
           GHC.Generics.$tcSourceUnpackedness1
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ SourceUnpackedness
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 15, types: 26, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceStrictness_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> SourceStrictness -> c SourceStrictness
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_ae32F :: * -> *))
                 _ [Occ=Dead]
                 (z_ae2mE [Occ=Once*!] :: forall g. g -> c_ae32F g)
                 (ds_de7qx [Occ=Once!] :: SourceStrictness) ->
                 case ds_de7qx of {
                   NoSourceStrictness ->
                     z_ae2mE @ SourceStrictness GHC.Generics.NoSourceStrictness;
                   SourceLazy -> z_ae2mE @ SourceStrictness GHC.Generics.SourceLazy;
                   SourceStrict ->
                     z_ae2mE @ SourceStrictness GHC.Generics.SourceStrict
                 }}]
Data.Data.$fDataSourceStrictness_$cgfoldl
  = \ (@ (c_ae32F :: * -> *))
      _ [Occ=Dead]
      (z_ae2mE :: forall g. g -> c_ae32F g)
      (ds_de7qx :: SourceStrictness) ->
      case ds_de7qx of {
        NoSourceStrictness ->
          z_ae2mE @ SourceStrictness GHC.Generics.NoSourceStrictness;
        SourceLazy -> z_ae2mE @ SourceStrictness GHC.Generics.SourceLazy;
        SourceStrict ->
          z_ae2mE @ SourceStrictness GHC.Generics.SourceStrict
      }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceStrictness6
  :: Data.Typeable.Internal.TypeRep SourceStrictness
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataSourceStrictness6
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ SourceStrictness
           12722581723425749841##
           17710543875920093053##
           GHC.Generics.$trModule
           GHC.Generics.$tcSourceStrictness1
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ SourceStrictness
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 15, types: 26, coercions: 0, joins: 0/0}
Data.Data.$fDataDecidedStrictness_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> DecidedStrictness -> c DecidedStrictness
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_ae2Zw :: * -> *))
                 _ [Occ=Dead]
                 (z_ae2mv [Occ=Once*!] :: forall g. g -> c_ae2Zw g)
                 (ds_de7qa [Occ=Once!] :: DecidedStrictness) ->
                 case ds_de7qa of {
                   DecidedLazy ->
                     z_ae2mv @ DecidedStrictness GHC.Generics.DecidedLazy;
                   DecidedStrict ->
                     z_ae2mv @ DecidedStrictness GHC.Generics.DecidedStrict;
                   DecidedUnpack ->
                     z_ae2mv @ DecidedStrictness GHC.Generics.DecidedUnpack
                 }}]
Data.Data.$fDataDecidedStrictness_$cgfoldl
  = \ (@ (c_ae2Zw :: * -> *))
      _ [Occ=Dead]
      (z_ae2mv :: forall g. g -> c_ae2Zw g)
      (ds_de7qa :: DecidedStrictness) ->
      case ds_de7qa of {
        DecidedLazy ->
          z_ae2mv @ DecidedStrictness GHC.Generics.DecidedLazy;
        DecidedStrict ->
          z_ae2mv @ DecidedStrictness GHC.Generics.DecidedStrict;
        DecidedUnpack ->
          z_ae2mv @ DecidedStrictness GHC.Generics.DecidedUnpack
      }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fDataDecidedStrictness6
  :: Data.Typeable.Internal.TypeRep DecidedStrictness
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Data.$fDataDecidedStrictness6
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ DecidedStrictness
           7991843135210125273##
           3692579892163919576##
           GHC.Generics.$trModule
           GHC.Generics.$tcDecidedStrictness1
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ *
      @ DecidedStrictness
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 31, types: 48, coercions: 0, joins: 0/1}
Data.Data.$dmgmapM
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> a -> m a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,U,A)><L,C(C1(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae1S5)
                 ($dData_ae2Pa [Occ=Once] :: Data a_ae1S5)
                 (@ (m_ae2UT :: * -> *))
                 ($dMonad_ae2UV :: Monad m_ae2UT)
                 (f_ae1Ti [Occ=OnceL!] :: forall d. Data d => d -> m_ae2UT d) ->
                 gfoldl
                   @ a_ae1S5
                   $dData_ae2Pa
                   @ m_ae2UT
                   (\ (@ d_ae2Vh)
                      (@ b_ae2Vi)
                      ($dData1_ae2Vk [Occ=OnceL] :: Data d_ae2Vh)
                      (c_ae1Tm [Occ=Once] :: m_ae2UT (d_ae2Vh -> b_ae2Vi))
                      (x_ae1Tn [Occ=OnceL] :: d_ae2Vh) ->
                      >>=
                        @ m_ae2UT
                        $dMonad_ae2UV
                        @ (d_ae2Vh -> b_ae2Vi)
                        @ b_ae2Vi
                        c_ae1Tm
                        (\ (c'_ae1To [Occ=OnceL!] :: d_ae2Vh -> b_ae2Vi) ->
                           >>=
                             @ m_ae2UT
                             $dMonad_ae2UV
                             @ d_ae2Vh
                             @ b_ae2Vi
                             (f_ae1Ti @ d_ae2Vh $dData1_ae2Vk x_ae1Tn)
                             (\ (x'_ae1Tp [Occ=Once] :: d_ae2Vh) ->
                                return @ m_ae2UT $dMonad_ae2UV @ b_ae2Vi (c'_ae1To x'_ae1Tp))))
                   (\ (@ g_ae2VN) -> return @ m_ae2UT $dMonad_ae2UV @ g_ae2VN)}]
Data.Data.$dmgmapM
  = \ (@ a_ae1S5)
      ($dData_ae2Pa :: Data a_ae1S5)
      (@ (m_ae2UT :: * -> *))
      ($dMonad_ae2UV :: Monad m_ae2UT)
      (f_ae1Ti :: forall d. Data d => d -> m_ae2UT d) ->
      gfoldl
        @ a_ae1S5
        $dData_ae2Pa
        @ m_ae2UT
        (\ (@ d_ae2Vh)
           (@ b_ae2Vi)
           ($dData1_ae2Vk :: Data d_ae2Vh)
           (c_ae1Tm :: m_ae2UT (d_ae2Vh -> b_ae2Vi))
           (x_ae1Tn :: d_ae2Vh) ->
           let {
             lvl270_se9AX :: m_ae2UT d_ae2Vh
             [LclId]
             lvl270_se9AX = f_ae1Ti @ d_ae2Vh $dData1_ae2Vk x_ae1Tn } in
           >>=
             @ m_ae2UT
             $dMonad_ae2UV
             @ (d_ae2Vh -> b_ae2Vi)
             @ b_ae2Vi
             c_ae1Tm
             (\ (c'_ae1To :: d_ae2Vh -> b_ae2Vi) ->
                >>=
                  @ m_ae2UT
                  $dMonad_ae2UV
                  @ d_ae2Vh
                  @ b_ae2Vi
                  lvl270_se9AX
                  (\ (x'_ae1Tp :: d_ae2Vh) ->
                     return @ m_ae2UT $dMonad_ae2UV @ b_ae2Vi (c'_ae1To x'_ae1Tp))))
        (\ (@ g_ae2VN) -> return @ m_ae2UT $dMonad_ae2UV @ g_ae2VN)

-- RHS size: {terms: 9, types: 18, coercions: 0, joins: 0/0}
Data.Data.$dmgmapQ
  :: forall a.
     Data a =>
     forall u. (forall d. Data d => d -> u) -> a -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLC(C(C(S)))LLLLL),1*U(A,A,A,A,A,A,A,A,A,1*C1(C1(C1(U))),A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae1S5)
                 ($dData_ae2Pa [Occ=Once] :: Data a_ae1S5)
                 (@ u_ae2T2)
                 (f_ae1T4 [Occ=Once] :: forall d. Data d => d -> u_ae2T2) ->
                 gmapQr
                   @ a_ae1S5
                   $dData_ae2Pa
                   @ [u_ae2T2]
                   @ u_ae2T2
                   (GHC.Types.: @ u_ae2T2)
                   (GHC.Types.[] @ u_ae2T2)
                   f_ae1T4}]
Data.Data.$dmgmapQ
  = \ (@ a_ae1S5)
      ($dData_ae2Pa :: Data a_ae1S5)
      (@ u_ae2T2)
      (f_ae1T4 :: forall d. Data d => d -> u_ae2T2) ->
      gmapQr
        @ a_ae1S5
        $dData_ae2Pa
        @ [u_ae2T2]
        @ u_ae2T2
        (GHC.Types.: @ u_ae2T2)
        (GHC.Types.[] @ u_ae2T2)
        f_ae1T4

-- RHS size: {terms: 26, types: 47, coercions: 48, joins: 0/1}
Data.Data.$dmgmapQl
  :: forall a.
     Data a =>
     forall r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,C(C1(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae1S5)
                 ($dData_ae2Pa [Occ=Once] :: Data a_ae1S5)
                 (@ r_ae2Qo)
                 (@ r'_ae2Qp)
                 (o_ae1SK [Occ=OnceL!] :: r_ae2Qo -> r'_ae2Qp -> r_ae2Qo)
                 (r1_ae1SL [Occ=OnceL] :: r_ae2Qo)
                 (f_ae1SM [Occ=OnceL!] :: forall d. Data d => d -> r'_ae2Qp) ->
                 let {
                   g_i7Rxh [Occ=OnceL!] :: a_ae1S5 -> Const r_ae2Qo a_ae1S5
                   [LclId]
                   g_i7Rxh
                     = gfoldl
                         @ a_ae1S5
                         $dData_ae2Pa
                         @ (Const r_ae2Qo)
                         ((\ (@ d_ae2R3)
                             (@ b_ae2R4)
                             ($dData1_ae2R6 [Occ=Once] :: Data d_ae2R3)
                             (c_ae1SS [Occ=Once] :: Const r_ae2Qo (d_ae2R3 -> b_ae2R4))
                             (x_ae1ST [Occ=Once] :: d_ae2R3) ->
                             o_ae1SK
                               (c_ae1SS
                                `cast` (Data.Functor.Const.N:Const[0]
                                            <*>_N <r_ae2Qo>_R <d_ae2R3 -> b_ae2R4>_P
                                        :: (Const r_ae2Qo (d_ae2R3 -> b_ae2R4) :: *)
                                           ~R# (r_ae2Qo :: *)))
                               (f_ae1SM @ d_ae2R3 $dData1_ae2R6 x_ae1ST))
                          `cast` (forall (d :: <*>_N) (b :: <*>_N).
                                  <Data d>_R
                                  ->_R <Const r_ae2Qo (d -> b)>_R
                                  ->_R <d>_R
                                  ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r_ae2Qo>_R <b>_P)
                                  :: (forall d b.
                                      Data d =>
                                      Const r_ae2Qo (d -> b) -> d -> r_ae2Qo :: *)
                                     ~R# (forall d b.
                                          Data d =>
                                          Const r_ae2Qo (d -> b) -> d -> Const r_ae2Qo b :: *)))
                         ((\ (@ g1_ae2RK) _ [Occ=Dead] -> r1_ae1SL)
                          `cast` (forall (g1 :: <*>_N).
                                  <g1>_R
                                  ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r_ae2Qo>_R <g1>_P)
                                  :: (forall g1. g1 -> r_ae2Qo :: *)
                                     ~R# (forall g1. g1 -> Const r_ae2Qo g1 :: *))) } in
                 (\ (x_i7Rxi [Occ=Once] :: a_ae1S5) -> g_i7Rxh x_i7Rxi)
                 `cast` (<a_ae1S5>_R
                         ->_R Data.Functor.Const.N:Const[0] <*>_N <r_ae2Qo>_R <a_ae1S5>_P
                         :: (a_ae1S5 -> Const r_ae2Qo a_ae1S5 :: *)
                            ~R# (a_ae1S5 -> r_ae2Qo :: *))}]
Data.Data.$dmgmapQl
  = \ (@ a_ae1S5)
      ($dData_ae2Pa :: Data a_ae1S5)
      (@ r_ae2Qo)
      (@ r'_ae2Qp)
      (o_ae1SK :: r_ae2Qo -> r'_ae2Qp -> r_ae2Qo)
      (r1_ae1SL :: r_ae2Qo)
      (f_ae1SM :: forall d. Data d => d -> r'_ae2Qp) ->
      let {
        g_se9ws [Dmd=<L,C(U)>] :: a_ae1S5 -> Const r_ae2Qo a_ae1S5
        [LclId]
        g_se9ws
          = gfoldl
              @ a_ae1S5
              $dData_ae2Pa
              @ (Const r_ae2Qo)
              ((\ (@ d_ae2R3)
                  (@ b_ae2R4)
                  ($dData1_ae2R6 :: Data d_ae2R3)
                  (c_ae1SS :: Const r_ae2Qo (d_ae2R3 -> b_ae2R4))
                  (x_ae1ST :: d_ae2R3) ->
                  o_ae1SK
                    (c_ae1SS
                     `cast` (Data.Functor.Const.N:Const[0]
                                 <*>_N <r_ae2Qo>_R <d_ae2R3 -> b_ae2R4>_P
                             :: (Const r_ae2Qo (d_ae2R3 -> b_ae2R4) :: *) ~R# (r_ae2Qo :: *)))
                    (f_ae1SM @ d_ae2R3 $dData1_ae2R6 x_ae1ST))
               `cast` (forall (d :: <*>_N) (b :: <*>_N).
                       <Data d>_R
                       ->_R <Const r_ae2Qo (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r_ae2Qo>_R <b>_P)
                       :: (forall d b.
                           Data d =>
                           Const r_ae2Qo (d -> b) -> d -> r_ae2Qo :: *)
                          ~R# (forall d b.
                               Data d =>
                               Const r_ae2Qo (d -> b) -> d -> Const r_ae2Qo b :: *)))
              ((\ (@ g1_ae2RK) _ [Occ=Dead] -> r1_ae1SL)
               `cast` (forall (g1 :: <*>_N).
                       <g1>_R
                       ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r_ae2Qo>_R <g1>_P)
                       :: (forall g1. g1 -> r_ae2Qo :: *)
                          ~R# (forall g1. g1 -> Const r_ae2Qo g1 :: *))) } in
      (\ (x_i7Rxi :: a_ae1S5) -> g_se9ws x_i7Rxi)
      `cast` (<a_ae1S5>_R
              ->_R Data.Functor.Const.N:Const[0] <*>_N <r_ae2Qo>_R <a_ae1S5>_P
              :: (a_ae1S5 -> Const r_ae2Qo a_ae1S5 :: *)
                 ~R# (a_ae1S5 -> r_ae2Qo :: *))

-- RHS size: {terms: 17, types: 24, coercions: 29, joins: 0/0}
$dmgmapT1_rejMl
  :: forall a.
     Data a =>
     (forall b. Data b => b -> b) -> a -> Identity a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []]
$dmgmapT1_rejMl
  = \ (@ a_ae1S5)
      ($dData_ae2Pa :: Data a_ae1S5)
      (f_ae1SD :: forall b. Data b => b -> b)
      (x0_ae1SE :: a_ae1S5) ->
      gfoldl
        @ a_ae1S5
        $dData_ae2Pa
        @ Identity
        ((\ (@ d_ae2PV)
            (@ b_ae2PW)
            ($dData1_ae2PY :: Data d_ae2PV)
            (ds_de7mO :: Identity (d_ae2PV -> b_ae2PW))
            (x_ae1SJ :: d_ae2PV) ->
            (ds_de7mO
             `cast` (Data.Functor.Identity.N:Identity[0] <d_ae2PV -> b_ae2PW>_R
                     :: (Identity (d_ae2PV -> b_ae2PW) :: *)
                        ~R# (d_ae2PV -> b_ae2PW :: *)))
              (f_ae1SD @ d_ae2PV $dData1_ae2PY x_ae1SJ))
         `cast` (forall (d :: <*>_N) (b :: <*>_N).
                 <Data d>_R
                 ->_R <Identity (d -> b)>_R
                 ->_R <d>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R)
                 :: (forall d b. Data d => Identity (d -> b) -> d -> b :: *)
                    ~R# (forall d b.
                         Data d =>
                         Identity (d -> b) -> d -> Identity b :: *)))
        (Data.Data.$fDataConst2
         `cast` (forall (g :: <*>_N).
                 <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R)
                 :: (forall g. g -> g :: *) ~R# (forall g. g -> Identity g :: *)))
        x0_ae1SE

-- RHS size: {terms: 1, types: 0, coercions: 17, joins: 0/0}
Data.Data.$dmgmapT
  :: forall a. Data a => (forall b. Data b => b -> b) -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= (\ (@ a_Xe2iK)
                  ($dData_Xe3fQ [Occ=Once] :: Data a_Xe2iK)
                  (f_Xe2jk [Occ=OnceL!] :: forall b. Data b => b -> b)
                  (x0_Xe2jm [Occ=Once] :: a_Xe2iK) ->
                  gfoldl
                    @ a_Xe2iK
                    $dData_Xe3fQ
                    @ Identity
                    ((\ (@ d_ae2PV)
                        (@ b_ae2PW)
                        ($dData1_ae2PY [Occ=Once] :: Data d_ae2PV)
                        (ds_de7mO [Occ=Once] :: Identity (d_ae2PV -> b_ae2PW))
                        (x_ae1SJ [Occ=Once] :: d_ae2PV) ->
                        (ds_de7mO
                         `cast` (Data.Functor.Identity.N:Identity[0] <d_ae2PV -> b_ae2PW>_R
                                 :: (Identity (d_ae2PV -> b_ae2PW) :: *)
                                    ~R# (d_ae2PV -> b_ae2PW :: *)))
                          (f_Xe2jk @ d_ae2PV $dData1_ae2PY x_ae1SJ))
                     `cast` (forall (d :: <*>_N) (b :: <*>_N).
                             <Data d>_R
                             ->_R <Identity (d -> b)>_R
                             ->_R <d>_R
                             ->_R Sym (Data.Functor.Identity.N:Identity[0] <b>_R)
                             :: (forall d b. Data d => Identity (d -> b) -> d -> b :: *)
                                ~R# (forall d b.
                                     Data d =>
                                     Identity (d -> b) -> d -> Identity b :: *)))
                    ((\ (@ g_ae2Qi) (v_B1 [Occ=Once] :: g_ae2Qi) -> v_B1)
                     `cast` (forall (g :: <*>_N).
                             <g>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <g>_R)
                             :: (forall g. g -> g :: *) ~R# (forall g. g -> Identity g :: *)))
                    x0_Xe2jm)
               `cast` (forall (a :: <*>_N).
                       <Data a>_R
                       ->_R <forall b. Data b => b -> b>_R
                       ->_R <a>_R
                       ->_R Data.Functor.Identity.N:Identity[0] <a>_R
                       :: (forall a.
                           Data a =>
                           (forall b. Data b => b -> b) -> a -> Identity a :: *)
                          ~R# (forall a.
                               Data a =>
                               (forall b. Data b => b -> b) -> a -> a :: *))}]
Data.Data.$dmgmapT
  = $dmgmapT1_rejMl
    `cast` (forall (a :: <*>_N).
            <Data a>_R
            ->_R <forall b. Data b => b -> b>_R
            ->_R <a>_R
            ->_R Data.Functor.Identity.N:Identity[0] <a>_R
            :: (forall a.
                Data a =>
                (forall b. Data b => b -> b) -> a -> Identity a :: *)
               ~R# (forall a.
                    Data a =>
                    (forall b. Data b => b -> b) -> a -> a :: *))

-- RHS size: {terms: 7, types: 36, coercions: 0, joins: 0/0}
Data.Data.$dmdataCast2
  :: forall a.
     Data a =>
     forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_Xe2iL)
                 _ [Occ=Dead]
                 (@ (t_ae2Pp :: * -> * -> *))
                 (@ (c_ae2Pq :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae2Pq a_Xe2iL)}]
Data.Data.$dmdataCast2
  = \ (@ a_Xe2iL)
      _ [Occ=Dead]
      (@ (t_ae2Pp :: * -> * -> *))
      (@ (c_ae2Pq :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae2Pq a_Xe2iL)

-- RHS size: {terms: 7, types: 27, coercions: 0, joins: 0/0}
Data.Data.$dmdataCast1
  :: forall a.
     Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_Xe2iM)
                 _ [Occ=Dead]
                 (@ (t_ae2Ph :: * -> *))
                 (@ (c_ae2Pi :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae2Pi a_Xe2iM)}]
Data.Data.$dmdataCast1
  = \ (@ a_Xe2iM)
      _ [Occ=Dead]
      (@ (t_ae2Ph :: * -> *))
      (@ (c_ae2Pi :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae2Pi a_Xe2iM)

-- RHS size: {terms: 6, types: 26, coercions: 0, joins: 0/0}
Data.Data.$dmgfoldl
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> a -> c a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_Xe2iN)
                 _ [Occ=Dead]
                 (@ (c_ae2Pc :: * -> *))
                 _ [Occ=Dead]
                 (z_ae1SC [Occ=Once] :: forall g. g -> c_ae2Pc g) ->
                 z_ae1SC @ a_Xe2iN}]
Data.Data.$dmgfoldl
  = \ (@ a_Xe2iN)
      _ [Occ=Dead]
      (@ (c_ae2Pc :: * -> *))
      _ [Occ=Dead]
      (z_ae1SC :: forall g. g -> c_ae2Pc g) ->
      z_ae1SC @ a_Xe2iN

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
Data.Data.unQr1 :: forall r k (a :: k). Qr r a -> Qr r a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae1YV)
                 (@ k_ae1YW)
                 (@ (a_ae1YX :: k_ae1YW))
                 (ds_de7my [Occ=Once] :: Qr r_ae1YV a_ae1YX) ->
                 ds_de7my}]
Data.Data.unQr1
  = \ (@ r_ae1YV)
      (@ k_ae1YW)
      (@ (a_ae1YX :: k_ae1YW))
      (ds_de7my :: Qr r_ae1YV a_ae1YX) ->
      ds_de7my

-- RHS size: {terms: 1, types: 0, coercions: 17, joins: 0/0}
unQr :: forall r k (a :: k). Qr r a -> r -> r
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Data.unQr1
               `cast` (forall (r :: <*>_N) (k :: <*>_N) (a :: <k>_N).
                       <Qr r a>_R ->_R Data.Data.N:Qr[0] <k>_N <r>_R <a>_P
                       :: (forall r k (a :: k). Qr r a -> Qr r a :: *)
                          ~R# (forall r k (a :: k). Qr r a -> r -> r :: *))}]
unQr
  = Data.Data.unQr1
    `cast` (forall (r :: <*>_N) (k :: <*>_N) (a :: <k>_N).
            <Qr r a>_R ->_R Data.Data.N:Qr[0] <k>_N <r>_R <a>_P
            :: (forall r k (a :: k). Qr r a -> Qr r a :: *)
               ~R# (forall r k (a :: k). Qr r a -> r -> r :: *))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
lvl13_rejMm :: forall r g. g -> r -> r
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><S,1*U>, Unf=OtherCon []]
lvl13_rejMm
  = \ (@ r_ae2RV) (@ g_ae2SQ) _ [Occ=Dead] (eta_B1 :: r_ae2RV) ->
      eta_B1

-- RHS size: {terms: 25, types: 40, coercions: 46, joins: 0/0}
Data.Data.$dmgmapQr
  :: forall a.
     Data a =>
     forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe2iU)
                 ($dData_Xe3g0 [Occ=Once] :: Data a_Xe2iU)
                 (@ r_ae2RV)
                 (@ r'_ae2RW)
                 (o_ae1SU [Occ=OnceL!] :: r'_ae2RW -> r_ae2RV -> r_ae2RV)
                 (r0_ae1SV [Occ=Once] :: r_ae2RV)
                 (f_ae1SW [Occ=OnceL!] :: forall d. Data d => d -> r'_ae2RW)
                 (x0_ae1SX [Occ=Once] :: a_Xe2iU) ->
                 ((gfoldl
                     @ a_Xe2iU
                     $dData_Xe3g0
                     @ (Qr r_ae2RV)
                     ((\ (@ d_ae2Sl)
                         (@ b_ae2Sm)
                         ($dData1_ae2So [Occ=Once] :: Data d_ae2Sl)
                         (ds_de7nc [Occ=Once] :: Qr r_ae2RV (d_ae2Sl -> b_ae2Sm))
                         (x_ae1T2 [Occ=Once] :: d_ae2Sl)
                         (r1_ae1T3 [Occ=Once] :: r_ae2RV) ->
                         (ds_de7nc
                          `cast` (Data.Data.N:Qr[0] <*>_N <r_ae2RV>_R <d_ae2Sl -> b_ae2Sm>_P
                                  :: (Qr r_ae2RV (d_ae2Sl -> b_ae2Sm) :: *)
                                     ~R# (r_ae2RV -> r_ae2RV :: *)))
                           (o_ae1SU (f_ae1SW @ d_ae2Sl $dData1_ae2So x_ae1T2) r1_ae1T3))
                      `cast` (forall (d :: <*>_N) (b :: <*>_N).
                              <Data d>_R
                              ->_R <Qr r_ae2RV (d -> b)>_R
                              ->_R <d>_R
                              ->_R Sym (Data.Data.N:Qr[0] <*>_N <r_ae2RV>_R <b>_P)
                              :: (forall d b.
                                  Data d =>
                                  Qr r_ae2RV (d -> b) -> d -> r_ae2RV -> r_ae2RV :: *)
                                 ~R# (forall d b.
                                      Data d =>
                                      Qr r_ae2RV (d -> b) -> d -> Qr r_ae2RV b :: *)))
                     ((\ (@ g_ae2SQ) _ [Occ=Dead] -> id @ r_ae2RV)
                      `cast` (forall (g :: <*>_N).
                              <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r_ae2RV>_R <g>_P)
                              :: (forall g. g -> r_ae2RV -> r_ae2RV :: *)
                                 ~R# (forall g. g -> Qr r_ae2RV g :: *)))
                     x0_ae1SX)
                  `cast` (Data.Data.N:Qr[0] <*>_N <r_ae2RV>_R <a_Xe2iU>_P
                          :: (Qr r_ae2RV a_Xe2iU :: *) ~R# (r_ae2RV -> r_ae2RV :: *)))
                   r0_ae1SV}]
Data.Data.$dmgmapQr
  = \ (@ a_Xe2iU)
      ($dData_Xe3g0 :: Data a_Xe2iU)
      (@ r_ae2RV)
      (@ r'_ae2RW)
      (o_ae1SU :: r'_ae2RW -> r_ae2RV -> r_ae2RV)
      (r0_ae1SV :: r_ae2RV)
      (f_ae1SW :: forall d. Data d => d -> r'_ae2RW)
      (x0_ae1SX :: a_Xe2iU) ->
      ((gfoldl
          @ a_Xe2iU
          $dData_Xe3g0
          @ (Qr r_ae2RV)
          ((\ (@ d_ae2Sl)
              (@ b_ae2Sm)
              ($dData1_ae2So :: Data d_ae2Sl)
              (ds_de7nc :: Qr r_ae2RV (d_ae2Sl -> b_ae2Sm))
              (x_ae1T2 :: d_ae2Sl)
              (r1_ae1T3 :: r_ae2RV) ->
              (ds_de7nc
               `cast` (Data.Data.N:Qr[0] <*>_N <r_ae2RV>_R <d_ae2Sl -> b_ae2Sm>_P
                       :: (Qr r_ae2RV (d_ae2Sl -> b_ae2Sm) :: *)
                          ~R# (r_ae2RV -> r_ae2RV :: *)))
                (o_ae1SU (f_ae1SW @ d_ae2Sl $dData1_ae2So x_ae1T2) r1_ae1T3))
           `cast` (forall (d :: <*>_N) (b :: <*>_N).
                   <Data d>_R
                   ->_R <Qr r_ae2RV (d -> b)>_R
                   ->_R <d>_R
                   ->_R Sym (Data.Data.N:Qr[0] <*>_N <r_ae2RV>_R <b>_P)
                   :: (forall d b.
                       Data d =>
                       Qr r_ae2RV (d -> b) -> d -> r_ae2RV -> r_ae2RV :: *)
                      ~R# (forall d b.
                           Data d =>
                           Qr r_ae2RV (d -> b) -> d -> Qr r_ae2RV b :: *)))
          ((lvl13_rejMm @ r_ae2RV)
           `cast` (forall (g :: <*>_N).
                   <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r_ae2RV>_R <g>_P)
                   :: (forall g. g -> r_ae2RV -> r_ae2RV :: *)
                      ~R# (forall g. g -> Qr r_ae2RV g :: *)))
          x0_ae1SX)
       `cast` (Data.Data.N:Qr[0] <*>_N <r_ae2RV>_R <a_Xe2iU>_P
               :: (Qr r_ae2RV a_Xe2iU :: *) ~R# (r_ae2RV -> r_ae2RV :: *)))
        r0_ae1SV

-- RHS size: {terms: 4, types: 9, coercions: 0, joins: 0/0}
Data.Data.unMp1 :: forall (m :: * -> *) x. Mp m x -> Mp m x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_ae1Zp :: * -> *))
                 (@ x_ae1Zq)
                 (ds_de7mw [Occ=Once] :: Mp m_ae1Zp x_ae1Zq) ->
                 ds_de7mw}]
Data.Data.unMp1
  = \ (@ (m_ae1Zp :: * -> *))
      (@ x_ae1Zq)
      (ds_de7mw :: Mp m_ae1Zp x_ae1Zq) ->
      ds_de7mw

-- RHS size: {terms: 1, types: 0, coercions: 15, joins: 0/0}
unMp :: forall (m :: * -> *) x. Mp m x -> m (x, Bool)
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Data.unMp1
               `cast` (forall (m :: <* -> *>_N) (x :: <*>_N).
                       <Mp m x>_R ->_R Data.Data.N:Mp[0] <m>_R <x>_N
                       :: (forall (m :: * -> *) x. Mp m x -> Mp m x :: *)
                          ~R# (forall (m :: * -> *) x. Mp m x -> m (x, Bool) :: *))}]
unMp
  = Data.Data.unMp1
    `cast` (forall (m :: <* -> *>_N) (x :: <*>_N).
            <Mp m x>_R ->_R Data.Data.N:Mp[0] <m>_R <x>_N
            :: (forall (m :: * -> *) x. Mp m x -> Mp m x :: *)
               ~R# (forall (m :: * -> *) x. Mp m x -> m (x, Bool) :: *))

-- RHS size: {terms: 70, types: 108, coercions: 36, joins: 0/3}
Data.Data.$dmgmapMp
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> a -> m a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe2j0)
                 ($dData_Xe3g6 [Occ=OnceL] :: Data a_Xe2j0)
                 (@ (m_ae2VV :: * -> *))
                 ($dMonadPlus_ae2VX :: MonadPlus m_ae2VV) ->
                 let {
                   $dMonad_ae6w1 :: Monad m_ae2VV
                   [LclId]
                   $dMonad_ae6w1
                     = GHC.Base.$p2MonadPlus @ m_ae2VV $dMonadPlus_ae2VX } in
                 \ (f_ae1Tq [Occ=OnceL!] :: forall d. Data d => d -> m_ae2VV d)
                   (x_ae1Tr [Occ=Once] :: a_Xe2j0) ->
                   >>=
                     @ m_ae2VV
                     $dMonad_ae6w1
                     @ (a_Xe2j0, Bool)
                     @ a_Xe2j0
                     ((gfoldl
                         @ a_Xe2j0
                         $dData_Xe3g6
                         @ (Mp m_ae2VV)
                         ((\ (@ d_ae2Ws)
                             (@ b_ae2Wt)
                             ($dData1_ae2Wv [Occ=OnceL] :: Data d_ae2Ws)
                             (ds_de7oC [Occ=Once] :: Mp m_ae2VV (d_ae2Ws -> b_ae2Wt))
                             (y_ae1Tz :: d_ae2Ws) ->
                             >>=
                               @ m_ae2VV
                               $dMonad_ae6w1
                               @ (d_ae2Ws -> b_ae2Wt, Bool)
                               @ (b_ae2Wt, Bool)
                               (ds_de7oC
                                `cast` (Data.Data.N:Mp[0] <m_ae2VV>_R <d_ae2Ws -> b_ae2Wt>_N
                                        :: (Mp m_ae2VV (d_ae2Ws -> b_ae2Wt) :: *)
                                           ~R# (m_ae2VV (d_ae2Ws -> b_ae2Wt, Bool) :: *)))
                               (\ (ds1_de7oD [Occ=Once!] :: (d_ae2Ws -> b_ae2Wt, Bool)) ->
                                  case ds1_de7oD of { (h_ae1TA, b1_ae1TB [Occ=Once]) ->
                                  mplus
                                    @ m_ae2VV
                                    $dMonadPlus_ae2VX
                                    @ (b_ae2Wt, Bool)
                                    (>>=
                                       @ m_ae2VV
                                       $dMonad_ae6w1
                                       @ d_ae2Ws
                                       @ (b_ae2Wt, Bool)
                                       (f_ae1Tq @ d_ae2Ws $dData1_ae2Wv y_ae1Tz)
                                       (\ (y'_ae1TC [Occ=Once] :: d_ae2Ws) ->
                                          return
                                            @ m_ae2VV
                                            $dMonad_ae6w1
                                            @ (b_ae2Wt, Bool)
                                            (h_ae1TA y'_ae1TC, GHC.Types.True)))
                                    (return
                                       @ m_ae2VV
                                       $dMonad_ae6w1
                                       @ (b_ae2Wt, Bool)
                                       (h_ae1TA y_ae1Tz, b1_ae1TB))
                                  }))
                          `cast` (forall (d :: <*>_N) (b :: <*>_N).
                                  <Data d>_R
                                  ->_R <Mp m_ae2VV (d -> b)>_R
                                  ->_R <d>_R
                                  ->_R Sym (Data.Data.N:Mp[0] <m_ae2VV>_R <b>_N)
                                  :: (forall d b.
                                      Data d =>
                                      Mp m_ae2VV (d -> b) -> d -> m_ae2VV (b, Bool) :: *)
                                     ~R# (forall d b.
                                          Data d =>
                                          Mp m_ae2VV (d -> b) -> d -> Mp m_ae2VV b :: *)))
                         ((\ (@ g_ae2Xq) (g1_ae1Tx [Occ=Once] :: g_ae2Xq) ->
                             return
                               @ m_ae2VV
                               $dMonad_ae6w1
                               @ (g_ae2Xq, Bool)
                               (g1_ae1Tx, GHC.Types.False))
                          `cast` (forall (g :: <*>_N).
                                  <g>_R ->_R Sym (Data.Data.N:Mp[0] <m_ae2VV>_R <g>_N)
                                  :: (forall g. g -> m_ae2VV (g, Bool) :: *)
                                     ~R# (forall g. g -> Mp m_ae2VV g :: *)))
                         x_ae1Tr)
                      `cast` (Data.Data.N:Mp[0] <m_ae2VV>_R <a_Xe2j0>_N
                              :: (Mp m_ae2VV a_Xe2j0 :: *) ~R# (m_ae2VV (a_Xe2j0, Bool) :: *)))
                     (\ (ds_de7oa [Occ=Once!] :: (a_Xe2j0, Bool)) ->
                        case ds_de7oa of { (x'_ae1TD [Occ=Once], b_ae1TE [Occ=Once!]) ->
                        case b_ae1TE of {
                          False -> mzero @ m_ae2VV $dMonadPlus_ae2VX @ a_Xe2j0;
                          True -> return @ m_ae2VV $dMonad_ae6w1 @ a_Xe2j0 x'_ae1TD
                        }
                        })}]
Data.Data.$dmgmapMp
  = \ (@ a_Xe2j0)
      ($dData_Xe3g6 :: Data a_Xe2j0)
      (@ (m_ae2VV :: * -> *))
      ($dMonadPlus_ae2VX :: MonadPlus m_ae2VV)
      (eta_B2 :: forall d. Data d => d -> m_ae2VV d)
      (eta1_B1 :: a_Xe2j0) ->
      let {
        lvl270_se9B1 :: m_ae2VV a_Xe2j0
        [LclId]
        lvl270_se9B1 = mzero @ m_ae2VV $dMonadPlus_ae2VX @ a_Xe2j0 } in
      let {
        $dMonad_se9wq [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae2VV
        [LclId]
        $dMonad_se9wq
          = GHC.Base.$p2MonadPlus @ m_ae2VV $dMonadPlus_ae2VX } in
      >>=
        @ m_ae2VV
        $dMonad_se9wq
        @ (a_Xe2j0, Bool)
        @ a_Xe2j0
        ((gfoldl
            @ a_Xe2j0
            $dData_Xe3g6
            @ (Mp m_ae2VV)
            ((\ (@ d_ae2Ws)
                (@ b_ae2Wt)
                ($dData1_ae2Wv :: Data d_ae2Ws)
                (ds_de7oC :: Mp m_ae2VV (d_ae2Ws -> b_ae2Wt))
                (y_ae1Tz :: d_ae2Ws) ->
                let {
                  lvl271_se9B0 :: m_ae2VV d_ae2Ws
                  [LclId]
                  lvl271_se9B0 = eta_B2 @ d_ae2Ws $dData1_ae2Wv y_ae1Tz } in
                >>=
                  @ m_ae2VV
                  $dMonad_se9wq
                  @ (d_ae2Ws -> b_ae2Wt, Bool)
                  @ (b_ae2Wt, Bool)
                  (ds_de7oC
                   `cast` (Data.Data.N:Mp[0] <m_ae2VV>_R <d_ae2Ws -> b_ae2Wt>_N
                           :: (Mp m_ae2VV (d_ae2Ws -> b_ae2Wt) :: *)
                              ~R# (m_ae2VV (d_ae2Ws -> b_ae2Wt, Bool) :: *)))
                  (\ (ds1_de7oD :: (d_ae2Ws -> b_ae2Wt, Bool)) ->
                     case ds1_de7oD of { (h_ae1TA, b1_ae1TB) ->
                     mplus
                       @ m_ae2VV
                       $dMonadPlus_ae2VX
                       @ (b_ae2Wt, Bool)
                       (>>=
                          @ m_ae2VV
                          $dMonad_se9wq
                          @ d_ae2Ws
                          @ (b_ae2Wt, Bool)
                          lvl271_se9B0
                          (\ (y'_ae1TC :: d_ae2Ws) ->
                             return
                               @ m_ae2VV
                               $dMonad_se9wq
                               @ (b_ae2Wt, Bool)
                               (h_ae1TA y'_ae1TC, GHC.Types.True)))
                       (return
                          @ m_ae2VV
                          $dMonad_se9wq
                          @ (b_ae2Wt, Bool)
                          (h_ae1TA y_ae1Tz, b1_ae1TB))
                     }))
             `cast` (forall (d :: <*>_N) (b :: <*>_N).
                     <Data d>_R
                     ->_R <Mp m_ae2VV (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Mp[0] <m_ae2VV>_R <b>_N)
                     :: (forall d b.
                         Data d =>
                         Mp m_ae2VV (d -> b) -> d -> m_ae2VV (b, Bool) :: *)
                        ~R# (forall d b.
                             Data d =>
                             Mp m_ae2VV (d -> b) -> d -> Mp m_ae2VV b :: *)))
            ((\ (@ g_ae2Xq) (g1_ae1Tx :: g_ae2Xq) ->
                return
                  @ m_ae2VV
                  $dMonad_se9wq
                  @ (g_ae2Xq, Bool)
                  (g1_ae1Tx, GHC.Types.False))
             `cast` (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Mp[0] <m_ae2VV>_R <g>_N)
                     :: (forall g. g -> m_ae2VV (g, Bool) :: *)
                        ~R# (forall g. g -> Mp m_ae2VV g :: *)))
            eta1_B1)
         `cast` (Data.Data.N:Mp[0] <m_ae2VV>_R <a_Xe2j0>_N
                 :: (Mp m_ae2VV a_Xe2j0 :: *) ~R# (m_ae2VV (a_Xe2j0, Bool) :: *)))
        (\ (ds_de7oa :: (a_Xe2j0, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9B1;
             True -> return @ m_ae2VV $dMonad_se9wq @ a_Xe2j0 x'_ae1TD
           }
           })

-- RHS size: {terms: 80, types: 115, coercions: 36, joins: 0/3}
Data.Data.$dmgmapMo
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> a -> m a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe2j1)
                 ($dData_Xe3g7 [Occ=OnceL] :: Data a_Xe2j1)
                 (@ (m_ae2XD :: * -> *))
                 ($dMonadPlus_ae2XF :: MonadPlus m_ae2XD) ->
                 let {
                   $dMonad_ae6wa :: Monad m_ae2XD
                   [LclId]
                   $dMonad_ae6wa
                     = GHC.Base.$p2MonadPlus @ m_ae2XD $dMonadPlus_ae2XF } in
                 \ (f_ae1TF [Occ=OnceL!] :: forall d. Data d => d -> m_ae2XD d)
                   (x_ae1TG [Occ=Once] :: a_Xe2j1) ->
                   >>=
                     @ m_ae2XD
                     $dMonad_ae6wa
                     @ (a_Xe2j1, Bool)
                     @ a_Xe2j1
                     ((gfoldl
                         @ a_Xe2j1
                         $dData_Xe3g7
                         @ (Mp m_ae2XD)
                         ((\ (@ d_ae2Ya)
                             (@ b_ae2Yb)
                             ($dData1_ae2Yd [Occ=OnceL] :: Data d_ae2Ya)
                             (ds_de7pC [Occ=Once] :: Mp m_ae2XD (d_ae2Ya -> b_ae2Yb))
                             (y_ae1TO :: d_ae2Ya) ->
                             >>=
                               @ m_ae2XD
                               $dMonad_ae6wa
                               @ (d_ae2Ya -> b_ae2Yb, Bool)
                               @ (b_ae2Yb, Bool)
                               (ds_de7pC
                                `cast` (Data.Data.N:Mp[0] <m_ae2XD>_R <d_ae2Ya -> b_ae2Yb>_N
                                        :: (Mp m_ae2XD (d_ae2Ya -> b_ae2Yb) :: *)
                                           ~R# (m_ae2XD (d_ae2Ya -> b_ae2Yb, Bool) :: *)))
                               (\ (ds1_de7pD [Occ=Once!] :: (d_ae2Ya -> b_ae2Yb, Bool)) ->
                                  case ds1_de7pD of { (h_ae1TP, b1_ae1TQ [Occ=Once!]) ->
                                  case b1_ae1TQ of {
                                    False ->
                                      mplus
                                        @ m_ae2XD
                                        $dMonadPlus_ae2XF
                                        @ (b_ae2Yb, Bool)
                                        (>>=
                                           @ m_ae2XD
                                           $dMonad_ae6wa
                                           @ d_ae2Ya
                                           @ (b_ae2Yb, Bool)
                                           (f_ae1TF @ d_ae2Ya $dData1_ae2Yd y_ae1TO)
                                           (\ (y'_ae1TR [Occ=Once] :: d_ae2Ya) ->
                                              return
                                                @ m_ae2XD
                                                $dMonad_ae6wa
                                                @ (b_ae2Yb, Bool)
                                                (h_ae1TP y'_ae1TR, GHC.Types.True)))
                                        (return
                                           @ m_ae2XD
                                           $dMonad_ae6wa
                                           @ (b_ae2Yb, Bool)
                                           (h_ae1TP y_ae1TO, GHC.Types.False));
                                    True ->
                                      return
                                        @ m_ae2XD
                                        $dMonad_ae6wa
                                        @ (b_ae2Yb, Bool)
                                        (h_ae1TP y_ae1TO, GHC.Types.True)
                                  }
                                  }))
                          `cast` (forall (d :: <*>_N) (b :: <*>_N).
                                  <Data d>_R
                                  ->_R <Mp m_ae2XD (d -> b)>_R
                                  ->_R <d>_R
                                  ->_R Sym (Data.Data.N:Mp[0] <m_ae2XD>_R <b>_N)
                                  :: (forall d b.
                                      Data d =>
                                      Mp m_ae2XD (d -> b) -> d -> m_ae2XD (b, Bool) :: *)
                                     ~R# (forall d b.
                                          Data d =>
                                          Mp m_ae2XD (d -> b) -> d -> Mp m_ae2XD b :: *)))
                         ((\ (@ g_ae2Zd) (g1_ae1TM [Occ=Once] :: g_ae2Zd) ->
                             return
                               @ m_ae2XD
                               $dMonad_ae6wa
                               @ (g_ae2Zd, Bool)
                               (g1_ae1TM, GHC.Types.False))
                          `cast` (forall (g :: <*>_N).
                                  <g>_R ->_R Sym (Data.Data.N:Mp[0] <m_ae2XD>_R <g>_N)
                                  :: (forall g. g -> m_ae2XD (g, Bool) :: *)
                                     ~R# (forall g. g -> Mp m_ae2XD g :: *)))
                         x_ae1TG)
                      `cast` (Data.Data.N:Mp[0] <m_ae2XD>_R <a_Xe2j1>_N
                              :: (Mp m_ae2XD a_Xe2j1 :: *) ~R# (m_ae2XD (a_Xe2j1, Bool) :: *)))
                     (\ (ds_de7pa [Occ=Once!] :: (a_Xe2j1, Bool)) ->
                        case ds_de7pa of { (x'_ae1TS [Occ=Once], b_ae1TT [Occ=Once!]) ->
                        case b_ae1TT of {
                          False -> mzero @ m_ae2XD $dMonadPlus_ae2XF @ a_Xe2j1;
                          True -> return @ m_ae2XD $dMonad_ae6wa @ a_Xe2j1 x'_ae1TS
                        }
                        })}]
Data.Data.$dmgmapMo
  = \ (@ a_Xe2j1)
      ($dData_Xe3g7 :: Data a_Xe2j1)
      (@ (m_ae2XD :: * -> *))
      ($dMonadPlus_ae2XF :: MonadPlus m_ae2XD)
      (eta_B2 :: forall d. Data d => d -> m_ae2XD d)
      (eta1_B1 :: a_Xe2j1) ->
      let {
        lvl270_se9B3 :: m_ae2XD a_Xe2j1
        [LclId]
        lvl270_se9B3 = mzero @ m_ae2XD $dMonadPlus_ae2XF @ a_Xe2j1 } in
      let {
        $dMonad_se9wo [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae2XD
        [LclId]
        $dMonad_se9wo
          = GHC.Base.$p2MonadPlus @ m_ae2XD $dMonadPlus_ae2XF } in
      >>=
        @ m_ae2XD
        $dMonad_se9wo
        @ (a_Xe2j1, Bool)
        @ a_Xe2j1
        ((gfoldl
            @ a_Xe2j1
            $dData_Xe3g7
            @ (Mp m_ae2XD)
            ((\ (@ d_ae2Ya)
                (@ b_ae2Yb)
                ($dData1_ae2Yd :: Data d_ae2Ya)
                (ds_de7pC :: Mp m_ae2XD (d_ae2Ya -> b_ae2Yb))
                (y_ae1TO :: d_ae2Ya) ->
                let {
                  lvl271_se9B2 :: m_ae2XD d_ae2Ya
                  [LclId]
                  lvl271_se9B2 = eta_B2 @ d_ae2Ya $dData1_ae2Yd y_ae1TO } in
                >>=
                  @ m_ae2XD
                  $dMonad_se9wo
                  @ (d_ae2Ya -> b_ae2Yb, Bool)
                  @ (b_ae2Yb, Bool)
                  (ds_de7pC
                   `cast` (Data.Data.N:Mp[0] <m_ae2XD>_R <d_ae2Ya -> b_ae2Yb>_N
                           :: (Mp m_ae2XD (d_ae2Ya -> b_ae2Yb) :: *)
                              ~R# (m_ae2XD (d_ae2Ya -> b_ae2Yb, Bool) :: *)))
                  (\ (ds1_de7pD :: (d_ae2Ya -> b_ae2Yb, Bool)) ->
                     case ds1_de7pD of { (h_ae1TP, b1_ae1TQ) ->
                     case b1_ae1TQ of {
                       False ->
                         mplus
                           @ m_ae2XD
                           $dMonadPlus_ae2XF
                           @ (b_ae2Yb, Bool)
                           (>>=
                              @ m_ae2XD
                              $dMonad_se9wo
                              @ d_ae2Ya
                              @ (b_ae2Yb, Bool)
                              lvl271_se9B2
                              (\ (y'_ae1TR :: d_ae2Ya) ->
                                 return
                                   @ m_ae2XD
                                   $dMonad_se9wo
                                   @ (b_ae2Yb, Bool)
                                   (h_ae1TP y'_ae1TR, GHC.Types.True)))
                           (return
                              @ m_ae2XD
                              $dMonad_se9wo
                              @ (b_ae2Yb, Bool)
                              (h_ae1TP y_ae1TO, GHC.Types.False));
                       True ->
                         return
                           @ m_ae2XD
                           $dMonad_se9wo
                           @ (b_ae2Yb, Bool)
                           (h_ae1TP y_ae1TO, GHC.Types.True)
                     }
                     }))
             `cast` (forall (d :: <*>_N) (b :: <*>_N).
                     <Data d>_R
                     ->_R <Mp m_ae2XD (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Mp[0] <m_ae2XD>_R <b>_N)
                     :: (forall d b.
                         Data d =>
                         Mp m_ae2XD (d -> b) -> d -> m_ae2XD (b, Bool) :: *)
                        ~R# (forall d b.
                             Data d =>
                             Mp m_ae2XD (d -> b) -> d -> Mp m_ae2XD b :: *)))
            ((\ (@ g_ae2Zd) (g1_ae1TM :: g_ae2Zd) ->
                return
                  @ m_ae2XD
                  $dMonad_se9wo
                  @ (g_ae2Zd, Bool)
                  (g1_ae1TM, GHC.Types.False))
             `cast` (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Mp[0] <m_ae2XD>_R <g>_N)
                     :: (forall g. g -> m_ae2XD (g, Bool) :: *)
                        ~R# (forall g. g -> Mp m_ae2XD g :: *)))
            eta1_B1)
         `cast` (Data.Data.N:Mp[0] <m_ae2XD>_R <a_Xe2j1>_N
                 :: (Mp m_ae2XD a_Xe2j1 :: *) ~R# (m_ae2XD (a_Xe2j1, Bool) :: *)))
        (\ (ds_de7pa :: (a_Xe2j1, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9B3;
             True -> return @ m_ae2XD $dMonad_se9wo @ a_Xe2j1 x'_ae1TS
           }
           })

-- RHS size: {terms: 5, types: 4, coercions: 0, joins: 0/0}
datarep :: DataType -> DataRep
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_de7mt [Occ=Once!] :: DataType) ->
                 case ds_de7mt of { DataType _ [Occ=Dead] ds2_de7mv [Occ=Once] ->
                 ds2_de7mv
                 }}]
datarep
  = \ (ds_de7mt :: DataType) ->
      case ds_de7mt of { DataType ds1_de7mu ds2_de7mv -> ds2_de7mv }

-- RHS size: {terms: 5, types: 4, coercions: 0, joins: 0/0}
tycon :: DataType -> String
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_de7mq [Occ=Once!] :: DataType) ->
                 case ds_de7mq of { DataType ds1_de7mr [Occ=Once] _ [Occ=Dead] ->
                 ds1_de7mr
                 }}]
tycon
  = \ (ds_de7mq :: DataType) ->
      case ds_de7mq of { DataType ds1_de7mr ds2_de7ms -> ds1_de7mr }

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
datatype :: Constr -> DataType
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLS),1*U(A,A,A,A,1*U(U,U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_de7mk [Occ=Once!] :: Constr) ->
                 case ds_de7mk of
                 { Constr _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                          ds5_de7mp [Occ=Once] ->
                 ds5_de7mp
                 }}]
datatype
  = \ (ds_de7mk :: Constr) ->
      case ds_de7mk of
      { Constr ds1_de7ml ds2_de7mm ds3_de7mn ds4_de7mo ds5_de7mp ->
      ds5_de7mp
      }

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
confixity :: Constr -> Fixity
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSL),1*U(A,A,A,1*U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_de7me [Occ=Once!] :: Constr) ->
                 case ds_de7me of
                 { Constr _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                          ds4_de7mi [Occ=Once] _ [Occ=Dead] ->
                 ds4_de7mi
                 }}]
confixity
  = \ (ds_de7me :: Constr) ->
      case ds_de7me of
      { Constr ds1_de7mf ds2_de7mg ds3_de7mh ds4_de7mi ds5_de7mj ->
      ds4_de7mi
      }

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
confields :: Constr -> [String]
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLL),1*U(A,A,1*U,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_de7m8 [Occ=Once!] :: Constr) ->
                 case ds_de7m8 of
                 { Constr _ [Occ=Dead] _ [Occ=Dead] ds3_de7mb [Occ=Once]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 ds3_de7mb
                 }}]
confields
  = \ (ds_de7m8 :: Constr) ->
      case ds_de7m8 of
      { Constr ds1_de7m9 ds2_de7ma ds3_de7mb ds4_de7mc ds5_de7md ->
      ds3_de7mb
      }

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
constring :: Constr -> String
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLL),1*U(A,1*U,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_de7m2 [Occ=Once!] :: Constr) ->
                 case ds_de7m2 of
                 { Constr _ [Occ=Dead] ds2_de7m4 [Occ=Once] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 ds2_de7m4
                 }}]
constring
  = \ (ds_de7m2 :: Constr) ->
      case ds_de7m2 of
      { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
      ds2_de7m4
      }

-- RHS size: {terms: 9, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fShowConstr_$cshowsPrec :: Int -> Constr -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S(LSLLL),1*U(A,1*U,A,A,A)><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ _ [Occ=Dead]
                 (x_i7QGZ [Occ=Once!] :: Constr)
                 (s_i7QH0 [Occ=Once] :: String) ->
                 case x_i7QGZ of
                 { Constr _ [Occ=Dead] ds2_de7m4 [Occ=Once] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 augment
                   @ Char
                   (\ (@ b_i7JbU)
                      (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                      (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                      foldr @ Char @ b_i7JbU c_i7JbV n_i7JbW ds2_de7m4)
                   s_i7QH0
                 }}]
Data.Data.$fShowConstr_$cshowsPrec
  = \ _ [Occ=Dead] (x_i7QGZ :: Constr) (s_i7QH0 :: String) ->
      case x_i7QGZ of
      { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
      ++ @ Char ds2_de7m4 s_i7QH0
      }

-- RHS size: {terms: 8, types: 10, coercions: 0, joins: 0/0}
Data.Data.$fShowConstr1 :: Constr -> String -> [Char]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLLL),1*U(A,1*U,A,A,A)><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i7QGZ [Occ=Once!] :: Constr)
                 (s_i7QH0 [Occ=Once, OS=OneShot] :: String) ->
                 case x_i7QGZ of
                 { Constr _ [Occ=Dead] ds1_de7m4 [Occ=Once] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 augment
                   @ Char
                   (\ (@ b_i7JbU)
                      (c_i7JbV [Occ=Once, OS=OneShot] :: Char -> b_i7JbU -> b_i7JbU)
                      (n_i7JbW [Occ=Once, OS=OneShot] :: b_i7JbU) ->
                      foldr @ Char @ b_i7JbU c_i7JbV n_i7JbW ds1_de7m4)
                   s_i7QH0
                 }}]
Data.Data.$fShowConstr1
  = \ (x_i7QGZ :: Constr) (s_i7QH0 [OS=OneShot] :: String) ->
      case x_i7QGZ of
      { Constr ds_de7m3 ds1_de7m4 ds2_de7m5 ds3_de7m6 ds4_de7m7 ->
      ++ @ Char ds1_de7m4 s_i7QH0
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
Data.Data.$fShowConstr_$cshowList :: [Constr] -> ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [Constr])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__ @ Constr Data.Data.$fShowConstr1 ls_i7JaB s_i7JaC}]
Data.Data.$fShowConstr_$cshowList
  = \ (ls_i7JaB :: [Constr]) (s_i7JaC :: String) ->
      showList__ @ Constr Data.Data.$fShowConstr1 ls_i7JaB s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fShowConstr [InlPrag=NOUSERINLINE CONLIKE]
  :: Show Constr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: Constr
                       Data.Data.$fShowConstr_$cshowsPrec
                       constring
                       Data.Data.$fShowConstr_$cshowList]
Data.Data.$fShowConstr
  = GHC.Show.C:Show
      @ Constr
      Data.Data.$fShowConstr_$cshowsPrec
      constring
      Data.Data.$fShowConstr_$cshowList

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fShowDataRep9 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fShowDataRep9 = "IntRep"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fShowDataRep8 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fShowDataRep8 = unpackCString# Data.Data.$fShowDataRep9

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fShowDataRep7 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fShowDataRep7 = "FloatRep"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fShowDataRep6 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fShowDataRep6 = unpackCString# Data.Data.$fShowDataRep7

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fShowDataRep5 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fShowDataRep5 = "CharRep"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fShowDataRep4 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fShowDataRep4 = unpackCString# Data.Data.$fShowDataRep5

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fShowDataRep3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fShowDataRep3 = "NoRep"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fShowDataRep2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fShowDataRep2 = unpackCString# Data.Data.$fShowDataRep3

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fShowDataRep10 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fShowDataRep10 = "AlgRep "#

-- RHS size: {terms: 79, types: 53, coercions: 0, joins: 0/3}
Data.Data.$fShowDataRep_$cshowsPrec :: Int -> DataRep -> ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(U)><S,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 180 0] 561 30}]
Data.Data.$fShowDataRep_$cshowsPrec
  = \ (a_ae2rm :: Int) (ds_de7FD :: DataRep) (eta_B1 :: String) ->
      case ds_de7FD of {
        AlgRep b1_ae2rn ->
          case a_ae2rm of { I# x_alMY ->
          let {
            p_se9wl [Dmd=<L,1*C1(U)>] :: ShowS
            [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
            p_se9wl
              = \ (x1_i7Rxi [OS=OneShot] :: String) ->
                  unpackAppendCString#
                    Data.Data.$fShowDataRep10
                    (case b1_ae2rn of {
                       [] -> unpackAppendCString# GHC.Show.showList__4 x1_i7Rxi;
                       : x2_i7Jf2 xs_i7Jf3 ->
                         GHC.Types.:
                           @ Char
                           GHC.Show.showList__3
                           (case x2_i7Jf2 of
                            { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
                            ++
                              @ Char
                              ds2_de7m4
                              (let {
                                 lvl270_i7Jf5 :: [Char]
                                 [LclId, Unf=OtherCon []]
                                 lvl270_i7Jf5
                                   = GHC.Types.: @ Char GHC.Show.showList__2 x1_i7Rxi } in
                               letrec {
                                 showl_i7Jf7 [Occ=LoopBreaker] :: [Constr] -> String
                                 [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                                 showl_i7Jf7
                                   = \ (ds6_i7Jf8 :: [Constr]) ->
                                       case ds6_i7Jf8 of {
                                         [] -> lvl270_i7Jf5;
                                         : y_i7Jfe ys_i7Jff ->
                                           GHC.Types.:
                                             @ Char
                                             GHC.Show.showList__1
                                             (case y_i7Jfe of
                                              { Constr ds7_Xe7Zd ds8_Xe7Zf ds9_Xe7Zh ds10_Xe7Zj
                                                       ds11_Xe7Zl ->
                                              ++ @ Char ds8_Xe7Zf (showl_i7Jf7 ys_i7Jff)
                                              })
                                       }; } in
                               showl_i7Jf7 xs_i7Jf3)
                            })
                     }) } in
          case >=# x_alMY 11# of {
            __DEFAULT -> p_se9wl eta_B1;
            1# ->
              GHC.Types.:
                @ Char
                GHC.Show.$fShow(,)4
                (p_se9wl (GHC.Types.: @ Char GHC.Show.$fShow(,)2 eta_B1))
          }
          };
        IntRep -> ++ @ Char Data.Data.$fShowDataRep8 eta_B1;
        FloatRep -> ++ @ Char Data.Data.$fShowDataRep6 eta_B1;
        CharRep -> ++ @ Char Data.Data.$fShowDataRep4 eta_B1;
        NoRep -> ++ @ Char Data.Data.$fShowDataRep2 eta_B1
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fShowDataRep11 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fShowDataRep11
  = unpackAppendCString# GHC.Show.showList__4 (GHC.Types.[] @ Char)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
lvl45_rejMn :: [Char]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
lvl45_rejMn
  = GHC.Types.: @ Char GHC.Show.showList__2 (GHC.Types.[] @ Char)

Rec {
-- RHS size: {terms: 15, types: 16, coercions: 0, joins: 0/0}
Data.Data.$fShowDataRep_showl [Occ=LoopBreaker]
  :: [Constr] -> String
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m2, Unf=OtherCon []]
Data.Data.$fShowDataRep_showl
  = \ (ds2_i7Jf8 :: [Constr]) ->
      case ds2_i7Jf8 of {
        [] -> lvl45_rejMn;
        : y_i7Jfe ys_i7Jff ->
          GHC.Types.:
            @ Char
            GHC.Show.showList__1
            (case y_i7Jfe of
             { Constr ds_Xe7Zn ds1_Xe7Zp ds3_Xe7Zr ds4_Xe7Zt ds5_Xe7Zv ->
             ++ @ Char ds1_Xe7Zp (Data.Data.$fShowDataRep_showl ys_i7Jff)
             })
      }
end Rec }

-- RHS size: {terms: 28, types: 18, coercions: 0, joins: 0/0}
Data.Data.$fShowDataRep_$cshow :: DataRep -> String
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60] 170 0}]
Data.Data.$fShowDataRep_$cshow
  = \ (x_i7Jay :: DataRep) ->
      case x_i7Jay of {
        AlgRep b1_ae2rn ->
          unpackAppendCString#
            Data.Data.$fShowDataRep10
            (case b1_ae2rn of {
               [] -> Data.Data.$fShowDataRep11;
               : x1_i7Jf2 xs_i7Jf3 ->
                 GHC.Types.:
                   @ Char
                   GHC.Show.showList__3
                   (case x1_i7Jf2 of
                    { Constr ds_de7m3 ds1_de7m4 ds2_de7m5 ds3_de7m6 ds4_de7m7 ->
                    ++ @ Char ds1_de7m4 (Data.Data.$fShowDataRep_showl xs_i7Jf3)
                    })
             });
        IntRep -> Data.Data.$fShowDataRep8;
        FloatRep -> Data.Data.$fShowDataRep6;
        CharRep -> Data.Data.$fShowDataRep4;
        NoRep -> Data.Data.$fShowDataRep2
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData:.:3 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fData:.:3 = GHC.Types.I# 0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fShowDataRep1 :: DataRep -> ShowS
[GblId,
 Arity=2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
Data.Data.$fShowDataRep1
  = Data.Data.$fShowDataRep_$cshowsPrec Data.Data.$fData:.:3

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
Data.Data.$fShowDataRep_$cshowList :: [DataRep] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [DataRep])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__ @ DataRep Data.Data.$fShowDataRep1 ls_i7JaB s_i7JaC}]
Data.Data.$fShowDataRep_$cshowList
  = \ (ls_i7JaB :: [DataRep]) (s_i7JaC :: String) ->
      showList__ @ DataRep Data.Data.$fShowDataRep1 ls_i7JaB s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fShowDataRep [InlPrag=NOUSERINLINE CONLIKE]
  :: Show DataRep
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: DataRep
                       Data.Data.$fShowDataRep_$cshowsPrec
                       Data.Data.$fShowDataRep_$cshow
                       Data.Data.$fShowDataRep_$cshowList]
Data.Data.$fShowDataRep
  = GHC.Show.C:Show
      @ DataRep
      Data.Data.$fShowDataRep_$cshowsPrec
      Data.Data.$fShowDataRep_$cshow
      Data.Data.$fShowDataRep_$cshowList

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
conrep :: Constr -> ConstrRep
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_de7lW [Occ=Once!] :: Constr) ->
                 case ds_de7lW of
                 { Constr ds1_de7lX [Occ=Once] _ [Occ=Dead] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 ds1_de7lX
                 }}]
conrep
  = \ (ds_de7lW :: Constr) ->
      case ds_de7lW of
      { Constr ds1_de7lX ds2_de7lY ds3_de7lZ ds4_de7m0 ds5_de7m1 ->
      ds1_de7lX
      }

-- RHS size: {terms: 17, types: 25, coercions: 31, joins: 0/1}
fromConstrB
  :: forall a. Data a => (forall d. Data d => d) -> Constr -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C(U))),A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 60] 140 60}]
fromConstrB
  = \ (@ a_ae2Ea)
      ($dData_ae2Ec :: Data a_ae2Ea)
      (f_ae1VC :: forall d. Data d => d) ->
      let {
        g_se9we [Dmd=<L,C(U)>] :: Constr -> Identity a_ae2Ea
        [LclId]
        g_se9we
          = gunfold
              @ a_ae2Ea
              $dData_ae2Ec
              @ Identity
              ((\ (@ b_ae2EM)
                  (@ r_ae2EN)
                  ($dData1_ae2EP :: Data b_ae2EM)
                  (c_ae1VI :: Identity (b_ae2EM -> r_ae2EN)) ->
                  (c_ae1VI
                   `cast` (Data.Functor.Identity.N:Identity[0] <b_ae2EM -> r_ae2EN>_R
                           :: (Identity (b_ae2EM -> r_ae2EN) :: *)
                              ~R# (b_ae2EM -> r_ae2EN :: *)))
                    (f_ae1VC @ b_ae2EM $dData1_ae2EP))
               `cast` (forall (b :: <*>_N) (r :: <*>_N).
                       <Data b>_R
                       ->_R <Identity (b -> r)>_R
                       ->_R Sym (Data.Functor.Identity.N:Identity[0] <r>_R)
                       :: (forall b r. Data b => Identity (b -> r) -> r :: *)
                          ~R# (forall b r. Data b => Identity (b -> r) -> Identity r :: *)))
              (Data.Data.$fDataConst2
               `cast` (forall (r :: <*>_N).
                       <r>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <r>_R)
                       :: (forall r. r -> r :: *)
                          ~R# (forall r. r -> Identity r :: *))) } in
      (\ (x_i7Rxi :: Constr) -> g_se9we x_i7Rxi)
      `cast` (<Constr>_R
              ->_R Data.Functor.Identity.N:Identity[0] <a_ae2Ea>_R
              :: (Constr -> Identity a_ae2Ea :: *) ~R# (Constr -> a_ae2Ea :: *))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl14_rejMo :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl14_rejMo = "Data.Data.fromConstr"#

-- RHS size: {terms: 4, types: 4, coercions: 0, joins: 0/0}
Data.Data.fromConstr2 :: forall b. b
[GblId, Str=x]
Data.Data.fromConstr2
  = \ (@ b_ae2EM) ->
      errorWithoutStackTrace
        @ 'LiftedRep @ b_ae2EM (unpackCString# lvl14_rejMo)

-- RHS size: {terms: 6, types: 10, coercions: 3, joins: 0/0}
Data.Data.fromConstr1
  :: forall b r. Data b => Identity (b -> r) -> r
[GblId,
 Arity=2,
 Str=<L,A><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_ae2EM)
                 (@ r_ae2EN)
                 _ [Occ=Dead]
                 (c_ae1VI [Occ=Once] :: Identity (b_ae2EM -> r_ae2EN)) ->
                 (c_ae1VI
                  `cast` (Data.Functor.Identity.N:Identity[0] <b_ae2EM -> r_ae2EN>_R
                          :: (Identity (b_ae2EM -> r_ae2EN) :: *)
                             ~R# (b_ae2EM -> r_ae2EN :: *)))
                   (Data.Data.fromConstr2 @ b_ae2EM)}]
Data.Data.fromConstr1
  = \ (@ b_ae2EM)
      (@ r_ae2EN)
      _ [Occ=Dead]
      (c_ae1VI :: Identity (b_ae2EM -> r_ae2EN)) ->
      (c_ae1VI
       `cast` (Data.Functor.Identity.N:Identity[0] <b_ae2EM -> r_ae2EN>_R
               :: (Identity (b_ae2EM -> r_ae2EN) :: *)
                  ~R# (b_ae2EM -> r_ae2EN :: *)))
        (Data.Data.fromConstr2 @ b_ae2EM)

-- RHS size: {terms: 10, types: 10, coercions: 28, joins: 0/1}
fromConstr :: forall a. Data a => Constr -> a
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,1*C1(C1(C(U))),A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae2Fi) ($dData_ae2Fk [Occ=Once] :: Data a_ae2Fi) ->
                 let {
                   g_se9wc [Occ=OnceL!] :: Constr -> Identity a_ae2Fi
                   [LclId]
                   g_se9wc
                     = gunfold
                         @ a_ae2Fi
                         $dData_ae2Fk
                         @ Identity
                         (Data.Data.fromConstr1
                          `cast` (forall (b :: <*>_N) (r :: <*>_N).
                                  <Data b>_R
                                  ->_R <Identity (b -> r)>_R
                                  ->_R Sym (Data.Functor.Identity.N:Identity[0] <r>_R)
                                  :: (forall b r. Data b => Identity (b -> r) -> r :: *)
                                     ~R# (forall b r.
                                          Data b =>
                                          Identity (b -> r) -> Identity r :: *)))
                         (Data.Data.$fDataConst2
                          `cast` (forall (r :: <*>_N).
                                  <r>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <r>_R)
                                  :: (forall r. r -> r :: *)
                                     ~R# (forall r. r -> Identity r :: *))) } in
                 (\ (x_i7Rxi [Occ=Once] :: Constr) -> g_se9wc x_i7Rxi)
                 `cast` (<Constr>_R
                         ->_R Data.Functor.Identity.N:Identity[0] <a_ae2Fi>_R
                         :: (Constr -> Identity a_ae2Fi :: *)
                            ~R# (Constr -> a_ae2Fi :: *))}]
fromConstr
  = \ (@ a_ae2Fi) ($dData_ae2Fk :: Data a_ae2Fi) ->
      let {
        g_se9wc [Dmd=<L,C(U)>] :: Constr -> Identity a_ae2Fi
        [LclId]
        g_se9wc
          = gunfold
              @ a_ae2Fi
              $dData_ae2Fk
              @ Identity
              (Data.Data.fromConstr1
               `cast` (forall (b :: <*>_N) (r :: <*>_N).
                       <Data b>_R
                       ->_R <Identity (b -> r)>_R
                       ->_R Sym (Data.Functor.Identity.N:Identity[0] <r>_R)
                       :: (forall b r. Data b => Identity (b -> r) -> r :: *)
                          ~R# (forall b r. Data b => Identity (b -> r) -> Identity r :: *)))
              (Data.Data.$fDataConst2
               `cast` (forall (r :: <*>_N).
                       <r>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <r>_R)
                       :: (forall r. r -> r :: *)
                          ~R# (forall r. r -> Identity r :: *))) } in
      (\ (x_i7Rxi :: Constr) -> g_se9wc x_i7Rxi)
      `cast` (<Constr>_R
              ->_R Data.Functor.Identity.N:Identity[0] <a_ae2Fi>_R
              :: (Constr -> Identity a_ae2Fi :: *) ~R# (Constr -> a_ae2Fi :: *))

-- RHS size: {terms: 29, types: 46, coercions: 0, joins: 0/1}
fromConstrM
  :: forall (m :: * -> *) a.
     (Monad m, Data a) =>
     (forall d. Data d => m d) -> Constr -> m a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,U,A)><S(LLC(C(S))LLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [120 30 60] 260 0}]
fromConstrM
  = \ (@ (m_ae2CW :: * -> *))
      (@ a_ae2CX)
      ($dMonad_ae2CZ :: Monad m_ae2CW)
      ($dData_ae2D0 :: Data a_ae2CX)
      (f_ae1VJ :: forall d. Data d => m_ae2CW d) ->
      gunfold
        @ a_ae2CX
        $dData_ae2D0
        @ m_ae2CW
        (\ (@ b_ae2Dz)
           (@ r_ae2DA)
           ($dData1_ae2DC :: Data b_ae2Dz)
           (c_ae1VP :: m_ae2CW (b_ae2Dz -> r_ae2DA)) ->
           let {
             lvl270_se9BX :: m_ae2CW b_ae2Dz
             [LclId]
             lvl270_se9BX = f_ae1VJ @ b_ae2Dz $dData1_ae2DC } in
           >>=
             @ m_ae2CW
             $dMonad_ae2CZ
             @ (b_ae2Dz -> r_ae2DA)
             @ r_ae2DA
             c_ae1VP
             (\ (c'_ae1VQ :: b_ae2Dz -> r_ae2DA) ->
                >>=
                  @ m_ae2CW
                  $dMonad_ae2CZ
                  @ b_ae2Dz
                  @ r_ae2DA
                  lvl270_se9BX
                  (\ (b1_ae1VR :: b_ae2Dz) ->
                     return @ m_ae2CW $dMonad_ae2CZ @ r_ae2DA (c'_ae1VQ b1_ae1VR))))
        (\ (@ r_ae2E5) -> return @ m_ae2CW $dMonad_ae2CZ @ r_ae2E5)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
dataTypeName :: DataType -> String
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= tycon}]
dataTypeName = tycon

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl15_rejMp :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl15_rejMp = "Data.Data.dataTypeConstrs is not supported for "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl16_rejMq :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl16_rejMq = ", as it is not an algebraic data type."#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl17_rejMr :: [Char]
[GblId]
lvl17_rejMr = unpackCString# lvl16_rejMq

-- RHS size: {terms: 7, types: 5, coercions: 0, joins: 0/0}
Data.Data.$wlvl16 [InlPrag=NOUSERINLINE[0]] :: String -> [Constr]
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
Data.Data.$wlvl16
  = \ (ww_sefUv :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ [Constr]
        (unpackAppendCString# lvl15_rejMp (++ @ Char ww_sefUv lvl17_rejMr))

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
Data.Data.dataTypeConstrs1 [InlPrag=NOUSERINLINE[0]]
  :: DataType -> [Constr]
[GblId,
 Arity=1,
 Str=<B,1*U(1*U,A)>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sefUs [Occ=Once!] :: DataType) ->
                 case w_sefUs of { DataType ww1_sefUv [Occ=Once] _ [Occ=Dead] ->
                 Data.Data.$wlvl16 ww1_sefUv
                 }}]
Data.Data.dataTypeConstrs1
  = \ (w_sefUs :: DataType) ->
      case w_sefUs of { DataType ww1_sefUv ww2_sefUw ->
      Data.Data.$wlvl16 ww1_sefUv
      }

-- RHS size: {terms: 11, types: 7, coercions: 0, joins: 0/0}
dataTypeConstrs :: DataType -> [Constr]
[GblId,
 Arity=1,
 Str=<S(LS),1*U(1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (dt_ae1W8 [Occ=Once!] :: DataType) ->
                 case dt_ae1W8 of wild_XqY
                 { DataType _ [Occ=Dead] ds1_de7mv [Occ=Once!] ->
                 case ds1_de7mv of {
                   __DEFAULT -> Data.Data.dataTypeConstrs1 wild_XqY;
                   AlgRep cons_ae1W9 [Occ=Once] -> cons_ae1W9
                 }
                 }}]
dataTypeConstrs
  = \ (dt_ae1W8 :: DataType) ->
      case dt_ae1W8 of { DataType ds_de7mu ds1_de7mv ->
      case ds1_de7mv of {
        __DEFAULT -> Data.Data.$wlvl16 ds_de7mu;
        AlgRep cons_ae1W9 -> cons_ae1W9
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
dataTypeRep :: DataType -> DataRep
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= datarep}]
dataTypeRep = datarep

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl18_rejMs :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl18_rejMs = "Data.Data.maxConstrIndex is not supported for "#

-- RHS size: {terms: 7, types: 4, coercions: 0, joins: 0/0}
Data.Data.$wlvl18 [InlPrag=NOUSERINLINE[0]] :: String -> ConIndex
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
Data.Data.$wlvl18
  = \ (ww_sefUC :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ ConIndex
        (unpackAppendCString# lvl18_rejMs (++ @ Char ww_sefUC lvl17_rejMr))

-- RHS size: {terms: 17, types: 9, coercions: 0, joins: 0/0}
maxConstrIndex [InlPrag=NOUSERINLINE[0]] :: DataType -> ConIndex
[GblId,
 Arity=1,
 Str=<S(LS),1*U(1*U,1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sefUG [Occ=Once!] :: DataType) ->
                 case w_sefUG of
                 { DataType ww1_sefUJ [Occ=Once] ww2_sefUK [Occ=Once!] ->
                 case ww2_sefUK of {
                   __DEFAULT -> Data.Data.$wlvl18 ww1_sefUJ;
                   AlgRep cs_ae1Wu [Occ=Once] ->
                     case GHC.List.$wlenAcc @ Constr cs_ae1Wu 0# of ww3_sefUO
                     { __DEFAULT ->
                     GHC.Types.I# ww3_sefUO
                     }
                 }
                 }}]
maxConstrIndex
  = \ (w_sefUG :: DataType) ->
      case w_sefUG of { DataType ww1_sefUJ ww2_sefUK ->
      case ww2_sefUK of {
        __DEFAULT -> Data.Data.$wlvl18 ww1_sefUJ;
        AlgRep cs_ae1Wu ->
          case GHC.List.$wlenAcc @ Constr cs_ae1Wu 0# of ww3_sefUO
          { __DEFAULT ->
          GHC.Types.I# ww3_sefUO
          }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
constrType :: Constr -> DataType
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLS),1*U(A,A,A,A,1*U(U,U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= datatype}]
constrType = datatype

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
constrRep :: Constr -> ConstrRep
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= conrep}]
constrRep = conrep

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl19_rejMt :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl19_rejMt = "Data.Data.constrIndex is not supported for "#

-- RHS size: {terms: 7, types: 4, coercions: 0, joins: 0/0}
Data.Data.$wlvl [InlPrag=NOUSERINLINE[0]] :: String -> ConIndex
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
Data.Data.$wlvl
  = \ (ww_sefV0 :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ ConIndex
        (unpackAppendCString# lvl19_rejMt (++ @ Char ww_sefV0 lvl17_rejMr))

-- RHS size: {terms: 9, types: 11, coercions: 0, joins: 0/0}
Data.Data.constrIndex1 [InlPrag=NOUSERINLINE[0]]
  :: Constr -> ConIndex
[GblId,
 Arity=1,
 Str=<B,1*U(A,A,A,A,1*U(1*U,A))>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_sefUQ [Occ=Once!] :: Constr) ->
                 case w_sefUQ of
                 { Constr _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                          ww5_sefUX [Occ=Once!] ->
                 case ww5_sefUX of { DataType ww7_sefV0 [Occ=Once] _ [Occ=Dead] ->
                 Data.Data.$wlvl ww7_sefV0
                 }
                 }}]
Data.Data.constrIndex1
  = \ (w_sefUQ :: Constr) ->
      case w_sefUQ of
      { Constr ww1_sefUT ww2_sefUU ww3_sefUV ww4_sefUW ww5_sefUX ->
      case ww5_sefUX of { DataType ww7_sefV0 ww8_sefV1 ->
      Data.Data.$wlvl ww7_sefV0
      }
      }

-- RHS size: {terms: 14, types: 13, coercions: 0, joins: 0/0}
constrIndex :: Constr -> ConIndex
[GblId,
 Arity=1,
 Str=<S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (con_ae1Wr [Occ=Once!] :: Constr) ->
                 case con_ae1Wr of wild_Xrf
                 { Constr ds_de7lX [Occ=Once!] _ [Occ=Dead] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 case ds_de7lX of {
                   __DEFAULT -> Data.Data.constrIndex1 wild_Xrf;
                   AlgConstr idx_ae1Ws [Occ=Once] -> idx_ae1Ws
                 }
                 }}]
constrIndex
  = \ (con_ae1Wr :: Constr) ->
      case con_ae1Wr of
      { Constr ds_de7lX ds1_de7lY ds2_de7lZ ds3_de7m0 ds4_de7m1 ->
      case ds_de7lX of {
        __DEFAULT ->
          case ds4_de7m1 of { DataType ww1_sefV0 ww2_sefV1 ->
          Data.Data.$wlvl ww1_sefV0
          };
        AlgConstr idx_ae1Ws -> idx_ae1Ws
      }
      }

-- RHS size: {terms: 28, types: 23, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold7 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r)
     -> ConstrRep -> DataType -> c DecidedStrictness
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U(1*U,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [180 60 20] 150 0}]
Data.Data.$w$cgunfold7
  = \ (@ (c_sefV5 :: * -> *))
      (w_sefV7 :: forall r. r -> c_sefV5 r)
      (ww_sefVb :: ConstrRep)
      (ww1_sefVf :: DataType) ->
      case ww_sefVb of {
        __DEFAULT ->
          case ww1_sefVf of { DataType ww3_sefV0 ww4_sefV1 ->
          case Data.Data.$wlvl ww3_sefV0 of wild1_00 { }
          };
        AlgConstr idx_ae1Ws ->
          case idx_ae1Ws of { I# ds_de7qd ->
          case ds_de7qd of {
            __DEFAULT ->
              w_sefV7 @ DecidedStrictness GHC.Generics.DecidedUnpack;
            1# -> w_sefV7 @ DecidedStrictness GHC.Generics.DecidedLazy;
            2# -> w_sefV7 @ DecidedStrictness GHC.Generics.DecidedStrict
          }
          }
      }

-- RHS size: {terms: 11, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataDecidedStrictness_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c DecidedStrictness
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_sefV5 :: * -> *))
                 _ [Occ=Dead]
                 (w1_sefV7 [Occ=Once] :: forall r. r -> c_sefV5 r)
                 (w2_sefV8 [Occ=Once!] :: Constr) ->
                 case w2_sefV8 of
                 { Constr ww1_sefVb [Occ=Once] _ [Occ=Dead] _ [Occ=Dead]
                          _ [Occ=Dead] ww5_sefVf [Occ=Once] ->
                 Data.Data.$w$cgunfold7 @ c_sefV5 w1_sefV7 ww1_sefVb ww5_sefVf
                 }}]
Data.Data.$fDataDecidedStrictness_$cgunfold
  = \ (@ (c_sefV5 :: * -> *))
      _ [Occ=Dead]
      (w1_sefV7 :: forall r. r -> c_sefV5 r)
      (w2_sefV8 :: Constr) ->
      case w2_sefV8 of
      { Constr ww1_sefVb ww2_sefVc ww3_sefVd ww4_sefVe ww5_sefVf ->
      Data.Data.$w$cgunfold7 @ c_sefV5 w1_sefV7 ww1_sefVb ww5_sefVf
      }

-- RHS size: {terms: 28, types: 23, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold20 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r) -> ConstrRep -> DataType -> c SourceStrictness
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U(1*U,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [180 60 20] 150 0}]
Data.Data.$w$cgunfold20
  = \ (@ (c_sefVi :: * -> *))
      (w_sefVk :: forall r. r -> c_sefVi r)
      (ww_sefVo :: ConstrRep)
      (ww1_sefVs :: DataType) ->
      case ww_sefVo of {
        __DEFAULT ->
          case ww1_sefVs of { DataType ww3_sefV0 ww4_sefV1 ->
          case Data.Data.$wlvl ww3_sefV0 of wild1_00 { }
          };
        AlgConstr idx_ae1Ws ->
          case idx_ae1Ws of { I# ds_de7qA ->
          case ds_de7qA of {
            __DEFAULT -> w_sefVk @ SourceStrictness GHC.Generics.SourceStrict;
            1# -> w_sefVk @ SourceStrictness GHC.Generics.NoSourceStrictness;
            2# -> w_sefVk @ SourceStrictness GHC.Generics.SourceLazy
          }
          }
      }

-- RHS size: {terms: 11, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceStrictness_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c SourceStrictness
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_sefVi :: * -> *))
                 _ [Occ=Dead]
                 (w1_sefVk [Occ=Once] :: forall r. r -> c_sefVi r)
                 (w2_sefVl [Occ=Once!] :: Constr) ->
                 case w2_sefVl of
                 { Constr ww1_sefVo [Occ=Once] _ [Occ=Dead] _ [Occ=Dead]
                          _ [Occ=Dead] ww5_sefVs [Occ=Once] ->
                 Data.Data.$w$cgunfold20 @ c_sefVi w1_sefVk ww1_sefVo ww5_sefVs
                 }}]
Data.Data.$fDataSourceStrictness_$cgunfold
  = \ (@ (c_sefVi :: * -> *))
      _ [Occ=Dead]
      (w1_sefVk :: forall r. r -> c_sefVi r)
      (w2_sefVl :: Constr) ->
      case w2_sefVl of
      { Constr ww1_sefVo ww2_sefVp ww3_sefVq ww4_sefVr ww5_sefVs ->
      Data.Data.$w$cgunfold20 @ c_sefVi w1_sefVk ww1_sefVo ww5_sefVs
      }

-- RHS size: {terms: 28, types: 23, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold21 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r)
     -> ConstrRep -> DataType -> c SourceUnpackedness
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U(1*U,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [180 60 20] 150 0}]
Data.Data.$w$cgunfold21
  = \ (@ (c_sefVv :: * -> *))
      (w_sefVx :: forall r. r -> c_sefVv r)
      (ww_sefVB :: ConstrRep)
      (ww1_sefVF :: DataType) ->
      case ww_sefVB of {
        __DEFAULT ->
          case ww1_sefVF of { DataType ww3_sefV0 ww4_sefV1 ->
          case Data.Data.$wlvl ww3_sefV0 of wild1_00 { }
          };
        AlgConstr idx_ae1Ws ->
          case idx_ae1Ws of { I# ds_de7qX ->
          case ds_de7qX of {
            __DEFAULT ->
              w_sefVx @ SourceUnpackedness GHC.Generics.SourceUnpack;
            1# ->
              w_sefVx @ SourceUnpackedness GHC.Generics.NoSourceUnpackedness;
            2# -> w_sefVx @ SourceUnpackedness GHC.Generics.SourceNoUnpack
          }
          }
      }

-- RHS size: {terms: 11, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceUnpackedness_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c SourceUnpackedness
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_sefVv :: * -> *))
                 _ [Occ=Dead]
                 (w1_sefVx [Occ=Once] :: forall r. r -> c_sefVv r)
                 (w2_sefVy [Occ=Once!] :: Constr) ->
                 case w2_sefVy of
                 { Constr ww1_sefVB [Occ=Once] _ [Occ=Dead] _ [Occ=Dead]
                          _ [Occ=Dead] ww5_sefVF [Occ=Once] ->
                 Data.Data.$w$cgunfold21 @ c_sefVv w1_sefVx ww1_sefVB ww5_sefVF
                 }}]
Data.Data.$fDataSourceUnpackedness_$cgunfold
  = \ (@ (c_sefVv :: * -> *))
      _ [Occ=Dead]
      (w1_sefVx :: forall r. r -> c_sefVv r)
      (w2_sefVy :: Constr) ->
      case w2_sefVy of
      { Constr ww1_sefVB ww2_sefVC ww3_sefVD ww4_sefVE ww5_sefVF ->
      Data.Data.$w$cgunfold21 @ c_sefVv w1_sefVx ww1_sefVB ww5_sefVF
      }

-- RHS size: {terms: 28, types: 23, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold6 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r) -> ConstrRep -> DataType -> c Associativity
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U(1*U,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [180 60 20] 150 0}]
Data.Data.$w$cgunfold6
  = \ (@ (c_sefVI :: * -> *))
      (w_sefVK :: forall r. r -> c_sefVI r)
      (ww_sefVO :: ConstrRep)
      (ww1_sefVS :: DataType) ->
      case ww_sefVO of {
        __DEFAULT ->
          case ww1_sefVS of { DataType ww3_sefV0 ww4_sefV1 ->
          case Data.Data.$wlvl ww3_sefV0 of wild1_00 { }
          };
        AlgConstr idx_ae1Ws ->
          case idx_ae1Ws of { I# ds_de7rk ->
          case ds_de7rk of {
            __DEFAULT -> w_sefVK @ Associativity GHC.Generics.NotAssociative;
            1# -> w_sefVK @ Associativity GHC.Generics.LeftAssociative;
            2# -> w_sefVK @ Associativity GHC.Generics.RightAssociative
          }
          }
      }

-- RHS size: {terms: 11, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataAssociativity_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c Associativity
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_sefVI :: * -> *))
                 _ [Occ=Dead]
                 (w1_sefVK [Occ=Once] :: forall r. r -> c_sefVI r)
                 (w2_sefVL [Occ=Once!] :: Constr) ->
                 case w2_sefVL of
                 { Constr ww1_sefVO [Occ=Once] _ [Occ=Dead] _ [Occ=Dead]
                          _ [Occ=Dead] ww5_sefVS [Occ=Once] ->
                 Data.Data.$w$cgunfold6 @ c_sefVI w1_sefVK ww1_sefVO ww5_sefVS
                 }}]
Data.Data.$fDataAssociativity_$cgunfold
  = \ (@ (c_sefVI :: * -> *))
      _ [Occ=Dead]
      (w1_sefVK :: forall r. r -> c_sefVI r)
      (w2_sefVL :: Constr) ->
      case w2_sefVL of
      { Constr ww1_sefVO ww2_sefVP ww3_sefVQ ww4_sefVR ww5_sefVS ->
      Data.Data.$w$cgunfold6 @ c_sefVI w1_sefVK ww1_sefVO ww5_sefVS
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl20_rejMu :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl20_rejMu = "Data/Data.hs:1315:1-39|case"#

-- RHS size: {terms: 4, types: 12, coercions: 0, joins: 0/0}
lvl21_rejMv :: forall (c :: * -> *) p. c (V1 p)
[GblId, Str=x]
lvl21_rejMv
  = \ (@ (c_ae3j7 :: * -> *)) (@ p_Xe3Kk) ->
      Control.Exception.Base.patError
        @ 'LiftedRep @ (c_ae3j7 (V1 p_Xe3Kk)) lvl20_rejMu

-- RHS size: {terms: 15, types: 15, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold22 [InlPrag=NOUSERINLINE[0]]
  :: forall p (c :: * -> *). ConstrRep -> String -> c (V1 p)
[GblId, Arity=2, Str=<B,1*U><B,1*U>x, Unf=OtherCon []]
Data.Data.$w$cgunfold22
  = \ (@ p_sefVV)
      (@ (c_sefVX :: * -> *))
      (ww_sefW3 :: ConstrRep)
      (ww1_sefWa :: String) ->
      case ww_sefW3 of {
        __DEFAULT -> case Data.Data.$wlvl ww1_sefWa of wild1_00 { };
        AlgConstr idx_ae1Ws ->
          case idx_ae1Ws of { I# ipv_se7Y1 ->
          lvl21_rejMv @ c_sefVX @ p_sefVV
          }
      }

-- RHS size: {terms: 15, types: 37, coercions: 0, joins: 0/0}
Data.Data.$fDataV1_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall p.
     Data p =>
     forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c (V1 p)
[GblId,
 Arity=4,
 Str=<B,A><B,A><B,A><B,1*U(1*U,A,A,A,1*U(1*U,A))>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ p_sefVV)
                 _ [Occ=Dead]
                 (@ (c_sefVX :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w3_sefW0 [Occ=Once!] :: Constr) ->
                 case w3_sefW0 of
                 { Constr ww1_sefW3 [Occ=Once] _ [Occ=Dead] _ [Occ=Dead]
                          _ [Occ=Dead] ww5_sefW7 [Occ=Once!] ->
                 case ww5_sefW7 of { DataType ww7_sefWa [Occ=Once] _ [Occ=Dead] ->
                 Data.Data.$w$cgunfold22 @ p_sefVV @ c_sefVX ww1_sefW3 ww7_sefWa
                 }
                 }}]
Data.Data.$fDataV1_$cgunfold
  = \ (@ p_sefVV)
      _ [Occ=Dead]
      (@ (c_sefVX :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w3_sefW0 :: Constr) ->
      case w3_sefW0 of
      { Constr ww1_sefW3 ww2_sefW4 ww3_sefW5 ww4_sefW6 ww5_sefW7 ->
      case ww5_sefW7 of { DataType ww7_sefWa ww8_sefWb ->
      Data.Data.$w$cgunfold22 @ p_sefVV @ c_sefVX ww1_sefW3 ww7_sefWa
      }
      }

-- RHS size: {terms: 35, types: 89, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold3 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Data (f p), Data (g p)) =>
     forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> ConstrRep -> DataType -> c ((:+:) f g p)
[GblId,
 Arity=6,
 Str=<L,U><L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 120 120 60 20] 180 0}]
Data.Data.$w$cgunfold3
  = \ (@ (f_sefWf :: * -> *))
      (@ (g_sefWg :: * -> *))
      (@ p_sefWh)
      (w_sefWl :: Data (f_sefWf p_sefWh))
      (w1_sefWm :: Data (g_sefWg p_sefWh))
      (@ (c_sefWn :: * -> *))
      (w2_sefWo :: forall b r. Data b => c_sefWn (b -> r) -> c_sefWn r)
      (w3_sefWp :: forall r. r -> c_sefWn r)
      (ww_sefWt :: ConstrRep)
      (ww1_sefWx :: DataType) ->
      case ww_sefWt of {
        __DEFAULT ->
          case ww1_sefWx of { DataType ww3_sefV0 ww4_sefV1 ->
          case Data.Data.$wlvl ww3_sefV0 of wild1_00 { }
          };
        AlgConstr idx_ae1Ws ->
          case idx_ae1Ws of { I# ds_de7tc ->
          case ds_de7tc of {
            __DEFAULT ->
              w2_sefWo
                @ (g_sefWg p_sefWh)
                @ ((:+:) f_sefWf g_sefWg p_sefWh)
                w1_sefWm
                (w3_sefWp
                   @ (g_sefWg p_sefWh -> (:+:) f_sefWf g_sefWg p_sefWh)
                   (GHC.Generics.R1 @ * @ f_sefWf @ g_sefWg @ p_sefWh));
            1# ->
              w2_sefWo
                @ (f_sefWf p_sefWh)
                @ ((:+:) f_sefWf g_sefWg p_sefWh)
                w_sefWl
                (w3_sefWp
                   @ (f_sefWf p_sefWh -> (:+:) f_sefWf g_sefWg p_sefWh)
                   (GHC.Generics.L1 @ * @ f_sefWf @ g_sefWg @ p_sefWh))
          }
          }
      }

-- RHS size: {terms: 22, types: 62, coercions: 0, joins: 0/0}
Data.Data.$fData:+:_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f p), Data (g p)) =>
     forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c ((:+:) f g p)
[GblId,
 Arity=8,
 Str=<L,A><L,A><L,A><L,U><L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=8,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sefWf :: * -> *))
                 (@ (g_sefWg :: * -> *))
                 (@ p_sefWh)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w3_sefWl [Occ=Once] :: Data (f_sefWf p_sefWh))
                 (w4_sefWm [Occ=Once] :: Data (g_sefWg p_sefWh))
                 (@ (c_sefWn :: * -> *))
                 (w5_sefWo [Occ=Once]
                    :: forall b r. Data b => c_sefWn (b -> r) -> c_sefWn r)
                 (w6_sefWp [Occ=Once] :: forall r. r -> c_sefWn r)
                 (w7_sefWq [Occ=Once!] :: Constr) ->
                 case w7_sefWq of
                 { Constr ww1_sefWt [Occ=Once] _ [Occ=Dead] _ [Occ=Dead]
                          _ [Occ=Dead] ww5_sefWx [Occ=Once] ->
                 Data.Data.$w$cgunfold3
                   @ f_sefWf
                   @ g_sefWg
                   @ p_sefWh
                   w3_sefWl
                   w4_sefWm
                   @ c_sefWn
                   w5_sefWo
                   w6_sefWp
                   ww1_sefWt
                   ww5_sefWx
                 }}]
Data.Data.$fData:+:_$cgunfold
  = \ (@ (f_sefWf :: * -> *))
      (@ (g_sefWg :: * -> *))
      (@ p_sefWh)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w3_sefWl :: Data (f_sefWf p_sefWh))
      (w4_sefWm :: Data (g_sefWg p_sefWh))
      (@ (c_sefWn :: * -> *))
      (w5_sefWo :: forall b r. Data b => c_sefWn (b -> r) -> c_sefWn r)
      (w6_sefWp :: forall r. r -> c_sefWn r)
      (w7_sefWq :: Constr) ->
      case w7_sefWq of
      { Constr ww1_sefWt ww2_sefWu ww3_sefWv ww4_sefWw ww5_sefWx ->
      Data.Data.$w$cgunfold3
        @ f_sefWf
        @ g_sefWg
        @ p_sefWh
        w3_sefWl
        w4_sefWm
        @ c_sefWn
        w5_sefWo
        w6_sefWp
        ww1_sefWt
        ww5_sefWx
      }

-- RHS size: {terms: 34, types: 59, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold9 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data a, Data b) =>
     forall (c :: * -> *).
     (forall b1 r. Data b1 => c (b1 -> r) -> c r)
     -> (forall r. r -> c r) -> ConstrRep -> DataType -> c (Either a b)
[GblId,
 Arity=6,
 Str=<L,U><L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 120 120 60 20] 180 0}]
Data.Data.$w$cgunfold9
  = \ (@ a_sefWA)
      (@ b_sefWB)
      (w_sefWC :: Data a_sefWA)
      (w1_sefWD :: Data b_sefWB)
      (@ (c_sefWE :: * -> *))
      (w2_sefWF
         :: forall b1 r. Data b1 => c_sefWE (b1 -> r) -> c_sefWE r)
      (w3_sefWG :: forall r. r -> c_sefWE r)
      (ww_sefWK :: ConstrRep)
      (ww1_sefWO :: DataType) ->
      case ww_sefWK of {
        __DEFAULT ->
          case ww1_sefWO of { DataType ww3_sefV0 ww4_sefV1 ->
          case Data.Data.$wlvl ww3_sefV0 of wild1_00 { }
          };
        AlgConstr idx_ae1Ws ->
          case idx_ae1Ws of { I# ds_de7DB ->
          case ds_de7DB of {
            __DEFAULT ->
              w2_sefWF
                @ b_sefWB
                @ (Either a_sefWA b_sefWB)
                w1_sefWD
                (w3_sefWG
                   @ (b_sefWB -> Either a_sefWA b_sefWB)
                   (Data.Either.Right @ a_sefWA @ b_sefWB));
            1# ->
              w2_sefWF
                @ a_sefWA
                @ (Either a_sefWA b_sefWB)
                w_sefWC
                (w3_sefWG
                   @ (a_sefWA -> Either a_sefWA b_sefWB)
                   (Data.Either.Left @ a_sefWA @ b_sefWB))
          }
          }
      }

-- RHS size: {terms: 18, types: 39, coercions: 0, joins: 0/0}
Data.Data.$fDataEither_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data a, Data b) =>
     forall (c :: * -> *).
     (forall b1 r. Data b1 => c (b1 -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c (Either a b)
[GblId,
 Arity=5,
 Str=<L,U><L,U><C(C(S)),1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sefWA)
                 (@ b_sefWB)
                 (w_sefWC [Occ=Once] :: Data a_sefWA)
                 (w1_sefWD [Occ=Once] :: Data b_sefWB)
                 (@ (c_sefWE :: * -> *))
                 (w2_sefWF [Occ=Once]
                    :: forall b1 r. Data b1 => c_sefWE (b1 -> r) -> c_sefWE r)
                 (w3_sefWG [Occ=Once] :: forall r. r -> c_sefWE r)
                 (w4_sefWH [Occ=Once!] :: Constr) ->
                 case w4_sefWH of
                 { Constr ww1_sefWK [Occ=Once] _ [Occ=Dead] _ [Occ=Dead]
                          _ [Occ=Dead] ww5_sefWO [Occ=Once] ->
                 Data.Data.$w$cgunfold9
                   @ a_sefWA
                   @ b_sefWB
                   w_sefWC
                   w1_sefWD
                   @ c_sefWE
                   w2_sefWF
                   w3_sefWG
                   ww1_sefWK
                   ww5_sefWO
                 }}]
Data.Data.$fDataEither_$cgunfold
  = \ (@ a_sefWA)
      (@ b_sefWB)
      (w_sefWC :: Data a_sefWA)
      (w1_sefWD :: Data b_sefWB)
      (@ (c_sefWE :: * -> *))
      (w2_sefWF
         :: forall b1 r. Data b1 => c_sefWE (b1 -> r) -> c_sefWE r)
      (w3_sefWG :: forall r. r -> c_sefWE r)
      (w4_sefWH :: Constr) ->
      case w4_sefWH of
      { Constr ww1_sefWK ww2_sefWL ww3_sefWM ww4_sefWN ww5_sefWO ->
      Data.Data.$w$cgunfold9
        @ a_sefWA
        @ b_sefWB
        w_sefWC
        w1_sefWD
        @ c_sefWE
        w2_sefWF
        w3_sefWG
        ww1_sefWK
        ww5_sefWO
      }

-- RHS size: {terms: 28, types: 23, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold18 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r) -> ConstrRep -> DataType -> c Ordering
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U(1*U,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [180 60 20] 150 0}]
Data.Data.$w$cgunfold18
  = \ (@ (c_sefWR :: * -> *))
      (w_sefWT :: forall r. r -> c_sefWR r)
      (ww_sefWX :: ConstrRep)
      (ww1_sefX1 :: DataType) ->
      case ww_sefWX of {
        __DEFAULT ->
          case ww1_sefX1 of { DataType ww3_sefV0 ww4_sefV1 ->
          case Data.Data.$wlvl ww3_sefV0 of wild1_00 { }
          };
        AlgConstr idx_ae1Ws ->
          case idx_ae1Ws of { I# ds_de7DZ ->
          case ds_de7DZ of {
            __DEFAULT -> w_sefWT @ Ordering GHC.Types.GT;
            1# -> w_sefWT @ Ordering GHC.Types.LT;
            2# -> w_sefWT @ Ordering GHC.Types.EQ
          }
          }
      }

-- RHS size: {terms: 11, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataOrdering_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c Ordering
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_sefWR :: * -> *))
                 _ [Occ=Dead]
                 (w1_sefWT [Occ=Once] :: forall r. r -> c_sefWR r)
                 (w2_sefWU [Occ=Once!] :: Constr) ->
                 case w2_sefWU of
                 { Constr ww1_sefWX [Occ=Once] _ [Occ=Dead] _ [Occ=Dead]
                          _ [Occ=Dead] ww5_sefX1 [Occ=Once] ->
                 Data.Data.$w$cgunfold18 @ c_sefWR w1_sefWT ww1_sefWX ww5_sefX1
                 }}]
Data.Data.$fDataOrdering_$cgunfold
  = \ (@ (c_sefWR :: * -> *))
      _ [Occ=Dead]
      (w1_sefWT :: forall r. r -> c_sefWR r)
      (w2_sefWU :: Constr) ->
      case w2_sefWU of
      { Constr ww1_sefWX ww2_sefWY ww3_sefWZ ww4_sefX0 ww5_sefX1 ->
      Data.Data.$w$cgunfold18 @ c_sefWR w1_sefWT ww1_sefWX ww5_sefX1
      }

-- RHS size: {terms: 30, types: 45, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold10 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> ConstrRep -> DataType -> c (Maybe a)
[GblId,
 Arity=5,
 Str=<L,U><L,1*C1(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 60 120 60 20] 150 0}]
Data.Data.$w$cgunfold10
  = \ (@ a_sefX4)
      (w_sefX5 :: Data a_sefX4)
      (@ (c_sefX6 :: * -> *))
      (w1_sefX7 :: forall b r. Data b => c_sefX6 (b -> r) -> c_sefX6 r)
      (w2_sefX8 :: forall r. r -> c_sefX6 r)
      (ww_sefXc :: ConstrRep)
      (ww1_sefXg :: DataType) ->
      case ww_sefXc of {
        __DEFAULT ->
          case ww1_sefXg of { DataType ww3_sefV0 ww4_sefV1 ->
          case Data.Data.$wlvl ww3_sefV0 of wild1_00 { }
          };
        AlgConstr idx_ae1Ws ->
          case idx_ae1Ws of { I# ds_de7Em ->
          case ds_de7Em of {
            __DEFAULT ->
              w1_sefX7
                @ a_sefX4
                @ (Maybe a_sefX4)
                w_sefX5
                (w2_sefX8 @ (a_sefX4 -> Maybe a_sefX4) (GHC.Base.Just @ a_sefX4));
            1# -> w2_sefX8 @ (Maybe a_sefX4) (GHC.Base.Nothing @ a_sefX4)
          }
          }
      }

-- RHS size: {terms: 15, types: 34, coercions: 0, joins: 0/0}
Data.Data.$fDataMaybe_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c (Maybe a)
[GblId,
 Arity=4,
 Str=<L,U><L,1*C1(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sefX4)
                 (w_sefX5 [Occ=Once] :: Data a_sefX4)
                 (@ (c_sefX6 :: * -> *))
                 (w1_sefX7 [Occ=Once]
                    :: forall b r. Data b => c_sefX6 (b -> r) -> c_sefX6 r)
                 (w2_sefX8 [Occ=Once] :: forall r. r -> c_sefX6 r)
                 (w3_sefX9 [Occ=Once!] :: Constr) ->
                 case w3_sefX9 of
                 { Constr ww1_sefXc [Occ=Once] _ [Occ=Dead] _ [Occ=Dead]
                          _ [Occ=Dead] ww5_sefXg [Occ=Once] ->
                 Data.Data.$w$cgunfold10
                   @ a_sefX4 w_sefX5 @ c_sefX6 w1_sefX7 w2_sefX8 ww1_sefXc ww5_sefXg
                 }}]
Data.Data.$fDataMaybe_$cgunfold
  = \ (@ a_sefX4)
      (w_sefX5 :: Data a_sefX4)
      (@ (c_sefX6 :: * -> *))
      (w1_sefX7 :: forall b r. Data b => c_sefX6 (b -> r) -> c_sefX6 r)
      (w2_sefX8 :: forall r. r -> c_sefX6 r)
      (w3_sefX9 :: Constr) ->
      case w3_sefX9 of
      { Constr ww1_sefXc ww2_sefXd ww3_sefXe ww4_sefXf ww5_sefXg ->
      Data.Data.$w$cgunfold10
        @ a_sefX4 w_sefX5 @ c_sefX6 w1_sefX7 w2_sefX8 ww1_sefXc ww5_sefXg
      }

-- RHS size: {terms: 25, types: 22, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold4 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r) -> ConstrRep -> DataType -> c Bool
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U(1*U,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [120 60 20] 120 0}]
Data.Data.$w$cgunfold4
  = \ (@ (c_sefXj :: * -> *))
      (w_sefXl :: forall r. r -> c_sefXj r)
      (ww_sefXp :: ConstrRep)
      (ww1_sefXt :: DataType) ->
      case ww_sefXp of {
        __DEFAULT ->
          case ww1_sefXt of { DataType ww3_sefV0 ww4_sefV1 ->
          case Data.Data.$wlvl ww3_sefV0 of wild1_00 { }
          };
        AlgConstr idx_ae1Ws ->
          case idx_ae1Ws of { I# ds_de7F3 ->
          case ds_de7F3 of {
            __DEFAULT -> w_sefXl @ Bool GHC.Types.True;
            1# -> w_sefXl @ Bool GHC.Types.False
          }
          }
      }

-- RHS size: {terms: 11, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataBool_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c Bool
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_sefXj :: * -> *))
                 _ [Occ=Dead]
                 (w1_sefXl [Occ=Once] :: forall r. r -> c_sefXj r)
                 (w2_sefXm [Occ=Once!] :: Constr) ->
                 case w2_sefXm of
                 { Constr ww1_sefXp [Occ=Once] _ [Occ=Dead] _ [Occ=Dead]
                          _ [Occ=Dead] ww5_sefXt [Occ=Once] ->
                 Data.Data.$w$cgunfold4 @ c_sefXj w1_sefXl ww1_sefXp ww5_sefXt
                 }}]
Data.Data.$fDataBool_$cgunfold
  = \ (@ (c_sefXj :: * -> *))
      _ [Occ=Dead]
      (w1_sefXl :: forall r. r -> c_sefXj r)
      (w2_sefXm :: Constr) ->
      case w2_sefXm of
      { Constr ww1_sefXp ww2_sefXq ww3_sefXr ww4_sefXs ww5_sefXt ->
      Data.Data.$w$cgunfold4 @ c_sefXj w1_sefXl ww1_sefXp ww5_sefXt
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl22_rejMw :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl22_rejMw = "Data.Data.gunfold(Ratio)"#

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
Data.Data.$fDataRatio7 :: forall (c :: * -> *) a. c (Ratio a)
[GblId, Str=x]
Data.Data.$fDataRatio7
  = \ (@ (c_ae5Ao :: * -> *)) (@ a_Xe61y) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ (c_ae5Ao (Ratio a_Xe61y))
        (unpackCString# lvl22_rejMw)

-- RHS size: {terms: 33, types: 51, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold19 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Data a, Integral a) =>
     forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> ConstrRep -> DataType -> c (Ratio a)
[GblId,
 Arity=6,
 Str=<L,U><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><C(C(S)),C(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 120 60 60 20] 180 0}]
Data.Data.$w$cgunfold19
  = \ (@ a_sefXw)
      (w_sefXx :: Data a_sefXw)
      (w1_sefXy :: Integral a_sefXw)
      (@ (c_sefXz :: * -> *))
      (w2_sefXA :: forall b r. Data b => c_sefXz (b -> r) -> c_sefXz r)
      (w3_sefXB :: forall r. r -> c_sefXz r)
      (ww_sefXF :: ConstrRep)
      (ww1_sefXJ :: DataType) ->
      case ww_sefXF of {
        __DEFAULT ->
          case ww1_sefXJ of { DataType ww3_sefV0 ww4_sefV1 ->
          case Data.Data.$wlvl ww3_sefV0 of wild1_00 { }
          };
        AlgConstr idx_ae1Ws ->
          case idx_ae1Ws of { I# x_a22G ->
          case x_a22G of {
            __DEFAULT -> Data.Data.$fDataRatio7 @ c_sefXz @ a_sefXw;
            1# ->
              w2_sefXA
                @ a_sefXw
                @ (Ratio a_sefXw)
                w_sefXx
                (w2_sefXA
                   @ a_sefXw
                   @ (a_sefXw -> Ratio a_sefXw)
                   w_sefXx
                   (w3_sefXB
                      @ (a_sefXw -> a_sefXw -> Ratio a_sefXw) (% @ a_sefXw w1_sefXy)))
          }
          }
      }

-- RHS size: {terms: 17, types: 36, coercions: 0, joins: 0/0}
Data.Data.$fDataRatio_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Data a, Integral a) =>
     forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c (Ratio a)
[GblId,
 Arity=5,
 Str=<L,U><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><C(C(S)),C(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sefXw)
                 (w_sefXx [Occ=Once] :: Data a_sefXw)
                 (w1_sefXy [Occ=Once] :: Integral a_sefXw)
                 (@ (c_sefXz :: * -> *))
                 (w2_sefXA [Occ=Once]
                    :: forall b r. Data b => c_sefXz (b -> r) -> c_sefXz r)
                 (w3_sefXB [Occ=Once] :: forall r. r -> c_sefXz r)
                 (w4_sefXC [Occ=Once!] :: Constr) ->
                 case w4_sefXC of
                 { Constr ww1_sefXF [Occ=Once] _ [Occ=Dead] _ [Occ=Dead]
                          _ [Occ=Dead] ww5_sefXJ [Occ=Once] ->
                 Data.Data.$w$cgunfold19
                   @ a_sefXw
                   w_sefXx
                   w1_sefXy
                   @ c_sefXz
                   w2_sefXA
                   w3_sefXB
                   ww1_sefXF
                   ww5_sefXJ
                 }}]
Data.Data.$fDataRatio_$cgunfold
  = \ (@ a_sefXw)
      (w_sefXx :: Data a_sefXw)
      (w1_sefXy :: Integral a_sefXw)
      (@ (c_sefXz :: * -> *))
      (w2_sefXA :: forall b r. Data b => c_sefXz (b -> r) -> c_sefXz r)
      (w3_sefXB :: forall r. r -> c_sefXz r)
      (w4_sefXC :: Constr) ->
      case w4_sefXC of
      { Constr ww1_sefXF ww2_sefXG ww3_sefXH ww4_sefXI ww5_sefXJ ->
      Data.Data.$w$cgunfold19
        @ a_sefXw
        w_sefXx
        w1_sefXy
        @ c_sefXz
        w2_sefXA
        w3_sefXB
        ww1_sefXF
        ww5_sefXJ
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl23_rejMx :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl23_rejMx = " is not of type Integer."#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl24_rejMy :: [Char]
[GblId]
lvl24_rejMy = unpackCString# lvl23_rejMx

-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
Data.Data.$wlvl9 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *). String -> c Integer
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
Data.Data.$wlvl9
  = \ (@ (c_sefXM :: * -> *)) (ww_sefXR :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ (c_sefXM Integer)
        (unpackAppendCString# lvl1_rejM9 (++ @ Char ww_sefXR lvl24_rejMy))

-- RHS size: {terms: 7, types: 13, coercions: 0, joins: 0/0}
Data.Data.$fDataInteger4 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *). Constr -> c Integer
[GblId,
 Arity=1,
 Str=<B,1*U(A,1*U,A,A,A)>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_sefXM :: * -> *)) (w_sefXN [Occ=Once!] :: Constr) ->
                 case w_sefXN of
                 { Constr _ [Occ=Dead] ww2_sefXR [Occ=Once] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Data.$wlvl9 @ c_sefXM ww2_sefXR
                 }}]
Data.Data.$fDataInteger4
  = \ (@ (c_sefXM :: * -> *)) (w_sefXN :: Constr) ->
      case w_sefXN of
      { Constr ww1_sefXQ ww2_sefXR ww3_sefXS ww4_sefXT ww5_sefXU ->
      Data.Data.$wlvl9 @ c_sefXM ww2_sefXR
      }

-- RHS size: {terms: 15, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataInteger_$cgunfold
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c Integer
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,1*U,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_ae6dn :: * -> *))
                 _ [Occ=Dead]
                 (z_ae1Vb [Occ=Once!] :: forall r. r -> c_ae6dn r)
                 (c1_ae1Vc [Occ=Once!] :: Constr) ->
                 case c1_ae1Vc of wild_Xrf
                 { Constr ds1_de7lX [Occ=Once!] _ [Occ=Dead] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 case ds1_de7lX of {
                   __DEFAULT -> Data.Data.$fDataInteger4 @ c_ae6dn wild_Xrf;
                   IntConstr x_ae1Vd [Occ=Once] -> z_ae1Vb @ Integer x_ae1Vd
                 }
                 }}]
Data.Data.$fDataInteger_$cgunfold
  = \ (@ (c_ae6dn :: * -> *))
      _ [Occ=Dead]
      (z_ae1Vb :: forall r. r -> c_ae6dn r)
      (c1_ae1Vc :: Constr) ->
      case c1_ae1Vc of
      { Constr ds1_de7lX ds2_de7lY ds3_de7lZ ds4_de7m0 ds5_de7m1 ->
      case ds1_de7lX of {
        __DEFAULT -> Data.Data.$wlvl9 @ c_ae6dn ds2_de7lY;
        IntConstr x_ae1Vd -> z_ae1Vb @ Integer x_ae1Vd
      }
      }

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
mkDataType :: String -> [Constr] -> DataType
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (str60_ae1VZ [Occ=Once] :: String)
                 (cs_ae1W0 [Occ=Once] :: [Constr]) ->
                 Data.Data.DataType str60_ae1VZ (Data.Data.AlgRep cs_ae1W0)}]
mkDataType
  = \ (str60_ae1VZ :: String) (cs_ae1W0 :: [Constr]) ->
      Data.Data.DataType str60_ae1VZ (Data.Data.AlgRep cs_ae1W0)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
constrFields :: Constr -> [String]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLL),1*U(A,A,1*U,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= confields}]
constrFields = confields

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
constrFixity :: Constr -> Fixity
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSL),1*U(A,A,A,1*U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= confixity}]
constrFixity = confixity

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
showConstr :: Constr -> String
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLL),1*U(A,1*U,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= constring}]
showConstr = constring

-- RHS size: {terms: 10, types: 7, coercions: 0, joins: 0/0}
isAlgType :: DataType -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (dt_ae1Wn [Occ=Once!] :: DataType) ->
                 case dt_ae1Wn of { DataType _ [Occ=Dead] ds1_de7mv [Occ=Once!] ->
                 case ds1_de7mv of {
                   __DEFAULT -> GHC.Types.False;
                   AlgRep _ [Occ=Dead] -> GHC.Types.True
                 }
                 }}]
isAlgType
  = \ (dt_ae1Wn :: DataType) ->
      case dt_ae1Wn of { DataType ds_de7mu ds1_de7mv ->
      case ds1_de7mv of {
        __DEFAULT -> GHC.Types.False;
        AlgRep ds2_de7hD -> GHC.Types.True
      }
      }

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
mkCharType :: String -> DataType
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (str60_ae1Ww [Occ=Once] :: String) ->
                 Data.Data.DataType str60_ae1Ww Data.Data.CharRep}]
mkCharType
  = \ (str60_ae1Ww :: String) ->
      Data.Data.DataType str60_ae1Ww Data.Data.CharRep

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
mkFloatType :: String -> DataType
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (str60_ae1Ww [Occ=Once] :: String) ->
                 Data.Data.DataType str60_ae1Ww Data.Data.FloatRep}]
mkFloatType
  = \ (str60_ae1Ww :: String) ->
      Data.Data.DataType str60_ae1Ww Data.Data.FloatRep

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataFloat3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Data.$fDataFloat3 = "Prelude.Float"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataFloat2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataFloat2 = unpackCString# Data.Data.$fDataFloat3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
floatType :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
floatType
  = Data.Data.DataType Data.Data.$fDataFloat2 Data.Data.FloatRep

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataFloat_$cdataTypeOf :: Float -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> floatType}]
Data.Data.$fDataFloat_$cdataTypeOf = \ _ [Occ=Dead] -> floatType

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataDouble3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Data.$fDataDouble3 = "Prelude.Double"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataDouble2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataDouble2 = unpackCString# Data.Data.$fDataDouble3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
doubleType :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
doubleType
  = Data.Data.DataType Data.Data.$fDataDouble2 Data.Data.FloatRep

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataDouble_$cdataTypeOf :: Double -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> doubleType}]
Data.Data.$fDataDouble_$cdataTypeOf = \ _ [Occ=Dead] -> doubleType

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
mkIntType :: String -> DataType
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (str60_ae1Ww [Occ=Once] :: String) ->
                 Data.Data.DataType str60_ae1Ww Data.Data.IntRep}]
mkIntType
  = \ (str60_ae1Ww :: String) ->
      Data.Data.DataType str60_ae1Ww Data.Data.IntRep

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataInteger3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Data.$fDataInteger3 = "Prelude.Integer"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataInteger2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataInteger2 = unpackCString# Data.Data.$fDataInteger3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
integerType :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
integerType
  = Data.Data.DataType Data.Data.$fDataInteger2 Data.Data.IntRep

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataInteger_$cdataTypeOf :: Integer -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> integerType}]
Data.Data.$fDataInteger_$cdataTypeOf
  = \ _ [Occ=Dead] -> integerType

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataNatural3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 0}]
Data.Data.$fDataNatural3 = "Numeric.Natural.Natural"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataNatural2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataNatural2 = unpackCString# Data.Data.$fDataNatural3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
naturalType :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
naturalType
  = Data.Data.DataType Data.Data.$fDataNatural2 Data.Data.IntRep

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataNatural_$cdataTypeOf :: Natural -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> naturalType}]
Data.Data.$fDataNatural_$cdataTypeOf
  = \ _ [Occ=Dead] -> naturalType

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataInt21 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Data.$fDataInt21 = "Data.Int.Int8"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataInt20 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataInt20 = unpackCString# Data.Data.$fDataInt21

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
int8Type :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
int8Type
  = Data.Data.DataType Data.Data.$fDataInt20 Data.Data.IntRep

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataInt8_$cdataTypeOf :: Int8 -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> int8Type}]
Data.Data.$fDataInt8_$cdataTypeOf = \ _ [Occ=Dead] -> int8Type

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataInt7 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Data.$fDataInt7 = "Data.Int.Int16"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataInt6 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataInt6 = unpackCString# Data.Data.$fDataInt7

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
int16Type :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
int16Type
  = Data.Data.DataType Data.Data.$fDataInt6 Data.Data.IntRep

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataInt16_$cdataTypeOf :: Int16 -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> int16Type}]
Data.Data.$fDataInt16_$cdataTypeOf = \ _ [Occ=Dead] -> int16Type

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataInt12 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Data.$fDataInt12 = "Data.Int.Int32"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataInt11 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataInt11 = unpackCString# Data.Data.$fDataInt12

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
int32Type :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
int32Type
  = Data.Data.DataType Data.Data.$fDataInt11 Data.Data.IntRep

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataInt32_$cdataTypeOf :: Int32 -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> int32Type}]
Data.Data.$fDataInt32_$cdataTypeOf = \ _ [Occ=Dead] -> int32Type

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataInt17 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Data.$fDataInt17 = "Data.Int.Int64"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataInt15 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataInt15 = unpackCString# Data.Data.$fDataInt17

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
int64Type :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
int64Type
  = Data.Data.DataType Data.Data.$fDataInt15 Data.Data.IntRep

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataInt64_$cdataTypeOf :: Int64 -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> int64Type}]
Data.Data.$fDataInt64_$cdataTypeOf = \ _ [Occ=Dead] -> int64Type

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataWord3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Data.$fDataWord3 = "Data.Word.Word"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataWord2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataWord2 = unpackCString# Data.Data.$fDataWord3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
wordType :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
wordType
  = Data.Data.DataType Data.Data.$fDataWord2 Data.Data.IntRep

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataWord_$cdataTypeOf :: Word -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> wordType}]
Data.Data.$fDataWord_$cdataTypeOf = \ _ [Occ=Dead] -> wordType

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataWord21 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Data.$fDataWord21 = "Data.Word.Word8"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataWord20 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataWord20 = unpackCString# Data.Data.$fDataWord21

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
word8Type :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
word8Type
  = Data.Data.DataType Data.Data.$fDataWord20 Data.Data.IntRep

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataWord8_$cdataTypeOf :: Word8 -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> word8Type}]
Data.Data.$fDataWord8_$cdataTypeOf = \ _ [Occ=Dead] -> word8Type

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataWord7 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Data.$fDataWord7 = "Data.Word.Word16"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataWord6 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataWord6 = unpackCString# Data.Data.$fDataWord7

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
word16Type :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
word16Type
  = Data.Data.DataType Data.Data.$fDataWord6 Data.Data.IntRep

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataWord16_$cdataTypeOf :: Word16 -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> word16Type}]
Data.Data.$fDataWord16_$cdataTypeOf = \ _ [Occ=Dead] -> word16Type

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataWord12 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Data.$fDataWord12 = "Data.Word.Word32"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataWord11 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataWord11 = unpackCString# Data.Data.$fDataWord12

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
word32Type :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
word32Type
  = Data.Data.DataType Data.Data.$fDataWord11 Data.Data.IntRep

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataWord32_$cdataTypeOf :: Word32 -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> word32Type}]
Data.Data.$fDataWord32_$cdataTypeOf = \ _ [Occ=Dead] -> word32Type

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataWord17 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Data.$fDataWord17 = "Data.Word.Word64"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataWord15 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataWord15 = unpackCString# Data.Data.$fDataWord17

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
word64Type :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
word64Type
  = Data.Data.DataType Data.Data.$fDataWord15 Data.Data.IntRep

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataWord64_$cdataTypeOf :: Word64 -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> word64Type}]
Data.Data.$fDataWord64_$cdataTypeOf = \ _ [Occ=Dead] -> word64Type

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataWord64_$ctoConstr :: Word64 -> Constr
[GblId,
 Arity=1,
 Str=<L,U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_ae1Ux :: Word64) ->
                 Data.Data.Constr
                   (Data.Data.IntConstr
                      (GHC.Word.$fIntegralWord64_$ctoInteger x_ae1Ux))
                   (GHC.Word.$fShowWord64_$cshow x_ae1Ux)
                   Data.Data.$fDataChar5
                   Data.Data.$fDataChar4
                   word64Type}]
Data.Data.$fDataWord64_$ctoConstr
  = \ (x_ae1Ux :: Word64) ->
      Data.Data.Constr
        (Data.Data.IntConstr
           (GHC.Word.$fIntegralWord64_$ctoInteger x_ae1Ux))
        (GHC.Word.$fShowWord64_$cshow x_ae1Ux)
        Data.Data.$fDataChar5
        Data.Data.$fDataChar4
        word64Type

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataWord32_$ctoConstr :: Word32 -> Constr
[GblId,
 Arity=1,
 Str=<L,U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_ae1UB :: Word32) ->
                 Data.Data.Constr
                   (Data.Data.IntConstr (GHC.Word.$ctoInteger2 x_ae1UB))
                   (GHC.Word.$fShowWord32_$cshow x_ae1UB)
                   Data.Data.$fDataChar5
                   Data.Data.$fDataChar4
                   word32Type}]
Data.Data.$fDataWord32_$ctoConstr
  = \ (x_ae1UB :: Word32) ->
      Data.Data.Constr
        (Data.Data.IntConstr (GHC.Word.$ctoInteger2 x_ae1UB))
        (GHC.Word.$fShowWord32_$cshow x_ae1UB)
        Data.Data.$fDataChar5
        Data.Data.$fDataChar4
        word32Type

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataWord16_$ctoConstr :: Word16 -> Constr
[GblId,
 Arity=1,
 Str=<L,U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_ae1UF :: Word16) ->
                 Data.Data.Constr
                   (Data.Data.IntConstr (GHC.Word.$ctoInteger1 x_ae1UF))
                   (GHC.Word.$fShowWord16_$cshow x_ae1UF)
                   Data.Data.$fDataChar5
                   Data.Data.$fDataChar4
                   word16Type}]
Data.Data.$fDataWord16_$ctoConstr
  = \ (x_ae1UF :: Word16) ->
      Data.Data.Constr
        (Data.Data.IntConstr (GHC.Word.$ctoInteger1 x_ae1UF))
        (GHC.Word.$fShowWord16_$cshow x_ae1UF)
        Data.Data.$fDataChar5
        Data.Data.$fDataChar4
        word16Type

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataWord8_$ctoConstr :: Word8 -> Constr
[GblId,
 Arity=1,
 Str=<L,U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_ae1UJ :: Word8) ->
                 Data.Data.Constr
                   (Data.Data.IntConstr (GHC.Word.$ctoInteger x_ae1UJ))
                   (GHC.Word.$fShowWord8_$cshow x_ae1UJ)
                   Data.Data.$fDataChar5
                   Data.Data.$fDataChar4
                   word8Type}]
Data.Data.$fDataWord8_$ctoConstr
  = \ (x_ae1UJ :: Word8) ->
      Data.Data.Constr
        (Data.Data.IntConstr (GHC.Word.$ctoInteger x_ae1UJ))
        (GHC.Word.$fShowWord8_$cshow x_ae1UJ)
        Data.Data.$fDataChar5
        Data.Data.$fDataChar4
        word8Type

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataWord_$ctoConstr :: Word -> Constr
[GblId,
 Arity=1,
 Str=<L,U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_ae1UN :: Word) ->
                 Data.Data.Constr
                   (Data.Data.IntConstr (GHC.Real.$fIntegralWord_$ctoInteger x_ae1UN))
                   (GHC.Show.$fShowWord_$cshow x_ae1UN)
                   Data.Data.$fDataChar5
                   Data.Data.$fDataChar4
                   wordType}]
Data.Data.$fDataWord_$ctoConstr
  = \ (x_ae1UN :: Word) ->
      Data.Data.Constr
        (Data.Data.IntConstr (GHC.Real.$fIntegralWord_$ctoInteger x_ae1UN))
        (GHC.Show.$fShowWord_$cshow x_ae1UN)
        Data.Data.$fDataChar5
        Data.Data.$fDataChar4
        wordType

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataInt64_$ctoConstr :: Int64 -> Constr
[GblId,
 Arity=1,
 Str=<L,U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_ae1UR :: Int64) ->
                 Data.Data.Constr
                   (Data.Data.IntConstr (GHC.Int.$fIntegralInt64_$ctoInteger x_ae1UR))
                   (GHC.Int.$fShowInt64_$cshow x_ae1UR)
                   Data.Data.$fDataChar5
                   Data.Data.$fDataChar4
                   int64Type}]
Data.Data.$fDataInt64_$ctoConstr
  = \ (x_ae1UR :: Int64) ->
      Data.Data.Constr
        (Data.Data.IntConstr (GHC.Int.$fIntegralInt64_$ctoInteger x_ae1UR))
        (GHC.Int.$fShowInt64_$cshow x_ae1UR)
        Data.Data.$fDataChar5
        Data.Data.$fDataChar4
        int64Type

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataInt32_$ctoConstr :: Int32 -> Constr
[GblId,
 Arity=1,
 Str=<L,U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_ae1UV :: Int32) ->
                 Data.Data.Constr
                   (Data.Data.IntConstr (GHC.Int.$fIntegralInt32_$ctoInteger x_ae1UV))
                   (GHC.Int.$fShowInt32_$cshow x_ae1UV)
                   Data.Data.$fDataChar5
                   Data.Data.$fDataChar4
                   int32Type}]
Data.Data.$fDataInt32_$ctoConstr
  = \ (x_ae1UV :: Int32) ->
      Data.Data.Constr
        (Data.Data.IntConstr (GHC.Int.$fIntegralInt32_$ctoInteger x_ae1UV))
        (GHC.Int.$fShowInt32_$cshow x_ae1UV)
        Data.Data.$fDataChar5
        Data.Data.$fDataChar4
        int32Type

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataInt16_$ctoConstr :: Int16 -> Constr
[GblId,
 Arity=1,
 Str=<L,U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_ae1UZ :: Int16) ->
                 Data.Data.Constr
                   (Data.Data.IntConstr (GHC.Int.$fIntegralInt16_$ctoInteger x_ae1UZ))
                   (GHC.Int.$fShowInt16_$cshow x_ae1UZ)
                   Data.Data.$fDataChar5
                   Data.Data.$fDataChar4
                   int16Type}]
Data.Data.$fDataInt16_$ctoConstr
  = \ (x_ae1UZ :: Int16) ->
      Data.Data.Constr
        (Data.Data.IntConstr (GHC.Int.$fIntegralInt16_$ctoInteger x_ae1UZ))
        (GHC.Int.$fShowInt16_$cshow x_ae1UZ)
        Data.Data.$fDataChar5
        Data.Data.$fDataChar4
        int16Type

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataInt8_$ctoConstr :: Int8 -> Constr
[GblId,
 Arity=1,
 Str=<L,U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_ae1V3 :: Int8) ->
                 Data.Data.Constr
                   (Data.Data.IntConstr (GHC.Int.$fIntegralInt8_$ctoInteger x_ae1V3))
                   (GHC.Int.$fShowInt8_$cshow x_ae1V3)
                   Data.Data.$fDataChar5
                   Data.Data.$fDataChar4
                   int8Type}]
Data.Data.$fDataInt8_$ctoConstr
  = \ (x_ae1V3 :: Int8) ->
      Data.Data.Constr
        (Data.Data.IntConstr (GHC.Int.$fIntegralInt8_$ctoInteger x_ae1V3))
        (GHC.Int.$fShowInt8_$cshow x_ae1V3)
        Data.Data.$fDataChar5
        Data.Data.$fDataChar4
        int8Type

-- RHS size: {terms: 9, types: 1, coercions: 1, joins: 0/0}
Data.Data.$fDataNatural_$ctoConstr :: Natural -> Constr
[GblId,
 Arity=1,
 Str=<L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_ae1V7 :: Natural) ->
                 Data.Data.Constr
                   (Data.Data.IntConstr
                      (x_ae1V7
                       `cast` (GHC.Natural.N:Natural[0]
                               :: (Natural :: *) ~R# (Integer :: *))))
                   (GHC.Natural.$fShowNatural_$cshow x_ae1V7)
                   Data.Data.$fDataChar5
                   Data.Data.$fDataChar4
                   naturalType}]
Data.Data.$fDataNatural_$ctoConstr
  = \ (x_ae1V7 :: Natural) ->
      Data.Data.Constr
        (Data.Data.IntConstr
           (x_ae1V7
            `cast` (GHC.Natural.N:Natural[0]
                    :: (Natural :: *) ~R# (Integer :: *))))
        (GHC.Natural.$fShowNatural_$cshow x_ae1V7)
        Data.Data.$fDataChar5
        Data.Data.$fDataChar4
        naturalType

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl25_rejMz :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl25_rejMz = "Data.Data.mkRealConstr is not supported for "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl26_rejMA :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl26_rejMA = ", as it is not a Real data type."#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl27_rejMB :: [Char]
[GblId]
lvl27_rejMB = unpackCString# lvl26_rejMA

-- RHS size: {terms: 7, types: 4, coercions: 0, joins: 0/0}
Data.Data.$wlvl21 [InlPrag=NOUSERINLINE[0]] :: String -> Constr
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
Data.Data.$wlvl21
  = \ (ww_sefY0 :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ Constr
        (unpackAppendCString# lvl25_rejMz (++ @ Char ww_sefY0 lvl27_rejMB))

-- RHS size: {terms: 27, types: 14, coercions: 0, joins: 0/0}
mkRealConstr [InlPrag=NOUSERINLINE[0]]
  :: forall a. (Real a, Show a) => DataType -> a -> Constr
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(U))><L,1*U(A,1*C1(U),A)><S(LS),1*U(U,1*U)><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sefYL)
                 (w_sefYM [Occ=Once] :: Real a_sefYL)
                 (w1_sefYN [Occ=Once] :: Show a_sefYL)
                 (w2_sefYO [Occ=Once!] :: DataType)
                 (w3_sefYP :: a_sefYL) ->
                 case w2_sefYO of
                 { DataType ww1_sefYS [Occ=Once*] ww2_sefYT [Occ=Once!] ->
                 case ww2_sefYT of {
                   __DEFAULT -> Data.Data.$wlvl21 ww1_sefYS;
                   FloatRep ->
                     Data.Data.Constr
                       (Data.Data.FloatConstr (toRational @ a_sefYL w_sefYM w3_sefYP))
                       (show @ a_sefYL w1_sefYN w3_sefYP)
                       Data.Data.$fDataChar5
                       Data.Data.$fDataChar4
                       (Data.Data.DataType ww1_sefYS Data.Data.FloatRep)
                 }
                 }}]
mkRealConstr
  = \ (@ a_sefYL)
      (w_sefYM :: Real a_sefYL)
      (w1_sefYN :: Show a_sefYL)
      (w2_sefYO :: DataType)
      (w3_sefYP :: a_sefYL) ->
      case w2_sefYO of { DataType ww1_sefYS ww2_sefYT ->
      case ww2_sefYT of {
        __DEFAULT -> Data.Data.$wlvl21 ww1_sefYS;
        FloatRep ->
          Data.Data.Constr
            (Data.Data.FloatConstr (toRational @ a_sefYL w_sefYM w3_sefYP))
            (show @ a_sefYL w1_sefYN w3_sefYP)
            Data.Data.$fDataChar5
            Data.Data.$fDataChar4
            (Data.Data.DataType ww1_sefYS Data.Data.FloatRep)
      }
      }

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataFloat_$ctoConstr :: Float -> Constr
[GblId,
 Arity=1,
 Str=<L,U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (f_ae1WD :: Float) ->
                 Data.Data.Constr
                   (Data.Data.FloatConstr
                      (GHC.Float.$fRealFloat_$ctoRational f_ae1WD))
                   (GHC.Float.$fShowFloat_$cshow f_ae1WD)
                   Data.Data.$fDataChar5
                   Data.Data.$fDataChar4
                   floatType}]
Data.Data.$fDataFloat_$ctoConstr
  = \ (f_ae1WD :: Float) ->
      Data.Data.Constr
        (Data.Data.FloatConstr
           (GHC.Float.$fRealFloat_$ctoRational f_ae1WD))
        (GHC.Float.$fShowFloat_$cshow f_ae1WD)
        Data.Data.$fDataChar5
        Data.Data.$fDataChar4
        floatType

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
mkNoRepType :: String -> DataType
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (str60_ae1WG [Occ=Once] :: String) ->
                 Data.Data.DataType str60_ae1WG Data.Data.NoRep}]
mkNoRepType
  = \ (str60_ae1WG :: String) ->
      Data.Data.DataType str60_ae1WG Data.Data.NoRep

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataArray5 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Data.$fDataArray5 = "Data.Array.Array"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataArray4 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataArray4 = unpackCString# Data.Data.$fDataArray5

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataArray3 :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataArray3
  = Data.Data.DataType Data.Data.$fDataArray4 Data.Data.NoRep

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataForeignPtr4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 80 0}]
Data.Data.$fDataForeignPtr4 = "GHC.ForeignPtr.ForeignPtr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataForeignPtr3 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataForeignPtr3
  = unpackCString# Data.Data.$fDataForeignPtr4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataForeignPtr2 :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataForeignPtr2
  = Data.Data.DataType Data.Data.$fDataForeignPtr3 Data.Data.NoRep

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataPtr4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Data.$fDataPtr4 = "GHC.Ptr.Ptr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataPtr3 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataPtr3 = unpackCString# Data.Data.$fDataPtr4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataPtr2 :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataPtr2
  = Data.Data.DataType Data.Data.$fDataPtr3 Data.Data.NoRep

-- RHS size: {terms: 10, types: 5, coercions: 0, joins: 0/0}
isNorepType :: DataType -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (dt_ae1WH [Occ=Once!] :: DataType) ->
                 case dt_ae1WH of { DataType _ [Occ=Dead] ds1_de7mv [Occ=Once!] ->
                 case ds1_de7mv of {
                   __DEFAULT -> GHC.Types.False;
                   NoRep -> GHC.Types.True
                 }
                 }}]
isNorepType
  = \ (dt_ae1WH :: DataType) ->
      case dt_ae1WH of { DataType ds_de7mu ds1_de7mv ->
      case ds1_de7mv of {
        __DEFAULT -> GHC.Types.False;
        NoRep -> GHC.Types.True
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataV4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataV4 = "V1"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataV3 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataV3 = unpackCString# Data.Data.$fDataV4

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataV2 :: DataRep
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataV2 = Data.Data.AlgRep (GHC.Types.[] @ Constr)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tV1 :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$tV1
  = Data.Data.DataType Data.Data.$fDataV3 Data.Data.$fDataV2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$trModule3 = GHC.Types.TrNameS Data.Data.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Data.$trModule2 = "Data.Data"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$trModule1 = GHC.Types.TrNameS Data.Data.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$trModule
  = GHC.Types.Module Data.Data.$trModule3 Data.Data.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_rejMC :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_rejMC
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcBool (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1_rejMD :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep1_rejMD
  = GHC.Types.KindRepTyConApp
      integer-simple-0.1.1.1:GHC.Integer.Type.$tcInteger
      (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep2_rejME :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep2_rejME
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcInt (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep3_rejMF :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep3_rejMF
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcChar (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep4_rejMG :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep4_rejMG
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcConstraint (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep5_rejMH :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep5_rejMH
  = GHC.Types.: @ KindRep $krep1_rejMD (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep6_rejMI :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep6_rejMI
  = GHC.Types.KindRepTyConApp GHC.Real.$tcRatio $krep5_rejMH

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep7_rejMJ :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep7_rejMJ
  = GHC.Types.: @ KindRep $krep3_rejMF (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep8_rejMK :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep8_rejMK
  = GHC.Types.KindRepTyConApp GHC.Types.$tc[] $krep7_rejMJ

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep9_rejML :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep9_rejML
  = GHC.Types.: @ KindRep $krep8_rejMK (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep10_rejMM :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep10_rejMM
  = GHC.Types.KindRepTyConApp GHC.Types.$tc[] $krep9_rejML

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcData1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Data.$tcData1
  = GHC.Types.KindRepFun GHC.Types.krep$* $krep4_rejMG

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcMp1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Data.$tcMp1
  = GHC.Types.KindRepFun GHC.Types.krep$*Arr* GHC.Types.krep$*Arr*

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep11_rejMN :: KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep11_rejMN = GHC.Types.KindRepVar 1#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep12_rejMO :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep12_rejMO = GHC.Types.KindRepFun $krep11_rejMN $krep11_rejMN

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep13_rejMP :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep13_rejMP
  = GHC.Types.: @ KindRep $krep_rejMC (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep14_rejMQ :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep14_rejMQ = GHC.Types.: @ KindRep $krep11_rejMN $krep13_rejMP

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep15_rejMR :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep15_rejMR
  = GHC.Types.KindRepTyConApp GHC.Tuple.$tc(,) $krep14_rejMQ

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep16_rejMS :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep16_rejMS
  = GHC.Types.: @ KindRep $krep11_rejMN (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep17_rejMT :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep17_rejMT
  = GHC.Types.KindRepTyConApp GHC.Base.$tcMaybe $krep16_rejMS

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep18_rejMU :: KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep18_rejMU = GHC.Types.KindRepVar 0#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep19_rejMV :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep19_rejMV = GHC.Types.KindRepFun $krep18_rejMU GHC.Types.krep$*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcQi1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Data.$tcQi1
  = GHC.Types.KindRepFun GHC.Types.krep$* $krep19_rejMV

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep20_rejMW :: KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []]
$krep20_rejMW = GHC.Types.KindRepApp $krep18_rejMU $krep15_rejMR

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep21_rejMX :: KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep21_rejMX = GHC.Types.KindRepVar 2#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcQi3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$tcQi3 = "Qi"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcQi2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tcQi2 = GHC.Types.TrNameS Data.Data.$tcQi3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcQi :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tcQi
  = GHC.Types.TyCon
      2912507722502294349##
      11958039092135823798##
      Data.Data.$trModule
      Data.Data.$tcQi2
      1#
      Data.Data.$tcQi1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep22_rejMY :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep22_rejMY
  = GHC.Types.: @ KindRep $krep21_rejMX (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep23_rejMZ :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep23_rejMZ = GHC.Types.: @ KindRep $krep11_rejMN $krep22_rejMY

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep24_rejN0 :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep24_rejN0 = GHC.Types.: @ KindRep $krep18_rejMU $krep23_rejMZ

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep25_rejN1 :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep25_rejN1
  = GHC.Types.KindRepTyConApp Data.Data.$tcQi $krep24_rejN0

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep26_rejN2 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep26_rejN2 = GHC.Types.KindRepFun $krep17_rejMT $krep25_rejN1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'Qi1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Data.$tc'Qi1 = GHC.Types.KindRepFun $krep2_rejME $krep26_rejN2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'Qi3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$tc'Qi3 = "'Qi"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'Qi2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tc'Qi2 = GHC.Types.TrNameS Data.Data.$tc'Qi3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'Qi :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tc'Qi
  = GHC.Types.TyCon
      13805440121410837890##
      1844947453487351718##
      Data.Data.$trModule
      Data.Data.$tc'Qi2
      3#
      Data.Data.$tc'Qi1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcQr2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$tcQr2 = "Qr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcQr1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tcQr1 = GHC.Types.TrNameS Data.Data.$tcQr2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcQr :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tcQr
  = GHC.Types.TyCon
      2704451361235406682##
      9900977236239896268##
      Data.Data.$trModule
      Data.Data.$tcQr1
      1#
      Data.Data.$tcQi1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep27_rejN3 :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep27_rejN3
  = GHC.Types.KindRepTyConApp Data.Data.$tcQr $krep24_rejN0

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'Qr1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Data.$tc'Qr1
  = GHC.Types.KindRepFun $krep12_rejMO $krep27_rejN3

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'Qr3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$tc'Qr3 = "'Qr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'Qr2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tc'Qr2 = GHC.Types.TrNameS Data.Data.$tc'Qr3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'Qr :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tc'Qr
  = GHC.Types.TyCon
      857387782932178477##
      10443502290716537597##
      Data.Data.$trModule
      Data.Data.$tc'Qr2
      3#
      Data.Data.$tc'Qr1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcMp3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$tcMp3 = "Mp"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcMp2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tcMp2 = GHC.Types.TrNameS Data.Data.$tcMp3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcMp :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tcMp
  = GHC.Types.TyCon
      18086976724350381593##
      1102978423777634325##
      Data.Data.$trModule
      Data.Data.$tcMp2
      0#
      Data.Data.$tcMp1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep28_rejN4 :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep28_rejN4 = GHC.Types.: @ KindRep $krep18_rejMU $krep16_rejMS

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep29_rejN5 :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep29_rejN5
  = GHC.Types.KindRepTyConApp Data.Data.$tcMp $krep28_rejN4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'Mp1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Data.$tc'Mp1
  = GHC.Types.KindRepFun $krep20_rejMW $krep29_rejN5

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'Mp3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$tc'Mp3 = "'Mp"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'Mp2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tc'Mp2 = GHC.Types.TrNameS Data.Data.$tc'Mp3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'Mp :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tc'Mp
  = GHC.Types.TyCon
      14459666944806647050##
      954255893298021944##
      Data.Data.$trModule
      Data.Data.$tc'Mp2
      2#
      Data.Data.$tc'Mp1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcConstrRep2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Data.$tcConstrRep2 = "ConstrRep"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcConstrRep1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tcConstrRep1 = GHC.Types.TrNameS Data.Data.$tcConstrRep2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcConstrRep :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tcConstrRep
  = GHC.Types.TyCon
      7659287471351671755##
      9192134917547656139##
      Data.Data.$trModule
      Data.Data.$tcConstrRep1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep30_rejN6 :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep30_rejN6
  = GHC.Types.KindRepTyConApp
      Data.Data.$tcConstrRep (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'FloatConstr1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Data.$tc'FloatConstr1
  = GHC.Types.KindRepFun $krep6_rejMI $krep30_rejN6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'FloatConstr3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Data.$tc'FloatConstr3 = "'FloatConstr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'FloatConstr2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tc'FloatConstr2
  = GHC.Types.TrNameS Data.Data.$tc'FloatConstr3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'FloatConstr :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tc'FloatConstr
  = GHC.Types.TyCon
      12163445948151391877##
      11140216685044477643##
      Data.Data.$trModule
      Data.Data.$tc'FloatConstr2
      0#
      Data.Data.$tc'FloatConstr1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'IntConstr1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Data.$tc'IntConstr1
  = GHC.Types.KindRepFun $krep1_rejMD $krep30_rejN6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'IntConstr3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Data.$tc'IntConstr3 = "'IntConstr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'IntConstr2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tc'IntConstr2
  = GHC.Types.TrNameS Data.Data.$tc'IntConstr3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'IntConstr :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tc'IntConstr
  = GHC.Types.TyCon
      1649688709368896048##
      7413862661916009214##
      Data.Data.$trModule
      Data.Data.$tc'IntConstr2
      0#
      Data.Data.$tc'IntConstr1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'CharConstr1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Data.$tc'CharConstr1
  = GHC.Types.KindRepFun $krep3_rejMF $krep30_rejN6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'CharConstr3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Data.$tc'CharConstr3 = "'CharConstr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'CharConstr2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tc'CharConstr2
  = GHC.Types.TrNameS Data.Data.$tc'CharConstr3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'CharConstr :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tc'CharConstr
  = GHC.Types.TyCon
      5198369131331367665##
      13148656396701252559##
      Data.Data.$trModule
      Data.Data.$tc'CharConstr2
      0#
      Data.Data.$tc'CharConstr1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'AlgConstr1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Data.$tc'AlgConstr1
  = GHC.Types.KindRepFun $krep2_rejME $krep30_rejN6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'AlgConstr3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Data.$tc'AlgConstr3 = "'AlgConstr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'AlgConstr2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tc'AlgConstr2
  = GHC.Types.TrNameS Data.Data.$tc'AlgConstr3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'AlgConstr :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tc'AlgConstr
  = GHC.Types.TyCon
      6426959395702389108##
      5251167763391034465##
      Data.Data.$trModule
      Data.Data.$tc'AlgConstr2
      0#
      Data.Data.$tc'AlgConstr1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcFixity2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$tcFixity2 = "Fixity"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcFixity1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tcFixity1 = GHC.Types.TrNameS Data.Data.$tcFixity2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcFixity :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tcFixity
  = GHC.Types.TyCon
      13918417559396020700##
      4362902577251129047##
      Data.Data.$trModule
      Data.Data.$tcFixity1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Data.$tc'Infix1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
Data.Data.$tc'Infix1
  = GHC.Types.KindRepTyConApp
      Data.Data.$tcFixity (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'Prefix2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$tc'Prefix2 = "'Prefix"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'Prefix1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tc'Prefix1 = GHC.Types.TrNameS Data.Data.$tc'Prefix2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'Prefix :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tc'Prefix
  = GHC.Types.TyCon
      18192500634486553138##
      5335553840204605545##
      Data.Data.$trModule
      Data.Data.$tc'Prefix1
      0#
      Data.Data.$tc'Infix1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'Infix3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$tc'Infix3 = "'Infix"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'Infix2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tc'Infix2 = GHC.Types.TrNameS Data.Data.$tc'Infix3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'Infix :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tc'Infix
  = GHC.Types.TyCon
      17816851295105190232##
      2763696255578910000##
      Data.Data.$trModule
      Data.Data.$tc'Infix2
      0#
      Data.Data.$tc'Infix1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcDataRep2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$tcDataRep2 = "DataRep"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcDataRep1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tcDataRep1 = GHC.Types.TrNameS Data.Data.$tcDataRep2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcDataRep :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tcDataRep
  = GHC.Types.TyCon
      1837901479420408726##
      14866864307051391848##
      Data.Data.$trModule
      Data.Data.$tcDataRep1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Data.$tc'CharRep1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
Data.Data.$tc'CharRep1
  = GHC.Types.KindRepTyConApp
      Data.Data.$tcDataRep (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'IntRep2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$tc'IntRep2 = "'IntRep"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'IntRep1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tc'IntRep1 = GHC.Types.TrNameS Data.Data.$tc'IntRep2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'IntRep :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tc'IntRep
  = GHC.Types.TyCon
      701344191116669652##
      3803348403161497237##
      Data.Data.$trModule
      Data.Data.$tc'IntRep1
      0#
      Data.Data.$tc'CharRep1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'FloatRep2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Data.$tc'FloatRep2 = "'FloatRep"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'FloatRep1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tc'FloatRep1 = GHC.Types.TrNameS Data.Data.$tc'FloatRep2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'FloatRep :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tc'FloatRep
  = GHC.Types.TyCon
      13479666879669966281##
      18377802819634571758##
      Data.Data.$trModule
      Data.Data.$tc'FloatRep1
      0#
      Data.Data.$tc'CharRep1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'CharRep3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$tc'CharRep3 = "'CharRep"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'CharRep2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tc'CharRep2 = GHC.Types.TrNameS Data.Data.$tc'CharRep3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'CharRep :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tc'CharRep
  = GHC.Types.TyCon
      9866995244336875441##
      2816144705852370202##
      Data.Data.$trModule
      Data.Data.$tc'CharRep2
      0#
      Data.Data.$tc'CharRep1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'NoRep2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$tc'NoRep2 = "'NoRep"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'NoRep1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tc'NoRep1 = GHC.Types.TrNameS Data.Data.$tc'NoRep2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'NoRep :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tc'NoRep
  = GHC.Types.TyCon
      17980512806527760717##
      10309785671714238761##
      Data.Data.$trModule
      Data.Data.$tc'NoRep1
      0#
      Data.Data.$tc'CharRep1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcDataType2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$tcDataType2 = "DataType"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcDataType1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tcDataType1 = GHC.Types.TrNameS Data.Data.$tcDataType2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcDataType :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tcDataType
  = GHC.Types.TyCon
      13990223408414889174##
      878717790678348775##
      Data.Data.$trModule
      Data.Data.$tcDataType1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep31_rejN7 :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep31_rejN7
  = GHC.Types.KindRepTyConApp
      Data.Data.$tcDataType (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep32_rejN8 :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep32_rejN8
  = GHC.Types.KindRepFun Data.Data.$tc'CharRep1 $krep31_rejN7

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'DataType1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Data.$tc'DataType1
  = GHC.Types.KindRepFun $krep8_rejMK $krep32_rejN8

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'DataType3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Data.$tc'DataType3 = "'DataType"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'DataType2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tc'DataType2 = GHC.Types.TrNameS Data.Data.$tc'DataType3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'DataType :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tc'DataType
  = GHC.Types.TyCon
      7800203538197050982##
      933913700600579668##
      Data.Data.$trModule
      Data.Data.$tc'DataType2
      0#
      Data.Data.$tc'DataType1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcConstr2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$tcConstr2 = "Constr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcConstr1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tcConstr1 = GHC.Types.TrNameS Data.Data.$tcConstr2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcConstr :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tcConstr
  = GHC.Types.TyCon
      16562201882403018000##
      12615646597309386354##
      Data.Data.$trModule
      Data.Data.$tcConstr1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep33_rejN9 :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep33_rejN9
  = GHC.Types.KindRepTyConApp
      Data.Data.$tcConstr (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep34_rejNa :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep34_rejNa = GHC.Types.KindRepFun $krep31_rejN7 $krep33_rejN9

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep35_rejNb :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep35_rejNb
  = GHC.Types.KindRepFun Data.Data.$tc'Infix1 $krep34_rejNa

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep36_rejNc :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep36_rejNc = GHC.Types.KindRepFun $krep10_rejMM $krep35_rejNb

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep37_rejNd :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep37_rejNd = GHC.Types.KindRepFun $krep8_rejMK $krep36_rejNc

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'Constr1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Data.$tc'Constr1
  = GHC.Types.KindRepFun $krep30_rejN6 $krep37_rejNd

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'Constr3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$tc'Constr3 = "'Constr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'Constr2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tc'Constr2 = GHC.Types.TrNameS Data.Data.$tc'Constr3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'Constr :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tc'Constr
  = GHC.Types.TyCon
      2704834352168883384##
      16020766185724935309##
      Data.Data.$trModule
      Data.Data.$tc'Constr2
      0#
      Data.Data.$tc'Constr1

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep38_rejNe :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep38_rejNe
  = GHC.Types.: @ KindRep $krep33_rejN9 (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep39_rejNf :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep39_rejNf
  = GHC.Types.KindRepTyConApp GHC.Types.$tc[] $krep38_rejNe

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'AlgRep1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Data.$tc'AlgRep1
  = GHC.Types.KindRepFun $krep39_rejNf Data.Data.$tc'CharRep1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'AlgRep3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$tc'AlgRep3 = "'AlgRep"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'AlgRep2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tc'AlgRep2 = GHC.Types.TrNameS Data.Data.$tc'AlgRep3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tc'AlgRep :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tc'AlgRep
  = GHC.Types.TyCon
      15126156253141103889##
      6503799265606561977##
      Data.Data.$trModule
      Data.Data.$tc'AlgRep2
      0#
      Data.Data.$tc'AlgRep1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcData3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$tcData3 = "Data"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcData2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$tcData2 = GHC.Types.TrNameS Data.Data.$tcData3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tcData :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Data.$tcData
  = GHC.Types.TyCon
      3328432435743497269##
      3957422409799886810##
      Data.Data.$trModule
      Data.Data.$tcData2
      0#
      Data.Data.$tcData1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl28_rejNg :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl28_rejNg = " is not of type Word64."#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl29_rejNh :: [Char]
[GblId]
lvl29_rejNh = unpackCString# lvl28_rejNg

-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
Data.Data.$wlvl14 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *). String -> c Word64
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
Data.Data.$wlvl14
  = \ (@ (c_sefYZ :: * -> *)) (ww_sefZ4 :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ (c_sefYZ Word64)
        (unpackAppendCString# lvl1_rejM9 (++ @ Char ww_sefZ4 lvl29_rejNh))

-- RHS size: {terms: 17, types: 16, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold26 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r) -> ConstrRep -> String -> c Word64
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 50 0] 100 0}]
Data.Data.$w$cgunfold26
  = \ (@ (c_sefZa :: * -> *))
      (w_sefZc :: forall r. r -> c_sefZa r)
      (ww_sefZg :: ConstrRep)
      (ww1_sefZh :: String) ->
      case ww_sefZg of {
        __DEFAULT -> Data.Data.$wlvl14 @ c_sefZa ww1_sefZh;
        IntConstr x_ae1UA ->
          w_sefZc
            @ Word64
            (case integerToWord x_ae1UA of wild1_iaVJo { __DEFAULT ->
             GHC.Word.W64# wild1_iaVJo
             })
      }

-- RHS size: {terms: 11, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataWord64_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c Word64
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,1*U,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_sefZa :: * -> *))
                 _ [Occ=Dead]
                 (w1_sefZc [Occ=Once] :: forall r. r -> c_sefZa r)
                 (w2_sefZd [Occ=Once!] :: Constr) ->
                 case w2_sefZd of
                 { Constr ww1_sefZg [Occ=Once] ww2_sefZh [Occ=Once] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Data.$w$cgunfold26 @ c_sefZa w1_sefZc ww1_sefZg ww2_sefZh
                 }}]
Data.Data.$fDataWord64_$cgunfold
  = \ (@ (c_sefZa :: * -> *))
      _ [Occ=Dead]
      (w1_sefZc :: forall r. r -> c_sefZa r)
      (w2_sefZd :: Constr) ->
      case w2_sefZd of
      { Constr ww1_sefZg ww2_sefZh ww3_sefZi ww4_sefZj ww5_sefZk ->
      Data.Data.$w$cgunfold26 @ c_sefZa w1_sefZc ww1_sefZg ww2_sefZh
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl30_rejNi :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl30_rejNi = " is not of type Word32."#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl31_rejNj :: [Char]
[GblId]
lvl31_rejNj = unpackCString# lvl30_rejNi

-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
Data.Data.$wlvl13 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *). String -> c Word32
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
Data.Data.$wlvl13
  = \ (@ (c_sefZn :: * -> *)) (ww_sefZs :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ (c_sefZn Word32)
        (unpackAppendCString# lvl1_rejM9 (++ @ Char ww_sefZs lvl31_rejNj))

-- RHS size: {terms: 18, types: 16, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold25 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r) -> ConstrRep -> String -> c Word32
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 50 0] 101 0}]
Data.Data.$w$cgunfold25
  = \ (@ (c_sefZy :: * -> *))
      (w_sefZA :: forall r. r -> c_sefZy r)
      (ww_sefZE :: ConstrRep)
      (ww1_sefZF :: String) ->
      case ww_sefZE of {
        __DEFAULT -> Data.Data.$wlvl13 @ c_sefZy ww1_sefZF;
        IntConstr x_ae1UE ->
          w_sefZA
            @ Word32
            (case integerToWord x_ae1UE of wild1_iaVJo { __DEFAULT ->
             GHC.Word.W32# (narrow32Word# wild1_iaVJo)
             })
      }

-- RHS size: {terms: 11, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataWord32_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c Word32
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,1*U,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_sefZy :: * -> *))
                 _ [Occ=Dead]
                 (w1_sefZA [Occ=Once] :: forall r. r -> c_sefZy r)
                 (w2_sefZB [Occ=Once!] :: Constr) ->
                 case w2_sefZB of
                 { Constr ww1_sefZE [Occ=Once] ww2_sefZF [Occ=Once] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Data.$w$cgunfold25 @ c_sefZy w1_sefZA ww1_sefZE ww2_sefZF
                 }}]
Data.Data.$fDataWord32_$cgunfold
  = \ (@ (c_sefZy :: * -> *))
      _ [Occ=Dead]
      (w1_sefZA :: forall r. r -> c_sefZy r)
      (w2_sefZB :: Constr) ->
      case w2_sefZB of
      { Constr ww1_sefZE ww2_sefZF ww3_sefZG ww4_sefZH ww5_sefZI ->
      Data.Data.$w$cgunfold25 @ c_sefZy w1_sefZA ww1_sefZE ww2_sefZF
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl32_rejNk :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl32_rejNk = " is not of type Word16."#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl33_rejNl :: [Char]
[GblId]
lvl33_rejNl = unpackCString# lvl32_rejNk

-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
Data.Data.$wlvl12 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *). String -> c Word16
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
Data.Data.$wlvl12
  = \ (@ (c_sefZL :: * -> *)) (ww_sefZQ :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ (c_sefZL Word16)
        (unpackAppendCString# lvl1_rejM9 (++ @ Char ww_sefZQ lvl33_rejNl))

-- RHS size: {terms: 18, types: 16, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold24 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r) -> ConstrRep -> String -> c Word16
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 50 0] 101 0}]
Data.Data.$w$cgunfold24
  = \ (@ (c_sefZW :: * -> *))
      (w_sefZY :: forall r. r -> c_sefZW r)
      (ww_seg02 :: ConstrRep)
      (ww1_seg03 :: String) ->
      case ww_seg02 of {
        __DEFAULT -> Data.Data.$wlvl12 @ c_sefZW ww1_seg03;
        IntConstr x_ae1UI ->
          w_sefZY
            @ Word16
            (case integerToWord x_ae1UI of wild1_iaVJo { __DEFAULT ->
             GHC.Word.W16# (narrow16Word# wild1_iaVJo)
             })
      }

-- RHS size: {terms: 11, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataWord16_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c Word16
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,1*U,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_sefZW :: * -> *))
                 _ [Occ=Dead]
                 (w1_sefZY [Occ=Once] :: forall r. r -> c_sefZW r)
                 (w2_sefZZ [Occ=Once!] :: Constr) ->
                 case w2_sefZZ of
                 { Constr ww1_seg02 [Occ=Once] ww2_seg03 [Occ=Once] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Data.$w$cgunfold24 @ c_sefZW w1_sefZY ww1_seg02 ww2_seg03
                 }}]
Data.Data.$fDataWord16_$cgunfold
  = \ (@ (c_sefZW :: * -> *))
      _ [Occ=Dead]
      (w1_sefZY :: forall r. r -> c_sefZW r)
      (w2_sefZZ :: Constr) ->
      case w2_sefZZ of
      { Constr ww1_seg02 ww2_seg03 ww3_seg04 ww4_seg05 ww5_seg06 ->
      Data.Data.$w$cgunfold24 @ c_sefZW w1_sefZY ww1_seg02 ww2_seg03
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl34_rejNm :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl34_rejNm = " is not of type Word8."#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl35_rejNn :: [Char]
[GblId]
lvl35_rejNn = unpackCString# lvl34_rejNm

-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
Data.Data.$wlvl15 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *). String -> c Word8
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
Data.Data.$wlvl15
  = \ (@ (c_seg09 :: * -> *)) (ww_seg0e :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ (c_seg09 Word8)
        (unpackAppendCString# lvl1_rejM9 (++ @ Char ww_seg0e lvl35_rejNn))

-- RHS size: {terms: 18, types: 16, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold27 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r) -> ConstrRep -> String -> c Word8
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 50 0] 101 0}]
Data.Data.$w$cgunfold27
  = \ (@ (c_seg0k :: * -> *))
      (w_seg0m :: forall r. r -> c_seg0k r)
      (ww_seg0q :: ConstrRep)
      (ww1_seg0r :: String) ->
      case ww_seg0q of {
        __DEFAULT -> Data.Data.$wlvl15 @ c_seg0k ww1_seg0r;
        IntConstr x_ae1UM ->
          w_seg0m
            @ Word8
            (case integerToWord x_ae1UM of wild1_iaVJo { __DEFAULT ->
             GHC.Word.W8# (narrow8Word# wild1_iaVJo)
             })
      }

-- RHS size: {terms: 11, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataWord8_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c Word8
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,1*U,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_seg0k :: * -> *))
                 _ [Occ=Dead]
                 (w1_seg0m [Occ=Once] :: forall r. r -> c_seg0k r)
                 (w2_seg0n [Occ=Once!] :: Constr) ->
                 case w2_seg0n of
                 { Constr ww1_seg0q [Occ=Once] ww2_seg0r [Occ=Once] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Data.$w$cgunfold27 @ c_seg0k w1_seg0m ww1_seg0q ww2_seg0r
                 }}]
Data.Data.$fDataWord8_$cgunfold
  = \ (@ (c_seg0k :: * -> *))
      _ [Occ=Dead]
      (w1_seg0m :: forall r. r -> c_seg0k r)
      (w2_seg0n :: Constr) ->
      case w2_seg0n of
      { Constr ww1_seg0q ww2_seg0r ww3_seg0s ww4_seg0t ww5_seg0u ->
      Data.Data.$w$cgunfold27 @ c_seg0k w1_seg0m ww1_seg0q ww2_seg0r
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl36_rejNo :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl36_rejNo = " is not of type Word"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl37_rejNp :: [Char]
[GblId]
lvl37_rejNp = unpackCString# lvl36_rejNo

-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
Data.Data.$wlvl11 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *). String -> c Word
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
Data.Data.$wlvl11
  = \ (@ (c_seg0x :: * -> *)) (ww_seg0C :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ (c_seg0x Word)
        (unpackAppendCString# lvl1_rejM9 (++ @ Char ww_seg0C lvl37_rejNp))

-- RHS size: {terms: 17, types: 16, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold23 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r) -> ConstrRep -> String -> c Word
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 50 0] 100 0}]
Data.Data.$w$cgunfold23
  = \ (@ (c_seg0I :: * -> *))
      (w_seg0K :: forall r. r -> c_seg0I r)
      (ww_seg0O :: ConstrRep)
      (ww1_seg0P :: String) ->
      case ww_seg0O of {
        __DEFAULT -> Data.Data.$wlvl11 @ c_seg0I ww1_seg0P;
        IntConstr x_ae1UQ ->
          w_seg0K
            @ Word
            (case integerToWord x_ae1UQ of wild1_iaVJo { __DEFAULT ->
             GHC.Types.W# wild1_iaVJo
             })
      }

-- RHS size: {terms: 11, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataWord_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c Word
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,1*U,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_seg0I :: * -> *))
                 _ [Occ=Dead]
                 (w1_seg0K [Occ=Once] :: forall r. r -> c_seg0I r)
                 (w2_seg0L [Occ=Once!] :: Constr) ->
                 case w2_seg0L of
                 { Constr ww1_seg0O [Occ=Once] ww2_seg0P [Occ=Once] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Data.$w$cgunfold23 @ c_seg0I w1_seg0K ww1_seg0O ww2_seg0P
                 }}]
Data.Data.$fDataWord_$cgunfold
  = \ (@ (c_seg0I :: * -> *))
      _ [Occ=Dead]
      (w1_seg0K :: forall r. r -> c_seg0I r)
      (w2_seg0L :: Constr) ->
      case w2_seg0L of
      { Constr ww1_seg0O ww2_seg0P ww3_seg0Q ww4_seg0R ww5_seg0S ->
      Data.Data.$w$cgunfold23 @ c_seg0I w1_seg0K ww1_seg0O ww2_seg0P
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl38_rejNq :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl38_rejNq = " is not of type Int64."#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl39_rejNr :: [Char]
[GblId]
lvl39_rejNr = unpackCString# lvl38_rejNq

-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
Data.Data.$wlvl7 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *). String -> c Int64
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
Data.Data.$wlvl7
  = \ (@ (c_seg0V :: * -> *)) (ww_seg10 :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ (c_seg0V Int64)
        (unpackAppendCString# lvl1_rejM9 (++ @ Char ww_seg10 lvl39_rejNr))

-- RHS size: {terms: 17, types: 16, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold15 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r) -> ConstrRep -> String -> c Int64
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 50 0] 100 0}]
Data.Data.$w$cgunfold15
  = \ (@ (c_seg16 :: * -> *))
      (w_seg18 :: forall r. r -> c_seg16 r)
      (ww_seg1c :: ConstrRep)
      (ww1_seg1d :: String) ->
      case ww_seg1c of {
        __DEFAULT -> Data.Data.$wlvl7 @ c_seg16 ww1_seg1d;
        IntConstr x_ae1UU ->
          w_seg18
            @ Int64
            (case integerToInt x_ae1UU of wild1_i7Vf0 { __DEFAULT ->
             GHC.Int.I64# wild1_i7Vf0
             })
      }

-- RHS size: {terms: 11, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataInt64_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c Int64
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,1*U,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_seg16 :: * -> *))
                 _ [Occ=Dead]
                 (w1_seg18 [Occ=Once] :: forall r. r -> c_seg16 r)
                 (w2_seg19 [Occ=Once!] :: Constr) ->
                 case w2_seg19 of
                 { Constr ww1_seg1c [Occ=Once] ww2_seg1d [Occ=Once] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Data.$w$cgunfold15 @ c_seg16 w1_seg18 ww1_seg1c ww2_seg1d
                 }}]
Data.Data.$fDataInt64_$cgunfold
  = \ (@ (c_seg16 :: * -> *))
      _ [Occ=Dead]
      (w1_seg18 :: forall r. r -> c_seg16 r)
      (w2_seg19 :: Constr) ->
      case w2_seg19 of
      { Constr ww1_seg1c ww2_seg1d ww3_seg1e ww4_seg1f ww5_seg1g ->
      Data.Data.$w$cgunfold15 @ c_seg16 w1_seg18 ww1_seg1c ww2_seg1d
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl40_rejNs :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl40_rejNs = " is not of type Int32."#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl41_rejNt :: [Char]
[GblId]
lvl41_rejNt = unpackCString# lvl40_rejNs

-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
Data.Data.$wlvl6 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *). String -> c Int32
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
Data.Data.$wlvl6
  = \ (@ (c_seg1j :: * -> *)) (ww_seg1o :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ (c_seg1j Int32)
        (unpackAppendCString# lvl1_rejM9 (++ @ Char ww_seg1o lvl41_rejNt))

-- RHS size: {terms: 18, types: 16, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold14 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r) -> ConstrRep -> String -> c Int32
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 50 0] 101 0}]
Data.Data.$w$cgunfold14
  = \ (@ (c_seg1u :: * -> *))
      (w_seg1w :: forall r. r -> c_seg1u r)
      (ww_seg1A :: ConstrRep)
      (ww1_seg1B :: String) ->
      case ww_seg1A of {
        __DEFAULT -> Data.Data.$wlvl6 @ c_seg1u ww1_seg1B;
        IntConstr x_ae1UY ->
          w_seg1w
            @ Int32
            (case integerToInt x_ae1UY of wild1_i7Vf0 { __DEFAULT ->
             GHC.Int.I32# (narrow32Int# wild1_i7Vf0)
             })
      }

-- RHS size: {terms: 11, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataInt32_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c Int32
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,1*U,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_seg1u :: * -> *))
                 _ [Occ=Dead]
                 (w1_seg1w [Occ=Once] :: forall r. r -> c_seg1u r)
                 (w2_seg1x [Occ=Once!] :: Constr) ->
                 case w2_seg1x of
                 { Constr ww1_seg1A [Occ=Once] ww2_seg1B [Occ=Once] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Data.$w$cgunfold14 @ c_seg1u w1_seg1w ww1_seg1A ww2_seg1B
                 }}]
Data.Data.$fDataInt32_$cgunfold
  = \ (@ (c_seg1u :: * -> *))
      _ [Occ=Dead]
      (w1_seg1w :: forall r. r -> c_seg1u r)
      (w2_seg1x :: Constr) ->
      case w2_seg1x of
      { Constr ww1_seg1A ww2_seg1B ww3_seg1C ww4_seg1D ww5_seg1E ->
      Data.Data.$w$cgunfold14 @ c_seg1u w1_seg1w ww1_seg1A ww2_seg1B
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl42_rejNu :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl42_rejNu = " is not of type Int16."#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl43_rejNv :: [Char]
[GblId]
lvl43_rejNv = unpackCString# lvl42_rejNu

-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
Data.Data.$wlvl5 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *). String -> c Int16
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
Data.Data.$wlvl5
  = \ (@ (c_seg1H :: * -> *)) (ww_seg1M :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ (c_seg1H Int16)
        (unpackAppendCString# lvl1_rejM9 (++ @ Char ww_seg1M lvl43_rejNv))

-- RHS size: {terms: 18, types: 16, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold13 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r) -> ConstrRep -> String -> c Int16
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 50 0] 101 0}]
Data.Data.$w$cgunfold13
  = \ (@ (c_seg1S :: * -> *))
      (w_seg1U :: forall r. r -> c_seg1S r)
      (ww_seg1Y :: ConstrRep)
      (ww1_seg1Z :: String) ->
      case ww_seg1Y of {
        __DEFAULT -> Data.Data.$wlvl5 @ c_seg1S ww1_seg1Z;
        IntConstr x_ae1V2 ->
          w_seg1U
            @ Int16
            (case integerToInt x_ae1V2 of wild1_i7Vf0 { __DEFAULT ->
             GHC.Int.I16# (narrow16Int# wild1_i7Vf0)
             })
      }

-- RHS size: {terms: 11, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataInt16_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c Int16
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,1*U,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_seg1S :: * -> *))
                 _ [Occ=Dead]
                 (w1_seg1U [Occ=Once] :: forall r. r -> c_seg1S r)
                 (w2_seg1V [Occ=Once!] :: Constr) ->
                 case w2_seg1V of
                 { Constr ww1_seg1Y [Occ=Once] ww2_seg1Z [Occ=Once] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Data.$w$cgunfold13 @ c_seg1S w1_seg1U ww1_seg1Y ww2_seg1Z
                 }}]
Data.Data.$fDataInt16_$cgunfold
  = \ (@ (c_seg1S :: * -> *))
      _ [Occ=Dead]
      (w1_seg1U :: forall r. r -> c_seg1S r)
      (w2_seg1V :: Constr) ->
      case w2_seg1V of
      { Constr ww1_seg1Y ww2_seg1Z ww3_seg20 ww4_seg21 ww5_seg22 ->
      Data.Data.$w$cgunfold13 @ c_seg1S w1_seg1U ww1_seg1Y ww2_seg1Z
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl44_rejNw :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl44_rejNw = " is not of type Int8."#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl46_rejNx :: [Char]
[GblId]
lvl46_rejNx = unpackCString# lvl44_rejNw

-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
Data.Data.$wlvl8 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *). String -> c Int8
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
Data.Data.$wlvl8
  = \ (@ (c_seg25 :: * -> *)) (ww_seg2a :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ (c_seg25 Int8)
        (unpackAppendCString# lvl1_rejM9 (++ @ Char ww_seg2a lvl46_rejNx))

-- RHS size: {terms: 18, types: 16, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold16 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r) -> ConstrRep -> String -> c Int8
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 50 0] 101 0}]
Data.Data.$w$cgunfold16
  = \ (@ (c_seg2g :: * -> *))
      (w_seg2i :: forall r. r -> c_seg2g r)
      (ww_seg2m :: ConstrRep)
      (ww1_seg2n :: String) ->
      case ww_seg2m of {
        __DEFAULT -> Data.Data.$wlvl8 @ c_seg2g ww1_seg2n;
        IntConstr x_ae1V6 ->
          w_seg2i
            @ Int8
            (case integerToInt x_ae1V6 of wild1_i7Vf0 { __DEFAULT ->
             GHC.Int.I8# (narrow8Int# wild1_i7Vf0)
             })
      }

-- RHS size: {terms: 11, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataInt8_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c Int8
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,1*U,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_seg2g :: * -> *))
                 _ [Occ=Dead]
                 (w1_seg2i [Occ=Once] :: forall r. r -> c_seg2g r)
                 (w2_seg2j [Occ=Once!] :: Constr) ->
                 case w2_seg2j of
                 { Constr ww1_seg2m [Occ=Once] ww2_seg2n [Occ=Once] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Data.$w$cgunfold16 @ c_seg2g w1_seg2i ww1_seg2m ww2_seg2n
                 }}]
Data.Data.$fDataInt8_$cgunfold
  = \ (@ (c_seg2g :: * -> *))
      _ [Occ=Dead]
      (w1_seg2i :: forall r. r -> c_seg2g r)
      (w2_seg2j :: Constr) ->
      case w2_seg2j of
      { Constr ww1_seg2m ww2_seg2n ww3_seg2o ww4_seg2p ww5_seg2q ->
      Data.Data.$w$cgunfold16 @ c_seg2g w1_seg2i ww1_seg2m ww2_seg2n
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl47_rejNy :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl47_rejNy = " is not of type Natural"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl48_rejNz :: [Char]
[GblId]
lvl48_rejNz = unpackCString# lvl47_rejNy

-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
Data.Data.$wlvl10 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *). String -> c Natural
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
Data.Data.$wlvl10
  = \ (@ (c_seg2t :: * -> *)) (ww_seg2y :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ (c_seg2t Natural)
        (unpackAppendCString# lvl1_rejM9 (++ @ Char ww_seg2y lvl48_rejNz))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataNatural4 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Data.Data.$fDataNatural4 = 0

-- RHS size: {terms: 19, types: 17, coercions: 2, joins: 0/0}
Data.Data.$w$cgunfold17 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r) -> ConstrRep -> String -> c Natural
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 50 0] 110 0}]
Data.Data.$w$cgunfold17
  = \ (@ (c_seg2E :: * -> *))
      (w_seg2G :: forall r. r -> c_seg2E r)
      (ww_seg2K :: ConstrRep)
      (ww1_seg2L :: String) ->
      case ww_seg2K of {
        __DEFAULT -> Data.Data.$wlvl10 @ c_seg2E ww1_seg2L;
        IntConstr x_ae1Va ->
          w_seg2G
            @ Natural
            (case geInteger# x_ae1Va Data.Data.$fDataNatural4 of {
               __DEFAULT -> GHC.Natural.underflowError @ Natural;
               1# ->
                 x_ae1Va
                 `cast` (Sym (GHC.Natural.N:Natural[0])
                         :: (Integer :: *) ~R# (Natural :: *))
             })
      }

-- RHS size: {terms: 11, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataNatural_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c Natural
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,1*U,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_seg2E :: * -> *))
                 _ [Occ=Dead]
                 (w1_seg2G [Occ=Once] :: forall r. r -> c_seg2E r)
                 (w2_seg2H [Occ=Once!] :: Constr) ->
                 case w2_seg2H of
                 { Constr ww1_seg2K [Occ=Once] ww2_seg2L [Occ=Once] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Data.$w$cgunfold17 @ c_seg2E w1_seg2G ww1_seg2K ww2_seg2L
                 }}]
Data.Data.$fDataNatural_$cgunfold
  = \ (@ (c_seg2E :: * -> *))
      _ [Occ=Dead]
      (w1_seg2G :: forall r. r -> c_seg2E r)
      (w2_seg2H :: Constr) ->
      case w2_seg2H of
      { Constr ww1_seg2K ww2_seg2L ww3_seg2M ww4_seg2N ww5_seg2O ->
      Data.Data.$w$cgunfold17 @ c_seg2E w1_seg2G ww1_seg2K ww2_seg2L
      }

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataInteger_$ctoConstr :: Integer -> Constr
[GblId,
 Arity=1,
 Str=<L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (i_ae1WB :: Integer) ->
                 Data.Data.Constr
                   (Data.Data.IntConstr i_ae1WB)
                   (GHC.Show.$fShowInteger_$cshow i_ae1WB)
                   Data.Data.$fDataChar5
                   Data.Data.$fDataChar4
                   integerType}]
Data.Data.$fDataInteger_$ctoConstr
  = \ (i_ae1WB :: Integer) ->
      Data.Data.Constr
        (Data.Data.IntConstr i_ae1WB)
        (GHC.Show.$fShowInteger_$cshow i_ae1WB)
        Data.Data.$fDataChar5
        Data.Data.$fDataChar4
        integerType

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl49_rejNA :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl49_rejNA = " is not of type Double."#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl50_rejNB :: [Char]
[GblId]
lvl50_rejNB = unpackCString# lvl49_rejNA

-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
Data.Data.$wlvl3 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *). String -> c Double
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
Data.Data.$wlvl3
  = \ (@ (c_seg2R :: * -> *)) (ww_seg2W :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ (c_seg2R Double)
        (unpackAppendCString# lvl1_rejM9 (++ @ Char ww_seg2W lvl50_rejNB))

-- RHS size: {terms: 17, types: 19, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold8 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r) -> ConstrRep -> String -> c Double
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 50 0] 100 0}]
Data.Data.$w$cgunfold8
  = \ (@ (c_seg32 :: * -> *))
      (w_seg34 :: forall r. r -> c_seg32 r)
      (ww_seg38 :: ConstrRep)
      (ww1_seg39 :: String) ->
      case ww_seg38 of {
        __DEFAULT -> Data.Data.$wlvl3 @ c_seg32 ww1_seg39;
        FloatConstr x_ae1Vk ->
          w_seg34
            @ Double
            (case x_ae1Vk of { :% x1_icBNb y_icBNc ->
             GHC.Float.rationalToDouble x1_icBNb y_icBNc
             })
      }

-- RHS size: {terms: 11, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataDouble_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c Double
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,1*U,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_seg32 :: * -> *))
                 _ [Occ=Dead]
                 (w1_seg34 [Occ=Once] :: forall r. r -> c_seg32 r)
                 (w2_seg35 [Occ=Once!] :: Constr) ->
                 case w2_seg35 of
                 { Constr ww1_seg38 [Occ=Once] ww2_seg39 [Occ=Once] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Data.$w$cgunfold8 @ c_seg32 w1_seg34 ww1_seg38 ww2_seg39
                 }}]
Data.Data.$fDataDouble_$cgunfold
  = \ (@ (c_seg32 :: * -> *))
      _ [Occ=Dead]
      (w1_seg34 :: forall r. r -> c_seg32 r)
      (w2_seg35 :: Constr) ->
      case w2_seg35 of
      { Constr ww1_seg38 ww2_seg39 ww3_seg3a ww4_seg3b ww5_seg3c ->
      Data.Data.$w$cgunfold8 @ c_seg32 w1_seg34 ww1_seg38 ww2_seg39
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl51_rejNC :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl51_rejNC = " is not of type Float."#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl52_rejND :: [Char]
[GblId]
lvl52_rejND = unpackCString# lvl51_rejNC

-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
Data.Data.$wlvl4 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *). String -> c Float
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
Data.Data.$wlvl4
  = \ (@ (c_seg3f :: * -> *)) (ww_seg3k :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ (c_seg3f Float)
        (unpackAppendCString# lvl1_rejM9 (++ @ Char ww_seg3k lvl52_rejND))

-- RHS size: {terms: 17, types: 19, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold12 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r) -> ConstrRep -> String -> c Float
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 50 0] 100 0}]
Data.Data.$w$cgunfold12
  = \ (@ (c_seg3q :: * -> *))
      (w_seg3s :: forall r. r -> c_seg3q r)
      (ww_seg3w :: ConstrRep)
      (ww1_seg3x :: String) ->
      case ww_seg3w of {
        __DEFAULT -> Data.Data.$wlvl4 @ c_seg3q ww1_seg3x;
        FloatConstr x_ae1Vn ->
          w_seg3s
            @ Float
            (case x_ae1Vn of { :% x1_icBNb y_icBNc ->
             GHC.Float.rationalToFloat x1_icBNb y_icBNc
             })
      }

-- RHS size: {terms: 11, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataFloat_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c Float
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,1*U,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_seg3q :: * -> *))
                 _ [Occ=Dead]
                 (w1_seg3s [Occ=Once] :: forall r. r -> c_seg3q r)
                 (w2_seg3t [Occ=Once!] :: Constr) ->
                 case w2_seg3t of
                 { Constr ww1_seg3w [Occ=Once] ww2_seg3x [Occ=Once] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Data.$w$cgunfold12 @ c_seg3q w1_seg3s ww1_seg3w ww2_seg3x
                 }}]
Data.Data.$fDataFloat_$cgunfold
  = \ (@ (c_seg3q :: * -> *))
      _ [Occ=Dead]
      (w1_seg3s :: forall r. r -> c_seg3q r)
      (w2_seg3t :: Constr) ->
      case w2_seg3t of
      { Constr ww1_seg3w ww2_seg3x ww3_seg3y ww4_seg3z ww5_seg3A ->
      Data.Data.$w$cgunfold12 @ c_seg3q w1_seg3s ww1_seg3w ww2_seg3x
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fShowConstrRep5 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Data.$fShowConstrRep5 = "AlgConstr "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fShowConstrRep4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Data.$fShowConstrRep4 = "IntConstr "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fShowConstrRep3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Data.$fShowConstrRep3 = "FloatConstr "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fShowConstrRep2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Data.$fShowConstrRep2 = "CharConstr "#

-- RHS size: {terms: 145, types: 96, coercions: 0, joins: 0/0}
Data.Data.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: Int# -> ConstrRep -> String -> String
[GblId, Arity=3, Str=<S,U><S,1*U><L,U>, Unf=OtherCon []]
Data.Data.$w$cshowsPrec
  = \ (ww_seg3I :: Int#)
      (w_seg3E :: ConstrRep)
      (w1_seg3F :: String) ->
      case w_seg3E of {
        AlgConstr b1_ae2ra ->
          case >=# ww_seg3I 11# of {
            __DEFAULT ->
              unpackAppendCString#
                Data.Data.$fShowConstrRep5
                (case b1_ae2ra of { I# ww3_i7NVa ->
                 case GHC.Show.$wshowSignedInt 11# ww3_i7NVa w1_seg3F of
                 { (# ww5_i7NVe, ww6_i7NVf #) ->
                 GHC.Types.: @ Char ww5_i7NVe ww6_i7NVf
                 }
                 });
            1# ->
              GHC.Types.:
                @ Char
                GHC.Show.$fShow(,)4
                (unpackAppendCString#
                   Data.Data.$fShowConstrRep5
                   (case b1_ae2ra of { I# ww3_i7NVa ->
                    case GHC.Show.$wshowSignedInt
                           11# ww3_i7NVa (GHC.Types.: @ Char GHC.Show.$fShow(,)2 w1_seg3F)
                    of
                    { (# ww5_i7NVe, ww6_i7NVf #) ->
                    GHC.Types.: @ Char ww5_i7NVe ww6_i7NVf
                    }
                    }))
          };
        IntConstr b1_ae2rc ->
          case >=# ww_seg3I 11# of {
            __DEFAULT ->
              unpackAppendCString#
                Data.Data.$fShowConstrRep4
                (case GHC.Show.$w$cshowsPrec4 11# b1_ae2rc w1_seg3F of
                 { (# ww3_ibkxp, ww4_ibkxq #) ->
                 GHC.Types.: @ Char ww3_ibkxp ww4_ibkxq
                 });
            1# ->
              GHC.Types.:
                @ Char
                GHC.Show.$fShow(,)4
                (unpackAppendCString#
                   Data.Data.$fShowConstrRep4
                   (case GHC.Show.$w$cshowsPrec4
                           11# b1_ae2rc (GHC.Types.: @ Char GHC.Show.$fShow(,)2 w1_seg3F)
                    of
                    { (# ww3_ibkxp, ww4_ibkxq #) ->
                    GHC.Types.: @ Char ww3_ibkxp ww4_ibkxq
                    }))
          };
        FloatConstr b1_ae2re ->
          case >=# ww_seg3I 11# of {
            __DEFAULT ->
              unpackAppendCString#
                Data.Data.$fShowConstrRep3
                (case b1_ae2re of { :% ww3_ie82Z ww4_ie830 ->
                 case GHC.Real.$w$s$cshowsPrec 11# ww3_ie82Z ww4_ie830 w1_seg3F of
                 { (# ww6_ie834, ww7_ie835 #) ->
                 GHC.Types.: @ Char ww6_ie834 ww7_ie835
                 }
                 });
            1# ->
              GHC.Types.:
                @ Char
                GHC.Show.$fShow(,)4
                (unpackAppendCString#
                   Data.Data.$fShowConstrRep3
                   (case b1_ae2re of { :% ww3_ie82Z ww4_ie830 ->
                    case GHC.Real.$w$s$cshowsPrec
                           11#
                           ww3_ie82Z
                           ww4_ie830
                           (GHC.Types.: @ Char GHC.Show.$fShow(,)2 w1_seg3F)
                    of
                    { (# ww6_ie834, ww7_ie835 #) ->
                    GHC.Types.: @ Char ww6_ie834 ww7_ie835
                    }
                    }))
          };
        CharConstr b1_ae2rg ->
          case >=# ww_seg3I 11# of {
            __DEFAULT ->
              unpackAppendCString#
                Data.Data.$fShowConstrRep2
                (case b1_ae2rg of { C# ww2_ie83g ->
                 GHC.Show.$w$cshowsPrec3 ww2_ie83g w1_seg3F
                 });
            1# ->
              GHC.Types.:
                @ Char
                GHC.Show.$fShow(,)4
                (unpackAppendCString#
                   Data.Data.$fShowConstrRep2
                   (case b1_ae2rg of { C# ww2_ie83g ->
                    GHC.Show.$w$cshowsPrec3
                      ww2_ie83g (GHC.Types.: @ Char GHC.Show.$fShow(,)2 w1_seg3F)
                    }))
          }
      }

-- RHS size: {terms: 10, types: 5, coercions: 0, joins: 0/0}
Data.Data.$fShowConstrRep_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: Int -> ConstrRep -> ShowS
[GblId,
 Arity=3,
 Str=<S(S),1*U(U)><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_seg3D [Occ=Once!] :: Int)
                 (w1_seg3E [Occ=Once] :: ConstrRep)
                 (w2_seg3F [Occ=Once] :: String) ->
                 case w_seg3D of { I# ww1_seg3I [Occ=Once] ->
                 Data.Data.$w$cshowsPrec ww1_seg3I w1_seg3E w2_seg3F
                 }}]
Data.Data.$fShowConstrRep_$cshowsPrec
  = \ (w_seg3D :: Int)
      (w1_seg3E :: ConstrRep)
      (w2_seg3F :: String) ->
      case w_seg3D of { I# ww1_seg3I ->
      Data.Data.$w$cshowsPrec ww1_seg3I w1_seg3E w2_seg3F
      }

-- RHS size: {terms: 55, types: 48, coercions: 0, joins: 0/0}
Data.Data.$fShowConstrRep_$cshow :: ConstrRep -> String
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [310] 410 0}]
Data.Data.$fShowConstrRep_$cshow
  = \ (x_i7Jay :: ConstrRep) ->
      case x_i7Jay of {
        AlgConstr b1_ae2ra ->
          unpackAppendCString#
            Data.Data.$fShowConstrRep5
            (case b1_ae2ra of { I# ww3_i7NVa ->
             case GHC.Show.$wshowSignedInt 11# ww3_i7NVa (GHC.Types.[] @ Char)
             of
             { (# ww5_i7NVe, ww6_i7NVf #) ->
             GHC.Types.: @ Char ww5_i7NVe ww6_i7NVf
             }
             });
        IntConstr b1_ae2rc ->
          unpackAppendCString#
            Data.Data.$fShowConstrRep4
            (case GHC.Show.$w$cshowsPrec4 11# b1_ae2rc (GHC.Types.[] @ Char) of
             { (# ww3_ibkxp, ww4_ibkxq #) ->
             GHC.Types.: @ Char ww3_ibkxp ww4_ibkxq
             });
        FloatConstr b1_ae2re ->
          unpackAppendCString#
            Data.Data.$fShowConstrRep3
            (case b1_ae2re of { :% ww3_ie82Z ww4_ie830 ->
             case GHC.Real.$w$s$cshowsPrec
                    11# ww3_ie82Z ww4_ie830 (GHC.Types.[] @ Char)
             of
             { (# ww6_ie834, ww7_ie835 #) ->
             GHC.Types.: @ Char ww6_ie834 ww7_ie835
             }
             });
        CharConstr b1_ae2rg ->
          unpackAppendCString#
            Data.Data.$fShowConstrRep2
            (case b1_ae2rg of { C# ww1_ie83g ->
             GHC.Show.$w$cshowsPrec3 ww1_ie83g (GHC.Types.[] @ Char)
             })
      }

-- RHS size: {terms: 6, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fShowConstrRep1 :: ConstrRep -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 40 0}]
Data.Data.$fShowConstrRep1
  = \ (w_seg3E :: ConstrRep) (w1_seg3F :: String) ->
      Data.Data.$w$cshowsPrec 0# w_seg3E w1_seg3F

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
Data.Data.$fShowConstrRep_$cshowList :: [ConstrRep] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [ConstrRep])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__
                   @ ConstrRep Data.Data.$fShowConstrRep1 ls_i7JaB s_i7JaC}]
Data.Data.$fShowConstrRep_$cshowList
  = \ (ls_i7JaB :: [ConstrRep]) (s_i7JaC :: String) ->
      showList__ @ ConstrRep Data.Data.$fShowConstrRep1 ls_i7JaB s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fShowConstrRep [InlPrag=NOUSERINLINE CONLIKE]
  :: Show ConstrRep
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: ConstrRep
                       Data.Data.$fShowConstrRep_$cshowsPrec
                       Data.Data.$fShowConstrRep_$cshow
                       Data.Data.$fShowConstrRep_$cshowList]
Data.Data.$fShowConstrRep
  = GHC.Show.C:Show
      @ ConstrRep
      Data.Data.$fShowConstrRep_$cshowsPrec
      Data.Data.$fShowConstrRep_$cshow
      Data.Data.$fShowConstrRep_$cshowList

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fShowDataType5 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Data.$fShowDataType5 = "DataType {"#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fShowDataType4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fShowDataType4 = "tycon = "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fShowDataType3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Data.$fShowDataType3 = "datarep = "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fShowDataType2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fShowDataType2 = "}"#

-- RHS size: {terms: 54, types: 13, coercions: 0, joins: 0/0}
Data.Data.$w$cshowsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: Int# -> String -> DataRep -> String -> String
[GblId,
 Arity=4,
 Str=<S,U><L,1*U><L,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0 0] 521 30}]
Data.Data.$w$cshowsPrec1
  = \ (ww_seg3R :: Int#)
      (ww1_seg3V :: String)
      (ww2_seg3W :: DataRep)
      (w_seg3O :: String) ->
      case >=# ww_seg3R 11# of {
        __DEFAULT ->
          unpackAppendCString#
            Data.Data.$fShowDataType5
            (unpackAppendCString#
               Data.Data.$fShowDataType4
               (GHC.Types.:
                  @ Char
                  GHC.Show.$fShow(,)3
                  (showLitString
                     ww1_seg3V
                     (GHC.Types.:
                        @ Char
                        GHC.Show.$fShow(,)3
                        (++
                           @ Char
                           GHC.Show.showCommaSpace1
                           (unpackAppendCString#
                              Data.Data.$fShowDataType3
                              (Data.Data.$fShowDataRep_$cshowsPrec
                                 Data.Data.$fData:.:3
                                 ww2_seg3W
                                 (unpackAppendCString# Data.Data.$fShowDataType2 w_seg3O))))))));
        1# ->
          GHC.Types.:
            @ Char
            GHC.Show.$fShow(,)4
            (unpackAppendCString#
               Data.Data.$fShowDataType5
               (unpackAppendCString#
                  Data.Data.$fShowDataType4
                  (GHC.Types.:
                     @ Char
                     GHC.Show.$fShow(,)3
                     (showLitString
                        ww1_seg3V
                        (GHC.Types.:
                           @ Char
                           GHC.Show.$fShow(,)3
                           (++
                              @ Char
                              GHC.Show.showCommaSpace1
                              (unpackAppendCString#
                                 Data.Data.$fShowDataType3
                                 (Data.Data.$fShowDataRep_$cshowsPrec
                                    Data.Data.$fData:.:3
                                    ww2_seg3W
                                    (unpackAppendCString#
                                       Data.Data.$fShowDataType2
                                       (GHC.Types.: @ Char GHC.Show.$fShow(,)2 w_seg3O))))))))))
      }

-- RHS size: {terms: 14, types: 8, coercions: 0, joins: 0/0}
Data.Data.$fShowDataType_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: Int -> DataType -> ShowS
[GblId,
 Arity=3,
 Str=<S(S),1*U(U)><S,1*U(1*U,1*U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_seg3M [Occ=Once!] :: Int)
                 (w1_seg3N [Occ=Once!] :: DataType)
                 (w2_seg3O [Occ=Once] :: String) ->
                 case w_seg3M of { I# ww1_seg3R [Occ=Once] ->
                 case w1_seg3N of
                 { DataType ww3_seg3V [Occ=Once] ww4_seg3W [Occ=Once] ->
                 Data.Data.$w$cshowsPrec1 ww1_seg3R ww3_seg3V ww4_seg3W w2_seg3O
                 }
                 }}]
Data.Data.$fShowDataType_$cshowsPrec
  = \ (w_seg3M :: Int) (w1_seg3N :: DataType) (w2_seg3O :: String) ->
      case w_seg3M of { I# ww1_seg3R ->
      case w1_seg3N of { DataType ww3_seg3V ww4_seg3W ->
      Data.Data.$w$cshowsPrec1 ww1_seg3R ww3_seg3V ww4_seg3W w2_seg3O
      }
      }

-- RHS size: {terms: 9, types: 5, coercions: 0, joins: 0/0}
Data.Data.$fShowDataType_$cshow :: DataType -> String
[GblId,
 Arity=1,
 Str=<S,1*U(1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i7Jay [Occ=Once] :: DataType) ->
                 Data.Data.$fShowDataType_$cshowsPrec
                   Data.Data.$fData:.:3 x_i7Jay (GHC.Types.[] @ Char)}]
Data.Data.$fShowDataType_$cshow
  = \ (x_i7Jay :: DataType) ->
      case x_i7Jay of { DataType ww1_seg3V ww2_seg3W ->
      Data.Data.$w$cshowsPrec1
        0# ww1_seg3V ww2_seg3W (GHC.Types.[] @ Char)
      }

-- RHS size: {terms: 10, types: 5, coercions: 0, joins: 0/0}
Data.Data.$fShowDataType1 :: DataType -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U(1*U,1*U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20 0] 60 0}]
Data.Data.$fShowDataType1
  = \ (w_seg3N :: DataType) (w1_seg3O :: String) ->
      case w_seg3N of { DataType ww1_seg3V ww2_seg3W ->
      Data.Data.$w$cshowsPrec1 0# ww1_seg3V ww2_seg3W w1_seg3O
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
Data.Data.$fShowDataType_$cshowList :: [DataType] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [DataType])
                 (s_i7JaC [Occ=Once] :: String) ->
                 showList__ @ DataType Data.Data.$fShowDataType1 ls_i7JaB s_i7JaC}]
Data.Data.$fShowDataType_$cshowList
  = \ (ls_i7JaB :: [DataType]) (s_i7JaC :: String) ->
      showList__ @ DataType Data.Data.$fShowDataType1 ls_i7JaB s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fShowDataType [InlPrag=NOUSERINLINE CONLIKE]
  :: Show DataType
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: DataType
                       Data.Data.$fShowDataType_$cshowsPrec
                       Data.Data.$fShowDataType_$cshow
                       Data.Data.$fShowDataType_$cshowList]
Data.Data.$fShowDataType
  = GHC.Show.C:Show
      @ DataType
      Data.Data.$fShowDataType_$cshowsPrec
      Data.Data.$fShowDataType_$cshow
      Data.Data.$fShowDataType_$cshowList

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
lvl53_rejNE :: forall g u. Qi u g
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl53_rejNE
  = \ (@ g_ae2UE) (@ u_ae2Tj) ->
      Data.Data.Qi
        @ *
        @ u_ae2Tj
        @ g_ae2UE
        Data.Data.$fData:.:3
        (GHC.Base.Nothing @ u_ae2Tj)

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
lvl54_rejNF :: forall u g. g -> Qi u g
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []]
lvl54_rejNF
  = \ (@ u_ae2Tj) (@ g_ae2UE) _ [Occ=Dead] ->
      lvl53_rejNE @ g_ae2UE @ u_ae2Tj

-- RHS size: {terms: 47, types: 64, coercions: 0, joins: 0/0}
Data.Data.$dmgmapQi
  :: forall a.
     Data a =>
     forall u. Int -> (forall d. Data d => d -> u) -> a -> u
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U)><L,C(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe2nC)
                 ($dData_Xe3kI [Occ=Once] :: Data a_Xe2nC)
                 (@ u_ae2Tj)
                 (i_ae1T5 [Occ=OnceL] :: Int)
                 (f_ae1T6 [Occ=OnceL!] :: forall d. Data d => d -> u_ae2Tj)
                 (x_ae1T7 [Occ=Once] :: a_Xe2nC) ->
                 case gfoldl
                        @ a_Xe2nC
                        $dData_Xe3kI
                        @ (Qi u_ae2Tj)
                        (\ (@ d_ae2U4)
                           (@ b_ae2U5)
                           ($dData1_ae2U7 [Occ=Once] :: Data d_ae2U4)
                           (ds_de7nG [Occ=Once!] :: Qi u_ae2Tj (d_ae2U4 -> b_ae2U5))
                           (a1_ae1Tg [Occ=Once] :: d_ae2U4) ->
                           case ds_de7nG of { Qi i'_ae1Te q_ae1Tf [Occ=Once] ->
                           Data.Data.Qi
                             @ *
                             @ u_ae2Tj
                             @ b_ae2U5
                             (case i'_ae1Te of { I# x1_i7MX1 [Occ=Once] ->
                              GHC.Types.I# (+# x1_i7MX1 1#)
                              })
                             (case eqInt i_ae1T5 i'_ae1Te of {
                                False -> q_ae1Tf;
                                True ->
                                  GHC.Base.Just @ u_ae2Tj (f_ae1T6 @ d_ae2U4 $dData1_ae2U7 a1_ae1Tg)
                              })
                           })
                        (\ (@ g_ae2UE) _ [Occ=Dead] ->
                           Data.Data.Qi
                             @ *
                             @ u_ae2Tj
                             @ g_ae2UE
                             (GHC.Types.I# 0#)
                             (GHC.Base.Nothing @ u_ae2Tj))
                        x_ae1T7
                 of
                 { Qi _ [Occ=Dead] q_ae1Th [Occ=Once] ->
                 fromJust @ u_ae2Tj q_ae1Th
                 }}]
Data.Data.$dmgmapQi
  = \ (@ a_Xe2nC)
      ($dData_Xe3kI :: Data a_Xe2nC)
      (@ u_ae2Tj)
      (i_ae1T5 :: Int)
      (f_ae1T6 :: forall d. Data d => d -> u_ae2Tj)
      (x_ae1T7 :: a_Xe2nC) ->
      case gfoldl
             @ a_Xe2nC
             $dData_Xe3kI
             @ (Qi u_ae2Tj)
             (\ (@ d_ae2U4)
                (@ b_ae2U5)
                ($dData1_ae2U7 :: Data d_ae2U4)
                (ds_de7nG :: Qi u_ae2Tj (d_ae2U4 -> b_ae2U5))
                (a1_ae1Tg :: d_ae2U4) ->
                case ds_de7nG of { Qi i'_ae1Te q_ae1Tf ->
                Data.Data.Qi
                  @ *
                  @ u_ae2Tj
                  @ b_ae2U5
                  (case i'_ae1Te of { I# x1_i7MX1 -> GHC.Types.I# (+# x1_i7MX1 1#) })
                  (case i_ae1T5 of { I# x1_a22G ->
                   case i'_ae1Te of { I# y_a22K ->
                   case ==# x1_a22G y_a22K of {
                     __DEFAULT -> q_ae1Tf;
                     1# ->
                       GHC.Base.Just @ u_ae2Tj (f_ae1T6 @ d_ae2U4 $dData1_ae2U7 a1_ae1Tg)
                   }
                   }
                   })
                })
             (lvl54_rejNF @ u_ae2Tj)
             x_ae1T7
      of
      { Qi ds_de7nD q_ae1Th ->
      fromJust @ u_ae2Tj q_ae1Th
      }

-- RHS size: {terms: 26, types: 63, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp33 [InlPrag=NOUSERINLINE[0]]
  :: forall p (m :: * -> *). MonadPlus m => V1 p -> m (V1 p)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 170 0}]
Data.Data.$w$cgmapMp33
  = \ (@ p_seg3Z)
      (@ (m_seg41 :: * -> *))
      (w_seg42 :: MonadPlus m_seg41)
      (w1_seg44 :: V1 p_seg3Z) ->
      let {
        lvl270_se9EO :: m_seg41 (V1 p_seg3Z)
        [LclId]
        lvl270_se9EO = mzero @ m_seg41 w_seg42 @ (V1 p_seg3Z) } in
      let {
        $dMonad_se9uP [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg41
        [LclId]
        $dMonad_se9uP = GHC.Base.$p2MonadPlus @ m_seg41 w_seg42 } in
      >>=
        @ m_seg41
        $dMonad_se9uP
        @ (V1 p_seg3Z, Bool)
        @ (V1 p_seg3Z)
        (case w1_seg44 of { })
        (\ (ds_de7oa :: (V1 p_seg3Z, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9EO;
             True -> return @ m_seg41 $dMonad_se9uP @ (V1 p_seg3Z) x'_ae1TD
           }
           })

-- RHS size: {terms: 9, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataV1_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall p.
     Data p =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> V1 p -> m (V1 p)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ p_seg3Z)
                 _ [Occ=Dead]
                 (@ (m_seg41 :: * -> *))
                 (w1_seg42 [Occ=Once] :: MonadPlus m_seg41)
                 _ [Occ=Dead]
                 (w3_seg44 [Occ=Once] :: V1 p_seg3Z) ->
                 Data.Data.$w$cgmapMp33 @ p_seg3Z @ m_seg41 w1_seg42 w3_seg44}]
Data.Data.$fDataV1_$cgmapMp
  = \ (@ p_seg3Z)
      _ [Occ=Dead]
      (@ (m_seg41 :: * -> *))
      (w1_seg42 :: MonadPlus m_seg41)
      _ [Occ=Dead]
      (w3_seg44 :: V1 p_seg3Z) ->
      Data.Data.$w$cgmapMp33 @ p_seg3Z @ m_seg41 w1_seg42 w3_seg44

-- RHS size: {terms: 26, types: 63, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo32 [InlPrag=NOUSERINLINE[0]]
  :: forall p (m :: * -> *). MonadPlus m => V1 p -> m (V1 p)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 170 0}]
Data.Data.$w$cgmapMo32
  = \ (@ p_seg46)
      (@ (m_seg48 :: * -> *))
      (w_seg49 :: MonadPlus m_seg48)
      (w1_seg4b :: V1 p_seg46) ->
      let {
        lvl270_se9EQ :: m_seg48 (V1 p_seg46)
        [LclId]
        lvl270_se9EQ = mzero @ m_seg48 w_seg49 @ (V1 p_seg46) } in
      let {
        $dMonad_se9uN [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg48
        [LclId]
        $dMonad_se9uN = GHC.Base.$p2MonadPlus @ m_seg48 w_seg49 } in
      >>=
        @ m_seg48
        $dMonad_se9uN
        @ (V1 p_seg46, Bool)
        @ (V1 p_seg46)
        (case w1_seg4b of { })
        (\ (ds_de7pa :: (V1 p_seg46, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9EQ;
             True -> return @ m_seg48 $dMonad_se9uN @ (V1 p_seg46) x'_ae1TS
           }
           })

-- RHS size: {terms: 9, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataV1_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall p.
     Data p =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> V1 p -> m (V1 p)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ p_seg46)
                 _ [Occ=Dead]
                 (@ (m_seg48 :: * -> *))
                 (w1_seg49 [Occ=Once] :: MonadPlus m_seg48)
                 _ [Occ=Dead]
                 (w3_seg4b [Occ=Once] :: V1 p_seg46) ->
                 Data.Data.$w$cgmapMo32 @ p_seg46 @ m_seg48 w1_seg49 w3_seg4b}]
Data.Data.$fDataV1_$cgmapMo
  = \ (@ p_seg46)
      _ [Occ=Dead]
      (@ (m_seg48 :: * -> *))
      (w1_seg49 :: MonadPlus m_seg48)
      _ [Occ=Dead]
      (w3_seg4b :: V1 p_seg46) ->
      Data.Data.$w$cgmapMo32 @ p_seg46 @ m_seg48 w1_seg49 w3_seg4b

-- RHS size: {terms: 7, types: 31, coercions: 0, joins: 0/0}
lvl55_rejNG
  :: forall p (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> V1 p -> c (V1 p)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,1*U>b,
 Unf=OtherCon []]
lvl55_rejNG
  = \ (@ p_Xe3Op)
      (@ (c_ae3j0 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead]
      (z_ae2nj :: V1 p_Xe3Op) ->
      case z_ae2nj of { }

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
lvl56_rejNH :: forall p. V1 p -> Constr
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []]
lvl56_rejNH
  = \ (@ p_Xe3Op) (z_ae2nn :: V1 p_Xe3Op) -> case z_ae2nn of { }

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
lvl57_rejNI :: forall p. V1 p -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl57_rejNI = \ (@ p_Xe3Op) _ [Occ=Dead] -> Data.Data.$tV1

-- RHS size: {terms: 6, types: 28, coercions: 0, joins: 0/0}
lvl58_rejNJ
  :: forall p (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (V1 p))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl58_rejNJ
  = \ (@ p_Xe3Op)
      (@ (t_ae3jo :: * -> *))
      (@ (c_ae3jp :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae3jp (V1 p_Xe3Op))

-- RHS size: {terms: 6, types: 37, coercions: 0, joins: 0/0}
lvl59_rejNK
  :: forall p (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c (V1 p))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl59_rejNK
  = \ (@ p_Xe3Op)
      (@ (t_ae3jH :: * -> * -> *))
      (@ (c_ae3jI :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae3jI (V1 p_Xe3Op))

-- RHS size: {terms: 5, types: 16, coercions: 0, joins: 0/0}
lvl60_rejNL
  :: forall p.
     (forall b. Data b => b -> b) -> V1 p -> Identity (V1 p)
[GblId, Arity=2, Caf=NoCafRefs, Str=<B,A><B,1*U>b, Unf=OtherCon []]
lvl60_rejNL
  = \ (@ p_Xe3Op) _ [Occ=Dead] (eta1_X1tw :: V1 p_Xe3Op) ->
      case eta1_X1tw of { }

-- RHS size: {terms: 9, types: 24, coercions: 0, joins: 0/0}
lvl61_rejNM
  :: forall p r r'.
     (r -> r' -> r)
     -> r -> (forall d. Data d => d -> r') -> V1 p -> Const r (V1 p)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,A><B,1*U>b,
 Unf=OtherCon []]
lvl61_rejNM
  = \ (@ p_Xe3Op)
      (@ r_Xe3OP)
      (@ r'_Xe3OR)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (eta3_XZl :: V1 p_Xe3Op) ->
      case eta3_XZl of { }

-- RHS size: {terms: 9, types: 24, coercions: 0, joins: 0/0}
lvl62_rejNN
  :: forall p r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> V1 p -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,A><B,1*U>b,
 Unf=OtherCon []]
lvl62_rejNN
  = \ (@ p_Xe3Op)
      (@ r_ae3kw)
      (@ r'_ae3kx)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (eta3_XZl :: V1 p_Xe3Op) ->
      case eta3_XZl of { }

-- RHS size: {terms: 6, types: 18, coercions: 0, joins: 0/0}
lvl63_rejNO
  :: forall p u. (forall d. Data d => d -> u) -> V1 p -> [u]
[GblId, Arity=2, Caf=NoCafRefs, Str=<B,A><B,1*U>b, Unf=OtherCon []]
lvl63_rejNO
  = \ (@ p_Xe3Op)
      (@ u_ae3kN)
      _ [Occ=Dead]
      (eta1_XZf :: V1 p_Xe3Op) ->
      case eta1_XZf of { }

-- RHS size: {terms: 7, types: 19, coercions: 0, joins: 0/0}
lvl64_rejNP
  :: forall p u. Int -> (forall d. Data d => d -> u) -> V1 p -> u
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,1*U>b,
 Unf=OtherCon []]
lvl64_rejNP
  = \ (@ p_Xe3Op)
      (@ u_ae3l1)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (eta2_XZh :: V1 p_Xe3Op) ->
      case eta2_XZh of { }

-- RHS size: {terms: 7, types: 23, coercions: 0, joins: 0/0}
lvl65_rejNQ
  :: forall p (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> V1 p -> m (V1 p)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,1*U>b,
 Unf=OtherCon []]
lvl65_rejNQ
  = \ (@ p_Xe3Op)
      (@ (m_ae3lf :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead]
      (eta1_XZh :: V1 p_Xe3Op) ->
      case eta1_XZh of { }

-- RHS size: {terms: 8, types: 21, coercions: 0, joins: 0/0}
lvl66_rejNR
  :: forall p (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> V1 p -> m (V1 p)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=OtherCon []]
lvl66_rejNR
  = \ (@ p_Xe3Op)
      (@ (m_seg41 :: * -> *))
      (w_seg42 :: MonadPlus m_seg41)
      _ [Occ=Dead]
      (w2_seg44 :: V1 p_Xe3Op) ->
      Data.Data.$w$cgmapMp33 @ p_Xe3Op @ m_seg41 w_seg42 w2_seg44

-- RHS size: {terms: 8, types: 21, coercions: 0, joins: 0/0}
lvl67_rejNS
  :: forall p (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> V1 p -> m (V1 p)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=OtherCon []]
lvl67_rejNS
  = \ (@ p_Xe3Op)
      (@ (m_seg48 :: * -> *))
      (w_seg49 :: MonadPlus m_seg48)
      _ [Occ=Dead]
      (w2_seg4b :: V1 p_Xe3Op) ->
      Data.Data.$w$cgmapMo32 @ p_Xe3Op @ m_seg48 w_seg49 w2_seg4b

-- RHS size: {terms: 20, types: 23, coercions: 57, joins: 0/0}
Data.Data.$fDataV1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall p. Data p => Data (V1 p)
[GblId[DFunId],
 Arity=1,
 Str=<L,1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=DFun: \ (@ p_ae1WT) (v_XuA :: Data p_ae1WT) ->
       Data.Data.C:Data TYPE: V1 p_ae1WT
                        (Data.Data.$fDataV5 @ p_ae1WT v_XuA)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <V1
                                                                                    p_ae1WT>_N
                                :: (Data.Typeable.Internal.TypeRep (V1 p_ae1WT) :: *)
                                   ~R# (Typeable (V1 p_ae1WT) :: Constraint))
                        \ (@ (c_ae3j0 :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead]
                          (z_ae2nj [Occ=Once] :: V1 p_ae1WT) ->
                          case z_ae2nj of { }
                        Data.Data.$fDataV1_$cgunfold @ p_ae1WT v_XuA
                        \ (z_ae2nn [Occ=Once] :: V1 p_ae1WT) -> case z_ae2nn of { }
                        \ _ [Occ=Dead] -> Data.Data.$tV1
                        \ (@ (t_ae3jo :: * -> *))
                          (@ (c_ae3jp :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae3jp (V1 p_ae1WT))
                        \ (@ (t_ae3jH :: * -> * -> *))
                          (@ (c_ae3jI :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae3jI (V1 p_ae1WT))
                        (\ _ [Occ=Dead] (eta1_X1tw [Occ=Once] :: V1 p_ae1WT) ->
                           case eta1_X1tw of { })
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <V1 p_ae1WT>_R
                                ->_R Data.Functor.Identity.N:Identity[0] <V1 p_ae1WT>_R
                                :: ((forall b. Data b => b -> b)
                                    -> V1 p_ae1WT -> Identity (V1 p_ae1WT) :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> V1 p_ae1WT -> V1 p_ae1WT :: *))
                        (\ (@ r_Xe3OP)
                           (@ r'_Xe3OR)
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           (eta3_XZl [Occ=Once] :: V1 p_ae1WT) ->
                           case eta3_XZl of { })
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <V1 p_ae1WT>_R
                                ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <V1 p_ae1WT>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> V1 p_ae1WT
                                    -> Const r (V1 p_ae1WT) :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d. Data d => d -> r')
                                        -> V1 p_ae1WT
                                        -> r :: *))
                        \ (@ r_ae3kw)
                          (@ r'_ae3kx)
                          _ [Occ=Dead]
                          _ [Occ=Dead]
                          _ [Occ=Dead]
                          (eta3_XZl [Occ=Once] :: V1 p_ae1WT) ->
                          case eta3_XZl of { }
                        \ (@ u_ae3kN) _ [Occ=Dead] (eta1_XZf [Occ=Once] :: V1 p_ae1WT) ->
                          case eta1_XZf of { }
                        \ (@ u_ae3l1)
                          _ [Occ=Dead]
                          _ [Occ=Dead]
                          (eta2_XZh [Occ=Once] :: V1 p_ae1WT) ->
                          case eta2_XZh of { }
                        \ (@ (m_ae3lf :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead]
                          (eta1_XZh [Occ=Once] :: V1 p_ae1WT) ->
                          case eta1_XZh of { }
                        Data.Data.$fDataV1_$cgmapMp @ p_ae1WT v_XuA
                        Data.Data.$fDataV1_$cgmapMo @ p_ae1WT v_XuA]
Data.Data.$fDataV1
  = \ (@ p_Xe3Op) ($dData_Xe3Or :: Data p_Xe3Op) ->
      Data.Data.C:Data
        @ (V1 p_Xe3Op)
        ((Data.Data.$fDataV5 @ p_Xe3Op $dData_Xe3Or)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <V1
                                                                     p_Xe3Op>_N
                 :: (Data.Typeable.Internal.TypeRep (V1 p_Xe3Op) :: *)
                    ~R# (Typeable (V1 p_Xe3Op) :: Constraint)))
        (lvl55_rejNG @ p_Xe3Op)
        (Data.Data.$fDataV1_$cgunfold @ p_Xe3Op $dData_Xe3Or)
        (lvl56_rejNH @ p_Xe3Op)
        (lvl57_rejNI @ p_Xe3Op)
        (lvl58_rejNJ @ p_Xe3Op)
        (lvl59_rejNK @ p_Xe3Op)
        ((lvl60_rejNL @ p_Xe3Op)
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <V1 p_Xe3Op>_R
                 ->_R Data.Functor.Identity.N:Identity[0] <V1 p_Xe3Op>_R
                 :: ((forall b. Data b => b -> b)
                     -> V1 p_Xe3Op -> Identity (V1 p_Xe3Op) :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> V1 p_Xe3Op -> V1 p_Xe3Op :: *)))
        ((lvl61_rejNM @ p_Xe3Op)
         `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                 <r -> r' -> r>_R
                 ->_R <r>_R
                 ->_R <forall d. Data d => d -> r'>_R
                 ->_R <V1 p_Xe3Op>_R
                 ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <V1 p_Xe3Op>_P
                 :: (forall r r'.
                     (r -> r' -> r)
                     -> r
                     -> (forall d. Data d => d -> r')
                     -> V1 p_Xe3Op
                     -> Const r (V1 p_Xe3Op) :: *)
                    ~R# (forall r r'.
                         (r -> r' -> r)
                         -> r -> (forall d. Data d => d -> r') -> V1 p_Xe3Op -> r :: *)))
        (lvl62_rejNN @ p_Xe3Op)
        (lvl63_rejNO @ p_Xe3Op)
        (lvl64_rejNP @ p_Xe3Op)
        (lvl65_rejNQ @ p_Xe3Op)
        (lvl66_rejNR @ p_Xe3Op)
        (lvl67_rejNS @ p_Xe3Op)

-- RHS size: {terms: 29, types: 49, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp17 [InlPrag=NOUSERINLINE[0]]
  :: forall a (m :: * -> *).
     MonadPlus m =>
     ForeignPtr a -> m (ForeignPtr a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMp17
  = \ (@ a_seg4d)
      (@ (m_seg4f :: * -> *))
      (w_seg4g :: MonadPlus m_seg4f)
      (w1_seg4i :: ForeignPtr a_seg4d) ->
      let {
        lvl270_se9F2 :: m_seg4f (ForeignPtr a_seg4d)
        [LclId]
        lvl270_se9F2 = mzero @ m_seg4f w_seg4g @ (ForeignPtr a_seg4d) } in
      let {
        $dMonad_se9uL [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg4f
        [LclId]
        $dMonad_se9uL = GHC.Base.$p2MonadPlus @ m_seg4f w_seg4g } in
      >>=
        @ m_seg4f
        $dMonad_se9uL
        @ (ForeignPtr a_seg4d, Bool)
        @ (ForeignPtr a_seg4d)
        (return
           @ m_seg4f
           $dMonad_se9uL
           @ (ForeignPtr a_seg4d, Bool)
           (w1_seg4i, GHC.Types.False))
        (\ (ds_de7oa :: (ForeignPtr a_seg4d, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9F2;
             True ->
               return @ m_seg4f $dMonad_se9uL @ (ForeignPtr a_seg4d) x'_ae1TD
           }
           })

-- RHS size: {terms: 9, types: 21, coercions: 0, joins: 0/0}
Data.Data.$fDataForeignPtr_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> ForeignPtr a -> m (ForeignPtr a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_seg4d)
                 _ [Occ=Dead]
                 (@ (m_seg4f :: * -> *))
                 (w1_seg4g [Occ=Once] :: MonadPlus m_seg4f)
                 _ [Occ=Dead]
                 (w3_seg4i [Occ=Once] :: ForeignPtr a_seg4d) ->
                 Data.Data.$w$cgmapMp17 @ a_seg4d @ m_seg4f w1_seg4g w3_seg4i}]
Data.Data.$fDataForeignPtr_$cgmapMp
  = \ (@ a_seg4d)
      _ [Occ=Dead]
      (@ (m_seg4f :: * -> *))
      (w1_seg4g :: MonadPlus m_seg4f)
      _ [Occ=Dead]
      (w3_seg4i :: ForeignPtr a_seg4d) ->
      Data.Data.$w$cgmapMp17 @ a_seg4d @ m_seg4f w1_seg4g w3_seg4i

-- RHS size: {terms: 29, types: 49, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo16 [InlPrag=NOUSERINLINE[0]]
  :: forall a (m :: * -> *).
     MonadPlus m =>
     ForeignPtr a -> m (ForeignPtr a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMo16
  = \ (@ a_seg4k)
      (@ (m_seg4m :: * -> *))
      (w_seg4n :: MonadPlus m_seg4m)
      (w1_seg4p :: ForeignPtr a_seg4k) ->
      let {
        lvl270_se9F3 :: m_seg4m (ForeignPtr a_seg4k)
        [LclId]
        lvl270_se9F3 = mzero @ m_seg4m w_seg4n @ (ForeignPtr a_seg4k) } in
      let {
        $dMonad_se9uJ [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg4m
        [LclId]
        $dMonad_se9uJ = GHC.Base.$p2MonadPlus @ m_seg4m w_seg4n } in
      >>=
        @ m_seg4m
        $dMonad_se9uJ
        @ (ForeignPtr a_seg4k, Bool)
        @ (ForeignPtr a_seg4k)
        (return
           @ m_seg4m
           $dMonad_se9uJ
           @ (ForeignPtr a_seg4k, Bool)
           (w1_seg4p, GHC.Types.False))
        (\ (ds_de7pa :: (ForeignPtr a_seg4k, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9F3;
             True ->
               return @ m_seg4m $dMonad_se9uJ @ (ForeignPtr a_seg4k) x'_ae1TS
           }
           })

-- RHS size: {terms: 9, types: 21, coercions: 0, joins: 0/0}
Data.Data.$fDataForeignPtr_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> ForeignPtr a -> m (ForeignPtr a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_seg4k)
                 _ [Occ=Dead]
                 (@ (m_seg4m :: * -> *))
                 (w1_seg4n [Occ=Once] :: MonadPlus m_seg4m)
                 _ [Occ=Dead]
                 (w3_seg4p [Occ=Once] :: ForeignPtr a_seg4k) ->
                 Data.Data.$w$cgmapMo16 @ a_seg4k @ m_seg4m w1_seg4n w3_seg4p}]
Data.Data.$fDataForeignPtr_$cgmapMo
  = \ (@ a_seg4k)
      _ [Occ=Dead]
      (@ (m_seg4m :: * -> *))
      (w1_seg4n :: MonadPlus m_seg4m)
      _ [Occ=Dead]
      (w3_seg4p :: ForeignPtr a_seg4k) ->
      Data.Data.$w$cgmapMo16 @ a_seg4k @ m_seg4m w1_seg4n w3_seg4p

-- RHS size: {terms: 5, types: 25, coercions: 0, joins: 0/0}
lvl68_rejNT
  :: forall a (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> ForeignPtr a -> c (ForeignPtr a)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><S,1*U>, Unf=OtherCon []]
lvl68_rejNT
  = \ (@ a_Xe5Vp)
      (@ (c_ae5pP :: * -> *))
      _ [Occ=Dead]
      (ds1_de7Gq :: forall g. g -> c_ae5pP g) ->
      ds1_de7Gq @ (ForeignPtr a_Xe5Vp)

-- RHS size: {terms: 6, types: 35, coercions: 0, joins: 0/0}
lvl69_rejNU
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e))
     -> Maybe (c (ForeignPtr a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl69_rejNU
  = \ (@ a_Xe5Vp)
      (@ (t_ae5qH :: * -> * -> *))
      (@ (c_ae5qI :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5qI (ForeignPtr a_Xe5Vp))

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
lvl70_rejNV
  :: forall a.
     (forall b. Data b => b -> b) -> ForeignPtr a -> ForeignPtr a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U(U,U)>m,
 Unf=OtherCon []]
lvl70_rejNV
  = \ (@ a_Xe5Vp) _ [Occ=Dead] (x0_Xe2jm :: ForeignPtr a_Xe5Vp) ->
      x0_Xe2jm

-- RHS size: {terms: 8, types: 18, coercions: 0, joins: 0/0}
lvl71_rejNW
  :: forall a r r'.
     (r -> r' -> r)
     -> r -> (forall d. Data d => d -> r') -> ForeignPtr a -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=OtherCon []]
lvl71_rejNW
  = \ (@ a_Xe5Vp)
      (@ r_ae5rf)
      (@ r'_ae5rg)
      _ [Occ=Dead]
      (ds1_de7GK :: r_ae5rf)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7GK

-- RHS size: {terms: 8, types: 18, coercions: 0, joins: 0/0}
lvl72_rejNX
  :: forall a r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> ForeignPtr a -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=OtherCon []]
lvl72_rejNX
  = \ (@ a_Xe5Vp)
      (@ r_ae5rw)
      (@ r'_ae5rx)
      _ [Occ=Dead]
      (ds1_de7GN :: r_ae5rw)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7GN

-- RHS size: {terms: 5, types: 13, coercions: 0, joins: 0/0}
lvl73_rejNY
  :: forall a u. (forall d. Data d => d -> u) -> ForeignPtr a -> [u]
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl73_rejNY
  = \ (@ a_Xe5Vp) (@ u_ae5rN) _ [Occ=Dead] _ [Occ=Dead] ->
      GHC.Types.[] @ u_ae5rN

-- RHS size: {terms: 6, types: 14, coercions: 0, joins: 0/0}
lvl74_rejNZ
  :: forall a u.
     Int -> (forall d. Data d => d -> u) -> ForeignPtr a -> u
[GblId, Arity=3, Str=<B,A><B,A><B,A>x, Unf=OtherCon []]
lvl74_rejNZ
  = \ (@ a_Xe5Vp)
      (@ u_ae5s1)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      Data.Maybe.fromJust1 @ u_ae5s1

-- RHS size: {terms: 6, types: 18, coercions: 0, joins: 0/0}
lvl75_rejO0
  :: forall a (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> ForeignPtr a -> m (ForeignPtr a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLSL),1*U(A,A,A,1*U,A)><L,A>,
 Unf=OtherCon []]
lvl75_rejO0
  = \ (@ a_Xe5Vp)
      (@ (m_ae5sf :: * -> *))
      ($dMonad_ae5sh :: Monad m_ae5sf)
      _ [Occ=Dead] ->
      return @ m_ae5sf $dMonad_ae5sh @ (ForeignPtr a_Xe5Vp)

-- RHS size: {terms: 6, types: 27, coercions: 0, joins: 0/0}
lvl76_rejO1
  :: forall a (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c (ForeignPtr a)
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []]
lvl76_rejO1
  = \ (@ a_Xe5Vp)
      (@ (c_ae5q8 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ (Constr -> c_ae5q8 (ForeignPtr a_Xe5Vp))
        Data.Data.$fDataForeignPtr7

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
lvl77_rejO2 :: forall a. ForeignPtr a -> Constr
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []]
lvl77_rejO2
  = \ (@ a_Xe5Vp) _ [Occ=Dead] ->
      errorWithoutStackTrace
        @ 'LiftedRep @ Constr Data.Data.$fDataForeignPtr5

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl78_rejO3 :: forall a. ForeignPtr a -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl78_rejO3
  = \ (@ a_Xe5Vp) _ [Occ=Dead] -> Data.Data.$fDataForeignPtr2

-- RHS size: {terms: 8, types: 19, coercions: 0, joins: 0/0}
lvl79_rejO4
  :: forall a (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> ForeignPtr a -> m (ForeignPtr a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=OtherCon []]
lvl79_rejO4
  = \ (@ a_Xe5Vp)
      (@ (m_seg4f :: * -> *))
      (w_seg4g :: MonadPlus m_seg4f)
      _ [Occ=Dead]
      (w2_seg4i :: ForeignPtr a_Xe5Vp) ->
      Data.Data.$w$cgmapMp17 @ a_Xe5Vp @ m_seg4f w_seg4g w2_seg4i

-- RHS size: {terms: 8, types: 19, coercions: 0, joins: 0/0}
lvl80_rejO5
  :: forall a (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> ForeignPtr a -> m (ForeignPtr a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=OtherCon []]
lvl80_rejO5
  = \ (@ a_Xe5Vp)
      (@ (m_seg4m :: * -> *))
      (w_seg4n :: MonadPlus m_seg4m)
      _ [Occ=Dead]
      (w2_seg4p :: ForeignPtr a_Xe5Vp) ->
      Data.Data.$w$cgmapMo16 @ a_Xe5Vp @ m_seg4m w_seg4n w2_seg4p

-- RHS size: {terms: 20, types: 21, coercions: 6, joins: 0/0}
Data.Data.$fDataForeignPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data a => Data (ForeignPtr a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_ae1U0) (v_XuO :: Data a_ae1U0) ->
       Data.Data.C:Data TYPE: ForeignPtr a_ae1U0
                        (Data.Data.$fDataForeignPtr9 @ a_ae1U0 v_XuO)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <ForeignPtr
                                                                                    a_ae1U0>_N
                                :: (Data.Typeable.Internal.TypeRep (ForeignPtr a_ae1U0) :: *)
                                   ~R# (Typeable (ForeignPtr a_ae1U0) :: Constraint))
                        \ (@ (c_ae5pP :: * -> *))
                          _ [Occ=Dead]
                          (ds1_de7Gq [Occ=Once] :: forall g. g -> c_ae5pP g) ->
                          ds1_de7Gq @ (ForeignPtr a_ae1U0)
                        \ (@ (c_ae5q8 :: * -> *)) _ [Occ=Dead] _ [Occ=Dead] ->
                          errorWithoutStackTrace
                            @ 'LiftedRep
                            @ (Constr -> c_ae5q8 (ForeignPtr a_ae1U0))
                            Data.Data.$fDataForeignPtr7
                        \ _ [Occ=Dead] ->
                          errorWithoutStackTrace
                            @ 'LiftedRep @ Constr Data.Data.$fDataForeignPtr5
                        \ _ [Occ=Dead] -> Data.Data.$fDataForeignPtr2
                        Data.Data.$fDataForeignPtr_$cdataCast1 @ a_ae1U0 v_XuO
                        \ (@ (t_ae5qH :: * -> * -> *))
                          (@ (c_ae5qI :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae5qI (ForeignPtr a_ae1U0))
                        \ _ [Occ=Dead] (x0_Xe2jm [Occ=Once] :: ForeignPtr a_ae1U0) ->
                          x0_Xe2jm
                        \ (@ r_ae5rf)
                          (@ r'_ae5rg)
                          _ [Occ=Dead]
                          (ds1_de7GK [Occ=Once] :: r_ae5rf)
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          ds1_de7GK
                        \ (@ r_ae5rw)
                          (@ r'_ae5rx)
                          _ [Occ=Dead]
                          (ds1_de7GN [Occ=Once] :: r_ae5rw)
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          ds1_de7GN
                        \ (@ u_ae5rN) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.[] @ u_ae5rN
                        \ (@ u_ae5s1) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                          Data.Maybe.fromJust1 @ u_ae5s1
                        \ (@ (m_ae5sf :: * -> *))
                          ($dMonad_ae5sh [Occ=Once] :: Monad m_ae5sf)
                          _ [Occ=Dead] ->
                          return @ m_ae5sf $dMonad_ae5sh @ (ForeignPtr a_ae1U0)
                        Data.Data.$fDataForeignPtr_$cgmapMp @ a_ae1U0 v_XuO
                        Data.Data.$fDataForeignPtr_$cgmapMo @ a_ae1U0 v_XuO]
Data.Data.$fDataForeignPtr
  = \ (@ a_Xe5Vp) ($dData_Xe5Vr :: Data a_Xe5Vp) ->
      Data.Data.C:Data
        @ (ForeignPtr a_Xe5Vp)
        ((Data.Data.$fDataForeignPtr9 @ a_Xe5Vp $dData_Xe5Vr)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <ForeignPtr
                                                                     a_Xe5Vp>_N
                 :: (Data.Typeable.Internal.TypeRep (ForeignPtr a_Xe5Vp) :: *)
                    ~R# (Typeable (ForeignPtr a_Xe5Vp) :: Constraint)))
        (lvl68_rejNT @ a_Xe5Vp)
        (lvl76_rejO1 @ a_Xe5Vp)
        (lvl77_rejO2 @ a_Xe5Vp)
        (lvl78_rejO3 @ a_Xe5Vp)
        (Data.Data.$fDataForeignPtr_$cdataCast1 @ a_Xe5Vp $dData_Xe5Vr)
        (lvl69_rejNU @ a_Xe5Vp)
        (lvl70_rejNV @ a_Xe5Vp)
        (lvl71_rejNW @ a_Xe5Vp)
        (lvl72_rejNX @ a_Xe5Vp)
        (lvl73_rejNY @ a_Xe5Vp)
        (lvl74_rejNZ @ a_Xe5Vp)
        (lvl75_rejO0 @ a_Xe5Vp)
        (lvl79_rejO4 @ a_Xe5Vp)
        (lvl80_rejO5 @ a_Xe5Vp)

-- RHS size: {terms: 29, types: 49, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp28 [InlPrag=NOUSERINLINE[0]]
  :: forall a (m :: * -> *). MonadPlus m => Ptr a -> m (Ptr a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMp28
  = \ (@ a_seg4r)
      (@ (m_seg4t :: * -> *))
      (w_seg4u :: MonadPlus m_seg4t)
      (w1_seg4w :: Ptr a_seg4r) ->
      let {
        lvl270_se9Fc :: m_seg4t (Ptr a_seg4r)
        [LclId]
        lvl270_se9Fc = mzero @ m_seg4t w_seg4u @ (Ptr a_seg4r) } in
      let {
        $dMonad_se9uH [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg4t
        [LclId]
        $dMonad_se9uH = GHC.Base.$p2MonadPlus @ m_seg4t w_seg4u } in
      >>=
        @ m_seg4t
        $dMonad_se9uH
        @ (Ptr a_seg4r, Bool)
        @ (Ptr a_seg4r)
        (return
           @ m_seg4t
           $dMonad_se9uH
           @ (Ptr a_seg4r, Bool)
           (w1_seg4w, GHC.Types.False))
        (\ (ds_de7oa :: (Ptr a_seg4r, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9Fc;
             True -> return @ m_seg4t $dMonad_se9uH @ (Ptr a_seg4r) x'_ae1TD
           }
           })

-- RHS size: {terms: 9, types: 21, coercions: 0, joins: 0/0}
Data.Data.$fDataPtr_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Ptr a -> m (Ptr a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_seg4r)
                 _ [Occ=Dead]
                 (@ (m_seg4t :: * -> *))
                 (w1_seg4u [Occ=Once] :: MonadPlus m_seg4t)
                 _ [Occ=Dead]
                 (w3_seg4w [Occ=Once] :: Ptr a_seg4r) ->
                 Data.Data.$w$cgmapMp28 @ a_seg4r @ m_seg4t w1_seg4u w3_seg4w}]
Data.Data.$fDataPtr_$cgmapMp
  = \ (@ a_seg4r)
      _ [Occ=Dead]
      (@ (m_seg4t :: * -> *))
      (w1_seg4u :: MonadPlus m_seg4t)
      _ [Occ=Dead]
      (w3_seg4w :: Ptr a_seg4r) ->
      Data.Data.$w$cgmapMp28 @ a_seg4r @ m_seg4t w1_seg4u w3_seg4w

-- RHS size: {terms: 29, types: 49, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo27 [InlPrag=NOUSERINLINE[0]]
  :: forall a (m :: * -> *). MonadPlus m => Ptr a -> m (Ptr a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMo27
  = \ (@ a_seg4y)
      (@ (m_seg4A :: * -> *))
      (w_seg4B :: MonadPlus m_seg4A)
      (w1_seg4D :: Ptr a_seg4y) ->
      let {
        lvl270_se9Fd :: m_seg4A (Ptr a_seg4y)
        [LclId]
        lvl270_se9Fd = mzero @ m_seg4A w_seg4B @ (Ptr a_seg4y) } in
      let {
        $dMonad_se9uF [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg4A
        [LclId]
        $dMonad_se9uF = GHC.Base.$p2MonadPlus @ m_seg4A w_seg4B } in
      >>=
        @ m_seg4A
        $dMonad_se9uF
        @ (Ptr a_seg4y, Bool)
        @ (Ptr a_seg4y)
        (return
           @ m_seg4A
           $dMonad_se9uF
           @ (Ptr a_seg4y, Bool)
           (w1_seg4D, GHC.Types.False))
        (\ (ds_de7pa :: (Ptr a_seg4y, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9Fd;
             True -> return @ m_seg4A $dMonad_se9uF @ (Ptr a_seg4y) x'_ae1TS
           }
           })

-- RHS size: {terms: 9, types: 21, coercions: 0, joins: 0/0}
Data.Data.$fDataPtr_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Ptr a -> m (Ptr a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_seg4y)
                 _ [Occ=Dead]
                 (@ (m_seg4A :: * -> *))
                 (w1_seg4B [Occ=Once] :: MonadPlus m_seg4A)
                 _ [Occ=Dead]
                 (w3_seg4D [Occ=Once] :: Ptr a_seg4y) ->
                 Data.Data.$w$cgmapMo27 @ a_seg4y @ m_seg4A w1_seg4B w3_seg4D}]
Data.Data.$fDataPtr_$cgmapMo
  = \ (@ a_seg4y)
      _ [Occ=Dead]
      (@ (m_seg4A :: * -> *))
      (w1_seg4B :: MonadPlus m_seg4A)
      _ [Occ=Dead]
      (w3_seg4D :: Ptr a_seg4y) ->
      Data.Data.$w$cgmapMo27 @ a_seg4y @ m_seg4A w1_seg4B w3_seg4D

-- RHS size: {terms: 5, types: 25, coercions: 0, joins: 0/0}
lvl81_rejO6
  :: forall a (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Ptr a -> c (Ptr a)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><S,1*U>, Unf=OtherCon []]
lvl81_rejO6
  = \ (@ a_Xe5YU)
      (@ (c_ae5t9 :: * -> *))
      _ [Occ=Dead]
      (ds1_de7GW :: forall g. g -> c_ae5t9 g) ->
      ds1_de7GW @ (Ptr a_Xe5YU)

-- RHS size: {terms: 6, types: 35, coercions: 0, joins: 0/0}
lvl82_rejO7
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c (Ptr a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl82_rejO7
  = \ (@ a_Xe5YU)
      (@ (t_ae5u1 :: * -> * -> *))
      (@ (c_ae5u2 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5u2 (Ptr a_Xe5YU))

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
lvl83_rejO8
  :: forall a. (forall b. Data b => b -> b) -> Ptr a -> Ptr a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U(U)>m,
 Unf=OtherCon []]
lvl83_rejO8
  = \ (@ a_Xe5YU) _ [Occ=Dead] (x0_Xe2jm :: Ptr a_Xe5YU) -> x0_Xe2jm

-- RHS size: {terms: 8, types: 18, coercions: 0, joins: 0/0}
lvl84_rejO9
  :: forall a r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> Ptr a -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=OtherCon []]
lvl84_rejO9
  = \ (@ a_Xe5YU)
      (@ r_ae5uz)
      (@ r'_ae5uA)
      _ [Occ=Dead]
      (ds1_de7Hg :: r_ae5uz)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7Hg

-- RHS size: {terms: 8, types: 18, coercions: 0, joins: 0/0}
lvl85_rejOa
  :: forall a r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> Ptr a -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=OtherCon []]
lvl85_rejOa
  = \ (@ a_Xe5YU)
      (@ r_ae5uQ)
      (@ r'_ae5uR)
      _ [Occ=Dead]
      (ds1_de7Hj :: r_ae5uQ)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7Hj

-- RHS size: {terms: 5, types: 13, coercions: 0, joins: 0/0}
lvl86_rejOb
  :: forall a u. (forall d. Data d => d -> u) -> Ptr a -> [u]
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl86_rejOb
  = \ (@ a_Xe5YU) (@ u_ae5v7) _ [Occ=Dead] _ [Occ=Dead] ->
      GHC.Types.[] @ u_ae5v7

-- RHS size: {terms: 6, types: 14, coercions: 0, joins: 0/0}
lvl87_rejOc
  :: forall a u. Int -> (forall d. Data d => d -> u) -> Ptr a -> u
[GblId, Arity=3, Str=<B,A><B,A><B,A>x, Unf=OtherCon []]
lvl87_rejOc
  = \ (@ a_Xe5YU)
      (@ u_ae5vl)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      Data.Maybe.fromJust1 @ u_ae5vl

-- RHS size: {terms: 6, types: 18, coercions: 0, joins: 0/0}
lvl88_rejOd
  :: forall a (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Ptr a -> m (Ptr a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLSL),1*U(A,A,A,1*U,A)><L,A>,
 Unf=OtherCon []]
lvl88_rejOd
  = \ (@ a_Xe5YU)
      (@ (m_ae5vz :: * -> *))
      ($dMonad_ae5vB :: Monad m_ae5vz)
      _ [Occ=Dead] ->
      return @ m_ae5vz $dMonad_ae5vB @ (Ptr a_Xe5YU)

-- RHS size: {terms: 6, types: 27, coercions: 0, joins: 0/0}
lvl89_rejOe
  :: forall a (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c (Ptr a)
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []]
lvl89_rejOe
  = \ (@ a_Xe5YU)
      (@ (c_ae5ts :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ (Constr -> c_ae5ts (Ptr a_Xe5YU))
        Data.Data.$fDataPtr7

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
lvl90_rejOf :: forall a. Ptr a -> Constr
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []]
lvl90_rejOf
  = \ (@ a_Xe5YU) _ [Occ=Dead] ->
      errorWithoutStackTrace @ 'LiftedRep @ Constr Data.Data.$fDataPtr5

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl91_rejOg :: forall a. Ptr a -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl91_rejOg = \ (@ a_Xe5YU) _ [Occ=Dead] -> Data.Data.$fDataPtr2

-- RHS size: {terms: 8, types: 19, coercions: 0, joins: 0/0}
lvl92_rejOh
  :: forall a (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Ptr a -> m (Ptr a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=OtherCon []]
lvl92_rejOh
  = \ (@ a_Xe5YU)
      (@ (m_seg4t :: * -> *))
      (w_seg4u :: MonadPlus m_seg4t)
      _ [Occ=Dead]
      (w2_seg4w :: Ptr a_Xe5YU) ->
      Data.Data.$w$cgmapMp28 @ a_Xe5YU @ m_seg4t w_seg4u w2_seg4w

-- RHS size: {terms: 8, types: 19, coercions: 0, joins: 0/0}
lvl93_rejOi
  :: forall a (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Ptr a -> m (Ptr a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=OtherCon []]
lvl93_rejOi
  = \ (@ a_Xe5YU)
      (@ (m_seg4A :: * -> *))
      (w_seg4B :: MonadPlus m_seg4A)
      _ [Occ=Dead]
      (w2_seg4D :: Ptr a_Xe5YU) ->
      Data.Data.$w$cgmapMo27 @ a_Xe5YU @ m_seg4A w_seg4B w2_seg4D

-- RHS size: {terms: 20, types: 21, coercions: 6, joins: 0/0}
Data.Data.$fDataPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data a => Data (Ptr a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_ae1U2) (v_Xv2 :: Data a_ae1U2) ->
       Data.Data.C:Data TYPE: Ptr a_ae1U2
                        (Data.Data.$fDataPtr9 @ a_ae1U2 v_Xv2)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Ptr
                                                                                    a_ae1U2>_N
                                :: (Data.Typeable.Internal.TypeRep (Ptr a_ae1U2) :: *)
                                   ~R# (Typeable (Ptr a_ae1U2) :: Constraint))
                        \ (@ (c_ae5t9 :: * -> *))
                          _ [Occ=Dead]
                          (ds1_de7GW [Occ=Once] :: forall g. g -> c_ae5t9 g) ->
                          ds1_de7GW @ (Ptr a_ae1U2)
                        \ (@ (c_ae5ts :: * -> *)) _ [Occ=Dead] _ [Occ=Dead] ->
                          errorWithoutStackTrace
                            @ 'LiftedRep
                            @ (Constr -> c_ae5ts (Ptr a_ae1U2))
                            Data.Data.$fDataPtr7
                        \ _ [Occ=Dead] ->
                          errorWithoutStackTrace @ 'LiftedRep @ Constr Data.Data.$fDataPtr5
                        \ _ [Occ=Dead] -> Data.Data.$fDataPtr2
                        Data.Data.$fDataPtr_$cdataCast1 @ a_ae1U2 v_Xv2
                        \ (@ (t_ae5u1 :: * -> * -> *))
                          (@ (c_ae5u2 :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae5u2 (Ptr a_ae1U2))
                        \ _ [Occ=Dead] (x0_Xe2jm [Occ=Once] :: Ptr a_ae1U2) -> x0_Xe2jm
                        \ (@ r_ae5uz)
                          (@ r'_ae5uA)
                          _ [Occ=Dead]
                          (ds1_de7Hg [Occ=Once] :: r_ae5uz)
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          ds1_de7Hg
                        \ (@ r_ae5uQ)
                          (@ r'_ae5uR)
                          _ [Occ=Dead]
                          (ds1_de7Hj [Occ=Once] :: r_ae5uQ)
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          ds1_de7Hj
                        \ (@ u_ae5v7) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.[] @ u_ae5v7
                        \ (@ u_ae5vl) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                          Data.Maybe.fromJust1 @ u_ae5vl
                        \ (@ (m_ae5vz :: * -> *))
                          ($dMonad_ae5vB [Occ=Once] :: Monad m_ae5vz)
                          _ [Occ=Dead] ->
                          return @ m_ae5vz $dMonad_ae5vB @ (Ptr a_ae1U2)
                        Data.Data.$fDataPtr_$cgmapMp @ a_ae1U2 v_Xv2
                        Data.Data.$fDataPtr_$cgmapMo @ a_ae1U2 v_Xv2]
Data.Data.$fDataPtr
  = \ (@ a_Xe5YU) ($dData_Xe5YW :: Data a_Xe5YU) ->
      Data.Data.C:Data
        @ (Ptr a_Xe5YU)
        ((Data.Data.$fDataPtr9 @ a_Xe5YU $dData_Xe5YW)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Ptr
                                                                     a_Xe5YU>_N
                 :: (Data.Typeable.Internal.TypeRep (Ptr a_Xe5YU) :: *)
                    ~R# (Typeable (Ptr a_Xe5YU) :: Constraint)))
        (lvl81_rejO6 @ a_Xe5YU)
        (lvl89_rejOe @ a_Xe5YU)
        (lvl90_rejOf @ a_Xe5YU)
        (lvl91_rejOg @ a_Xe5YU)
        (Data.Data.$fDataPtr_$cdataCast1 @ a_Xe5YU $dData_Xe5YW)
        (lvl82_rejO7 @ a_Xe5YU)
        (lvl83_rejO8 @ a_Xe5YU)
        (lvl84_rejO9 @ a_Xe5YU)
        (lvl85_rejOa @ a_Xe5YU)
        (lvl86_rejOb @ a_Xe5YU)
        (lvl87_rejOc @ a_Xe5YU)
        (lvl88_rejOd @ a_Xe5YU)
        (lvl92_rejOh @ a_Xe5YU)
        (lvl93_rejOi @ a_Xe5YU)

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataWord64_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c Word64)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae5EI :: * -> * -> *))
                 (@ (c_ae5EJ :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae5EJ Word64)}]
Data.Data.$fDataWord64_$cdataCast2
  = \ (@ (t_ae5EI :: * -> * -> *))
      (@ (c_ae5EJ :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5EJ Word64)

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataWord64_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c Word64)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae5Ep :: * -> *))
                 (@ (c_ae5Eq :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae5Eq Word64)}]
Data.Data.$fDataWord64_$cdataCast1
  = \ (@ (t_ae5Ep :: * -> *))
      (@ (c_ae5Eq :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5Eq Word64)

-- RHS size: {terms: 4, types: 22, coercions: 0, joins: 0/0}
Data.Data.$fDataWord64_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Word64 -> c Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (c_ae5DA :: * -> *))
                 _ [Occ=Dead]
                 (ds1_de7JN [Occ=Once] :: forall g. g -> c_ae5DA g) ->
                 ds1_de7JN @ Word64}]
Data.Data.$fDataWord64_$cgfoldl
  = \ (@ (c_ae5DA :: * -> *))
      _ [Occ=Dead]
      (ds1_de7JN :: forall g. g -> c_ae5DA g) ->
      ds1_de7JN @ Word64

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fDataWord14
  :: (forall b. Data b => b -> b) -> Word64 -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (x0_Xe2jm [Occ=Once] :: Word64) -> x0_Xe2jm}]
Data.Data.$fDataWord14
  = \ _ [Occ=Dead] (x0_Xe2jm :: Word64) -> x0_Xe2jm

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord64_$cgmapQl
  :: forall r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> Word64 -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae5Fg)
                 (@ r'_ae5Fh)
                 _ [Occ=Dead]
                 (ds1_de7Kd [Occ=Once] :: r_ae5Fg)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7Kd}]
Data.Data.$fDataWord64_$cgmapQl
  = \ (@ r_ae5Fg)
      (@ r'_ae5Fh)
      _ [Occ=Dead]
      (ds1_de7Kd :: r_ae5Fg)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7Kd

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord64_$cgmapQr
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> Word64 -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae5Fx)
                 (@ r'_ae5Fy)
                 _ [Occ=Dead]
                 (ds1_de7Kg [Occ=Once] :: r_ae5Fx)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7Kg}]
Data.Data.$fDataWord64_$cgmapQr
  = \ (@ r_ae5Fx)
      (@ r'_ae5Fy)
      _ [Occ=Dead]
      (ds1_de7Kg :: r_ae5Fx)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7Kg

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
Data.Data.$fDataWord64_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> Word64 -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae5FO) _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.[] @ u_ae5FO}]
Data.Data.$fDataWord64_$cgmapQ
  = \ (@ u_ae5FO) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.[] @ u_ae5FO

-- RHS size: {terms: 5, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord64_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Word64 -> m Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLSL),1*U(A,A,A,1*U,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_ae5Gg :: * -> *))
                 ($dMonad_ae5Gi [Occ=Once] :: Monad m_ae5Gg)
                 _ [Occ=Dead] ->
                 return @ m_ae5Gg $dMonad_ae5Gi @ Word64}]
Data.Data.$fDataWord64_$cgmapM
  = \ (@ (m_ae5Gg :: * -> *))
      ($dMonad_ae5Gi :: Monad m_ae5Gg)
      _ [Occ=Dead] ->
      return @ m_ae5Gg $dMonad_ae5Gi @ Word64

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp37 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Word64 -> m Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMp37
  = \ (@ (m_seg4F :: * -> *))
      (w_seg4G :: MonadPlus m_seg4F)
      (w1_seg4I :: Word64) ->
      let {
        lvl270_se9Fm :: m_seg4F Word64
        [LclId]
        lvl270_se9Fm = mzero @ m_seg4F w_seg4G @ Word64 } in
      let {
        $dMonad_se9uD [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg4F
        [LclId]
        $dMonad_se9uD = GHC.Base.$p2MonadPlus @ m_seg4F w_seg4G } in
      >>=
        @ m_seg4F
        $dMonad_se9uD
        @ (Word64, Bool)
        @ Word64
        (return
           @ m_seg4F
           $dMonad_se9uD
           @ (Word64, Bool)
           (w1_seg4I, GHC.Types.False))
        (\ (ds_de7oa :: (Word64, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9Fm;
             True -> return @ m_seg4F $dMonad_se9uD @ Word64 x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord64_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Word64 -> m Word64
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg4F :: * -> *))
                 (w_seg4G [Occ=Once] :: MonadPlus m_seg4F)
                 _ [Occ=Dead]
                 (w2_seg4I [Occ=Once] :: Word64) ->
                 Data.Data.$w$cgmapMp37 @ m_seg4F w_seg4G w2_seg4I}]
Data.Data.$fDataWord64_$cgmapMp
  = \ (@ (m_seg4F :: * -> *))
      (w_seg4G :: MonadPlus m_seg4F)
      _ [Occ=Dead]
      (w2_seg4I :: Word64) ->
      Data.Data.$w$cgmapMp37 @ m_seg4F w_seg4G w2_seg4I

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataWord64_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> Word64 -> u
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae5G2) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Maybe.fromJust1 @ u_ae5G2}]
Data.Data.$fDataWord64_$cgmapQi
  = \ (@ u_ae5G2) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Maybe.fromJust1 @ u_ae5G2

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo36 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Word64 -> m Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMo36
  = \ (@ (m_seg4K :: * -> *))
      (w_seg4L :: MonadPlus m_seg4K)
      (w1_seg4N :: Word64) ->
      let {
        lvl270_se9Fn :: m_seg4K Word64
        [LclId]
        lvl270_se9Fn = mzero @ m_seg4K w_seg4L @ Word64 } in
      let {
        $dMonad_se9uB [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg4K
        [LclId]
        $dMonad_se9uB = GHC.Base.$p2MonadPlus @ m_seg4K w_seg4L } in
      >>=
        @ m_seg4K
        $dMonad_se9uB
        @ (Word64, Bool)
        @ Word64
        (return
           @ m_seg4K
           $dMonad_se9uB
           @ (Word64, Bool)
           (w1_seg4N, GHC.Types.False))
        (\ (ds_de7pa :: (Word64, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9Fn;
             True -> return @ m_seg4K $dMonad_se9uB @ Word64 x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord64_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Word64 -> m Word64
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg4K :: * -> *))
                 (w_seg4L [Occ=Once] :: MonadPlus m_seg4K)
                 _ [Occ=Dead]
                 (w2_seg4N [Occ=Once] :: Word64) ->
                 Data.Data.$w$cgmapMo36 @ m_seg4K w_seg4L w2_seg4N}]
Data.Data.$fDataWord64_$cgmapMo
  = \ (@ (m_seg4K :: * -> *))
      (w_seg4L :: MonadPlus m_seg4K)
      _ [Occ=Dead]
      (w2_seg4N :: Word64) ->
      Data.Data.$w$cgmapMo36 @ m_seg4K w_seg4L w2_seg4N

-- RHS size: {terms: 16, types: 1, coercions: 5, joins: 0/0}
Data.Data.$fDataWord64 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data Word64
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: Word64
                        Data.Data.$fDataWord18
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Word64>_N
                                :: (Data.Typeable.Internal.TypeRep Word64 :: *)
                                   ~R# (Typeable Word64 :: Constraint))
                        Data.Data.$fDataWord64_$cgfoldl
                        Data.Data.$fDataWord64_$cgunfold
                        Data.Data.$fDataWord64_$ctoConstr
                        Data.Data.$fDataWord64_$cdataTypeOf
                        Data.Data.$fDataWord64_$cdataCast1
                        Data.Data.$fDataWord64_$cdataCast2
                        Data.Data.$fDataWord14
                        Data.Data.$fDataWord64_$cgmapQl
                        Data.Data.$fDataWord64_$cgmapQr
                        Data.Data.$fDataWord64_$cgmapQ
                        Data.Data.$fDataWord64_$cgmapQi
                        Data.Data.$fDataWord64_$cgmapM
                        Data.Data.$fDataWord64_$cgmapMp
                        Data.Data.$fDataWord64_$cgmapMo]
Data.Data.$fDataWord64
  = Data.Data.C:Data
      @ Word64
      (Data.Data.$fDataWord18
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Word64>_N
               :: (Data.Typeable.Internal.TypeRep Word64 :: *)
                  ~R# (Typeable Word64 :: Constraint)))
      Data.Data.$fDataWord64_$cgfoldl
      Data.Data.$fDataWord64_$cgunfold
      Data.Data.$fDataWord64_$ctoConstr
      Data.Data.$fDataWord64_$cdataTypeOf
      Data.Data.$fDataWord64_$cdataCast1
      Data.Data.$fDataWord64_$cdataCast2
      Data.Data.$fDataWord14
      Data.Data.$fDataWord64_$cgmapQl
      Data.Data.$fDataWord64_$cgmapQr
      Data.Data.$fDataWord64_$cgmapQ
      Data.Data.$fDataWord64_$cgmapQi
      Data.Data.$fDataWord64_$cgmapM
      Data.Data.$fDataWord64_$cgmapMp
      Data.Data.$fDataWord64_$cgmapMo

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataWord32_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c Word32)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae5Ig :: * -> * -> *))
                 (@ (c_ae5Ih :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae5Ih Word32)}]
Data.Data.$fDataWord32_$cdataCast2
  = \ (@ (t_ae5Ig :: * -> * -> *))
      (@ (c_ae5Ih :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5Ih Word32)

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataWord32_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c Word32)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae5HX :: * -> *))
                 (@ (c_ae5HY :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae5HY Word32)}]
Data.Data.$fDataWord32_$cdataCast1
  = \ (@ (t_ae5HX :: * -> *))
      (@ (c_ae5HY :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5HY Word32)

-- RHS size: {terms: 4, types: 22, coercions: 0, joins: 0/0}
Data.Data.$fDataWord32_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Word32 -> c Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (c_ae5H8 :: * -> *))
                 _ [Occ=Dead]
                 (ds1_de7Kp [Occ=Once] :: forall g. g -> c_ae5H8 g) ->
                 ds1_de7Kp @ Word32}]
Data.Data.$fDataWord32_$cgfoldl
  = \ (@ (c_ae5H8 :: * -> *))
      _ [Occ=Dead]
      (ds1_de7Kp :: forall g. g -> c_ae5H8 g) ->
      ds1_de7Kp @ Word32

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fDataWord10
  :: (forall b. Data b => b -> b) -> Word32 -> Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (x0_Xe2OH [Occ=Once] :: Word32) -> x0_Xe2OH}]
Data.Data.$fDataWord10
  = \ _ [Occ=Dead] (x0_Xe2OH :: Word32) -> x0_Xe2OH

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord32_$cgmapQl
  :: forall r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> Word32 -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae5IO)
                 (@ r'_ae5IP)
                 _ [Occ=Dead]
                 (ds1_de7KP [Occ=Once] :: r_ae5IO)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7KP}]
Data.Data.$fDataWord32_$cgmapQl
  = \ (@ r_ae5IO)
      (@ r'_ae5IP)
      _ [Occ=Dead]
      (ds1_de7KP :: r_ae5IO)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7KP

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord32_$cgmapQr
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> Word32 -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae5J5)
                 (@ r'_ae5J6)
                 _ [Occ=Dead]
                 (ds1_de7KS [Occ=Once] :: r_ae5J5)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7KS}]
Data.Data.$fDataWord32_$cgmapQr
  = \ (@ r_ae5J5)
      (@ r'_ae5J6)
      _ [Occ=Dead]
      (ds1_de7KS :: r_ae5J5)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7KS

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
Data.Data.$fDataWord32_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> Word32 -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae5Jm) _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.[] @ u_ae5Jm}]
Data.Data.$fDataWord32_$cgmapQ
  = \ (@ u_ae5Jm) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.[] @ u_ae5Jm

-- RHS size: {terms: 5, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord32_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Word32 -> m Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLSL),1*U(A,A,A,1*U,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_ae5JO :: * -> *))
                 ($dMonad_ae5JQ [Occ=Once] :: Monad m_ae5JO)
                 _ [Occ=Dead] ->
                 return @ m_ae5JO $dMonad_ae5JQ @ Word32}]
Data.Data.$fDataWord32_$cgmapM
  = \ (@ (m_ae5JO :: * -> *))
      ($dMonad_ae5JQ :: Monad m_ae5JO)
      _ [Occ=Dead] ->
      return @ m_ae5JO $dMonad_ae5JQ @ Word32

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp36 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Word32 -> m Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMp36
  = \ (@ (m_seg4P :: * -> *))
      (w_seg4Q :: MonadPlus m_seg4P)
      (w1_seg4S :: Word32) ->
      let {
        lvl270_se9Fo :: m_seg4P Word32
        [LclId]
        lvl270_se9Fo = mzero @ m_seg4P w_seg4Q @ Word32 } in
      let {
        $dMonad_se9uz [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg4P
        [LclId]
        $dMonad_se9uz = GHC.Base.$p2MonadPlus @ m_seg4P w_seg4Q } in
      >>=
        @ m_seg4P
        $dMonad_se9uz
        @ (Word32, Bool)
        @ Word32
        (return
           @ m_seg4P
           $dMonad_se9uz
           @ (Word32, Bool)
           (w1_seg4S, GHC.Types.False))
        (\ (ds_de7oa :: (Word32, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9Fo;
             True -> return @ m_seg4P $dMonad_se9uz @ Word32 x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord32_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Word32 -> m Word32
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg4P :: * -> *))
                 (w_seg4Q [Occ=Once] :: MonadPlus m_seg4P)
                 _ [Occ=Dead]
                 (w2_seg4S [Occ=Once] :: Word32) ->
                 Data.Data.$w$cgmapMp36 @ m_seg4P w_seg4Q w2_seg4S}]
Data.Data.$fDataWord32_$cgmapMp
  = \ (@ (m_seg4P :: * -> *))
      (w_seg4Q :: MonadPlus m_seg4P)
      _ [Occ=Dead]
      (w2_seg4S :: Word32) ->
      Data.Data.$w$cgmapMp36 @ m_seg4P w_seg4Q w2_seg4S

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataWord32_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> Word32 -> u
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae5JA) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Maybe.fromJust1 @ u_ae5JA}]
Data.Data.$fDataWord32_$cgmapQi
  = \ (@ u_ae5JA) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Maybe.fromJust1 @ u_ae5JA

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo35 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Word32 -> m Word32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMo35
  = \ (@ (m_seg4U :: * -> *))
      (w_seg4V :: MonadPlus m_seg4U)
      (w1_seg4X :: Word32) ->
      let {
        lvl270_se9Fp :: m_seg4U Word32
        [LclId]
        lvl270_se9Fp = mzero @ m_seg4U w_seg4V @ Word32 } in
      let {
        $dMonad_se9ux [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg4U
        [LclId]
        $dMonad_se9ux = GHC.Base.$p2MonadPlus @ m_seg4U w_seg4V } in
      >>=
        @ m_seg4U
        $dMonad_se9ux
        @ (Word32, Bool)
        @ Word32
        (return
           @ m_seg4U
           $dMonad_se9ux
           @ (Word32, Bool)
           (w1_seg4X, GHC.Types.False))
        (\ (ds_de7pa :: (Word32, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9Fp;
             True -> return @ m_seg4U $dMonad_se9ux @ Word32 x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord32_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Word32 -> m Word32
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg4U :: * -> *))
                 (w_seg4V [Occ=Once] :: MonadPlus m_seg4U)
                 _ [Occ=Dead]
                 (w2_seg4X [Occ=Once] :: Word32) ->
                 Data.Data.$w$cgmapMo35 @ m_seg4U w_seg4V w2_seg4X}]
Data.Data.$fDataWord32_$cgmapMo
  = \ (@ (m_seg4U :: * -> *))
      (w_seg4V :: MonadPlus m_seg4U)
      _ [Occ=Dead]
      (w2_seg4X :: Word32) ->
      Data.Data.$w$cgmapMo35 @ m_seg4U w_seg4V w2_seg4X

-- RHS size: {terms: 16, types: 1, coercions: 5, joins: 0/0}
Data.Data.$fDataWord32 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data Word32
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: Word32
                        Data.Data.$fDataWord13
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Word32>_N
                                :: (Data.Typeable.Internal.TypeRep Word32 :: *)
                                   ~R# (Typeable Word32 :: Constraint))
                        Data.Data.$fDataWord32_$cgfoldl
                        Data.Data.$fDataWord32_$cgunfold
                        Data.Data.$fDataWord32_$ctoConstr
                        Data.Data.$fDataWord32_$cdataTypeOf
                        Data.Data.$fDataWord32_$cdataCast1
                        Data.Data.$fDataWord32_$cdataCast2
                        Data.Data.$fDataWord10
                        Data.Data.$fDataWord32_$cgmapQl
                        Data.Data.$fDataWord32_$cgmapQr
                        Data.Data.$fDataWord32_$cgmapQ
                        Data.Data.$fDataWord32_$cgmapQi
                        Data.Data.$fDataWord32_$cgmapM
                        Data.Data.$fDataWord32_$cgmapMp
                        Data.Data.$fDataWord32_$cgmapMo]
Data.Data.$fDataWord32
  = Data.Data.C:Data
      @ Word32
      (Data.Data.$fDataWord13
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Word32>_N
               :: (Data.Typeable.Internal.TypeRep Word32 :: *)
                  ~R# (Typeable Word32 :: Constraint)))
      Data.Data.$fDataWord32_$cgfoldl
      Data.Data.$fDataWord32_$cgunfold
      Data.Data.$fDataWord32_$ctoConstr
      Data.Data.$fDataWord32_$cdataTypeOf
      Data.Data.$fDataWord32_$cdataCast1
      Data.Data.$fDataWord32_$cdataCast2
      Data.Data.$fDataWord10
      Data.Data.$fDataWord32_$cgmapQl
      Data.Data.$fDataWord32_$cgmapQr
      Data.Data.$fDataWord32_$cgmapQ
      Data.Data.$fDataWord32_$cgmapQi
      Data.Data.$fDataWord32_$cgmapM
      Data.Data.$fDataWord32_$cgmapMp
      Data.Data.$fDataWord32_$cgmapMo

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataWord16_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c Word16)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae5LO :: * -> * -> *))
                 (@ (c_ae5LP :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae5LP Word16)}]
Data.Data.$fDataWord16_$cdataCast2
  = \ (@ (t_ae5LO :: * -> * -> *))
      (@ (c_ae5LP :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5LP Word16)

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataWord16_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c Word16)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae5Lv :: * -> *))
                 (@ (c_ae5Lw :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae5Lw Word16)}]
Data.Data.$fDataWord16_$cdataCast1
  = \ (@ (t_ae5Lv :: * -> *))
      (@ (c_ae5Lw :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5Lw Word16)

-- RHS size: {terms: 4, types: 22, coercions: 0, joins: 0/0}
Data.Data.$fDataWord16_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Word16 -> c Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (c_ae5KG :: * -> *))
                 _ [Occ=Dead]
                 (ds1_de7L1 [Occ=Once] :: forall g. g -> c_ae5KG g) ->
                 ds1_de7L1 @ Word16}]
Data.Data.$fDataWord16_$cgfoldl
  = \ (@ (c_ae5KG :: * -> *))
      _ [Occ=Dead]
      (ds1_de7L1 :: forall g. g -> c_ae5KG g) ->
      ds1_de7L1 @ Word16

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fDataWord5
  :: (forall b. Data b => b -> b) -> Word16 -> Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (x0_Xe2OX [Occ=Once] :: Word16) -> x0_Xe2OX}]
Data.Data.$fDataWord5
  = \ _ [Occ=Dead] (x0_Xe2OX :: Word16) -> x0_Xe2OX

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord16_$cgmapQl
  :: forall r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> Word16 -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae5Mm)
                 (@ r'_ae5Mn)
                 _ [Occ=Dead]
                 (ds1_de7Lr [Occ=Once] :: r_ae5Mm)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7Lr}]
Data.Data.$fDataWord16_$cgmapQl
  = \ (@ r_ae5Mm)
      (@ r'_ae5Mn)
      _ [Occ=Dead]
      (ds1_de7Lr :: r_ae5Mm)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7Lr

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord16_$cgmapQr
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> Word16 -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae5MD)
                 (@ r'_ae5ME)
                 _ [Occ=Dead]
                 (ds1_de7Lu [Occ=Once] :: r_ae5MD)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7Lu}]
Data.Data.$fDataWord16_$cgmapQr
  = \ (@ r_ae5MD)
      (@ r'_ae5ME)
      _ [Occ=Dead]
      (ds1_de7Lu :: r_ae5MD)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7Lu

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
Data.Data.$fDataWord16_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> Word16 -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae5MU) _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.[] @ u_ae5MU}]
Data.Data.$fDataWord16_$cgmapQ
  = \ (@ u_ae5MU) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.[] @ u_ae5MU

-- RHS size: {terms: 5, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord16_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Word16 -> m Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLSL),1*U(A,A,A,1*U,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_ae5Nm :: * -> *))
                 ($dMonad_ae5No [Occ=Once] :: Monad m_ae5Nm)
                 _ [Occ=Dead] ->
                 return @ m_ae5Nm $dMonad_ae5No @ Word16}]
Data.Data.$fDataWord16_$cgmapM
  = \ (@ (m_ae5Nm :: * -> *))
      ($dMonad_ae5No :: Monad m_ae5Nm)
      _ [Occ=Dead] ->
      return @ m_ae5Nm $dMonad_ae5No @ Word16

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp35 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Word16 -> m Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMp35
  = \ (@ (m_seg4Z :: * -> *))
      (w_seg50 :: MonadPlus m_seg4Z)
      (w1_seg52 :: Word16) ->
      let {
        lvl270_se9Fq :: m_seg4Z Word16
        [LclId]
        lvl270_se9Fq = mzero @ m_seg4Z w_seg50 @ Word16 } in
      let {
        $dMonad_se9uv [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg4Z
        [LclId]
        $dMonad_se9uv = GHC.Base.$p2MonadPlus @ m_seg4Z w_seg50 } in
      >>=
        @ m_seg4Z
        $dMonad_se9uv
        @ (Word16, Bool)
        @ Word16
        (return
           @ m_seg4Z
           $dMonad_se9uv
           @ (Word16, Bool)
           (w1_seg52, GHC.Types.False))
        (\ (ds_de7oa :: (Word16, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9Fq;
             True -> return @ m_seg4Z $dMonad_se9uv @ Word16 x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord16_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Word16 -> m Word16
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg4Z :: * -> *))
                 (w_seg50 [Occ=Once] :: MonadPlus m_seg4Z)
                 _ [Occ=Dead]
                 (w2_seg52 [Occ=Once] :: Word16) ->
                 Data.Data.$w$cgmapMp35 @ m_seg4Z w_seg50 w2_seg52}]
Data.Data.$fDataWord16_$cgmapMp
  = \ (@ (m_seg4Z :: * -> *))
      (w_seg50 :: MonadPlus m_seg4Z)
      _ [Occ=Dead]
      (w2_seg52 :: Word16) ->
      Data.Data.$w$cgmapMp35 @ m_seg4Z w_seg50 w2_seg52

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataWord16_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> Word16 -> u
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae5N8) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Maybe.fromJust1 @ u_ae5N8}]
Data.Data.$fDataWord16_$cgmapQi
  = \ (@ u_ae5N8) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Maybe.fromJust1 @ u_ae5N8

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo34 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Word16 -> m Word16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMo34
  = \ (@ (m_seg54 :: * -> *))
      (w_seg55 :: MonadPlus m_seg54)
      (w1_seg57 :: Word16) ->
      let {
        lvl270_se9Fr :: m_seg54 Word16
        [LclId]
        lvl270_se9Fr = mzero @ m_seg54 w_seg55 @ Word16 } in
      let {
        $dMonad_se9ut [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg54
        [LclId]
        $dMonad_se9ut = GHC.Base.$p2MonadPlus @ m_seg54 w_seg55 } in
      >>=
        @ m_seg54
        $dMonad_se9ut
        @ (Word16, Bool)
        @ Word16
        (return
           @ m_seg54
           $dMonad_se9ut
           @ (Word16, Bool)
           (w1_seg57, GHC.Types.False))
        (\ (ds_de7pa :: (Word16, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9Fr;
             True -> return @ m_seg54 $dMonad_se9ut @ Word16 x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord16_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Word16 -> m Word16
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg54 :: * -> *))
                 (w_seg55 [Occ=Once] :: MonadPlus m_seg54)
                 _ [Occ=Dead]
                 (w2_seg57 [Occ=Once] :: Word16) ->
                 Data.Data.$w$cgmapMo34 @ m_seg54 w_seg55 w2_seg57}]
Data.Data.$fDataWord16_$cgmapMo
  = \ (@ (m_seg54 :: * -> *))
      (w_seg55 :: MonadPlus m_seg54)
      _ [Occ=Dead]
      (w2_seg57 :: Word16) ->
      Data.Data.$w$cgmapMo34 @ m_seg54 w_seg55 w2_seg57

-- RHS size: {terms: 16, types: 1, coercions: 5, joins: 0/0}
Data.Data.$fDataWord16 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data Word16
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: Word16
                        Data.Data.$fDataWord9
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Word16>_N
                                :: (Data.Typeable.Internal.TypeRep Word16 :: *)
                                   ~R# (Typeable Word16 :: Constraint))
                        Data.Data.$fDataWord16_$cgfoldl
                        Data.Data.$fDataWord16_$cgunfold
                        Data.Data.$fDataWord16_$ctoConstr
                        Data.Data.$fDataWord16_$cdataTypeOf
                        Data.Data.$fDataWord16_$cdataCast1
                        Data.Data.$fDataWord16_$cdataCast2
                        Data.Data.$fDataWord5
                        Data.Data.$fDataWord16_$cgmapQl
                        Data.Data.$fDataWord16_$cgmapQr
                        Data.Data.$fDataWord16_$cgmapQ
                        Data.Data.$fDataWord16_$cgmapQi
                        Data.Data.$fDataWord16_$cgmapM
                        Data.Data.$fDataWord16_$cgmapMp
                        Data.Data.$fDataWord16_$cgmapMo]
Data.Data.$fDataWord16
  = Data.Data.C:Data
      @ Word16
      (Data.Data.$fDataWord9
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Word16>_N
               :: (Data.Typeable.Internal.TypeRep Word16 :: *)
                  ~R# (Typeable Word16 :: Constraint)))
      Data.Data.$fDataWord16_$cgfoldl
      Data.Data.$fDataWord16_$cgunfold
      Data.Data.$fDataWord16_$ctoConstr
      Data.Data.$fDataWord16_$cdataTypeOf
      Data.Data.$fDataWord16_$cdataCast1
      Data.Data.$fDataWord16_$cdataCast2
      Data.Data.$fDataWord5
      Data.Data.$fDataWord16_$cgmapQl
      Data.Data.$fDataWord16_$cgmapQr
      Data.Data.$fDataWord16_$cgmapQ
      Data.Data.$fDataWord16_$cgmapQi
      Data.Data.$fDataWord16_$cgmapM
      Data.Data.$fDataWord16_$cgmapMp
      Data.Data.$fDataWord16_$cgmapMo

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataWord8_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c Word8)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae5Pm :: * -> * -> *))
                 (@ (c_ae5Pn :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae5Pn Word8)}]
Data.Data.$fDataWord8_$cdataCast2
  = \ (@ (t_ae5Pm :: * -> * -> *))
      (@ (c_ae5Pn :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5Pn Word8)

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataWord8_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c Word8)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae5P3 :: * -> *))
                 (@ (c_ae5P4 :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae5P4 Word8)}]
Data.Data.$fDataWord8_$cdataCast1
  = \ (@ (t_ae5P3 :: * -> *))
      (@ (c_ae5P4 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5P4 Word8)

-- RHS size: {terms: 4, types: 22, coercions: 0, joins: 0/0}
Data.Data.$fDataWord8_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Word8 -> c Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (c_ae5Oe :: * -> *))
                 _ [Occ=Dead]
                 (ds1_de7LD [Occ=Once] :: forall g. g -> c_ae5Oe g) ->
                 ds1_de7LD @ Word8}]
Data.Data.$fDataWord8_$cgfoldl
  = \ (@ (c_ae5Oe :: * -> *))
      _ [Occ=Dead]
      (ds1_de7LD :: forall g. g -> c_ae5Oe g) ->
      ds1_de7LD @ Word8

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fDataWord19
  :: (forall b. Data b => b -> b) -> Word8 -> Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (x0_Xe2Pd [Occ=Once] :: Word8) -> x0_Xe2Pd}]
Data.Data.$fDataWord19
  = \ _ [Occ=Dead] (x0_Xe2Pd :: Word8) -> x0_Xe2Pd

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord8_$cgmapQl
  :: forall r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> Word8 -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae5PU)
                 (@ r'_ae5PV)
                 _ [Occ=Dead]
                 (ds1_de7M3 [Occ=Once] :: r_ae5PU)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7M3}]
Data.Data.$fDataWord8_$cgmapQl
  = \ (@ r_ae5PU)
      (@ r'_ae5PV)
      _ [Occ=Dead]
      (ds1_de7M3 :: r_ae5PU)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7M3

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord8_$cgmapQr
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> Word8 -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae5Qb)
                 (@ r'_ae5Qc)
                 _ [Occ=Dead]
                 (ds1_de7M6 [Occ=Once] :: r_ae5Qb)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7M6}]
Data.Data.$fDataWord8_$cgmapQr
  = \ (@ r_ae5Qb)
      (@ r'_ae5Qc)
      _ [Occ=Dead]
      (ds1_de7M6 :: r_ae5Qb)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7M6

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
Data.Data.$fDataWord8_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> Word8 -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae5Qs) _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.[] @ u_ae5Qs}]
Data.Data.$fDataWord8_$cgmapQ
  = \ (@ u_ae5Qs) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.[] @ u_ae5Qs

-- RHS size: {terms: 5, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord8_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Word8 -> m Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLSL),1*U(A,A,A,1*U,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_ae5QU :: * -> *))
                 ($dMonad_ae5QW [Occ=Once] :: Monad m_ae5QU)
                 _ [Occ=Dead] ->
                 return @ m_ae5QU $dMonad_ae5QW @ Word8}]
Data.Data.$fDataWord8_$cgmapM
  = \ (@ (m_ae5QU :: * -> *))
      ($dMonad_ae5QW :: Monad m_ae5QU)
      _ [Occ=Dead] ->
      return @ m_ae5QU $dMonad_ae5QW @ Word8

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp38 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Word8 -> m Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMp38
  = \ (@ (m_seg59 :: * -> *))
      (w_seg5a :: MonadPlus m_seg59)
      (w1_seg5c :: Word8) ->
      let {
        lvl270_se9Fs :: m_seg59 Word8
        [LclId]
        lvl270_se9Fs = mzero @ m_seg59 w_seg5a @ Word8 } in
      let {
        $dMonad_se9ur [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg59
        [LclId]
        $dMonad_se9ur = GHC.Base.$p2MonadPlus @ m_seg59 w_seg5a } in
      >>=
        @ m_seg59
        $dMonad_se9ur
        @ (Word8, Bool)
        @ Word8
        (return
           @ m_seg59
           $dMonad_se9ur
           @ (Word8, Bool)
           (w1_seg5c, GHC.Types.False))
        (\ (ds_de7oa :: (Word8, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9Fs;
             True -> return @ m_seg59 $dMonad_se9ur @ Word8 x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord8_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Word8 -> m Word8
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg59 :: * -> *))
                 (w_seg5a [Occ=Once] :: MonadPlus m_seg59)
                 _ [Occ=Dead]
                 (w2_seg5c [Occ=Once] :: Word8) ->
                 Data.Data.$w$cgmapMp38 @ m_seg59 w_seg5a w2_seg5c}]
Data.Data.$fDataWord8_$cgmapMp
  = \ (@ (m_seg59 :: * -> *))
      (w_seg5a :: MonadPlus m_seg59)
      _ [Occ=Dead]
      (w2_seg5c :: Word8) ->
      Data.Data.$w$cgmapMp38 @ m_seg59 w_seg5a w2_seg5c

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataWord8_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> Word8 -> u
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae5QG) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Maybe.fromJust1 @ u_ae5QG}]
Data.Data.$fDataWord8_$cgmapQi
  = \ (@ u_ae5QG) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Maybe.fromJust1 @ u_ae5QG

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo37 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Word8 -> m Word8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMo37
  = \ (@ (m_seg5e :: * -> *))
      (w_seg5f :: MonadPlus m_seg5e)
      (w1_seg5h :: Word8) ->
      let {
        lvl270_se9Ft :: m_seg5e Word8
        [LclId]
        lvl270_se9Ft = mzero @ m_seg5e w_seg5f @ Word8 } in
      let {
        $dMonad_se9up [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg5e
        [LclId]
        $dMonad_se9up = GHC.Base.$p2MonadPlus @ m_seg5e w_seg5f } in
      >>=
        @ m_seg5e
        $dMonad_se9up
        @ (Word8, Bool)
        @ Word8
        (return
           @ m_seg5e
           $dMonad_se9up
           @ (Word8, Bool)
           (w1_seg5h, GHC.Types.False))
        (\ (ds_de7pa :: (Word8, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9Ft;
             True -> return @ m_seg5e $dMonad_se9up @ Word8 x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord8_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Word8 -> m Word8
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg5e :: * -> *))
                 (w_seg5f [Occ=Once] :: MonadPlus m_seg5e)
                 _ [Occ=Dead]
                 (w2_seg5h [Occ=Once] :: Word8) ->
                 Data.Data.$w$cgmapMo37 @ m_seg5e w_seg5f w2_seg5h}]
Data.Data.$fDataWord8_$cgmapMo
  = \ (@ (m_seg5e :: * -> *))
      (w_seg5f :: MonadPlus m_seg5e)
      _ [Occ=Dead]
      (w2_seg5h :: Word8) ->
      Data.Data.$w$cgmapMo37 @ m_seg5e w_seg5f w2_seg5h

-- RHS size: {terms: 16, types: 1, coercions: 5, joins: 0/0}
Data.Data.$fDataWord8 [InlPrag=NOUSERINLINE CONLIKE] :: Data Word8
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: Word8
                        Data.Data.$fDataWord22
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Word8>_N
                                :: (Data.Typeable.Internal.TypeRep Word8 :: *)
                                   ~R# (Typeable Word8 :: Constraint))
                        Data.Data.$fDataWord8_$cgfoldl
                        Data.Data.$fDataWord8_$cgunfold
                        Data.Data.$fDataWord8_$ctoConstr
                        Data.Data.$fDataWord8_$cdataTypeOf
                        Data.Data.$fDataWord8_$cdataCast1
                        Data.Data.$fDataWord8_$cdataCast2
                        Data.Data.$fDataWord19
                        Data.Data.$fDataWord8_$cgmapQl
                        Data.Data.$fDataWord8_$cgmapQr
                        Data.Data.$fDataWord8_$cgmapQ
                        Data.Data.$fDataWord8_$cgmapQi
                        Data.Data.$fDataWord8_$cgmapM
                        Data.Data.$fDataWord8_$cgmapMp
                        Data.Data.$fDataWord8_$cgmapMo]
Data.Data.$fDataWord8
  = Data.Data.C:Data
      @ Word8
      (Data.Data.$fDataWord22
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Word8>_N
               :: (Data.Typeable.Internal.TypeRep Word8 :: *)
                  ~R# (Typeable Word8 :: Constraint)))
      Data.Data.$fDataWord8_$cgfoldl
      Data.Data.$fDataWord8_$cgunfold
      Data.Data.$fDataWord8_$ctoConstr
      Data.Data.$fDataWord8_$cdataTypeOf
      Data.Data.$fDataWord8_$cdataCast1
      Data.Data.$fDataWord8_$cdataCast2
      Data.Data.$fDataWord19
      Data.Data.$fDataWord8_$cgmapQl
      Data.Data.$fDataWord8_$cgmapQr
      Data.Data.$fDataWord8_$cgmapQ
      Data.Data.$fDataWord8_$cgmapQi
      Data.Data.$fDataWord8_$cgmapM
      Data.Data.$fDataWord8_$cgmapMp
      Data.Data.$fDataWord8_$cgmapMo

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataWord_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c Word)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae5SU :: * -> * -> *))
                 (@ (c_ae5SV :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae5SV Word)}]
Data.Data.$fDataWord_$cdataCast2
  = \ (@ (t_ae5SU :: * -> * -> *))
      (@ (c_ae5SV :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5SV Word)

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataWord_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c Word)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae5SB :: * -> *))
                 (@ (c_ae5SC :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae5SC Word)}]
Data.Data.$fDataWord_$cdataCast1
  = \ (@ (t_ae5SB :: * -> *))
      (@ (c_ae5SC :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5SC Word)

-- RHS size: {terms: 4, types: 22, coercions: 0, joins: 0/0}
Data.Data.$fDataWord_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Word -> c Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (c_ae5RM :: * -> *))
                 _ [Occ=Dead]
                 (ds1_de7Mf [Occ=Once] :: forall g. g -> c_ae5RM g) ->
                 ds1_de7Mf @ Word}]
Data.Data.$fDataWord_$cgfoldl
  = \ (@ (c_ae5RM :: * -> *))
      _ [Occ=Dead]
      (ds1_de7Mf :: forall g. g -> c_ae5RM g) ->
      ds1_de7Mf @ Word

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fDataWord1
  :: (forall b. Data b => b -> b) -> Word -> Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (x0_Xe2Pt [Occ=Once] :: Word) -> x0_Xe2Pt}]
Data.Data.$fDataWord1
  = \ _ [Occ=Dead] (x0_Xe2Pt :: Word) -> x0_Xe2Pt

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord_$cgmapQl
  :: forall r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> Word -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae5Ts)
                 (@ r'_ae5Tt)
                 _ [Occ=Dead]
                 (ds1_de7MF [Occ=Once] :: r_ae5Ts)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7MF}]
Data.Data.$fDataWord_$cgmapQl
  = \ (@ r_ae5Ts)
      (@ r'_ae5Tt)
      _ [Occ=Dead]
      (ds1_de7MF :: r_ae5Ts)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7MF

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord_$cgmapQr
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> Word -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae5TJ)
                 (@ r'_ae5TK)
                 _ [Occ=Dead]
                 (ds1_de7MI [Occ=Once] :: r_ae5TJ)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7MI}]
Data.Data.$fDataWord_$cgmapQr
  = \ (@ r_ae5TJ)
      (@ r'_ae5TK)
      _ [Occ=Dead]
      (ds1_de7MI :: r_ae5TJ)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7MI

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
Data.Data.$fDataWord_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> Word -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae5U0) _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.[] @ u_ae5U0}]
Data.Data.$fDataWord_$cgmapQ
  = \ (@ u_ae5U0) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.[] @ u_ae5U0

-- RHS size: {terms: 5, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Word -> m Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLSL),1*U(A,A,A,1*U,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_ae5Us :: * -> *))
                 ($dMonad_ae5Uu [Occ=Once] :: Monad m_ae5Us)
                 _ [Occ=Dead] ->
                 return @ m_ae5Us $dMonad_ae5Uu @ Word}]
Data.Data.$fDataWord_$cgmapM
  = \ (@ (m_ae5Us :: * -> *))
      ($dMonad_ae5Uu :: Monad m_ae5Us)
      _ [Occ=Dead] ->
      return @ m_ae5Us $dMonad_ae5Uu @ Word

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp34 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Word -> m Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMp34
  = \ (@ (m_seg5j :: * -> *))
      (w_seg5k :: MonadPlus m_seg5j)
      (w1_seg5m :: Word) ->
      let {
        lvl270_se9Fu :: m_seg5j Word
        [LclId]
        lvl270_se9Fu = mzero @ m_seg5j w_seg5k @ Word } in
      let {
        $dMonad_se9un [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg5j
        [LclId]
        $dMonad_se9un = GHC.Base.$p2MonadPlus @ m_seg5j w_seg5k } in
      >>=
        @ m_seg5j
        $dMonad_se9un
        @ (Word, Bool)
        @ Word
        (return
           @ m_seg5j $dMonad_se9un @ (Word, Bool) (w1_seg5m, GHC.Types.False))
        (\ (ds_de7oa :: (Word, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9Fu;
             True -> return @ m_seg5j $dMonad_se9un @ Word x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Word -> m Word
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg5j :: * -> *))
                 (w_seg5k [Occ=Once] :: MonadPlus m_seg5j)
                 _ [Occ=Dead]
                 (w2_seg5m [Occ=Once] :: Word) ->
                 Data.Data.$w$cgmapMp34 @ m_seg5j w_seg5k w2_seg5m}]
Data.Data.$fDataWord_$cgmapMp
  = \ (@ (m_seg5j :: * -> *))
      (w_seg5k :: MonadPlus m_seg5j)
      _ [Occ=Dead]
      (w2_seg5m :: Word) ->
      Data.Data.$w$cgmapMp34 @ m_seg5j w_seg5k w2_seg5m

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataWord_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> Word -> u
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae5Ue) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Maybe.fromJust1 @ u_ae5Ue}]
Data.Data.$fDataWord_$cgmapQi
  = \ (@ u_ae5Ue) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Maybe.fromJust1 @ u_ae5Ue

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo33 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Word -> m Word
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMo33
  = \ (@ (m_seg5o :: * -> *))
      (w_seg5p :: MonadPlus m_seg5o)
      (w1_seg5r :: Word) ->
      let {
        lvl270_se9Fv :: m_seg5o Word
        [LclId]
        lvl270_se9Fv = mzero @ m_seg5o w_seg5p @ Word } in
      let {
        $dMonad_se9ul [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg5o
        [LclId]
        $dMonad_se9ul = GHC.Base.$p2MonadPlus @ m_seg5o w_seg5p } in
      >>=
        @ m_seg5o
        $dMonad_se9ul
        @ (Word, Bool)
        @ Word
        (return
           @ m_seg5o $dMonad_se9ul @ (Word, Bool) (w1_seg5r, GHC.Types.False))
        (\ (ds_de7pa :: (Word, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9Fv;
             True -> return @ m_seg5o $dMonad_se9ul @ Word x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataWord_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Word -> m Word
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg5o :: * -> *))
                 (w_seg5p [Occ=Once] :: MonadPlus m_seg5o)
                 _ [Occ=Dead]
                 (w2_seg5r [Occ=Once] :: Word) ->
                 Data.Data.$w$cgmapMo33 @ m_seg5o w_seg5p w2_seg5r}]
Data.Data.$fDataWord_$cgmapMo
  = \ (@ (m_seg5o :: * -> *))
      (w_seg5p :: MonadPlus m_seg5o)
      _ [Occ=Dead]
      (w2_seg5r :: Word) ->
      Data.Data.$w$cgmapMo33 @ m_seg5o w_seg5p w2_seg5r

-- RHS size: {terms: 16, types: 1, coercions: 5, joins: 0/0}
Data.Data.$fDataWord [InlPrag=NOUSERINLINE CONLIKE] :: Data Word
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: Word
                        Data.Data.$fDataWord4
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Word>_N
                                :: (Data.Typeable.Internal.TypeRep Word :: *)
                                   ~R# (Typeable Word :: Constraint))
                        Data.Data.$fDataWord_$cgfoldl
                        Data.Data.$fDataWord_$cgunfold
                        Data.Data.$fDataWord_$ctoConstr
                        Data.Data.$fDataWord_$cdataTypeOf
                        Data.Data.$fDataWord_$cdataCast1
                        Data.Data.$fDataWord_$cdataCast2
                        Data.Data.$fDataWord1
                        Data.Data.$fDataWord_$cgmapQl
                        Data.Data.$fDataWord_$cgmapQr
                        Data.Data.$fDataWord_$cgmapQ
                        Data.Data.$fDataWord_$cgmapQi
                        Data.Data.$fDataWord_$cgmapM
                        Data.Data.$fDataWord_$cgmapMp
                        Data.Data.$fDataWord_$cgmapMo]
Data.Data.$fDataWord
  = Data.Data.C:Data
      @ Word
      (Data.Data.$fDataWord4
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Word>_N
               :: (Data.Typeable.Internal.TypeRep Word :: *)
                  ~R# (Typeable Word :: Constraint)))
      Data.Data.$fDataWord_$cgfoldl
      Data.Data.$fDataWord_$cgunfold
      Data.Data.$fDataWord_$ctoConstr
      Data.Data.$fDataWord_$cdataTypeOf
      Data.Data.$fDataWord_$cdataCast1
      Data.Data.$fDataWord_$cdataCast2
      Data.Data.$fDataWord1
      Data.Data.$fDataWord_$cgmapQl
      Data.Data.$fDataWord_$cgmapQr
      Data.Data.$fDataWord_$cgmapQ
      Data.Data.$fDataWord_$cgmapQi
      Data.Data.$fDataWord_$cgmapM
      Data.Data.$fDataWord_$cgmapMp
      Data.Data.$fDataWord_$cgmapMo

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataWordPtr2 :: Word -> Word
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (v_Xwo [Occ=Once] :: Word) -> v_Xwo}]
Data.Data.$fDataWordPtr2 = \ (v_Xwo :: Word) -> v_Xwo

-- RHS size: {terms: 9, types: 26, coercions: 5, joins: 0/0}
Data.Data.$fDataWordPtr_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> WordPtr -> c WordPtr
[GblId,
 Arity=3,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_ae4wZ :: * -> *))
                 (k_ae2ph [Occ=Once!]
                    :: forall d b. Data d => c_ae4wZ (d -> b) -> d -> c_ae4wZ b)
                 (z_ae2pi [Occ=Once!] :: forall g. g -> c_ae4wZ g)
                 (ds_de7A6 [Occ=Once] :: WordPtr) ->
                 k_ae2ph
                   @ Word
                   @ WordPtr
                   Data.Data.$fDataWord
                   (z_ae2pi
                      @ (Word -> WordPtr)
                      (Data.Data.$fDataWordPtr2
                       `cast` (<Word>_R ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                               :: (Word -> Word :: *) ~R# (Word -> WordPtr :: *))))
                   (ds_de7A6
                    `cast` (Foreign.Ptr.N:WordPtr[0]
                            :: (WordPtr :: *) ~R# (Word :: *)))}]
Data.Data.$fDataWordPtr_$cgfoldl
  = \ (@ (c_ae4wZ :: * -> *))
      (k_ae2ph
         :: forall d b. Data d => c_ae4wZ (d -> b) -> d -> c_ae4wZ b)
      (z_ae2pi :: forall g. g -> c_ae4wZ g)
      (ds_de7A6 :: WordPtr) ->
      k_ae2ph
        @ Word
        @ WordPtr
        Data.Data.$fDataWord
        (z_ae2pi
           @ (Word -> WordPtr)
           (Data.Data.$fDataWordPtr2
            `cast` (<Word>_R ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                    :: (Word -> Word :: *) ~R# (Word -> WordPtr :: *))))
        (ds_de7A6
         `cast` (Foreign.Ptr.N:WordPtr[0]
                 :: (WordPtr :: *) ~R# (Word :: *)))

-- RHS size: {terms: 8, types: 25, coercions: 4, joins: 0/0}
Data.Data.$fDataWordPtr_$cgunfold
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c WordPtr
[GblId,
 Arity=3,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_ae4x9 :: * -> *))
                 (k_ae2pk [Occ=Once!]
                    :: forall b r. Data b => c_ae4x9 (b -> r) -> c_ae4x9 r)
                 (z_ae2pl [Occ=Once!] :: forall r. r -> c_ae4x9 r)
                 _ [Occ=Dead] ->
                 k_ae2pk
                   @ Word
                   @ WordPtr
                   Data.Data.$fDataWord
                   (z_ae2pl
                      @ (Word -> WordPtr)
                      (Data.Data.$fDataWordPtr2
                       `cast` (<Word>_R ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                               :: (Word -> Word :: *) ~R# (Word -> WordPtr :: *))))}]
Data.Data.$fDataWordPtr_$cgunfold
  = \ (@ (c_ae4x9 :: * -> *))
      (k_ae2pk :: forall b r. Data b => c_ae4x9 (b -> r) -> c_ae4x9 r)
      (z_ae2pl :: forall r. r -> c_ae4x9 r)
      _ [Occ=Dead] ->
      k_ae2pk
        @ Word
        @ WordPtr
        Data.Data.$fDataWord
        (z_ae2pl
           @ (Word -> WordPtr)
           (Data.Data.$fDataWordPtr2
            `cast` (<Word>_R ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                    :: (Word -> Word :: *) ~R# (Word -> WordPtr :: *))))

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataInt64_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c Int64)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae5Ws :: * -> * -> *))
                 (@ (c_ae5Wt :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae5Wt Int64)}]
Data.Data.$fDataInt64_$cdataCast2
  = \ (@ (t_ae5Ws :: * -> * -> *))
      (@ (c_ae5Wt :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5Wt Int64)

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataInt64_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c Int64)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae5W9 :: * -> *))
                 (@ (c_ae5Wa :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae5Wa Int64)}]
Data.Data.$fDataInt64_$cdataCast1
  = \ (@ (t_ae5W9 :: * -> *))
      (@ (c_ae5Wa :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5Wa Int64)

-- RHS size: {terms: 4, types: 22, coercions: 0, joins: 0/0}
Data.Data.$fDataInt64_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Int64 -> c Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (c_ae5Vk :: * -> *))
                 _ [Occ=Dead]
                 (ds1_de7MR [Occ=Once] :: forall g. g -> c_ae5Vk g) ->
                 ds1_de7MR @ Int64}]
Data.Data.$fDataInt64_$cgfoldl
  = \ (@ (c_ae5Vk :: * -> *))
      _ [Occ=Dead]
      (ds1_de7MR :: forall g. g -> c_ae5Vk g) ->
      ds1_de7MR @ Int64

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fDataInt14
  :: (forall b. Data b => b -> b) -> Int64 -> Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (x0_Xe2PL [Occ=Once] :: Int64) -> x0_Xe2PL}]
Data.Data.$fDataInt14
  = \ _ [Occ=Dead] (x0_Xe2PL :: Int64) -> x0_Xe2PL

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt64_$cgmapQl
  :: forall r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> Int64 -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae5X0)
                 (@ r'_ae5X1)
                 _ [Occ=Dead]
                 (ds1_de7Nh [Occ=Once] :: r_ae5X0)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7Nh}]
Data.Data.$fDataInt64_$cgmapQl
  = \ (@ r_ae5X0)
      (@ r'_ae5X1)
      _ [Occ=Dead]
      (ds1_de7Nh :: r_ae5X0)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7Nh

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt64_$cgmapQr
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> Int64 -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae5Xh)
                 (@ r'_ae5Xi)
                 _ [Occ=Dead]
                 (ds1_de7Nk [Occ=Once] :: r_ae5Xh)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7Nk}]
Data.Data.$fDataInt64_$cgmapQr
  = \ (@ r_ae5Xh)
      (@ r'_ae5Xi)
      _ [Occ=Dead]
      (ds1_de7Nk :: r_ae5Xh)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7Nk

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
Data.Data.$fDataInt64_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> Int64 -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae5Xy) _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.[] @ u_ae5Xy}]
Data.Data.$fDataInt64_$cgmapQ
  = \ (@ u_ae5Xy) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.[] @ u_ae5Xy

-- RHS size: {terms: 5, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt64_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Int64 -> m Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLSL),1*U(A,A,A,1*U,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_ae5Y0 :: * -> *))
                 ($dMonad_ae5Y2 [Occ=Once] :: Monad m_ae5Y0)
                 _ [Occ=Dead] ->
                 return @ m_ae5Y0 $dMonad_ae5Y2 @ Int64}]
Data.Data.$fDataInt64_$cgmapM
  = \ (@ (m_ae5Y0 :: * -> *))
      ($dMonad_ae5Y2 :: Monad m_ae5Y0)
      _ [Occ=Dead] ->
      return @ m_ae5Y0 $dMonad_ae5Y2 @ Int64

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp20 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Int64 -> m Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMp20
  = \ (@ (m_seg5t :: * -> *))
      (w_seg5u :: MonadPlus m_seg5t)
      (w1_seg5w :: Int64) ->
      let {
        lvl270_se9Fy :: m_seg5t Int64
        [LclId]
        lvl270_se9Fy = mzero @ m_seg5t w_seg5u @ Int64 } in
      let {
        $dMonad_se9uj [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg5t
        [LclId]
        $dMonad_se9uj = GHC.Base.$p2MonadPlus @ m_seg5t w_seg5u } in
      >>=
        @ m_seg5t
        $dMonad_se9uj
        @ (Int64, Bool)
        @ Int64
        (return
           @ m_seg5t
           $dMonad_se9uj
           @ (Int64, Bool)
           (w1_seg5w, GHC.Types.False))
        (\ (ds_de7oa :: (Int64, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9Fy;
             True -> return @ m_seg5t $dMonad_se9uj @ Int64 x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt64_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Int64 -> m Int64
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg5t :: * -> *))
                 (w_seg5u [Occ=Once] :: MonadPlus m_seg5t)
                 _ [Occ=Dead]
                 (w2_seg5w [Occ=Once] :: Int64) ->
                 Data.Data.$w$cgmapMp20 @ m_seg5t w_seg5u w2_seg5w}]
Data.Data.$fDataInt64_$cgmapMp
  = \ (@ (m_seg5t :: * -> *))
      (w_seg5u :: MonadPlus m_seg5t)
      _ [Occ=Dead]
      (w2_seg5w :: Int64) ->
      Data.Data.$w$cgmapMp20 @ m_seg5t w_seg5u w2_seg5w

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataInt64_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> Int64 -> u
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae5XM) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Maybe.fromJust1 @ u_ae5XM}]
Data.Data.$fDataInt64_$cgmapQi
  = \ (@ u_ae5XM) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Maybe.fromJust1 @ u_ae5XM

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo19 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Int64 -> m Int64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMo19
  = \ (@ (m_seg5y :: * -> *))
      (w_seg5z :: MonadPlus m_seg5y)
      (w1_seg5B :: Int64) ->
      let {
        lvl270_se9Fz :: m_seg5y Int64
        [LclId]
        lvl270_se9Fz = mzero @ m_seg5y w_seg5z @ Int64 } in
      let {
        $dMonad_se9uh [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg5y
        [LclId]
        $dMonad_se9uh = GHC.Base.$p2MonadPlus @ m_seg5y w_seg5z } in
      >>=
        @ m_seg5y
        $dMonad_se9uh
        @ (Int64, Bool)
        @ Int64
        (return
           @ m_seg5y
           $dMonad_se9uh
           @ (Int64, Bool)
           (w1_seg5B, GHC.Types.False))
        (\ (ds_de7pa :: (Int64, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9Fz;
             True -> return @ m_seg5y $dMonad_se9uh @ Int64 x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt64_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Int64 -> m Int64
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg5y :: * -> *))
                 (w_seg5z [Occ=Once] :: MonadPlus m_seg5y)
                 _ [Occ=Dead]
                 (w2_seg5B [Occ=Once] :: Int64) ->
                 Data.Data.$w$cgmapMo19 @ m_seg5y w_seg5z w2_seg5B}]
Data.Data.$fDataInt64_$cgmapMo
  = \ (@ (m_seg5y :: * -> *))
      (w_seg5z :: MonadPlus m_seg5y)
      _ [Occ=Dead]
      (w2_seg5B :: Int64) ->
      Data.Data.$w$cgmapMo19 @ m_seg5y w_seg5z w2_seg5B

-- RHS size: {terms: 16, types: 1, coercions: 5, joins: 0/0}
Data.Data.$fDataInt64 [InlPrag=NOUSERINLINE CONLIKE] :: Data Int64
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: Int64
                        Data.Data.$fDataInt18
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Int64>_N
                                :: (Data.Typeable.Internal.TypeRep Int64 :: *)
                                   ~R# (Typeable Int64 :: Constraint))
                        Data.Data.$fDataInt64_$cgfoldl
                        Data.Data.$fDataInt64_$cgunfold
                        Data.Data.$fDataInt64_$ctoConstr
                        Data.Data.$fDataInt64_$cdataTypeOf
                        Data.Data.$fDataInt64_$cdataCast1
                        Data.Data.$fDataInt64_$cdataCast2
                        Data.Data.$fDataInt14
                        Data.Data.$fDataInt64_$cgmapQl
                        Data.Data.$fDataInt64_$cgmapQr
                        Data.Data.$fDataInt64_$cgmapQ
                        Data.Data.$fDataInt64_$cgmapQi
                        Data.Data.$fDataInt64_$cgmapM
                        Data.Data.$fDataInt64_$cgmapMp
                        Data.Data.$fDataInt64_$cgmapMo]
Data.Data.$fDataInt64
  = Data.Data.C:Data
      @ Int64
      (Data.Data.$fDataInt18
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Int64>_N
               :: (Data.Typeable.Internal.TypeRep Int64 :: *)
                  ~R# (Typeable Int64 :: Constraint)))
      Data.Data.$fDataInt64_$cgfoldl
      Data.Data.$fDataInt64_$cgunfold
      Data.Data.$fDataInt64_$ctoConstr
      Data.Data.$fDataInt64_$cdataTypeOf
      Data.Data.$fDataInt64_$cdataCast1
      Data.Data.$fDataInt64_$cdataCast2
      Data.Data.$fDataInt14
      Data.Data.$fDataInt64_$cgmapQl
      Data.Data.$fDataInt64_$cgmapQr
      Data.Data.$fDataInt64_$cgmapQ
      Data.Data.$fDataInt64_$cgmapQi
      Data.Data.$fDataInt64_$cgmapM
      Data.Data.$fDataInt64_$cgmapMp
      Data.Data.$fDataInt64_$cgmapMo

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataInt32_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c Int32)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae600 :: * -> * -> *))
                 (@ (c_ae601 :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae601 Int32)}]
Data.Data.$fDataInt32_$cdataCast2
  = \ (@ (t_ae600 :: * -> * -> *))
      (@ (c_ae601 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae601 Int32)

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataInt32_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c Int32)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae5ZH :: * -> *))
                 (@ (c_ae5ZI :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae5ZI Int32)}]
Data.Data.$fDataInt32_$cdataCast1
  = \ (@ (t_ae5ZH :: * -> *))
      (@ (c_ae5ZI :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5ZI Int32)

-- RHS size: {terms: 4, types: 22, coercions: 0, joins: 0/0}
Data.Data.$fDataInt32_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Int32 -> c Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (c_ae5YS :: * -> *))
                 _ [Occ=Dead]
                 (ds1_de7Nt [Occ=Once] :: forall g. g -> c_ae5YS g) ->
                 ds1_de7Nt @ Int32}]
Data.Data.$fDataInt32_$cgfoldl
  = \ (@ (c_ae5YS :: * -> *))
      _ [Occ=Dead]
      (ds1_de7Nt :: forall g. g -> c_ae5YS g) ->
      ds1_de7Nt @ Int32

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fDataInt10
  :: (forall b. Data b => b -> b) -> Int32 -> Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (x0_Xe2Q1 [Occ=Once] :: Int32) -> x0_Xe2Q1}]
Data.Data.$fDataInt10
  = \ _ [Occ=Dead] (x0_Xe2Q1 :: Int32) -> x0_Xe2Q1

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt32_$cgmapQl
  :: forall r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> Int32 -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae60y)
                 (@ r'_ae60z)
                 _ [Occ=Dead]
                 (ds1_de7NT [Occ=Once] :: r_ae60y)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7NT}]
Data.Data.$fDataInt32_$cgmapQl
  = \ (@ r_ae60y)
      (@ r'_ae60z)
      _ [Occ=Dead]
      (ds1_de7NT :: r_ae60y)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7NT

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt32_$cgmapQr
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> Int32 -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae60P)
                 (@ r'_ae60Q)
                 _ [Occ=Dead]
                 (ds1_de7NW [Occ=Once] :: r_ae60P)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7NW}]
Data.Data.$fDataInt32_$cgmapQr
  = \ (@ r_ae60P)
      (@ r'_ae60Q)
      _ [Occ=Dead]
      (ds1_de7NW :: r_ae60P)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7NW

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
Data.Data.$fDataInt32_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> Int32 -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae616) _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.[] @ u_ae616}]
Data.Data.$fDataInt32_$cgmapQ
  = \ (@ u_ae616) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.[] @ u_ae616

-- RHS size: {terms: 5, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt32_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Int32 -> m Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLSL),1*U(A,A,A,1*U,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_ae61y :: * -> *))
                 ($dMonad_ae61A [Occ=Once] :: Monad m_ae61y)
                 _ [Occ=Dead] ->
                 return @ m_ae61y $dMonad_ae61A @ Int32}]
Data.Data.$fDataInt32_$cgmapM
  = \ (@ (m_ae61y :: * -> *))
      ($dMonad_ae61A :: Monad m_ae61y)
      _ [Occ=Dead] ->
      return @ m_ae61y $dMonad_ae61A @ Int32

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp19 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Int32 -> m Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMp19
  = \ (@ (m_seg5D :: * -> *))
      (w_seg5E :: MonadPlus m_seg5D)
      (w1_seg5G :: Int32) ->
      let {
        lvl270_se9FA :: m_seg5D Int32
        [LclId]
        lvl270_se9FA = mzero @ m_seg5D w_seg5E @ Int32 } in
      let {
        $dMonad_se9uf [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg5D
        [LclId]
        $dMonad_se9uf = GHC.Base.$p2MonadPlus @ m_seg5D w_seg5E } in
      >>=
        @ m_seg5D
        $dMonad_se9uf
        @ (Int32, Bool)
        @ Int32
        (return
           @ m_seg5D
           $dMonad_se9uf
           @ (Int32, Bool)
           (w1_seg5G, GHC.Types.False))
        (\ (ds_de7oa :: (Int32, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9FA;
             True -> return @ m_seg5D $dMonad_se9uf @ Int32 x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt32_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Int32 -> m Int32
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg5D :: * -> *))
                 (w_seg5E [Occ=Once] :: MonadPlus m_seg5D)
                 _ [Occ=Dead]
                 (w2_seg5G [Occ=Once] :: Int32) ->
                 Data.Data.$w$cgmapMp19 @ m_seg5D w_seg5E w2_seg5G}]
Data.Data.$fDataInt32_$cgmapMp
  = \ (@ (m_seg5D :: * -> *))
      (w_seg5E :: MonadPlus m_seg5D)
      _ [Occ=Dead]
      (w2_seg5G :: Int32) ->
      Data.Data.$w$cgmapMp19 @ m_seg5D w_seg5E w2_seg5G

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataInt32_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> Int32 -> u
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae61k) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Maybe.fromJust1 @ u_ae61k}]
Data.Data.$fDataInt32_$cgmapQi
  = \ (@ u_ae61k) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Maybe.fromJust1 @ u_ae61k

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo18 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Int32 -> m Int32
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMo18
  = \ (@ (m_seg5I :: * -> *))
      (w_seg5J :: MonadPlus m_seg5I)
      (w1_seg5L :: Int32) ->
      let {
        lvl270_se9FB :: m_seg5I Int32
        [LclId]
        lvl270_se9FB = mzero @ m_seg5I w_seg5J @ Int32 } in
      let {
        $dMonad_se9ud [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg5I
        [LclId]
        $dMonad_se9ud = GHC.Base.$p2MonadPlus @ m_seg5I w_seg5J } in
      >>=
        @ m_seg5I
        $dMonad_se9ud
        @ (Int32, Bool)
        @ Int32
        (return
           @ m_seg5I
           $dMonad_se9ud
           @ (Int32, Bool)
           (w1_seg5L, GHC.Types.False))
        (\ (ds_de7pa :: (Int32, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9FB;
             True -> return @ m_seg5I $dMonad_se9ud @ Int32 x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt32_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Int32 -> m Int32
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg5I :: * -> *))
                 (w_seg5J [Occ=Once] :: MonadPlus m_seg5I)
                 _ [Occ=Dead]
                 (w2_seg5L [Occ=Once] :: Int32) ->
                 Data.Data.$w$cgmapMo18 @ m_seg5I w_seg5J w2_seg5L}]
Data.Data.$fDataInt32_$cgmapMo
  = \ (@ (m_seg5I :: * -> *))
      (w_seg5J :: MonadPlus m_seg5I)
      _ [Occ=Dead]
      (w2_seg5L :: Int32) ->
      Data.Data.$w$cgmapMo18 @ m_seg5I w_seg5J w2_seg5L

-- RHS size: {terms: 16, types: 1, coercions: 5, joins: 0/0}
Data.Data.$fDataInt32 [InlPrag=NOUSERINLINE CONLIKE] :: Data Int32
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: Int32
                        Data.Data.$fDataInt13
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Int32>_N
                                :: (Data.Typeable.Internal.TypeRep Int32 :: *)
                                   ~R# (Typeable Int32 :: Constraint))
                        Data.Data.$fDataInt32_$cgfoldl
                        Data.Data.$fDataInt32_$cgunfold
                        Data.Data.$fDataInt32_$ctoConstr
                        Data.Data.$fDataInt32_$cdataTypeOf
                        Data.Data.$fDataInt32_$cdataCast1
                        Data.Data.$fDataInt32_$cdataCast2
                        Data.Data.$fDataInt10
                        Data.Data.$fDataInt32_$cgmapQl
                        Data.Data.$fDataInt32_$cgmapQr
                        Data.Data.$fDataInt32_$cgmapQ
                        Data.Data.$fDataInt32_$cgmapQi
                        Data.Data.$fDataInt32_$cgmapM
                        Data.Data.$fDataInt32_$cgmapMp
                        Data.Data.$fDataInt32_$cgmapMo]
Data.Data.$fDataInt32
  = Data.Data.C:Data
      @ Int32
      (Data.Data.$fDataInt13
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Int32>_N
               :: (Data.Typeable.Internal.TypeRep Int32 :: *)
                  ~R# (Typeable Int32 :: Constraint)))
      Data.Data.$fDataInt32_$cgfoldl
      Data.Data.$fDataInt32_$cgunfold
      Data.Data.$fDataInt32_$ctoConstr
      Data.Data.$fDataInt32_$cdataTypeOf
      Data.Data.$fDataInt32_$cdataCast1
      Data.Data.$fDataInt32_$cdataCast2
      Data.Data.$fDataInt10
      Data.Data.$fDataInt32_$cgmapQl
      Data.Data.$fDataInt32_$cgmapQr
      Data.Data.$fDataInt32_$cgmapQ
      Data.Data.$fDataInt32_$cgmapQi
      Data.Data.$fDataInt32_$cgmapM
      Data.Data.$fDataInt32_$cgmapMp
      Data.Data.$fDataInt32_$cgmapMo

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataInt16_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c Int16)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae63y :: * -> * -> *))
                 (@ (c_ae63z :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae63z Int16)}]
Data.Data.$fDataInt16_$cdataCast2
  = \ (@ (t_ae63y :: * -> * -> *))
      (@ (c_ae63z :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae63z Int16)

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataInt16_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c Int16)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae63f :: * -> *))
                 (@ (c_ae63g :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae63g Int16)}]
Data.Data.$fDataInt16_$cdataCast1
  = \ (@ (t_ae63f :: * -> *))
      (@ (c_ae63g :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae63g Int16)

-- RHS size: {terms: 4, types: 22, coercions: 0, joins: 0/0}
Data.Data.$fDataInt16_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Int16 -> c Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (c_ae62q :: * -> *))
                 _ [Occ=Dead]
                 (ds1_de7O5 [Occ=Once] :: forall g. g -> c_ae62q g) ->
                 ds1_de7O5 @ Int16}]
Data.Data.$fDataInt16_$cgfoldl
  = \ (@ (c_ae62q :: * -> *))
      _ [Occ=Dead]
      (ds1_de7O5 :: forall g. g -> c_ae62q g) ->
      ds1_de7O5 @ Int16

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fDataInt5
  :: (forall b. Data b => b -> b) -> Int16 -> Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (x0_Xe2Qh [Occ=Once] :: Int16) -> x0_Xe2Qh}]
Data.Data.$fDataInt5
  = \ _ [Occ=Dead] (x0_Xe2Qh :: Int16) -> x0_Xe2Qh

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt16_$cgmapQl
  :: forall r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> Int16 -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae646)
                 (@ r'_ae647)
                 _ [Occ=Dead]
                 (ds1_de7Ov [Occ=Once] :: r_ae646)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7Ov}]
Data.Data.$fDataInt16_$cgmapQl
  = \ (@ r_ae646)
      (@ r'_ae647)
      _ [Occ=Dead]
      (ds1_de7Ov :: r_ae646)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7Ov

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt16_$cgmapQr
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> Int16 -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae64n)
                 (@ r'_ae64o)
                 _ [Occ=Dead]
                 (ds1_de7Oy [Occ=Once] :: r_ae64n)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7Oy}]
Data.Data.$fDataInt16_$cgmapQr
  = \ (@ r_ae64n)
      (@ r'_ae64o)
      _ [Occ=Dead]
      (ds1_de7Oy :: r_ae64n)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7Oy

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
Data.Data.$fDataInt16_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> Int16 -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae64E) _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.[] @ u_ae64E}]
Data.Data.$fDataInt16_$cgmapQ
  = \ (@ u_ae64E) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.[] @ u_ae64E

-- RHS size: {terms: 5, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt16_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Int16 -> m Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLSL),1*U(A,A,A,1*U,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_ae656 :: * -> *))
                 ($dMonad_ae658 [Occ=Once] :: Monad m_ae656)
                 _ [Occ=Dead] ->
                 return @ m_ae656 $dMonad_ae658 @ Int16}]
Data.Data.$fDataInt16_$cgmapM
  = \ (@ (m_ae656 :: * -> *))
      ($dMonad_ae658 :: Monad m_ae656)
      _ [Occ=Dead] ->
      return @ m_ae656 $dMonad_ae658 @ Int16

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp18 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Int16 -> m Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMp18
  = \ (@ (m_seg5N :: * -> *))
      (w_seg5O :: MonadPlus m_seg5N)
      (w1_seg5Q :: Int16) ->
      let {
        lvl270_se9FC :: m_seg5N Int16
        [LclId]
        lvl270_se9FC = mzero @ m_seg5N w_seg5O @ Int16 } in
      let {
        $dMonad_se9ub [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg5N
        [LclId]
        $dMonad_se9ub = GHC.Base.$p2MonadPlus @ m_seg5N w_seg5O } in
      >>=
        @ m_seg5N
        $dMonad_se9ub
        @ (Int16, Bool)
        @ Int16
        (return
           @ m_seg5N
           $dMonad_se9ub
           @ (Int16, Bool)
           (w1_seg5Q, GHC.Types.False))
        (\ (ds_de7oa :: (Int16, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9FC;
             True -> return @ m_seg5N $dMonad_se9ub @ Int16 x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt16_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Int16 -> m Int16
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg5N :: * -> *))
                 (w_seg5O [Occ=Once] :: MonadPlus m_seg5N)
                 _ [Occ=Dead]
                 (w2_seg5Q [Occ=Once] :: Int16) ->
                 Data.Data.$w$cgmapMp18 @ m_seg5N w_seg5O w2_seg5Q}]
Data.Data.$fDataInt16_$cgmapMp
  = \ (@ (m_seg5N :: * -> *))
      (w_seg5O :: MonadPlus m_seg5N)
      _ [Occ=Dead]
      (w2_seg5Q :: Int16) ->
      Data.Data.$w$cgmapMp18 @ m_seg5N w_seg5O w2_seg5Q

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataInt16_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> Int16 -> u
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae64S) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Maybe.fromJust1 @ u_ae64S}]
Data.Data.$fDataInt16_$cgmapQi
  = \ (@ u_ae64S) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Maybe.fromJust1 @ u_ae64S

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo17 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Int16 -> m Int16
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMo17
  = \ (@ (m_seg5S :: * -> *))
      (w_seg5T :: MonadPlus m_seg5S)
      (w1_seg5V :: Int16) ->
      let {
        lvl270_se9FD :: m_seg5S Int16
        [LclId]
        lvl270_se9FD = mzero @ m_seg5S w_seg5T @ Int16 } in
      let {
        $dMonad_se9u9 [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg5S
        [LclId]
        $dMonad_se9u9 = GHC.Base.$p2MonadPlus @ m_seg5S w_seg5T } in
      >>=
        @ m_seg5S
        $dMonad_se9u9
        @ (Int16, Bool)
        @ Int16
        (return
           @ m_seg5S
           $dMonad_se9u9
           @ (Int16, Bool)
           (w1_seg5V, GHC.Types.False))
        (\ (ds_de7pa :: (Int16, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9FD;
             True -> return @ m_seg5S $dMonad_se9u9 @ Int16 x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt16_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Int16 -> m Int16
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg5S :: * -> *))
                 (w_seg5T [Occ=Once] :: MonadPlus m_seg5S)
                 _ [Occ=Dead]
                 (w2_seg5V [Occ=Once] :: Int16) ->
                 Data.Data.$w$cgmapMo17 @ m_seg5S w_seg5T w2_seg5V}]
Data.Data.$fDataInt16_$cgmapMo
  = \ (@ (m_seg5S :: * -> *))
      (w_seg5T :: MonadPlus m_seg5S)
      _ [Occ=Dead]
      (w2_seg5V :: Int16) ->
      Data.Data.$w$cgmapMo17 @ m_seg5S w_seg5T w2_seg5V

-- RHS size: {terms: 16, types: 1, coercions: 5, joins: 0/0}
Data.Data.$fDataInt16 [InlPrag=NOUSERINLINE CONLIKE] :: Data Int16
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: Int16
                        Data.Data.$fDataInt9
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Int16>_N
                                :: (Data.Typeable.Internal.TypeRep Int16 :: *)
                                   ~R# (Typeable Int16 :: Constraint))
                        Data.Data.$fDataInt16_$cgfoldl
                        Data.Data.$fDataInt16_$cgunfold
                        Data.Data.$fDataInt16_$ctoConstr
                        Data.Data.$fDataInt16_$cdataTypeOf
                        Data.Data.$fDataInt16_$cdataCast1
                        Data.Data.$fDataInt16_$cdataCast2
                        Data.Data.$fDataInt5
                        Data.Data.$fDataInt16_$cgmapQl
                        Data.Data.$fDataInt16_$cgmapQr
                        Data.Data.$fDataInt16_$cgmapQ
                        Data.Data.$fDataInt16_$cgmapQi
                        Data.Data.$fDataInt16_$cgmapM
                        Data.Data.$fDataInt16_$cgmapMp
                        Data.Data.$fDataInt16_$cgmapMo]
Data.Data.$fDataInt16
  = Data.Data.C:Data
      @ Int16
      (Data.Data.$fDataInt9
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Int16>_N
               :: (Data.Typeable.Internal.TypeRep Int16 :: *)
                  ~R# (Typeable Int16 :: Constraint)))
      Data.Data.$fDataInt16_$cgfoldl
      Data.Data.$fDataInt16_$cgunfold
      Data.Data.$fDataInt16_$ctoConstr
      Data.Data.$fDataInt16_$cdataTypeOf
      Data.Data.$fDataInt16_$cdataCast1
      Data.Data.$fDataInt16_$cdataCast2
      Data.Data.$fDataInt5
      Data.Data.$fDataInt16_$cgmapQl
      Data.Data.$fDataInt16_$cgmapQr
      Data.Data.$fDataInt16_$cgmapQ
      Data.Data.$fDataInt16_$cgmapQi
      Data.Data.$fDataInt16_$cgmapM
      Data.Data.$fDataInt16_$cgmapMp
      Data.Data.$fDataInt16_$cgmapMo

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataInt8_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c Int8)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae676 :: * -> * -> *))
                 (@ (c_ae677 :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae677 Int8)}]
Data.Data.$fDataInt8_$cdataCast2
  = \ (@ (t_ae676 :: * -> * -> *))
      (@ (c_ae677 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae677 Int8)

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataInt8_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c Int8)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae66N :: * -> *))
                 (@ (c_ae66O :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae66O Int8)}]
Data.Data.$fDataInt8_$cdataCast1
  = \ (@ (t_ae66N :: * -> *))
      (@ (c_ae66O :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae66O Int8)

-- RHS size: {terms: 4, types: 22, coercions: 0, joins: 0/0}
Data.Data.$fDataInt8_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Int8 -> c Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (c_ae65Y :: * -> *))
                 _ [Occ=Dead]
                 (ds1_de7OH [Occ=Once] :: forall g. g -> c_ae65Y g) ->
                 ds1_de7OH @ Int8}]
Data.Data.$fDataInt8_$cgfoldl
  = \ (@ (c_ae65Y :: * -> *))
      _ [Occ=Dead]
      (ds1_de7OH :: forall g. g -> c_ae65Y g) ->
      ds1_de7OH @ Int8

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fDataInt19
  :: (forall b. Data b => b -> b) -> Int8 -> Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (x0_Xe2Qx [Occ=Once] :: Int8) -> x0_Xe2Qx}]
Data.Data.$fDataInt19
  = \ _ [Occ=Dead] (x0_Xe2Qx :: Int8) -> x0_Xe2Qx

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt8_$cgmapQl
  :: forall r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> Int8 -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae67E)
                 (@ r'_ae67F)
                 _ [Occ=Dead]
                 (ds1_de7P7 [Occ=Once] :: r_ae67E)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7P7}]
Data.Data.$fDataInt8_$cgmapQl
  = \ (@ r_ae67E)
      (@ r'_ae67F)
      _ [Occ=Dead]
      (ds1_de7P7 :: r_ae67E)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7P7

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt8_$cgmapQr
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> Int8 -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae67V)
                 (@ r'_ae67W)
                 _ [Occ=Dead]
                 (ds1_de7Pa [Occ=Once] :: r_ae67V)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7Pa}]
Data.Data.$fDataInt8_$cgmapQr
  = \ (@ r_ae67V)
      (@ r'_ae67W)
      _ [Occ=Dead]
      (ds1_de7Pa :: r_ae67V)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7Pa

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
Data.Data.$fDataInt8_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> Int8 -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae68c) _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.[] @ u_ae68c}]
Data.Data.$fDataInt8_$cgmapQ
  = \ (@ u_ae68c) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.[] @ u_ae68c

-- RHS size: {terms: 5, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt8_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Int8 -> m Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLSL),1*U(A,A,A,1*U,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_ae68E :: * -> *))
                 ($dMonad_ae68G [Occ=Once] :: Monad m_ae68E)
                 _ [Occ=Dead] ->
                 return @ m_ae68E $dMonad_ae68G @ Int8}]
Data.Data.$fDataInt8_$cgmapM
  = \ (@ (m_ae68E :: * -> *))
      ($dMonad_ae68G :: Monad m_ae68E)
      _ [Occ=Dead] ->
      return @ m_ae68E $dMonad_ae68G @ Int8

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp21 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Int8 -> m Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMp21
  = \ (@ (m_seg5X :: * -> *))
      (w_seg5Y :: MonadPlus m_seg5X)
      (w1_seg60 :: Int8) ->
      let {
        lvl270_se9FE :: m_seg5X Int8
        [LclId]
        lvl270_se9FE = mzero @ m_seg5X w_seg5Y @ Int8 } in
      let {
        $dMonad_se9u7 [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg5X
        [LclId]
        $dMonad_se9u7 = GHC.Base.$p2MonadPlus @ m_seg5X w_seg5Y } in
      >>=
        @ m_seg5X
        $dMonad_se9u7
        @ (Int8, Bool)
        @ Int8
        (return
           @ m_seg5X $dMonad_se9u7 @ (Int8, Bool) (w1_seg60, GHC.Types.False))
        (\ (ds_de7oa :: (Int8, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9FE;
             True -> return @ m_seg5X $dMonad_se9u7 @ Int8 x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt8_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Int8 -> m Int8
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg5X :: * -> *))
                 (w_seg5Y [Occ=Once] :: MonadPlus m_seg5X)
                 _ [Occ=Dead]
                 (w2_seg60 [Occ=Once] :: Int8) ->
                 Data.Data.$w$cgmapMp21 @ m_seg5X w_seg5Y w2_seg60}]
Data.Data.$fDataInt8_$cgmapMp
  = \ (@ (m_seg5X :: * -> *))
      (w_seg5Y :: MonadPlus m_seg5X)
      _ [Occ=Dead]
      (w2_seg60 :: Int8) ->
      Data.Data.$w$cgmapMp21 @ m_seg5X w_seg5Y w2_seg60

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataInt8_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> Int8 -> u
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae68q) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Maybe.fromJust1 @ u_ae68q}]
Data.Data.$fDataInt8_$cgmapQi
  = \ (@ u_ae68q) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Maybe.fromJust1 @ u_ae68q

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo20 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Int8 -> m Int8
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMo20
  = \ (@ (m_seg62 :: * -> *))
      (w_seg63 :: MonadPlus m_seg62)
      (w1_seg65 :: Int8) ->
      let {
        lvl270_se9FF :: m_seg62 Int8
        [LclId]
        lvl270_se9FF = mzero @ m_seg62 w_seg63 @ Int8 } in
      let {
        $dMonad_se9u5 [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg62
        [LclId]
        $dMonad_se9u5 = GHC.Base.$p2MonadPlus @ m_seg62 w_seg63 } in
      >>=
        @ m_seg62
        $dMonad_se9u5
        @ (Int8, Bool)
        @ Int8
        (return
           @ m_seg62 $dMonad_se9u5 @ (Int8, Bool) (w1_seg65, GHC.Types.False))
        (\ (ds_de7pa :: (Int8, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9FF;
             True -> return @ m_seg62 $dMonad_se9u5 @ Int8 x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInt8_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Int8 -> m Int8
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg62 :: * -> *))
                 (w_seg63 [Occ=Once] :: MonadPlus m_seg62)
                 _ [Occ=Dead]
                 (w2_seg65 [Occ=Once] :: Int8) ->
                 Data.Data.$w$cgmapMo20 @ m_seg62 w_seg63 w2_seg65}]
Data.Data.$fDataInt8_$cgmapMo
  = \ (@ (m_seg62 :: * -> *))
      (w_seg63 :: MonadPlus m_seg62)
      _ [Occ=Dead]
      (w2_seg65 :: Int8) ->
      Data.Data.$w$cgmapMo20 @ m_seg62 w_seg63 w2_seg65

-- RHS size: {terms: 16, types: 1, coercions: 5, joins: 0/0}
Data.Data.$fDataInt8 [InlPrag=NOUSERINLINE CONLIKE] :: Data Int8
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: Int8
                        Data.Data.$fDataInt22
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Int8>_N
                                :: (Data.Typeable.Internal.TypeRep Int8 :: *)
                                   ~R# (Typeable Int8 :: Constraint))
                        Data.Data.$fDataInt8_$cgfoldl
                        Data.Data.$fDataInt8_$cgunfold
                        Data.Data.$fDataInt8_$ctoConstr
                        Data.Data.$fDataInt8_$cdataTypeOf
                        Data.Data.$fDataInt8_$cdataCast1
                        Data.Data.$fDataInt8_$cdataCast2
                        Data.Data.$fDataInt19
                        Data.Data.$fDataInt8_$cgmapQl
                        Data.Data.$fDataInt8_$cgmapQr
                        Data.Data.$fDataInt8_$cgmapQ
                        Data.Data.$fDataInt8_$cgmapQi
                        Data.Data.$fDataInt8_$cgmapM
                        Data.Data.$fDataInt8_$cgmapMp
                        Data.Data.$fDataInt8_$cgmapMo]
Data.Data.$fDataInt8
  = Data.Data.C:Data
      @ Int8
      (Data.Data.$fDataInt22
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Int8>_N
               :: (Data.Typeable.Internal.TypeRep Int8 :: *)
                  ~R# (Typeable Int8 :: Constraint)))
      Data.Data.$fDataInt8_$cgfoldl
      Data.Data.$fDataInt8_$cgunfold
      Data.Data.$fDataInt8_$ctoConstr
      Data.Data.$fDataInt8_$cdataTypeOf
      Data.Data.$fDataInt8_$cdataCast1
      Data.Data.$fDataInt8_$cdataCast2
      Data.Data.$fDataInt19
      Data.Data.$fDataInt8_$cgmapQl
      Data.Data.$fDataInt8_$cgmapQr
      Data.Data.$fDataInt8_$cgmapQ
      Data.Data.$fDataInt8_$cgmapQi
      Data.Data.$fDataInt8_$cgmapM
      Data.Data.$fDataInt8_$cgmapMp
      Data.Data.$fDataInt8_$cgmapMo

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataNatural_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c Natural)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae6aE :: * -> * -> *))
                 (@ (c_ae6aF :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae6aF Natural)}]
Data.Data.$fDataNatural_$cdataCast2
  = \ (@ (t_ae6aE :: * -> * -> *))
      (@ (c_ae6aF :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae6aF Natural)

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataNatural_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c Natural)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae6al :: * -> *))
                 (@ (c_ae6am :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae6am Natural)}]
Data.Data.$fDataNatural_$cdataCast1
  = \ (@ (t_ae6al :: * -> *))
      (@ (c_ae6am :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae6am Natural)

-- RHS size: {terms: 4, types: 22, coercions: 0, joins: 0/0}
Data.Data.$fDataNatural_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Natural -> c Natural
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (c_ae69w :: * -> *))
                 _ [Occ=Dead]
                 (ds1_de7Pj [Occ=Once] :: forall g. g -> c_ae69w g) ->
                 ds1_de7Pj @ Natural}]
Data.Data.$fDataNatural_$cgfoldl
  = \ (@ (c_ae69w :: * -> *))
      _ [Occ=Dead]
      (ds1_de7Pj :: forall g. g -> c_ae69w g) ->
      ds1_de7Pj @ Natural

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fDataNatural1
  :: (forall b. Data b => b -> b) -> Natural -> Natural
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (x0_Xe2QN [Occ=Once] :: Natural) -> x0_Xe2QN}]
Data.Data.$fDataNatural1
  = \ _ [Occ=Dead] (x0_Xe2QN :: Natural) -> x0_Xe2QN

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataNatural_$cgmapQl
  :: forall r r'.
     (r -> r' -> r)
     -> r -> (forall d. Data d => d -> r') -> Natural -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae6bc)
                 (@ r'_ae6bd)
                 _ [Occ=Dead]
                 (ds1_de7PJ [Occ=Once] :: r_ae6bc)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7PJ}]
Data.Data.$fDataNatural_$cgmapQl
  = \ (@ r_ae6bc)
      (@ r'_ae6bd)
      _ [Occ=Dead]
      (ds1_de7PJ :: r_ae6bc)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7PJ

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataNatural_$cgmapQr
  :: forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> Natural -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae6bt)
                 (@ r'_ae6bu)
                 _ [Occ=Dead]
                 (ds1_de7PM [Occ=Once] :: r_ae6bt)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7PM}]
Data.Data.$fDataNatural_$cgmapQr
  = \ (@ r_ae6bt)
      (@ r'_ae6bu)
      _ [Occ=Dead]
      (ds1_de7PM :: r_ae6bt)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7PM

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
Data.Data.$fDataNatural_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> Natural -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae6bK) _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.[] @ u_ae6bK}]
Data.Data.$fDataNatural_$cgmapQ
  = \ (@ u_ae6bK) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.[] @ u_ae6bK

-- RHS size: {terms: 5, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataNatural_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Natural -> m Natural
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLSL),1*U(A,A,A,1*U,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_ae6cc :: * -> *))
                 ($dMonad_ae6ce [Occ=Once] :: Monad m_ae6cc)
                 _ [Occ=Dead] ->
                 return @ m_ae6cc $dMonad_ae6ce @ Natural}]
Data.Data.$fDataNatural_$cgmapM
  = \ (@ (m_ae6cc :: * -> *))
      ($dMonad_ae6ce :: Monad m_ae6cc)
      _ [Occ=Dead] ->
      return @ m_ae6cc $dMonad_ae6ce @ Natural

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp25 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Natural -> m Natural
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMp25
  = \ (@ (m_seg67 :: * -> *))
      (w_seg68 :: MonadPlus m_seg67)
      (w1_seg6a :: Natural) ->
      let {
        lvl270_se9FG :: m_seg67 Natural
        [LclId]
        lvl270_se9FG = mzero @ m_seg67 w_seg68 @ Natural } in
      let {
        $dMonad_se9u3 [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg67
        [LclId]
        $dMonad_se9u3 = GHC.Base.$p2MonadPlus @ m_seg67 w_seg68 } in
      >>=
        @ m_seg67
        $dMonad_se9u3
        @ (Natural, Bool)
        @ Natural
        (return
           @ m_seg67
           $dMonad_se9u3
           @ (Natural, Bool)
           (w1_seg6a, GHC.Types.False))
        (\ (ds_de7oa :: (Natural, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9FG;
             True -> return @ m_seg67 $dMonad_se9u3 @ Natural x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataNatural_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Natural -> m Natural
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg67 :: * -> *))
                 (w_seg68 [Occ=Once] :: MonadPlus m_seg67)
                 _ [Occ=Dead]
                 (w2_seg6a [Occ=Once] :: Natural) ->
                 Data.Data.$w$cgmapMp25 @ m_seg67 w_seg68 w2_seg6a}]
Data.Data.$fDataNatural_$cgmapMp
  = \ (@ (m_seg67 :: * -> *))
      (w_seg68 :: MonadPlus m_seg67)
      _ [Occ=Dead]
      (w2_seg6a :: Natural) ->
      Data.Data.$w$cgmapMp25 @ m_seg67 w_seg68 w2_seg6a

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataNatural_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> Natural -> u
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae6bY) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Maybe.fromJust1 @ u_ae6bY}]
Data.Data.$fDataNatural_$cgmapQi
  = \ (@ u_ae6bY) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Maybe.fromJust1 @ u_ae6bY

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo24 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Natural -> m Natural
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMo24
  = \ (@ (m_seg6c :: * -> *))
      (w_seg6d :: MonadPlus m_seg6c)
      (w1_seg6f :: Natural) ->
      let {
        lvl270_se9FH :: m_seg6c Natural
        [LclId]
        lvl270_se9FH = mzero @ m_seg6c w_seg6d @ Natural } in
      let {
        $dMonad_se9u1 [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg6c
        [LclId]
        $dMonad_se9u1 = GHC.Base.$p2MonadPlus @ m_seg6c w_seg6d } in
      >>=
        @ m_seg6c
        $dMonad_se9u1
        @ (Natural, Bool)
        @ Natural
        (return
           @ m_seg6c
           $dMonad_se9u1
           @ (Natural, Bool)
           (w1_seg6f, GHC.Types.False))
        (\ (ds_de7pa :: (Natural, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9FH;
             True -> return @ m_seg6c $dMonad_se9u1 @ Natural x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataNatural_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Natural -> m Natural
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg6c :: * -> *))
                 (w_seg6d [Occ=Once] :: MonadPlus m_seg6c)
                 _ [Occ=Dead]
                 (w2_seg6f [Occ=Once] :: Natural) ->
                 Data.Data.$w$cgmapMo24 @ m_seg6c w_seg6d w2_seg6f}]
Data.Data.$fDataNatural_$cgmapMo
  = \ (@ (m_seg6c :: * -> *))
      (w_seg6d :: MonadPlus m_seg6c)
      _ [Occ=Dead]
      (w2_seg6f :: Natural) ->
      Data.Data.$w$cgmapMo24 @ m_seg6c w_seg6d w2_seg6f

-- RHS size: {terms: 16, types: 1, coercions: 5, joins: 0/0}
Data.Data.$fDataNatural [InlPrag=NOUSERINLINE CONLIKE]
  :: Data Natural
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: Natural
                        Data.Data.$fDataNatural5
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Natural>_N
                                :: (Data.Typeable.Internal.TypeRep Natural :: *)
                                   ~R# (Typeable Natural :: Constraint))
                        Data.Data.$fDataNatural_$cgfoldl
                        Data.Data.$fDataNatural_$cgunfold
                        Data.Data.$fDataNatural_$ctoConstr
                        Data.Data.$fDataNatural_$cdataTypeOf
                        Data.Data.$fDataNatural_$cdataCast1
                        Data.Data.$fDataNatural_$cdataCast2
                        Data.Data.$fDataNatural1
                        Data.Data.$fDataNatural_$cgmapQl
                        Data.Data.$fDataNatural_$cgmapQr
                        Data.Data.$fDataNatural_$cgmapQ
                        Data.Data.$fDataNatural_$cgmapQi
                        Data.Data.$fDataNatural_$cgmapM
                        Data.Data.$fDataNatural_$cgmapMp
                        Data.Data.$fDataNatural_$cgmapMo]
Data.Data.$fDataNatural
  = Data.Data.C:Data
      @ Natural
      (Data.Data.$fDataNatural5
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Natural>_N
               :: (Data.Typeable.Internal.TypeRep Natural :: *)
                  ~R# (Typeable Natural :: Constraint)))
      Data.Data.$fDataNatural_$cgfoldl
      Data.Data.$fDataNatural_$cgunfold
      Data.Data.$fDataNatural_$ctoConstr
      Data.Data.$fDataNatural_$cdataTypeOf
      Data.Data.$fDataNatural_$cdataCast1
      Data.Data.$fDataNatural_$cdataCast2
      Data.Data.$fDataNatural1
      Data.Data.$fDataNatural_$cgmapQl
      Data.Data.$fDataNatural_$cgmapQr
      Data.Data.$fDataNatural_$cgmapQ
      Data.Data.$fDataNatural_$cgmapQi
      Data.Data.$fDataNatural_$cgmapM
      Data.Data.$fDataNatural_$cgmapMp
      Data.Data.$fDataNatural_$cgmapMo

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataInteger_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c Integer)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae6e8 :: * -> * -> *))
                 (@ (c_ae6e9 :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae6e9 Integer)}]
Data.Data.$fDataInteger_$cdataCast2
  = \ (@ (t_ae6e8 :: * -> * -> *))
      (@ (c_ae6e9 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae6e9 Integer)

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataInteger_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c Integer)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae6dP :: * -> *))
                 (@ (c_ae6dQ :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae6dQ Integer)}]
Data.Data.$fDataInteger_$cdataCast1
  = \ (@ (t_ae6dP :: * -> *))
      (@ (c_ae6dQ :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae6dQ Integer)

-- RHS size: {terms: 4, types: 22, coercions: 0, joins: 0/0}
Data.Data.$fDataInteger_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Integer -> c Integer
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (c_ae6d4 :: * -> *))
                 _ [Occ=Dead]
                 (ds1_de7PV [Occ=Once] :: forall g. g -> c_ae6d4 g) ->
                 ds1_de7PV @ Integer}]
Data.Data.$fDataInteger_$cgfoldl
  = \ (@ (c_ae6d4 :: * -> *))
      _ [Occ=Dead]
      (ds1_de7PV :: forall g. g -> c_ae6d4 g) ->
      ds1_de7PV @ Integer

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fDataInteger1
  :: (forall b. Data b => b -> b) -> Integer -> Integer
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (x0_Xe2R3 [Occ=Once] :: Integer) -> x0_Xe2R3}]
Data.Data.$fDataInteger1
  = \ _ [Occ=Dead] (x0_Xe2R3 :: Integer) -> x0_Xe2R3

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInteger_$cgmapQl
  :: forall r r'.
     (r -> r' -> r)
     -> r -> (forall d. Data d => d -> r') -> Integer -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae6eG)
                 (@ r'_ae6eH)
                 _ [Occ=Dead]
                 (ds1_de7Ql [Occ=Once] :: r_ae6eG)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7Ql}]
Data.Data.$fDataInteger_$cgmapQl
  = \ (@ r_ae6eG)
      (@ r'_ae6eH)
      _ [Occ=Dead]
      (ds1_de7Ql :: r_ae6eG)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7Ql

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInteger_$cgmapQr
  :: forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> Integer -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae6eX)
                 (@ r'_ae6eY)
                 _ [Occ=Dead]
                 (ds1_de7Qo [Occ=Once] :: r_ae6eX)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7Qo}]
Data.Data.$fDataInteger_$cgmapQr
  = \ (@ r_ae6eX)
      (@ r'_ae6eY)
      _ [Occ=Dead]
      (ds1_de7Qo :: r_ae6eX)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7Qo

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
Data.Data.$fDataInteger_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> Integer -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae6fe) _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.[] @ u_ae6fe}]
Data.Data.$fDataInteger_$cgmapQ
  = \ (@ u_ae6fe) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.[] @ u_ae6fe

-- RHS size: {terms: 5, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInteger_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Integer -> m Integer
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLSL),1*U(A,A,A,1*U,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_ae6fG :: * -> *))
                 ($dMonad_ae6fI [Occ=Once] :: Monad m_ae6fG)
                 _ [Occ=Dead] ->
                 return @ m_ae6fG $dMonad_ae6fI @ Integer}]
Data.Data.$fDataInteger_$cgmapM
  = \ (@ (m_ae6fG :: * -> *))
      ($dMonad_ae6fI :: Monad m_ae6fG)
      _ [Occ=Dead] ->
      return @ m_ae6fG $dMonad_ae6fI @ Integer

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp22 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Integer -> m Integer
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMp22
  = \ (@ (m_seg6h :: * -> *))
      (w_seg6i :: MonadPlus m_seg6h)
      (w1_seg6k :: Integer) ->
      let {
        lvl270_se9FI :: m_seg6h Integer
        [LclId]
        lvl270_se9FI = mzero @ m_seg6h w_seg6i @ Integer } in
      let {
        $dMonad_se9tZ [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg6h
        [LclId]
        $dMonad_se9tZ = GHC.Base.$p2MonadPlus @ m_seg6h w_seg6i } in
      >>=
        @ m_seg6h
        $dMonad_se9tZ
        @ (Integer, Bool)
        @ Integer
        (return
           @ m_seg6h
           $dMonad_se9tZ
           @ (Integer, Bool)
           (w1_seg6k, GHC.Types.False))
        (\ (ds_de7oa :: (Integer, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9FI;
             True -> return @ m_seg6h $dMonad_se9tZ @ Integer x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInteger_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Integer -> m Integer
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg6h :: * -> *))
                 (w_seg6i [Occ=Once] :: MonadPlus m_seg6h)
                 _ [Occ=Dead]
                 (w2_seg6k [Occ=Once] :: Integer) ->
                 Data.Data.$w$cgmapMp22 @ m_seg6h w_seg6i w2_seg6k}]
Data.Data.$fDataInteger_$cgmapMp
  = \ (@ (m_seg6h :: * -> *))
      (w_seg6i :: MonadPlus m_seg6h)
      _ [Occ=Dead]
      (w2_seg6k :: Integer) ->
      Data.Data.$w$cgmapMp22 @ m_seg6h w_seg6i w2_seg6k

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataInteger_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> Integer -> u
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae6fs) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Maybe.fromJust1 @ u_ae6fs}]
Data.Data.$fDataInteger_$cgmapQi
  = \ (@ u_ae6fs) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Maybe.fromJust1 @ u_ae6fs

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo21 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Integer -> m Integer
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMo21
  = \ (@ (m_seg6m :: * -> *))
      (w_seg6n :: MonadPlus m_seg6m)
      (w1_seg6p :: Integer) ->
      let {
        lvl270_se9FJ :: m_seg6m Integer
        [LclId]
        lvl270_se9FJ = mzero @ m_seg6m w_seg6n @ Integer } in
      let {
        $dMonad_se9tX [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg6m
        [LclId]
        $dMonad_se9tX = GHC.Base.$p2MonadPlus @ m_seg6m w_seg6n } in
      >>=
        @ m_seg6m
        $dMonad_se9tX
        @ (Integer, Bool)
        @ Integer
        (return
           @ m_seg6m
           $dMonad_se9tX
           @ (Integer, Bool)
           (w1_seg6p, GHC.Types.False))
        (\ (ds_de7pa :: (Integer, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9FJ;
             True -> return @ m_seg6m $dMonad_se9tX @ Integer x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataInteger_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Integer -> m Integer
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg6m :: * -> *))
                 (w_seg6n [Occ=Once] :: MonadPlus m_seg6m)
                 _ [Occ=Dead]
                 (w2_seg6p [Occ=Once] :: Integer) ->
                 Data.Data.$w$cgmapMo21 @ m_seg6m w_seg6n w2_seg6p}]
Data.Data.$fDataInteger_$cgmapMo
  = \ (@ (m_seg6m :: * -> *))
      (w_seg6n :: MonadPlus m_seg6m)
      _ [Occ=Dead]
      (w2_seg6p :: Integer) ->
      Data.Data.$w$cgmapMo21 @ m_seg6m w_seg6n w2_seg6p

-- RHS size: {terms: 16, types: 1, coercions: 5, joins: 0/0}
Data.Data.$fDataInteger [InlPrag=NOUSERINLINE CONLIKE]
  :: Data Integer
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: Integer
                        Data.Data.$fDataInteger5
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Integer>_N
                                :: (Data.Typeable.Internal.TypeRep Integer :: *)
                                   ~R# (Typeable Integer :: Constraint))
                        Data.Data.$fDataInteger_$cgfoldl
                        Data.Data.$fDataInteger_$cgunfold
                        Data.Data.$fDataInteger_$ctoConstr
                        Data.Data.$fDataInteger_$cdataTypeOf
                        Data.Data.$fDataInteger_$cdataCast1
                        Data.Data.$fDataInteger_$cdataCast2
                        Data.Data.$fDataInteger1
                        Data.Data.$fDataInteger_$cgmapQl
                        Data.Data.$fDataInteger_$cgmapQr
                        Data.Data.$fDataInteger_$cgmapQ
                        Data.Data.$fDataInteger_$cgmapQi
                        Data.Data.$fDataInteger_$cgmapM
                        Data.Data.$fDataInteger_$cgmapMp
                        Data.Data.$fDataInteger_$cgmapMo]
Data.Data.$fDataInteger
  = Data.Data.C:Data
      @ Integer
      (Data.Data.$fDataInteger5
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Integer>_N
               :: (Data.Typeable.Internal.TypeRep Integer :: *)
                  ~R# (Typeable Integer :: Constraint)))
      Data.Data.$fDataInteger_$cgfoldl
      Data.Data.$fDataInteger_$cgunfold
      Data.Data.$fDataInteger_$ctoConstr
      Data.Data.$fDataInteger_$cdataTypeOf
      Data.Data.$fDataInteger_$cdataCast1
      Data.Data.$fDataInteger_$cdataCast2
      Data.Data.$fDataInteger1
      Data.Data.$fDataInteger_$cgmapQl
      Data.Data.$fDataInteger_$cgmapQr
      Data.Data.$fDataInteger_$cgmapQ
      Data.Data.$fDataInteger_$cgmapQi
      Data.Data.$fDataInteger_$cgmapM
      Data.Data.$fDataInteger_$cgmapMp
      Data.Data.$fDataInteger_$cgmapMo

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataFloat_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c Float)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae6oP :: * -> * -> *))
                 (@ (c_ae6oQ :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae6oQ Float)}]
Data.Data.$fDataFloat_$cdataCast2
  = \ (@ (t_ae6oP :: * -> * -> *))
      (@ (c_ae6oQ :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae6oQ Float)

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataFloat_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c Float)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae6ow :: * -> *))
                 (@ (c_ae6ox :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae6ox Float)}]
Data.Data.$fDataFloat_$cdataCast1
  = \ (@ (t_ae6ow :: * -> *))
      (@ (c_ae6ox :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae6ox Float)

-- RHS size: {terms: 4, types: 22, coercions: 0, joins: 0/0}
Data.Data.$fDataFloat_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Float -> c Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (c_ae6nH :: * -> *))
                 _ [Occ=Dead]
                 (ds1_de7RQ [Occ=Once] :: forall g. g -> c_ae6nH g) ->
                 ds1_de7RQ @ Float}]
Data.Data.$fDataFloat_$cgfoldl
  = \ (@ (c_ae6nH :: * -> *))
      _ [Occ=Dead]
      (ds1_de7RQ :: forall g. g -> c_ae6nH g) ->
      ds1_de7RQ @ Float

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fDataFloat1
  :: (forall b. Data b => b -> b) -> Float -> Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (x0_Xe2Rj [Occ=Once] :: Float) -> x0_Xe2Rj}]
Data.Data.$fDataFloat1
  = \ _ [Occ=Dead] (x0_Xe2Rj :: Float) -> x0_Xe2Rj

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataFloat_$cgmapQl
  :: forall r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> Float -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae6pn)
                 (@ r'_ae6po)
                 _ [Occ=Dead]
                 (ds1_de7Sg [Occ=Once] :: r_ae6pn)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7Sg}]
Data.Data.$fDataFloat_$cgmapQl
  = \ (@ r_ae6pn)
      (@ r'_ae6po)
      _ [Occ=Dead]
      (ds1_de7Sg :: r_ae6pn)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7Sg

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataFloat_$cgmapQr
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> Float -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae6pE)
                 (@ r'_ae6pF)
                 _ [Occ=Dead]
                 (ds1_de7Sj [Occ=Once] :: r_ae6pE)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7Sj}]
Data.Data.$fDataFloat_$cgmapQr
  = \ (@ r_ae6pE)
      (@ r'_ae6pF)
      _ [Occ=Dead]
      (ds1_de7Sj :: r_ae6pE)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7Sj

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
Data.Data.$fDataFloat_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> Float -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae6pV) _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.[] @ u_ae6pV}]
Data.Data.$fDataFloat_$cgmapQ
  = \ (@ u_ae6pV) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.[] @ u_ae6pV

-- RHS size: {terms: 5, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataFloat_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Float -> m Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLSL),1*U(A,A,A,1*U,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_ae6qn :: * -> *))
                 ($dMonad_ae6qp [Occ=Once] :: Monad m_ae6qn)
                 _ [Occ=Dead] ->
                 return @ m_ae6qn $dMonad_ae6qp @ Float}]
Data.Data.$fDataFloat_$cgmapM
  = \ (@ (m_ae6qn :: * -> *))
      ($dMonad_ae6qp :: Monad m_ae6qn)
      _ [Occ=Dead] ->
      return @ m_ae6qn $dMonad_ae6qp @ Float

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp16 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Float -> m Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMp16
  = \ (@ (m_seg6r :: * -> *))
      (w_seg6s :: MonadPlus m_seg6r)
      (w1_seg6u :: Float) ->
      let {
        lvl270_se9FK :: m_seg6r Float
        [LclId]
        lvl270_se9FK = mzero @ m_seg6r w_seg6s @ Float } in
      let {
        $dMonad_se9tV [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg6r
        [LclId]
        $dMonad_se9tV = GHC.Base.$p2MonadPlus @ m_seg6r w_seg6s } in
      >>=
        @ m_seg6r
        $dMonad_se9tV
        @ (Float, Bool)
        @ Float
        (return
           @ m_seg6r
           $dMonad_se9tV
           @ (Float, Bool)
           (w1_seg6u, GHC.Types.False))
        (\ (ds_de7oa :: (Float, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9FK;
             True -> return @ m_seg6r $dMonad_se9tV @ Float x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataFloat_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Float -> m Float
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg6r :: * -> *))
                 (w_seg6s [Occ=Once] :: MonadPlus m_seg6r)
                 _ [Occ=Dead]
                 (w2_seg6u [Occ=Once] :: Float) ->
                 Data.Data.$w$cgmapMp16 @ m_seg6r w_seg6s w2_seg6u}]
Data.Data.$fDataFloat_$cgmapMp
  = \ (@ (m_seg6r :: * -> *))
      (w_seg6s :: MonadPlus m_seg6r)
      _ [Occ=Dead]
      (w2_seg6u :: Float) ->
      Data.Data.$w$cgmapMp16 @ m_seg6r w_seg6s w2_seg6u

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataFloat_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> Float -> u
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae6q9) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Maybe.fromJust1 @ u_ae6q9}]
Data.Data.$fDataFloat_$cgmapQi
  = \ (@ u_ae6q9) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Maybe.fromJust1 @ u_ae6q9

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo15 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Float -> m Float
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMo15
  = \ (@ (m_seg6w :: * -> *))
      (w_seg6x :: MonadPlus m_seg6w)
      (w1_seg6z :: Float) ->
      let {
        lvl270_se9FL :: m_seg6w Float
        [LclId]
        lvl270_se9FL = mzero @ m_seg6w w_seg6x @ Float } in
      let {
        $dMonad_se9tT [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg6w
        [LclId]
        $dMonad_se9tT = GHC.Base.$p2MonadPlus @ m_seg6w w_seg6x } in
      >>=
        @ m_seg6w
        $dMonad_se9tT
        @ (Float, Bool)
        @ Float
        (return
           @ m_seg6w
           $dMonad_se9tT
           @ (Float, Bool)
           (w1_seg6z, GHC.Types.False))
        (\ (ds_de7pa :: (Float, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9FL;
             True -> return @ m_seg6w $dMonad_se9tT @ Float x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataFloat_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Float -> m Float
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg6w :: * -> *))
                 (w_seg6x [Occ=Once] :: MonadPlus m_seg6w)
                 _ [Occ=Dead]
                 (w2_seg6z [Occ=Once] :: Float) ->
                 Data.Data.$w$cgmapMo15 @ m_seg6w w_seg6x w2_seg6z}]
Data.Data.$fDataFloat_$cgmapMo
  = \ (@ (m_seg6w :: * -> *))
      (w_seg6x :: MonadPlus m_seg6w)
      _ [Occ=Dead]
      (w2_seg6z :: Float) ->
      Data.Data.$w$cgmapMo15 @ m_seg6w w_seg6x w2_seg6z

-- RHS size: {terms: 16, types: 1, coercions: 5, joins: 0/0}
Data.Data.$fDataFloat [InlPrag=NOUSERINLINE CONLIKE] :: Data Float
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: Float
                        Data.Data.$fDataFloat4
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Float>_N
                                :: (Data.Typeable.Internal.TypeRep Float :: *)
                                   ~R# (Typeable Float :: Constraint))
                        Data.Data.$fDataFloat_$cgfoldl
                        Data.Data.$fDataFloat_$cgunfold
                        Data.Data.$fDataFloat_$ctoConstr
                        Data.Data.$fDataFloat_$cdataTypeOf
                        Data.Data.$fDataFloat_$cdataCast1
                        Data.Data.$fDataFloat_$cdataCast2
                        Data.Data.$fDataFloat1
                        Data.Data.$fDataFloat_$cgmapQl
                        Data.Data.$fDataFloat_$cgmapQr
                        Data.Data.$fDataFloat_$cgmapQ
                        Data.Data.$fDataFloat_$cgmapQi
                        Data.Data.$fDataFloat_$cgmapM
                        Data.Data.$fDataFloat_$cgmapMp
                        Data.Data.$fDataFloat_$cgmapMo]
Data.Data.$fDataFloat
  = Data.Data.C:Data
      @ Float
      (Data.Data.$fDataFloat4
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Float>_N
               :: (Data.Typeable.Internal.TypeRep Float :: *)
                  ~R# (Typeable Float :: Constraint)))
      Data.Data.$fDataFloat_$cgfoldl
      Data.Data.$fDataFloat_$cgunfold
      Data.Data.$fDataFloat_$ctoConstr
      Data.Data.$fDataFloat_$cdataTypeOf
      Data.Data.$fDataFloat_$cdataCast1
      Data.Data.$fDataFloat_$cdataCast2
      Data.Data.$fDataFloat1
      Data.Data.$fDataFloat_$cgmapQl
      Data.Data.$fDataFloat_$cgmapQr
      Data.Data.$fDataFloat_$cgmapQ
      Data.Data.$fDataFloat_$cgmapQi
      Data.Data.$fDataFloat_$cgmapM
      Data.Data.$fDataFloat_$cgmapMp
      Data.Data.$fDataFloat_$cgmapMo

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataIntPtr2 :: Int -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (v_XyL [Occ=Once] :: Int) -> v_XyL}]
Data.Data.$fDataIntPtr2 = \ (v_XyL :: Int) -> v_XyL

-- RHS size: {terms: 9, types: 26, coercions: 5, joins: 0/0}
Data.Data.$fDataIntPtr_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> IntPtr -> c IntPtr
[GblId,
 Arity=3,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_ae4Aa :: * -> *))
                 (k_ae2pm [Occ=Once!]
                    :: forall d b. Data d => c_ae4Aa (d -> b) -> d -> c_ae4Aa b)
                 (z_ae2pn [Occ=Once!] :: forall g. g -> c_ae4Aa g)
                 (ds_de7Aq [Occ=Once] :: IntPtr) ->
                 k_ae2pm
                   @ Int
                   @ IntPtr
                   Data.Data.$fDataInt
                   (z_ae2pn
                      @ (Int -> IntPtr)
                      (Data.Data.$fDataIntPtr2
                       `cast` (<Int>_R ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                               :: (Int -> Int :: *) ~R# (Int -> IntPtr :: *))))
                   (ds_de7Aq
                    `cast` (Foreign.Ptr.N:IntPtr[0] :: (IntPtr :: *) ~R# (Int :: *)))}]
Data.Data.$fDataIntPtr_$cgfoldl
  = \ (@ (c_ae4Aa :: * -> *))
      (k_ae2pm
         :: forall d b. Data d => c_ae4Aa (d -> b) -> d -> c_ae4Aa b)
      (z_ae2pn :: forall g. g -> c_ae4Aa g)
      (ds_de7Aq :: IntPtr) ->
      k_ae2pm
        @ Int
        @ IntPtr
        Data.Data.$fDataInt
        (z_ae2pn
           @ (Int -> IntPtr)
           (Data.Data.$fDataIntPtr2
            `cast` (<Int>_R ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                    :: (Int -> Int :: *) ~R# (Int -> IntPtr :: *))))
        (ds_de7Aq
         `cast` (Foreign.Ptr.N:IntPtr[0] :: (IntPtr :: *) ~R# (Int :: *)))

-- RHS size: {terms: 8, types: 25, coercions: 4, joins: 0/0}
Data.Data.$fDataIntPtr_$cgunfold
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c IntPtr
[GblId,
 Arity=3,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_ae4Ak :: * -> *))
                 (k_ae2pp [Occ=Once!]
                    :: forall b r. Data b => c_ae4Ak (b -> r) -> c_ae4Ak r)
                 (z_ae2pq [Occ=Once!] :: forall r. r -> c_ae4Ak r)
                 _ [Occ=Dead] ->
                 k_ae2pp
                   @ Int
                   @ IntPtr
                   Data.Data.$fDataInt
                   (z_ae2pq
                      @ (Int -> IntPtr)
                      (Data.Data.$fDataIntPtr2
                       `cast` (<Int>_R ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                               :: (Int -> Int :: *) ~R# (Int -> IntPtr :: *))))}]
Data.Data.$fDataIntPtr_$cgunfold
  = \ (@ (c_ae4Ak :: * -> *))
      (k_ae2pp :: forall b r. Data b => c_ae4Ak (b -> r) -> c_ae4Ak r)
      (z_ae2pq :: forall r. r -> c_ae4Ak r)
      _ [Occ=Dead] ->
      k_ae2pp
        @ Int
        @ IntPtr
        Data.Data.$fDataInt
        (z_ae2pq
           @ (Int -> IntPtr)
           (Data.Data.$fDataIntPtr2
            `cast` (<Int>_R ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                    :: (Int -> Int :: *) ~R# (Int -> IntPtr :: *))))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl94_rejOj :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl94_rejOj = "Data.Data.indexConstr is not supported for "#

-- RHS size: {terms: 7, types: 4, coercions: 0, joins: 0/0}
Data.Data.$wlvl17 [InlPrag=NOUSERINLINE[0]] :: String -> Constr
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []]
Data.Data.$wlvl17
  = \ (ww_seg6E :: String) ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ Constr
        (unpackAppendCString# lvl94_rejOj (++ @ Char ww_seg6E lvl17_rejMr))

-- RHS size: {terms: 14, types: 7, coercions: 0, joins: 0/0}
Data.Data.$windexConstr [InlPrag=NOUSERINLINE[0]]
  :: String -> DataRep -> Int# -> Constr
[GblId,
 Arity=3,
 Str=<L,1*U><S,1*U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 50 0] 71 0}]
Data.Data.$windexConstr
  = \ (ww_seg6M :: String)
      (ww1_seg6N :: DataRep)
      (ww2_seg6R :: Int#) ->
      case ww1_seg6N of {
        __DEFAULT -> Data.Data.$wlvl17 ww_seg6M;
        AlgRep cs_ae1Wq ->
          GHC.List.$w!! @ Constr cs_ae1Wq (-# ww2_seg6R 1#)
      }

-- RHS size: {terms: 12, types: 7, coercions: 0, joins: 0/0}
indexConstr [InlPrag=NOUSERINLINE[0]]
  :: DataType -> ConIndex -> Constr
[GblId,
 Arity=2,
 Str=<S(LS),1*U(1*U,1*U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_seg6I [Occ=Once!] :: DataType)
                 (w1_seg6J [Occ=Once!] :: ConIndex) ->
                 case w_seg6I of
                 { DataType ww1_seg6M [Occ=Once] ww2_seg6N [Occ=Once] ->
                 case w1_seg6J of { I# ww4_seg6R [Occ=Once] ->
                 Data.Data.$windexConstr ww1_seg6M ww2_seg6N ww4_seg6R
                 }
                 }}]
indexConstr
  = \ (w_seg6I :: DataType) (w1_seg6J :: ConIndex) ->
      case w_seg6I of { DataType ww1_seg6M ww2_seg6N ->
      case w1_seg6J of { I# ww4_seg6R ->
      Data.Data.$windexConstr ww1_seg6M ww2_seg6N ww4_seg6R
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl95_rejOk :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl95_rejOk
  = "Data.Data.repConstr: The given ConstrRep does not fit to the given DataType."#

-- RHS size: {terms: 4, types: 3, coercions: 0, joins: 0/0}
fail_rejOl :: Void# -> Constr
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []]
fail_rejOl
  = \ _ [Occ=Dead, OS=OneShot] ->
      errorWithoutStackTrace
        @ 'LiftedRep @ Constr (unpackCString# lvl95_rejOk)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.repConstr1 :: Constr
[GblId, Str=x]
Data.Data.repConstr1 = fail_rejOl void#

-- RHS size: {terms: 66, types: 17, coercions: 0, joins: 0/0}
Data.Data.$wrepConstr [InlPrag=NOUSERINLINE[0]]
  :: String -> DataRep -> ConstrRep -> Constr
[GblId,
 Arity=3,
 Str=<L,U><S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 240 120] 291 180}]
Data.Data.$wrepConstr
  = \ (ww_seg6Z :: String)
      (ww1_seg70 :: DataRep)
      (w_seg6W :: ConstrRep) ->
      case ww1_seg70 of {
        AlgRep cs_ae1VU ->
          case w_seg6W of {
            __DEFAULT -> Data.Data.repConstr1;
            AlgConstr i_ae1VV ->
              case i_ae1VV of { I# x_i7NWO ->
              GHC.List.$w!! @ Constr cs_ae1VU (-# x_i7NWO 1#)
              }
          };
        IntRep ->
          case w_seg6W of wild1_X9d {
            __DEFAULT -> Data.Data.repConstr1;
            IntConstr i_ae1VW ->
              Data.Data.Constr
                wild1_X9d
                (GHC.Show.$fShowInteger_$cshow i_ae1VW)
                Data.Data.$fDataChar5
                Data.Data.$fDataChar4
                (Data.Data.DataType ww_seg6Z Data.Data.IntRep)
          };
        FloatRep ->
          case w_seg6W of wild1_X9d {
            __DEFAULT -> Data.Data.repConstr1;
            FloatConstr f_ae1VX ->
              Data.Data.Constr
                wild1_X9d
                (GHC.Real.$fShowRatio_$s$cshow f_ae1VX)
                Data.Data.$fDataChar5
                Data.Data.$fDataChar4
                (Data.Data.DataType ww_seg6Z Data.Data.FloatRep)
          };
        CharRep ->
          case w_seg6W of wild1_X9d {
            __DEFAULT -> Data.Data.repConstr1;
            CharConstr c_ae1VY ->
              Data.Data.Constr
                wild1_X9d
                (GHC.Show.$fShowChar_$cshow c_ae1VY)
                Data.Data.$fDataChar5
                Data.Data.$fDataChar4
                (Data.Data.DataType ww_seg6Z Data.Data.CharRep)
          };
        NoRep -> Data.Data.repConstr1
      }

-- RHS size: {terms: 9, types: 5, coercions: 0, joins: 0/0}
repConstr [InlPrag=NOUSERINLINE[0]]
  :: DataType -> ConstrRep -> Constr
[GblId,
 Arity=2,
 Str=<S(LS),1*U(U,1*U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_seg6V [Occ=Once!] :: DataType)
                 (w1_seg6W [Occ=Once] :: ConstrRep) ->
                 case w_seg6V of
                 { DataType ww1_seg6Z [Occ=Once] ww2_seg70 [Occ=Once] ->
                 Data.Data.$wrepConstr ww1_seg6Z ww2_seg70 w1_seg6W
                 }}]
repConstr
  = \ (w_seg6V :: DataType) (w1_seg6W :: ConstrRep) ->
      case w_seg6V of { DataType ww1_seg6Z ww2_seg70 ->
      Data.Data.$wrepConstr ww1_seg6Z ww2_seg70 w1_seg6W
      }

-- RHS size: {terms: 10, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataDouble_$ctoConstr :: Double -> Constr
[GblId,
 Arity=1,
 Str=<L,U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (f_ae1WD :: Double) ->
                 Data.Data.Constr
                   (Data.Data.FloatConstr
                      (GHC.Float.$fRealDouble_$ctoRational f_ae1WD))
                   (GHC.Float.$fShowDouble_$cshow f_ae1WD)
                   Data.Data.$fDataChar5
                   Data.Data.$fDataChar4
                   doubleType}]
Data.Data.$fDataDouble_$ctoConstr
  = \ (f_ae1WD :: Double) ->
      Data.Data.Constr
        (Data.Data.FloatConstr
           (GHC.Float.$fRealDouble_$ctoRational f_ae1WD))
        (GHC.Float.$fShowDouble_$cshow f_ae1WD)
        Data.Data.$fDataChar5
        Data.Data.$fDataChar4
        doubleType

-- RHS size: {terms: 4, types: 22, coercions: 0, joins: 0/0}
Data.Data.$fDataDouble_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Double -> c Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (c_ae6k6 :: * -> *))
                 _ [Occ=Dead]
                 (ds1_de7R9 [Occ=Once] :: forall g. g -> c_ae6k6 g) ->
                 ds1_de7R9 @ Double}]
Data.Data.$fDataDouble_$cgfoldl
  = \ (@ (c_ae6k6 :: * -> *))
      _ [Occ=Dead]
      (ds1_de7R9 :: forall g. g -> c_ae6k6 g) ->
      ds1_de7R9 @ Double

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp15 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Double -> m Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMp15
  = \ (@ (m_seg73 :: * -> *))
      (w_seg74 :: MonadPlus m_seg73)
      (w1_seg76 :: Double) ->
      let {
        lvl270_se9FV :: m_seg73 Double
        [LclId]
        lvl270_se9FV = mzero @ m_seg73 w_seg74 @ Double } in
      let {
        $dMonad_se9tH [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg73
        [LclId]
        $dMonad_se9tH = GHC.Base.$p2MonadPlus @ m_seg73 w_seg74 } in
      >>=
        @ m_seg73
        $dMonad_se9tH
        @ (Double, Bool)
        @ Double
        (return
           @ m_seg73
           $dMonad_se9tH
           @ (Double, Bool)
           (w1_seg76, GHC.Types.False))
        (\ (ds_de7oa :: (Double, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9FV;
             True -> return @ m_seg73 $dMonad_se9tH @ Double x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataDouble_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Double -> m Double
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg73 :: * -> *))
                 (w_seg74 [Occ=Once] :: MonadPlus m_seg73)
                 _ [Occ=Dead]
                 (w2_seg76 [Occ=Once] :: Double) ->
                 Data.Data.$w$cgmapMp15 @ m_seg73 w_seg74 w2_seg76}]
Data.Data.$fDataDouble_$cgmapMp
  = \ (@ (m_seg73 :: * -> *))
      (w_seg74 :: MonadPlus m_seg73)
      _ [Occ=Dead]
      (w2_seg76 :: Double) ->
      Data.Data.$w$cgmapMp15 @ m_seg73 w_seg74 w2_seg76

-- RHS size: {terms: 5, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataDouble_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Double -> m Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLSL),1*U(A,A,A,1*U,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_ae6mP :: * -> *))
                 ($dMonad_ae6mR [Occ=Once] :: Monad m_ae6mP)
                 _ [Occ=Dead] ->
                 return @ m_ae6mP $dMonad_ae6mR @ Double}]
Data.Data.$fDataDouble_$cgmapM
  = \ (@ (m_ae6mP :: * -> *))
      ($dMonad_ae6mR :: Monad m_ae6mP)
      _ [Occ=Dead] ->
      return @ m_ae6mP $dMonad_ae6mR @ Double

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataDouble_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> Double -> u
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae6mB) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Maybe.fromJust1 @ u_ae6mB}]
Data.Data.$fDataDouble_$cgmapQi
  = \ (@ u_ae6mB) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Maybe.fromJust1 @ u_ae6mB

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataDouble_$cgmapQr
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> Double -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae6m6)
                 (@ r'_ae6m7)
                 _ [Occ=Dead]
                 (ds1_de7RH [Occ=Once] :: r_ae6m6)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7RH}]
Data.Data.$fDataDouble_$cgmapQr
  = \ (@ r_ae6m6)
      (@ r'_ae6m7)
      _ [Occ=Dead]
      (ds1_de7RH :: r_ae6m6)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7RH

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
Data.Data.$fDataDouble_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> Double -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ u_ae6mn) _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.[] @ u_ae6mn}]
Data.Data.$fDataDouble_$cgmapQ
  = \ (@ u_ae6mn) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.[] @ u_ae6mn

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataDouble_$cgmapQl
  :: forall r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> Double -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_ae6lP)
                 (@ r'_ae6lQ)
                 _ [Occ=Dead]
                 (ds1_de7RE [Occ=Once] :: r_ae6lP)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 ds1_de7RE}]
Data.Data.$fDataDouble_$cgmapQl
  = \ (@ r_ae6lP)
      (@ r'_ae6lQ)
      _ [Occ=Dead]
      (ds1_de7RE :: r_ae6lP)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      ds1_de7RE

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fDataDouble1
  :: (forall b. Data b => b -> b) -> Double -> Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (x0_Xe2Sf [Occ=Once] :: Double) -> x0_Xe2Sf}]
Data.Data.$fDataDouble1
  = \ _ [Occ=Dead] (x0_Xe2Sf :: Double) -> x0_Xe2Sf

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataDouble_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c Double)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae6lh :: * -> * -> *))
                 (@ (c_ae6li :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae6li Double)}]
Data.Data.$fDataDouble_$cdataCast2
  = \ (@ (t_ae6lh :: * -> * -> *))
      (@ (c_ae6li :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae6li Double)

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataDouble_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c Double)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae6kY :: * -> *))
                 (@ (c_ae6kZ :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae6kZ Double)}]
Data.Data.$fDataDouble_$cdataCast1
  = \ (@ (t_ae6kY :: * -> *))
      (@ (c_ae6kZ :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae6kZ Double)

-- RHS size: {terms: 28, types: 36, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo14 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Double -> m Double
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 210 0}]
Data.Data.$w$cgmapMo14
  = \ (@ (m_seg78 :: * -> *))
      (w_seg79 :: MonadPlus m_seg78)
      (w1_seg7b :: Double) ->
      let {
        lvl270_se9FW :: m_seg78 Double
        [LclId]
        lvl270_se9FW = mzero @ m_seg78 w_seg79 @ Double } in
      let {
        $dMonad_se9tF [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg78
        [LclId]
        $dMonad_se9tF = GHC.Base.$p2MonadPlus @ m_seg78 w_seg79 } in
      >>=
        @ m_seg78
        $dMonad_se9tF
        @ (Double, Bool)
        @ Double
        (return
           @ m_seg78
           $dMonad_se9tF
           @ (Double, Bool)
           (w1_seg7b, GHC.Types.False))
        (\ (ds_de7pa :: (Double, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9FW;
             True -> return @ m_seg78 $dMonad_se9tF @ Double x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataDouble_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Double -> m Double
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg78 :: * -> *))
                 (w_seg79 [Occ=Once] :: MonadPlus m_seg78)
                 _ [Occ=Dead]
                 (w2_seg7b [Occ=Once] :: Double) ->
                 Data.Data.$w$cgmapMo14 @ m_seg78 w_seg79 w2_seg7b}]
Data.Data.$fDataDouble_$cgmapMo
  = \ (@ (m_seg78 :: * -> *))
      (w_seg79 :: MonadPlus m_seg78)
      _ [Occ=Dead]
      (w2_seg7b :: Double) ->
      Data.Data.$w$cgmapMo14 @ m_seg78 w_seg79 w2_seg7b

-- RHS size: {terms: 16, types: 1, coercions: 5, joins: 0/0}
Data.Data.$fDataDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: Data Double
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: Double
                        Data.Data.$fDataDouble4
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Double>_N
                                :: (Data.Typeable.Internal.TypeRep Double :: *)
                                   ~R# (Typeable Double :: Constraint))
                        Data.Data.$fDataDouble_$cgfoldl
                        Data.Data.$fDataDouble_$cgunfold
                        Data.Data.$fDataDouble_$ctoConstr
                        Data.Data.$fDataDouble_$cdataTypeOf
                        Data.Data.$fDataDouble_$cdataCast1
                        Data.Data.$fDataDouble_$cdataCast2
                        Data.Data.$fDataDouble1
                        Data.Data.$fDataDouble_$cgmapQl
                        Data.Data.$fDataDouble_$cgmapQr
                        Data.Data.$fDataDouble_$cgmapQ
                        Data.Data.$fDataDouble_$cgmapQi
                        Data.Data.$fDataDouble_$cgmapM
                        Data.Data.$fDataDouble_$cgmapMp
                        Data.Data.$fDataDouble_$cgmapMo]
Data.Data.$fDataDouble
  = Data.Data.C:Data
      @ Double
      (Data.Data.$fDataDouble4
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Double>_N
               :: (Data.Typeable.Internal.TypeRep Double :: *)
                  ~R# (Typeable Double :: Constraint)))
      Data.Data.$fDataDouble_$cgfoldl
      Data.Data.$fDataDouble_$cgunfold
      Data.Data.$fDataDouble_$ctoConstr
      Data.Data.$fDataDouble_$cdataTypeOf
      Data.Data.$fDataDouble_$cdataCast1
      Data.Data.$fDataDouble_$cdataCast2
      Data.Data.$fDataDouble1
      Data.Data.$fDataDouble_$cgmapQl
      Data.Data.$fDataDouble_$cgmapQr
      Data.Data.$fDataDouble_$cgmapQ
      Data.Data.$fDataDouble_$cgmapQi
      Data.Data.$fDataDouble_$cgmapM
      Data.Data.$fDataDouble_$cgmapMp
      Data.Data.$fDataDouble_$cgmapMo

-- RHS size: {terms: 57, types: 26, coercions: 0, joins: 0/0}
Data.Data.$fEqConstr_$c== :: ConstrRep -> ConstrRep -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [200 120] 321 50}]
Data.Data.$fEqConstr_$c==
  = \ (ds_de7Fn :: ConstrRep) (ds1_de7Fo :: ConstrRep) ->
      case ds_de7Fn of {
        AlgConstr a1_ae2r1 ->
          case ds1_de7Fo of {
            __DEFAULT -> GHC.Types.False;
            AlgConstr b1_ae2r2 -> eqInt a1_ae2r1 b1_ae2r2
          };
        IntConstr a1_ae2r3 ->
          case ds1_de7Fo of {
            __DEFAULT -> GHC.Types.False;
            IntConstr b1_ae2r4 -> eqInteger a1_ae2r3 b1_ae2r4
          };
        FloatConstr a1_ae2r5 ->
          case ds1_de7Fo of {
            __DEFAULT -> GHC.Types.False;
            FloatConstr b1_ae2r6 ->
              case a1_ae2r5 of { :% a2_icBNB a3_icBNC ->
              case b1_ae2r6 of { :% b2_icBNG b3_icBNH ->
              case eqInteger# a2_icBNB b2_icBNG of {
                __DEFAULT -> GHC.Types.False;
                1# ->
                  case eqInteger# a3_icBNC b3_icBNH of wild5_icBNK { __DEFAULT ->
                  tagToEnum# @ Bool wild5_icBNK
                  }
              }
              }
              }
          };
        CharConstr a1_ae2r7 ->
          case ds1_de7Fo of {
            __DEFAULT -> GHC.Types.False;
            CharConstr b1_ae2r8 -> eqChar a1_ae2r7 b1_ae2r8
          }
      }

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
Data.Data.$fEqConstrRep_$c/= [InlPrag=INLINE (sat-args=2)]
  :: ConstrRep -> ConstrRep -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a22b [Occ=Once] :: ConstrRep)
                 (y_a22c [Occ=Once] :: ConstrRep) ->
                 case Data.Data.$fEqConstr_$c== x_a22b y_a22c of {
                   False -> GHC.Types.True;
                   True -> GHC.Types.False
                 }}]
Data.Data.$fEqConstrRep_$c/=
  = \ (eta_Xz4 :: ConstrRep) (eta1_X187 :: ConstrRep) ->
      case Data.Data.$fEqConstr_$c== eta_Xz4 eta1_X187 of {
        False -> GHC.Types.True;
        True -> GHC.Types.False
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fEqConstrRep [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq ConstrRep
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: ConstrRep
                        Data.Data.$fEqConstr_$c==
                        Data.Data.$fEqConstrRep_$c/=]
Data.Data.$fEqConstrRep
  = GHC.Classes.C:Eq
      @ ConstrRep Data.Data.$fEqConstr_$c== Data.Data.$fEqConstrRep_$c/=

-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
Data.Data.$fEqConstr_$c==1 :: Constr -> Constr -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U,A,A,A,A)><S(SLLLL),1*U(1*U,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (c_ae1Vs [Occ=Once!] :: Constr)
                 (c'_ae1Vt [Occ=Once!] :: Constr) ->
                 case c_ae1Vs of
                 { Constr ds_de7lX [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                          _ [Occ=Dead] ->
                 case c'_ae1Vt of
                 { Constr ds5_Xe8hx [Occ=Once] _ [Occ=Dead] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Data.$fEqConstr_$c== ds_de7lX ds5_Xe8hx
                 }
                 }}]
Data.Data.$fEqConstr_$c==1
  = \ (c_ae1Vs :: Constr) (c'_ae1Vt :: Constr) ->
      case c_ae1Vs of
      { Constr ds_de7lX ds1_de7lY ds2_de7lZ ds3_de7m0 ds4_de7m1 ->
      case c'_ae1Vt of
      { Constr ds5_Xe8hx ds6_Xe8hz ds7_Xe8hB ds8_Xe8hD ds9_Xe8hF ->
      Data.Data.$fEqConstr_$c== ds_de7lX ds5_Xe8hx
      }
      }

-- RHS size: {terms: 16, types: 17, coercions: 0, joins: 0/0}
Data.Data.$fEqConstr_$c/= [InlPrag=INLINE (sat-args=2)]
  :: Constr -> Constr -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U,A,A,A,A)><S(SLLLL),1*U(1*U,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a22b [Occ=Once!] :: Constr)
                 (y_a22c [Occ=Once!] :: Constr) ->
                 case x_a22b of
                 { Constr ds_de7lX [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                          _ [Occ=Dead] ->
                 case y_a22c of
                 { Constr ds5_Xe8hy [Occ=Once] _ [Occ=Dead] _ [Occ=Dead]
                          _ [Occ=Dead] _ [Occ=Dead] ->
                 case Data.Data.$fEqConstr_$c== ds_de7lX ds5_Xe8hy of {
                   False -> GHC.Types.True;
                   True -> GHC.Types.False
                 }
                 }
                 }}]
Data.Data.$fEqConstr_$c/=
  = \ (eta_Xz7 :: Constr) (eta1_X18d :: Constr) ->
      case eta_Xz7 of
      { Constr ds_de7lX ds1_de7lY ds2_de7lZ ds3_de7m0 ds4_de7m1 ->
      case eta1_X18d of
      { Constr ds5_Xe8hy ds6_Xe8hA ds7_Xe8hC ds8_Xe8hE ds9_Xe8hG ->
      case Data.Data.$fEqConstr_$c== ds_de7lX ds5_Xe8hy of {
        False -> GHC.Types.True;
        True -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fEqConstr [InlPrag=NOUSERINLINE CONLIKE] :: Eq Constr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: Constr
                        Data.Data.$fEqConstr_$c==1
                        Data.Data.$fEqConstr_$c/=]
Data.Data.$fEqConstr
  = GHC.Classes.C:Eq
      @ Constr Data.Data.$fEqConstr_$c==1 Data.Data.$fEqConstr_$c/=

-- RHS size: {terms: 42, types: 13, coercions: 0, joins: 0/0}
Data.Data.$fEqDataRep_$c== :: DataRep -> DataRep -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [140 150] 190 90}]
Data.Data.$fEqDataRep_$c==
  = \ (ds_de7Fz :: DataRep) (ds1_de7FA :: DataRep) ->
      case ds_de7Fz of {
        AlgRep a1_ae2rk ->
          case ds1_de7FA of {
            __DEFAULT -> GHC.Types.False;
            AlgRep b1_ae2rl ->
              GHC.Classes.$fEq[]_$c==
                @ Constr Data.Data.$fEqConstr a1_ae2rk b1_ae2rl
          };
        IntRep ->
          case ds1_de7FA of {
            __DEFAULT -> GHC.Types.False;
            IntRep -> GHC.Types.True
          };
        FloatRep ->
          case ds1_de7FA of {
            __DEFAULT -> GHC.Types.False;
            FloatRep -> GHC.Types.True
          };
        CharRep ->
          case ds1_de7FA of {
            __DEFAULT -> GHC.Types.False;
            CharRep -> GHC.Types.True
          };
        NoRep ->
          case ds1_de7FA of {
            __DEFAULT -> GHC.Types.False;
            NoRep -> GHC.Types.True
          }
      }

-- RHS size: {terms: 47, types: 14, coercions: 0, joins: 0/0}
Data.Data.$fEqDataRep_$c/= [InlPrag=INLINE (sat-args=2)]
  :: DataRep -> DataRep -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a22b [Occ=Once!] :: DataRep)
                 (y_a22c [Occ=Once*!] :: DataRep) ->
                 case x_a22b of {
                   AlgRep a1_ae2rk [Occ=Once] ->
                     case y_a22c of {
                       __DEFAULT -> GHC.Types.True;
                       AlgRep b1_ae2rl [Occ=Once] ->
                         case GHC.Classes.$fEq[]_$c==
                                @ Constr Data.Data.$fEqConstr a1_ae2rk b1_ae2rl
                         of {
                           False -> GHC.Types.True;
                           True -> GHC.Types.False
                         }
                     };
                   IntRep ->
                     case y_a22c of {
                       __DEFAULT -> GHC.Types.True;
                       IntRep -> GHC.Types.False
                     };
                   FloatRep ->
                     case y_a22c of {
                       __DEFAULT -> GHC.Types.True;
                       FloatRep -> GHC.Types.False
                     };
                   CharRep ->
                     case y_a22c of {
                       __DEFAULT -> GHC.Types.True;
                       CharRep -> GHC.Types.False
                     };
                   NoRep ->
                     case y_a22c of {
                       __DEFAULT -> GHC.Types.True;
                       NoRep -> GHC.Types.False
                     }
                 }}]
Data.Data.$fEqDataRep_$c/=
  = \ (eta_Xza :: DataRep) (eta1_X18j :: DataRep) ->
      case eta_Xza of {
        AlgRep a1_ae2rk ->
          case eta1_X18j of {
            __DEFAULT -> GHC.Types.True;
            AlgRep b1_ae2rl ->
              case GHC.Classes.$fEq[]_$c==
                     @ Constr Data.Data.$fEqConstr a1_ae2rk b1_ae2rl
              of {
                False -> GHC.Types.True;
                True -> GHC.Types.False
              }
          };
        IntRep ->
          case eta1_X18j of {
            __DEFAULT -> GHC.Types.True;
            IntRep -> GHC.Types.False
          };
        FloatRep ->
          case eta1_X18j of {
            __DEFAULT -> GHC.Types.True;
            FloatRep -> GHC.Types.False
          };
        CharRep ->
          case eta1_X18j of {
            __DEFAULT -> GHC.Types.True;
            CharRep -> GHC.Types.False
          };
        NoRep ->
          case eta1_X18j of {
            __DEFAULT -> GHC.Types.True;
            NoRep -> GHC.Types.False
          }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fEqDataRep [InlPrag=NOUSERINLINE CONLIKE] :: Eq DataRep
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: DataRep
                        Data.Data.$fEqDataRep_$c==
                        Data.Data.$fEqDataRep_$c/=]
Data.Data.$fEqDataRep
  = GHC.Classes.C:Eq
      @ DataRep Data.Data.$fEqDataRep_$c== Data.Data.$fEqDataRep_$c/=

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl96_rejOm :: Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl96_rejOm = GHC.Types.C# '.'#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl97_rejOn :: Char -> Bool
[GblId, Arity=1, Caf=NoCafRefs, Unf=OtherCon []]
lvl97_rejOn = eqChar lvl96_rejOm

Rec {
-- RHS size: {terms: 34, types: 30, coercions: 0, joins: 0/1}
tyconModule [Occ=LoopBreaker] :: String -> String
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
tyconModule
  = \ (x_ae1WK :: String) ->
      case GHC.List.$wbreak @ Char lvl97_rejOn x_ae1WK of
      { (# ww1_iby3b, ww2_iby3c #) ->
      case eqString ww2_iby3c (GHC.Types.[] @ Char) of {
        False ->
          ++
            @ Char
            ww1_iby3b
            (case ww2_iby3c of {
               [] -> case GHC.List.scanl2 of wild2_00 { };
               : ds1_ibGtk xs_ibGtl ->
                 let {
                   y'_se9tD [Dmd=<S,U>] :: String
                   [LclId]
                   y'_se9tD = tyconModule xs_ibGtl } in
                 case eqString y'_se9tD (GHC.Types.[] @ Char) of {
                   False -> GHC.Types.: @ Char lvl96_rejOm y'_se9tD;
                   True -> GHC.Types.[] @ Char
                 }
             });
        True -> ww2_iby3c
      }
      }
end Rec }

-- RHS size: {terms: 4, types: 2, coercions: 0, joins: 0/0}
Data.Data.readConstr3 :: Text.ParserCombinators.ReadP.P Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
Data.Data.readConstr3
  = GHC.Read.$fReadInteger_$sreadNumber
      GHC.Read.$fReadInteger2
      Text.ParserCombinators.ReadPrec.minPrec
      @ Integer
      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ Integer)

-- RHS size: {terms: 4, types: 2, coercions: 0, joins: 0/0}
Data.Data.readConstr2 :: Text.ParserCombinators.ReadP.P Double
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
Data.Data.readConstr2
  = GHC.Read.$fReadDouble_$sreadNumber
      GHC.Read.$fReadDouble_$sconvertFrac
      Text.ParserCombinators.ReadPrec.minPrec
      @ Double
      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ Double)

-- RHS size: {terms: 4, types: 3, coercions: 9, joins: 0/0}
Data.Data.readConstr1 :: Text.ParserCombinators.ReadP.P Char
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
Data.Data.readConstr1
  = GHC.Read.list3
      @ Char
      (GHC.Read.$fReadChar7
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Char>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                    <Char>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Char -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Char :: *)))
      Text.ParserCombinators.ReadPrec.minPrec
      @ Char
      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ Char)

-- RHS size: {terms: 123, types: 138, coercions: 0, joins: 0/1}
Data.Data.$wreadConstr [InlPrag=NOUSERINLINE[0]]
  :: String -> DataRep -> String -> Maybe Constr
[GblId,
 Arity=3,
 Str=<L,U><S,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 500 0] 670 190}]
Data.Data.$wreadConstr
  = \ (ww_seg7r :: String)
      (ww1_seg7s :: DataRep)
      (w_seg7o :: String) ->
      case ww1_seg7s of {
        AlgRep cons_ae1Wk ->
          let {
            fit_se9tx [Dmd=<S,U>] :: [Constr]
            [LclId]
            fit_se9tx
              = filter
                  @ Constr
                  (\ (x_i7Rxi :: Constr) ->
                     case x_i7Rxi of
                     { Constr ds_de7m3 ds1_de7m4 ds2_de7m5 ds3_de7m6 ds4_de7m7 ->
                     eqString w_seg7o ds1_de7m4
                     })
                  cons_ae1Wk } in
          case GHC.Classes.$fEq[]_$c==
                 @ Constr Data.Data.$fEqConstr fit_se9tx (GHC.Types.[] @ Constr)
          of {
            False -> GHC.Base.Just @ Constr (head @ Constr fit_se9tx);
            True -> GHC.Base.Nothing @ Constr
          };
        IntRep ->
          case Text.ParserCombinators.ReadP.run
                 @ Integer Data.Data.readConstr3 w_seg7o
          of {
            [] -> GHC.Base.Nothing @ Constr;
            : ds_de7ii ds1_de7ij ->
              case ds_de7ii of { (t_ae1Wh, ds2_de7ik) ->
              case ds2_de7ik of {
                [] ->
                  case ds1_de7ij of {
                    [] ->
                      GHC.Base.Just
                        @ Constr
                        (Data.Data.Constr
                           (Data.Data.IntConstr t_ae1Wh)
                           w_seg7o
                           Data.Data.$fDataChar5
                           Data.Data.$fDataChar4
                           (Data.Data.DataType ww_seg7r Data.Data.IntRep));
                    : ipv_se883 ipv1_se884 -> GHC.Base.Nothing @ Constr
                  };
                : ipv_se881 ipv1_se886 -> GHC.Base.Nothing @ Constr
              }
              }
          };
        FloatRep ->
          case Text.ParserCombinators.ReadP.run
                 @ Double Data.Data.readConstr2 w_seg7o
          of {
            [] -> GHC.Base.Nothing @ Constr;
            : ds_de7ii ds1_de7ij ->
              case ds_de7ii of { (t_ae1Wh, ds2_de7ik) ->
              case ds2_de7ik of {
                [] ->
                  case ds1_de7ij of {
                    [] ->
                      GHC.Base.Just
                        @ Constr
                        (Data.Data.Constr
                           (Data.Data.FloatConstr
                              (GHC.Float.$fRealDouble_$ctoRational t_ae1Wh))
                           w_seg7o
                           Data.Data.$fDataChar5
                           Data.Data.$fDataChar4
                           (Data.Data.DataType ww_seg7r Data.Data.FloatRep));
                    : ipv_se883 ipv1_se884 -> GHC.Base.Nothing @ Constr
                  };
                : ipv_se881 ipv1_se886 -> GHC.Base.Nothing @ Constr
              }
              }
          };
        CharRep ->
          case Text.ParserCombinators.ReadP.run
                 @ Char Data.Data.readConstr1 w_seg7o
          of {
            [] -> GHC.Base.Nothing @ Constr;
            : ds_de7ii ds1_de7ij ->
              case ds_de7ii of { (t_ae1Wh, ds2_de7ik) ->
              case ds2_de7ik of {
                [] ->
                  case ds1_de7ij of {
                    [] ->
                      GHC.Base.Just
                        @ Constr
                        (Data.Data.Constr
                           (Data.Data.CharConstr t_ae1Wh)
                           w_seg7o
                           Data.Data.$fDataChar5
                           Data.Data.$fDataChar4
                           (Data.Data.DataType ww_seg7r Data.Data.CharRep));
                    : ipv_se883 ipv1_se884 -> GHC.Base.Nothing @ Constr
                  };
                : ipv_se881 ipv1_se886 -> GHC.Base.Nothing @ Constr
              }
              }
          };
        NoRep -> GHC.Base.Nothing @ Constr
      }

-- RHS size: {terms: 9, types: 5, coercions: 0, joins: 0/0}
readConstr [InlPrag=NOUSERINLINE[0]]
  :: DataType -> String -> Maybe Constr
[GblId,
 Arity=2,
 Str=<S(LS),1*U(U,1*U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_seg7n [Occ=Once!] :: DataType)
                 (w1_seg7o [Occ=Once] :: String) ->
                 case w_seg7n of
                 { DataType ww1_seg7r [Occ=Once] ww2_seg7s [Occ=Once] ->
                 Data.Data.$wreadConstr ww1_seg7r ww2_seg7s w1_seg7o
                 }}]
readConstr
  = \ (w_seg7n :: DataType) (w1_seg7o :: String) ->
      case w_seg7n of { DataType ww1_seg7r ww2_seg7s ->
      Data.Data.$wreadConstr ww1_seg7r ww2_seg7s w1_seg7o
      }

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.mkConstr1 :: [Int]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
Data.Data.mkConstr1 = GHC.Enum.eftInt 1# 9223372036854775807#

-- RHS size: {terms: 49, types: 42, coercions: 0, joins: 1/1}
mkConstr [InlPrag=NOUSERINLINE[0]]
  :: DataType -> String -> [String] -> Fixity -> Constr
[GblId,
 Arity=4,
 Str=<L,U(U,U)><L,U><L,U><L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_seg7x :: DataType)
                 (w1_seg7y :: String)
                 (w2_seg7z [Occ=Once] :: [String])
                 (w3_seg7A [Occ=Once] :: Fixity) ->
                 Data.Data.Constr
                   (Data.Data.AlgConstr
                      (case w_seg7x of
                       { DataType ds_de7mu [Occ=Once] ds1_de7mv [Occ=Once!] ->
                       case ds1_de7mv of {
                         __DEFAULT -> case Data.Data.$wlvl16 ds_de7mu of { };
                         AlgRep cons_ae1W9 [Occ=Once] ->
                           joinrec {
                             go61_XaJoH [Occ=LoopBreakerT[2]] :: [Constr] -> [Int] -> ConIndex
                             [LclId[JoinId(2)], Arity=2, Str=<S,U><S,U>, Unf=OtherCon []]
                             go61_XaJoH (ds2_iaIB3 [Occ=Once!] :: [Constr])
                                        (_ys_iaIB4 [Occ=Once!] :: [Int])
                               = case ds2_iaIB3 of {
                                   [] -> GHC.List.badHead @ Int;
                                   : ipv_iaIB9 [Occ=Once!] ipv1_iaIBa [Occ=Once] ->
                                     case _ys_iaIB4 of {
                                       [] -> GHC.List.badHead @ Int;
                                       : ipv2_iaIBg [Occ=Once] ipv3_iaIBh [Occ=Once] ->
                                         case ipv_iaIB9 of
                                         { Constr _ [Occ=Dead] ds4_de7m4 [Occ=Once] _ [Occ=Dead]
                                                  _ [Occ=Dead] _ [Occ=Dead] ->
                                         case eqString ds4_de7m4 w1_seg7y of {
                                           False -> jump go61_XaJoH ipv1_iaIBa ipv3_iaIBh;
                                           True -> ipv2_iaIBg
                                         }
                                         }
                                     }
                                 }; } in
                           jump go61_XaJoH cons_ae1W9 Data.Data.mkConstr1
                       }
                       }))
                   w1_seg7y
                   w2_seg7z
                   w3_seg7A
                   w_seg7x}]
mkConstr
  = \ (w_seg7x :: DataType)
      (w1_seg7y :: String)
      (w2_seg7z :: [String])
      (w3_seg7A :: Fixity) ->
      Data.Data.Constr
        (Data.Data.AlgConstr
           (case w_seg7x of { DataType ds_de7mu ds1_de7mv ->
            case ds1_de7mv of {
              __DEFAULT -> case Data.Data.$wlvl16 ds_de7mu of wild2_00 { };
              AlgRep cons_ae1W9 ->
                joinrec {
                  go61_XaJoH [Occ=LoopBreaker] :: [Constr] -> [Int] -> ConIndex
                  [LclId[JoinId(2)], Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
                  go61_XaJoH (ds2_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int])
                    = case ds2_iaIB3 of {
                        [] -> GHC.List.badHead @ Int;
                        : ipv_iaIB9 ipv1_iaIBa ->
                          case _ys_iaIB4 of {
                            [] -> GHC.List.badHead @ Int;
                            : ipv2_iaIBg ipv3_iaIBh ->
                              case ipv_iaIB9 of
                              { Constr ds3_de7m3 ds4_de7m4 ds5_de7m5 ds6_de7m6 ds7_de7m7 ->
                              case eqString ds4_de7m4 w1_seg7y of {
                                False -> jump go61_XaJoH ipv1_iaIBa ipv3_iaIBh;
                                True -> ipv2_iaIBg
                              }
                              }
                          }
                      }; } in
                jump go61_XaJoH cons_ae1W9 Data.Data.mkConstr1
            }
            }))
        w1_seg7y
        w2_seg7z
        w3_seg7A
        w_seg7x

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tBool1_rejOo :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$tBool1_rejOo = "Bool"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tBool2_rejOp :: [Char]
[GblId]
$tBool2_rejOp = unpackCString# $tBool1_rejOo

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str_rejOq :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str_rejOq = "False"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str1_rejOr :: String
[GblId]
str1_rejOr = unpackCString# str_rejOq

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str2_rejOs :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str2_rejOs = "True"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str3_rejOt :: String
[GblId]
str3_rejOt = unpackCString# str2_rejOs

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go2_rejOu :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go2_rejOu
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str3_rejOt of {
                False -> go2_rejOu ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go1_rejOv :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go1_rejOv
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str1_rejOr of {
                False -> go1_rejOv ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cTrue1_rejOw :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cTrue1_rejOw = Data.Data.AlgConstr $cTrue2_rejOC

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cFalse1_rejOx :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cFalse1_rejOx = Data.Data.AlgConstr $cFalse2_rejOB

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cTrue [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cTrue
  = Data.Data.Constr
      $cTrue1_rejOw
      str3_rejOt
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tBool

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$tBool3_rejOy :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tBool3_rejOy
  = GHC.Types.: @ Constr Data.Data.$cTrue (GHC.Types.[] @ Constr)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$tBool4_rejOz :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tBool4_rejOz
  = GHC.Types.: @ Constr Data.Data.$cFalse $tBool3_rejOy

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tBool5_rejOA :: DataRep
[GblId, Str=m1, Unf=OtherCon []]
$tBool5_rejOA = Data.Data.AlgRep $tBool4_rejOz

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tBool [Occ=LoopBreaker] :: DataType
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$tBool = Data.Data.DataType $tBool2_rejOp $tBool5_rejOA

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cFalse [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cFalse
  = Data.Data.Constr
      $cFalse1_rejOx
      str1_rejOr
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tBool

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cFalse2_rejOB :: ConIndex
[GblId]
$cFalse2_rejOB = go1_rejOv $tBool4_rejOz Data.Data.mkConstr1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cTrue2_rejOC :: ConIndex
[GblId]
$cTrue2_rejOC = go2_rejOu $tBool4_rejOz Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataBool_$cdataTypeOf :: Bool -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Data.$tBool}]
Data.Data.$fDataBool_$cdataTypeOf
  = \ _ [Occ=Dead] -> Data.Data.$tBool

-- RHS size: {terms: 7, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataBool_$ctoConstr :: Bool -> Constr
[GblId,
 Arity=1,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_de7F6 [Occ=Once!] :: Bool) ->
                 case ds_de7F6 of {
                   False -> Data.Data.$cFalse;
                   True -> Data.Data.$cTrue
                 }}]
Data.Data.$fDataBool_$ctoConstr
  = \ (ds_de7F6 :: Bool) ->
      case ds_de7F6 of {
        False -> Data.Data.$cFalse;
        True -> Data.Data.$cTrue
      }

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataBool_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c Bool)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae5h3 :: * -> *))
                 (@ (c_ae5h4 :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae5h4 Bool)}]
Data.Data.$fDataBool_$cdataCast1
  = \ (@ (t_ae5h3 :: * -> *))
      (@ (c_ae5h4 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5h4 Bool)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataBool2 :: (Bool, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataBool2 = (GHC.Types.False, GHC.Types.False)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataBool1 :: (Bool, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataBool1 = (GHC.Types.True, GHC.Types.False)

-- RHS size: {terms: 33, types: 39, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp6 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Bool -> m Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 60] 250 0}]
Data.Data.$w$cgmapMp6
  = \ (@ (m_seg7J :: * -> *))
      (w_seg7K :: MonadPlus m_seg7J)
      (w1_seg7M :: Bool) ->
      let {
        lvl270_se9Gg :: m_seg7J Bool
        [LclId]
        lvl270_se9Gg = mzero @ m_seg7J w_seg7K @ Bool } in
      let {
        $dMonad_se9tv [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg7J
        [LclId]
        $dMonad_se9tv = GHC.Base.$p2MonadPlus @ m_seg7J w_seg7K } in
      >>=
        @ m_seg7J
        $dMonad_se9tv
        @ (Bool, Bool)
        @ Bool
        (case w1_seg7M of {
           False ->
             return
               @ m_seg7J $dMonad_se9tv @ (Bool, Bool) Data.Data.$fDataBool2;
           True ->
             return @ m_seg7J $dMonad_se9tv @ (Bool, Bool) Data.Data.$fDataBool1
         })
        (\ (ds_de7oa :: (Bool, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9Gg;
             True -> return @ m_seg7J $dMonad_se9tv @ Bool x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataBool_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Bool -> m Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg7J :: * -> *))
                 (w_seg7K [Occ=Once] :: MonadPlus m_seg7J)
                 _ [Occ=Dead]
                 (w2_seg7M [Occ=Once] :: Bool) ->
                 Data.Data.$w$cgmapMp6 @ m_seg7J w_seg7K w2_seg7M}]
Data.Data.$fDataBool_$cgmapMp
  = \ (@ (m_seg7J :: * -> *))
      (w_seg7K :: MonadPlus m_seg7J)
      _ [Occ=Dead]
      (w2_seg7M :: Bool) ->
      Data.Data.$w$cgmapMp6 @ m_seg7J w_seg7K w2_seg7M

-- RHS size: {terms: 14, types: 19, coercions: 0, joins: 0/0}
Data.Data.$fDataBool_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Bool -> m Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (m_ae5iU :: * -> *))
                 ($dMonad_ae5iW [Occ=Once*] :: Monad m_ae5iU)
                 _ [Occ=Dead]
                 (eta_Xzr [Occ=Once!] :: Bool) ->
                 case eta_Xzr of {
                   False -> return @ m_ae5iU $dMonad_ae5iW @ Bool GHC.Types.False;
                   True -> return @ m_ae5iU $dMonad_ae5iW @ Bool GHC.Types.True
                 }}]
Data.Data.$fDataBool_$cgmapM
  = \ (@ (m_ae5iU :: * -> *))
      ($dMonad_ae5iW :: Monad m_ae5iU)
      _ [Occ=Dead]
      (eta_Xzr :: Bool) ->
      case eta_Xzr of {
        False -> return @ m_ae5iU $dMonad_ae5iW @ Bool GHC.Types.False;
        True -> return @ m_ae5iU $dMonad_ae5iW @ Bool GHC.Types.True
      }

-- RHS size: {terms: 8, types: 12, coercions: 0, joins: 0/0}
Data.Data.$fDataBool_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> Bool -> u
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,1*U>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae5iG)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (x_ae1T7 [Occ=Once] :: Bool) ->
                 case x_ae1T7 of { __DEFAULT -> Data.Maybe.fromJust1 @ u_ae5iG }}]
Data.Data.$fDataBool_$cgmapQi
  = \ (@ u_ae5iG) _ [Occ=Dead] _ [Occ=Dead] (x_ae1T7 :: Bool) ->
      case x_ae1T7 of { __DEFAULT -> Data.Maybe.fromJust1 @ u_ae5iG }

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
Data.Data.$fDataBool_$cgmapQr
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> Bool -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_ae5ib)
                 (@ r'_ae5ic)
                 _ [Occ=Dead]
                 (ds1_de7Ff [Occ=Once] :: r_ae5ib)
                 _ [Occ=Dead]
                 (x0_ae1SX [Occ=Once] :: Bool) ->
                 case x0_ae1SX of { __DEFAULT -> ds1_de7Ff }}]
Data.Data.$fDataBool_$cgmapQr
  = \ (@ r_ae5ib)
      (@ r'_ae5ic)
      _ [Occ=Dead]
      (ds1_de7Ff :: r_ae5ib)
      _ [Occ=Dead]
      (x0_ae1SX :: Bool) ->
      case x0_ae1SX of { __DEFAULT -> ds1_de7Ff }

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataBool_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> Bool -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae5is) _ [Occ=Dead] (x0_ae1SX [Occ=Once] :: Bool) ->
                 case x0_ae1SX of { __DEFAULT -> GHC.Types.[] @ u_ae5is }}]
Data.Data.$fDataBool_$cgmapQ
  = \ (@ u_ae5is) _ [Occ=Dead] (x0_ae1SX :: Bool) ->
      case x0_ae1SX of { __DEFAULT -> GHC.Types.[] @ u_ae5is }

-- RHS size: {terms: 10, types: 16, coercions: 6, joins: 0/0}
Data.Data.$fDataBool3
  :: forall r r'.
     (r -> r' -> r)
     -> r -> (forall d. Data d => d -> r') -> Bool -> Const r Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_ae5hU)
                 (@ r'_ae5hV)
                 _ [Occ=Dead]
                 (ds1_de7Fc [Occ=Once] :: r_ae5hU)
                 _ [Occ=Dead]
                 (eta_Xzx [Occ=Once] :: Bool) ->
                 case eta_Xzx of { __DEFAULT ->
                 ds1_de7Fc
                 `cast` (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r_ae5hU>_R <Bool>_P)
                         :: (r_ae5hU :: *) ~R# (Const r_ae5hU Bool :: *))
                 }}]
Data.Data.$fDataBool3
  = \ (@ r_ae5hU)
      (@ r'_ae5hV)
      _ [Occ=Dead]
      (ds1_de7Fc :: r_ae5hU)
      _ [Occ=Dead]
      (eta_Xzx :: Bool) ->
      case eta_Xzx of { __DEFAULT ->
      ds1_de7Fc
      `cast` (Sym (Data.Functor.Const.N:Const[0]
                       <*>_N <r_ae5hU>_R <Bool>_P)
              :: (r_ae5hU :: *) ~R# (Const r_ae5hU Bool :: *))
      }

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fDataBool4
  :: (forall b. Data b => b -> b) -> Bool -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (x0_Xe2SW [Occ=Once] :: Bool) -> x0_Xe2SW}]
Data.Data.$fDataBool4
  = \ _ [Occ=Dead] (x0_Xe2SW :: Bool) -> x0_Xe2SW

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataBool_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c Bool)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae5hm :: * -> * -> *))
                 (@ (c_ae5hn :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae5hn Bool)}]
Data.Data.$fDataBool_$cdataCast2
  = \ (@ (t_ae5hm :: * -> * -> *))
      (@ (c_ae5hn :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5hn Bool)

-- RHS size: {terms: 33, types: 39, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo5 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Bool -> m Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 60] 250 0}]
Data.Data.$w$cgmapMo5
  = \ (@ (m_seg7O :: * -> *))
      (w_seg7P :: MonadPlus m_seg7O)
      (w1_seg7R :: Bool) ->
      let {
        lvl270_se9Gp :: m_seg7O Bool
        [LclId]
        lvl270_se9Gp = mzero @ m_seg7O w_seg7P @ Bool } in
      let {
        $dMonad_se9tt [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg7O
        [LclId]
        $dMonad_se9tt = GHC.Base.$p2MonadPlus @ m_seg7O w_seg7P } in
      >>=
        @ m_seg7O
        $dMonad_se9tt
        @ (Bool, Bool)
        @ Bool
        (case w1_seg7R of {
           False ->
             return
               @ m_seg7O $dMonad_se9tt @ (Bool, Bool) Data.Data.$fDataBool2;
           True ->
             return @ m_seg7O $dMonad_se9tt @ (Bool, Bool) Data.Data.$fDataBool1
         })
        (\ (ds_de7pa :: (Bool, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9Gp;
             True -> return @ m_seg7O $dMonad_se9tt @ Bool x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataBool_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Bool -> m Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg7O :: * -> *))
                 (w_seg7P [Occ=Once] :: MonadPlus m_seg7O)
                 _ [Occ=Dead]
                 (w2_seg7R [Occ=Once] :: Bool) ->
                 Data.Data.$w$cgmapMo5 @ m_seg7O w_seg7P w2_seg7R}]
Data.Data.$fDataBool_$cgmapMo
  = \ (@ (m_seg7O :: * -> *))
      (w_seg7P :: MonadPlus m_seg7O)
      _ [Occ=Dead]
      (w2_seg7R :: Bool) ->
      Data.Data.$w$cgmapMo5 @ m_seg7O w_seg7P w2_seg7R

-- RHS size: {terms: 16, types: 1, coercions: 31, joins: 0/0}
Data.Data.$fDataBool [InlPrag=NOUSERINLINE CONLIKE] :: Data Bool
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: Bool
                        Data.Data.$fDataBool5
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Bool>_N
                                :: (Data.Typeable.Internal.TypeRep Bool :: *)
                                   ~R# (Typeable Bool :: Constraint))
                        Data.Data.$fDataBool_$cgfoldl
                        Data.Data.$fDataBool_$cgunfold
                        Data.Data.$fDataBool_$ctoConstr
                        Data.Data.$fDataBool_$cdataTypeOf
                        Data.Data.$fDataBool_$cdataCast1
                        Data.Data.$fDataBool_$cdataCast2
                        Data.Data.$fDataBool4
                        Data.Data.$fDataBool3
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <Bool>_R
                                ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <Bool>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> Bool
                                    -> Const r Bool :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r -> (forall d. Data d => d -> r') -> Bool -> r :: *))
                        Data.Data.$fDataBool_$cgmapQr
                        Data.Data.$fDataBool_$cgmapQ
                        Data.Data.$fDataBool_$cgmapQi
                        Data.Data.$fDataBool_$cgmapM
                        Data.Data.$fDataBool_$cgmapMp
                        Data.Data.$fDataBool_$cgmapMo]
Data.Data.$fDataBool
  = Data.Data.C:Data
      @ Bool
      (Data.Data.$fDataBool5
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Bool>_N
               :: (Data.Typeable.Internal.TypeRep Bool :: *)
                  ~R# (Typeable Bool :: Constraint)))
      Data.Data.$fDataBool_$cgfoldl
      Data.Data.$fDataBool_$cgunfold
      Data.Data.$fDataBool_$ctoConstr
      Data.Data.$fDataBool_$cdataTypeOf
      Data.Data.$fDataBool_$cdataCast1
      Data.Data.$fDataBool_$cdataCast2
      Data.Data.$fDataBool4
      (Data.Data.$fDataBool3
       `cast` (forall (r :: <*>_N) (r' :: <*>_N).
               <r -> r' -> r>_R
               ->_R <r>_R
               ->_R <forall d. Data d => d -> r'>_R
               ->_R <Bool>_R
               ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <Bool>_P
               :: (forall r r'.
                   (r -> r' -> r)
                   -> r -> (forall d. Data d => d -> r') -> Bool -> Const r Bool :: *)
                  ~R# (forall r r'.
                       (r -> r' -> r)
                       -> r -> (forall d. Data d => d -> r') -> Bool -> r :: *)))
      Data.Data.$fDataBool_$cgmapQr
      Data.Data.$fDataBool_$cgmapQ
      Data.Data.$fDataBool_$cgmapQi
      Data.Data.$fDataBool_$cgmapM
      Data.Data.$fDataBool_$cgmapMp
      Data.Data.$fDataBool_$cgmapMo

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataAll2 :: Bool -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (v_XzM [Occ=Once] :: Bool) -> v_XzM}]
Data.Data.$fDataAll2 = \ (v_XzM :: Bool) -> v_XzM

-- RHS size: {terms: 9, types: 26, coercions: 5, joins: 0/0}
Data.Data.$fDataAny_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Any -> c Any
[GblId,
 Arity=3,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_ae40h :: * -> *))
                 (k_ae2ou [Occ=Once!]
                    :: forall d b. Data d => c_ae40h (d -> b) -> d -> c_ae40h b)
                 (z_ae2ov [Occ=Once!] :: forall g. g -> c_ae40h g)
                 (ds_de7wT [Occ=Once] :: Any) ->
                 k_ae2ou
                   @ Bool
                   @ Any
                   Data.Data.$fDataBool
                   (z_ae2ov
                      @ (Bool -> Any)
                      (Data.Data.$fDataAll2
                       `cast` (<Bool>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                               :: (Bool -> Bool :: *) ~R# (Bool -> Any :: *))))
                   (ds_de7wT
                    `cast` (Data.Semigroup.Internal.N:Any[0]
                            :: (Any :: *) ~R# (Bool :: *)))}]
Data.Data.$fDataAny_$cgfoldl
  = \ (@ (c_ae40h :: * -> *))
      (k_ae2ou
         :: forall d b. Data d => c_ae40h (d -> b) -> d -> c_ae40h b)
      (z_ae2ov :: forall g. g -> c_ae40h g)
      (ds_de7wT :: Any) ->
      k_ae2ou
        @ Bool
        @ Any
        Data.Data.$fDataBool
        (z_ae2ov
           @ (Bool -> Any)
           (Data.Data.$fDataAll2
            `cast` (<Bool>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                    :: (Bool -> Bool :: *) ~R# (Bool -> Any :: *))))
        (ds_de7wT
         `cast` (Data.Semigroup.Internal.N:Any[0]
                 :: (Any :: *) ~R# (Bool :: *)))

-- RHS size: {terms: 8, types: 25, coercions: 4, joins: 0/0}
Data.Data.$fDataAny_$cgunfold
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c Any
[GblId,
 Arity=3,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_ae40r :: * -> *))
                 (k_ae2ox [Occ=Once!]
                    :: forall b r. Data b => c_ae40r (b -> r) -> c_ae40r r)
                 (z_ae2oy [Occ=Once!] :: forall r. r -> c_ae40r r)
                 _ [Occ=Dead] ->
                 k_ae2ox
                   @ Bool
                   @ Any
                   Data.Data.$fDataBool
                   (z_ae2oy
                      @ (Bool -> Any)
                      (Data.Data.$fDataAll2
                       `cast` (<Bool>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                               :: (Bool -> Bool :: *) ~R# (Bool -> Any :: *))))}]
Data.Data.$fDataAny_$cgunfold
  = \ (@ (c_ae40r :: * -> *))
      (k_ae2ox :: forall b r. Data b => c_ae40r (b -> r) -> c_ae40r r)
      (z_ae2oy :: forall r. r -> c_ae40r r)
      _ [Occ=Dead] ->
      k_ae2ox
        @ Bool
        @ Any
        Data.Data.$fDataBool
        (z_ae2oy
           @ (Bool -> Any)
           (Data.Data.$fDataAll2
            `cast` (<Bool>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                    :: (Bool -> Bool :: *) ~R# (Bool -> Any :: *))))

-- RHS size: {terms: 9, types: 26, coercions: 5, joins: 0/0}
Data.Data.$fDataAll_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> All -> c All
[GblId,
 Arity=3,
 Str=<C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_ae43s :: * -> *))
                 (k_ae2oz [Occ=Once!]
                    :: forall d b. Data d => c_ae43s (d -> b) -> d -> c_ae43s b)
                 (z_ae2oA [Occ=Once!] :: forall g. g -> c_ae43s g)
                 (ds_de7xd [Occ=Once] :: All) ->
                 k_ae2oz
                   @ Bool
                   @ All
                   Data.Data.$fDataBool
                   (z_ae2oA
                      @ (Bool -> All)
                      (Data.Data.$fDataAll2
                       `cast` (<Bool>_R ->_R Sym (Data.Semigroup.Internal.N:All[0])
                               :: (Bool -> Bool :: *) ~R# (Bool -> All :: *))))
                   (ds_de7xd
                    `cast` (Data.Semigroup.Internal.N:All[0]
                            :: (All :: *) ~R# (Bool :: *)))}]
Data.Data.$fDataAll_$cgfoldl
  = \ (@ (c_ae43s :: * -> *))
      (k_ae2oz
         :: forall d b. Data d => c_ae43s (d -> b) -> d -> c_ae43s b)
      (z_ae2oA :: forall g. g -> c_ae43s g)
      (ds_de7xd :: All) ->
      k_ae2oz
        @ Bool
        @ All
        Data.Data.$fDataBool
        (z_ae2oA
           @ (Bool -> All)
           (Data.Data.$fDataAll2
            `cast` (<Bool>_R ->_R Sym (Data.Semigroup.Internal.N:All[0])
                    :: (Bool -> Bool :: *) ~R# (Bool -> All :: *))))
        (ds_de7xd
         `cast` (Data.Semigroup.Internal.N:All[0]
                 :: (All :: *) ~R# (Bool :: *)))

-- RHS size: {terms: 8, types: 25, coercions: 4, joins: 0/0}
Data.Data.$fDataAll_$cgunfold
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c All
[GblId,
 Arity=3,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_ae43C :: * -> *))
                 (k_ae2oC [Occ=Once!]
                    :: forall b r. Data b => c_ae43C (b -> r) -> c_ae43C r)
                 (z_ae2oD [Occ=Once!] :: forall r. r -> c_ae43C r)
                 _ [Occ=Dead] ->
                 k_ae2oC
                   @ Bool
                   @ All
                   Data.Data.$fDataBool
                   (z_ae2oD
                      @ (Bool -> All)
                      (Data.Data.$fDataAll2
                       `cast` (<Bool>_R ->_R Sym (Data.Semigroup.Internal.N:All[0])
                               :: (Bool -> Bool :: *) ~R# (Bool -> All :: *))))}]
Data.Data.$fDataAll_$cgunfold
  = \ (@ (c_ae43C :: * -> *))
      (k_ae2oC :: forall b r. Data b => c_ae43C (b -> r) -> c_ae43C r)
      (z_ae2oD :: forall r. r -> c_ae43C r)
      _ [Occ=Dead] ->
      k_ae2oC
        @ Bool
        @ All
        Data.Data.$fDataBool
        (z_ae2oD
           @ (Bool -> All)
           (Data.Data.$fDataAll2
            `cast` (<Bool>_R ->_R Sym (Data.Semigroup.Internal.N:All[0])
                    :: (Bool -> Bool :: *) ~R# (Bool -> All :: *))))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataNonEmpty6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fDataNonEmpty6 = "NonEmpty"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataNonEmpty5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataNonEmpty5
  = unpackCString# Data.Data.$fDataNonEmpty6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str4_rejOD :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str4_rejOD = ":|"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str5_rejOE :: String
[GblId]
str5_rejOE = unpackCString# str4_rejOD

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go3_rejOF :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go3_rejOF
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str5_rejOE of {
                False -> go3_rejOF ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$c:|1_rejOG :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$c:|1_rejOG = Data.Data.AlgConstr $c:|2_rejOH

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataNonEmpty4 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataNonEmpty4
  = GHC.Types.: @ Constr Data.Data.$c:| (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataNonEmpty3 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataNonEmpty3
  = Data.Data.AlgRep Data.Data.$fDataNonEmpty4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tNonEmpty :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$tNonEmpty
  = Data.Data.DataType
      Data.Data.$fDataNonEmpty5 Data.Data.$fDataNonEmpty3

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$c:| [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$c:|
  = Data.Data.Constr
      $c:|1_rejOG
      str5_rejOE
      (GHC.Types.[] @ String)
      Data.Data.Infix
      Data.Data.$tNonEmpty

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$c:|2_rejOH :: ConIndex
[GblId]
$c:|2_rejOH
  = go3_rejOF Data.Data.$fDataNonEmpty4 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tMaybe1_rejOI :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$tMaybe1_rejOI = "Maybe"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tMaybe2_rejOJ :: [Char]
[GblId]
$tMaybe2_rejOJ = unpackCString# $tMaybe1_rejOI

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str6_rejOK :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str6_rejOK = "Nothing"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str7_rejOL :: String
[GblId]
str7_rejOL = unpackCString# str6_rejOK

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str8_rejOM :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str8_rejOM = "Just"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str9_rejON :: String
[GblId]
str9_rejON = unpackCString# str8_rejOM

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go4_rejOO :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go4_rejOO
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str9_rejON of {
                False -> go4_rejOO ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go5_rejOP :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go5_rejOP
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str7_rejOL of {
                False -> go5_rejOP ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cJust1_rejOQ :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cJust1_rejOQ = Data.Data.AlgConstr $cJust2_rejOW

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cNothing1_rejOR :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cNothing1_rejOR = Data.Data.AlgConstr $cNothing2_rejOV

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cJust [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cJust
  = Data.Data.Constr
      $cJust1_rejOQ
      str9_rejON
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tMaybe

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$tMaybe3_rejOS :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tMaybe3_rejOS
  = GHC.Types.: @ Constr Data.Data.$cJust (GHC.Types.[] @ Constr)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$tMaybe4_rejOT :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tMaybe4_rejOT
  = GHC.Types.: @ Constr Data.Data.$cNothing $tMaybe3_rejOS

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tMaybe5_rejOU :: DataRep
[GblId, Str=m1, Unf=OtherCon []]
$tMaybe5_rejOU = Data.Data.AlgRep $tMaybe4_rejOT

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tMaybe [Occ=LoopBreaker] :: DataType
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$tMaybe
  = Data.Data.DataType $tMaybe2_rejOJ $tMaybe5_rejOU

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cNothing [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cNothing
  = Data.Data.Constr
      $cNothing1_rejOR
      str7_rejOL
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tMaybe

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cNothing2_rejOV :: ConIndex
[GblId]
$cNothing2_rejOV = go5_rejOP $tMaybe4_rejOT Data.Data.mkConstr1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cJust2_rejOW :: ConIndex
[GblId]
$cJust2_rejOW = go4_rejOO $tMaybe4_rejOT Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Data.$fDataMaybe2 :: forall a. (Maybe a, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataMaybe2
  = \ (@ a_Xe5Kv) -> (GHC.Base.Nothing @ a_Xe5Kv, GHC.Types.False)

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fDataMaybe1 :: forall a. (a -> Maybe a, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataMaybe1
  = \ (@ a_Xe5Kv) -> (GHC.Base.Just @ a_Xe5Kv, GHC.Types.False)

-- RHS size: {terms: 64, types: 121, coercions: 0, joins: 0/3}
Data.Data.$fDataMaybe_$cgmapMp
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Maybe a -> m (Maybe a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 60] 560 0}]
Data.Data.$fDataMaybe_$cgmapMp
  = \ (@ a_Xe5Kv)
      ($dData_Xe5Kx :: Data a_Xe5Kv)
      (@ (m_ae5cJ :: * -> *))
      ($dMonadPlus_ae5cL :: MonadPlus m_ae5cJ)
      (ds_de7EE :: forall d. Data d => d -> m_ae5cJ d)
      (eta_XA3 :: Maybe a_Xe5Kv) ->
      let {
        lvl270_se9GM :: m_ae5cJ (Maybe a_Xe5Kv)
        [LclId]
        lvl270_se9GM
          = mzero @ m_ae5cJ $dMonadPlus_ae5cL @ (Maybe a_Xe5Kv) } in
      let {
        $dMonad_se9tr [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae5cJ
        [LclId]
        $dMonad_se9tr
          = GHC.Base.$p2MonadPlus @ m_ae5cJ $dMonadPlus_ae5cL } in
      >>=
        @ m_ae5cJ
        $dMonad_se9tr
        @ (Maybe a_Xe5Kv, Bool)
        @ (Maybe a_Xe5Kv)
        (case eta_XA3 of {
           Nothing ->
             return
               @ m_ae5cJ
               $dMonad_se9tr
               @ (Maybe a_Xe5Kv, Bool)
               (Data.Data.$fDataMaybe2 @ a_Xe5Kv);
           Just a1_ae2qI ->
             let {
               lvl271_se9GL :: m_ae5cJ a_Xe5Kv
               [LclId]
               lvl271_se9GL = ds_de7EE @ a_Xe5Kv $dData_Xe5Kx a1_ae2qI } in
             >>=
               @ m_ae5cJ
               $dMonad_se9tr
               @ (a_Xe5Kv -> Maybe a_Xe5Kv, Bool)
               @ (Maybe a_Xe5Kv, Bool)
               (return
                  @ m_ae5cJ
                  $dMonad_se9tr
                  @ (a_Xe5Kv -> Maybe a_Xe5Kv, Bool)
                  (Data.Data.$fDataMaybe1 @ a_Xe5Kv))
               (\ (ds1_de7oD :: (a_Xe5Kv -> Maybe a_Xe5Kv, Bool)) ->
                  case ds1_de7oD of { (h_ae1TA, b_ae1TB) ->
                  mplus
                    @ m_ae5cJ
                    $dMonadPlus_ae5cL
                    @ (Maybe a_Xe5Kv, Bool)
                    (>>=
                       @ m_ae5cJ
                       $dMonad_se9tr
                       @ a_Xe5Kv
                       @ (Maybe a_Xe5Kv, Bool)
                       lvl271_se9GL
                       (\ (y'_ae1TC :: a_Xe5Kv) ->
                          return
                            @ m_ae5cJ
                            $dMonad_se9tr
                            @ (Maybe a_Xe5Kv, Bool)
                            (h_ae1TA y'_ae1TC, GHC.Types.True)))
                    (return
                       @ m_ae5cJ
                       $dMonad_se9tr
                       @ (Maybe a_Xe5Kv, Bool)
                       (h_ae1TA a1_ae2qI, b_ae1TB))
                  })
         })
        (\ (ds1_de7oa :: (Maybe a_Xe5Kv, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9GM;
             True -> return @ m_ae5cJ $dMonad_se9tr @ (Maybe a_Xe5Kv) x'_ae1TD
           }
           })

-- RHS size: {terms: 31, types: 51, coercions: 0, joins: 0/1}
Data.Data.$fDataMaybe_$cgmapM
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Maybe a -> m (Maybe a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S,U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 150 60 60] 270 0}]
Data.Data.$fDataMaybe_$cgmapM
  = \ (@ a_Xe5Ku)
      ($dData_Xe5Kw :: Data a_Xe5Ku)
      (@ (m_ae5ct :: * -> *))
      ($dMonad_ae5cv :: Monad m_ae5ct)
      (ds_de7ED :: forall d. Data d => d -> m_ae5ct d)
      (eta_XA4 :: Maybe a_Xe5Ku) ->
      case eta_XA4 of {
        Nothing ->
          return
            @ m_ae5ct
            $dMonad_ae5cv
            @ (Maybe a_Xe5Ku)
            (GHC.Base.Nothing @ a_Xe5Ku);
        Just a1_ae2qI ->
          let {
            lvl270_se9GN :: m_ae5ct a_Xe5Ku
            [LclId]
            lvl270_se9GN = ds_de7ED @ a_Xe5Ku $dData_Xe5Kw a1_ae2qI } in
          >>=
            @ m_ae5ct
            $dMonad_ae5cv
            @ (a_Xe5Ku -> Maybe a_Xe5Ku)
            @ (Maybe a_Xe5Ku)
            (return
               @ m_ae5ct
               $dMonad_ae5cv
               @ (a_Xe5Ku -> Maybe a_Xe5Ku)
               (GHC.Base.Just @ a_Xe5Ku))
            (\ (c'_ae1To :: a_Xe5Ku -> Maybe a_Xe5Ku) ->
               >>=
                 @ m_ae5ct
                 $dMonad_ae5cv
                 @ a_Xe5Ku
                 @ (Maybe a_Xe5Ku)
                 lvl270_se9GN
                 (\ (x'_ae1Tp :: a_Xe5Ku) ->
                    return
                      @ m_ae5ct $dMonad_ae5cv @ (Maybe a_Xe5Ku) (c'_ae1To x'_ae1Tp)))
      }

-- RHS size: {terms: 22, types: 24, coercions: 0, joins: 0/0}
Data.Data.$fDataMaybe_$cgmapQi
  :: forall a.
     Data a =>
     forall u. Int -> (forall d. Data d => d -> u) -> Maybe a -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe5Kt)
                 ($dData_Xe5Kv [Occ=Once] :: Data a_Xe5Kt)
                 (@ u_ae5cf)
                 (ds_de7EB [Occ=Once!] :: Int)
                 (ds1_de7EC [Occ=Once!] :: forall d. Data d => d -> u_ae5cf)
                 (x_ae1T7 [Occ=Once!] :: Maybe a_Xe5Kt) ->
                 case x_ae1T7 of {
                   Nothing -> Data.Maybe.fromJust1 @ u_ae5cf;
                   Just a1_ae2qI [Occ=Once] ->
                     case ds_de7EB of { I# x1_a22G [Occ=Once!] ->
                     case x1_a22G of {
                       __DEFAULT -> Data.Maybe.fromJust1 @ u_ae5cf;
                       0# -> ds1_de7EC @ a_Xe5Kt $dData_Xe5Kv a1_ae2qI
                     }
                     }
                 }}]
Data.Data.$fDataMaybe_$cgmapQi
  = \ (@ a_Xe5Kt)
      ($dData_Xe5Kv :: Data a_Xe5Kt)
      (@ u_ae5cf)
      (ds_de7EB :: Int)
      (ds1_de7EC :: forall d. Data d => d -> u_ae5cf)
      (x_ae1T7 :: Maybe a_Xe5Kt) ->
      case x_ae1T7 of {
        Nothing -> Data.Maybe.fromJust1 @ u_ae5cf;
        Just a1_ae2qI ->
          case ds_de7EB of { I# x1_a22G ->
          case x1_a22G of {
            __DEFAULT -> Data.Maybe.fromJust1 @ u_ae5cf;
            0# -> ds1_de7EC @ a_Xe5Kt $dData_Xe5Kv a1_ae2qI
          }
          }
      }

-- RHS size: {terms: 18, types: 24, coercions: 0, joins: 0/0}
Data.Data.$fDataMaybe_$cgmapQr
  :: forall a.
     Data a =>
     forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> Maybe a -> r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe5Kr)
                 ($dData_Xe5Kt [Occ=Once] :: Data a_Xe5Kr)
                 (@ r_ae5bK)
                 (@ r'_ae5bL)
                 (ds_de7Ex [Occ=Once!] :: r'_ae5bL -> r_ae5bK -> r_ae5bK)
                 (ds1_de7Ey [Occ=Once*] :: r_ae5bK)
                 (ds2_de7Ez [Occ=Once!] :: forall d. Data d => d -> r'_ae5bL)
                 (x0_ae1SX [Occ=Once!] :: Maybe a_Xe5Kr) ->
                 case x0_ae1SX of {
                   Nothing -> ds1_de7Ey;
                   Just a1_ae2qI [Occ=Once] ->
                     ds_de7Ex (ds2_de7Ez @ a_Xe5Kr $dData_Xe5Kt a1_ae2qI) ds1_de7Ey
                 }}]
Data.Data.$fDataMaybe_$cgmapQr
  = \ (@ a_Xe5Kr)
      ($dData_Xe5Kt :: Data a_Xe5Kr)
      (@ r_ae5bK)
      (@ r'_ae5bL)
      (ds_de7Ex :: r'_ae5bL -> r_ae5bK -> r_ae5bK)
      (ds1_de7Ey :: r_ae5bK)
      (ds2_de7Ez :: forall d. Data d => d -> r'_ae5bL)
      (x0_ae1SX :: Maybe a_Xe5Kr) ->
      case x0_ae1SX of {
        Nothing -> ds1_de7Ey;
        Just a1_ae2qI ->
          ds_de7Ex (ds2_de7Ez @ a_Xe5Kr $dData_Xe5Kt a1_ae2qI) ds1_de7Ey
      }

-- RHS size: {terms: 15, types: 21, coercions: 0, joins: 0/0}
Data.Data.$fDataMaybe_$cgmapQ
  :: forall a.
     Data a =>
     forall u. (forall d. Data d => d -> u) -> Maybe a -> [u]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,1*C1(C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe5Ks)
                 ($dData_Xe5Ku [Occ=Once] :: Data a_Xe5Ks)
                 (@ u_ae5c1)
                 (ds_de7EA [Occ=Once!] :: forall d. Data d => d -> u_ae5c1)
                 (x0_ae1SX [Occ=Once!] :: Maybe a_Xe5Ks) ->
                 case x0_ae1SX of {
                   Nothing -> GHC.Types.[] @ u_ae5c1;
                   Just a1_ae2qI [Occ=Once] ->
                     GHC.Types.:
                       @ u_ae5c1
                       (ds_de7EA @ a_Xe5Ks $dData_Xe5Ku a1_ae2qI)
                       (GHC.Types.[] @ u_ae5c1)
                 }}]
Data.Data.$fDataMaybe_$cgmapQ
  = \ (@ a_Xe5Ks)
      ($dData_Xe5Ku :: Data a_Xe5Ks)
      (@ u_ae5c1)
      (ds_de7EA :: forall d. Data d => d -> u_ae5c1)
      (x0_ae1SX :: Maybe a_Xe5Ks) ->
      case x0_ae1SX of {
        Nothing -> GHC.Types.[] @ u_ae5c1;
        Just a1_ae2qI ->
          GHC.Types.:
            @ u_ae5c1
            (ds_de7EA @ a_Xe5Ks $dData_Xe5Ku a1_ae2qI)
            (GHC.Types.[] @ u_ae5c1)
      }

-- RHS size: {terms: 18, types: 24, coercions: 14, joins: 0/0}
Data.Data.$fDataMaybe3
  :: forall a.
     Data a =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data d => d -> r')
     -> Maybe a
     -> Const r (Maybe a)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe5Kq)
                 ($dData_Xe5Ks [Occ=Once] :: Data a_Xe5Kq)
                 (@ r_ae5bt)
                 (@ r'_ae5bu)
                 (ds_de7Eu [Occ=Once!] :: r_ae5bt -> r'_ae5bu -> r_ae5bt)
                 (ds1_de7Ev [Occ=Once*] :: r_ae5bt)
                 (ds2_de7Ew [Occ=Once!] :: forall d. Data d => d -> r'_ae5bu)
                 (eta_XAa [Occ=Once!] :: Maybe a_Xe5Kq) ->
                 case eta_XAa of {
                   Nothing ->
                     ds1_de7Ev
                     `cast` (Sym (Data.Functor.Const.N:Const[0]
                                      <*>_N <r_ae5bt>_R <Maybe a_Xe5Kq>_P)
                             :: (r_ae5bt :: *) ~R# (Const r_ae5bt (Maybe a_Xe5Kq) :: *));
                   Just a1_ae2qI [Occ=Once] ->
                     (ds_de7Eu ds1_de7Ev (ds2_de7Ew @ a_Xe5Kq $dData_Xe5Ks a1_ae2qI))
                     `cast` (Sym (Data.Functor.Const.N:Const[0]
                                      <*>_N <r_ae5bt>_R <Maybe a_Xe5Kq>_P)
                             :: (r_ae5bt :: *) ~R# (Const r_ae5bt (Maybe a_Xe5Kq) :: *))
                 }}]
Data.Data.$fDataMaybe3
  = \ (@ a_Xe5Kq)
      ($dData_Xe5Ks :: Data a_Xe5Kq)
      (@ r_ae5bt)
      (@ r'_ae5bu)
      (ds_de7Eu :: r_ae5bt -> r'_ae5bu -> r_ae5bt)
      (ds1_de7Ev :: r_ae5bt)
      (ds2_de7Ew :: forall d. Data d => d -> r'_ae5bu)
      (eta_XAa :: Maybe a_Xe5Kq) ->
      case eta_XAa of {
        Nothing ->
          ds1_de7Ev
          `cast` (Sym (Data.Functor.Const.N:Const[0]
                           <*>_N <r_ae5bt>_R <Maybe a_Xe5Kq>_P)
                  :: (r_ae5bt :: *) ~R# (Const r_ae5bt (Maybe a_Xe5Kq) :: *));
        Just a1_ae2qI ->
          (ds_de7Eu ds1_de7Ev (ds2_de7Ew @ a_Xe5Kq $dData_Xe5Ks a1_ae2qI))
          `cast` (Sym (Data.Functor.Const.N:Const[0]
                           <*>_N <r_ae5bt>_R <Maybe a_Xe5Kq>_P)
                  :: (r_ae5bt :: *) ~R# (Const r_ae5bt (Maybe a_Xe5Kq) :: *))
      }

-- RHS size: {terms: 13, types: 18, coercions: 8, joins: 0/0}
Data.Data.$fDataMaybe4
  :: forall a.
     Data a =>
     (forall b. Data b => b -> b) -> Maybe a -> Identity (Maybe a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,1*C1(C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe5Kp)
                 ($dData_Xe5Kr [Occ=Once] :: Data a_Xe5Kp)
                 (ds_de7Et [Occ=Once!] :: forall b. Data b => b -> b)
                 (x0_Xe2TB [Occ=Once!] :: Maybe a_Xe5Kp) ->
                 case x0_Xe2TB of {
                   Nothing ->
                     (GHC.Base.Nothing @ a_Xe5Kp)
                     `cast` (Sym (Data.Functor.Identity.N:Identity[0] <Maybe a_Xe5Kp>_R)
                             :: (Maybe a_Xe5Kp :: *) ~R# (Identity (Maybe a_Xe5Kp) :: *));
                   Just a1_ae2qI [Occ=Once] ->
                     (GHC.Base.Just
                        @ a_Xe5Kp (ds_de7Et @ a_Xe5Kp $dData_Xe5Kr a1_ae2qI))
                     `cast` (Sym (Data.Functor.Identity.N:Identity[0] <Maybe a_Xe5Kp>_R)
                             :: (Maybe a_Xe5Kp :: *) ~R# (Identity (Maybe a_Xe5Kp) :: *))
                 }}]
Data.Data.$fDataMaybe4
  = \ (@ a_Xe5Kp)
      ($dData_Xe5Kr :: Data a_Xe5Kp)
      (ds_de7Et :: forall b. Data b => b -> b)
      (x0_Xe2TB :: Maybe a_Xe5Kp) ->
      case x0_Xe2TB of {
        Nothing ->
          (GHC.Base.Nothing @ a_Xe5Kp)
          `cast` (Sym (Data.Functor.Identity.N:Identity[0] <Maybe a_Xe5Kp>_R)
                  :: (Maybe a_Xe5Kp :: *) ~R# (Identity (Maybe a_Xe5Kp) :: *));
        Just a1_ae2qI ->
          (GHC.Base.Just
             @ a_Xe5Kp (ds_de7Et @ a_Xe5Kp $dData_Xe5Kr a1_ae2qI))
          `cast` (Sym (Data.Functor.Identity.N:Identity[0] <Maybe a_Xe5Kp>_R)
                  :: (Maybe a_Xe5Kp :: *) ~R# (Identity (Maybe a_Xe5Kp) :: *))
      }

-- RHS size: {terms: 74, types: 130, coercions: 0, joins: 0/3}
Data.Data.$fDataMaybe_$cgmapMo
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Maybe a -> m (Maybe a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 60] 640 0}]
Data.Data.$fDataMaybe_$cgmapMo
  = \ (@ a_Xe5Ko)
      ($dData_Xe6kH :: Data a_Xe5Ko)
      (@ (m_ae5cZ :: * -> *))
      ($dMonadPlus_ae5d1 :: MonadPlus m_ae5cZ)
      (ds_de7EF :: forall d. Data d => d -> m_ae5cZ d)
      (eta_XAm :: Maybe a_Xe5Ko) ->
      let {
        lvl270_se9GX :: m_ae5cZ (Maybe a_Xe5Ko)
        [LclId]
        lvl270_se9GX
          = mzero @ m_ae5cZ $dMonadPlus_ae5d1 @ (Maybe a_Xe5Ko) } in
      let {
        $dMonad_se9tp [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae5cZ
        [LclId]
        $dMonad_se9tp
          = GHC.Base.$p2MonadPlus @ m_ae5cZ $dMonadPlus_ae5d1 } in
      >>=
        @ m_ae5cZ
        $dMonad_se9tp
        @ (Maybe a_Xe5Ko, Bool)
        @ (Maybe a_Xe5Ko)
        (case eta_XAm of {
           Nothing ->
             return
               @ m_ae5cZ
               $dMonad_se9tp
               @ (Maybe a_Xe5Ko, Bool)
               (Data.Data.$fDataMaybe2 @ a_Xe5Ko);
           Just a1_ae2qI ->
             let {
               lvl271_se9GW :: m_ae5cZ a_Xe5Ko
               [LclId]
               lvl271_se9GW = ds_de7EF @ a_Xe5Ko $dData_Xe6kH a1_ae2qI } in
             >>=
               @ m_ae5cZ
               $dMonad_se9tp
               @ (a_Xe5Ko -> Maybe a_Xe5Ko, Bool)
               @ (Maybe a_Xe5Ko, Bool)
               (return
                  @ m_ae5cZ
                  $dMonad_se9tp
                  @ (a_Xe5Ko -> Maybe a_Xe5Ko, Bool)
                  (Data.Data.$fDataMaybe1 @ a_Xe5Ko))
               (\ (ds1_de7pD :: (a_Xe5Ko -> Maybe a_Xe5Ko, Bool)) ->
                  case ds1_de7pD of { (h_ae1TP, b_ae1TQ) ->
                  case b_ae1TQ of {
                    False ->
                      mplus
                        @ m_ae5cZ
                        $dMonadPlus_ae5d1
                        @ (Maybe a_Xe5Ko, Bool)
                        (>>=
                           @ m_ae5cZ
                           $dMonad_se9tp
                           @ a_Xe5Ko
                           @ (Maybe a_Xe5Ko, Bool)
                           lvl271_se9GW
                           (\ (y'_ae1TR :: a_Xe5Ko) ->
                              return
                                @ m_ae5cZ
                                $dMonad_se9tp
                                @ (Maybe a_Xe5Ko, Bool)
                                (h_ae1TP y'_ae1TR, GHC.Types.True)))
                        (return
                           @ m_ae5cZ
                           $dMonad_se9tp
                           @ (Maybe a_Xe5Ko, Bool)
                           (h_ae1TP a1_ae2qI, GHC.Types.False));
                    True ->
                      return
                        @ m_ae5cZ
                        $dMonad_se9tp
                        @ (Maybe a_Xe5Ko, Bool)
                        (h_ae1TP a1_ae2qI, GHC.Types.True)
                  }
                  })
         })
        (\ (ds1_de7pa :: (Maybe a_Xe5Ko, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9GX;
             True -> return @ m_ae5cZ $dMonad_se9tp @ (Maybe a_Xe5Ko) x'_ae1TS
           }
           })

-- RHS size: {terms: 8, types: 7, coercions: 0, joins: 0/0}
lvl98_rejOX :: forall a. Maybe a -> Constr
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []]
lvl98_rejOX
  = \ (@ a_Xe5Kn) (ds_de7Ep :: Maybe a_Xe5Kn) ->
      case ds_de7Ep of {
        Nothing -> Data.Data.$cNothing;
        Just ds1_de7Eq -> Data.Data.$cJust
      }

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl99_rejOY :: forall a. Maybe a -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl99_rejOY = \ (@ a_Xe5Kn) _ [Occ=Dead] -> Data.Data.$tMaybe

-- RHS size: {terms: 6, types: 35, coercions: 0, joins: 0/0}
lvl100_rejOZ
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c (Maybe a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl100_rejOZ
  = \ (@ a_Xe5Kn)
      (@ (t_ae5aV :: * -> * -> *))
      (@ (c_ae5aW :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5aW (Maybe a_Xe5Kn))

-- RHS size: {terms: 30, types: 21, coercions: 47, joins: 0/0}
Data.Data.$fDataMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data a => Data (Maybe a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_ae1XY) (v_XAj :: Data a_ae1XY) ->
       Data.Data.C:Data TYPE: Maybe a_ae1XY
                        (Data.Data.$fDataMaybe6 @ a_ae1XY v_XAj)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Maybe
                                                                                    a_ae1XY>_N
                                :: (Data.Typeable.Internal.TypeRep (Maybe a_ae1XY) :: *)
                                   ~R# (Typeable (Maybe a_ae1XY) :: Constraint))
                        Data.Data.$fDataMaybe_$cgfoldl @ a_ae1XY v_XAj
                        Data.Data.$fDataMaybe_$cgunfold @ a_ae1XY v_XAj
                        \ (ds_de7Ep [Occ=Once!] :: Maybe a_ae1XY) ->
                          case ds_de7Ep of {
                            Nothing -> Data.Data.$cNothing;
                            Just _ [Occ=Dead] -> Data.Data.$cJust
                          }
                        \ _ [Occ=Dead] -> Data.Data.$tMaybe
                        Data.Data.$fDataMaybe_$cdataCast1 @ a_ae1XY v_XAj
                        \ (@ (t_ae5aV :: * -> * -> *))
                          (@ (c_ae5aW :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae5aW (Maybe a_ae1XY))
                        (Data.Data.$fDataMaybe4 @ a_ae1XY v_XAj)
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <Maybe a_ae1XY>_R
                                ->_R Data.Functor.Identity.N:Identity[0] <Maybe a_ae1XY>_R
                                :: ((forall b. Data b => b -> b)
                                    -> Maybe a_ae1XY -> Identity (Maybe a_ae1XY) :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> Maybe a_ae1XY -> Maybe a_ae1XY :: *))
                        (Data.Data.$fDataMaybe3 @ a_ae1XY v_XAj)
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <Maybe a_ae1XY>_R
                                ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <Maybe a_ae1XY>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> Maybe a_ae1XY
                                    -> Const r (Maybe a_ae1XY) :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d. Data d => d -> r')
                                        -> Maybe a_ae1XY
                                        -> r :: *))
                        Data.Data.$fDataMaybe_$cgmapQr @ a_ae1XY v_XAj
                        Data.Data.$fDataMaybe_$cgmapQ @ a_ae1XY v_XAj
                        Data.Data.$fDataMaybe_$cgmapQi @ a_ae1XY v_XAj
                        Data.Data.$fDataMaybe_$cgmapM @ a_ae1XY v_XAj
                        Data.Data.$fDataMaybe_$cgmapMp @ a_ae1XY v_XAj
                        Data.Data.$fDataMaybe_$cgmapMo @ a_ae1XY v_XAj]
Data.Data.$fDataMaybe
  = \ (@ a_Xe5Kn) ($dData_Xe6kH :: Data a_Xe5Kn) ->
      Data.Data.C:Data
        @ (Maybe a_Xe5Kn)
        ((Data.Data.$fDataMaybe6 @ a_Xe5Kn $dData_Xe6kH)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Maybe
                                                                     a_Xe5Kn>_N
                 :: (Data.Typeable.Internal.TypeRep (Maybe a_Xe5Kn) :: *)
                    ~R# (Typeable (Maybe a_Xe5Kn) :: Constraint)))
        (Data.Data.$fDataMaybe_$cgfoldl @ a_Xe5Kn $dData_Xe6kH)
        (Data.Data.$fDataMaybe_$cgunfold @ a_Xe5Kn $dData_Xe6kH)
        (lvl98_rejOX @ a_Xe5Kn)
        (lvl99_rejOY @ a_Xe5Kn)
        (Data.Data.$fDataMaybe_$cdataCast1 @ a_Xe5Kn $dData_Xe6kH)
        (lvl100_rejOZ @ a_Xe5Kn)
        ((Data.Data.$fDataMaybe4 @ a_Xe5Kn $dData_Xe6kH)
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <Maybe a_Xe5Kn>_R
                 ->_R Data.Functor.Identity.N:Identity[0] <Maybe a_Xe5Kn>_R
                 :: ((forall b. Data b => b -> b)
                     -> Maybe a_Xe5Kn -> Identity (Maybe a_Xe5Kn) :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> Maybe a_Xe5Kn -> Maybe a_Xe5Kn :: *)))
        ((Data.Data.$fDataMaybe3 @ a_Xe5Kn $dData_Xe6kH)
         `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                 <r -> r' -> r>_R
                 ->_R <r>_R
                 ->_R <forall d. Data d => d -> r'>_R
                 ->_R <Maybe a_Xe5Kn>_R
                 ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <Maybe a_Xe5Kn>_P
                 :: (forall r r'.
                     (r -> r' -> r)
                     -> r
                     -> (forall d. Data d => d -> r')
                     -> Maybe a_Xe5Kn
                     -> Const r (Maybe a_Xe5Kn) :: *)
                    ~R# (forall r r'.
                         (r -> r' -> r)
                         -> r -> (forall d. Data d => d -> r') -> Maybe a_Xe5Kn -> r :: *)))
        (Data.Data.$fDataMaybe_$cgmapQr @ a_Xe5Kn $dData_Xe6kH)
        (Data.Data.$fDataMaybe_$cgmapQ @ a_Xe5Kn $dData_Xe6kH)
        (Data.Data.$fDataMaybe_$cgmapQi @ a_Xe5Kn $dData_Xe6kH)
        (Data.Data.$fDataMaybe_$cgmapM @ a_Xe5Kn $dData_Xe6kH)
        (Data.Data.$fDataMaybe_$cgmapMp @ a_Xe5Kn $dData_Xe6kH)
        (Data.Data.$fDataMaybe_$cgmapMo @ a_Xe5Kn $dData_Xe6kH)

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Data.$fDataFirst2 :: forall a. Maybe a -> Maybe a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_Xe4nT) (v_XAr [Occ=Once] :: Maybe a_Xe4nT) -> v_XAr}]
Data.Data.$fDataFirst2
  = \ (@ a_Xe4nT) (v_XAr :: Maybe a_Xe4nT) -> v_XAr

-- RHS size: {terms: 14, types: 40, coercions: 8, joins: 0/1}
Data.Data.$fDataLast_$cgfoldl
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Last a -> c (Last a)
[GblId,
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 120 60}]
Data.Data.$fDataLast_$cgfoldl
  = \ (@ a_Xe4nT)
      ($dData_Xe4nV :: Data a_Xe4nT)
      (@ (c_ae3Np :: * -> *)) ->
      let {
        $dData1_se9tn :: Data (Maybe a_Xe4nT)
        [LclId]
        $dData1_se9tn = Data.Data.$fDataMaybe @ a_Xe4nT $dData_Xe4nV } in
      \ (k_ae2o6
           :: forall d b. Data d => c_ae3Np (d -> b) -> d -> c_ae3Np b)
        (z_ae2o7 :: forall g. g -> c_ae3Np g)
        (ds_de7vF :: Last a_Xe4nT) ->
        k_ae2o6
          @ (Maybe a_Xe4nT)
          @ (Last a_Xe4nT)
          $dData1_se9tn
          (z_ae2o7
             @ (Maybe a_Xe4nT -> Last a_Xe4nT)
             ((Data.Data.$fDataFirst2 @ a_Xe4nT)
              `cast` (<Maybe a_Xe4nT>_R
                      ->_R Sym (Data.Monoid.N:Last[0]) <a_Xe4nT>_N
                      :: (Maybe a_Xe4nT -> Maybe a_Xe4nT :: *)
                         ~R# (Maybe a_Xe4nT -> Last a_Xe4nT :: *))))
          (ds_de7vF
           `cast` (Data.Monoid.N:Last[0] <a_Xe4nT>_N
                   :: (Last a_Xe4nT :: *) ~R# (Maybe a_Xe4nT :: *)))

-- RHS size: {terms: 13, types: 38, coercions: 6, joins: 0/1}
Data.Data.$fDataLast_$cgunfold
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c (Last a)
[GblId,
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 110 60}]
Data.Data.$fDataLast_$cgunfold
  = \ (@ a_Xe4nU)
      ($dData_Xe4nW :: Data a_Xe4nU)
      (@ (c_ae3NA :: * -> *)) ->
      let {
        $dData1_se9tl :: Data (Maybe a_Xe4nU)
        [LclId]
        $dData1_se9tl = Data.Data.$fDataMaybe @ a_Xe4nU $dData_Xe4nW } in
      \ (k_ae2o9 :: forall b r. Data b => c_ae3NA (b -> r) -> c_ae3NA r)
        (z_ae2oa :: forall r. r -> c_ae3NA r)
        _ [Occ=Dead] ->
        k_ae2o9
          @ (Maybe a_Xe4nU)
          @ (Last a_Xe4nU)
          $dData1_se9tl
          (z_ae2oa
             @ (Maybe a_Xe4nU -> Last a_Xe4nU)
             ((Data.Data.$fDataFirst2 @ a_Xe4nU)
              `cast` (<Maybe a_Xe4nU>_R
                      ->_R Sym (Data.Monoid.N:Last[0]) <a_Xe4nU>_N
                      :: (Maybe a_Xe4nU -> Maybe a_Xe4nU :: *)
                         ~R# (Maybe a_Xe4nU -> Last a_Xe4nU :: *))))

-- RHS size: {terms: 14, types: 40, coercions: 8, joins: 0/1}
Data.Data.$fDataFirst_$cgfoldl
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> First a -> c (First a)
[GblId,
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 120 60}]
Data.Data.$fDataFirst_$cgfoldl
  = \ (@ a_Xe4r9)
      ($dData_Xe4rb :: Data a_Xe4r9)
      (@ (c_ae3QD :: * -> *)) ->
      let {
        $dData1_se9tj :: Data (Maybe a_Xe4r9)
        [LclId]
        $dData1_se9tj = Data.Data.$fDataMaybe @ a_Xe4r9 $dData_Xe4rb } in
      \ (k_ae2oc
           :: forall d b. Data d => c_ae3QD (d -> b) -> d -> c_ae3QD b)
        (z_ae2od :: forall g. g -> c_ae3QD g)
        (ds_de7vY :: First a_Xe4r9) ->
        k_ae2oc
          @ (Maybe a_Xe4r9)
          @ (First a_Xe4r9)
          $dData1_se9tj
          (z_ae2od
             @ (Maybe a_Xe4r9 -> First a_Xe4r9)
             ((Data.Data.$fDataFirst2 @ a_Xe4r9)
              `cast` (<Maybe a_Xe4r9>_R
                      ->_R Sym (Data.Monoid.N:First[0]) <a_Xe4r9>_N
                      :: (Maybe a_Xe4r9 -> Maybe a_Xe4r9 :: *)
                         ~R# (Maybe a_Xe4r9 -> First a_Xe4r9 :: *))))
          (ds_de7vY
           `cast` (Data.Monoid.N:First[0] <a_Xe4r9>_N
                   :: (First a_Xe4r9 :: *) ~R# (Maybe a_Xe4r9 :: *)))

-- RHS size: {terms: 13, types: 38, coercions: 6, joins: 0/1}
Data.Data.$fDataFirst_$cgunfold
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c (First a)
[GblId,
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 110 60}]
Data.Data.$fDataFirst_$cgunfold
  = \ (@ a_Xe4ra)
      ($dData_Xe4rc :: Data a_Xe4ra)
      (@ (c_ae3QO :: * -> *)) ->
      let {
        $dData1_se9th :: Data (Maybe a_Xe4ra)
        [LclId]
        $dData1_se9th = Data.Data.$fDataMaybe @ a_Xe4ra $dData_Xe4rc } in
      \ (k_ae2of :: forall b r. Data b => c_ae3QO (b -> r) -> c_ae3QO r)
        (z_ae2og :: forall r. r -> c_ae3QO r)
        _ [Occ=Dead] ->
        k_ae2of
          @ (Maybe a_Xe4ra)
          @ (First a_Xe4ra)
          $dData1_se9th
          (z_ae2og
             @ (Maybe a_Xe4ra -> First a_Xe4ra)
             ((Data.Data.$fDataFirst2 @ a_Xe4ra)
              `cast` (<Maybe a_Xe4ra>_R
                      ->_R Sym (Data.Monoid.N:First[0]) <a_Xe4ra>_N
                      :: (Maybe a_Xe4ra -> Maybe a_Xe4ra :: *)
                         ~R# (Maybe a_Xe4ra -> First a_Xe4ra :: *))))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tOrdering1_rejP0 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$tOrdering1_rejP0 = "Ordering"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tOrdering2_rejP1 :: [Char]
[GblId]
$tOrdering2_rejP1 = unpackCString# $tOrdering1_rejP0

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str10_rejP2 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str10_rejP2 = "LT"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str11_rejP3 :: String
[GblId]
str11_rejP3 = unpackCString# str10_rejP2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str12_rejP4 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str12_rejP4 = "GT"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str13_rejP5 :: String
[GblId]
str13_rejP5 = unpackCString# str12_rejP4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str14_rejP6 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str14_rejP6 = "EQ"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str15_rejP7 :: String
[GblId]
str15_rejP7 = unpackCString# str14_rejP6

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go6_rejP8 :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go6_rejP8
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str11_rejP3 of {
                False -> go6_rejP8 ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go7_rejP9 :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go7_rejP9
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str15_rejP7 of {
                False -> go7_rejP9 ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go8_rejPa :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go8_rejPa
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str13_rejP5 of {
                False -> go8_rejPa ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cLT1_rejPb :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cLT1_rejPb = Data.Data.AlgConstr $cLT2_rejPk

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cEQ1_rejPc :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cEQ1_rejPc = Data.Data.AlgConstr $cEQ2_rejPj

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cGT1_rejPd :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cGT1_rejPd = Data.Data.AlgConstr $cGT2_rejPi

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$tOrdering3_rejPe :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tOrdering3_rejPe
  = GHC.Types.: @ Constr Data.Data.$cGT (GHC.Types.[] @ Constr)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$tOrdering4_rejPf :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tOrdering4_rejPf
  = GHC.Types.: @ Constr Data.Data.$cLT $tOrdering6_rejPh

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tOrdering5_rejPg :: DataRep
[GblId, Str=m1, Unf=OtherCon []]
$tOrdering5_rejPg = Data.Data.AlgRep $tOrdering4_rejPf

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tOrdering [Occ=LoopBreaker] :: DataType
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$tOrdering
  = Data.Data.DataType $tOrdering2_rejP1 $tOrdering5_rejPg

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cEQ [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cEQ
  = Data.Data.Constr
      $cEQ1_rejPc
      str15_rejP7
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tOrdering

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$tOrdering6_rejPh :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tOrdering6_rejPh
  = GHC.Types.: @ Constr Data.Data.$cEQ $tOrdering3_rejPe

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cLT [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cLT
  = Data.Data.Constr
      $cLT1_rejPb
      str11_rejP3
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tOrdering

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cGT [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cGT
  = Data.Data.Constr
      $cGT1_rejPd
      str13_rejP5
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tOrdering

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cGT2_rejPi :: ConIndex
[GblId]
$cGT2_rejPi = go8_rejPa $tOrdering4_rejPf Data.Data.mkConstr1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cEQ2_rejPj :: ConIndex
[GblId]
$cEQ2_rejPj = go7_rejP9 $tOrdering4_rejPf Data.Data.mkConstr1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cLT2_rejPk :: ConIndex
[GblId]
$cLT2_rejPk = go6_rejP8 $tOrdering4_rejPf Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataOrdering_$cdataTypeOf :: Ordering -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Data.$tOrdering}]
Data.Data.$fDataOrdering_$cdataTypeOf
  = \ _ [Occ=Dead] -> Data.Data.$tOrdering

-- RHS size: {terms: 9, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataOrdering_$ctoConstr :: Ordering -> Constr
[GblId,
 Arity=1,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_de7E2 [Occ=Once!] :: Ordering) ->
                 case ds_de7E2 of {
                   LT -> Data.Data.$cLT;
                   EQ -> Data.Data.$cEQ;
                   GT -> Data.Data.$cGT
                 }}]
Data.Data.$fDataOrdering_$ctoConstr
  = \ (ds_de7E2 :: Ordering) ->
      case ds_de7E2 of {
        LT -> Data.Data.$cLT;
        EQ -> Data.Data.$cEQ;
        GT -> Data.Data.$cGT
      }

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataOrdering_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c Ordering)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae57i :: * -> *))
                 (@ (c_ae57j :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae57j Ordering)}]
Data.Data.$fDataOrdering_$cdataCast1
  = \ (@ (t_ae57i :: * -> *))
      (@ (c_ae57j :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae57j Ordering)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataOrdering3 :: (Ordering, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataOrdering3 = (GHC.Types.LT, GHC.Types.False)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataOrdering2 :: (Ordering, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataOrdering2 = (GHC.Types.EQ, GHC.Types.False)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataOrdering1 :: (Ordering, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataOrdering1 = (GHC.Types.GT, GHC.Types.False)

-- RHS size: {terms: 37, types: 43, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp26 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Ordering -> m Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 100] 290 0}]
Data.Data.$w$cgmapMp26
  = \ (@ (m_seg8v :: * -> *))
      (w_seg8w :: MonadPlus m_seg8v)
      (w1_seg8y :: Ordering) ->
      let {
        lvl270_se9Hk :: m_seg8v Ordering
        [LclId]
        lvl270_se9Hk = mzero @ m_seg8v w_seg8w @ Ordering } in
      let {
        $dMonad_se9tf [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg8v
        [LclId]
        $dMonad_se9tf = GHC.Base.$p2MonadPlus @ m_seg8v w_seg8w } in
      >>=
        @ m_seg8v
        $dMonad_se9tf
        @ (Ordering, Bool)
        @ Ordering
        (case w1_seg8y of {
           LT ->
             return
               @ m_seg8v
               $dMonad_se9tf
               @ (Ordering, Bool)
               Data.Data.$fDataOrdering3;
           EQ ->
             return
               @ m_seg8v
               $dMonad_se9tf
               @ (Ordering, Bool)
               Data.Data.$fDataOrdering2;
           GT ->
             return
               @ m_seg8v
               $dMonad_se9tf
               @ (Ordering, Bool)
               Data.Data.$fDataOrdering1
         })
        (\ (ds_de7oa :: (Ordering, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9Hk;
             True -> return @ m_seg8v $dMonad_se9tf @ Ordering x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataOrdering_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Ordering -> m Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg8v :: * -> *))
                 (w_seg8w [Occ=Once] :: MonadPlus m_seg8v)
                 _ [Occ=Dead]
                 (w2_seg8y [Occ=Once] :: Ordering) ->
                 Data.Data.$w$cgmapMp26 @ m_seg8v w_seg8w w2_seg8y}]
Data.Data.$fDataOrdering_$cgmapMp
  = \ (@ (m_seg8v :: * -> *))
      (w_seg8w :: MonadPlus m_seg8v)
      _ [Occ=Dead]
      (w2_seg8y :: Ordering) ->
      Data.Data.$w$cgmapMp26 @ m_seg8v w_seg8w w2_seg8y

-- RHS size: {terms: 17, types: 14, coercions: 0, joins: 0/0}
Data.Data.$w$cgmapM13 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). Monad m => Ordering -> m Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 100] 120 0}]
Data.Data.$w$cgmapM13
  = \ (@ (m_seg8A :: * -> *))
      (w_seg8B :: Monad m_seg8A)
      (w1_seg8D :: Ordering) ->
      case w1_seg8D of {
        LT -> return @ m_seg8A w_seg8B @ Ordering GHC.Types.LT;
        EQ -> return @ m_seg8A w_seg8B @ Ordering GHC.Types.EQ;
        GT -> return @ m_seg8A w_seg8B @ Ordering GHC.Types.GT
      }

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataOrdering_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Ordering -> m Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg8A :: * -> *))
                 (w_seg8B [Occ=Once] :: Monad m_seg8A)
                 _ [Occ=Dead]
                 (w2_seg8D [Occ=Once] :: Ordering) ->
                 Data.Data.$w$cgmapM13 @ m_seg8A w_seg8B w2_seg8D}]
Data.Data.$fDataOrdering_$cgmapM
  = \ (@ (m_seg8A :: * -> *))
      (w_seg8B :: Monad m_seg8A)
      _ [Occ=Dead]
      (w2_seg8D :: Ordering) ->
      Data.Data.$w$cgmapM13 @ m_seg8A w_seg8B w2_seg8D

-- RHS size: {terms: 8, types: 12, coercions: 0, joins: 0/0}
Data.Data.$fDataOrdering_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> Ordering -> u
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,1*U>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae58V)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (x_ae1T7 [Occ=Once] :: Ordering) ->
                 case x_ae1T7 of { __DEFAULT -> Data.Maybe.fromJust1 @ u_ae58V }}]
Data.Data.$fDataOrdering_$cgmapQi
  = \ (@ u_ae58V) _ [Occ=Dead] _ [Occ=Dead] (x_ae1T7 :: Ordering) ->
      case x_ae1T7 of { __DEFAULT -> Data.Maybe.fromJust1 @ u_ae58V }

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
Data.Data.$fDataOrdering_$cgmapQr
  :: forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> Ordering -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_ae58q)
                 (@ r'_ae58r)
                 _ [Occ=Dead]
                 (ds1_de7Eb [Occ=Once] :: r_ae58q)
                 _ [Occ=Dead]
                 (x0_ae1SX [Occ=Once] :: Ordering) ->
                 case x0_ae1SX of { __DEFAULT -> ds1_de7Eb }}]
Data.Data.$fDataOrdering_$cgmapQr
  = \ (@ r_ae58q)
      (@ r'_ae58r)
      _ [Occ=Dead]
      (ds1_de7Eb :: r_ae58q)
      _ [Occ=Dead]
      (x0_ae1SX :: Ordering) ->
      case x0_ae1SX of { __DEFAULT -> ds1_de7Eb }

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataOrdering_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> Ordering -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae58H)
                 _ [Occ=Dead]
                 (x0_ae1SX [Occ=Once] :: Ordering) ->
                 case x0_ae1SX of { __DEFAULT -> GHC.Types.[] @ u_ae58H }}]
Data.Data.$fDataOrdering_$cgmapQ
  = \ (@ u_ae58H) _ [Occ=Dead] (x0_ae1SX :: Ordering) ->
      case x0_ae1SX of { __DEFAULT -> GHC.Types.[] @ u_ae58H }

-- RHS size: {terms: 10, types: 16, coercions: 6, joins: 0/0}
Data.Data.$fDataOrdering4
  :: forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data d => d -> r')
     -> Ordering
     -> Const r Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_ae589)
                 (@ r'_ae58a)
                 _ [Occ=Dead]
                 (ds1_de7E8 [Occ=Once] :: r_ae589)
                 _ [Occ=Dead]
                 (eta_XAH [Occ=Once] :: Ordering) ->
                 case eta_XAH of { __DEFAULT ->
                 ds1_de7E8
                 `cast` (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r_ae589>_R <Ordering>_P)
                         :: (r_ae589 :: *) ~R# (Const r_ae589 Ordering :: *))
                 }}]
Data.Data.$fDataOrdering4
  = \ (@ r_ae589)
      (@ r'_ae58a)
      _ [Occ=Dead]
      (ds1_de7E8 :: r_ae589)
      _ [Occ=Dead]
      (eta_XAH :: Ordering) ->
      case eta_XAH of { __DEFAULT ->
      ds1_de7E8
      `cast` (Sym (Data.Functor.Const.N:Const[0]
                       <*>_N <r_ae589>_R <Ordering>_P)
              :: (r_ae589 :: *) ~R# (Const r_ae589 Ordering :: *))
      }

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fDataOrdering5
  :: (forall b. Data b => b -> b) -> Ordering -> Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (x0_Xe2U6 [Occ=Once] :: Ordering) ->
                 x0_Xe2U6}]
Data.Data.$fDataOrdering5
  = \ _ [Occ=Dead] (x0_Xe2U6 :: Ordering) -> x0_Xe2U6

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataOrdering_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c Ordering)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae57B :: * -> * -> *))
                 (@ (c_ae57C :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae57C Ordering)}]
Data.Data.$fDataOrdering_$cdataCast2
  = \ (@ (t_ae57B :: * -> * -> *))
      (@ (c_ae57C :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae57C Ordering)

-- RHS size: {terms: 37, types: 43, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo25 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => Ordering -> m Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 100] 290 0}]
Data.Data.$w$cgmapMo25
  = \ (@ (m_seg8F :: * -> *))
      (w_seg8G :: MonadPlus m_seg8F)
      (w1_seg8I :: Ordering) ->
      let {
        lvl270_se9Hw :: m_seg8F Ordering
        [LclId]
        lvl270_se9Hw = mzero @ m_seg8F w_seg8G @ Ordering } in
      let {
        $dMonad_se9td [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_seg8F
        [LclId]
        $dMonad_se9td = GHC.Base.$p2MonadPlus @ m_seg8F w_seg8G } in
      >>=
        @ m_seg8F
        $dMonad_se9td
        @ (Ordering, Bool)
        @ Ordering
        (case w1_seg8I of {
           LT ->
             return
               @ m_seg8F
               $dMonad_se9td
               @ (Ordering, Bool)
               Data.Data.$fDataOrdering3;
           EQ ->
             return
               @ m_seg8F
               $dMonad_se9td
               @ (Ordering, Bool)
               Data.Data.$fDataOrdering2;
           GT ->
             return
               @ m_seg8F
               $dMonad_se9td
               @ (Ordering, Bool)
               Data.Data.$fDataOrdering1
         })
        (\ (ds_de7pa :: (Ordering, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9Hw;
             True -> return @ m_seg8F $dMonad_se9td @ Ordering x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataOrdering_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Ordering -> m Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_seg8F :: * -> *))
                 (w_seg8G [Occ=Once] :: MonadPlus m_seg8F)
                 _ [Occ=Dead]
                 (w2_seg8I [Occ=Once] :: Ordering) ->
                 Data.Data.$w$cgmapMo25 @ m_seg8F w_seg8G w2_seg8I}]
Data.Data.$fDataOrdering_$cgmapMo
  = \ (@ (m_seg8F :: * -> *))
      (w_seg8G :: MonadPlus m_seg8F)
      _ [Occ=Dead]
      (w2_seg8I :: Ordering) ->
      Data.Data.$w$cgmapMo25 @ m_seg8F w_seg8G w2_seg8I

-- RHS size: {terms: 16, types: 1, coercions: 31, joins: 0/0}
Data.Data.$fDataOrdering [InlPrag=NOUSERINLINE CONLIKE]
  :: Data Ordering
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: Ordering
                        Data.Data.$fDataOrdering6
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Ordering>_N
                                :: (Data.Typeable.Internal.TypeRep Ordering :: *)
                                   ~R# (Typeable Ordering :: Constraint))
                        Data.Data.$fDataOrdering_$cgfoldl
                        Data.Data.$fDataOrdering_$cgunfold
                        Data.Data.$fDataOrdering_$ctoConstr
                        Data.Data.$fDataOrdering_$cdataTypeOf
                        Data.Data.$fDataOrdering_$cdataCast1
                        Data.Data.$fDataOrdering_$cdataCast2
                        Data.Data.$fDataOrdering5
                        Data.Data.$fDataOrdering4
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <Ordering>_R
                                ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <Ordering>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> Ordering
                                    -> Const r Ordering :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d. Data d => d -> r')
                                        -> Ordering
                                        -> r :: *))
                        Data.Data.$fDataOrdering_$cgmapQr
                        Data.Data.$fDataOrdering_$cgmapQ
                        Data.Data.$fDataOrdering_$cgmapQi
                        Data.Data.$fDataOrdering_$cgmapM
                        Data.Data.$fDataOrdering_$cgmapMp
                        Data.Data.$fDataOrdering_$cgmapMo]
Data.Data.$fDataOrdering
  = Data.Data.C:Data
      @ Ordering
      (Data.Data.$fDataOrdering6
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Ordering>_N
               :: (Data.Typeable.Internal.TypeRep Ordering :: *)
                  ~R# (Typeable Ordering :: Constraint)))
      Data.Data.$fDataOrdering_$cgfoldl
      Data.Data.$fDataOrdering_$cgunfold
      Data.Data.$fDataOrdering_$ctoConstr
      Data.Data.$fDataOrdering_$cdataTypeOf
      Data.Data.$fDataOrdering_$cdataCast1
      Data.Data.$fDataOrdering_$cdataCast2
      Data.Data.$fDataOrdering5
      (Data.Data.$fDataOrdering4
       `cast` (forall (r :: <*>_N) (r' :: <*>_N).
               <r -> r' -> r>_R
               ->_R <r>_R
               ->_R <forall d. Data d => d -> r'>_R
               ->_R <Ordering>_R
               ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <Ordering>_P
               :: (forall r r'.
                   (r -> r' -> r)
                   -> r
                   -> (forall d. Data d => d -> r')
                   -> Ordering
                   -> Const r Ordering :: *)
                  ~R# (forall r r'.
                       (r -> r' -> r)
                       -> r -> (forall d. Data d => d -> r') -> Ordering -> r :: *)))
      Data.Data.$fDataOrdering_$cgmapQr
      Data.Data.$fDataOrdering_$cgmapQ
      Data.Data.$fDataOrdering_$cgmapQi
      Data.Data.$fDataOrdering_$cgmapM
      Data.Data.$fDataOrdering_$cgmapMp
      Data.Data.$fDataOrdering_$cgmapMo

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tEither1_rejPl :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$tEither1_rejPl = "Either"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tEither2_rejPm :: [Char]
[GblId]
$tEither2_rejPm = unpackCString# $tEither1_rejPl

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str16_rejPn :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str16_rejPn = "Right"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str17_rejPo :: String
[GblId]
str17_rejPo = unpackCString# str16_rejPn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str18_rejPp :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str18_rejPp = "Left"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str19_rejPq :: String
[GblId]
str19_rejPq = unpackCString# str18_rejPp

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go9_rejPr :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go9_rejPr
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str17_rejPo of {
                False -> go9_rejPr ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go10_rejPs :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go10_rejPs
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str19_rejPq of {
                False -> go10_rejPs ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cRight1_rejPt :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cRight1_rejPt = Data.Data.AlgConstr $cRight2_rejPz

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cLeft1_rejPu :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cLeft1_rejPu = Data.Data.AlgConstr $cLeft2_rejPy

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cRight [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cRight
  = Data.Data.Constr
      $cRight1_rejPt
      str17_rejPo
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tEither

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$tEither3_rejPv :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tEither3_rejPv
  = GHC.Types.: @ Constr Data.Data.$cRight (GHC.Types.[] @ Constr)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$tEither4_rejPw :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tEither4_rejPw
  = GHC.Types.: @ Constr Data.Data.$cLeft $tEither3_rejPv

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tEither5_rejPx :: DataRep
[GblId, Str=m1, Unf=OtherCon []]
$tEither5_rejPx = Data.Data.AlgRep $tEither4_rejPw

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tEither [Occ=LoopBreaker] :: DataType
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$tEither
  = Data.Data.DataType $tEither2_rejPm $tEither5_rejPx

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cLeft [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cLeft
  = Data.Data.Constr
      $cLeft1_rejPu
      str19_rejPq
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tEither

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cLeft2_rejPy :: ConIndex
[GblId]
$cLeft2_rejPy = go10_rejPs $tEither4_rejPw Data.Data.mkConstr1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cRight2_rejPz :: ConIndex
[GblId]
$cRight2_rejPz = go9_rejPr $tEither4_rejPw Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataEither2 :: forall b a. (a -> Either a b, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataEither2
  = \ (@ b_Xe5EA) (@ a_Xe5Ey) ->
      (Data.Either.Left @ a_Xe5Ey @ b_Xe5EA, GHC.Types.False)

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataEither1 :: forall b a. (b -> Either a b, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataEither1
  = \ (@ b_Xe5EA) (@ a_Xe5Ey) ->
      (Data.Either.Right @ a_Xe5Ey @ b_Xe5EA, GHC.Types.False)

-- RHS size: {terms: 79, types: 164, coercions: 18, joins: 0/4}
Data.Data.$fDataEither_$cgmapMp
  :: forall a b.
     (Data a, Data b) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Either a b -> m (Either a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 90 60 100] 680 0}]
Data.Data.$fDataEither_$cgmapMp
  = \ (@ a_Xe5Ey)
      (@ b_Xe5EA)
      ($dData_Xe5EC :: Data a_Xe5Ey)
      ($dData1_Xe5EE :: Data b_Xe5EA)
      (@ (m_ae56g :: * -> *))
      ($dMonadPlus_ae56i :: MonadPlus m_ae56g)
      (ds_de7DU :: forall d. Data d => d -> m_ae56g d)
      (eta_XB6 :: Either a_Xe5Ey b_Xe5EA) ->
      let {
        lvl270_se9HJ :: m_ae56g (Either a_Xe5Ey b_Xe5EA)
        [LclId]
        lvl270_se9HJ
          = mzero @ m_ae56g $dMonadPlus_ae56i @ (Either a_Xe5Ey b_Xe5EA) } in
      let {
        $dMonad_se9tb [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae56g
        [LclId]
        $dMonad_se9tb
          = GHC.Base.$p2MonadPlus @ m_ae56g $dMonadPlus_ae56i } in
      >>=
        @ m_ae56g
        $dMonad_se9tb
        @ (Either a_Xe5Ey b_Xe5EA, Bool)
        @ (Either a_Xe5Ey b_Xe5EA)
        (let {
           k_se9ta [Dmd=<C(C(C(S))),1*C1(C1(C1(U)))>]
             :: forall d b1.
                Data d =>
                Mp m_ae56g (d -> b1) -> d -> m_ae56g (b1, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_se9ta
             = \ (@ d_ae2Ws)
                 (@ b1_ae2Wt)
                 ($dData2_ae2Wv [OS=OneShot] :: Data d_ae2Ws)
                 (ds1_de7oC [OS=OneShot] :: Mp m_ae56g (d_ae2Ws -> b1_ae2Wt))
                 (y_ae1Tz [OS=OneShot] :: d_ae2Ws) ->
                 let {
                   lvl271_se9HG :: m_ae56g d_ae2Ws
                   [LclId]
                   lvl271_se9HG = ds_de7DU @ d_ae2Ws $dData2_ae2Wv y_ae1Tz } in
                 >>=
                   @ m_ae56g
                   $dMonad_se9tb
                   @ (d_ae2Ws -> b1_ae2Wt, Bool)
                   @ (b1_ae2Wt, Bool)
                   (ds1_de7oC
                    `cast` (Data.Data.N:Mp[0] <m_ae56g>_R <d_ae2Ws -> b1_ae2Wt>_N
                            :: (Mp m_ae56g (d_ae2Ws -> b1_ae2Wt) :: *)
                               ~R# (m_ae56g (d_ae2Ws -> b1_ae2Wt, Bool) :: *)))
                   (\ (ds2_de7oD :: (d_ae2Ws -> b1_ae2Wt, Bool)) ->
                      case ds2_de7oD of { (h_ae1TA, b2_ae1TB) ->
                      mplus
                        @ m_ae56g
                        $dMonadPlus_ae56i
                        @ (b1_ae2Wt, Bool)
                        (>>=
                           @ m_ae56g
                           $dMonad_se9tb
                           @ d_ae2Ws
                           @ (b1_ae2Wt, Bool)
                           lvl271_se9HG
                           (\ (y'_ae1TC :: d_ae2Ws) ->
                              return
                                @ m_ae56g
                                $dMonad_se9tb
                                @ (b1_ae2Wt, Bool)
                                (h_ae1TA y'_ae1TC, GHC.Types.True)))
                        (return
                           @ m_ae56g
                           $dMonad_se9tb
                           @ (b1_ae2Wt, Bool)
                           (h_ae1TA y_ae1Tz, b2_ae1TB))
                      }) } in
         case eta_XB6 of {
           Left a1_ae2qn ->
             k_se9ta
               @ a_Xe5Ey
               @ (Either a_Xe5Ey b_Xe5EA)
               $dData_Xe5EC
               ((return
                   @ m_ae56g
                   $dMonad_se9tb
                   @ (a_Xe5Ey -> Either a_Xe5Ey b_Xe5EA, Bool)
                   (Data.Data.$fDataEither2 @ b_Xe5EA @ a_Xe5Ey))
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_ae56g>_R <a_Xe5Ey -> Either a_Xe5Ey b_Xe5EA>_N)
                        :: (m_ae56g (a_Xe5Ey -> Either a_Xe5Ey b_Xe5EA, Bool) :: *)
                           ~R# (Mp m_ae56g (a_Xe5Ey -> Either a_Xe5Ey b_Xe5EA) :: *)))
               a1_ae2qn;
           Right a1_ae2qq ->
             k_se9ta
               @ b_Xe5EA
               @ (Either a_Xe5Ey b_Xe5EA)
               $dData1_Xe5EE
               ((return
                   @ m_ae56g
                   $dMonad_se9tb
                   @ (b_Xe5EA -> Either a_Xe5Ey b_Xe5EA, Bool)
                   (Data.Data.$fDataEither1 @ b_Xe5EA @ a_Xe5Ey))
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_ae56g>_R <b_Xe5EA -> Either a_Xe5Ey b_Xe5EA>_N)
                        :: (m_ae56g (b_Xe5EA -> Either a_Xe5Ey b_Xe5EA, Bool) :: *)
                           ~R# (Mp m_ae56g (b_Xe5EA -> Either a_Xe5Ey b_Xe5EA) :: *)))
               a1_ae2qq
         })
        (\ (ds1_de7oa :: (Either a_Xe5Ey b_Xe5EA, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b1_ae1TE) ->
           case b1_ae1TE of {
             False -> lvl270_se9HJ;
             True ->
               return @ m_ae56g $dMonad_se9tb @ (Either a_Xe5Ey b_Xe5EA) x'_ae1TD
           }
           })

-- RHS size: {terms: 46, types: 88, coercions: 0, joins: 0/2}
Data.Data.$fDataEither_$cgmapM
  :: forall a b.
     (Data a, Data b) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Either a b -> m (Either a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 150 60 100] 390 0}]
Data.Data.$fDataEither_$cgmapM
  = \ (@ a_Xe5Ex)
      (@ b_Xe5Ez)
      ($dData_Xe5EB :: Data a_Xe5Ex)
      ($dData1_Xe5ED :: Data b_Xe5Ez)
      (@ (m_ae560 :: * -> *))
      ($dMonad_ae562 :: Monad m_ae560)
      (ds_de7DT :: forall d. Data d => d -> m_ae560 d)
      (eta_XB7 :: Either a_Xe5Ex b_Xe5Ez) ->
      let {
        k_se9t7 [Dmd=<C(C(C(S))),1*C1(C1(C1(U)))>]
          :: forall d b1. Data d => m_ae560 (d -> b1) -> d -> m_ae560 b1
        [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
        k_se9t7
          = \ (@ d_ae2Vh)
              (@ b1_ae2Vi)
              ($dData2_ae2Vk [OS=OneShot] :: Data d_ae2Vh)
              (c_ae1Tm [OS=OneShot] :: m_ae560 (d_ae2Vh -> b1_ae2Vi))
              (x_ae1Tn [OS=OneShot] :: d_ae2Vh) ->
              let {
                lvl270_se9HK :: m_ae560 d_ae2Vh
                [LclId]
                lvl270_se9HK = ds_de7DT @ d_ae2Vh $dData2_ae2Vk x_ae1Tn } in
              >>=
                @ m_ae560
                $dMonad_ae562
                @ (d_ae2Vh -> b1_ae2Vi)
                @ b1_ae2Vi
                c_ae1Tm
                (\ (c'_ae1To :: d_ae2Vh -> b1_ae2Vi) ->
                   >>=
                     @ m_ae560
                     $dMonad_ae562
                     @ d_ae2Vh
                     @ b1_ae2Vi
                     lvl270_se9HK
                     (\ (x'_ae1Tp :: d_ae2Vh) ->
                        return
                          @ m_ae560 $dMonad_ae562 @ b1_ae2Vi (c'_ae1To x'_ae1Tp))) } in
      case eta_XB7 of {
        Left a1_ae2qn ->
          k_se9t7
            @ a_Xe5Ex
            @ (Either a_Xe5Ex b_Xe5Ez)
            $dData_Xe5EB
            (return
               @ m_ae560
               $dMonad_ae562
               @ (a_Xe5Ex -> Either a_Xe5Ex b_Xe5Ez)
               (Data.Either.Left @ a_Xe5Ex @ b_Xe5Ez))
            a1_ae2qn;
        Right a1_ae2qq ->
          k_se9t7
            @ b_Xe5Ez
            @ (Either a_Xe5Ex b_Xe5Ez)
            $dData1_Xe5ED
            (return
               @ m_ae560
               $dMonad_ae562
               @ (b_Xe5Ez -> Either a_Xe5Ex b_Xe5Ez)
               (Data.Either.Right @ a_Xe5Ex @ b_Xe5Ez))
            a1_ae2qq
      }

-- RHS size: {terms: 28, types: 31, coercions: 0, joins: 0/0}
Data.Data.$w$cgmapQi3 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data a, Data b) =>
     forall u. Int# -> (forall d. Data d => d -> u) -> Either a b -> u
[GblId,
 Arity=5,
 Str=<L,U><L,U><S,1*U><C(C(S)),1*C1(C1(U))><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 60 120 80] 120 0}]
Data.Data.$w$cgmapQi3
  = \ (@ a_seg9e)
      (@ b_seg9f)
      (w_seg9g :: Data a_seg9e)
      (w1_seg9h :: Data b_seg9f)
      (@ u_seg9i)
      (ww_seg9o :: Int#)
      (w2_seg9k :: forall d. Data d => d -> u_seg9i)
      (w3_seg9l :: Either a_seg9e b_seg9f) ->
      case w3_seg9l of {
        Left a1_ae2qn ->
          case ww_seg9o of {
            __DEFAULT -> Data.Maybe.fromJust1 @ u_seg9i;
            0# -> w2_seg9k @ a_seg9e w_seg9g a1_ae2qn
          };
        Right a1_ae2qq ->
          case ww_seg9o of {
            __DEFAULT -> Data.Maybe.fromJust1 @ u_seg9i;
            0# -> w2_seg9k @ b_seg9f w1_seg9h a1_ae2qq
          }
      }

-- RHS size: {terms: 17, types: 25, coercions: 0, joins: 0/0}
Data.Data.$fDataEither_$cgmapQi [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data a, Data b) =>
     forall u. Int -> (forall d. Data d => d -> u) -> Either a b -> u
[GblId,
 Arity=5,
 Str=<L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_seg9e)
                 (@ b_seg9f)
                 (w_seg9g [Occ=Once] :: Data a_seg9e)
                 (w1_seg9h [Occ=Once] :: Data b_seg9f)
                 (@ u_seg9i)
                 (w2_seg9j [Occ=Once!] :: Int)
                 (w3_seg9k [Occ=Once] :: forall d. Data d => d -> u_seg9i)
                 (w4_seg9l [Occ=Once] :: Either a_seg9e b_seg9f) ->
                 case w2_seg9j of { I# ww1_seg9o [Occ=Once] ->
                 Data.Data.$w$cgmapQi3
                   @ a_seg9e
                   @ b_seg9f
                   w_seg9g
                   w1_seg9h
                   @ u_seg9i
                   ww1_seg9o
                   w3_seg9k
                   w4_seg9l
                 }}]
Data.Data.$fDataEither_$cgmapQi
  = \ (@ a_seg9e)
      (@ b_seg9f)
      (w_seg9g :: Data a_seg9e)
      (w1_seg9h :: Data b_seg9f)
      (@ u_seg9i)
      (w2_seg9j :: Int)
      (w3_seg9k :: forall d. Data d => d -> u_seg9i)
      (w4_seg9l :: Either a_seg9e b_seg9f) ->
      case w2_seg9j of { I# ww1_seg9o ->
      Data.Data.$w$cgmapQi3
        @ a_seg9e
        @ b_seg9f
        w_seg9g
        w1_seg9h
        @ u_seg9i
        ww1_seg9o
        w3_seg9k
        w4_seg9l
      }

-- RHS size: {terms: 24, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataEither_$cgmapQr
  :: forall a b.
     (Data a, Data b) =>
     forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> Either a b -> r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 60 0 120 90] 140 0}]
Data.Data.$fDataEither_$cgmapQr
  = \ (@ a_Xe5Eu)
      (@ b_Xe5Ew)
      ($dData_Xe5Ey :: Data a_Xe5Eu)
      ($dData1_Xe5EA :: Data b_Xe5Ew)
      (@ r_ae55h)
      (@ r'_ae55i)
      (ds_de7DN :: r'_ae55i -> r_ae55h -> r_ae55h)
      (ds1_de7DO :: r_ae55h)
      (ds2_de7DP :: forall d. Data d => d -> r'_ae55i)
      (x0_ae1SX :: Either a_Xe5Eu b_Xe5Ew) ->
      case x0_ae1SX of {
        Left a1_ae2qn ->
          ds_de7DN (ds2_de7DP @ a_Xe5Eu $dData_Xe5Ey a1_ae2qn) ds1_de7DO;
        Right a1_ae2qq ->
          ds_de7DN (ds2_de7DP @ b_Xe5Ew $dData1_Xe5EA a1_ae2qq) ds1_de7DO
      }

-- RHS size: {terms: 21, types: 30, coercions: 0, joins: 0/0}
Data.Data.$fDataEither_$cgmapQ
  :: forall a b.
     (Data a, Data b) =>
     forall u. (forall d. Data d => d -> u) -> Either a b -> [u]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,1*C1(C1(U))><S,1*U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe5Ev)
                 (@ b_Xe5Ex)
                 ($dData_Xe5Ez [Occ=Once] :: Data a_Xe5Ev)
                 ($dData1_Xe5EB [Occ=Once] :: Data b_Xe5Ex)
                 (@ u_ae55y)
                 (ds_de7DQ [Occ=Once*!] :: forall d. Data d => d -> u_ae55y)
                 (x0_ae1SX [Occ=Once!] :: Either a_Xe5Ev b_Xe5Ex) ->
                 case x0_ae1SX of {
                   Left a1_ae2qn [Occ=Once] ->
                     GHC.Types.:
                       @ u_ae55y
                       (ds_de7DQ @ a_Xe5Ev $dData_Xe5Ez a1_ae2qn)
                       (GHC.Types.[] @ u_ae55y);
                   Right a1_ae2qq [Occ=Once] ->
                     GHC.Types.:
                       @ u_ae55y
                       (ds_de7DQ @ b_Xe5Ex $dData1_Xe5EB a1_ae2qq)
                       (GHC.Types.[] @ u_ae55y)
                 }}]
Data.Data.$fDataEither_$cgmapQ
  = \ (@ a_Xe5Ev)
      (@ b_Xe5Ex)
      ($dData_Xe5Ez :: Data a_Xe5Ev)
      ($dData1_Xe5EB :: Data b_Xe5Ex)
      (@ u_ae55y)
      (ds_de7DQ :: forall d. Data d => d -> u_ae55y)
      (x0_ae1SX :: Either a_Xe5Ev b_Xe5Ex) ->
      case x0_ae1SX of {
        Left a1_ae2qn ->
          GHC.Types.:
            @ u_ae55y
            (ds_de7DQ @ a_Xe5Ev $dData_Xe5Ez a1_ae2qn)
            (GHC.Types.[] @ u_ae55y);
        Right a1_ae2qq ->
          GHC.Types.:
            @ u_ae55y
            (ds_de7DQ @ b_Xe5Ex $dData1_Xe5EB a1_ae2qq)
            (GHC.Types.[] @ u_ae55y)
      }

-- RHS size: {terms: 24, types: 32, coercions: 16, joins: 0/0}
Data.Data.$fDataEither3
  :: forall a b.
     (Data a, Data b) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data d => d -> r')
     -> Either a b
     -> Const r (Either a b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 60 0 120 90] 140 0}]
Data.Data.$fDataEither3
  = \ (@ a_Xe5Et)
      (@ b_Xe5Ev)
      ($dData_Xe5Ex :: Data a_Xe5Et)
      ($dData1_Xe5Ez :: Data b_Xe5Ev)
      (@ r_ae550)
      (@ r'_ae551)
      (ds_de7DK :: r_ae550 -> r'_ae551 -> r_ae550)
      (ds1_de7DL :: r_ae550)
      (ds2_de7DM :: forall d. Data d => d -> r'_ae551)
      (eta_XBd :: Either a_Xe5Et b_Xe5Ev) ->
      case eta_XBd of {
        Left a1_ae2qn ->
          (ds_de7DK ds1_de7DL (ds2_de7DM @ a_Xe5Et $dData_Xe5Ex a1_ae2qn))
          `cast` (Sym (Data.Functor.Const.N:Const[0]
                           <*>_N <r_ae550>_R <Either a_Xe5Et b_Xe5Ev>_P)
                  :: (r_ae550 :: *)
                     ~R# (Const r_ae550 (Either a_Xe5Et b_Xe5Ev) :: *));
        Right a1_ae2qq ->
          (ds_de7DK ds1_de7DL (ds2_de7DM @ b_Xe5Ev $dData1_Xe5Ez a1_ae2qq))
          `cast` (Sym (Data.Functor.Const.N:Const[0]
                           <*>_N <r_ae550>_R <Either a_Xe5Et b_Xe5Ev>_P)
                  :: (r_ae550 :: *)
                     ~R# (Const r_ae550 (Either a_Xe5Et b_Xe5Ev) :: *))
      }

-- RHS size: {terms: 18, types: 28, coercions: 10, joins: 0/0}
Data.Data.$fDataEither4
  :: forall a b.
     (Data a, Data b) =>
     (forall b1. Data b1 => b1 -> b1)
     -> Either a b -> Identity (Either a b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,1*C1(C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe5Es)
                 (@ b_Xe5Eu)
                 ($dData_Xe5Ew [Occ=Once] :: Data a_Xe5Es)
                 ($dData1_Xe5Ey [Occ=Once] :: Data b_Xe5Eu)
                 (ds_de7DJ [Occ=Once*!] :: forall b1. Data b1 => b1 -> b1)
                 (x0_Xe2UG [Occ=Once!] :: Either a_Xe5Es b_Xe5Eu) ->
                 case x0_Xe2UG of {
                   Left a1_ae2qn [Occ=Once] ->
                     (Data.Either.Left
                        @ a_Xe5Es @ b_Xe5Eu (ds_de7DJ @ a_Xe5Es $dData_Xe5Ew a1_ae2qn))
                     `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Either a_Xe5Es b_Xe5Eu>_R)
                             :: (Either a_Xe5Es b_Xe5Eu :: *)
                                ~R# (Identity (Either a_Xe5Es b_Xe5Eu) :: *));
                   Right a1_ae2qq [Occ=Once] ->
                     (Data.Either.Right
                        @ a_Xe5Es @ b_Xe5Eu (ds_de7DJ @ b_Xe5Eu $dData1_Xe5Ey a1_ae2qq))
                     `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Either a_Xe5Es b_Xe5Eu>_R)
                             :: (Either a_Xe5Es b_Xe5Eu :: *)
                                ~R# (Identity (Either a_Xe5Es b_Xe5Eu) :: *))
                 }}]
Data.Data.$fDataEither4
  = \ (@ a_Xe5Es)
      (@ b_Xe5Eu)
      ($dData_Xe5Ew :: Data a_Xe5Es)
      ($dData1_Xe5Ey :: Data b_Xe5Eu)
      (ds_de7DJ :: forall b1. Data b1 => b1 -> b1)
      (x0_Xe2UG :: Either a_Xe5Es b_Xe5Eu) ->
      case x0_Xe2UG of {
        Left a1_ae2qn ->
          (Data.Either.Left
             @ a_Xe5Es @ b_Xe5Eu (ds_de7DJ @ a_Xe5Es $dData_Xe5Ew a1_ae2qn))
          `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                           <Either a_Xe5Es b_Xe5Eu>_R)
                  :: (Either a_Xe5Es b_Xe5Eu :: *)
                     ~R# (Identity (Either a_Xe5Es b_Xe5Eu) :: *));
        Right a1_ae2qq ->
          (Data.Either.Right
             @ a_Xe5Es @ b_Xe5Eu (ds_de7DJ @ b_Xe5Eu $dData1_Xe5Ey a1_ae2qq))
          `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                           <Either a_Xe5Es b_Xe5Eu>_R)
                  :: (Either a_Xe5Es b_Xe5Eu :: *)
                     ~R# (Identity (Either a_Xe5Es b_Xe5Eu) :: *))
      }

-- RHS size: {terms: 89, types: 171, coercions: 18, joins: 0/4}
Data.Data.$fDataEither_$cgmapMo
  :: forall a b.
     (Data a, Data b) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Either a b -> m (Either a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=OtherCon []]
Data.Data.$fDataEither_$cgmapMo
  = \ (@ a_Xe5Er)
      (@ b_Xe6fP)
      ($dData_Xe6fS :: Data a_Xe5Er)
      ($dData1_Xe6fV :: Data b_Xe6fP)
      (@ (m_ae56w :: * -> *))
      ($dMonadPlus_ae56y :: MonadPlus m_ae56w)
      (ds_de7DV :: forall d. Data d => d -> m_ae56w d)
      (eta_XBt :: Either a_Xe5Er b_Xe6fP) ->
      let {
        lvl270_se9HS :: m_ae56w (Either a_Xe5Er b_Xe6fP)
        [LclId]
        lvl270_se9HS
          = mzero @ m_ae56w $dMonadPlus_ae56y @ (Either a_Xe5Er b_Xe6fP) } in
      let {
        $dMonad_se9t3 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae56w
        [LclId]
        $dMonad_se9t3
          = GHC.Base.$p2MonadPlus @ m_ae56w $dMonadPlus_ae56y } in
      >>=
        @ m_ae56w
        $dMonad_se9t3
        @ (Either a_Xe5Er b_Xe6fP, Bool)
        @ (Either a_Xe5Er b_Xe6fP)
        (let {
           k_se9t2 [Dmd=<C(C(C(S))),1*C1(C1(C1(U)))>]
             :: forall d b1.
                Data d =>
                Mp m_ae56w (d -> b1) -> d -> m_ae56w (b1, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_se9t2
             = \ (@ d_ae2Ya)
                 (@ b1_ae2Yb)
                 ($dData2_ae2Yd [OS=OneShot] :: Data d_ae2Ya)
                 (ds1_de7pC [OS=OneShot] :: Mp m_ae56w (d_ae2Ya -> b1_ae2Yb))
                 (y_ae1TO [OS=OneShot] :: d_ae2Ya) ->
                 let {
                   lvl271_se9HP :: m_ae56w d_ae2Ya
                   [LclId]
                   lvl271_se9HP = ds_de7DV @ d_ae2Ya $dData2_ae2Yd y_ae1TO } in
                 >>=
                   @ m_ae56w
                   $dMonad_se9t3
                   @ (d_ae2Ya -> b1_ae2Yb, Bool)
                   @ (b1_ae2Yb, Bool)
                   (ds1_de7pC
                    `cast` (Data.Data.N:Mp[0] <m_ae56w>_R <d_ae2Ya -> b1_ae2Yb>_N
                            :: (Mp m_ae56w (d_ae2Ya -> b1_ae2Yb) :: *)
                               ~R# (m_ae56w (d_ae2Ya -> b1_ae2Yb, Bool) :: *)))
                   (\ (ds2_de7pD :: (d_ae2Ya -> b1_ae2Yb, Bool)) ->
                      case ds2_de7pD of { (h_ae1TP, b2_ae1TQ) ->
                      case b2_ae1TQ of {
                        False ->
                          mplus
                            @ m_ae56w
                            $dMonadPlus_ae56y
                            @ (b1_ae2Yb, Bool)
                            (>>=
                               @ m_ae56w
                               $dMonad_se9t3
                               @ d_ae2Ya
                               @ (b1_ae2Yb, Bool)
                               lvl271_se9HP
                               (\ (y'_ae1TR :: d_ae2Ya) ->
                                  return
                                    @ m_ae56w
                                    $dMonad_se9t3
                                    @ (b1_ae2Yb, Bool)
                                    (h_ae1TP y'_ae1TR, GHC.Types.True)))
                            (return
                               @ m_ae56w
                               $dMonad_se9t3
                               @ (b1_ae2Yb, Bool)
                               (h_ae1TP y_ae1TO, GHC.Types.False));
                        True ->
                          return
                            @ m_ae56w
                            $dMonad_se9t3
                            @ (b1_ae2Yb, Bool)
                            (h_ae1TP y_ae1TO, GHC.Types.True)
                      }
                      }) } in
         case eta_XBt of {
           Left a1_ae2qn ->
             k_se9t2
               @ a_Xe5Er
               @ (Either a_Xe5Er b_Xe6fP)
               $dData_Xe6fS
               ((return
                   @ m_ae56w
                   $dMonad_se9t3
                   @ (a_Xe5Er -> Either a_Xe5Er b_Xe6fP, Bool)
                   (Data.Data.$fDataEither2 @ b_Xe6fP @ a_Xe5Er))
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_ae56w>_R <a_Xe5Er -> Either a_Xe5Er b_Xe6fP>_N)
                        :: (m_ae56w (a_Xe5Er -> Either a_Xe5Er b_Xe6fP, Bool) :: *)
                           ~R# (Mp m_ae56w (a_Xe5Er -> Either a_Xe5Er b_Xe6fP) :: *)))
               a1_ae2qn;
           Right a1_ae2qq ->
             k_se9t2
               @ b_Xe6fP
               @ (Either a_Xe5Er b_Xe6fP)
               $dData1_Xe6fV
               ((return
                   @ m_ae56w
                   $dMonad_se9t3
                   @ (b_Xe6fP -> Either a_Xe5Er b_Xe6fP, Bool)
                   (Data.Data.$fDataEither1 @ b_Xe6fP @ a_Xe5Er))
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_ae56w>_R <b_Xe6fP -> Either a_Xe5Er b_Xe6fP>_N)
                        :: (m_ae56w (b_Xe6fP -> Either a_Xe5Er b_Xe6fP, Bool) :: *)
                           ~R# (Mp m_ae56w (b_Xe6fP -> Either a_Xe5Er b_Xe6fP) :: *)))
               a1_ae2qq
         })
        (\ (ds1_de7pa :: (Either a_Xe5Er b_Xe6fP, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b1_ae1TT) ->
           case b1_ae1TT of {
             False -> lvl270_se9HS;
             True ->
               return @ m_ae56w $dMonad_se9t3 @ (Either a_Xe5Er b_Xe6fP) x'_ae1TS
           }
           })

-- RHS size: {terms: 9, types: 12, coercions: 0, joins: 0/0}
lvl101_rejPA :: forall b a. Either a b -> Constr
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []]
lvl101_rejPA
  = \ (@ b_Xe6fP) (@ a_Xe5Eq) (ds_de7DE :: Either a_Xe5Eq b_Xe6fP) ->
      case ds_de7DE of {
        Left ds1_de7DF -> Data.Data.$cLeft;
        Right ds1_de7DG -> Data.Data.$cRight
      }

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
lvl102_rejPB :: forall a b. Either a b -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl102_rejPB
  = \ (@ a_Xe5Eq) (@ b_Xe6fP) _ [Occ=Dead] -> Data.Data.$tEither

-- RHS size: {terms: 7, types: 29, coercions: 0, joins: 0/0}
lvl103_rejPC
  :: forall a b (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Either a b))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl103_rejPC
  = \ (@ a_Xe5Eq)
      (@ b_Xe6fP)
      (@ (t_ae54a :: * -> *))
      (@ (c_ae54b :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae54b (Either a_Xe5Eq b_Xe6fP))

-- RHS size: {terms: 44, types: 41, coercions: 52, joins: 0/0}
Data.Data.$fDataEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. (Data a, Data b) => Data (Either a b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_ae1XW)
             (@ b_ae1XX)
             (v_XBp :: Data a_ae1XW)
             (v1_XBr :: Data b_ae1XX) ->
       Data.Data.C:Data TYPE: Either a_ae1XW b_ae1XX
                        (Data.Data.$fDataEither6 @ a_ae1XW @ b_ae1XX v_XBp v1_XBr)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Either
                                                                                    a_ae1XW
                                                                                    b_ae1XX>_N
                                :: (Data.Typeable.Internal.TypeRep (Either a_ae1XW b_ae1XX) :: *)
                                   ~R# (Typeable (Either a_ae1XW b_ae1XX) :: Constraint))
                        Data.Data.$fDataEither_$cgfoldl @ a_ae1XW @ b_ae1XX v_XBp v1_XBr
                        Data.Data.$fDataEither_$cgunfold @ a_ae1XW @ b_ae1XX v_XBp v1_XBr
                        \ (ds_de7DE [Occ=Once!] :: Either a_ae1XW b_ae1XX) ->
                          case ds_de7DE of {
                            Left _ [Occ=Dead] -> Data.Data.$cLeft;
                            Right _ [Occ=Dead] -> Data.Data.$cRight
                          }
                        \ _ [Occ=Dead] -> Data.Data.$tEither
                        \ (@ (t_ae54a :: * -> *))
                          (@ (c_ae54b :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae54b (Either a_ae1XW b_ae1XX))
                        Data.Data.$fDataEither_$cdataCast2 @ a_ae1XW @ b_ae1XX v_XBp v1_XBr
                        (Data.Data.$fDataEither4 @ a_ae1XW @ b_ae1XX v_XBp v1_XBr)
                        `cast` (<forall b1. Data b1 => b1 -> b1>_R
                                ->_R <Either a_ae1XW b_ae1XX>_R
                                ->_R Data.Functor.Identity.N:Identity[0] <Either a_ae1XW b_ae1XX>_R
                                :: ((forall b1. Data b1 => b1 -> b1)
                                    -> Either a_ae1XW b_ae1XX
                                    -> Identity (Either a_ae1XW b_ae1XX) :: *)
                                   ~R# ((forall b1. Data b1 => b1 -> b1)
                                        -> Either a_ae1XW b_ae1XX -> Either a_ae1XW b_ae1XX :: *))
                        (Data.Data.$fDataEither3 @ a_ae1XW @ b_ae1XX v_XBp v1_XBr)
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <Either a_ae1XW b_ae1XX>_R
                                ->_R Data.Functor.Const.N:Const[0]
                                         <*>_N <r>_R <Either a_ae1XW b_ae1XX>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> Either a_ae1XW b_ae1XX
                                    -> Const r (Either a_ae1XW b_ae1XX) :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d. Data d => d -> r')
                                        -> Either a_ae1XW b_ae1XX
                                        -> r :: *))
                        Data.Data.$fDataEither_$cgmapQr @ a_ae1XW @ b_ae1XX v_XBp v1_XBr
                        Data.Data.$fDataEither_$cgmapQ @ a_ae1XW @ b_ae1XX v_XBp v1_XBr
                        Data.Data.$fDataEither_$cgmapQi @ a_ae1XW @ b_ae1XX v_XBp v1_XBr
                        Data.Data.$fDataEither_$cgmapM @ a_ae1XW @ b_ae1XX v_XBp v1_XBr
                        Data.Data.$fDataEither_$cgmapMp @ a_ae1XW @ b_ae1XX v_XBp v1_XBr
                        Data.Data.$fDataEither_$cgmapMo @ a_ae1XW @ b_ae1XX v_XBp v1_XBr]
Data.Data.$fDataEither
  = \ (@ a_Xe5Eq)
      (@ b_Xe6fP)
      ($dData_Xe6fS :: Data a_Xe5Eq)
      ($dData1_Xe6fV :: Data b_Xe6fP) ->
      Data.Data.C:Data
        @ (Either a_Xe5Eq b_Xe6fP)
        ((Data.Data.$fDataEither6
            @ a_Xe5Eq @ b_Xe6fP $dData_Xe6fS $dData1_Xe6fV)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Either
                                                                     a_Xe5Eq b_Xe6fP>_N
                 :: (Data.Typeable.Internal.TypeRep (Either a_Xe5Eq b_Xe6fP) :: *)
                    ~R# (Typeable (Either a_Xe5Eq b_Xe6fP) :: Constraint)))
        (Data.Data.$fDataEither_$cgfoldl
           @ a_Xe5Eq @ b_Xe6fP $dData_Xe6fS $dData1_Xe6fV)
        (Data.Data.$fDataEither_$cgunfold
           @ a_Xe5Eq @ b_Xe6fP $dData_Xe6fS $dData1_Xe6fV)
        (lvl101_rejPA @ b_Xe6fP @ a_Xe5Eq)
        (lvl102_rejPB @ a_Xe5Eq @ b_Xe6fP)
        (lvl103_rejPC @ a_Xe5Eq @ b_Xe6fP)
        (Data.Data.$fDataEither_$cdataCast2
           @ a_Xe5Eq @ b_Xe6fP $dData_Xe6fS $dData1_Xe6fV)
        ((Data.Data.$fDataEither4
            @ a_Xe5Eq @ b_Xe6fP $dData_Xe6fS $dData1_Xe6fV)
         `cast` (<forall b1. Data b1 => b1 -> b1>_R
                 ->_R <Either a_Xe5Eq b_Xe6fP>_R
                 ->_R Data.Functor.Identity.N:Identity[0] <Either a_Xe5Eq b_Xe6fP>_R
                 :: ((forall b1. Data b1 => b1 -> b1)
                     -> Either a_Xe5Eq b_Xe6fP
                     -> Identity (Either a_Xe5Eq b_Xe6fP) :: *)
                    ~R# ((forall b1. Data b1 => b1 -> b1)
                         -> Either a_Xe5Eq b_Xe6fP -> Either a_Xe5Eq b_Xe6fP :: *)))
        ((Data.Data.$fDataEither3
            @ a_Xe5Eq @ b_Xe6fP $dData_Xe6fS $dData1_Xe6fV)
         `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                 <r -> r' -> r>_R
                 ->_R <r>_R
                 ->_R <forall d. Data d => d -> r'>_R
                 ->_R <Either a_Xe5Eq b_Xe6fP>_R
                 ->_R Data.Functor.Const.N:Const[0]
                          <*>_N <r>_R <Either a_Xe5Eq b_Xe6fP>_P
                 :: (forall r r'.
                     (r -> r' -> r)
                     -> r
                     -> (forall d. Data d => d -> r')
                     -> Either a_Xe5Eq b_Xe6fP
                     -> Const r (Either a_Xe5Eq b_Xe6fP) :: *)
                    ~R# (forall r r'.
                         (r -> r' -> r)
                         -> r
                         -> (forall d. Data d => d -> r')
                         -> Either a_Xe5Eq b_Xe6fP
                         -> r :: *)))
        (Data.Data.$fDataEither_$cgmapQr
           @ a_Xe5Eq @ b_Xe6fP $dData_Xe6fS $dData1_Xe6fV)
        (Data.Data.$fDataEither_$cgmapQ
           @ a_Xe5Eq @ b_Xe6fP $dData_Xe6fS $dData1_Xe6fV)
        (Data.Data.$fDataEither_$cgmapQi
           @ a_Xe5Eq @ b_Xe6fP $dData_Xe6fS $dData1_Xe6fV)
        (Data.Data.$fDataEither_$cgmapM
           @ a_Xe5Eq @ b_Xe6fP $dData_Xe6fS $dData1_Xe6fV)
        (Data.Data.$fDataEither_$cgmapMp
           @ a_Xe5Eq @ b_Xe6fP $dData_Xe6fS $dData1_Xe6fV)
        (Data.Data.$fDataEither_$cgmapMo
           @ a_Xe5Eq @ b_Xe6fP $dData_Xe6fS $dData1_Xe6fV)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData()7 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fData()7 = "()"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData()6 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fData()6 = unpackCString# Data.Data.$fData()7

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go11_rejPD :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go11_rejPD
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fData()6 of {
                False -> go11_rejPD ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$c()1_rejPE :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$c()1_rejPE = Data.Data.AlgConstr $c()2_rejPF

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fData()5 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData()5
  = GHC.Types.: @ Constr Data.Data.$c() (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData()4 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fData()4 = Data.Data.AlgRep Data.Data.$fData()5

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$t() :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$t()
  = Data.Data.DataType Data.Data.$fData()6 Data.Data.$fData()4

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$c() [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$c()
  = Data.Data.Constr
      $c()1_rejPE
      Data.Data.$fData()6
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$t()

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$c()2_rejPF :: ConIndex
[GblId]
$c()2_rejPF = go11_rejPD Data.Data.$fData()5 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fData()_$cdataTypeOf :: () -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Data.$t()}]
Data.Data.$fData()_$cdataTypeOf = \ _ [Occ=Dead] -> Data.Data.$t()

-- RHS size: {terms: 5, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fData()_$ctoConstr :: () -> Constr
[GblId,
 Arity=1,
 Str=<S,1*H>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_de7Dh [Occ=Once!] :: ()) ->
                 case ds_de7Dh of { () -> Data.Data.$c() }}]
Data.Data.$fData()_$ctoConstr
  = \ (ds_de7Dh :: ()) -> case ds_de7Dh of { () -> Data.Data.$c() }

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fData()_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c ())
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae50D :: * -> *))
                 (@ (c_ae50E :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae50E ())}]
Data.Data.$fData()_$cdataCast1
  = \ (@ (t_ae50D :: * -> *))
      (@ (c_ae50E :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae50E ())

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fData()1 :: ((), Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData()1 = (GHC.Tuple.(), GHC.Types.False)

-- RHS size: {terms: 29, types: 35, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => () -> m ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*H>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 20] 210 0}]
Data.Data.$w$cgmapMp
  = \ (@ (m_sega0 :: * -> *))
      (w_sega1 :: MonadPlus m_sega0)
      (w1_sega3 :: ()) ->
      let {
        lvl270_se9I3 :: m_sega0 ()
        [LclId]
        lvl270_se9I3 = mzero @ m_sega0 w_sega1 @ () } in
      let {
        $dMonad_se9sZ [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_sega0
        [LclId]
        $dMonad_se9sZ = GHC.Base.$p2MonadPlus @ m_sega0 w_sega1 } in
      >>=
        @ m_sega0
        $dMonad_se9sZ
        @ ((), Bool)
        @ ()
        (case w1_sega3 of { () ->
         return @ m_sega0 $dMonad_se9sZ @ ((), Bool) Data.Data.$fData()1
         })
        (\ (ds_de7oa :: ((), Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9I3;
             True -> return @ m_sega0 $dMonad_se9sZ @ () x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fData()_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> () -> m ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_sega0 :: * -> *))
                 (w_sega1 [Occ=Once] :: MonadPlus m_sega0)
                 _ [Occ=Dead]
                 (w2_sega3 [Occ=Once] :: ()) ->
                 Data.Data.$w$cgmapMp @ m_sega0 w_sega1 w2_sega3}]
Data.Data.$fData()_$cgmapMp
  = \ (@ (m_sega0 :: * -> *))
      (w_sega1 :: MonadPlus m_sega0)
      _ [Occ=Dead]
      (w2_sega3 :: ()) ->
      Data.Data.$w$cgmapMp @ m_sega0 w_sega1 w2_sega3

-- RHS size: {terms: 10, types: 17, coercions: 0, joins: 0/0}
Data.Data.$fData()_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> () -> m ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><L,A><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (m_ae52u :: * -> *))
                 ($dMonad_ae52w [Occ=Once] :: Monad m_ae52u)
                 _ [Occ=Dead]
                 (eta_XBA [Occ=Once!] :: ()) ->
                 case eta_XBA of { () ->
                 return @ m_ae52u $dMonad_ae52w @ () GHC.Tuple.()
                 }}]
Data.Data.$fData()_$cgmapM
  = \ (@ (m_ae52u :: * -> *))
      ($dMonad_ae52w :: Monad m_ae52u)
      _ [Occ=Dead]
      (eta_XBA :: ()) ->
      case eta_XBA of { () ->
      return @ m_ae52u $dMonad_ae52w @ () GHC.Tuple.()
      }

-- RHS size: {terms: 8, types: 12, coercions: 0, joins: 0/0}
Data.Data.$fData()_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> () -> u
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,1*H>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae52g)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (x_ae1T7 [Occ=Once!] :: ()) ->
                 case x_ae1T7 of { () -> Data.Maybe.fromJust1 @ u_ae52g }}]
Data.Data.$fData()_$cgmapQi
  = \ (@ u_ae52g) _ [Occ=Dead] _ [Occ=Dead] (x_ae1T7 :: ()) ->
      case x_ae1T7 of { () -> Data.Maybe.fromJust1 @ u_ae52g }

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
Data.Data.$fData()_$cgmapQr
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> () -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_ae51L)
                 (@ r'_ae51M)
                 _ [Occ=Dead]
                 (ds1_de7Dq [Occ=Once] :: r_ae51L)
                 _ [Occ=Dead]
                 (x0_ae1SX [Occ=Once!] :: ()) ->
                 case x0_ae1SX of { () -> ds1_de7Dq }}]
Data.Data.$fData()_$cgmapQr
  = \ (@ r_ae51L)
      (@ r'_ae51M)
      _ [Occ=Dead]
      (ds1_de7Dq :: r_ae51L)
      _ [Occ=Dead]
      (x0_ae1SX :: ()) ->
      case x0_ae1SX of { () -> ds1_de7Dq }

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fData()_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> () -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae522) _ [Occ=Dead] (x0_ae1SX [Occ=Once!] :: ()) ->
                 case x0_ae1SX of { () -> GHC.Types.[] @ u_ae522 }}]
Data.Data.$fData()_$cgmapQ
  = \ (@ u_ae522) _ [Occ=Dead] (x0_ae1SX :: ()) ->
      case x0_ae1SX of { () -> GHC.Types.[] @ u_ae522 }

-- RHS size: {terms: 10, types: 16, coercions: 6, joins: 0/0}
Data.Data.$fData()2
  :: forall r r'.
     (r -> r' -> r)
     -> r -> (forall d. Data d => d -> r') -> () -> Const r ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_ae51u)
                 (@ r'_ae51v)
                 _ [Occ=Dead]
                 (ds1_de7Dn [Occ=Once] :: r_ae51u)
                 _ [Occ=Dead]
                 (eta_XBG [Occ=Once!] :: ()) ->
                 case eta_XBG of { () ->
                 ds1_de7Dn
                 `cast` (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r_ae51u>_R <()>_P)
                         :: (r_ae51u :: *) ~R# (Const r_ae51u () :: *))
                 }}]
Data.Data.$fData()2
  = \ (@ r_ae51u)
      (@ r'_ae51v)
      _ [Occ=Dead]
      (ds1_de7Dn :: r_ae51u)
      _ [Occ=Dead]
      (eta_XBG :: ()) ->
      case eta_XBG of { () ->
      ds1_de7Dn
      `cast` (Sym (Data.Functor.Const.N:Const[0]
                       <*>_N <r_ae51u>_R <()>_P)
              :: (r_ae51u :: *) ~R# (Const r_ae51u () :: *))
      }

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fData()3 :: (forall b. Data b => b -> b) -> () -> ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U()>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (x0_Xe2V5 [Occ=Once] :: ()) -> x0_Xe2V5}]
Data.Data.$fData()3 = \ _ [Occ=Dead] (x0_Xe2V5 :: ()) -> x0_Xe2V5

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fData()_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c ())
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae50W :: * -> * -> *))
                 (@ (c_ae50X :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae50X ())}]
Data.Data.$fData()_$cdataCast2
  = \ (@ (t_ae50W :: * -> * -> *))
      (@ (c_ae50X :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae50X ())

-- RHS size: {terms: 29, types: 35, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). MonadPlus m => () -> m ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*H>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 20] 210 0}]
Data.Data.$w$cgmapMo
  = \ (@ (m_sega5 :: * -> *))
      (w_sega6 :: MonadPlus m_sega5)
      (w1_sega8 :: ()) ->
      let {
        lvl270_se9I7 :: m_sega5 ()
        [LclId]
        lvl270_se9I7 = mzero @ m_sega5 w_sega6 @ () } in
      let {
        $dMonad_se9sX [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_sega5
        [LclId]
        $dMonad_se9sX = GHC.Base.$p2MonadPlus @ m_sega5 w_sega6 } in
      >>=
        @ m_sega5
        $dMonad_se9sX
        @ ((), Bool)
        @ ()
        (case w1_sega8 of { () ->
         return @ m_sega5 $dMonad_se9sX @ ((), Bool) Data.Data.$fData()1
         })
        (\ (ds_de7pa :: ((), Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9I7;
             True -> return @ m_sega5 $dMonad_se9sX @ () x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fData()_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> () -> m ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_sega5 :: * -> *))
                 (w_sega6 [Occ=Once] :: MonadPlus m_sega5)
                 _ [Occ=Dead]
                 (w2_sega8 [Occ=Once] :: ()) ->
                 Data.Data.$w$cgmapMo @ m_sega5 w_sega6 w2_sega8}]
Data.Data.$fData()_$cgmapMo
  = \ (@ (m_sega5 :: * -> *))
      (w_sega6 :: MonadPlus m_sega5)
      _ [Occ=Dead]
      (w2_sega8 :: ()) ->
      Data.Data.$w$cgmapMo @ m_sega5 w_sega6 w2_sega8

-- RHS size: {terms: 16, types: 1, coercions: 31, joins: 0/0}
Data.Data.$fData() [InlPrag=NOUSERINLINE CONLIKE] :: Data ()
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: ()
                        Data.Data.$fData()8
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <()>_N
                                :: (Data.Typeable.Internal.TypeRep () :: *)
                                   ~R# (Typeable () :: Constraint))
                        Data.Data.$fData()_$cgfoldl
                        Data.Data.$fData()_$cgunfold
                        Data.Data.$fData()_$ctoConstr
                        Data.Data.$fData()_$cdataTypeOf
                        Data.Data.$fData()_$cdataCast1
                        Data.Data.$fData()_$cdataCast2
                        Data.Data.$fData()3
                        Data.Data.$fData()2
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <()>_R
                                ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <()>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r -> (forall d. Data d => d -> r') -> () -> Const r () :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r -> (forall d. Data d => d -> r') -> () -> r :: *))
                        Data.Data.$fData()_$cgmapQr
                        Data.Data.$fData()_$cgmapQ
                        Data.Data.$fData()_$cgmapQi
                        Data.Data.$fData()_$cgmapM
                        Data.Data.$fData()_$cgmapMp
                        Data.Data.$fData()_$cgmapMo]
Data.Data.$fData()
  = Data.Data.C:Data
      @ ()
      (Data.Data.$fData()8
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <()>_N
               :: (Data.Typeable.Internal.TypeRep () :: *)
                  ~R# (Typeable () :: Constraint)))
      Data.Data.$fData()_$cgfoldl
      Data.Data.$fData()_$cgunfold
      Data.Data.$fData()_$ctoConstr
      Data.Data.$fData()_$cdataTypeOf
      Data.Data.$fData()_$cdataCast1
      Data.Data.$fData()_$cdataCast2
      Data.Data.$fData()3
      (Data.Data.$fData()2
       `cast` (forall (r :: <*>_N) (r' :: <*>_N).
               <r -> r' -> r>_R
               ->_R <r>_R
               ->_R <forall d. Data d => d -> r'>_R
               ->_R <()>_R
               ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <()>_P
               :: (forall r r'.
                   (r -> r' -> r)
                   -> r -> (forall d. Data d => d -> r') -> () -> Const r () :: *)
                  ~R# (forall r r'.
                       (r -> r' -> r)
                       -> r -> (forall d. Data d => d -> r') -> () -> r :: *)))
      Data.Data.$fData()_$cgmapQr
      Data.Data.$fData()_$cgmapQ
      Data.Data.$fData()_$cgmapQi
      Data.Data.$fData()_$cgmapM
      Data.Data.$fData()_$cgmapMp
      Data.Data.$fData()_$cgmapMo

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData(,)8 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fData(,)8 = "(,)"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData(,)7 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fData(,)7 = unpackCString# Data.Data.$fData(,)8

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go12_rejPG :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go12_rejPG
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fData(,)7 of {
                False -> go12_rejPG ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$c(,)1_rejPH :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$c(,)1_rejPH = Data.Data.AlgConstr $c(,)2_rejPI

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fData(,)6 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData(,)6
  = GHC.Types.: @ Constr Data.Data.$c(,) (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData(,)5 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fData(,)5 = Data.Data.AlgRep Data.Data.$fData(,)6

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$t(,) :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$t(,)
  = Data.Data.DataType Data.Data.$fData(,)7 Data.Data.$fData(,)5

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$c(,) [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$c(,)
  = Data.Data.Constr
      $c(,)1_rejPH
      Data.Data.$fData(,)7
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$t(,)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$c(,)2_rejPI :: ConIndex
[GblId]
$c(,)2_rejPI = go12_rejPG Data.Data.$fData(,)6 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 5, types: 12, coercions: 0, joins: 0/0}
Data.Data.$fData(,)1 :: forall b a. (a -> b -> (a, b), Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData(,)1
  = \ (@ b_Xe5yB) (@ a_Xe5yz) ->
      (GHC.Tuple.(,) @ a_Xe5yz @ b_Xe5yB, GHC.Types.False)

-- RHS size: {terms: 75, types: 157, coercions: 19, joins: 0/4}
Data.Data.$fData(,)_$cgmapMp
  :: forall a b.
     (Data a, Data b) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> (a, b) -> m (a, b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 90 60 20] 640 0}]
Data.Data.$fData(,)_$cgmapMp
  = \ (@ a_Xe5yz)
      (@ b_Xe5yB)
      ($dData_Xe5yD :: Data a_Xe5yz)
      ($dData1_Xe5yF :: Data b_Xe5yB)
      (@ (m_ae4ZH :: * -> *))
      ($dMonadPlus_ae4ZJ :: MonadPlus m_ae4ZH)
      (ds_de7Dd :: forall d. Data d => d -> m_ae4ZH d)
      (eta_XC1 :: (a_Xe5yz, b_Xe5yB)) ->
      let {
        lvl270_se9Ig :: m_ae4ZH (a_Xe5yz, b_Xe5yB)
        [LclId]
        lvl270_se9Ig
          = mzero @ m_ae4ZH $dMonadPlus_ae4ZJ @ (a_Xe5yz, b_Xe5yB) } in
      let {
        $dMonad_se9sV [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae4ZH
        [LclId]
        $dMonad_se9sV
          = GHC.Base.$p2MonadPlus @ m_ae4ZH $dMonadPlus_ae4ZJ } in
      >>=
        @ m_ae4ZH
        $dMonad_se9sV
        @ ((a_Xe5yz, b_Xe5yB), Bool)
        @ (a_Xe5yz, b_Xe5yB)
        (case eta_XC1 of { (a1_ae2qc, a2_ae2qd) ->
         let {
           k_se9sU [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
             :: forall d b1.
                Data d =>
                Mp m_ae4ZH (d -> b1) -> d -> m_ae4ZH (b1, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_se9sU
             = \ (@ d_ae2Ws)
                 (@ b1_ae2Wt)
                 ($dData2_ae2Wv :: Data d_ae2Ws)
                 (ds1_de7oC [OS=OneShot] :: Mp m_ae4ZH (d_ae2Ws -> b1_ae2Wt))
                 (y_ae1Tz [OS=OneShot] :: d_ae2Ws) ->
                 let {
                   lvl271_se9Ie :: m_ae4ZH d_ae2Ws
                   [LclId]
                   lvl271_se9Ie = ds_de7Dd @ d_ae2Ws $dData2_ae2Wv y_ae1Tz } in
                 >>=
                   @ m_ae4ZH
                   $dMonad_se9sV
                   @ (d_ae2Ws -> b1_ae2Wt, Bool)
                   @ (b1_ae2Wt, Bool)
                   (ds1_de7oC
                    `cast` (Data.Data.N:Mp[0] <m_ae4ZH>_R <d_ae2Ws -> b1_ae2Wt>_N
                            :: (Mp m_ae4ZH (d_ae2Ws -> b1_ae2Wt) :: *)
                               ~R# (m_ae4ZH (d_ae2Ws -> b1_ae2Wt, Bool) :: *)))
                   (\ (ds2_de7oD :: (d_ae2Ws -> b1_ae2Wt, Bool)) ->
                      case ds2_de7oD of { (h_ae1TA, b2_ae1TB) ->
                      mplus
                        @ m_ae4ZH
                        $dMonadPlus_ae4ZJ
                        @ (b1_ae2Wt, Bool)
                        (>>=
                           @ m_ae4ZH
                           $dMonad_se9sV
                           @ d_ae2Ws
                           @ (b1_ae2Wt, Bool)
                           lvl271_se9Ie
                           (\ (y'_ae1TC :: d_ae2Ws) ->
                              return
                                @ m_ae4ZH
                                $dMonad_se9sV
                                @ (b1_ae2Wt, Bool)
                                (h_ae1TA y'_ae1TC, GHC.Types.True)))
                        (return
                           @ m_ae4ZH
                           $dMonad_se9sV
                           @ (b1_ae2Wt, Bool)
                           (h_ae1TA y_ae1Tz, b2_ae1TB))
                      }) } in
         k_se9sU
           @ b_Xe5yB
           @ (a_Xe5yz, b_Xe5yB)
           $dData1_Xe5yF
           ((k_se9sU
               @ a_Xe5yz
               @ (b_Xe5yB -> (a_Xe5yz, b_Xe5yB))
               $dData_Xe5yD
               ((return
                   @ m_ae4ZH
                   $dMonad_se9sV
                   @ (a_Xe5yz -> b_Xe5yB -> (a_Xe5yz, b_Xe5yB), Bool)
                   (Data.Data.$fData(,)1 @ b_Xe5yB @ a_Xe5yz))
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_ae4ZH>_R <a_Xe5yz -> b_Xe5yB -> (a_Xe5yz, b_Xe5yB)>_N)
                        :: (m_ae4ZH (a_Xe5yz -> b_Xe5yB -> (a_Xe5yz, b_Xe5yB), Bool) :: *)
                           ~R# (Mp m_ae4ZH (a_Xe5yz -> b_Xe5yB -> (a_Xe5yz, b_Xe5yB)) :: *)))
               a1_ae2qc)
            `cast` (Sym (Data.Data.N:Mp[0]
                             <m_ae4ZH>_R <b_Xe5yB -> (a_Xe5yz, b_Xe5yB)>_N)
                    :: (m_ae4ZH (b_Xe5yB -> (a_Xe5yz, b_Xe5yB), Bool) :: *)
                       ~R# (Mp m_ae4ZH (b_Xe5yB -> (a_Xe5yz, b_Xe5yB)) :: *)))
           a2_ae2qd
         })
        (\ (ds1_de7oa :: ((a_Xe5yz, b_Xe5yB), Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b1_ae1TE) ->
           case b1_ae1TE of {
             False -> lvl270_se9Ig;
             True ->
               return @ m_ae4ZH $dMonad_se9sV @ (a_Xe5yz, b_Xe5yB) x'_ae1TD
           }
           })

-- RHS size: {terms: 40, types: 77, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data a, Data b) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> a -> b -> m (a, b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 120 60 0 0] 340 0}]
Data.Data.$w$cgmapM
  = \ (@ a_segau)
      (@ b_segav)
      (w_segaw :: Data a_segau)
      (w1_segax :: Data b_segav)
      (@ (m_segay :: * -> *))
      (w2_segaz :: Monad m_segay)
      (w3_segaA :: forall d. Data d => d -> m_segay d)
      (ww_segaE :: a_segau)
      (ww1_segaF :: b_segav) ->
      let {
        k_se9sR [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
          :: forall d b1. Data d => m_segay (d -> b1) -> d -> m_segay b1
        [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
        k_se9sR
          = \ (@ d_ae2Vh)
              (@ b1_ae2Vi)
              ($dData_ae2Vk :: Data d_ae2Vh)
              (c_ae1Tm [OS=OneShot] :: m_segay (d_ae2Vh -> b1_ae2Vi))
              (x_ae1Tn [OS=OneShot] :: d_ae2Vh) ->
              let {
                lvl270_se9Ih :: m_segay d_ae2Vh
                [LclId]
                lvl270_se9Ih = w3_segaA @ d_ae2Vh $dData_ae2Vk x_ae1Tn } in
              >>=
                @ m_segay
                w2_segaz
                @ (d_ae2Vh -> b1_ae2Vi)
                @ b1_ae2Vi
                c_ae1Tm
                (\ (c'_ae1To :: d_ae2Vh -> b1_ae2Vi) ->
                   >>=
                     @ m_segay
                     w2_segaz
                     @ d_ae2Vh
                     @ b1_ae2Vi
                     lvl270_se9Ih
                     (\ (x'_ae1Tp :: d_ae2Vh) ->
                        return @ m_segay w2_segaz @ b1_ae2Vi (c'_ae1To x'_ae1Tp))) } in
      k_se9sR
        @ b_segav
        @ (a_segau, b_segav)
        w1_segax
        (k_se9sR
           @ a_segau
           @ (b_segav -> (a_segau, b_segav))
           w_segaw
           (return
              @ m_segay
              w2_segaz
              @ (a_segau -> b_segav -> (a_segau, b_segav))
              (GHC.Tuple.(,) @ a_segau @ b_segav))
           ww_segaE)
        ww1_segaF

-- RHS size: {terms: 18, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fData(,)_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data a, Data b) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> (a, b) -> m (a, b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_segau)
                 (@ b_segav)
                 (w_segaw [Occ=Once] :: Data a_segau)
                 (w1_segax [Occ=Once] :: Data b_segav)
                 (@ (m_segay :: * -> *))
                 (w2_segaz [Occ=Once] :: Monad m_segay)
                 (w3_segaA [Occ=Once] :: forall d. Data d => d -> m_segay d)
                 (w4_segaB [Occ=Once!] :: (a_segau, b_segav)) ->
                 case w4_segaB of { (ww1_segaE [Occ=Once], ww2_segaF [Occ=Once]) ->
                 Data.Data.$w$cgmapM
                   @ a_segau
                   @ b_segav
                   w_segaw
                   w1_segax
                   @ m_segay
                   w2_segaz
                   w3_segaA
                   ww1_segaE
                   ww2_segaF
                 }}]
Data.Data.$fData(,)_$cgmapM
  = \ (@ a_segau)
      (@ b_segav)
      (w_segaw :: Data a_segau)
      (w1_segax :: Data b_segav)
      (@ (m_segay :: * -> *))
      (w2_segaz :: Monad m_segay)
      (w3_segaA :: forall d. Data d => d -> m_segay d)
      (w4_segaB :: (a_segau, b_segav)) ->
      case w4_segaB of { (ww1_segaE, ww2_segaF) ->
      Data.Data.$w$cgmapM
        @ a_segau
        @ b_segav
        w_segaw
        w1_segax
        @ m_segay
        w2_segaz
        w3_segaA
        ww1_segaE
        ww2_segaF
      }

-- RHS size: {terms: 26, types: 31, coercions: 0, joins: 0/0}
Data.Data.$fData(,)_$cgmapQi
  :: forall a b.
     (Data a, Data b) =>
     forall u. Int -> (forall d. Data d => d -> u) -> (a, b) -> u
[GblId,
 Arity=5,
 Str=<L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe5yx)
                 (@ b_Xe5yz)
                 ($dData_Xe5yB [Occ=Once] :: Data a_Xe5yx)
                 ($dData1_Xe5yD [Occ=Once] :: Data b_Xe5yz)
                 (@ u_ae4Zd)
                 (ds_de7Da [Occ=Once!] :: Int)
                 (ds1_de7Db [Occ=Once*!] :: forall d. Data d => d -> u_ae4Zd)
                 (x_ae1T7 [Occ=Once!] :: (a_Xe5yx, b_Xe5yz)) ->
                 case x_ae1T7 of { (a1_ae2qc [Occ=Once], a2_ae2qd [Occ=Once]) ->
                 case ds_de7Da of { I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_ae4Zd;
                   0# -> ds1_de7Db @ a_Xe5yx $dData_Xe5yB a1_ae2qc;
                   1# -> ds1_de7Db @ b_Xe5yz $dData1_Xe5yD a2_ae2qd
                 }
                 }
                 }}]
Data.Data.$fData(,)_$cgmapQi
  = \ (@ a_Xe5yx)
      (@ b_Xe5yz)
      ($dData_Xe5yB :: Data a_Xe5yx)
      ($dData1_Xe5yD :: Data b_Xe5yz)
      (@ u_ae4Zd)
      (ds_de7Da :: Int)
      (ds1_de7Db :: forall d. Data d => d -> u_ae4Zd)
      (x_ae1T7 :: (a_Xe5yx, b_Xe5yz)) ->
      case x_ae1T7 of { (a1_ae2qc, a2_ae2qd) ->
      case ds_de7Da of { I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_ae4Zd;
        0# -> ds1_de7Db @ a_Xe5yx $dData_Xe5yB a1_ae2qc;
        1# -> ds1_de7Db @ b_Xe5yz $dData1_Xe5yD a2_ae2qd
      }
      }
      }

-- RHS size: {terms: 22, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fData(,)_$cgmapQr
  :: forall a b.
     (Data a, Data b) =>
     forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> (a, b) -> r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe5yv)
                 (@ b_Xe5yx)
                 ($dData_Xe5yz [Occ=Once] :: Data a_Xe5yv)
                 ($dData1_Xe5yB [Occ=Once] :: Data b_Xe5yx)
                 (@ r_ae4YI)
                 (@ r'_ae4YJ)
                 (ds_de7D6 :: r'_ae4YJ -> r_ae4YI -> r_ae4YI)
                 (ds1_de7D7 [Occ=Once] :: r_ae4YI)
                 (ds2_de7D8 :: forall d. Data d => d -> r'_ae4YJ)
                 (x0_ae1SX [Occ=Once!] :: (a_Xe5yv, b_Xe5yx)) ->
                 case x0_ae1SX of { (a1_ae2qc [Occ=Once], a2_ae2qd [Occ=Once]) ->
                 ds_de7D6
                   (ds2_de7D8 @ a_Xe5yv $dData_Xe5yz a1_ae2qc)
                   (ds_de7D6 (ds2_de7D8 @ b_Xe5yx $dData1_Xe5yB a2_ae2qd) ds1_de7D7)
                 }}]
Data.Data.$fData(,)_$cgmapQr
  = \ (@ a_Xe5yv)
      (@ b_Xe5yx)
      ($dData_Xe5yz :: Data a_Xe5yv)
      ($dData1_Xe5yB :: Data b_Xe5yx)
      (@ r_ae4YI)
      (@ r'_ae4YJ)
      (ds_de7D6 :: r'_ae4YJ -> r_ae4YI -> r_ae4YI)
      (ds1_de7D7 :: r_ae4YI)
      (ds2_de7D8 :: forall d. Data d => d -> r'_ae4YJ)
      (x0_ae1SX :: (a_Xe5yv, b_Xe5yx)) ->
      case x0_ae1SX of { (a1_ae2qc, a2_ae2qd) ->
      ds_de7D6
        (ds2_de7D8 @ a_Xe5yv $dData_Xe5yz a1_ae2qc)
        (ds_de7D6 (ds2_de7D8 @ b_Xe5yx $dData1_Xe5yB a2_ae2qd) ds1_de7D7)
      }

-- RHS size: {terms: 19, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fData(,)_$cgmapQ
  :: forall a b.
     (Data a, Data b) =>
     forall u. (forall d. Data d => d -> u) -> (a, b) -> [u]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,C(C1(U))><S,1*U(U,U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe5yw)
                 (@ b_Xe5yy)
                 ($dData_Xe5yA [Occ=Once] :: Data a_Xe5yw)
                 ($dData1_Xe5yC [Occ=Once] :: Data b_Xe5yy)
                 (@ u_ae4YZ)
                 (ds_de7D9 :: forall d. Data d => d -> u_ae4YZ)
                 (x0_ae1SX [Occ=Once!] :: (a_Xe5yw, b_Xe5yy)) ->
                 case x0_ae1SX of { (a1_ae2qc [Occ=Once], a2_ae2qd [Occ=Once]) ->
                 GHC.Types.:
                   @ u_ae4YZ
                   (ds_de7D9 @ a_Xe5yw $dData_Xe5yA a1_ae2qc)
                   (GHC.Types.:
                      @ u_ae4YZ
                      (ds_de7D9 @ b_Xe5yy $dData1_Xe5yC a2_ae2qd)
                      (GHC.Types.[] @ u_ae4YZ))
                 }}]
Data.Data.$fData(,)_$cgmapQ
  = \ (@ a_Xe5yw)
      (@ b_Xe5yy)
      ($dData_Xe5yA :: Data a_Xe5yw)
      ($dData1_Xe5yC :: Data b_Xe5yy)
      (@ u_ae4YZ)
      (ds_de7D9 :: forall d. Data d => d -> u_ae4YZ)
      (x0_ae1SX :: (a_Xe5yw, b_Xe5yy)) ->
      case x0_ae1SX of { (a1_ae2qc, a2_ae2qd) ->
      GHC.Types.:
        @ u_ae4YZ
        (ds_de7D9 @ a_Xe5yw $dData_Xe5yA a1_ae2qc)
        (GHC.Types.:
           @ u_ae4YZ
           (ds_de7D9 @ b_Xe5yy $dData1_Xe5yC a2_ae2qd)
           (GHC.Types.[] @ u_ae4YZ))
      }

-- RHS size: {terms: 22, types: 32, coercions: 8, joins: 0/0}
Data.Data.$fData(,)2
  :: forall a b.
     (Data a, Data b) =>
     forall r r'.
     (r -> r' -> r)
     -> r -> (forall d. Data d => d -> r') -> (a, b) -> Const r (a, b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe5yu)
                 (@ b_Xe5yw)
                 ($dData_Xe5yy [Occ=Once] :: Data a_Xe5yu)
                 ($dData1_Xe5yA [Occ=Once] :: Data b_Xe5yw)
                 (@ r_ae4Yr)
                 (@ r'_ae4Ys)
                 (ds_de7D3 :: r_ae4Yr -> r'_ae4Ys -> r_ae4Yr)
                 (ds1_de7D4 [Occ=Once] :: r_ae4Yr)
                 (ds2_de7D5 :: forall d. Data d => d -> r'_ae4Ys)
                 (eta_XC8 [Occ=Once!] :: (a_Xe5yu, b_Xe5yw)) ->
                 case eta_XC8 of { (a1_ae2qc [Occ=Once], a2_ae2qd [Occ=Once]) ->
                 (ds_de7D3
                    (ds_de7D3 ds1_de7D4 (ds2_de7D5 @ a_Xe5yu $dData_Xe5yy a1_ae2qc))
                    (ds2_de7D5 @ b_Xe5yw $dData1_Xe5yA a2_ae2qd))
                 `cast` (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r_ae4Yr>_R <(a_Xe5yu, b_Xe5yw)>_P)
                         :: (r_ae4Yr :: *) ~R# (Const r_ae4Yr (a_Xe5yu, b_Xe5yw) :: *))
                 }}]
Data.Data.$fData(,)2
  = \ (@ a_Xe5yu)
      (@ b_Xe5yw)
      ($dData_Xe5yy :: Data a_Xe5yu)
      ($dData1_Xe5yA :: Data b_Xe5yw)
      (@ r_ae4Yr)
      (@ r'_ae4Ys)
      (ds_de7D3 :: r_ae4Yr -> r'_ae4Ys -> r_ae4Yr)
      (ds1_de7D4 :: r_ae4Yr)
      (ds2_de7D5 :: forall d. Data d => d -> r'_ae4Ys)
      (eta_XC8 :: (a_Xe5yu, b_Xe5yw)) ->
      case eta_XC8 of { (a1_ae2qc, a2_ae2qd) ->
      (ds_de7D3
         (ds_de7D3 ds1_de7D4 (ds2_de7D5 @ a_Xe5yu $dData_Xe5yy a1_ae2qc))
         (ds2_de7D5 @ b_Xe5yw $dData1_Xe5yA a2_ae2qd))
      `cast` (Sym (Data.Functor.Const.N:Const[0]
                       <*>_N <r_ae4Yr>_R <(a_Xe5yu, b_Xe5yw)>_P)
              :: (r_ae4Yr :: *) ~R# (Const r_ae4Yr (a_Xe5yu, b_Xe5yw) :: *))
      }

-- RHS size: {terms: 16, types: 26, coercions: 5, joins: 0/0}
Data.Data.$fData(,)3
  :: forall a b.
     (Data a, Data b) =>
     (forall b1. Data b1 => b1 -> b1) -> (a, b) -> Identity (a, b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,C(C1(U))><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe5yt)
                 (@ b_Xe5yv)
                 ($dData_Xe5yx [Occ=Once] :: Data a_Xe5yt)
                 ($dData1_Xe5yz [Occ=Once] :: Data b_Xe5yv)
                 (ds_de7D2 :: forall b1. Data b1 => b1 -> b1)
                 (x0_Xe2VB [Occ=Once!] :: (a_Xe5yt, b_Xe5yv)) ->
                 case x0_Xe2VB of { (a1_ae2qc [Occ=Once], a2_ae2qd [Occ=Once]) ->
                 (ds_de7D2 @ a_Xe5yt $dData_Xe5yx a1_ae2qc,
                  ds_de7D2 @ b_Xe5yv $dData1_Xe5yz a2_ae2qd)
                 `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                                  <(a_Xe5yt, b_Xe5yv)>_R)
                         :: ((a_Xe5yt, b_Xe5yv) :: *)
                            ~R# (Identity (a_Xe5yt, b_Xe5yv) :: *))
                 }}]
Data.Data.$fData(,)3
  = \ (@ a_Xe5yt)
      (@ b_Xe5yv)
      ($dData_Xe5yx :: Data a_Xe5yt)
      ($dData1_Xe5yz :: Data b_Xe5yv)
      (ds_de7D2 :: forall b1. Data b1 => b1 -> b1)
      (x0_Xe2VB :: (a_Xe5yt, b_Xe5yv)) ->
      case x0_Xe2VB of { (a1_ae2qc, a2_ae2qd) ->
      (ds_de7D2 @ a_Xe5yt $dData_Xe5yx a1_ae2qc,
       ds_de7D2 @ b_Xe5yv $dData1_Xe5yz a2_ae2qd)
      `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                       <(a_Xe5yt, b_Xe5yv)>_R)
              :: ((a_Xe5yt, b_Xe5yv) :: *)
                 ~R# (Identity (a_Xe5yt, b_Xe5yv) :: *))
      }

-- RHS size: {terms: 85, types: 164, coercions: 19, joins: 0/4}
Data.Data.$fData(,)_$cgmapMo
  :: forall a b.
     (Data a, Data b) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> (a, b) -> m (a, b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 90 60 20] 720 0}]
Data.Data.$fData(,)_$cgmapMo
  = \ (@ a_Xe5ys)
      (@ b_Xe6aL)
      ($dData_Xe6aO :: Data a_Xe5ys)
      ($dData1_Xe6aR :: Data b_Xe6aL)
      (@ (m_ae4ZX :: * -> *))
      ($dMonadPlus_ae4ZZ :: MonadPlus m_ae4ZX)
      (ds_de7De :: forall d. Data d => d -> m_ae4ZX d)
      (eta_XCo :: (a_Xe5ys, b_Xe6aL)) ->
      let {
        lvl270_se9In :: m_ae4ZX (a_Xe5ys, b_Xe6aL)
        [LclId]
        lvl270_se9In
          = mzero @ m_ae4ZX $dMonadPlus_ae4ZZ @ (a_Xe5ys, b_Xe6aL) } in
      let {
        $dMonad_se9sP [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae4ZX
        [LclId]
        $dMonad_se9sP
          = GHC.Base.$p2MonadPlus @ m_ae4ZX $dMonadPlus_ae4ZZ } in
      >>=
        @ m_ae4ZX
        $dMonad_se9sP
        @ ((a_Xe5ys, b_Xe6aL), Bool)
        @ (a_Xe5ys, b_Xe6aL)
        (case eta_XCo of { (a1_ae2qc, a2_ae2qd) ->
         let {
           k_se9sO [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
             :: forall d b1.
                Data d =>
                Mp m_ae4ZX (d -> b1) -> d -> m_ae4ZX (b1, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_se9sO
             = \ (@ d_ae2Ya)
                 (@ b1_ae2Yb)
                 ($dData2_ae2Yd :: Data d_ae2Ya)
                 (ds1_de7pC [OS=OneShot] :: Mp m_ae4ZX (d_ae2Ya -> b1_ae2Yb))
                 (y_ae1TO [OS=OneShot] :: d_ae2Ya) ->
                 let {
                   lvl271_se9Il :: m_ae4ZX d_ae2Ya
                   [LclId]
                   lvl271_se9Il = ds_de7De @ d_ae2Ya $dData2_ae2Yd y_ae1TO } in
                 >>=
                   @ m_ae4ZX
                   $dMonad_se9sP
                   @ (d_ae2Ya -> b1_ae2Yb, Bool)
                   @ (b1_ae2Yb, Bool)
                   (ds1_de7pC
                    `cast` (Data.Data.N:Mp[0] <m_ae4ZX>_R <d_ae2Ya -> b1_ae2Yb>_N
                            :: (Mp m_ae4ZX (d_ae2Ya -> b1_ae2Yb) :: *)
                               ~R# (m_ae4ZX (d_ae2Ya -> b1_ae2Yb, Bool) :: *)))
                   (\ (ds2_de7pD :: (d_ae2Ya -> b1_ae2Yb, Bool)) ->
                      case ds2_de7pD of { (h_ae1TP, b2_ae1TQ) ->
                      case b2_ae1TQ of {
                        False ->
                          mplus
                            @ m_ae4ZX
                            $dMonadPlus_ae4ZZ
                            @ (b1_ae2Yb, Bool)
                            (>>=
                               @ m_ae4ZX
                               $dMonad_se9sP
                               @ d_ae2Ya
                               @ (b1_ae2Yb, Bool)
                               lvl271_se9Il
                               (\ (y'_ae1TR :: d_ae2Ya) ->
                                  return
                                    @ m_ae4ZX
                                    $dMonad_se9sP
                                    @ (b1_ae2Yb, Bool)
                                    (h_ae1TP y'_ae1TR, GHC.Types.True)))
                            (return
                               @ m_ae4ZX
                               $dMonad_se9sP
                               @ (b1_ae2Yb, Bool)
                               (h_ae1TP y_ae1TO, GHC.Types.False));
                        True ->
                          return
                            @ m_ae4ZX
                            $dMonad_se9sP
                            @ (b1_ae2Yb, Bool)
                            (h_ae1TP y_ae1TO, GHC.Types.True)
                      }
                      }) } in
         k_se9sO
           @ b_Xe6aL
           @ (a_Xe5ys, b_Xe6aL)
           $dData1_Xe6aR
           ((k_se9sO
               @ a_Xe5ys
               @ (b_Xe6aL -> (a_Xe5ys, b_Xe6aL))
               $dData_Xe6aO
               ((return
                   @ m_ae4ZX
                   $dMonad_se9sP
                   @ (a_Xe5ys -> b_Xe6aL -> (a_Xe5ys, b_Xe6aL), Bool)
                   (Data.Data.$fData(,)1 @ b_Xe6aL @ a_Xe5ys))
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_ae4ZX>_R <a_Xe5ys -> b_Xe6aL -> (a_Xe5ys, b_Xe6aL)>_N)
                        :: (m_ae4ZX (a_Xe5ys -> b_Xe6aL -> (a_Xe5ys, b_Xe6aL), Bool) :: *)
                           ~R# (Mp m_ae4ZX (a_Xe5ys -> b_Xe6aL -> (a_Xe5ys, b_Xe6aL)) :: *)))
               a1_ae2qc)
            `cast` (Sym (Data.Data.N:Mp[0]
                             <m_ae4ZX>_R <b_Xe6aL -> (a_Xe5ys, b_Xe6aL)>_N)
                    :: (m_ae4ZX (b_Xe6aL -> (a_Xe5ys, b_Xe6aL), Bool) :: *)
                       ~R# (Mp m_ae4ZX (b_Xe6aL -> (a_Xe5ys, b_Xe6aL)) :: *)))
           a2_ae2qd
         })
        (\ (ds1_de7pa :: ((a_Xe5ys, b_Xe6aL), Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b1_ae1TT) ->
           case b1_ae1TT of {
             False -> lvl270_se9In;
             True ->
               return @ m_ae4ZX $dMonad_se9sP @ (a_Xe5ys, b_Xe6aL) x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 12, coercions: 0, joins: 0/0}
lvl104_rejPJ :: forall b a. (a, b) -> Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []]
lvl104_rejPJ
  = \ (@ b_Xe6aL) (@ a_Xe5yr) (ds_de7CI :: (a_Xe5yr, b_Xe6aL)) ->
      case ds_de7CI of { (ds1_de7CJ, ds2_de7CK) -> Data.Data.$c(,) }

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
lvl105_rejPK :: forall a b. (a, b) -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl105_rejPK
  = \ (@ a_Xe5yr) (@ b_Xe6aL) _ [Occ=Dead] -> Data.Data.$t(,)

-- RHS size: {terms: 7, types: 29, coercions: 0, joins: 0/0}
lvl106_rejPL
  :: forall a b (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (a, b))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl106_rejPL
  = \ (@ a_Xe5yr)
      (@ b_Xe6aL)
      (@ (t_ae4Xs :: * -> *))
      (@ (c_ae4Xt :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae4Xt (a_Xe5yr, b_Xe6aL))

-- RHS size: {terms: 44, types: 41, coercions: 52, joins: 0/0}
Data.Data.$fData(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. (Data a, Data b) => Data (a, b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_ae1XU)
             (@ b_ae1XV)
             (v_XCk :: Data a_ae1XU)
             (v1_XCm :: Data b_ae1XV) ->
       Data.Data.C:Data TYPE: (a_ae1XU, b_ae1XV)
                        (Data.Data.$fData(,)9 @ a_ae1XU @ b_ae1XV v_XCk v1_XCm)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <(a_ae1XU,
                                                                                   b_ae1XV)>_N
                                :: (Data.Typeable.Internal.TypeRep (a_ae1XU, b_ae1XV) :: *)
                                   ~R# (Typeable (a_ae1XU, b_ae1XV) :: Constraint))
                        Data.Data.$fData(,)_$cgfoldl @ a_ae1XU @ b_ae1XV v_XCk v1_XCm
                        Data.Data.$fData(,)_$cgunfold @ a_ae1XU @ b_ae1XV v_XCk v1_XCm
                        \ (ds_de7CI [Occ=Once!] :: (a_ae1XU, b_ae1XV)) ->
                          case ds_de7CI of { (_ [Occ=Dead], _ [Occ=Dead]) ->
                          Data.Data.$c(,)
                          }
                        \ _ [Occ=Dead] -> Data.Data.$t(,)
                        \ (@ (t_ae4Xs :: * -> *))
                          (@ (c_ae4Xt :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae4Xt (a_ae1XU, b_ae1XV))
                        Data.Data.$fData(,)_$cdataCast2 @ a_ae1XU @ b_ae1XV v_XCk v1_XCm
                        (Data.Data.$fData(,)3 @ a_ae1XU @ b_ae1XV v_XCk v1_XCm)
                        `cast` (<forall b1. Data b1 => b1 -> b1>_R
                                ->_R <(a_ae1XU, b_ae1XV)>_R
                                ->_R Data.Functor.Identity.N:Identity[0] <(a_ae1XU, b_ae1XV)>_R
                                :: ((forall b1. Data b1 => b1 -> b1)
                                    -> (a_ae1XU, b_ae1XV) -> Identity (a_ae1XU, b_ae1XV) :: *)
                                   ~R# ((forall b1. Data b1 => b1 -> b1)
                                        -> (a_ae1XU, b_ae1XV) -> (a_ae1XU, b_ae1XV) :: *))
                        (Data.Data.$fData(,)2 @ a_ae1XU @ b_ae1XV v_XCk v1_XCm)
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <(a_ae1XU, b_ae1XV)>_R
                                ->_R Data.Functor.Const.N:Const[0]
                                         <*>_N <r>_R <(a_ae1XU, b_ae1XV)>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> (a_ae1XU, b_ae1XV)
                                    -> Const r (a_ae1XU, b_ae1XV) :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d. Data d => d -> r')
                                        -> (a_ae1XU, b_ae1XV)
                                        -> r :: *))
                        Data.Data.$fData(,)_$cgmapQr @ a_ae1XU @ b_ae1XV v_XCk v1_XCm
                        Data.Data.$fData(,)_$cgmapQ @ a_ae1XU @ b_ae1XV v_XCk v1_XCm
                        Data.Data.$fData(,)_$cgmapQi @ a_ae1XU @ b_ae1XV v_XCk v1_XCm
                        Data.Data.$fData(,)_$cgmapM @ a_ae1XU @ b_ae1XV v_XCk v1_XCm
                        Data.Data.$fData(,)_$cgmapMp @ a_ae1XU @ b_ae1XV v_XCk v1_XCm
                        Data.Data.$fData(,)_$cgmapMo @ a_ae1XU @ b_ae1XV v_XCk v1_XCm]
Data.Data.$fData(,)
  = \ (@ a_Xe5yr)
      (@ b_Xe6aL)
      ($dData_Xe6aO :: Data a_Xe5yr)
      ($dData1_Xe6aR :: Data b_Xe6aL) ->
      Data.Data.C:Data
        @ (a_Xe5yr, b_Xe6aL)
        ((Data.Data.$fData(,)9
            @ a_Xe5yr @ b_Xe6aL $dData_Xe6aO $dData1_Xe6aR)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <(a_Xe5yr,
                                                                    b_Xe6aL)>_N
                 :: (Data.Typeable.Internal.TypeRep (a_Xe5yr, b_Xe6aL) :: *)
                    ~R# (Typeable (a_Xe5yr, b_Xe6aL) :: Constraint)))
        (Data.Data.$fData(,)_$cgfoldl
           @ a_Xe5yr @ b_Xe6aL $dData_Xe6aO $dData1_Xe6aR)
        (Data.Data.$fData(,)_$cgunfold
           @ a_Xe5yr @ b_Xe6aL $dData_Xe6aO $dData1_Xe6aR)
        (lvl104_rejPJ @ b_Xe6aL @ a_Xe5yr)
        (lvl105_rejPK @ a_Xe5yr @ b_Xe6aL)
        (lvl106_rejPL @ a_Xe5yr @ b_Xe6aL)
        (Data.Data.$fData(,)_$cdataCast2
           @ a_Xe5yr @ b_Xe6aL $dData_Xe6aO $dData1_Xe6aR)
        ((Data.Data.$fData(,)3
            @ a_Xe5yr @ b_Xe6aL $dData_Xe6aO $dData1_Xe6aR)
         `cast` (<forall b1. Data b1 => b1 -> b1>_R
                 ->_R <(a_Xe5yr, b_Xe6aL)>_R
                 ->_R Data.Functor.Identity.N:Identity[0] <(a_Xe5yr, b_Xe6aL)>_R
                 :: ((forall b1. Data b1 => b1 -> b1)
                     -> (a_Xe5yr, b_Xe6aL) -> Identity (a_Xe5yr, b_Xe6aL) :: *)
                    ~R# ((forall b1. Data b1 => b1 -> b1)
                         -> (a_Xe5yr, b_Xe6aL) -> (a_Xe5yr, b_Xe6aL) :: *)))
        ((Data.Data.$fData(,)2
            @ a_Xe5yr @ b_Xe6aL $dData_Xe6aO $dData1_Xe6aR)
         `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                 <r -> r' -> r>_R
                 ->_R <r>_R
                 ->_R <forall d. Data d => d -> r'>_R
                 ->_R <(a_Xe5yr, b_Xe6aL)>_R
                 ->_R Data.Functor.Const.N:Const[0]
                          <*>_N <r>_R <(a_Xe5yr, b_Xe6aL)>_P
                 :: (forall r r'.
                     (r -> r' -> r)
                     -> r
                     -> (forall d. Data d => d -> r')
                     -> (a_Xe5yr, b_Xe6aL)
                     -> Const r (a_Xe5yr, b_Xe6aL) :: *)
                    ~R# (forall r r'.
                         (r -> r' -> r)
                         -> r
                         -> (forall d. Data d => d -> r')
                         -> (a_Xe5yr, b_Xe6aL)
                         -> r :: *)))
        (Data.Data.$fData(,)_$cgmapQr
           @ a_Xe5yr @ b_Xe6aL $dData_Xe6aO $dData1_Xe6aR)
        (Data.Data.$fData(,)_$cgmapQ
           @ a_Xe5yr @ b_Xe6aL $dData_Xe6aO $dData1_Xe6aR)
        (Data.Data.$fData(,)_$cgmapQi
           @ a_Xe5yr @ b_Xe6aL $dData_Xe6aO $dData1_Xe6aR)
        (Data.Data.$fData(,)_$cgmapM
           @ a_Xe5yr @ b_Xe6aL $dData_Xe6aO $dData1_Xe6aR)
        (Data.Data.$fData(,)_$cgmapMp
           @ a_Xe5yr @ b_Xe6aL $dData_Xe6aO $dData1_Xe6aR)
        (Data.Data.$fData(,)_$cgmapMo
           @ a_Xe5yr @ b_Xe6aL $dData_Xe6aO $dData1_Xe6aR)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData(,,)7 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fData(,,)7 = "(,,)"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData(,,)6 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fData(,,)6 = unpackCString# Data.Data.$fData(,,)7

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go13_rejPM :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go13_rejPM
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fData(,,)6 of {
                False -> go13_rejPM ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$c(,,)1_rejPN :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$c(,,)1_rejPN = Data.Data.AlgConstr $c(,,)2_rejPO

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fData(,,)5 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData(,,)5
  = GHC.Types.: @ Constr Data.Data.$c(,,) (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData(,,)4 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fData(,,)4 = Data.Data.AlgRep Data.Data.$fData(,,)5

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$t(,,) :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$t(,,)
  = Data.Data.DataType Data.Data.$fData(,,)6 Data.Data.$fData(,,)4

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$c(,,) [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$c(,,)
  = Data.Data.Constr
      $c(,,)1_rejPN
      Data.Data.$fData(,,)6
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$t(,,)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$c(,,)2_rejPO :: ConIndex
[GblId]
$c(,,)2_rejPO
  = go13_rejPM Data.Data.$fData(,,)5 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 6, types: 17, coercions: 0, joins: 0/0}
Data.Data.$fData(,,)1
  :: forall b a c. (a -> b -> c -> (a, b, c), Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData(,,)1
  = \ (@ b_Xe5vk) (@ a_Xe5vi) (@ c_Xe5vm) ->
      (GHC.Tuple.(,,) @ a_Xe5vi @ b_Xe5vk @ c_Xe5vm, GHC.Types.False)

-- RHS size: {terms: 80, types: 184, coercions: 31, joins: 0/4}
Data.Data.$fData(,,)_$cgmapMp
  :: forall a b c.
     (Data a, Data b, Data c) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> (a, b, c) -> m (a, b, c)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 90 60 20] 680 0}]
Data.Data.$fData(,,)_$cgmapMp
  = \ (@ a_Xe5vi)
      (@ b_Xe5vk)
      (@ c_Xe5vm)
      ($dData_Xe5vo :: Data a_Xe5vi)
      ($dData1_Xe5vq :: Data b_Xe5vk)
      ($dData2_Xe5vs :: Data c_Xe5vm)
      (@ (m_ae4Wa :: * -> *))
      ($dMonadPlus_ae4Wc :: MonadPlus m_ae4Wa)
      (ds_de7CE :: forall d. Data d => d -> m_ae4Wa d)
      (eta_XCy :: (a_Xe5vi, b_Xe5vk, c_Xe5vm)) ->
      let {
        lvl270_se9Iz :: m_ae4Wa (a_Xe5vi, b_Xe5vk, c_Xe5vm)
        [LclId]
        lvl270_se9Iz
          = mzero
              @ m_ae4Wa $dMonadPlus_ae4Wc @ (a_Xe5vi, b_Xe5vk, c_Xe5vm) } in
      let {
        $dMonad_se9sL [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae4Wa
        [LclId]
        $dMonad_se9sL
          = GHC.Base.$p2MonadPlus @ m_ae4Wa $dMonadPlus_ae4Wc } in
      >>=
        @ m_ae4Wa
        $dMonad_se9sL
        @ ((a_Xe5vi, b_Xe5vk, c_Xe5vm), Bool)
        @ (a_Xe5vi, b_Xe5vk, c_Xe5vm)
        (case eta_XCy of { (a1_ae2q5, a2_ae2q6, a3_ae2q7) ->
         let {
           k_se9sK [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
             :: forall d b1.
                Data d =>
                Mp m_ae4Wa (d -> b1) -> d -> m_ae4Wa (b1, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_se9sK
             = \ (@ d_ae2Ws)
                 (@ b1_ae2Wt)
                 ($dData3_ae2Wv :: Data d_ae2Ws)
                 (ds1_de7oC [OS=OneShot] :: Mp m_ae4Wa (d_ae2Ws -> b1_ae2Wt))
                 (y_ae1Tz [OS=OneShot] :: d_ae2Ws) ->
                 let {
                   lvl271_se9Ix :: m_ae4Wa d_ae2Ws
                   [LclId]
                   lvl271_se9Ix = ds_de7CE @ d_ae2Ws $dData3_ae2Wv y_ae1Tz } in
                 >>=
                   @ m_ae4Wa
                   $dMonad_se9sL
                   @ (d_ae2Ws -> b1_ae2Wt, Bool)
                   @ (b1_ae2Wt, Bool)
                   (ds1_de7oC
                    `cast` (Data.Data.N:Mp[0] <m_ae4Wa>_R <d_ae2Ws -> b1_ae2Wt>_N
                            :: (Mp m_ae4Wa (d_ae2Ws -> b1_ae2Wt) :: *)
                               ~R# (m_ae4Wa (d_ae2Ws -> b1_ae2Wt, Bool) :: *)))
                   (\ (ds2_de7oD :: (d_ae2Ws -> b1_ae2Wt, Bool)) ->
                      case ds2_de7oD of { (h_ae1TA, b2_ae1TB) ->
                      mplus
                        @ m_ae4Wa
                        $dMonadPlus_ae4Wc
                        @ (b1_ae2Wt, Bool)
                        (>>=
                           @ m_ae4Wa
                           $dMonad_se9sL
                           @ d_ae2Ws
                           @ (b1_ae2Wt, Bool)
                           lvl271_se9Ix
                           (\ (y'_ae1TC :: d_ae2Ws) ->
                              return
                                @ m_ae4Wa
                                $dMonad_se9sL
                                @ (b1_ae2Wt, Bool)
                                (h_ae1TA y'_ae1TC, GHC.Types.True)))
                        (return
                           @ m_ae4Wa
                           $dMonad_se9sL
                           @ (b1_ae2Wt, Bool)
                           (h_ae1TA y_ae1Tz, b2_ae1TB))
                      }) } in
         k_se9sK
           @ c_Xe5vm
           @ (a_Xe5vi, b_Xe5vk, c_Xe5vm)
           $dData2_Xe5vs
           ((k_se9sK
               @ b_Xe5vk
               @ (c_Xe5vm -> (a_Xe5vi, b_Xe5vk, c_Xe5vm))
               $dData1_Xe5vq
               ((k_se9sK
                   @ a_Xe5vi
                   @ (b_Xe5vk -> c_Xe5vm -> (a_Xe5vi, b_Xe5vk, c_Xe5vm))
                   $dData_Xe5vo
                   ((return
                       @ m_ae4Wa
                       $dMonad_se9sL
                       @ (a_Xe5vi -> b_Xe5vk -> c_Xe5vm -> (a_Xe5vi, b_Xe5vk, c_Xe5vm),
                          Bool)
                       (Data.Data.$fData(,,)1 @ b_Xe5vk @ a_Xe5vi @ c_Xe5vm))
                    `cast` (Sym (Data.Data.N:Mp[0]
                                     <m_ae4Wa>_R
                                     <a_Xe5vi
                                      -> b_Xe5vk -> c_Xe5vm -> (a_Xe5vi, b_Xe5vk, c_Xe5vm)>_N)
                            :: (m_ae4Wa (a_Xe5vi
                                         -> b_Xe5vk -> c_Xe5vm -> (a_Xe5vi, b_Xe5vk, c_Xe5vm),
                                         Bool) :: *)
                               ~R# (Mp
                                      m_ae4Wa
                                      (a_Xe5vi
                                       -> b_Xe5vk -> c_Xe5vm -> (a_Xe5vi, b_Xe5vk, c_Xe5vm)) :: *)))
                   a1_ae2q5)
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_ae4Wa>_R <b_Xe5vk -> c_Xe5vm -> (a_Xe5vi, b_Xe5vk, c_Xe5vm)>_N)
                        :: (m_ae4Wa (b_Xe5vk -> c_Xe5vm -> (a_Xe5vi, b_Xe5vk, c_Xe5vm),
                                     Bool) :: *)
                           ~R# (Mp
                                  m_ae4Wa
                                  (b_Xe5vk -> c_Xe5vm -> (a_Xe5vi, b_Xe5vk, c_Xe5vm)) :: *)))
               a2_ae2q6)
            `cast` (Sym (Data.Data.N:Mp[0]
                             <m_ae4Wa>_R <c_Xe5vm -> (a_Xe5vi, b_Xe5vk, c_Xe5vm)>_N)
                    :: (m_ae4Wa (c_Xe5vm -> (a_Xe5vi, b_Xe5vk, c_Xe5vm), Bool) :: *)
                       ~R# (Mp m_ae4Wa (c_Xe5vm -> (a_Xe5vi, b_Xe5vk, c_Xe5vm)) :: *)))
           a3_ae2q7
         })
        (\ (ds1_de7oa :: ((a_Xe5vi, b_Xe5vk, c_Xe5vm), Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b1_ae1TE) ->
           case b1_ae1TE of {
             False -> lvl270_se9Iz;
             True ->
               return
                 @ m_ae4Wa $dMonad_se9sL @ (a_Xe5vi, b_Xe5vk, c_Xe5vm) x'_ae1TD
           }
           })

-- RHS size: {terms: 46, types: 94, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapM1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (Data a, Data b, Data c) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> a -> b -> c -> m (a, b, c)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 120 60 0 0 0] 380 0}]
Data.Data.$w$cgmapM1
  = \ (@ a_segbh)
      (@ b_segbi)
      (@ c_segbj)
      (w_segbk :: Data a_segbh)
      (w1_segbl :: Data b_segbi)
      (w2_segbm :: Data c_segbj)
      (@ (m_segbn :: * -> *))
      (w3_segbo :: Monad m_segbn)
      (w4_segbp :: forall d. Data d => d -> m_segbn d)
      (ww_segbt :: a_segbh)
      (ww1_segbu :: b_segbi)
      (ww2_segbv :: c_segbj) ->
      let {
        k_se9sH [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
          :: forall d b1. Data d => m_segbn (d -> b1) -> d -> m_segbn b1
        [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
        k_se9sH
          = \ (@ d_ae2Vh)
              (@ b1_ae2Vi)
              ($dData_ae2Vk :: Data d_ae2Vh)
              (c1_ae1Tm [OS=OneShot] :: m_segbn (d_ae2Vh -> b1_ae2Vi))
              (x_ae1Tn [OS=OneShot] :: d_ae2Vh) ->
              let {
                lvl270_se9IA :: m_segbn d_ae2Vh
                [LclId]
                lvl270_se9IA = w4_segbp @ d_ae2Vh $dData_ae2Vk x_ae1Tn } in
              >>=
                @ m_segbn
                w3_segbo
                @ (d_ae2Vh -> b1_ae2Vi)
                @ b1_ae2Vi
                c1_ae1Tm
                (\ (c'_ae1To :: d_ae2Vh -> b1_ae2Vi) ->
                   >>=
                     @ m_segbn
                     w3_segbo
                     @ d_ae2Vh
                     @ b1_ae2Vi
                     lvl270_se9IA
                     (\ (x'_ae1Tp :: d_ae2Vh) ->
                        return @ m_segbn w3_segbo @ b1_ae2Vi (c'_ae1To x'_ae1Tp))) } in
      k_se9sH
        @ c_segbj
        @ (a_segbh, b_segbi, c_segbj)
        w2_segbm
        (k_se9sH
           @ b_segbi
           @ (c_segbj -> (a_segbh, b_segbi, c_segbj))
           w1_segbl
           (k_se9sH
              @ a_segbh
              @ (b_segbi -> c_segbj -> (a_segbh, b_segbi, c_segbj))
              w_segbk
              (return
                 @ m_segbn
                 w3_segbo
                 @ (a_segbh -> b_segbi -> c_segbj -> (a_segbh, b_segbi, c_segbj))
                 (GHC.Tuple.(,,) @ a_segbh @ b_segbi @ c_segbj))
              ww_segbt)
           ww1_segbu)
        ww2_segbv

-- RHS size: {terms: 22, types: 40, coercions: 0, joins: 0/0}
Data.Data.$fData(,,)_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (Data a, Data b, Data c) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> (a, b, c) -> m (a, b, c)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_segbh)
                 (@ b_segbi)
                 (@ c_segbj)
                 (w_segbk [Occ=Once] :: Data a_segbh)
                 (w1_segbl [Occ=Once] :: Data b_segbi)
                 (w2_segbm [Occ=Once] :: Data c_segbj)
                 (@ (m_segbn :: * -> *))
                 (w3_segbo [Occ=Once] :: Monad m_segbn)
                 (w4_segbp [Occ=Once] :: forall d. Data d => d -> m_segbn d)
                 (w5_segbq [Occ=Once!] :: (a_segbh, b_segbi, c_segbj)) ->
                 case w5_segbq of
                 { (ww1_segbt [Occ=Once], ww2_segbu [Occ=Once],
                    ww3_segbv [Occ=Once]) ->
                 Data.Data.$w$cgmapM1
                   @ a_segbh
                   @ b_segbi
                   @ c_segbj
                   w_segbk
                   w1_segbl
                   w2_segbm
                   @ m_segbn
                   w3_segbo
                   w4_segbp
                   ww1_segbt
                   ww2_segbu
                   ww3_segbv
                 }}]
Data.Data.$fData(,,)_$cgmapM
  = \ (@ a_segbh)
      (@ b_segbi)
      (@ c_segbj)
      (w_segbk :: Data a_segbh)
      (w1_segbl :: Data b_segbi)
      (w2_segbm :: Data c_segbj)
      (@ (m_segbn :: * -> *))
      (w3_segbo :: Monad m_segbn)
      (w4_segbp :: forall d. Data d => d -> m_segbn d)
      (w5_segbq :: (a_segbh, b_segbi, c_segbj)) ->
      case w5_segbq of { (ww1_segbt, ww2_segbu, ww3_segbv) ->
      Data.Data.$w$cgmapM1
        @ a_segbh
        @ b_segbi
        @ c_segbj
        w_segbk
        w1_segbl
        w2_segbm
        @ m_segbn
        w3_segbo
        w4_segbp
        ww1_segbt
        ww2_segbu
        ww3_segbv
      }

-- RHS size: {terms: 28, types: 29, coercions: 0, joins: 0/0}
Data.Data.$w$cgmapQi [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (Data a, Data b, Data c) =>
     forall u. Int# -> (forall d. Data d => d -> u) -> a -> b -> c -> u
[GblId,
 Arity=8,
 Str=<L,U><L,U><L,U><S,1*U><C(C(S)),1*C1(C1(U))><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 110 180 0 0 0] 130 0}]
Data.Data.$w$cgmapQi
  = \ (@ a_segby)
      (@ b_segbz)
      (@ c_segbA)
      (w_segbB :: Data a_segby)
      (w1_segbC :: Data b_segbz)
      (w2_segbD :: Data c_segbA)
      (@ u_segbE)
      (ww_segbK :: Int#)
      (w3_segbG :: forall d. Data d => d -> u_segbE)
      (ww1_segbO :: a_segby)
      (ww2_segbP :: b_segbz)
      (ww3_segbQ :: c_segbA) ->
      case ww_segbK of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_segbE;
        0# -> w3_segbG @ a_segby w_segbB ww1_segbO;
        1# -> w3_segbG @ b_segbz w1_segbC ww2_segbP;
        2# -> w3_segbG @ c_segbA w2_segbD ww3_segbQ
      }

-- RHS size: {terms: 25, types: 38, coercions: 0, joins: 0/0}
Data.Data.$fData(,,)_$cgmapQi [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (Data a, Data b, Data c) =>
     forall u. Int -> (forall d. Data d => d -> u) -> (a, b, c) -> u
[GblId,
 Arity=6,
 Str=<L,U><L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_segby)
                 (@ b_segbz)
                 (@ c_segbA)
                 (w_segbB [Occ=Once] :: Data a_segby)
                 (w1_segbC [Occ=Once] :: Data b_segbz)
                 (w2_segbD [Occ=Once] :: Data c_segbA)
                 (@ u_segbE)
                 (w3_segbF [Occ=Once!] :: Int)
                 (w4_segbG [Occ=Once] :: forall d. Data d => d -> u_segbE)
                 (w5_segbH [Occ=Once!] :: (a_segby, b_segbz, c_segbA)) ->
                 case w3_segbF of { I# ww1_segbK [Occ=Once] ->
                 case w5_segbH of
                 { (ww3_segbO [Occ=Once], ww4_segbP [Occ=Once],
                    ww5_segbQ [Occ=Once]) ->
                 Data.Data.$w$cgmapQi
                   @ a_segby
                   @ b_segbz
                   @ c_segbA
                   w_segbB
                   w1_segbC
                   w2_segbD
                   @ u_segbE
                   ww1_segbK
                   w4_segbG
                   ww3_segbO
                   ww4_segbP
                   ww5_segbQ
                 }
                 }}]
Data.Data.$fData(,,)_$cgmapQi
  = \ (@ a_segby)
      (@ b_segbz)
      (@ c_segbA)
      (w_segbB :: Data a_segby)
      (w1_segbC :: Data b_segbz)
      (w2_segbD :: Data c_segbA)
      (@ u_segbE)
      (w3_segbF :: Int)
      (w4_segbG :: forall d. Data d => d -> u_segbE)
      (w5_segbH :: (a_segby, b_segbz, c_segbA)) ->
      case w3_segbF of { I# ww1_segbK ->
      case w5_segbH of { (ww3_segbO, ww4_segbP, ww5_segbQ) ->
      Data.Data.$w$cgmapQi
        @ a_segby
        @ b_segbz
        @ c_segbA
        w_segbB
        w1_segbC
        w2_segbD
        @ u_segbE
        ww1_segbK
        w4_segbG
        ww3_segbO
        ww4_segbP
        ww5_segbQ
      }
      }

-- RHS size: {terms: 27, types: 32, coercions: 0, joins: 0/0}
Data.Data.$w$cgmapQr [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (Data a, Data b, Data c) =>
     forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> a -> b -> c -> r
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 60 0 180 0 0 0] 180 0}]
Data.Data.$w$cgmapQr
  = \ (@ a_segbT)
      (@ b_segbU)
      (@ c_segbV)
      (w_segbW :: Data a_segbT)
      (w1_segbX :: Data b_segbU)
      (w2_segbY :: Data c_segbV)
      (@ r_segbZ)
      (@ r'_segc0)
      (w3_segc1 :: r'_segc0 -> r_segbZ -> r_segbZ)
      (w4_segc2 :: r_segbZ)
      (w5_segc3 :: forall d. Data d => d -> r'_segc0)
      (ww_segc7 :: a_segbT)
      (ww1_segc8 :: b_segbU)
      (ww2_segc9 :: c_segbV) ->
      w3_segc1
        (w5_segc3 @ a_segbT w_segbW ww_segc7)
        (w3_segc1
           (w5_segc3 @ b_segbU w1_segbX ww1_segc8)
           (w3_segc1 (w5_segc3 @ c_segbV w2_segbY ww2_segc9) w4_segc2))

-- RHS size: {terms: 25, types: 42, coercions: 0, joins: 0/0}
Data.Data.$fData(,,)_$cgmapQr [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (Data a, Data b, Data c) =>
     forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> (a, b, c) -> r
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=7,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_segbT)
                 (@ b_segbU)
                 (@ c_segbV)
                 (w_segbW [Occ=Once] :: Data a_segbT)
                 (w1_segbX [Occ=Once] :: Data b_segbU)
                 (w2_segbY [Occ=Once] :: Data c_segbV)
                 (@ r_segbZ)
                 (@ r'_segc0)
                 (w3_segc1 [Occ=Once] :: r'_segc0 -> r_segbZ -> r_segbZ)
                 (w4_segc2 [Occ=Once] :: r_segbZ)
                 (w5_segc3 [Occ=Once] :: forall d. Data d => d -> r'_segc0)
                 (w6_segc4 [Occ=Once!] :: (a_segbT, b_segbU, c_segbV)) ->
                 case w6_segc4 of
                 { (ww1_segc7 [Occ=Once], ww2_segc8 [Occ=Once],
                    ww3_segc9 [Occ=Once]) ->
                 Data.Data.$w$cgmapQr
                   @ a_segbT
                   @ b_segbU
                   @ c_segbV
                   w_segbW
                   w1_segbX
                   w2_segbY
                   @ r_segbZ
                   @ r'_segc0
                   w3_segc1
                   w4_segc2
                   w5_segc3
                   ww1_segc7
                   ww2_segc8
                   ww3_segc9
                 }}]
Data.Data.$fData(,,)_$cgmapQr
  = \ (@ a_segbT)
      (@ b_segbU)
      (@ c_segbV)
      (w_segbW :: Data a_segbT)
      (w1_segbX :: Data b_segbU)
      (w2_segbY :: Data c_segbV)
      (@ r_segbZ)
      (@ r'_segc0)
      (w3_segc1 :: r'_segc0 -> r_segbZ -> r_segbZ)
      (w4_segc2 :: r_segbZ)
      (w5_segc3 :: forall d. Data d => d -> r'_segc0)
      (w6_segc4 :: (a_segbT, b_segbU, c_segbV)) ->
      case w6_segc4 of { (ww1_segc7, ww2_segc8, ww3_segc9) ->
      Data.Data.$w$cgmapQr
        @ a_segbT
        @ b_segbU
        @ c_segbV
        w_segbW
        w1_segbX
        w2_segbY
        @ r_segbZ
        @ r'_segc0
        w3_segc1
        w4_segc2
        w5_segc3
        ww1_segc7
        ww2_segc8
        ww3_segc9
      }

-- RHS size: {terms: 25, types: 38, coercions: 0, joins: 0/0}
Data.Data.$fData(,,)_$cgmapQ [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (Data a, Data b, Data c) =>
     forall u. (forall d. Data d => d -> u) -> (a, b, c) -> [u]
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,C(C1(U))><S,1*U(U,U,U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_segcc)
                 (@ b_segcd)
                 (@ c_segce)
                 (w_segcf [Occ=Once] :: Data a_segcc)
                 (w1_segcg [Occ=Once] :: Data b_segcd)
                 (w2_segch [Occ=Once] :: Data c_segce)
                 (@ u_segci)
                 (w3_segcj :: forall d. Data d => d -> u_segci)
                 (w4_segck [Occ=Once!] :: (a_segcc, b_segcd, c_segce)) ->
                 case w4_segck of
                 { (ww1_segcn [Occ=Once], ww2_segco [Occ=Once],
                    ww3_segcp [Occ=Once]) ->
                 GHC.Types.:
                   @ u_segci
                   (w3_segcj @ a_segcc w_segcf ww1_segcn)
                   (GHC.Types.:
                      @ u_segci
                      (w3_segcj @ b_segcd w1_segcg ww2_segco)
                      (GHC.Types.:
                         @ u_segci
                         (w3_segcj @ c_segce w2_segch ww3_segcp)
                         (GHC.Types.[] @ u_segci)))
                 }}]
Data.Data.$fData(,,)_$cgmapQ
  = \ (@ a_segcc)
      (@ b_segcd)
      (@ c_segce)
      (w_segcf :: Data a_segcc)
      (w1_segcg :: Data b_segcd)
      (w2_segch :: Data c_segce)
      (@ u_segci)
      (w3_segcj :: forall d. Data d => d -> u_segci)
      (w4_segck :: (a_segcc, b_segcd, c_segce)) ->
      case w4_segck of { (ww1_segcn, ww2_segco, ww3_segcp) ->
      GHC.Types.:
        @ u_segci
        (w3_segcj @ a_segcc w_segcf ww1_segcn)
        (GHC.Types.:
           @ u_segci
           (w3_segcj @ b_segcd w1_segcg ww2_segco)
           (GHC.Types.:
              @ u_segci
              (w3_segcj @ c_segce w2_segch ww3_segcp)
              (GHC.Types.[] @ u_segci)))
      }

-- RHS size: {terms: 27, types: 32, coercions: 0, joins: 0/0}
Data.Data.$w$cgmapQl
  :: forall a b c.
     (Data a, Data b, Data c) =>
     forall r r'.
     (r -> r' -> r)
     -> r -> (forall d. Data d => d -> r') -> a -> b -> c -> r
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 60 0 180 0 0 0] 180 0}]
Data.Data.$w$cgmapQl
  = \ (@ a_segcv)
      (@ b_segcw)
      (@ c_segcx)
      (w_segcy :: Data a_segcv)
      (w1_segcz :: Data b_segcw)
      (w2_segcA :: Data c_segcx)
      (@ r_segcB)
      (@ r'_segcC)
      (w3_segcD :: r_segcB -> r'_segcC -> r_segcB)
      (w4_segcE :: r_segcB)
      (w5_segcF :: forall d. Data d => d -> r'_segcC)
      (ww_segcJ :: a_segcv)
      (ww1_segcK :: b_segcw)
      (ww2_segcL :: c_segcx) ->
      w3_segcD
        (w3_segcD
           (w3_segcD w4_segcE (w5_segcF @ a_segcv w_segcy ww_segcJ))
           (w5_segcF @ b_segcw w1_segcz ww1_segcK))
        (w5_segcF @ c_segcx w2_segcA ww2_segcL)

-- RHS size: {terms: 25, types: 42, coercions: 9, joins: 0/0}
Data.Data.$fData(,,)2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (Data a, Data b, Data c) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data d => d -> r')
     -> (a, b, c)
     -> Const r (a, b, c)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=7,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xehck)
                 (@ b_Xehcm)
                 (@ c_Xehco)
                 (w_Xehcq [Occ=Once] :: Data a_Xehck)
                 (w1_Xehcs [Occ=Once] :: Data b_Xehcm)
                 (w2_Xehcu [Occ=Once] :: Data c_Xehco)
                 (@ r_Xehcw)
                 (@ r'_Xehcy)
                 (w3_XehcA [Occ=Once] :: r_Xehcw -> r'_Xehcy -> r_Xehcw)
                 (w4_XehcC [Occ=Once] :: r_Xehcw)
                 (w5_XehcE [Occ=Once] :: forall d. Data d => d -> r'_Xehcy)
                 (w6_segcG [Occ=Once!] :: (a_Xehck, b_Xehcm, c_Xehco)) ->
                 case w6_segcG of
                 { (ww1_XehcM [Occ=Once], ww2_XehcO [Occ=Once],
                    ww3_XehcQ [Occ=Once]) ->
                 (Data.Data.$w$cgmapQl
                    @ a_Xehck
                    @ b_Xehcm
                    @ c_Xehco
                    w_Xehcq
                    w1_Xehcs
                    w2_Xehcu
                    @ r_Xehcw
                    @ r'_Xehcy
                    w3_XehcA
                    w4_XehcC
                    w5_XehcE
                    ww1_XehcM
                    ww2_XehcO
                    ww3_XehcQ)
                 `cast` (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r_Xehcw>_R <(a_Xehck, b_Xehcm, c_Xehco)>_P)
                         :: (r_Xehcw :: *)
                            ~R# (Const r_Xehcw (a_Xehck, b_Xehcm, c_Xehco) :: *))
                 }}]
Data.Data.$fData(,,)2
  = \ (@ a_Xehck)
      (@ b_Xehcm)
      (@ c_Xehco)
      (w_Xehcq :: Data a_Xehck)
      (w1_Xehcs :: Data b_Xehcm)
      (w2_Xehcu :: Data c_Xehco)
      (@ r_Xehcw)
      (@ r'_Xehcy)
      (w3_XehcA :: r_Xehcw -> r'_Xehcy -> r_Xehcw)
      (w4_XehcC :: r_Xehcw)
      (w5_XehcE :: forall d. Data d => d -> r'_Xehcy)
      (w6_segcG :: (a_Xehck, b_Xehcm, c_Xehco)) ->
      case w6_segcG of { (ww1_XehcM, ww2_XehcO, ww3_XehcQ) ->
      (Data.Data.$w$cgmapQl
         @ a_Xehck
         @ b_Xehcm
         @ c_Xehco
         w_Xehcq
         w1_Xehcs
         w2_Xehcu
         @ r_Xehcw
         @ r'_Xehcy
         w3_XehcA
         w4_XehcC
         w5_XehcE
         ww1_XehcM
         ww2_XehcO
         ww3_XehcQ)
      `cast` (Sym (Data.Functor.Const.N:Const[0]
                       <*>_N <r_Xehcw>_R <(a_Xehck, b_Xehcm, c_Xehco)>_P)
              :: (r_Xehcw :: *)
                 ~R# (Const r_Xehcw (a_Xehck, b_Xehcm, c_Xehco) :: *))
      }

-- RHS size: {terms: 21, types: 35, coercions: 6, joins: 0/0}
Data.Data.$fData(,,)3
  :: forall a b c.
     (Data a, Data b, Data c) =>
     (forall b1. Data b1 => b1 -> b1) -> (a, b, c) -> Identity (a, b, c)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,C(C1(U))><S,1*U(U,U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe5vc)
                 (@ b_Xe5ve)
                 (@ c_Xe5vg)
                 ($dData_Xe5vi [Occ=Once] :: Data a_Xe5vc)
                 ($dData1_Xe5vk [Occ=Once] :: Data b_Xe5ve)
                 ($dData2_Xe5vm [Occ=Once] :: Data c_Xe5vg)
                 (ds_de7Ct :: forall b1. Data b1 => b1 -> b1)
                 (x0_Xe2Wa [Occ=Once!] :: (a_Xe5vc, b_Xe5ve, c_Xe5vg)) ->
                 case x0_Xe2Wa of
                 { (a1_ae2q5 [Occ=Once], a2_ae2q6 [Occ=Once],
                    a3_ae2q7 [Occ=Once]) ->
                 (ds_de7Ct @ a_Xe5vc $dData_Xe5vi a1_ae2q5,
                  ds_de7Ct @ b_Xe5ve $dData1_Xe5vk a2_ae2q6,
                  ds_de7Ct @ c_Xe5vg $dData2_Xe5vm a3_ae2q7)
                 `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                                  <(a_Xe5vc, b_Xe5ve, c_Xe5vg)>_R)
                         :: ((a_Xe5vc, b_Xe5ve, c_Xe5vg) :: *)
                            ~R# (Identity (a_Xe5vc, b_Xe5ve, c_Xe5vg) :: *))
                 }}]
Data.Data.$fData(,,)3
  = \ (@ a_Xe5vc)
      (@ b_Xe5ve)
      (@ c_Xe5vg)
      ($dData_Xe5vi :: Data a_Xe5vc)
      ($dData1_Xe5vk :: Data b_Xe5ve)
      ($dData2_Xe5vm :: Data c_Xe5vg)
      (ds_de7Ct :: forall b1. Data b1 => b1 -> b1)
      (x0_Xe2Wa :: (a_Xe5vc, b_Xe5ve, c_Xe5vg)) ->
      case x0_Xe2Wa of { (a1_ae2q5, a2_ae2q6, a3_ae2q7) ->
      (ds_de7Ct @ a_Xe5vc $dData_Xe5vi a1_ae2q5,
       ds_de7Ct @ b_Xe5ve $dData1_Xe5vk a2_ae2q6,
       ds_de7Ct @ c_Xe5vg $dData2_Xe5vm a3_ae2q7)
      `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                       <(a_Xe5vc, b_Xe5ve, c_Xe5vg)>_R)
              :: ((a_Xe5vc, b_Xe5ve, c_Xe5vg) :: *)
                 ~R# (Identity (a_Xe5vc, b_Xe5ve, c_Xe5vg) :: *))
      }

-- RHS size: {terms: 90, types: 191, coercions: 31, joins: 0/4}
Data.Data.$fData(,,)_$cgmapMo
  :: forall a b c.
     (Data a, Data b, Data c) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> (a, b, c) -> m (a, b, c)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U,U)>,
 Unf=OtherCon []]
Data.Data.$fData(,,)_$cgmapMo
  = \ (@ a_Xe5va)
      (@ b_Xe683)
      (@ c_Xe686)
      ($dData_Xe689 :: Data a_Xe5va)
      ($dData1_Xe68c :: Data b_Xe683)
      ($dData2_Xe68f :: Data c_Xe686)
      (@ (m_ae4Wq :: * -> *))
      ($dMonadPlus_ae4Ws :: MonadPlus m_ae4Wq)
      (ds_de7CF :: forall d. Data d => d -> m_ae4Wq d)
      (eta_XD0 :: (a_Xe5va, b_Xe683, c_Xe686)) ->
      let {
        lvl270_se9IF :: m_ae4Wq (a_Xe5va, b_Xe683, c_Xe686)
        [LclId]
        lvl270_se9IF
          = mzero
              @ m_ae4Wq $dMonadPlus_ae4Ws @ (a_Xe5va, b_Xe683, c_Xe686) } in
      let {
        $dMonad_se9sD [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae4Wq
        [LclId]
        $dMonad_se9sD
          = GHC.Base.$p2MonadPlus @ m_ae4Wq $dMonadPlus_ae4Ws } in
      >>=
        @ m_ae4Wq
        $dMonad_se9sD
        @ ((a_Xe5va, b_Xe683, c_Xe686), Bool)
        @ (a_Xe5va, b_Xe683, c_Xe686)
        (case eta_XD0 of { (a1_ae2q5, a2_ae2q6, a3_ae2q7) ->
         let {
           k_se9sC [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
             :: forall d b1.
                Data d =>
                Mp m_ae4Wq (d -> b1) -> d -> m_ae4Wq (b1, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_se9sC
             = \ (@ d_ae2Ya)
                 (@ b1_ae2Yb)
                 ($dData3_ae2Yd :: Data d_ae2Ya)
                 (ds1_de7pC [OS=OneShot] :: Mp m_ae4Wq (d_ae2Ya -> b1_ae2Yb))
                 (y_ae1TO [OS=OneShot] :: d_ae2Ya) ->
                 let {
                   lvl271_se9ID :: m_ae4Wq d_ae2Ya
                   [LclId]
                   lvl271_se9ID = ds_de7CF @ d_ae2Ya $dData3_ae2Yd y_ae1TO } in
                 >>=
                   @ m_ae4Wq
                   $dMonad_se9sD
                   @ (d_ae2Ya -> b1_ae2Yb, Bool)
                   @ (b1_ae2Yb, Bool)
                   (ds1_de7pC
                    `cast` (Data.Data.N:Mp[0] <m_ae4Wq>_R <d_ae2Ya -> b1_ae2Yb>_N
                            :: (Mp m_ae4Wq (d_ae2Ya -> b1_ae2Yb) :: *)
                               ~R# (m_ae4Wq (d_ae2Ya -> b1_ae2Yb, Bool) :: *)))
                   (\ (ds2_de7pD :: (d_ae2Ya -> b1_ae2Yb, Bool)) ->
                      case ds2_de7pD of { (h_ae1TP, b2_ae1TQ) ->
                      case b2_ae1TQ of {
                        False ->
                          mplus
                            @ m_ae4Wq
                            $dMonadPlus_ae4Ws
                            @ (b1_ae2Yb, Bool)
                            (>>=
                               @ m_ae4Wq
                               $dMonad_se9sD
                               @ d_ae2Ya
                               @ (b1_ae2Yb, Bool)
                               lvl271_se9ID
                               (\ (y'_ae1TR :: d_ae2Ya) ->
                                  return
                                    @ m_ae4Wq
                                    $dMonad_se9sD
                                    @ (b1_ae2Yb, Bool)
                                    (h_ae1TP y'_ae1TR, GHC.Types.True)))
                            (return
                               @ m_ae4Wq
                               $dMonad_se9sD
                               @ (b1_ae2Yb, Bool)
                               (h_ae1TP y_ae1TO, GHC.Types.False));
                        True ->
                          return
                            @ m_ae4Wq
                            $dMonad_se9sD
                            @ (b1_ae2Yb, Bool)
                            (h_ae1TP y_ae1TO, GHC.Types.True)
                      }
                      }) } in
         k_se9sC
           @ c_Xe686
           @ (a_Xe5va, b_Xe683, c_Xe686)
           $dData2_Xe68f
           ((k_se9sC
               @ b_Xe683
               @ (c_Xe686 -> (a_Xe5va, b_Xe683, c_Xe686))
               $dData1_Xe68c
               ((k_se9sC
                   @ a_Xe5va
                   @ (b_Xe683 -> c_Xe686 -> (a_Xe5va, b_Xe683, c_Xe686))
                   $dData_Xe689
                   ((return
                       @ m_ae4Wq
                       $dMonad_se9sD
                       @ (a_Xe5va -> b_Xe683 -> c_Xe686 -> (a_Xe5va, b_Xe683, c_Xe686),
                          Bool)
                       (Data.Data.$fData(,,)1 @ b_Xe683 @ a_Xe5va @ c_Xe686))
                    `cast` (Sym (Data.Data.N:Mp[0]
                                     <m_ae4Wq>_R
                                     <a_Xe5va
                                      -> b_Xe683 -> c_Xe686 -> (a_Xe5va, b_Xe683, c_Xe686)>_N)
                            :: (m_ae4Wq (a_Xe5va
                                         -> b_Xe683 -> c_Xe686 -> (a_Xe5va, b_Xe683, c_Xe686),
                                         Bool) :: *)
                               ~R# (Mp
                                      m_ae4Wq
                                      (a_Xe5va
                                       -> b_Xe683 -> c_Xe686 -> (a_Xe5va, b_Xe683, c_Xe686)) :: *)))
                   a1_ae2q5)
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_ae4Wq>_R <b_Xe683 -> c_Xe686 -> (a_Xe5va, b_Xe683, c_Xe686)>_N)
                        :: (m_ae4Wq (b_Xe683 -> c_Xe686 -> (a_Xe5va, b_Xe683, c_Xe686),
                                     Bool) :: *)
                           ~R# (Mp
                                  m_ae4Wq
                                  (b_Xe683 -> c_Xe686 -> (a_Xe5va, b_Xe683, c_Xe686)) :: *)))
               a2_ae2q6)
            `cast` (Sym (Data.Data.N:Mp[0]
                             <m_ae4Wq>_R <c_Xe686 -> (a_Xe5va, b_Xe683, c_Xe686)>_N)
                    :: (m_ae4Wq (c_Xe686 -> (a_Xe5va, b_Xe683, c_Xe686), Bool) :: *)
                       ~R# (Mp m_ae4Wq (c_Xe686 -> (a_Xe5va, b_Xe683, c_Xe686)) :: *)))
           a3_ae2q7
         })
        (\ (ds1_de7pa :: ((a_Xe5va, b_Xe683, c_Xe686), Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b1_ae1TT) ->
           case b1_ae1TT of {
             False -> lvl270_se9IF;
             True ->
               return
                 @ m_ae4Wq $dMonad_se9sD @ (a_Xe5va, b_Xe683, c_Xe686) x'_ae1TS
           }
           })

-- RHS size: {terms: 8, types: 17, coercions: 0, joins: 0/0}
lvl107_rejPP :: forall c b a. (a, b, c) -> Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []]
lvl107_rejPP
  = \ (@ c_Xe686)
      (@ b_Xe5vb)
      (@ a_Xe5v9)
      (ds_de7Cm :: (a_Xe5v9, b_Xe5vb, c_Xe686)) ->
      case ds_de7Cm of { (ds1_de7Cn, ds2_de7Co, ds3_de7Cp) ->
      Data.Data.$c(,,)
      }

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
lvl108_rejPQ :: forall a b c. (a, b, c) -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl108_rejPQ
  = \ (@ a_Xe5v9) (@ b_Xe5vb) (@ c_Xe686) _ [Occ=Dead] ->
      Data.Data.$t(,,)

-- RHS size: {terms: 8, types: 32, coercions: 0, joins: 0/0}
lvl109_rejPR
  :: forall a b c1 (t :: * -> *) (c2 :: * -> *).
     Typeable t =>
     (forall d. Data d => c2 (t d)) -> Maybe (c2 (a, b, c1))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl109_rejPR
  = \ (@ a_Xe5v9)
      (@ b_Xe5vb)
      (@ c_Xe686)
      (@ (t_ae4U3 :: * -> *))
      (@ (c1_ae4U4 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c1_ae4U4 (a_Xe5v9, b_Xe5vb, c_Xe686))

-- RHS size: {terms: 8, types: 41, coercions: 0, joins: 0/0}
lvl110_rejPS
  :: forall a b c1 (t :: * -> * -> *) (c2 :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c2 (t d e))
     -> Maybe (c2 (a, b, c1))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl110_rejPS
  = \ (@ a_Xe5v9)
      (@ b_Xe5vb)
      (@ c_Xe686)
      (@ (t_ae4Um :: * -> * -> *))
      (@ (c1_ae4Un :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c1_ae4Un (a_Xe5v9, b_Xe5vb, c_Xe686))

-- RHS size: {terms: 55, types: 61, coercions: 57, joins: 0/0}
Data.Data.$fData(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c. (Data a, Data b, Data c) => Data (a, b, c)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_ae1XR)
             (@ b_ae1XS)
             (@ c_ae1XT)
             (v_XCV :: Data a_ae1XR)
             (v1_XCX :: Data b_ae1XS)
             (v2_XCZ :: Data c_ae1XT) ->
       Data.Data.C:Data TYPE: (a_ae1XR, b_ae1XS, c_ae1XT)
                        (Data.Data.$fData(,,)8
                           @ a_ae1XR @ b_ae1XS @ c_ae1XT v_XCV v1_XCX v2_XCZ)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <(a_ae1XR,
                                                                                   b_ae1XS,
                                                                                   c_ae1XT)>_N
                                :: (Data.Typeable.Internal.TypeRep
                                      (a_ae1XR, b_ae1XS, c_ae1XT) :: *)
                                   ~R# (Typeable (a_ae1XR, b_ae1XS, c_ae1XT) :: Constraint))
                        Data.Data.$fData(,,)_$cgfoldl
                          @ a_ae1XR @ b_ae1XS @ c_ae1XT v_XCV v1_XCX v2_XCZ
                        Data.Data.$fData(,,)_$cgunfold
                          @ a_ae1XR @ b_ae1XS @ c_ae1XT v_XCV v1_XCX v2_XCZ
                        \ (ds_de7Cm [Occ=Once!] :: (a_ae1XR, b_ae1XS, c_ae1XT)) ->
                          case ds_de7Cm of { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
                          Data.Data.$c(,,)
                          }
                        \ _ [Occ=Dead] -> Data.Data.$t(,,)
                        \ (@ (t_ae4U3 :: * -> *))
                          (@ (c1_ae4U4 :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c1_ae4U4 (a_ae1XR, b_ae1XS, c_ae1XT))
                        \ (@ (t_ae4Um :: * -> * -> *))
                          (@ (c1_ae4Un :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c1_ae4Un (a_ae1XR, b_ae1XS, c_ae1XT))
                        (Data.Data.$fData(,,)3
                           @ a_ae1XR @ b_ae1XS @ c_ae1XT v_XCV v1_XCX v2_XCZ)
                        `cast` (<forall b1. Data b1 => b1 -> b1>_R
                                ->_R <(a_ae1XR, b_ae1XS, c_ae1XT)>_R
                                ->_R Data.Functor.Identity.N:Identity[0]
                                         <(a_ae1XR, b_ae1XS, c_ae1XT)>_R
                                :: ((forall b1. Data b1 => b1 -> b1)
                                    -> (a_ae1XR, b_ae1XS, c_ae1XT)
                                    -> Identity (a_ae1XR, b_ae1XS, c_ae1XT) :: *)
                                   ~R# ((forall b1. Data b1 => b1 -> b1)
                                        -> (a_ae1XR, b_ae1XS, c_ae1XT)
                                        -> (a_ae1XR, b_ae1XS, c_ae1XT) :: *))
                        (Data.Data.$fData(,,)2
                           @ a_ae1XR @ b_ae1XS @ c_ae1XT v_XCV v1_XCX v2_XCZ)
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <(a_ae1XR, b_ae1XS, c_ae1XT)>_R
                                ->_R Data.Functor.Const.N:Const[0]
                                         <*>_N <r>_R <(a_ae1XR, b_ae1XS, c_ae1XT)>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> (a_ae1XR, b_ae1XS, c_ae1XT)
                                    -> Const r (a_ae1XR, b_ae1XS, c_ae1XT) :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d. Data d => d -> r')
                                        -> (a_ae1XR, b_ae1XS, c_ae1XT)
                                        -> r :: *))
                        Data.Data.$fData(,,)_$cgmapQr
                          @ a_ae1XR @ b_ae1XS @ c_ae1XT v_XCV v1_XCX v2_XCZ
                        Data.Data.$fData(,,)_$cgmapQ
                          @ a_ae1XR @ b_ae1XS @ c_ae1XT v_XCV v1_XCX v2_XCZ
                        Data.Data.$fData(,,)_$cgmapQi
                          @ a_ae1XR @ b_ae1XS @ c_ae1XT v_XCV v1_XCX v2_XCZ
                        Data.Data.$fData(,,)_$cgmapM
                          @ a_ae1XR @ b_ae1XS @ c_ae1XT v_XCV v1_XCX v2_XCZ
                        Data.Data.$fData(,,)_$cgmapMp
                          @ a_ae1XR @ b_ae1XS @ c_ae1XT v_XCV v1_XCX v2_XCZ
                        Data.Data.$fData(,,)_$cgmapMo
                          @ a_ae1XR @ b_ae1XS @ c_ae1XT v_XCV v1_XCX v2_XCZ]
Data.Data.$fData(,,)
  = \ (@ a_Xe5v9)
      (@ b_Xe5vb)
      (@ c_Xe686)
      ($dData_Xe689 :: Data a_Xe5v9)
      ($dData1_Xe68c :: Data b_Xe5vb)
      ($dData2_Xe68f :: Data c_Xe686) ->
      Data.Data.C:Data
        @ (a_Xe5v9, b_Xe5vb, c_Xe686)
        ((Data.Data.$fData(,,)8
            @ a_Xe5v9
            @ b_Xe5vb
            @ c_Xe686
            $dData_Xe689
            $dData1_Xe68c
            $dData2_Xe68f)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <(a_Xe5v9,
                                                                    b_Xe5vb, c_Xe686)>_N
                 :: (Data.Typeable.Internal.TypeRep
                       (a_Xe5v9, b_Xe5vb, c_Xe686) :: *)
                    ~R# (Typeable (a_Xe5v9, b_Xe5vb, c_Xe686) :: Constraint)))
        (Data.Data.$fData(,,)_$cgfoldl
           @ a_Xe5v9
           @ b_Xe5vb
           @ c_Xe686
           $dData_Xe689
           $dData1_Xe68c
           $dData2_Xe68f)
        (Data.Data.$fData(,,)_$cgunfold
           @ a_Xe5v9
           @ b_Xe5vb
           @ c_Xe686
           $dData_Xe689
           $dData1_Xe68c
           $dData2_Xe68f)
        (lvl107_rejPP @ c_Xe686 @ b_Xe5vb @ a_Xe5v9)
        (lvl108_rejPQ @ a_Xe5v9 @ b_Xe5vb @ c_Xe686)
        (lvl109_rejPR @ a_Xe5v9 @ b_Xe5vb @ c_Xe686)
        (lvl110_rejPS @ a_Xe5v9 @ b_Xe5vb @ c_Xe686)
        ((Data.Data.$fData(,,)3
            @ a_Xe5v9
            @ b_Xe5vb
            @ c_Xe686
            $dData_Xe689
            $dData1_Xe68c
            $dData2_Xe68f)
         `cast` (<forall b1. Data b1 => b1 -> b1>_R
                 ->_R <(a_Xe5v9, b_Xe5vb, c_Xe686)>_R
                 ->_R Data.Functor.Identity.N:Identity[0]
                          <(a_Xe5v9, b_Xe5vb, c_Xe686)>_R
                 :: ((forall b1. Data b1 => b1 -> b1)
                     -> (a_Xe5v9, b_Xe5vb, c_Xe686)
                     -> Identity (a_Xe5v9, b_Xe5vb, c_Xe686) :: *)
                    ~R# ((forall b1. Data b1 => b1 -> b1)
                         -> (a_Xe5v9, b_Xe5vb, c_Xe686)
                         -> (a_Xe5v9, b_Xe5vb, c_Xe686) :: *)))
        ((Data.Data.$fData(,,)2
            @ a_Xe5v9
            @ b_Xe5vb
            @ c_Xe686
            $dData_Xe689
            $dData1_Xe68c
            $dData2_Xe68f)
         `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                 <r -> r' -> r>_R
                 ->_R <r>_R
                 ->_R <forall d. Data d => d -> r'>_R
                 ->_R <(a_Xe5v9, b_Xe5vb, c_Xe686)>_R
                 ->_R Data.Functor.Const.N:Const[0]
                          <*>_N <r>_R <(a_Xe5v9, b_Xe5vb, c_Xe686)>_P
                 :: (forall r r'.
                     (r -> r' -> r)
                     -> r
                     -> (forall d. Data d => d -> r')
                     -> (a_Xe5v9, b_Xe5vb, c_Xe686)
                     -> Const r (a_Xe5v9, b_Xe5vb, c_Xe686) :: *)
                    ~R# (forall r r'.
                         (r -> r' -> r)
                         -> r
                         -> (forall d. Data d => d -> r')
                         -> (a_Xe5v9, b_Xe5vb, c_Xe686)
                         -> r :: *)))
        (Data.Data.$fData(,,)_$cgmapQr
           @ a_Xe5v9
           @ b_Xe5vb
           @ c_Xe686
           $dData_Xe689
           $dData1_Xe68c
           $dData2_Xe68f)
        (Data.Data.$fData(,,)_$cgmapQ
           @ a_Xe5v9
           @ b_Xe5vb
           @ c_Xe686
           $dData_Xe689
           $dData1_Xe68c
           $dData2_Xe68f)
        (Data.Data.$fData(,,)_$cgmapQi
           @ a_Xe5v9
           @ b_Xe5vb
           @ c_Xe686
           $dData_Xe689
           $dData1_Xe68c
           $dData2_Xe68f)
        (Data.Data.$fData(,,)_$cgmapM
           @ a_Xe5v9
           @ b_Xe5vb
           @ c_Xe686
           $dData_Xe689
           $dData1_Xe68c
           $dData2_Xe68f)
        (Data.Data.$fData(,,)_$cgmapMp
           @ a_Xe5v9
           @ b_Xe5vb
           @ c_Xe686
           $dData_Xe689
           $dData1_Xe68c
           $dData2_Xe68f)
        (Data.Data.$fData(,,)_$cgmapMo
           @ a_Xe5v9
           @ b_Xe5vb
           @ c_Xe686
           $dData_Xe689
           $dData1_Xe68c
           $dData2_Xe68f)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,)7 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fData(,,,)7 = "(,,,)"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,)6 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fData(,,,)6 = unpackCString# Data.Data.$fData(,,,)7

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go14_rejPT :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go14_rejPT
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fData(,,,)6 of {
                False -> go14_rejPT ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$c(,,,)1_rejPU :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$c(,,,)1_rejPU = Data.Data.AlgConstr $c(,,,)2_rejPV

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,)5 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData(,,,)5
  = GHC.Types.: @ Constr Data.Data.$c(,,,) (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,)4 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fData(,,,)4 = Data.Data.AlgRep Data.Data.$fData(,,,)5

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$t(,,,) :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$t(,,,)
  = Data.Data.DataType Data.Data.$fData(,,,)6 Data.Data.$fData(,,,)4

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$c(,,,) [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$c(,,,)
  = Data.Data.Constr
      $c(,,,)1_rejPU
      Data.Data.$fData(,,,)6
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$t(,,,)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$c(,,,)2_rejPV :: ConIndex
[GblId]
$c(,,,)2_rejPV
  = go14_rejPT Data.Data.$fData(,,,)5 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 7, types: 22, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,)1
  :: forall b a c d. (a -> b -> c -> d -> (a, b, c, d), Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData(,,,)1
  = \ (@ b_Xe5rT) (@ a_Xe5rR) (@ c_Xe5rV) (@ d_Xe5rX) ->
      (GHC.Tuple.(,,,) @ a_Xe5rR @ b_Xe5rT @ c_Xe5rV @ d_Xe5rX,
       GHC.Types.False)

-- RHS size: {terms: 85, types: 214, coercions: 46, joins: 0/4}
Data.Data.$fData(,,,)_$cgmapMp
  :: forall a b c d.
     (Data a, Data b, Data c, Data d) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d1. Data d1 => d1 -> m d1)
     -> (a, b, c, d) -> m (a, b, c, d)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 90 60 20] 720 0}]
Data.Data.$fData(,,,)_$cgmapMp
  = \ (@ a_Xe5rR)
      (@ b_Xe5rT)
      (@ c_Xe5rV)
      (@ d_Xe5rX)
      ($dData_Xe5rZ :: Data a_Xe5rR)
      ($dData1_Xe5s1 :: Data b_Xe5rT)
      ($dData2_Xe5s3 :: Data c_Xe5rV)
      ($dData3_Xe5s5 :: Data d_Xe5rX)
      (@ (m_ae4SB :: * -> *))
      ($dMonadPlus_ae4SD :: MonadPlus m_ae4SB)
      (ds_de7Ci :: forall d1. Data d1 => d1 -> m_ae4SB d1)
      (eta_XDa :: (a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX)) ->
      let {
        lvl270_se9IS :: m_ae4SB (a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX)
        [LclId]
        lvl270_se9IS
          = mzero
              @ m_ae4SB
              $dMonadPlus_ae4SD
              @ (a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX) } in
      let {
        $dMonad_se9sz [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae4SB
        [LclId]
        $dMonad_se9sz
          = GHC.Base.$p2MonadPlus @ m_ae4SB $dMonadPlus_ae4SD } in
      >>=
        @ m_ae4SB
        $dMonad_se9sz
        @ ((a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX), Bool)
        @ (a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX)
        (case eta_XDa of { (a1_ae2pX, a2_ae2pY, a3_ae2pZ, a4_ae2q0) ->
         let {
           k_se9sy [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
             :: forall d1 b1.
                Data d1 =>
                Mp m_ae4SB (d1 -> b1) -> d1 -> m_ae4SB (b1, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_se9sy
             = \ (@ d1_ae2Ws)
                 (@ b1_ae2Wt)
                 ($dData4_ae2Wv :: Data d1_ae2Ws)
                 (ds1_de7oC [OS=OneShot] :: Mp m_ae4SB (d1_ae2Ws -> b1_ae2Wt))
                 (y_ae1Tz [OS=OneShot] :: d1_ae2Ws) ->
                 let {
                   lvl271_se9IQ :: m_ae4SB d1_ae2Ws
                   [LclId]
                   lvl271_se9IQ = ds_de7Ci @ d1_ae2Ws $dData4_ae2Wv y_ae1Tz } in
                 >>=
                   @ m_ae4SB
                   $dMonad_se9sz
                   @ (d1_ae2Ws -> b1_ae2Wt, Bool)
                   @ (b1_ae2Wt, Bool)
                   (ds1_de7oC
                    `cast` (Data.Data.N:Mp[0] <m_ae4SB>_R <d1_ae2Ws -> b1_ae2Wt>_N
                            :: (Mp m_ae4SB (d1_ae2Ws -> b1_ae2Wt) :: *)
                               ~R# (m_ae4SB (d1_ae2Ws -> b1_ae2Wt, Bool) :: *)))
                   (\ (ds2_de7oD :: (d1_ae2Ws -> b1_ae2Wt, Bool)) ->
                      case ds2_de7oD of { (h_ae1TA, b2_ae1TB) ->
                      mplus
                        @ m_ae4SB
                        $dMonadPlus_ae4SD
                        @ (b1_ae2Wt, Bool)
                        (>>=
                           @ m_ae4SB
                           $dMonad_se9sz
                           @ d1_ae2Ws
                           @ (b1_ae2Wt, Bool)
                           lvl271_se9IQ
                           (\ (y'_ae1TC :: d1_ae2Ws) ->
                              return
                                @ m_ae4SB
                                $dMonad_se9sz
                                @ (b1_ae2Wt, Bool)
                                (h_ae1TA y'_ae1TC, GHC.Types.True)))
                        (return
                           @ m_ae4SB
                           $dMonad_se9sz
                           @ (b1_ae2Wt, Bool)
                           (h_ae1TA y_ae1Tz, b2_ae1TB))
                      }) } in
         k_se9sy
           @ d_Xe5rX
           @ (a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX)
           $dData3_Xe5s5
           ((k_se9sy
               @ c_Xe5rV
               @ (d_Xe5rX -> (a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX))
               $dData2_Xe5s3
               ((k_se9sy
                   @ b_Xe5rT
                   @ (c_Xe5rV -> d_Xe5rX -> (a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX))
                   $dData1_Xe5s1
                   ((k_se9sy
                       @ a_Xe5rR
                       @ (b_Xe5rT
                          -> c_Xe5rV -> d_Xe5rX -> (a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX))
                       $dData_Xe5rZ
                       ((return
                           @ m_ae4SB
                           $dMonad_se9sz
                           @ (a_Xe5rR
                              -> b_Xe5rT
                              -> c_Xe5rV
                              -> d_Xe5rX
                              -> (a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX),
                              Bool)
                           (Data.Data.$fData(,,,)1 @ b_Xe5rT @ a_Xe5rR @ c_Xe5rV @ d_Xe5rX))
                        `cast` (Sym (Data.Data.N:Mp[0]
                                         <m_ae4SB>_R
                                         <a_Xe5rR
                                          -> b_Xe5rT
                                          -> c_Xe5rV
                                          -> d_Xe5rX
                                          -> (a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX)>_N)
                                :: (m_ae4SB (a_Xe5rR
                                             -> b_Xe5rT
                                             -> c_Xe5rV
                                             -> d_Xe5rX
                                             -> (a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX),
                                             Bool) :: *)
                                   ~R# (Mp
                                          m_ae4SB
                                          (a_Xe5rR
                                           -> b_Xe5rT
                                           -> c_Xe5rV
                                           -> d_Xe5rX
                                           -> (a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX)) :: *)))
                       a1_ae2pX)
                    `cast` (Sym (Data.Data.N:Mp[0]
                                     <m_ae4SB>_R
                                     <b_Xe5rT
                                      -> c_Xe5rV
                                      -> d_Xe5rX
                                      -> (a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX)>_N)
                            :: (m_ae4SB (b_Xe5rT
                                         -> c_Xe5rV
                                         -> d_Xe5rX
                                         -> (a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX),
                                         Bool) :: *)
                               ~R# (Mp
                                      m_ae4SB
                                      (b_Xe5rT
                                       -> c_Xe5rV
                                       -> d_Xe5rX
                                       -> (a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX)) :: *)))
                   a2_ae2pY)
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_ae4SB>_R
                                 <c_Xe5rV -> d_Xe5rX -> (a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX)>_N)
                        :: (m_ae4SB (c_Xe5rV
                                     -> d_Xe5rX -> (a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX),
                                     Bool) :: *)
                           ~R# (Mp
                                  m_ae4SB
                                  (c_Xe5rV
                                   -> d_Xe5rX -> (a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX)) :: *)))
               a3_ae2pZ)
            `cast` (Sym (Data.Data.N:Mp[0]
                             <m_ae4SB>_R <d_Xe5rX -> (a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX)>_N)
                    :: (m_ae4SB (d_Xe5rX -> (a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX),
                                 Bool) :: *)
                       ~R# (Mp
                              m_ae4SB (d_Xe5rX -> (a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX)) :: *)))
           a4_ae2q0
         })
        (\ (ds1_de7oa :: ((a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX), Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b1_ae1TE) ->
           case b1_ae1TE of {
             False -> lvl270_se9IS;
             True ->
               return
                 @ m_ae4SB
                 $dMonad_se9sz
                 @ (a_Xe5rR, b_Xe5rT, c_Xe5rV, d_Xe5rX)
                 x'_ae1TD
           }
           })

-- RHS size: {terms: 52, types: 114, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapM2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (Data a, Data b, Data c, Data d) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d1. Data d1 => d1 -> m d1)
     -> a -> b -> c -> d -> m (a, b, c, d)
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 120 60 0 0 0 0] 420 0}]
Data.Data.$w$cgmapM2
  = \ (@ a_segdr)
      (@ b_segds)
      (@ c_segdt)
      (@ d_segdu)
      (w_segdv :: Data a_segdr)
      (w1_segdw :: Data b_segds)
      (w2_segdx :: Data c_segdt)
      (w3_segdy :: Data d_segdu)
      (@ (m_segdz :: * -> *))
      (w4_segdA :: Monad m_segdz)
      (w5_segdB :: forall d1. Data d1 => d1 -> m_segdz d1)
      (ww_segdF :: a_segdr)
      (ww1_segdG :: b_segds)
      (ww2_segdH :: c_segdt)
      (ww3_segdI :: d_segdu) ->
      let {
        k_se9sv [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
          :: forall d1 b1. Data d1 => m_segdz (d1 -> b1) -> d1 -> m_segdz b1
        [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
        k_se9sv
          = \ (@ d1_ae2Vh)
              (@ b1_ae2Vi)
              ($dData_ae2Vk :: Data d1_ae2Vh)
              (c1_ae1Tm [OS=OneShot] :: m_segdz (d1_ae2Vh -> b1_ae2Vi))
              (x_ae1Tn [OS=OneShot] :: d1_ae2Vh) ->
              let {
                lvl270_se9IT :: m_segdz d1_ae2Vh
                [LclId]
                lvl270_se9IT = w5_segdB @ d1_ae2Vh $dData_ae2Vk x_ae1Tn } in
              >>=
                @ m_segdz
                w4_segdA
                @ (d1_ae2Vh -> b1_ae2Vi)
                @ b1_ae2Vi
                c1_ae1Tm
                (\ (c'_ae1To :: d1_ae2Vh -> b1_ae2Vi) ->
                   >>=
                     @ m_segdz
                     w4_segdA
                     @ d1_ae2Vh
                     @ b1_ae2Vi
                     lvl270_se9IT
                     (\ (x'_ae1Tp :: d1_ae2Vh) ->
                        return @ m_segdz w4_segdA @ b1_ae2Vi (c'_ae1To x'_ae1Tp))) } in
      k_se9sv
        @ d_segdu
        @ (a_segdr, b_segds, c_segdt, d_segdu)
        w3_segdy
        (k_se9sv
           @ c_segdt
           @ (d_segdu -> (a_segdr, b_segds, c_segdt, d_segdu))
           w2_segdx
           (k_se9sv
              @ b_segds
              @ (c_segdt -> d_segdu -> (a_segdr, b_segds, c_segdt, d_segdu))
              w1_segdw
              (k_se9sv
                 @ a_segdr
                 @ (b_segds
                    -> c_segdt -> d_segdu -> (a_segdr, b_segds, c_segdt, d_segdu))
                 w_segdv
                 (return
                    @ m_segdz
                    w4_segdA
                    @ (a_segdr
                       -> b_segds
                       -> c_segdt
                       -> d_segdu
                       -> (a_segdr, b_segds, c_segdt, d_segdu))
                    (GHC.Tuple.(,,,) @ a_segdr @ b_segds @ c_segdt @ d_segdu))
                 ww_segdF)
              ww1_segdG)
           ww2_segdH)
        ww3_segdI

-- RHS size: {terms: 26, types: 48, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,)_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (Data a, Data b, Data c, Data d) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d1. Data d1 => d1 -> m d1)
     -> (a, b, c, d) -> m (a, b, c, d)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=7,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_segdr)
                 (@ b_segds)
                 (@ c_segdt)
                 (@ d_segdu)
                 (w_segdv [Occ=Once] :: Data a_segdr)
                 (w1_segdw [Occ=Once] :: Data b_segds)
                 (w2_segdx [Occ=Once] :: Data c_segdt)
                 (w3_segdy [Occ=Once] :: Data d_segdu)
                 (@ (m_segdz :: * -> *))
                 (w4_segdA [Occ=Once] :: Monad m_segdz)
                 (w5_segdB [Occ=Once] :: forall d1. Data d1 => d1 -> m_segdz d1)
                 (w6_segdC [Occ=Once!] :: (a_segdr, b_segds, c_segdt, d_segdu)) ->
                 case w6_segdC of
                 { (ww1_segdF [Occ=Once], ww2_segdG [Occ=Once],
                    ww3_segdH [Occ=Once], ww4_segdI [Occ=Once]) ->
                 Data.Data.$w$cgmapM2
                   @ a_segdr
                   @ b_segds
                   @ c_segdt
                   @ d_segdu
                   w_segdv
                   w1_segdw
                   w2_segdx
                   w3_segdy
                   @ m_segdz
                   w4_segdA
                   w5_segdB
                   ww1_segdF
                   ww2_segdG
                   ww3_segdH
                   ww4_segdI
                 }}]
Data.Data.$fData(,,,)_$cgmapM
  = \ (@ a_segdr)
      (@ b_segds)
      (@ c_segdt)
      (@ d_segdu)
      (w_segdv :: Data a_segdr)
      (w1_segdw :: Data b_segds)
      (w2_segdx :: Data c_segdt)
      (w3_segdy :: Data d_segdu)
      (@ (m_segdz :: * -> *))
      (w4_segdA :: Monad m_segdz)
      (w5_segdB :: forall d1. Data d1 => d1 -> m_segdz d1)
      (w6_segdC :: (a_segdr, b_segds, c_segdt, d_segdu)) ->
      case w6_segdC of { (ww1_segdF, ww2_segdG, ww3_segdH, ww4_segdI) ->
      Data.Data.$w$cgmapM2
        @ a_segdr
        @ b_segds
        @ c_segdt
        @ d_segdu
        w_segdv
        w1_segdw
        w2_segdx
        w3_segdy
        @ m_segdz
        w4_segdA
        w5_segdB
        ww1_segdF
        ww2_segdG
        ww3_segdH
        ww4_segdI
      }

-- RHS size: {terms: 35, types: 35, coercions: 0, joins: 0/0}
Data.Data.$w$cgmapQi1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (Data a, Data b, Data c, Data d) =>
     forall u.
     Int# -> (forall d1. Data d1 => d1 -> u) -> a -> b -> c -> d -> u
[GblId,
 Arity=10,
 Str=<L,U><L,U><L,U><L,U><S,1*U><C(C(S)),1*C1(C1(U))><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 150 240 0 0 0 0] 170 0}]
Data.Data.$w$cgmapQi1
  = \ (@ a_segdL)
      (@ b_segdM)
      (@ c_segdN)
      (@ d_segdO)
      (w_segdP :: Data a_segdL)
      (w1_segdQ :: Data b_segdM)
      (w2_segdR :: Data c_segdN)
      (w3_segdS :: Data d_segdO)
      (@ u_segdT)
      (ww_segdZ :: Int#)
      (w4_segdV :: forall d1. Data d1 => d1 -> u_segdT)
      (ww1_sege3 :: a_segdL)
      (ww2_sege4 :: b_segdM)
      (ww3_sege5 :: c_segdN)
      (ww4_sege6 :: d_segdO) ->
      case ww_segdZ of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_segdT;
        0# -> w4_segdV @ a_segdL w_segdP ww1_sege3;
        1# -> w4_segdV @ b_segdM w1_segdQ ww2_sege4;
        2# -> w4_segdV @ c_segdN w2_segdR ww3_sege5;
        3# -> w4_segdV @ d_segdO w3_segdS ww4_sege6
      }

-- RHS size: {terms: 29, types: 46, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,)_$cgmapQi [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (Data a, Data b, Data c, Data d) =>
     forall u.
     Int -> (forall d1. Data d1 => d1 -> u) -> (a, b, c, d) -> u
[GblId,
 Arity=7,
 Str=<L,U><L,U><L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=7,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_segdL)
                 (@ b_segdM)
                 (@ c_segdN)
                 (@ d_segdO)
                 (w_segdP [Occ=Once] :: Data a_segdL)
                 (w1_segdQ [Occ=Once] :: Data b_segdM)
                 (w2_segdR [Occ=Once] :: Data c_segdN)
                 (w3_segdS [Occ=Once] :: Data d_segdO)
                 (@ u_segdT)
                 (w4_segdU [Occ=Once!] :: Int)
                 (w5_segdV [Occ=Once] :: forall d1. Data d1 => d1 -> u_segdT)
                 (w6_segdW [Occ=Once!] :: (a_segdL, b_segdM, c_segdN, d_segdO)) ->
                 case w4_segdU of { I# ww1_segdZ [Occ=Once] ->
                 case w6_segdW of
                 { (ww3_sege3 [Occ=Once], ww4_sege4 [Occ=Once],
                    ww5_sege5 [Occ=Once], ww6_sege6 [Occ=Once]) ->
                 Data.Data.$w$cgmapQi1
                   @ a_segdL
                   @ b_segdM
                   @ c_segdN
                   @ d_segdO
                   w_segdP
                   w1_segdQ
                   w2_segdR
                   w3_segdS
                   @ u_segdT
                   ww1_segdZ
                   w5_segdV
                   ww3_sege3
                   ww4_sege4
                   ww5_sege5
                   ww6_sege6
                 }
                 }}]
Data.Data.$fData(,,,)_$cgmapQi
  = \ (@ a_segdL)
      (@ b_segdM)
      (@ c_segdN)
      (@ d_segdO)
      (w_segdP :: Data a_segdL)
      (w1_segdQ :: Data b_segdM)
      (w2_segdR :: Data c_segdN)
      (w3_segdS :: Data d_segdO)
      (@ u_segdT)
      (w4_segdU :: Int)
      (w5_segdV :: forall d1. Data d1 => d1 -> u_segdT)
      (w6_segdW :: (a_segdL, b_segdM, c_segdN, d_segdO)) ->
      case w4_segdU of { I# ww1_segdZ ->
      case w6_segdW of { (ww3_sege3, ww4_sege4, ww5_sege5, ww6_sege6) ->
      Data.Data.$w$cgmapQi1
        @ a_segdL
        @ b_segdM
        @ c_segdN
        @ d_segdO
        w_segdP
        w1_segdQ
        w2_segdR
        w3_segdS
        @ u_segdT
        ww1_segdZ
        w5_segdV
        ww3_sege3
        ww4_sege4
        ww5_sege5
        ww6_sege6
      }
      }

-- RHS size: {terms: 34, types: 48, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,)_$cgmapQr
  :: forall a b c d.
     (Data a, Data b, Data c, Data d) =>
     forall r r'.
     (r' -> r -> r)
     -> r -> (forall d1. Data d1 => d1 -> r') -> (a, b, c, d) -> r
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 60 0 240 20] 250 0}]
Data.Data.$fData(,,,)_$cgmapQr
  = \ (@ a_Xe5rN)
      (@ b_Xe5rP)
      (@ c_Xe5rR)
      (@ d_Xe5rT)
      ($dData_Xe5rV :: Data a_Xe5rN)
      ($dData1_Xe5rX :: Data b_Xe5rP)
      ($dData2_Xe5rZ :: Data c_Xe5rR)
      ($dData3_Xe5s1 :: Data d_Xe5rT)
      (@ r_ae4RC)
      (@ r'_ae4RD)
      (ds_de7Cb :: r'_ae4RD -> r_ae4RC -> r_ae4RC)
      (ds1_de7Cc :: r_ae4RC)
      (ds2_de7Cd :: forall d1. Data d1 => d1 -> r'_ae4RD)
      (x0_ae1SX :: (a_Xe5rN, b_Xe5rP, c_Xe5rR, d_Xe5rT)) ->
      case x0_ae1SX of { (a1_ae2pX, a2_ae2pY, a3_ae2pZ, a4_ae2q0) ->
      ds_de7Cb
        (ds2_de7Cd @ a_Xe5rN $dData_Xe5rV a1_ae2pX)
        (ds_de7Cb
           (ds2_de7Cd @ b_Xe5rP $dData1_Xe5rX a2_ae2pY)
           (ds_de7Cb
              (ds2_de7Cd @ c_Xe5rR $dData2_Xe5rZ a3_ae2pZ)
              (ds_de7Cb (ds2_de7Cd @ d_Xe5rT $dData3_Xe5s1 a4_ae2q0) ds1_de7Cc)))
      }

-- RHS size: {terms: 18, types: 33, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,)_$cgmapQ
  :: forall a b c d.
     (Data a, Data b, Data c, Data d) =>
     forall u. (forall d1. Data d1 => d1 -> u) -> (a, b, c, d) -> [u]
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,C(C1(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe5rO)
                 (@ b_Xe5rQ)
                 (@ c_Xe5rS)
                 (@ d_Xe5rU)
                 ($dData_Xe5rW [Occ=Once] :: Data a_Xe5rO)
                 ($dData1_Xe5rY [Occ=Once] :: Data b_Xe5rQ)
                 ($dData2_Xe5s0 [Occ=Once] :: Data c_Xe5rS)
                 ($dData3_Xe5s2 [Occ=Once] :: Data d_Xe5rU)
                 (@ u_ae4RT)
                 (ds_de7Ce [Occ=Once] :: forall d1. Data d1 => d1 -> u_ae4RT) ->
                 Data.Data.$fData(,,,)_$cgmapQr
                   @ a_Xe5rO
                   @ b_Xe5rQ
                   @ c_Xe5rS
                   @ d_Xe5rU
                   $dData_Xe5rW
                   $dData1_Xe5rY
                   $dData2_Xe5s0
                   $dData3_Xe5s2
                   @ [u_ae4RT]
                   @ u_ae4RT
                   (GHC.Types.: @ u_ae4RT)
                   (GHC.Types.[] @ u_ae4RT)
                   ds_de7Ce}]
Data.Data.$fData(,,,)_$cgmapQ
  = \ (@ a_Xe5rO)
      (@ b_Xe5rQ)
      (@ c_Xe5rS)
      (@ d_Xe5rU)
      ($dData_Xe5rW :: Data a_Xe5rO)
      ($dData1_Xe5rY :: Data b_Xe5rQ)
      ($dData2_Xe5s0 :: Data c_Xe5rS)
      ($dData3_Xe5s2 :: Data d_Xe5rU)
      (@ u_ae4RT)
      (ds_de7Ce :: forall d1. Data d1 => d1 -> u_ae4RT) ->
      Data.Data.$fData(,,,)_$cgmapQr
        @ a_Xe5rO
        @ b_Xe5rQ
        @ c_Xe5rS
        @ d_Xe5rU
        $dData_Xe5rW
        $dData1_Xe5rY
        $dData2_Xe5s0
        $dData3_Xe5s2
        @ [u_ae4RT]
        @ u_ae4RT
        (GHC.Types.: @ u_ae4RT)
        (GHC.Types.[] @ u_ae4RT)
        ds_de7Ce

-- RHS size: {terms: 34, types: 48, coercions: 10, joins: 0/0}
Data.Data.$fData(,,,)2
  :: forall a b c d.
     (Data a, Data b, Data c, Data d) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d1. Data d1 => d1 -> r')
     -> (a, b, c, d)
     -> Const r (a, b, c, d)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 60 0 240 20] 250 0}]
Data.Data.$fData(,,,)2
  = \ (@ a_Xe5rM)
      (@ b_Xe5rO)
      (@ c_Xe5rQ)
      (@ d_Xe5rS)
      ($dData_Xe5rU :: Data a_Xe5rM)
      ($dData1_Xe5rW :: Data b_Xe5rO)
      ($dData2_Xe5rY :: Data c_Xe5rQ)
      ($dData3_Xe5s0 :: Data d_Xe5rS)
      (@ r_ae4Rl)
      (@ r'_ae4Rm)
      (ds_de7C8 :: r_ae4Rl -> r'_ae4Rm -> r_ae4Rl)
      (ds1_de7C9 :: r_ae4Rl)
      (ds2_de7Ca :: forall d1. Data d1 => d1 -> r'_ae4Rm)
      (eta_XDh :: (a_Xe5rM, b_Xe5rO, c_Xe5rQ, d_Xe5rS)) ->
      case eta_XDh of { (a1_ae2pX, a2_ae2pY, a3_ae2pZ, a4_ae2q0) ->
      (ds_de7C8
         (ds_de7C8
            (ds_de7C8
               (ds_de7C8 ds1_de7C9 (ds2_de7Ca @ a_Xe5rM $dData_Xe5rU a1_ae2pX))
               (ds2_de7Ca @ b_Xe5rO $dData1_Xe5rW a2_ae2pY))
            (ds2_de7Ca @ c_Xe5rQ $dData2_Xe5rY a3_ae2pZ))
         (ds2_de7Ca @ d_Xe5rS $dData3_Xe5s0 a4_ae2q0))
      `cast` (Sym (Data.Functor.Const.N:Const[0]
                       <*>_N <r_ae4Rl>_R <(a_Xe5rM, b_Xe5rO, c_Xe5rQ, d_Xe5rS)>_P)
              :: (r_ae4Rl :: *)
                 ~R# (Const r_ae4Rl (a_Xe5rM, b_Xe5rO, c_Xe5rQ, d_Xe5rS) :: *))
      }

-- RHS size: {terms: 26, types: 44, coercions: 7, joins: 0/0}
Data.Data.$fData(,,,)3 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (Data a, Data b, Data c, Data d) =>
     (forall b1. Data b1 => b1 -> b1)
     -> (a, b, c, d) -> Identity (a, b, c, d)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,C(C1(U))><S,1*U(U,U,U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_segeP)
                 (@ b_segeQ)
                 (@ c_segeR)
                 (@ d_segeS)
                 (w_segeT [Occ=Once] :: Data a_segeP)
                 (w1_segeU [Occ=Once] :: Data b_segeQ)
                 (w2_segeV [Occ=Once] :: Data c_segeR)
                 (w3_segeW [Occ=Once] :: Data d_segeS)
                 (w4_segeX :: forall b1. Data b1 => b1 -> b1)
                 (w5_segeY [Occ=Once!] :: (a_segeP, b_segeQ, c_segeR, d_segeS)) ->
                 case w5_segeY of
                 { (ww1_segf1 [Occ=Once], ww2_segf2 [Occ=Once],
                    ww3_segf3 [Occ=Once], ww4_segf4 [Occ=Once]) ->
                 (w4_segeX @ a_segeP w_segeT ww1_segf1,
                  w4_segeX @ b_segeQ w1_segeU ww2_segf2,
                  w4_segeX @ c_segeR w2_segeV ww3_segf3,
                  w4_segeX @ d_segeS w3_segeW ww4_segf4)
                 `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                                  <(a_segeP, b_segeQ, c_segeR, d_segeS)>_R)
                         :: ((a_segeP, b_segeQ, c_segeR, d_segeS) :: *)
                            ~R# (Identity (a_segeP, b_segeQ, c_segeR, d_segeS) :: *))
                 }}]
Data.Data.$fData(,,,)3
  = \ (@ a_segeP)
      (@ b_segeQ)
      (@ c_segeR)
      (@ d_segeS)
      (w_segeT :: Data a_segeP)
      (w1_segeU :: Data b_segeQ)
      (w2_segeV :: Data c_segeR)
      (w3_segeW :: Data d_segeS)
      (w4_segeX :: forall b1. Data b1 => b1 -> b1)
      (w5_segeY :: (a_segeP, b_segeQ, c_segeR, d_segeS)) ->
      case w5_segeY of { (ww1_segf1, ww2_segf2, ww3_segf3, ww4_segf4) ->
      (w4_segeX @ a_segeP w_segeT ww1_segf1,
       w4_segeX @ b_segeQ w1_segeU ww2_segf2,
       w4_segeX @ c_segeR w2_segeV ww3_segf3,
       w4_segeX @ d_segeS w3_segeW ww4_segf4)
      `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                       <(a_segeP, b_segeQ, c_segeR, d_segeS)>_R)
              :: ((a_segeP, b_segeQ, c_segeR, d_segeS) :: *)
                 ~R# (Identity (a_segeP, b_segeQ, c_segeR, d_segeS) :: *))
      }

-- RHS size: {terms: 95, types: 221, coercions: 46, joins: 0/4}
Data.Data.$fData(,,,)_$cgmapMo
  :: forall a b c d.
     (Data a, Data b, Data c, Data d) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d1. Data d1 => d1 -> m d1)
     -> (a, b, c, d) -> m (a, b, c, d)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U,U,U)>,
 Unf=OtherCon []]
Data.Data.$fData(,,,)_$cgmapMo
  = \ (@ a_Xe5rJ)
      (@ b_Xe65g)
      (@ c_Xe65j)
      (@ d_Xe65m)
      ($dData_Xe65p :: Data a_Xe5rJ)
      ($dData1_Xe65s :: Data b_Xe65g)
      ($dData2_Xe65v :: Data c_Xe65j)
      ($dData3_Xe65y :: Data d_Xe65m)
      (@ (m_ae4SR :: * -> *))
      ($dMonadPlus_ae4ST :: MonadPlus m_ae4SR)
      (ds_de7Cj :: forall d1. Data d1 => d1 -> m_ae4SR d1)
      (eta_XDG :: (a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m)) ->
      let {
        lvl270_se9IY :: m_ae4SR (a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m)
        [LclId]
        lvl270_se9IY
          = mzero
              @ m_ae4SR
              $dMonadPlus_ae4ST
              @ (a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m) } in
      let {
        $dMonad_se9sr [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae4SR
        [LclId]
        $dMonad_se9sr
          = GHC.Base.$p2MonadPlus @ m_ae4SR $dMonadPlus_ae4ST } in
      >>=
        @ m_ae4SR
        $dMonad_se9sr
        @ ((a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m), Bool)
        @ (a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m)
        (case eta_XDG of { (a1_ae2pX, a2_ae2pY, a3_ae2pZ, a4_ae2q0) ->
         let {
           k_se9sq [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
             :: forall d1 b1.
                Data d1 =>
                Mp m_ae4SR (d1 -> b1) -> d1 -> m_ae4SR (b1, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_se9sq
             = \ (@ d1_ae2Ya)
                 (@ b1_ae2Yb)
                 ($dData4_ae2Yd :: Data d1_ae2Ya)
                 (ds1_de7pC [OS=OneShot] :: Mp m_ae4SR (d1_ae2Ya -> b1_ae2Yb))
                 (y_ae1TO [OS=OneShot] :: d1_ae2Ya) ->
                 let {
                   lvl271_se9IW :: m_ae4SR d1_ae2Ya
                   [LclId]
                   lvl271_se9IW = ds_de7Cj @ d1_ae2Ya $dData4_ae2Yd y_ae1TO } in
                 >>=
                   @ m_ae4SR
                   $dMonad_se9sr
                   @ (d1_ae2Ya -> b1_ae2Yb, Bool)
                   @ (b1_ae2Yb, Bool)
                   (ds1_de7pC
                    `cast` (Data.Data.N:Mp[0] <m_ae4SR>_R <d1_ae2Ya -> b1_ae2Yb>_N
                            :: (Mp m_ae4SR (d1_ae2Ya -> b1_ae2Yb) :: *)
                               ~R# (m_ae4SR (d1_ae2Ya -> b1_ae2Yb, Bool) :: *)))
                   (\ (ds2_de7pD :: (d1_ae2Ya -> b1_ae2Yb, Bool)) ->
                      case ds2_de7pD of { (h_ae1TP, b2_ae1TQ) ->
                      case b2_ae1TQ of {
                        False ->
                          mplus
                            @ m_ae4SR
                            $dMonadPlus_ae4ST
                            @ (b1_ae2Yb, Bool)
                            (>>=
                               @ m_ae4SR
                               $dMonad_se9sr
                               @ d1_ae2Ya
                               @ (b1_ae2Yb, Bool)
                               lvl271_se9IW
                               (\ (y'_ae1TR :: d1_ae2Ya) ->
                                  return
                                    @ m_ae4SR
                                    $dMonad_se9sr
                                    @ (b1_ae2Yb, Bool)
                                    (h_ae1TP y'_ae1TR, GHC.Types.True)))
                            (return
                               @ m_ae4SR
                               $dMonad_se9sr
                               @ (b1_ae2Yb, Bool)
                               (h_ae1TP y_ae1TO, GHC.Types.False));
                        True ->
                          return
                            @ m_ae4SR
                            $dMonad_se9sr
                            @ (b1_ae2Yb, Bool)
                            (h_ae1TP y_ae1TO, GHC.Types.True)
                      }
                      }) } in
         k_se9sq
           @ d_Xe65m
           @ (a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m)
           $dData3_Xe65y
           ((k_se9sq
               @ c_Xe65j
               @ (d_Xe65m -> (a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m))
               $dData2_Xe65v
               ((k_se9sq
                   @ b_Xe65g
                   @ (c_Xe65j -> d_Xe65m -> (a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m))
                   $dData1_Xe65s
                   ((k_se9sq
                       @ a_Xe5rJ
                       @ (b_Xe65g
                          -> c_Xe65j -> d_Xe65m -> (a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m))
                       $dData_Xe65p
                       ((return
                           @ m_ae4SR
                           $dMonad_se9sr
                           @ (a_Xe5rJ
                              -> b_Xe65g
                              -> c_Xe65j
                              -> d_Xe65m
                              -> (a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m),
                              Bool)
                           (Data.Data.$fData(,,,)1 @ b_Xe65g @ a_Xe5rJ @ c_Xe65j @ d_Xe65m))
                        `cast` (Sym (Data.Data.N:Mp[0]
                                         <m_ae4SR>_R
                                         <a_Xe5rJ
                                          -> b_Xe65g
                                          -> c_Xe65j
                                          -> d_Xe65m
                                          -> (a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m)>_N)
                                :: (m_ae4SR (a_Xe5rJ
                                             -> b_Xe65g
                                             -> c_Xe65j
                                             -> d_Xe65m
                                             -> (a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m),
                                             Bool) :: *)
                                   ~R# (Mp
                                          m_ae4SR
                                          (a_Xe5rJ
                                           -> b_Xe65g
                                           -> c_Xe65j
                                           -> d_Xe65m
                                           -> (a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m)) :: *)))
                       a1_ae2pX)
                    `cast` (Sym (Data.Data.N:Mp[0]
                                     <m_ae4SR>_R
                                     <b_Xe65g
                                      -> c_Xe65j
                                      -> d_Xe65m
                                      -> (a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m)>_N)
                            :: (m_ae4SR (b_Xe65g
                                         -> c_Xe65j
                                         -> d_Xe65m
                                         -> (a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m),
                                         Bool) :: *)
                               ~R# (Mp
                                      m_ae4SR
                                      (b_Xe65g
                                       -> c_Xe65j
                                       -> d_Xe65m
                                       -> (a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m)) :: *)))
                   a2_ae2pY)
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_ae4SR>_R
                                 <c_Xe65j -> d_Xe65m -> (a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m)>_N)
                        :: (m_ae4SR (c_Xe65j
                                     -> d_Xe65m -> (a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m),
                                     Bool) :: *)
                           ~R# (Mp
                                  m_ae4SR
                                  (c_Xe65j
                                   -> d_Xe65m -> (a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m)) :: *)))
               a3_ae2pZ)
            `cast` (Sym (Data.Data.N:Mp[0]
                             <m_ae4SR>_R <d_Xe65m -> (a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m)>_N)
                    :: (m_ae4SR (d_Xe65m -> (a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m),
                                 Bool) :: *)
                       ~R# (Mp
                              m_ae4SR (d_Xe65m -> (a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m)) :: *)))
           a4_ae2q0
         })
        (\ (ds1_de7pa :: ((a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m), Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b1_ae1TT) ->
           case b1_ae1TT of {
             False -> lvl270_se9IY;
             True ->
               return
                 @ m_ae4SR
                 $dMonad_se9sr
                 @ (a_Xe5rJ, b_Xe65g, c_Xe65j, d_Xe65m)
                 x'_ae1TS
           }
           })

-- RHS size: {terms: 9, types: 22, coercions: 0, joins: 0/0}
lvl111_rejPW :: forall d c b a. (a, b, c, d) -> Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []]
lvl111_rejPW
  = \ (@ d_Xe65m)
      (@ c_Xe65j)
      (@ b_Xe5rK)
      (@ a_Xe5rI)
      (ds_de7BZ :: (a_Xe5rI, b_Xe5rK, c_Xe65j, d_Xe65m)) ->
      case ds_de7BZ of { (ds1_de7C0, ds2_de7C1, ds3_de7C2, ds4_de7C3) ->
      Data.Data.$c(,,,)
      }

-- RHS size: {terms: 6, types: 13, coercions: 0, joins: 0/0}
lvl112_rejPX :: forall a b c d. (a, b, c, d) -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl112_rejPX
  = \ (@ a_Xe5rI) (@ b_Xe5rK) (@ c_Xe65j) (@ d_Xe65m) _ [Occ=Dead] ->
      Data.Data.$t(,,,)

-- RHS size: {terms: 9, types: 35, coercions: 0, joins: 0/0}
lvl113_rejPY
  :: forall a b c1 d (t :: * -> *) (c2 :: * -> *).
     Typeable t =>
     (forall d1. Data d1 => c2 (t d1)) -> Maybe (c2 (a, b, c1, d))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl113_rejPY
  = \ (@ a_Xe5rI)
      (@ b_Xe5rK)
      (@ c_Xe65j)
      (@ d_Xe65m)
      (@ (t_ae4Qu :: * -> *))
      (@ (c1_ae4Qv :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c1_ae4Qv (a_Xe5rI, b_Xe5rK, c_Xe65j, d_Xe65m))

-- RHS size: {terms: 9, types: 44, coercions: 0, joins: 0/0}
lvl114_rejPZ
  :: forall a b c1 d (t :: * -> * -> *) (c2 :: * -> *).
     Typeable t =>
     (forall d1 e. (Data d1, Data e) => c2 (t d1 e))
     -> Maybe (c2 (a, b, c1, d))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl114_rejPZ
  = \ (@ a_Xe5rI)
      (@ b_Xe5rK)
      (@ c_Xe65j)
      (@ d_Xe65m)
      (@ (t_ae4QN :: * -> * -> *))
      (@ (c1_ae4QO :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c1_ae4QO (a_Xe5rI, b_Xe5rK, c_Xe65j, d_Xe65m))

-- RHS size: {terms: 68, types: 81, coercions: 62, joins: 0/0}
Data.Data.$fData(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d.
     (Data a, Data b, Data c, Data d) =>
     Data (a, b, c, d)
[GblId[DFunId],
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_ae1XN)
             (@ b_ae1XO)
             (@ c_ae1XP)
             (@ d_ae1XQ)
             (v_XDA :: Data a_ae1XN)
             (v1_XDC :: Data b_ae1XO)
             (v2_XDE :: Data c_ae1XP)
             (v3_XDG :: Data d_ae1XQ) ->
       Data.Data.C:Data TYPE: (a_ae1XN, b_ae1XO, c_ae1XP, d_ae1XQ)
                        (Data.Data.$fData(,,,)8
                           @ a_ae1XN @ b_ae1XO @ c_ae1XP @ d_ae1XQ v_XDA v1_XDC v2_XDE v3_XDG)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <(a_ae1XN,
                                                                                   b_ae1XO, c_ae1XP,
                                                                                   d_ae1XQ)>_N
                                :: (Data.Typeable.Internal.TypeRep
                                      (a_ae1XN, b_ae1XO, c_ae1XP, d_ae1XQ) :: *)
                                   ~R# (Typeable
                                          (a_ae1XN, b_ae1XO, c_ae1XP, d_ae1XQ) :: Constraint))
                        Data.Data.$fData(,,,)_$cgfoldl
                          @ a_ae1XN @ b_ae1XO @ c_ae1XP @ d_ae1XQ v_XDA v1_XDC v2_XDE v3_XDG
                        Data.Data.$fData(,,,)_$cgunfold
                          @ a_ae1XN @ b_ae1XO @ c_ae1XP @ d_ae1XQ v_XDA v1_XDC v2_XDE v3_XDG
                        \ (ds_de7BZ [Occ=Once!] :: (a_ae1XN, b_ae1XO, c_ae1XP, d_ae1XQ)) ->
                          case ds_de7BZ of
                          { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
                          Data.Data.$c(,,,)
                          }
                        \ _ [Occ=Dead] -> Data.Data.$t(,,,)
                        \ (@ (t_ae4Qu :: * -> *))
                          (@ (c1_ae4Qv :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c1_ae4Qv (a_ae1XN, b_ae1XO, c_ae1XP, d_ae1XQ))
                        \ (@ (t_ae4QN :: * -> * -> *))
                          (@ (c1_ae4QO :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c1_ae4QO (a_ae1XN, b_ae1XO, c_ae1XP, d_ae1XQ))
                        (Data.Data.$fData(,,,)3
                           @ a_ae1XN @ b_ae1XO @ c_ae1XP @ d_ae1XQ v_XDA v1_XDC v2_XDE v3_XDG)
                        `cast` (<forall b1. Data b1 => b1 -> b1>_R
                                ->_R <(a_ae1XN, b_ae1XO, c_ae1XP, d_ae1XQ)>_R
                                ->_R Data.Functor.Identity.N:Identity[0]
                                         <(a_ae1XN, b_ae1XO, c_ae1XP, d_ae1XQ)>_R
                                :: ((forall b1. Data b1 => b1 -> b1)
                                    -> (a_ae1XN, b_ae1XO, c_ae1XP, d_ae1XQ)
                                    -> Identity (a_ae1XN, b_ae1XO, c_ae1XP, d_ae1XQ) :: *)
                                   ~R# ((forall b1. Data b1 => b1 -> b1)
                                        -> (a_ae1XN, b_ae1XO, c_ae1XP, d_ae1XQ)
                                        -> (a_ae1XN, b_ae1XO, c_ae1XP, d_ae1XQ) :: *))
                        (Data.Data.$fData(,,,)2
                           @ a_ae1XN @ b_ae1XO @ c_ae1XP @ d_ae1XQ v_XDA v1_XDC v2_XDE v3_XDG)
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d1. Data d1 => d1 -> r'>_R
                                ->_R <(a_ae1XN, b_ae1XO, c_ae1XP, d_ae1XQ)>_R
                                ->_R Data.Functor.Const.N:Const[0]
                                         <*>_N <r>_R <(a_ae1XN, b_ae1XO, c_ae1XP, d_ae1XQ)>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d1. Data d1 => d1 -> r')
                                    -> (a_ae1XN, b_ae1XO, c_ae1XP, d_ae1XQ)
                                    -> Const r (a_ae1XN, b_ae1XO, c_ae1XP, d_ae1XQ) :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d1. Data d1 => d1 -> r')
                                        -> (a_ae1XN, b_ae1XO, c_ae1XP, d_ae1XQ)
                                        -> r :: *))
                        Data.Data.$fData(,,,)_$cgmapQr
                          @ a_ae1XN @ b_ae1XO @ c_ae1XP @ d_ae1XQ v_XDA v1_XDC v2_XDE v3_XDG
                        Data.Data.$fData(,,,)_$cgmapQ
                          @ a_ae1XN @ b_ae1XO @ c_ae1XP @ d_ae1XQ v_XDA v1_XDC v2_XDE v3_XDG
                        Data.Data.$fData(,,,)_$cgmapQi
                          @ a_ae1XN @ b_ae1XO @ c_ae1XP @ d_ae1XQ v_XDA v1_XDC v2_XDE v3_XDG
                        Data.Data.$fData(,,,)_$cgmapM
                          @ a_ae1XN @ b_ae1XO @ c_ae1XP @ d_ae1XQ v_XDA v1_XDC v2_XDE v3_XDG
                        Data.Data.$fData(,,,)_$cgmapMp
                          @ a_ae1XN @ b_ae1XO @ c_ae1XP @ d_ae1XQ v_XDA v1_XDC v2_XDE v3_XDG
                        Data.Data.$fData(,,,)_$cgmapMo
                          @ a_ae1XN @ b_ae1XO @ c_ae1XP @ d_ae1XQ v_XDA v1_XDC v2_XDE v3_XDG]
Data.Data.$fData(,,,)
  = \ (@ a_Xe5rI)
      (@ b_Xe5rK)
      (@ c_Xe65j)
      (@ d_Xe65m)
      ($dData_Xe65p :: Data a_Xe5rI)
      ($dData1_Xe65s :: Data b_Xe5rK)
      ($dData2_Xe65v :: Data c_Xe65j)
      ($dData3_Xe65y :: Data d_Xe65m) ->
      Data.Data.C:Data
        @ (a_Xe5rI, b_Xe5rK, c_Xe65j, d_Xe65m)
        ((Data.Data.$fData(,,,)8
            @ a_Xe5rI
            @ b_Xe5rK
            @ c_Xe65j
            @ d_Xe65m
            $dData_Xe65p
            $dData1_Xe65s
            $dData2_Xe65v
            $dData3_Xe65y)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <(a_Xe5rI,
                                                                    b_Xe5rK, c_Xe65j, d_Xe65m)>_N
                 :: (Data.Typeable.Internal.TypeRep
                       (a_Xe5rI, b_Xe5rK, c_Xe65j, d_Xe65m) :: *)
                    ~R# (Typeable (a_Xe5rI, b_Xe5rK, c_Xe65j, d_Xe65m) :: Constraint)))
        (Data.Data.$fData(,,,)_$cgfoldl
           @ a_Xe5rI
           @ b_Xe5rK
           @ c_Xe65j
           @ d_Xe65m
           $dData_Xe65p
           $dData1_Xe65s
           $dData2_Xe65v
           $dData3_Xe65y)
        (Data.Data.$fData(,,,)_$cgunfold
           @ a_Xe5rI
           @ b_Xe5rK
           @ c_Xe65j
           @ d_Xe65m
           $dData_Xe65p
           $dData1_Xe65s
           $dData2_Xe65v
           $dData3_Xe65y)
        (lvl111_rejPW @ d_Xe65m @ c_Xe65j @ b_Xe5rK @ a_Xe5rI)
        (lvl112_rejPX @ a_Xe5rI @ b_Xe5rK @ c_Xe65j @ d_Xe65m)
        (lvl113_rejPY @ a_Xe5rI @ b_Xe5rK @ c_Xe65j @ d_Xe65m)
        (lvl114_rejPZ @ a_Xe5rI @ b_Xe5rK @ c_Xe65j @ d_Xe65m)
        ((Data.Data.$fData(,,,)3
            @ a_Xe5rI
            @ b_Xe5rK
            @ c_Xe65j
            @ d_Xe65m
            $dData_Xe65p
            $dData1_Xe65s
            $dData2_Xe65v
            $dData3_Xe65y)
         `cast` (<forall b1. Data b1 => b1 -> b1>_R
                 ->_R <(a_Xe5rI, b_Xe5rK, c_Xe65j, d_Xe65m)>_R
                 ->_R Data.Functor.Identity.N:Identity[0]
                          <(a_Xe5rI, b_Xe5rK, c_Xe65j, d_Xe65m)>_R
                 :: ((forall b1. Data b1 => b1 -> b1)
                     -> (a_Xe5rI, b_Xe5rK, c_Xe65j, d_Xe65m)
                     -> Identity (a_Xe5rI, b_Xe5rK, c_Xe65j, d_Xe65m) :: *)
                    ~R# ((forall b1. Data b1 => b1 -> b1)
                         -> (a_Xe5rI, b_Xe5rK, c_Xe65j, d_Xe65m)
                         -> (a_Xe5rI, b_Xe5rK, c_Xe65j, d_Xe65m) :: *)))
        ((Data.Data.$fData(,,,)2
            @ a_Xe5rI
            @ b_Xe5rK
            @ c_Xe65j
            @ d_Xe65m
            $dData_Xe65p
            $dData1_Xe65s
            $dData2_Xe65v
            $dData3_Xe65y)
         `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                 <r -> r' -> r>_R
                 ->_R <r>_R
                 ->_R <forall d1. Data d1 => d1 -> r'>_R
                 ->_R <(a_Xe5rI, b_Xe5rK, c_Xe65j, d_Xe65m)>_R
                 ->_R Data.Functor.Const.N:Const[0]
                          <*>_N <r>_R <(a_Xe5rI, b_Xe5rK, c_Xe65j, d_Xe65m)>_P
                 :: (forall r r'.
                     (r -> r' -> r)
                     -> r
                     -> (forall d1. Data d1 => d1 -> r')
                     -> (a_Xe5rI, b_Xe5rK, c_Xe65j, d_Xe65m)
                     -> Const r (a_Xe5rI, b_Xe5rK, c_Xe65j, d_Xe65m) :: *)
                    ~R# (forall r r'.
                         (r -> r' -> r)
                         -> r
                         -> (forall d1. Data d1 => d1 -> r')
                         -> (a_Xe5rI, b_Xe5rK, c_Xe65j, d_Xe65m)
                         -> r :: *)))
        (Data.Data.$fData(,,,)_$cgmapQr
           @ a_Xe5rI
           @ b_Xe5rK
           @ c_Xe65j
           @ d_Xe65m
           $dData_Xe65p
           $dData1_Xe65s
           $dData2_Xe65v
           $dData3_Xe65y)
        (Data.Data.$fData(,,,)_$cgmapQ
           @ a_Xe5rI
           @ b_Xe5rK
           @ c_Xe65j
           @ d_Xe65m
           $dData_Xe65p
           $dData1_Xe65s
           $dData2_Xe65v
           $dData3_Xe65y)
        (Data.Data.$fData(,,,)_$cgmapQi
           @ a_Xe5rI
           @ b_Xe5rK
           @ c_Xe65j
           @ d_Xe65m
           $dData_Xe65p
           $dData1_Xe65s
           $dData2_Xe65v
           $dData3_Xe65y)
        (Data.Data.$fData(,,,)_$cgmapM
           @ a_Xe5rI
           @ b_Xe5rK
           @ c_Xe65j
           @ d_Xe65m
           $dData_Xe65p
           $dData1_Xe65s
           $dData2_Xe65v
           $dData3_Xe65y)
        (Data.Data.$fData(,,,)_$cgmapMp
           @ a_Xe5rI
           @ b_Xe5rK
           @ c_Xe65j
           @ d_Xe65m
           $dData_Xe65p
           $dData1_Xe65s
           $dData2_Xe65v
           $dData3_Xe65y)
        (Data.Data.$fData(,,,)_$cgmapMo
           @ a_Xe5rI
           @ b_Xe5rK
           @ c_Xe65j
           @ d_Xe65m
           $dData_Xe65p
           $dData1_Xe65s
           $dData2_Xe65v
           $dData3_Xe65y)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,)6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fData(,,,,)6 = "(,,,,)"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,)5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fData(,,,,)5 = unpackCString# Data.Data.$fData(,,,,)6

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go15_rejQ0 :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go15_rejQ0
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fData(,,,,)5 of {
                False -> go15_rejQ0 ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$c(,,,,)1_rejQ1 :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$c(,,,,)1_rejQ1 = Data.Data.AlgConstr $c(,,,,)2_rejQ2

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,)4 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData(,,,,)4
  = GHC.Types.: @ Constr Data.Data.$c(,,,,) (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,)3 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fData(,,,,)3 = Data.Data.AlgRep Data.Data.$fData(,,,,)4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$t(,,,,) :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$t(,,,,)
  = Data.Data.DataType
      Data.Data.$fData(,,,,)5 Data.Data.$fData(,,,,)3

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$c(,,,,) [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$c(,,,,)
  = Data.Data.Constr
      $c(,,,,)1_rejQ1
      Data.Data.$fData(,,,,)5
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$t(,,,,)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$c(,,,,)2_rejQ2 :: ConIndex
[GblId]
$c(,,,,)2_rejQ2
  = go15_rejQ0 Data.Data.$fData(,,,,)4 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 8, types: 27, coercions: 0, joins: 0/0}
lvl115_rejQ3
  :: forall b a c d e.
     (a -> b -> c -> d -> e -> (a, b, c, d, e), Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl115_rejQ3
  = \ (@ b_Xe5oi) (@ a_Xe5og) (@ c_Xe5ok) (@ d_Xe5om) (@ e_Xe5oo) ->
      (GHC.Tuple.(,,,,)
         @ a_Xe5og @ b_Xe5oi @ c_Xe5ok @ d_Xe5om @ e_Xe5oo,
       GHC.Types.False)

-- RHS size: {terms: 90, types: 247, coercions: 64, joins: 0/4}
Data.Data.$fData(,,,,)_$cgmapMp
  :: forall a b c d e.
     (Data a, Data b, Data c, Data d, Data e) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d1. Data d1 => d1 -> m d1)
     -> (a, b, c, d, e) -> m (a, b, c, d, e)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U,U,U,U)>,
 Unf=OtherCon []]
Data.Data.$fData(,,,,)_$cgmapMp
  = \ (@ a_Xe5og)
      (@ b_Xe5oi)
      (@ c_Xe5ok)
      (@ d_Xe5om)
      (@ e_Xe5oo)
      ($dData_Xe5oq :: Data a_Xe5og)
      ($dData1_Xe5os :: Data b_Xe5oi)
      ($dData2_Xe5ou :: Data c_Xe5ok)
      ($dData3_Xe5ow :: Data d_Xe5om)
      ($dData4_Xe5oy :: Data e_Xe5oo)
      (@ (m_ae4OS :: * -> *))
      ($dMonadPlus_ae4OU :: MonadPlus m_ae4OS)
      (ds_de7BV :: forall d1. Data d1 => d1 -> m_ae4OS d1)
      (eta_XDQ :: (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo)) ->
      let {
        lvl270_se9Jb
          :: m_ae4OS (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo)
        [LclId]
        lvl270_se9Jb
          = mzero
              @ m_ae4OS
              $dMonadPlus_ae4OU
              @ (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo) } in
      let {
        $dMonad_se9sn [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae4OS
        [LclId]
        $dMonad_se9sn
          = GHC.Base.$p2MonadPlus @ m_ae4OS $dMonadPlus_ae4OU } in
      >>=
        @ m_ae4OS
        $dMonad_se9sn
        @ ((a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo), Bool)
        @ (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo)
        (case eta_XDQ of
         { (a1_ae2pO, a2_ae2pP, a3_ae2pQ, a4_ae2pR, a5_ae2pS) ->
         let {
           k_se9sm [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
             :: forall d1 b1.
                Data d1 =>
                Mp m_ae4OS (d1 -> b1) -> d1 -> m_ae4OS (b1, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_se9sm
             = \ (@ d1_ae2Ws)
                 (@ b1_ae2Wt)
                 ($dData5_ae2Wv :: Data d1_ae2Ws)
                 (ds1_de7oC [OS=OneShot] :: Mp m_ae4OS (d1_ae2Ws -> b1_ae2Wt))
                 (y_ae1Tz [OS=OneShot] :: d1_ae2Ws) ->
                 let {
                   lvl271_se9J9 :: m_ae4OS d1_ae2Ws
                   [LclId]
                   lvl271_se9J9 = ds_de7BV @ d1_ae2Ws $dData5_ae2Wv y_ae1Tz } in
                 >>=
                   @ m_ae4OS
                   $dMonad_se9sn
                   @ (d1_ae2Ws -> b1_ae2Wt, Bool)
                   @ (b1_ae2Wt, Bool)
                   (ds1_de7oC
                    `cast` (Data.Data.N:Mp[0] <m_ae4OS>_R <d1_ae2Ws -> b1_ae2Wt>_N
                            :: (Mp m_ae4OS (d1_ae2Ws -> b1_ae2Wt) :: *)
                               ~R# (m_ae4OS (d1_ae2Ws -> b1_ae2Wt, Bool) :: *)))
                   (\ (ds2_de7oD :: (d1_ae2Ws -> b1_ae2Wt, Bool)) ->
                      case ds2_de7oD of { (h_ae1TA, b2_ae1TB) ->
                      mplus
                        @ m_ae4OS
                        $dMonadPlus_ae4OU
                        @ (b1_ae2Wt, Bool)
                        (>>=
                           @ m_ae4OS
                           $dMonad_se9sn
                           @ d1_ae2Ws
                           @ (b1_ae2Wt, Bool)
                           lvl271_se9J9
                           (\ (y'_ae1TC :: d1_ae2Ws) ->
                              return
                                @ m_ae4OS
                                $dMonad_se9sn
                                @ (b1_ae2Wt, Bool)
                                (h_ae1TA y'_ae1TC, GHC.Types.True)))
                        (return
                           @ m_ae4OS
                           $dMonad_se9sn
                           @ (b1_ae2Wt, Bool)
                           (h_ae1TA y_ae1Tz, b2_ae1TB))
                      }) } in
         k_se9sm
           @ e_Xe5oo
           @ (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo)
           $dData4_Xe5oy
           ((k_se9sm
               @ d_Xe5om
               @ (e_Xe5oo -> (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo))
               $dData3_Xe5ow
               ((k_se9sm
                   @ c_Xe5ok
                   @ (d_Xe5om
                      -> e_Xe5oo -> (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo))
                   $dData2_Xe5ou
                   ((k_se9sm
                       @ b_Xe5oi
                       @ (c_Xe5ok
                          -> d_Xe5om
                          -> e_Xe5oo
                          -> (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo))
                       $dData1_Xe5os
                       ((k_se9sm
                           @ a_Xe5og
                           @ (b_Xe5oi
                              -> c_Xe5ok
                              -> d_Xe5om
                              -> e_Xe5oo
                              -> (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo))
                           $dData_Xe5oq
                           ((return
                               @ m_ae4OS
                               $dMonad_se9sn
                               @ (a_Xe5og
                                  -> b_Xe5oi
                                  -> c_Xe5ok
                                  -> d_Xe5om
                                  -> e_Xe5oo
                                  -> (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo),
                                  Bool)
                               (lvl115_rejQ3 @ b_Xe5oi @ a_Xe5og @ c_Xe5ok @ d_Xe5om @ e_Xe5oo))
                            `cast` (Sym (Data.Data.N:Mp[0]
                                             <m_ae4OS>_R
                                             <a_Xe5og
                                              -> b_Xe5oi
                                              -> c_Xe5ok
                                              -> d_Xe5om
                                              -> e_Xe5oo
                                              -> (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo)>_N)
                                    :: (m_ae4OS (a_Xe5og
                                                 -> b_Xe5oi
                                                 -> c_Xe5ok
                                                 -> d_Xe5om
                                                 -> e_Xe5oo
                                                 -> (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo),
                                                 Bool) :: *)
                                       ~R# (Mp
                                              m_ae4OS
                                              (a_Xe5og
                                               -> b_Xe5oi
                                               -> c_Xe5ok
                                               -> d_Xe5om
                                               -> e_Xe5oo
                                               -> (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om,
                                                   e_Xe5oo)) :: *)))
                           a1_ae2pO)
                        `cast` (Sym (Data.Data.N:Mp[0]
                                         <m_ae4OS>_R
                                         <b_Xe5oi
                                          -> c_Xe5ok
                                          -> d_Xe5om
                                          -> e_Xe5oo
                                          -> (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo)>_N)
                                :: (m_ae4OS (b_Xe5oi
                                             -> c_Xe5ok
                                             -> d_Xe5om
                                             -> e_Xe5oo
                                             -> (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo),
                                             Bool) :: *)
                                   ~R# (Mp
                                          m_ae4OS
                                          (b_Xe5oi
                                           -> c_Xe5ok
                                           -> d_Xe5om
                                           -> e_Xe5oo
                                           -> (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo)) :: *)))
                       a2_ae2pP)
                    `cast` (Sym (Data.Data.N:Mp[0]
                                     <m_ae4OS>_R
                                     <c_Xe5ok
                                      -> d_Xe5om
                                      -> e_Xe5oo
                                      -> (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo)>_N)
                            :: (m_ae4OS (c_Xe5ok
                                         -> d_Xe5om
                                         -> e_Xe5oo
                                         -> (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo),
                                         Bool) :: *)
                               ~R# (Mp
                                      m_ae4OS
                                      (c_Xe5ok
                                       -> d_Xe5om
                                       -> e_Xe5oo
                                       -> (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo)) :: *)))
                   a3_ae2pQ)
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_ae4OS>_R
                                 <d_Xe5om
                                  -> e_Xe5oo -> (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo)>_N)
                        :: (m_ae4OS (d_Xe5om
                                     -> e_Xe5oo -> (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo),
                                     Bool) :: *)
                           ~R# (Mp
                                  m_ae4OS
                                  (d_Xe5om
                                   -> e_Xe5oo
                                   -> (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo)) :: *)))
               a4_ae2pR)
            `cast` (Sym (Data.Data.N:Mp[0]
                             <m_ae4OS>_R
                             <e_Xe5oo -> (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo)>_N)
                    :: (m_ae4OS (e_Xe5oo
                                 -> (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo),
                                 Bool) :: *)
                       ~R# (Mp
                              m_ae4OS
                              (e_Xe5oo -> (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo)) :: *)))
           a5_ae2pS
         })
        (\ (ds1_de7oa
              :: ((a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo), Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b1_ae1TE) ->
           case b1_ae1TE of {
             False -> lvl270_se9Jb;
             True ->
               return
                 @ m_ae4OS
                 $dMonad_se9sn
                 @ (a_Xe5og, b_Xe5oi, c_Xe5ok, d_Xe5om, e_Xe5oo)
                 x'_ae1TD
           }
           })

-- RHS size: {terms: 57, types: 149, coercions: 0, joins: 0/2}
Data.Data.$fData(,,,,)_$cgmapM
  :: forall a b c d e.
     (Data a, Data b, Data c, Data d, Data e) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d1. Data d1 => d1 -> m d1)
     -> (a, b, c, d, e) -> m (a, b, c, d, e)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 120 60 20] 470 0}]
Data.Data.$fData(,,,,)_$cgmapM
  = \ (@ a_Xe5of)
      (@ b_Xe5oh)
      (@ c_Xe5oj)
      (@ d_Xe5ol)
      (@ e_Xe5on)
      ($dData_Xe5op :: Data a_Xe5of)
      ($dData1_Xe5or :: Data b_Xe5oh)
      ($dData2_Xe5ot :: Data c_Xe5oj)
      ($dData3_Xe5ov :: Data d_Xe5ol)
      ($dData4_Xe5ox :: Data e_Xe5on)
      (@ (m_ae4OC :: * -> *))
      ($dMonad_ae4OE :: Monad m_ae4OC)
      (ds_de7BU :: forall d1. Data d1 => d1 -> m_ae4OC d1)
      (eta_XDR :: (a_Xe5of, b_Xe5oh, c_Xe5oj, d_Xe5ol, e_Xe5on)) ->
      case eta_XDR of
      { (a1_ae2pO, a2_ae2pP, a3_ae2pQ, a4_ae2pR, a5_ae2pS) ->
      let {
        k_se9sj [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
          :: forall d1 b1. Data d1 => m_ae4OC (d1 -> b1) -> d1 -> m_ae4OC b1
        [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
        k_se9sj
          = \ (@ d1_ae2Vh)
              (@ b1_ae2Vi)
              ($dData5_ae2Vk :: Data d1_ae2Vh)
              (c1_ae1Tm [OS=OneShot] :: m_ae4OC (d1_ae2Vh -> b1_ae2Vi))
              (x_ae1Tn [OS=OneShot] :: d1_ae2Vh) ->
              let {
                lvl270_se9Jc :: m_ae4OC d1_ae2Vh
                [LclId]
                lvl270_se9Jc = ds_de7BU @ d1_ae2Vh $dData5_ae2Vk x_ae1Tn } in
              >>=
                @ m_ae4OC
                $dMonad_ae4OE
                @ (d1_ae2Vh -> b1_ae2Vi)
                @ b1_ae2Vi
                c1_ae1Tm
                (\ (c'_ae1To :: d1_ae2Vh -> b1_ae2Vi) ->
                   >>=
                     @ m_ae4OC
                     $dMonad_ae4OE
                     @ d1_ae2Vh
                     @ b1_ae2Vi
                     lvl270_se9Jc
                     (\ (x'_ae1Tp :: d1_ae2Vh) ->
                        return
                          @ m_ae4OC $dMonad_ae4OE @ b1_ae2Vi (c'_ae1To x'_ae1Tp))) } in
      k_se9sj
        @ e_Xe5on
        @ (a_Xe5of, b_Xe5oh, c_Xe5oj, d_Xe5ol, e_Xe5on)
        $dData4_Xe5ox
        (k_se9sj
           @ d_Xe5ol
           @ (e_Xe5on -> (a_Xe5of, b_Xe5oh, c_Xe5oj, d_Xe5ol, e_Xe5on))
           $dData3_Xe5ov
           (k_se9sj
              @ c_Xe5oj
              @ (d_Xe5ol
                 -> e_Xe5on -> (a_Xe5of, b_Xe5oh, c_Xe5oj, d_Xe5ol, e_Xe5on))
              $dData2_Xe5ot
              (k_se9sj
                 @ b_Xe5oh
                 @ (c_Xe5oj
                    -> d_Xe5ol
                    -> e_Xe5on
                    -> (a_Xe5of, b_Xe5oh, c_Xe5oj, d_Xe5ol, e_Xe5on))
                 $dData1_Xe5or
                 (k_se9sj
                    @ a_Xe5of
                    @ (b_Xe5oh
                       -> c_Xe5oj
                       -> d_Xe5ol
                       -> e_Xe5on
                       -> (a_Xe5of, b_Xe5oh, c_Xe5oj, d_Xe5ol, e_Xe5on))
                    $dData_Xe5op
                    (return
                       @ m_ae4OC
                       $dMonad_ae4OE
                       @ (a_Xe5of
                          -> b_Xe5oh
                          -> c_Xe5oj
                          -> d_Xe5ol
                          -> e_Xe5on
                          -> (a_Xe5of, b_Xe5oh, c_Xe5oj, d_Xe5ol, e_Xe5on))
                       (GHC.Tuple.(,,,,)
                          @ a_Xe5of @ b_Xe5oh @ c_Xe5oj @ d_Xe5ol @ e_Xe5on))
                    a1_ae2pO)
                 a2_ae2pP)
              a3_ae2pQ)
           a4_ae2pR)
        a5_ae2pS
      }

-- RHS size: {terms: 44, types: 55, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,)_$cgmapQi
  :: forall a b c d e.
     (Data a, Data b, Data c, Data d, Data e) =>
     forall u.
     Int -> (forall d1. Data d1 => d1 -> u) -> (a, b, c, d, e) -> u
[GblId,
 Arity=8,
 Str=<L,U><L,U><L,U><L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 20 300 20] 230 0}]
Data.Data.$fData(,,,,)_$cgmapQi
  = \ (@ a_Xe5oe)
      (@ b_Xe5og)
      (@ c_Xe5oi)
      (@ d_Xe5ok)
      (@ e_Xe5om)
      ($dData_Xe5oo :: Data a_Xe5oe)
      ($dData1_Xe5oq :: Data b_Xe5og)
      ($dData2_Xe5os :: Data c_Xe5oi)
      ($dData3_Xe5ou :: Data d_Xe5ok)
      ($dData4_Xe5ow :: Data e_Xe5om)
      (@ u_ae4Oo)
      (ds_de7BS :: Int)
      (ds1_de7BT :: forall d1. Data d1 => d1 -> u_ae4Oo)
      (x_ae1T7 :: (a_Xe5oe, b_Xe5og, c_Xe5oi, d_Xe5ok, e_Xe5om)) ->
      case x_ae1T7 of
      { (a1_ae2pO, a2_ae2pP, a3_ae2pQ, a4_ae2pR, a5_ae2pS) ->
      case ds_de7BS of { I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_ae4Oo;
        0# -> ds1_de7BT @ a_Xe5oe $dData_Xe5oo a1_ae2pO;
        1# -> ds1_de7BT @ b_Xe5og $dData1_Xe5oq a2_ae2pP;
        2# -> ds1_de7BT @ c_Xe5oi $dData2_Xe5os a3_ae2pQ;
        3# -> ds1_de7BT @ d_Xe5ok $dData3_Xe5ou a4_ae2pR;
        4# -> ds1_de7BT @ e_Xe5om $dData4_Xe5ow a5_ae2pS
      }
      }
      }

-- RHS size: {terms: 40, types: 56, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,)_$cgmapQr
  :: forall a b c d e.
     (Data a, Data b, Data c, Data d, Data e) =>
     forall r r'.
     (r' -> r -> r)
     -> r -> (forall d1. Data d1 => d1 -> r') -> (a, b, c, d, e) -> r
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 60 0 300 20] 310 0}]
Data.Data.$fData(,,,,)_$cgmapQr
  = \ (@ a_Xe5oc)
      (@ b_Xe5oe)
      (@ c_Xe5og)
      (@ d_Xe5oi)
      (@ e_Xe5ok)
      ($dData_Xe5om :: Data a_Xe5oc)
      ($dData1_Xe5oo :: Data b_Xe5oe)
      ($dData2_Xe5oq :: Data c_Xe5og)
      ($dData3_Xe5os :: Data d_Xe5oi)
      ($dData4_Xe5ou :: Data e_Xe5ok)
      (@ r_ae4NT)
      (@ r'_ae4NU)
      (ds_de7BO :: r'_ae4NU -> r_ae4NT -> r_ae4NT)
      (ds1_de7BP :: r_ae4NT)
      (ds2_de7BQ :: forall d1. Data d1 => d1 -> r'_ae4NU)
      (x0_ae1SX :: (a_Xe5oc, b_Xe5oe, c_Xe5og, d_Xe5oi, e_Xe5ok)) ->
      case x0_ae1SX of
      { (a1_ae2pO, a2_ae2pP, a3_ae2pQ, a4_ae2pR, a5_ae2pS) ->
      ds_de7BO
        (ds2_de7BQ @ a_Xe5oc $dData_Xe5om a1_ae2pO)
        (ds_de7BO
           (ds2_de7BQ @ b_Xe5oe $dData1_Xe5oo a2_ae2pP)
           (ds_de7BO
              (ds2_de7BQ @ c_Xe5og $dData2_Xe5oq a3_ae2pQ)
              (ds_de7BO
                 (ds2_de7BQ @ d_Xe5oi $dData3_Xe5os a4_ae2pR)
                 (ds_de7BO
                    (ds2_de7BQ @ e_Xe5ok $dData4_Xe5ou a5_ae2pS) ds1_de7BP))))
      }

-- RHS size: {terms: 21, types: 38, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,)_$cgmapQ
  :: forall a b c d e.
     (Data a, Data b, Data c, Data d, Data e) =>
     forall u. (forall d1. Data d1 => d1 -> u) -> (a, b, c, d, e) -> [u]
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,C(C1(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe5od)
                 (@ b_Xe5of)
                 (@ c_Xe5oh)
                 (@ d_Xe5oj)
                 (@ e_Xe5ol)
                 ($dData_Xe5on [Occ=Once] :: Data a_Xe5od)
                 ($dData1_Xe5op [Occ=Once] :: Data b_Xe5of)
                 ($dData2_Xe5or [Occ=Once] :: Data c_Xe5oh)
                 ($dData3_Xe5ot [Occ=Once] :: Data d_Xe5oj)
                 ($dData4_Xe5ov [Occ=Once] :: Data e_Xe5ol)
                 (@ u_ae4Oa)
                 (ds_de7BR [Occ=Once] :: forall d1. Data d1 => d1 -> u_ae4Oa) ->
                 Data.Data.$fData(,,,,)_$cgmapQr
                   @ a_Xe5od
                   @ b_Xe5of
                   @ c_Xe5oh
                   @ d_Xe5oj
                   @ e_Xe5ol
                   $dData_Xe5on
                   $dData1_Xe5op
                   $dData2_Xe5or
                   $dData3_Xe5ot
                   $dData4_Xe5ov
                   @ [u_ae4Oa]
                   @ u_ae4Oa
                   (GHC.Types.: @ u_ae4Oa)
                   (GHC.Types.[] @ u_ae4Oa)
                   ds_de7BR}]
Data.Data.$fData(,,,,)_$cgmapQ
  = \ (@ a_Xe5od)
      (@ b_Xe5of)
      (@ c_Xe5oh)
      (@ d_Xe5oj)
      (@ e_Xe5ol)
      ($dData_Xe5on :: Data a_Xe5od)
      ($dData1_Xe5op :: Data b_Xe5of)
      ($dData2_Xe5or :: Data c_Xe5oh)
      ($dData3_Xe5ot :: Data d_Xe5oj)
      ($dData4_Xe5ov :: Data e_Xe5ol)
      (@ u_ae4Oa)
      (ds_de7BR :: forall d1. Data d1 => d1 -> u_ae4Oa) ->
      Data.Data.$fData(,,,,)_$cgmapQr
        @ a_Xe5od
        @ b_Xe5of
        @ c_Xe5oh
        @ d_Xe5oj
        @ e_Xe5ol
        $dData_Xe5on
        $dData1_Xe5op
        $dData2_Xe5or
        $dData3_Xe5ot
        $dData4_Xe5ov
        @ [u_ae4Oa]
        @ u_ae4Oa
        (GHC.Types.: @ u_ae4Oa)
        (GHC.Types.[] @ u_ae4Oa)
        ds_de7BR

-- RHS size: {terms: 40, types: 56, coercions: 11, joins: 0/0}
Data.Data.$fData(,,,,)1
  :: forall a b c d e.
     (Data a, Data b, Data c, Data d, Data e) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d1. Data d1 => d1 -> r')
     -> (a, b, c, d, e)
     -> Const r (a, b, c, d, e)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 60 0 300 20] 310 0}]
Data.Data.$fData(,,,,)1
  = \ (@ a_Xe5ob)
      (@ b_Xe5od)
      (@ c_Xe5of)
      (@ d_Xe5oh)
      (@ e_Xe5oj)
      ($dData_Xe5ol :: Data a_Xe5ob)
      ($dData1_Xe5on :: Data b_Xe5od)
      ($dData2_Xe5op :: Data c_Xe5of)
      ($dData3_Xe5or :: Data d_Xe5oh)
      ($dData4_Xe5ot :: Data e_Xe5oj)
      (@ r_ae4NC)
      (@ r'_ae4ND)
      (ds_de7BL :: r_ae4NC -> r'_ae4ND -> r_ae4NC)
      (ds1_de7BM :: r_ae4NC)
      (ds2_de7BN :: forall d1. Data d1 => d1 -> r'_ae4ND)
      (eta_XDX :: (a_Xe5ob, b_Xe5od, c_Xe5of, d_Xe5oh, e_Xe5oj)) ->
      case eta_XDX of
      { (a1_ae2pO, a2_ae2pP, a3_ae2pQ, a4_ae2pR, a5_ae2pS) ->
      (ds_de7BL
         (ds_de7BL
            (ds_de7BL
               (ds_de7BL
                  (ds_de7BL ds1_de7BM (ds2_de7BN @ a_Xe5ob $dData_Xe5ol a1_ae2pO))
                  (ds2_de7BN @ b_Xe5od $dData1_Xe5on a2_ae2pP))
               (ds2_de7BN @ c_Xe5of $dData2_Xe5op a3_ae2pQ))
            (ds2_de7BN @ d_Xe5oh $dData3_Xe5or a4_ae2pR))
         (ds2_de7BN @ e_Xe5oj $dData4_Xe5ot a5_ae2pS))
      `cast` (Sym (Data.Functor.Const.N:Const[0]
                       <*>_N
                       <r_ae4NC>_R
                       <(a_Xe5ob, b_Xe5od, c_Xe5of, d_Xe5oh, e_Xe5oj)>_P)
              :: (r_ae4NC :: *)
                 ~R# (Const
                        r_ae4NC (a_Xe5ob, b_Xe5od, c_Xe5of, d_Xe5oh, e_Xe5oj) :: *))
      }

-- RHS size: {terms: 31, types: 53, coercions: 8, joins: 0/0}
Data.Data.$fData(,,,,)2
  :: forall a b c d e.
     (Data a, Data b, Data c, Data d, Data e) =>
     (forall b1. Data b1 => b1 -> b1)
     -> (a, b, c, d, e) -> Identity (a, b, c, d, e)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,C(C1(U))><S,1*U(U,U,U,U,U)>m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 300 20] 170 60}]
Data.Data.$fData(,,,,)2
  = \ (@ a_Xe5oa)
      (@ b_Xe5oc)
      (@ c_Xe5oe)
      (@ d_Xe5og)
      (@ e_Xe5oi)
      ($dData_Xe5ok :: Data a_Xe5oa)
      ($dData1_Xe5om :: Data b_Xe5oc)
      ($dData2_Xe5oo :: Data c_Xe5oe)
      ($dData3_Xe5oq :: Data d_Xe5og)
      ($dData4_Xe5os :: Data e_Xe5oi)
      (ds_de7BK :: forall b1. Data b1 => b1 -> b1)
      (x0_Xe2Xw :: (a_Xe5oa, b_Xe5oc, c_Xe5oe, d_Xe5og, e_Xe5oi)) ->
      case x0_Xe2Xw of
      { (a1_ae2pO, a2_ae2pP, a3_ae2pQ, a4_ae2pR, a5_ae2pS) ->
      (ds_de7BK @ a_Xe5oa $dData_Xe5ok a1_ae2pO,
       ds_de7BK @ b_Xe5oc $dData1_Xe5om a2_ae2pP,
       ds_de7BK @ c_Xe5oe $dData2_Xe5oo a3_ae2pQ,
       ds_de7BK @ d_Xe5og $dData3_Xe5oq a4_ae2pR,
       ds_de7BK @ e_Xe5oi $dData4_Xe5os a5_ae2pS)
      `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                       <(a_Xe5oa, b_Xe5oc, c_Xe5oe, d_Xe5og, e_Xe5oi)>_R)
              :: ((a_Xe5oa, b_Xe5oc, c_Xe5oe, d_Xe5og, e_Xe5oi) :: *)
                 ~R# (Identity (a_Xe5oa, b_Xe5oc, c_Xe5oe, d_Xe5og, e_Xe5oi) :: *))
      }

-- RHS size: {terms: 100, types: 254, coercions: 64, joins: 0/4}
Data.Data.$fData(,,,,)_$cgmapMo
  :: forall a b c d e.
     (Data a, Data b, Data c, Data d, Data e) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d1. Data d1 => d1 -> m d1)
     -> (a, b, c, d, e) -> m (a, b, c, d, e)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U,U,U,U)>,
 Unf=OtherCon []]
Data.Data.$fData(,,,,)_$cgmapMo
  = \ (@ a_Xe5o8)
      (@ b_Xe62n)
      (@ c_Xe62q)
      (@ d_Xe62t)
      (@ e_Xe62w)
      ($dData_Xe62z :: Data a_Xe5o8)
      ($dData1_Xe62C :: Data b_Xe62n)
      ($dData2_Xe62F :: Data c_Xe62q)
      ($dData3_Xe62I :: Data d_Xe62t)
      ($dData4_Xe62L :: Data e_Xe62w)
      (@ (m_ae4P8 :: * -> *))
      ($dMonadPlus_ae4Pa :: MonadPlus m_ae4P8)
      (ds_de7BW :: forall d1. Data d1 => d1 -> m_ae4P8 d1)
      (eta_XEq :: (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w)) ->
      let {
        lvl270_se9Jh
          :: m_ae4P8 (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w)
        [LclId]
        lvl270_se9Jh
          = mzero
              @ m_ae4P8
              $dMonadPlus_ae4Pa
              @ (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w) } in
      let {
        $dMonad_se9sf [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae4P8
        [LclId]
        $dMonad_se9sf
          = GHC.Base.$p2MonadPlus @ m_ae4P8 $dMonadPlus_ae4Pa } in
      >>=
        @ m_ae4P8
        $dMonad_se9sf
        @ ((a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w), Bool)
        @ (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w)
        (case eta_XEq of
         { (a1_ae2pO, a2_ae2pP, a3_ae2pQ, a4_ae2pR, a5_ae2pS) ->
         let {
           k_se9se [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
             :: forall d1 b1.
                Data d1 =>
                Mp m_ae4P8 (d1 -> b1) -> d1 -> m_ae4P8 (b1, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_se9se
             = \ (@ d1_ae2Ya)
                 (@ b1_ae2Yb)
                 ($dData5_ae2Yd :: Data d1_ae2Ya)
                 (ds1_de7pC [OS=OneShot] :: Mp m_ae4P8 (d1_ae2Ya -> b1_ae2Yb))
                 (y_ae1TO [OS=OneShot] :: d1_ae2Ya) ->
                 let {
                   lvl271_se9Jf :: m_ae4P8 d1_ae2Ya
                   [LclId]
                   lvl271_se9Jf = ds_de7BW @ d1_ae2Ya $dData5_ae2Yd y_ae1TO } in
                 >>=
                   @ m_ae4P8
                   $dMonad_se9sf
                   @ (d1_ae2Ya -> b1_ae2Yb, Bool)
                   @ (b1_ae2Yb, Bool)
                   (ds1_de7pC
                    `cast` (Data.Data.N:Mp[0] <m_ae4P8>_R <d1_ae2Ya -> b1_ae2Yb>_N
                            :: (Mp m_ae4P8 (d1_ae2Ya -> b1_ae2Yb) :: *)
                               ~R# (m_ae4P8 (d1_ae2Ya -> b1_ae2Yb, Bool) :: *)))
                   (\ (ds2_de7pD :: (d1_ae2Ya -> b1_ae2Yb, Bool)) ->
                      case ds2_de7pD of { (h_ae1TP, b2_ae1TQ) ->
                      case b2_ae1TQ of {
                        False ->
                          mplus
                            @ m_ae4P8
                            $dMonadPlus_ae4Pa
                            @ (b1_ae2Yb, Bool)
                            (>>=
                               @ m_ae4P8
                               $dMonad_se9sf
                               @ d1_ae2Ya
                               @ (b1_ae2Yb, Bool)
                               lvl271_se9Jf
                               (\ (y'_ae1TR :: d1_ae2Ya) ->
                                  return
                                    @ m_ae4P8
                                    $dMonad_se9sf
                                    @ (b1_ae2Yb, Bool)
                                    (h_ae1TP y'_ae1TR, GHC.Types.True)))
                            (return
                               @ m_ae4P8
                               $dMonad_se9sf
                               @ (b1_ae2Yb, Bool)
                               (h_ae1TP y_ae1TO, GHC.Types.False));
                        True ->
                          return
                            @ m_ae4P8
                            $dMonad_se9sf
                            @ (b1_ae2Yb, Bool)
                            (h_ae1TP y_ae1TO, GHC.Types.True)
                      }
                      }) } in
         k_se9se
           @ e_Xe62w
           @ (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w)
           $dData4_Xe62L
           ((k_se9se
               @ d_Xe62t
               @ (e_Xe62w -> (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w))
               $dData3_Xe62I
               ((k_se9se
                   @ c_Xe62q
                   @ (d_Xe62t
                      -> e_Xe62w -> (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w))
                   $dData2_Xe62F
                   ((k_se9se
                       @ b_Xe62n
                       @ (c_Xe62q
                          -> d_Xe62t
                          -> e_Xe62w
                          -> (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w))
                       $dData1_Xe62C
                       ((k_se9se
                           @ a_Xe5o8
                           @ (b_Xe62n
                              -> c_Xe62q
                              -> d_Xe62t
                              -> e_Xe62w
                              -> (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w))
                           $dData_Xe62z
                           ((return
                               @ m_ae4P8
                               $dMonad_se9sf
                               @ (a_Xe5o8
                                  -> b_Xe62n
                                  -> c_Xe62q
                                  -> d_Xe62t
                                  -> e_Xe62w
                                  -> (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w),
                                  Bool)
                               (lvl115_rejQ3 @ b_Xe62n @ a_Xe5o8 @ c_Xe62q @ d_Xe62t @ e_Xe62w))
                            `cast` (Sym (Data.Data.N:Mp[0]
                                             <m_ae4P8>_R
                                             <a_Xe5o8
                                              -> b_Xe62n
                                              -> c_Xe62q
                                              -> d_Xe62t
                                              -> e_Xe62w
                                              -> (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w)>_N)
                                    :: (m_ae4P8 (a_Xe5o8
                                                 -> b_Xe62n
                                                 -> c_Xe62q
                                                 -> d_Xe62t
                                                 -> e_Xe62w
                                                 -> (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w),
                                                 Bool) :: *)
                                       ~R# (Mp
                                              m_ae4P8
                                              (a_Xe5o8
                                               -> b_Xe62n
                                               -> c_Xe62q
                                               -> d_Xe62t
                                               -> e_Xe62w
                                               -> (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t,
                                                   e_Xe62w)) :: *)))
                           a1_ae2pO)
                        `cast` (Sym (Data.Data.N:Mp[0]
                                         <m_ae4P8>_R
                                         <b_Xe62n
                                          -> c_Xe62q
                                          -> d_Xe62t
                                          -> e_Xe62w
                                          -> (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w)>_N)
                                :: (m_ae4P8 (b_Xe62n
                                             -> c_Xe62q
                                             -> d_Xe62t
                                             -> e_Xe62w
                                             -> (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w),
                                             Bool) :: *)
                                   ~R# (Mp
                                          m_ae4P8
                                          (b_Xe62n
                                           -> c_Xe62q
                                           -> d_Xe62t
                                           -> e_Xe62w
                                           -> (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w)) :: *)))
                       a2_ae2pP)
                    `cast` (Sym (Data.Data.N:Mp[0]
                                     <m_ae4P8>_R
                                     <c_Xe62q
                                      -> d_Xe62t
                                      -> e_Xe62w
                                      -> (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w)>_N)
                            :: (m_ae4P8 (c_Xe62q
                                         -> d_Xe62t
                                         -> e_Xe62w
                                         -> (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w),
                                         Bool) :: *)
                               ~R# (Mp
                                      m_ae4P8
                                      (c_Xe62q
                                       -> d_Xe62t
                                       -> e_Xe62w
                                       -> (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w)) :: *)))
                   a3_ae2pQ)
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_ae4P8>_R
                                 <d_Xe62t
                                  -> e_Xe62w -> (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w)>_N)
                        :: (m_ae4P8 (d_Xe62t
                                     -> e_Xe62w -> (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w),
                                     Bool) :: *)
                           ~R# (Mp
                                  m_ae4P8
                                  (d_Xe62t
                                   -> e_Xe62w
                                   -> (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w)) :: *)))
               a4_ae2pR)
            `cast` (Sym (Data.Data.N:Mp[0]
                             <m_ae4P8>_R
                             <e_Xe62w -> (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w)>_N)
                    :: (m_ae4P8 (e_Xe62w
                                 -> (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w),
                                 Bool) :: *)
                       ~R# (Mp
                              m_ae4P8
                              (e_Xe62w -> (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w)) :: *)))
           a5_ae2pS
         })
        (\ (ds1_de7pa
              :: ((a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w), Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b1_ae1TT) ->
           case b1_ae1TT of {
             False -> lvl270_se9Jh;
             True ->
               return
                 @ m_ae4P8
                 $dMonad_se9sf
                 @ (a_Xe5o8, b_Xe62n, c_Xe62q, d_Xe62t, e_Xe62w)
                 x'_ae1TS
           }
           })

-- RHS size: {terms: 10, types: 27, coercions: 0, joins: 0/0}
lvl116_rejQ4 :: forall e d c b a. (a, b, c, d, e) -> Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []]
lvl116_rejQ4
  = \ (@ e_Xe62w)
      (@ d_Xe62t)
      (@ c_Xe62q)
      (@ b_Xe5o9)
      (@ a_Xe5o7)
      (ds_de7BB :: (a_Xe5o7, b_Xe5o9, c_Xe62q, d_Xe62t, e_Xe62w)) ->
      case ds_de7BB of
      { (ds1_de7BC, ds2_de7BD, ds3_de7BE, ds4_de7BF, ds5_de7BG) ->
      Data.Data.$c(,,,,)
      }

-- RHS size: {terms: 7, types: 16, coercions: 0, joins: 0/0}
lvl117_rejQ5 :: forall a b c d e. (a, b, c, d, e) -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl117_rejQ5
  = \ (@ a_Xe5o7)
      (@ b_Xe5o9)
      (@ c_Xe62q)
      (@ d_Xe62t)
      (@ e_Xe62w)
      _ [Occ=Dead] ->
      Data.Data.$t(,,,,)

-- RHS size: {terms: 10, types: 38, coercions: 0, joins: 0/0}
lvl118_rejQ6
  :: forall a b c1 d e (t :: * -> *) (c2 :: * -> *).
     Typeable t =>
     (forall d1. Data d1 => c2 (t d1)) -> Maybe (c2 (a, b, c1, d, e))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl118_rejQ6
  = \ (@ a_Xe5o7)
      (@ b_Xe5o9)
      (@ c_Xe62q)
      (@ d_Xe62t)
      (@ e_Xe62w)
      (@ (t_ae4ML :: * -> *))
      (@ (c1_ae4MM :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing
        @ (c1_ae4MM (a_Xe5o7, b_Xe5o9, c_Xe62q, d_Xe62t, e_Xe62w))

-- RHS size: {terms: 10, types: 47, coercions: 0, joins: 0/0}
lvl119_rejQ7
  :: forall a b c1 d e (t :: * -> * -> *) (c2 :: * -> *).
     Typeable t =>
     (forall d1 e1. (Data d1, Data e1) => c2 (t d1 e1))
     -> Maybe (c2 (a, b, c1, d, e))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl119_rejQ7
  = \ (@ a_Xe5o7)
      (@ b_Xe5o9)
      (@ c_Xe62q)
      (@ d_Xe62t)
      (@ e_Xe62w)
      (@ (t_ae4N4 :: * -> * -> *))
      (@ (c1_ae4N5 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing
        @ (c1_ae4N5 (a_Xe5o7, b_Xe5o9, c_Xe62q, d_Xe62t, e_Xe62w))

-- RHS size: {terms: 87, types: 123, coercions: 67, joins: 0/0}
Data.Data.$fData(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e.
     (Data a, Data b, Data c, Data d, Data e) =>
     Data (a, b, c, d, e)
[GblId[DFunId],
 Arity=5,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_ae1XI)
             (@ b_ae1XJ)
             (@ c_ae1XK)
             (@ d_ae1XL)
             (@ e_ae1XM)
             (v_XEj :: Data a_ae1XI)
             (v1_XEl :: Data b_ae1XJ)
             (v2_XEn :: Data c_ae1XK)
             (v3_XEp :: Data d_ae1XL)
             (v4_B5 :: Data e_ae1XM) ->
       Data.Data.C:Data TYPE: (a_ae1XI, b_ae1XJ, c_ae1XK, d_ae1XL,
                               e_ae1XM)
                        (Data.Data.$fData(,,,,)7
                           @ a_ae1XI
                           @ b_ae1XJ
                           @ c_ae1XK
                           @ d_ae1XL
                           @ e_ae1XM
                           v_XEj
                           v1_XEl
                           v2_XEn
                           v3_XEp
                           v4_B5)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <(a_ae1XI,
                                                                                   b_ae1XJ, c_ae1XK,
                                                                                   d_ae1XL,
                                                                                   e_ae1XM)>_N
                                :: (Data.Typeable.Internal.TypeRep
                                      (a_ae1XI, b_ae1XJ, c_ae1XK, d_ae1XL, e_ae1XM) :: *)
                                   ~R# (Typeable
                                          (a_ae1XI, b_ae1XJ, c_ae1XK, d_ae1XL,
                                           e_ae1XM) :: Constraint))
                        Data.Data.$fData(,,,,)_$cgfoldl
                          @ a_ae1XI
                          @ b_ae1XJ
                          @ c_ae1XK
                          @ d_ae1XL
                          @ e_ae1XM
                          v_XEj
                          v1_XEl
                          v2_XEn
                          v3_XEp
                          v4_B5
                        Data.Data.$fData(,,,,)_$cgunfold
                          @ a_ae1XI
                          @ b_ae1XJ
                          @ c_ae1XK
                          @ d_ae1XL
                          @ e_ae1XM
                          v_XEj
                          v1_XEl
                          v2_XEn
                          v3_XEp
                          v4_B5
                        \ (ds_de7BB [Occ=Once!]
                             :: (a_ae1XI, b_ae1XJ, c_ae1XK, d_ae1XL, e_ae1XM)) ->
                          case ds_de7BB of
                          { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead],
                             _ [Occ=Dead]) ->
                          Data.Data.$c(,,,,)
                          }
                        \ _ [Occ=Dead] -> Data.Data.$t(,,,,)
                        \ (@ (t_ae4ML :: * -> *))
                          (@ (c1_ae4MM :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing
                            @ (c1_ae4MM (a_ae1XI, b_ae1XJ, c_ae1XK, d_ae1XL, e_ae1XM))
                        \ (@ (t_ae4N4 :: * -> * -> *))
                          (@ (c1_ae4N5 :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing
                            @ (c1_ae4N5 (a_ae1XI, b_ae1XJ, c_ae1XK, d_ae1XL, e_ae1XM))
                        (Data.Data.$fData(,,,,)2
                           @ a_ae1XI
                           @ b_ae1XJ
                           @ c_ae1XK
                           @ d_ae1XL
                           @ e_ae1XM
                           v_XEj
                           v1_XEl
                           v2_XEn
                           v3_XEp
                           v4_B5)
                        `cast` (<forall b1. Data b1 => b1 -> b1>_R
                                ->_R <(a_ae1XI, b_ae1XJ, c_ae1XK, d_ae1XL, e_ae1XM)>_R
                                ->_R Data.Functor.Identity.N:Identity[0]
                                         <(a_ae1XI, b_ae1XJ, c_ae1XK, d_ae1XL, e_ae1XM)>_R
                                :: ((forall b1. Data b1 => b1 -> b1)
                                    -> (a_ae1XI, b_ae1XJ, c_ae1XK, d_ae1XL, e_ae1XM)
                                    -> Identity (a_ae1XI, b_ae1XJ, c_ae1XK, d_ae1XL, e_ae1XM) :: *)
                                   ~R# ((forall b1. Data b1 => b1 -> b1)
                                        -> (a_ae1XI, b_ae1XJ, c_ae1XK, d_ae1XL, e_ae1XM)
                                        -> (a_ae1XI, b_ae1XJ, c_ae1XK, d_ae1XL, e_ae1XM) :: *))
                        (Data.Data.$fData(,,,,)1
                           @ a_ae1XI
                           @ b_ae1XJ
                           @ c_ae1XK
                           @ d_ae1XL
                           @ e_ae1XM
                           v_XEj
                           v1_XEl
                           v2_XEn
                           v3_XEp
                           v4_B5)
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d1. Data d1 => d1 -> r'>_R
                                ->_R <(a_ae1XI, b_ae1XJ, c_ae1XK, d_ae1XL, e_ae1XM)>_R
                                ->_R Data.Functor.Const.N:Const[0]
                                         <*>_N
                                         <r>_R
                                         <(a_ae1XI, b_ae1XJ, c_ae1XK, d_ae1XL, e_ae1XM)>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d1. Data d1 => d1 -> r')
                                    -> (a_ae1XI, b_ae1XJ, c_ae1XK, d_ae1XL, e_ae1XM)
                                    -> Const r (a_ae1XI, b_ae1XJ, c_ae1XK, d_ae1XL, e_ae1XM) :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d1. Data d1 => d1 -> r')
                                        -> (a_ae1XI, b_ae1XJ, c_ae1XK, d_ae1XL, e_ae1XM)
                                        -> r :: *))
                        Data.Data.$fData(,,,,)_$cgmapQr
                          @ a_ae1XI
                          @ b_ae1XJ
                          @ c_ae1XK
                          @ d_ae1XL
                          @ e_ae1XM
                          v_XEj
                          v1_XEl
                          v2_XEn
                          v3_XEp
                          v4_B5
                        Data.Data.$fData(,,,,)_$cgmapQ
                          @ a_ae1XI
                          @ b_ae1XJ
                          @ c_ae1XK
                          @ d_ae1XL
                          @ e_ae1XM
                          v_XEj
                          v1_XEl
                          v2_XEn
                          v3_XEp
                          v4_B5
                        Data.Data.$fData(,,,,)_$cgmapQi
                          @ a_ae1XI
                          @ b_ae1XJ
                          @ c_ae1XK
                          @ d_ae1XL
                          @ e_ae1XM
                          v_XEj
                          v1_XEl
                          v2_XEn
                          v3_XEp
                          v4_B5
                        Data.Data.$fData(,,,,)_$cgmapM
                          @ a_ae1XI
                          @ b_ae1XJ
                          @ c_ae1XK
                          @ d_ae1XL
                          @ e_ae1XM
                          v_XEj
                          v1_XEl
                          v2_XEn
                          v3_XEp
                          v4_B5
                        Data.Data.$fData(,,,,)_$cgmapMp
                          @ a_ae1XI
                          @ b_ae1XJ
                          @ c_ae1XK
                          @ d_ae1XL
                          @ e_ae1XM
                          v_XEj
                          v1_XEl
                          v2_XEn
                          v3_XEp
                          v4_B5
                        Data.Data.$fData(,,,,)_$cgmapMo
                          @ a_ae1XI
                          @ b_ae1XJ
                          @ c_ae1XK
                          @ d_ae1XL
                          @ e_ae1XM
                          v_XEj
                          v1_XEl
                          v2_XEn
                          v3_XEp
                          v4_B5]
Data.Data.$fData(,,,,)
  = \ (@ a_Xe5o7)
      (@ b_Xe5o9)
      (@ c_Xe62q)
      (@ d_Xe62t)
      (@ e_Xe62w)
      ($dData_Xe62z :: Data a_Xe5o7)
      ($dData1_Xe62C :: Data b_Xe5o9)
      ($dData2_Xe62F :: Data c_Xe62q)
      ($dData3_Xe62I :: Data d_Xe62t)
      ($dData4_Xe62L :: Data e_Xe62w) ->
      Data.Data.C:Data
        @ (a_Xe5o7, b_Xe5o9, c_Xe62q, d_Xe62t, e_Xe62w)
        ((Data.Data.$fData(,,,,)7
            @ a_Xe5o7
            @ b_Xe5o9
            @ c_Xe62q
            @ d_Xe62t
            @ e_Xe62w
            $dData_Xe62z
            $dData1_Xe62C
            $dData2_Xe62F
            $dData3_Xe62I
            $dData4_Xe62L)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <(a_Xe5o7,
                                                                    b_Xe5o9, c_Xe62q, d_Xe62t,
                                                                    e_Xe62w)>_N
                 :: (Data.Typeable.Internal.TypeRep
                       (a_Xe5o7, b_Xe5o9, c_Xe62q, d_Xe62t, e_Xe62w) :: *)
                    ~R# (Typeable
                           (a_Xe5o7, b_Xe5o9, c_Xe62q, d_Xe62t, e_Xe62w) :: Constraint)))
        (Data.Data.$fData(,,,,)_$cgfoldl
           @ a_Xe5o7
           @ b_Xe5o9
           @ c_Xe62q
           @ d_Xe62t
           @ e_Xe62w
           $dData_Xe62z
           $dData1_Xe62C
           $dData2_Xe62F
           $dData3_Xe62I
           $dData4_Xe62L)
        (\ (@ (c1_sefQy :: * -> *))
           (w_sefQz
              :: forall b1 r. Data b1 => c1_sefQy (b1 -> r) -> c1_sefQy r)
           (w1_sefQA :: forall r. r -> c1_sefQy r)
           _ [Occ=Dead] ->
           Data.Data.$w$cgunfold
             @ a_Xe5o7
             @ b_Xe5o9
             @ c_Xe62q
             @ d_Xe62t
             @ e_Xe62w
             $dData_Xe62z
             $dData1_Xe62C
             $dData2_Xe62F
             $dData3_Xe62I
             $dData4_Xe62L
             @ c1_sefQy
             w_sefQz
             w1_sefQA)
        (lvl116_rejQ4 @ e_Xe62w @ d_Xe62t @ c_Xe62q @ b_Xe5o9 @ a_Xe5o7)
        (lvl117_rejQ5 @ a_Xe5o7 @ b_Xe5o9 @ c_Xe62q @ d_Xe62t @ e_Xe62w)
        (lvl118_rejQ6 @ a_Xe5o7 @ b_Xe5o9 @ c_Xe62q @ d_Xe62t @ e_Xe62w)
        (lvl119_rejQ7 @ a_Xe5o7 @ b_Xe5o9 @ c_Xe62q @ d_Xe62t @ e_Xe62w)
        ((Data.Data.$fData(,,,,)2
            @ a_Xe5o7
            @ b_Xe5o9
            @ c_Xe62q
            @ d_Xe62t
            @ e_Xe62w
            $dData_Xe62z
            $dData1_Xe62C
            $dData2_Xe62F
            $dData3_Xe62I
            $dData4_Xe62L)
         `cast` (<forall b1. Data b1 => b1 -> b1>_R
                 ->_R <(a_Xe5o7, b_Xe5o9, c_Xe62q, d_Xe62t, e_Xe62w)>_R
                 ->_R Data.Functor.Identity.N:Identity[0]
                          <(a_Xe5o7, b_Xe5o9, c_Xe62q, d_Xe62t, e_Xe62w)>_R
                 :: ((forall b1. Data b1 => b1 -> b1)
                     -> (a_Xe5o7, b_Xe5o9, c_Xe62q, d_Xe62t, e_Xe62w)
                     -> Identity (a_Xe5o7, b_Xe5o9, c_Xe62q, d_Xe62t, e_Xe62w) :: *)
                    ~R# ((forall b1. Data b1 => b1 -> b1)
                         -> (a_Xe5o7, b_Xe5o9, c_Xe62q, d_Xe62t, e_Xe62w)
                         -> (a_Xe5o7, b_Xe5o9, c_Xe62q, d_Xe62t, e_Xe62w) :: *)))
        ((Data.Data.$fData(,,,,)1
            @ a_Xe5o7
            @ b_Xe5o9
            @ c_Xe62q
            @ d_Xe62t
            @ e_Xe62w
            $dData_Xe62z
            $dData1_Xe62C
            $dData2_Xe62F
            $dData3_Xe62I
            $dData4_Xe62L)
         `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                 <r -> r' -> r>_R
                 ->_R <r>_R
                 ->_R <forall d1. Data d1 => d1 -> r'>_R
                 ->_R <(a_Xe5o7, b_Xe5o9, c_Xe62q, d_Xe62t, e_Xe62w)>_R
                 ->_R Data.Functor.Const.N:Const[0]
                          <*>_N <r>_R <(a_Xe5o7, b_Xe5o9, c_Xe62q, d_Xe62t, e_Xe62w)>_P
                 :: (forall r r'.
                     (r -> r' -> r)
                     -> r
                     -> (forall d1. Data d1 => d1 -> r')
                     -> (a_Xe5o7, b_Xe5o9, c_Xe62q, d_Xe62t, e_Xe62w)
                     -> Const r (a_Xe5o7, b_Xe5o9, c_Xe62q, d_Xe62t, e_Xe62w) :: *)
                    ~R# (forall r r'.
                         (r -> r' -> r)
                         -> r
                         -> (forall d1. Data d1 => d1 -> r')
                         -> (a_Xe5o7, b_Xe5o9, c_Xe62q, d_Xe62t, e_Xe62w)
                         -> r :: *)))
        (Data.Data.$fData(,,,,)_$cgmapQr
           @ a_Xe5o7
           @ b_Xe5o9
           @ c_Xe62q
           @ d_Xe62t
           @ e_Xe62w
           $dData_Xe62z
           $dData1_Xe62C
           $dData2_Xe62F
           $dData3_Xe62I
           $dData4_Xe62L)
        (Data.Data.$fData(,,,,)_$cgmapQ
           @ a_Xe5o7
           @ b_Xe5o9
           @ c_Xe62q
           @ d_Xe62t
           @ e_Xe62w
           $dData_Xe62z
           $dData1_Xe62C
           $dData2_Xe62F
           $dData3_Xe62I
           $dData4_Xe62L)
        (Data.Data.$fData(,,,,)_$cgmapQi
           @ a_Xe5o7
           @ b_Xe5o9
           @ c_Xe62q
           @ d_Xe62t
           @ e_Xe62w
           $dData_Xe62z
           $dData1_Xe62C
           $dData2_Xe62F
           $dData3_Xe62I
           $dData4_Xe62L)
        (Data.Data.$fData(,,,,)_$cgmapM
           @ a_Xe5o7
           @ b_Xe5o9
           @ c_Xe62q
           @ d_Xe62t
           @ e_Xe62w
           $dData_Xe62z
           $dData1_Xe62C
           $dData2_Xe62F
           $dData3_Xe62I
           $dData4_Xe62L)
        (Data.Data.$fData(,,,,)_$cgmapMp
           @ a_Xe5o7
           @ b_Xe5o9
           @ c_Xe62q
           @ d_Xe62t
           @ e_Xe62w
           $dData_Xe62z
           $dData1_Xe62C
           $dData2_Xe62F
           $dData3_Xe62I
           $dData4_Xe62L)
        (Data.Data.$fData(,,,,)_$cgmapMo
           @ a_Xe5o7
           @ b_Xe5o9
           @ c_Xe62q
           @ d_Xe62t
           @ e_Xe62w
           $dData_Xe62z
           $dData1_Xe62C
           $dData2_Xe62F
           $dData3_Xe62I
           $dData4_Xe62L)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,,)6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fData(,,,,,)6 = "(,,,,,)"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,,)5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fData(,,,,,)5 = unpackCString# Data.Data.$fData(,,,,,)6

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go16_rejQ8 :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go16_rejQ8
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fData(,,,,,)5 of {
                False -> go16_rejQ8 ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$c(,,,,,)1_rejQ9 :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$c(,,,,,)1_rejQ9 = Data.Data.AlgConstr $c(,,,,,)2_rejQa

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,,)4 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData(,,,,,)4
  = GHC.Types.: @ Constr Data.Data.$c(,,,,,) (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,,)3 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fData(,,,,,)3
  = Data.Data.AlgRep Data.Data.$fData(,,,,,)4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$t(,,,,,) :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$t(,,,,,)
  = Data.Data.DataType
      Data.Data.$fData(,,,,,)5 Data.Data.$fData(,,,,,)3

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$c(,,,,,) [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$c(,,,,,)
  = Data.Data.Constr
      $c(,,,,,)1_rejQ9
      Data.Data.$fData(,,,,,)5
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$t(,,,,,)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$c(,,,,,)2_rejQa :: ConIndex
[GblId]
$c(,,,,,)2_rejQa
  = go16_rejQ8 Data.Data.$fData(,,,,,)4 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 9, types: 32, coercions: 0, joins: 0/0}
lvl120_rejQb
  :: forall b a c d e f.
     (a -> b -> c -> d -> e -> f -> (a, b, c, d, e, f), Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl120_rejQb
  = \ (@ b_Xe5kx)
      (@ a_Xe5kv)
      (@ c_Xe5kz)
      (@ d_Xe5kB)
      (@ e_Xe5kD)
      (@ f_Xe5kF) ->
      (GHC.Tuple.(,,,,,)
         @ a_Xe5kv @ b_Xe5kx @ c_Xe5kz @ d_Xe5kB @ e_Xe5kD @ f_Xe5kF,
       GHC.Types.False)

-- RHS size: {terms: 95, types: 283, coercions: 85, joins: 0/4}
Data.Data.$fData(,,,,,)_$cgmapMp
  :: forall a b c d e f.
     (Data a, Data b, Data c, Data d, Data e, Data f) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d1. Data d1 => d1 -> m d1)
     -> (a, b, c, d, e, f) -> m (a, b, c, d, e, f)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U,U,U,U,U)>,
 Unf=OtherCon []]
Data.Data.$fData(,,,,,)_$cgmapMp
  = \ (@ a_Xe5kv)
      (@ b_Xe5kx)
      (@ c_Xe5kz)
      (@ d_Xe5kB)
      (@ e_Xe5kD)
      (@ f_Xe5kF)
      ($dData_Xe5kH :: Data a_Xe5kv)
      ($dData1_Xe5kJ :: Data b_Xe5kx)
      ($dData2_Xe5kL :: Data c_Xe5kz)
      ($dData3_Xe5kN :: Data d_Xe5kB)
      ($dData4_Xe5kP :: Data e_Xe5kD)
      ($dData5_Xe5kR :: Data f_Xe5kF)
      (@ (m_ae4KZ :: * -> *))
      ($dMonadPlus_ae4L1 :: MonadPlus m_ae4KZ)
      (ds_de7Bx :: forall d1. Data d1 => d1 -> m_ae4KZ d1)
      (eta_XEA
         :: (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD, f_Xe5kF)) ->
      let {
        lvl270_se9Ju
          :: m_ae4KZ (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD, f_Xe5kF)
        [LclId]
        lvl270_se9Ju
          = mzero
              @ m_ae4KZ
              $dMonadPlus_ae4L1
              @ (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD, f_Xe5kF) } in
      let {
        $dMonad_se9sb [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae4KZ
        [LclId]
        $dMonad_se9sb
          = GHC.Base.$p2MonadPlus @ m_ae4KZ $dMonadPlus_ae4L1 } in
      >>=
        @ m_ae4KZ
        $dMonad_se9sb
        @ ((a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD, f_Xe5kF), Bool)
        @ (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD, f_Xe5kF)
        (case eta_XEA of
         { (a1_ae2pE, a2_ae2pF, a3_ae2pG, a4_ae2pH, a5_ae2pI, a6_ae2pJ) ->
         let {
           k_se9sa [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
             :: forall d1 b1.
                Data d1 =>
                Mp m_ae4KZ (d1 -> b1) -> d1 -> m_ae4KZ (b1, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_se9sa
             = \ (@ d1_ae2Ws)
                 (@ b1_ae2Wt)
                 ($dData6_ae2Wv :: Data d1_ae2Ws)
                 (ds1_de7oC [OS=OneShot] :: Mp m_ae4KZ (d1_ae2Ws -> b1_ae2Wt))
                 (y_ae1Tz [OS=OneShot] :: d1_ae2Ws) ->
                 let {
                   lvl271_se9Js :: m_ae4KZ d1_ae2Ws
                   [LclId]
                   lvl271_se9Js = ds_de7Bx @ d1_ae2Ws $dData6_ae2Wv y_ae1Tz } in
                 >>=
                   @ m_ae4KZ
                   $dMonad_se9sb
                   @ (d1_ae2Ws -> b1_ae2Wt, Bool)
                   @ (b1_ae2Wt, Bool)
                   (ds1_de7oC
                    `cast` (Data.Data.N:Mp[0] <m_ae4KZ>_R <d1_ae2Ws -> b1_ae2Wt>_N
                            :: (Mp m_ae4KZ (d1_ae2Ws -> b1_ae2Wt) :: *)
                               ~R# (m_ae4KZ (d1_ae2Ws -> b1_ae2Wt, Bool) :: *)))
                   (\ (ds2_de7oD :: (d1_ae2Ws -> b1_ae2Wt, Bool)) ->
                      case ds2_de7oD of { (h_ae1TA, b2_ae1TB) ->
                      mplus
                        @ m_ae4KZ
                        $dMonadPlus_ae4L1
                        @ (b1_ae2Wt, Bool)
                        (>>=
                           @ m_ae4KZ
                           $dMonad_se9sb
                           @ d1_ae2Ws
                           @ (b1_ae2Wt, Bool)
                           lvl271_se9Js
                           (\ (y'_ae1TC :: d1_ae2Ws) ->
                              return
                                @ m_ae4KZ
                                $dMonad_se9sb
                                @ (b1_ae2Wt, Bool)
                                (h_ae1TA y'_ae1TC, GHC.Types.True)))
                        (return
                           @ m_ae4KZ
                           $dMonad_se9sb
                           @ (b1_ae2Wt, Bool)
                           (h_ae1TA y_ae1Tz, b2_ae1TB))
                      }) } in
         k_se9sa
           @ f_Xe5kF
           @ (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD, f_Xe5kF)
           $dData5_Xe5kR
           ((k_se9sa
               @ e_Xe5kD
               @ (f_Xe5kF
                  -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD, f_Xe5kF))
               $dData4_Xe5kP
               ((k_se9sa
                   @ d_Xe5kB
                   @ (e_Xe5kD
                      -> f_Xe5kF
                      -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD, f_Xe5kF))
                   $dData3_Xe5kN
                   ((k_se9sa
                       @ c_Xe5kz
                       @ (d_Xe5kB
                          -> e_Xe5kD
                          -> f_Xe5kF
                          -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD, f_Xe5kF))
                       $dData2_Xe5kL
                       ((k_se9sa
                           @ b_Xe5kx
                           @ (c_Xe5kz
                              -> d_Xe5kB
                              -> e_Xe5kD
                              -> f_Xe5kF
                              -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD, f_Xe5kF))
                           $dData1_Xe5kJ
                           ((k_se9sa
                               @ a_Xe5kv
                               @ (b_Xe5kx
                                  -> c_Xe5kz
                                  -> d_Xe5kB
                                  -> e_Xe5kD
                                  -> f_Xe5kF
                                  -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD, f_Xe5kF))
                               $dData_Xe5kH
                               ((return
                                   @ m_ae4KZ
                                   $dMonad_se9sb
                                   @ (a_Xe5kv
                                      -> b_Xe5kx
                                      -> c_Xe5kz
                                      -> d_Xe5kB
                                      -> e_Xe5kD
                                      -> f_Xe5kF
                                      -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD, f_Xe5kF),
                                      Bool)
                                   (lvl120_rejQb
                                      @ b_Xe5kx @ a_Xe5kv @ c_Xe5kz @ d_Xe5kB @ e_Xe5kD @ f_Xe5kF))
                                `cast` (Sym (Data.Data.N:Mp[0]
                                                 <m_ae4KZ>_R
                                                 <a_Xe5kv
                                                  -> b_Xe5kx
                                                  -> c_Xe5kz
                                                  -> d_Xe5kB
                                                  -> e_Xe5kD
                                                  -> f_Xe5kF
                                                  -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD,
                                                      f_Xe5kF)>_N)
                                        :: (m_ae4KZ (a_Xe5kv
                                                     -> b_Xe5kx
                                                     -> c_Xe5kz
                                                     -> d_Xe5kB
                                                     -> e_Xe5kD
                                                     -> f_Xe5kF
                                                     -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB,
                                                         e_Xe5kD, f_Xe5kF),
                                                     Bool) :: *)
                                           ~R# (Mp
                                                  m_ae4KZ
                                                  (a_Xe5kv
                                                   -> b_Xe5kx
                                                   -> c_Xe5kz
                                                   -> d_Xe5kB
                                                   -> e_Xe5kD
                                                   -> f_Xe5kF
                                                   -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD,
                                                       f_Xe5kF)) :: *)))
                               a1_ae2pE)
                            `cast` (Sym (Data.Data.N:Mp[0]
                                             <m_ae4KZ>_R
                                             <b_Xe5kx
                                              -> c_Xe5kz
                                              -> d_Xe5kB
                                              -> e_Xe5kD
                                              -> f_Xe5kF
                                              -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD,
                                                  f_Xe5kF)>_N)
                                    :: (m_ae4KZ (b_Xe5kx
                                                 -> c_Xe5kz
                                                 -> d_Xe5kB
                                                 -> e_Xe5kD
                                                 -> f_Xe5kF
                                                 -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD,
                                                     f_Xe5kF),
                                                 Bool) :: *)
                                       ~R# (Mp
                                              m_ae4KZ
                                              (b_Xe5kx
                                               -> c_Xe5kz
                                               -> d_Xe5kB
                                               -> e_Xe5kD
                                               -> f_Xe5kF
                                               -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD,
                                                   f_Xe5kF)) :: *)))
                           a2_ae2pF)
                        `cast` (Sym (Data.Data.N:Mp[0]
                                         <m_ae4KZ>_R
                                         <c_Xe5kz
                                          -> d_Xe5kB
                                          -> e_Xe5kD
                                          -> f_Xe5kF
                                          -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD,
                                              f_Xe5kF)>_N)
                                :: (m_ae4KZ (c_Xe5kz
                                             -> d_Xe5kB
                                             -> e_Xe5kD
                                             -> f_Xe5kF
                                             -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD,
                                                 f_Xe5kF),
                                             Bool) :: *)
                                   ~R# (Mp
                                          m_ae4KZ
                                          (c_Xe5kz
                                           -> d_Xe5kB
                                           -> e_Xe5kD
                                           -> f_Xe5kF
                                           -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD,
                                               f_Xe5kF)) :: *)))
                       a3_ae2pG)
                    `cast` (Sym (Data.Data.N:Mp[0]
                                     <m_ae4KZ>_R
                                     <d_Xe5kB
                                      -> e_Xe5kD
                                      -> f_Xe5kF
                                      -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD, f_Xe5kF)>_N)
                            :: (m_ae4KZ (d_Xe5kB
                                         -> e_Xe5kD
                                         -> f_Xe5kF
                                         -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD, f_Xe5kF),
                                         Bool) :: *)
                               ~R# (Mp
                                      m_ae4KZ
                                      (d_Xe5kB
                                       -> e_Xe5kD
                                       -> f_Xe5kF
                                       -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD,
                                           f_Xe5kF)) :: *)))
                   a4_ae2pH)
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_ae4KZ>_R
                                 <e_Xe5kD
                                  -> f_Xe5kF
                                  -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD, f_Xe5kF)>_N)
                        :: (m_ae4KZ (e_Xe5kD
                                     -> f_Xe5kF
                                     -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD, f_Xe5kF),
                                     Bool) :: *)
                           ~R# (Mp
                                  m_ae4KZ
                                  (e_Xe5kD
                                   -> f_Xe5kF
                                   -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD,
                                       f_Xe5kF)) :: *)))
               a5_ae2pI)
            `cast` (Sym (Data.Data.N:Mp[0]
                             <m_ae4KZ>_R
                             <f_Xe5kF
                              -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD, f_Xe5kF)>_N)
                    :: (m_ae4KZ (f_Xe5kF
                                 -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD, f_Xe5kF),
                                 Bool) :: *)
                       ~R# (Mp
                              m_ae4KZ
                              (f_Xe5kF
                               -> (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD, f_Xe5kF)) :: *)))
           a6_ae2pJ
         })
        (\ (ds1_de7oa
              :: ((a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD, f_Xe5kF),
                  Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b1_ae1TE) ->
           case b1_ae1TE of {
             False -> lvl270_se9Ju;
             True ->
               return
                 @ m_ae4KZ
                 $dMonad_se9sb
                 @ (a_Xe5kv, b_Xe5kx, c_Xe5kz, d_Xe5kB, e_Xe5kD, f_Xe5kF)
                 x'_ae1TD
           }
           })

-- RHS size: {terms: 62, types: 177, coercions: 0, joins: 0/2}
Data.Data.$fData(,,,,,)_$cgmapM
  :: forall a b c d e f.
     (Data a, Data b, Data c, Data d, Data e, Data f) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d1. Data d1 => d1 -> m d1)
     -> (a, b, c, d, e, f) -> m (a, b, c, d, e, f)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 120 60 20] 510 0}]
Data.Data.$fData(,,,,,)_$cgmapM
  = \ (@ a_Xe5ku)
      (@ b_Xe5kw)
      (@ c_Xe5ky)
      (@ d_Xe5kA)
      (@ e_Xe5kC)
      (@ f_Xe5kE)
      ($dData_Xe5kG :: Data a_Xe5ku)
      ($dData1_Xe5kI :: Data b_Xe5kw)
      ($dData2_Xe5kK :: Data c_Xe5ky)
      ($dData3_Xe5kM :: Data d_Xe5kA)
      ($dData4_Xe5kO :: Data e_Xe5kC)
      ($dData5_Xe5kQ :: Data f_Xe5kE)
      (@ (m_ae4KJ :: * -> *))
      ($dMonad_ae4KL :: Monad m_ae4KJ)
      (ds_de7Bw :: forall d1. Data d1 => d1 -> m_ae4KJ d1)
      (eta_XEB
         :: (a_Xe5ku, b_Xe5kw, c_Xe5ky, d_Xe5kA, e_Xe5kC, f_Xe5kE)) ->
      case eta_XEB of
      { (a1_ae2pE, a2_ae2pF, a3_ae2pG, a4_ae2pH, a5_ae2pI, a6_ae2pJ) ->
      let {
        k_se9s7 [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
          :: forall d1 b1. Data d1 => m_ae4KJ (d1 -> b1) -> d1 -> m_ae4KJ b1
        [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
        k_se9s7
          = \ (@ d1_ae2Vh)
              (@ b1_ae2Vi)
              ($dData6_ae2Vk :: Data d1_ae2Vh)
              (c1_ae1Tm [OS=OneShot] :: m_ae4KJ (d1_ae2Vh -> b1_ae2Vi))
              (x_ae1Tn [OS=OneShot] :: d1_ae2Vh) ->
              let {
                lvl270_se9Jv :: m_ae4KJ d1_ae2Vh
                [LclId]
                lvl270_se9Jv = ds_de7Bw @ d1_ae2Vh $dData6_ae2Vk x_ae1Tn } in
              >>=
                @ m_ae4KJ
                $dMonad_ae4KL
                @ (d1_ae2Vh -> b1_ae2Vi)
                @ b1_ae2Vi
                c1_ae1Tm
                (\ (c'_ae1To :: d1_ae2Vh -> b1_ae2Vi) ->
                   >>=
                     @ m_ae4KJ
                     $dMonad_ae4KL
                     @ d1_ae2Vh
                     @ b1_ae2Vi
                     lvl270_se9Jv
                     (\ (x'_ae1Tp :: d1_ae2Vh) ->
                        return
                          @ m_ae4KJ $dMonad_ae4KL @ b1_ae2Vi (c'_ae1To x'_ae1Tp))) } in
      k_se9s7
        @ f_Xe5kE
        @ (a_Xe5ku, b_Xe5kw, c_Xe5ky, d_Xe5kA, e_Xe5kC, f_Xe5kE)
        $dData5_Xe5kQ
        (k_se9s7
           @ e_Xe5kC
           @ (f_Xe5kE
              -> (a_Xe5ku, b_Xe5kw, c_Xe5ky, d_Xe5kA, e_Xe5kC, f_Xe5kE))
           $dData4_Xe5kO
           (k_se9s7
              @ d_Xe5kA
              @ (e_Xe5kC
                 -> f_Xe5kE
                 -> (a_Xe5ku, b_Xe5kw, c_Xe5ky, d_Xe5kA, e_Xe5kC, f_Xe5kE))
              $dData3_Xe5kM
              (k_se9s7
                 @ c_Xe5ky
                 @ (d_Xe5kA
                    -> e_Xe5kC
                    -> f_Xe5kE
                    -> (a_Xe5ku, b_Xe5kw, c_Xe5ky, d_Xe5kA, e_Xe5kC, f_Xe5kE))
                 $dData2_Xe5kK
                 (k_se9s7
                    @ b_Xe5kw
                    @ (c_Xe5ky
                       -> d_Xe5kA
                       -> e_Xe5kC
                       -> f_Xe5kE
                       -> (a_Xe5ku, b_Xe5kw, c_Xe5ky, d_Xe5kA, e_Xe5kC, f_Xe5kE))
                    $dData1_Xe5kI
                    (k_se9s7
                       @ a_Xe5ku
                       @ (b_Xe5kw
                          -> c_Xe5ky
                          -> d_Xe5kA
                          -> e_Xe5kC
                          -> f_Xe5kE
                          -> (a_Xe5ku, b_Xe5kw, c_Xe5ky, d_Xe5kA, e_Xe5kC, f_Xe5kE))
                       $dData_Xe5kG
                       (return
                          @ m_ae4KJ
                          $dMonad_ae4KL
                          @ (a_Xe5ku
                             -> b_Xe5kw
                             -> c_Xe5ky
                             -> d_Xe5kA
                             -> e_Xe5kC
                             -> f_Xe5kE
                             -> (a_Xe5ku, b_Xe5kw, c_Xe5ky, d_Xe5kA, e_Xe5kC, f_Xe5kE))
                          (GHC.Tuple.(,,,,,)
                             @ a_Xe5ku @ b_Xe5kw @ c_Xe5ky @ d_Xe5kA @ e_Xe5kC @ f_Xe5kE))
                       a1_ae2pE)
                    a2_ae2pF)
                 a3_ae2pG)
              a4_ae2pH)
           a5_ae2pI)
        a6_ae2pJ
      }

-- RHS size: {terms: 50, types: 63, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,,)_$cgmapQi
  :: forall a b c d e f.
     (Data a, Data b, Data c, Data d, Data e, Data f) =>
     forall u.
     Int -> (forall d1. Data d1 => d1 -> u) -> (a, b, c, d, e, f) -> u
[GblId,
 Arity=9,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 20 360 20] 270 0}]
Data.Data.$fData(,,,,,)_$cgmapQi
  = \ (@ a_Xe5kt)
      (@ b_Xe5kv)
      (@ c_Xe5kx)
      (@ d_Xe5kz)
      (@ e_Xe5kB)
      (@ f_Xe5kD)
      ($dData_Xe5kF :: Data a_Xe5kt)
      ($dData1_Xe5kH :: Data b_Xe5kv)
      ($dData2_Xe5kJ :: Data c_Xe5kx)
      ($dData3_Xe5kL :: Data d_Xe5kz)
      ($dData4_Xe5kN :: Data e_Xe5kB)
      ($dData5_Xe5kP :: Data f_Xe5kD)
      (@ u_ae4Kv)
      (ds_de7Bu :: Int)
      (ds1_de7Bv :: forall d1. Data d1 => d1 -> u_ae4Kv)
      (x_ae1T7
         :: (a_Xe5kt, b_Xe5kv, c_Xe5kx, d_Xe5kz, e_Xe5kB, f_Xe5kD)) ->
      case x_ae1T7 of
      { (a1_ae2pE, a2_ae2pF, a3_ae2pG, a4_ae2pH, a5_ae2pI, a6_ae2pJ) ->
      case ds_de7Bu of { I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_ae4Kv;
        0# -> ds1_de7Bv @ a_Xe5kt $dData_Xe5kF a1_ae2pE;
        1# -> ds1_de7Bv @ b_Xe5kv $dData1_Xe5kH a2_ae2pF;
        2# -> ds1_de7Bv @ c_Xe5kx $dData2_Xe5kJ a3_ae2pG;
        3# -> ds1_de7Bv @ d_Xe5kz $dData3_Xe5kL a4_ae2pH;
        4# -> ds1_de7Bv @ e_Xe5kB $dData4_Xe5kN a5_ae2pI;
        5# -> ds1_de7Bv @ f_Xe5kD $dData5_Xe5kP a6_ae2pJ
      }
      }
      }

-- RHS size: {terms: 46, types: 64, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,,)_$cgmapQr
  :: forall a b c d e f.
     (Data a, Data b, Data c, Data d, Data e, Data f) =>
     forall r r'.
     (r' -> r -> r)
     -> r -> (forall d1. Data d1 => d1 -> r') -> (a, b, c, d, e, f) -> r
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 60 0 360 20] 370 0}]
Data.Data.$fData(,,,,,)_$cgmapQr
  = \ (@ a_Xe5kr)
      (@ b_Xe5kt)
      (@ c_Xe5kv)
      (@ d_Xe5kx)
      (@ e_Xe5kz)
      (@ f_Xe5kB)
      ($dData_Xe5kD :: Data a_Xe5kr)
      ($dData1_Xe5kF :: Data b_Xe5kt)
      ($dData2_Xe5kH :: Data c_Xe5kv)
      ($dData3_Xe5kJ :: Data d_Xe5kx)
      ($dData4_Xe5kL :: Data e_Xe5kz)
      ($dData5_Xe5kN :: Data f_Xe5kB)
      (@ r_ae4K0)
      (@ r'_ae4K1)
      (ds_de7Bq :: r'_ae4K1 -> r_ae4K0 -> r_ae4K0)
      (ds1_de7Br :: r_ae4K0)
      (ds2_de7Bs :: forall d1. Data d1 => d1 -> r'_ae4K1)
      (x0_ae1SX
         :: (a_Xe5kr, b_Xe5kt, c_Xe5kv, d_Xe5kx, e_Xe5kz, f_Xe5kB)) ->
      case x0_ae1SX of
      { (a1_ae2pE, a2_ae2pF, a3_ae2pG, a4_ae2pH, a5_ae2pI, a6_ae2pJ) ->
      ds_de7Bq
        (ds2_de7Bs @ a_Xe5kr $dData_Xe5kD a1_ae2pE)
        (ds_de7Bq
           (ds2_de7Bs @ b_Xe5kt $dData1_Xe5kF a2_ae2pF)
           (ds_de7Bq
              (ds2_de7Bs @ c_Xe5kv $dData2_Xe5kH a3_ae2pG)
              (ds_de7Bq
                 (ds2_de7Bs @ d_Xe5kx $dData3_Xe5kJ a4_ae2pH)
                 (ds_de7Bq
                    (ds2_de7Bs @ e_Xe5kz $dData4_Xe5kL a5_ae2pI)
                    (ds_de7Bq
                       (ds2_de7Bs @ f_Xe5kB $dData5_Xe5kN a6_ae2pJ) ds1_de7Br)))))
      }

-- RHS size: {terms: 24, types: 43, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,,)_$cgmapQ
  :: forall a b c d e f.
     (Data a, Data b, Data c, Data d, Data e, Data f) =>
     forall u.
     (forall d1. Data d1 => d1 -> u) -> (a, b, c, d, e, f) -> [u]
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,C(C1(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=7,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe5ks)
                 (@ b_Xe5ku)
                 (@ c_Xe5kw)
                 (@ d_Xe5ky)
                 (@ e_Xe5kA)
                 (@ f_Xe5kC)
                 ($dData_Xe5kE [Occ=Once] :: Data a_Xe5ks)
                 ($dData1_Xe5kG [Occ=Once] :: Data b_Xe5ku)
                 ($dData2_Xe5kI [Occ=Once] :: Data c_Xe5kw)
                 ($dData3_Xe5kK [Occ=Once] :: Data d_Xe5ky)
                 ($dData4_Xe5kM [Occ=Once] :: Data e_Xe5kA)
                 ($dData5_Xe5kO [Occ=Once] :: Data f_Xe5kC)
                 (@ u_ae4Kh)
                 (ds_de7Bt [Occ=Once] :: forall d1. Data d1 => d1 -> u_ae4Kh) ->
                 Data.Data.$fData(,,,,,)_$cgmapQr
                   @ a_Xe5ks
                   @ b_Xe5ku
                   @ c_Xe5kw
                   @ d_Xe5ky
                   @ e_Xe5kA
                   @ f_Xe5kC
                   $dData_Xe5kE
                   $dData1_Xe5kG
                   $dData2_Xe5kI
                   $dData3_Xe5kK
                   $dData4_Xe5kM
                   $dData5_Xe5kO
                   @ [u_ae4Kh]
                   @ u_ae4Kh
                   (GHC.Types.: @ u_ae4Kh)
                   (GHC.Types.[] @ u_ae4Kh)
                   ds_de7Bt}]
Data.Data.$fData(,,,,,)_$cgmapQ
  = \ (@ a_Xe5ks)
      (@ b_Xe5ku)
      (@ c_Xe5kw)
      (@ d_Xe5ky)
      (@ e_Xe5kA)
      (@ f_Xe5kC)
      ($dData_Xe5kE :: Data a_Xe5ks)
      ($dData1_Xe5kG :: Data b_Xe5ku)
      ($dData2_Xe5kI :: Data c_Xe5kw)
      ($dData3_Xe5kK :: Data d_Xe5ky)
      ($dData4_Xe5kM :: Data e_Xe5kA)
      ($dData5_Xe5kO :: Data f_Xe5kC)
      (@ u_ae4Kh)
      (ds_de7Bt :: forall d1. Data d1 => d1 -> u_ae4Kh) ->
      Data.Data.$fData(,,,,,)_$cgmapQr
        @ a_Xe5ks
        @ b_Xe5ku
        @ c_Xe5kw
        @ d_Xe5ky
        @ e_Xe5kA
        @ f_Xe5kC
        $dData_Xe5kE
        $dData1_Xe5kG
        $dData2_Xe5kI
        $dData3_Xe5kK
        $dData4_Xe5kM
        $dData5_Xe5kO
        @ [u_ae4Kh]
        @ u_ae4Kh
        (GHC.Types.: @ u_ae4Kh)
        (GHC.Types.[] @ u_ae4Kh)
        ds_de7Bt

-- RHS size: {terms: 46, types: 64, coercions: 12, joins: 0/0}
Data.Data.$fData(,,,,,)1
  :: forall a b c d e f.
     (Data a, Data b, Data c, Data d, Data e, Data f) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d1. Data d1 => d1 -> r')
     -> (a, b, c, d, e, f)
     -> Const r (a, b, c, d, e, f)
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 60 0 360 20] 370 0}]
Data.Data.$fData(,,,,,)1
  = \ (@ a_Xe5kq)
      (@ b_Xe5ks)
      (@ c_Xe5ku)
      (@ d_Xe5kw)
      (@ e_Xe5ky)
      (@ f_Xe5kA)
      ($dData_Xe5kC :: Data a_Xe5kq)
      ($dData1_Xe5kE :: Data b_Xe5ks)
      ($dData2_Xe5kG :: Data c_Xe5ku)
      ($dData3_Xe5kI :: Data d_Xe5kw)
      ($dData4_Xe5kK :: Data e_Xe5ky)
      ($dData5_Xe5kM :: Data f_Xe5kA)
      (@ r_ae4JJ)
      (@ r'_ae4JK)
      (ds_de7Bn :: r_ae4JJ -> r'_ae4JK -> r_ae4JJ)
      (ds1_de7Bo :: r_ae4JJ)
      (ds2_de7Bp :: forall d1. Data d1 => d1 -> r'_ae4JK)
      (eta_XEH
         :: (a_Xe5kq, b_Xe5ks, c_Xe5ku, d_Xe5kw, e_Xe5ky, f_Xe5kA)) ->
      case eta_XEH of
      { (a1_ae2pE, a2_ae2pF, a3_ae2pG, a4_ae2pH, a5_ae2pI, a6_ae2pJ) ->
      (ds_de7Bn
         (ds_de7Bn
            (ds_de7Bn
               (ds_de7Bn
                  (ds_de7Bn
                     (ds_de7Bn ds1_de7Bo (ds2_de7Bp @ a_Xe5kq $dData_Xe5kC a1_ae2pE))
                     (ds2_de7Bp @ b_Xe5ks $dData1_Xe5kE a2_ae2pF))
                  (ds2_de7Bp @ c_Xe5ku $dData2_Xe5kG a3_ae2pG))
               (ds2_de7Bp @ d_Xe5kw $dData3_Xe5kI a4_ae2pH))
            (ds2_de7Bp @ e_Xe5ky $dData4_Xe5kK a5_ae2pI))
         (ds2_de7Bp @ f_Xe5kA $dData5_Xe5kM a6_ae2pJ))
      `cast` (Sym (Data.Functor.Const.N:Const[0]
                       <*>_N
                       <r_ae4JJ>_R
                       <(a_Xe5kq, b_Xe5ks, c_Xe5ku, d_Xe5kw, e_Xe5ky, f_Xe5kA)>_P)
              :: (r_ae4JJ :: *)
                 ~R# (Const
                        r_ae4JJ
                        (a_Xe5kq, b_Xe5ks, c_Xe5ku, d_Xe5kw, e_Xe5ky, f_Xe5kA) :: *))
      }

-- RHS size: {terms: 36, types: 62, coercions: 9, joins: 0/0}
Data.Data.$fData(,,,,,)2
  :: forall a b c d e f.
     (Data a, Data b, Data c, Data d, Data e, Data f) =>
     (forall b1. Data b1 => b1 -> b1)
     -> (a, b, c, d, e, f) -> Identity (a, b, c, d, e, f)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,C(C1(U))><S,1*U(U,U,U,U,U,U)>m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 360 20] 200 70}]
Data.Data.$fData(,,,,,)2
  = \ (@ a_Xe5kp)
      (@ b_Xe5kr)
      (@ c_Xe5kt)
      (@ d_Xe5kv)
      (@ e_Xe5kx)
      (@ f_Xe5kz)
      ($dData_Xe5kB :: Data a_Xe5kp)
      ($dData1_Xe5kD :: Data b_Xe5kr)
      ($dData2_Xe5kF :: Data c_Xe5kt)
      ($dData3_Xe5kH :: Data d_Xe5kv)
      ($dData4_Xe5kJ :: Data e_Xe5kx)
      ($dData5_Xe5kL :: Data f_Xe5kz)
      (ds_de7Bm :: forall b1. Data b1 => b1 -> b1)
      (x0_Xe2Yi
         :: (a_Xe5kp, b_Xe5kr, c_Xe5kt, d_Xe5kv, e_Xe5kx, f_Xe5kz)) ->
      case x0_Xe2Yi of
      { (a1_ae2pE, a2_ae2pF, a3_ae2pG, a4_ae2pH, a5_ae2pI, a6_ae2pJ) ->
      (ds_de7Bm @ a_Xe5kp $dData_Xe5kB a1_ae2pE,
       ds_de7Bm @ b_Xe5kr $dData1_Xe5kD a2_ae2pF,
       ds_de7Bm @ c_Xe5kt $dData2_Xe5kF a3_ae2pG,
       ds_de7Bm @ d_Xe5kv $dData3_Xe5kH a4_ae2pH,
       ds_de7Bm @ e_Xe5kx $dData4_Xe5kJ a5_ae2pI,
       ds_de7Bm @ f_Xe5kz $dData5_Xe5kL a6_ae2pJ)
      `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                       <(a_Xe5kp, b_Xe5kr, c_Xe5kt, d_Xe5kv, e_Xe5kx, f_Xe5kz)>_R)
              :: ((a_Xe5kp, b_Xe5kr, c_Xe5kt, d_Xe5kv, e_Xe5kx, f_Xe5kz) :: *)
                 ~R# (Identity
                        (a_Xe5kp, b_Xe5kr, c_Xe5kt, d_Xe5kv, e_Xe5kx, f_Xe5kz) :: *))
      }

-- RHS size: {terms: 105, types: 290, coercions: 85, joins: 0/4}
Data.Data.$fData(,,,,,)_$cgmapMo
  :: forall a b c d e f.
     (Data a, Data b, Data c, Data d, Data e, Data f) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d1. Data d1 => d1 -> m d1)
     -> (a, b, c, d, e, f) -> m (a, b, c, d, e, f)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U,U,U,U,U)>,
 Unf=OtherCon []]
Data.Data.$fData(,,,,,)_$cgmapMo
  = \ (@ a_Xe5kn)
      (@ b_Xe5Zo)
      (@ c_Xe5Zr)
      (@ d_Xe5Zu)
      (@ e_Xe5Zx)
      (@ f_Xe5ZA)
      ($dData_Xe5ZD :: Data a_Xe5kn)
      ($dData1_Xe5ZG :: Data b_Xe5Zo)
      ($dData2_Xe5ZJ :: Data c_Xe5Zr)
      ($dData3_Xe5ZM :: Data d_Xe5Zu)
      ($dData4_Xe5ZP :: Data e_Xe5Zx)
      ($dData5_Xe5ZS :: Data f_Xe5ZA)
      (@ (m_ae4Lf :: * -> *))
      ($dMonadPlus_ae4Lh :: MonadPlus m_ae4Lf)
      (ds_de7By :: forall d1. Data d1 => d1 -> m_ae4Lf d1)
      (eta_XFe
         :: (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA)) ->
      let {
        lvl270_se9JA
          :: m_ae4Lf (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA)
        [LclId]
        lvl270_se9JA
          = mzero
              @ m_ae4Lf
              $dMonadPlus_ae4Lh
              @ (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA) } in
      let {
        $dMonad_se9s3 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae4Lf
        [LclId]
        $dMonad_se9s3
          = GHC.Base.$p2MonadPlus @ m_ae4Lf $dMonadPlus_ae4Lh } in
      >>=
        @ m_ae4Lf
        $dMonad_se9s3
        @ ((a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA), Bool)
        @ (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA)
        (case eta_XFe of
         { (a1_ae2pE, a2_ae2pF, a3_ae2pG, a4_ae2pH, a5_ae2pI, a6_ae2pJ) ->
         let {
           k_se9s2 [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
             :: forall d1 b1.
                Data d1 =>
                Mp m_ae4Lf (d1 -> b1) -> d1 -> m_ae4Lf (b1, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_se9s2
             = \ (@ d1_ae2Ya)
                 (@ b1_ae2Yb)
                 ($dData6_ae2Yd :: Data d1_ae2Ya)
                 (ds1_de7pC [OS=OneShot] :: Mp m_ae4Lf (d1_ae2Ya -> b1_ae2Yb))
                 (y_ae1TO [OS=OneShot] :: d1_ae2Ya) ->
                 let {
                   lvl271_se9Jy :: m_ae4Lf d1_ae2Ya
                   [LclId]
                   lvl271_se9Jy = ds_de7By @ d1_ae2Ya $dData6_ae2Yd y_ae1TO } in
                 >>=
                   @ m_ae4Lf
                   $dMonad_se9s3
                   @ (d1_ae2Ya -> b1_ae2Yb, Bool)
                   @ (b1_ae2Yb, Bool)
                   (ds1_de7pC
                    `cast` (Data.Data.N:Mp[0] <m_ae4Lf>_R <d1_ae2Ya -> b1_ae2Yb>_N
                            :: (Mp m_ae4Lf (d1_ae2Ya -> b1_ae2Yb) :: *)
                               ~R# (m_ae4Lf (d1_ae2Ya -> b1_ae2Yb, Bool) :: *)))
                   (\ (ds2_de7pD :: (d1_ae2Ya -> b1_ae2Yb, Bool)) ->
                      case ds2_de7pD of { (h_ae1TP, b2_ae1TQ) ->
                      case b2_ae1TQ of {
                        False ->
                          mplus
                            @ m_ae4Lf
                            $dMonadPlus_ae4Lh
                            @ (b1_ae2Yb, Bool)
                            (>>=
                               @ m_ae4Lf
                               $dMonad_se9s3
                               @ d1_ae2Ya
                               @ (b1_ae2Yb, Bool)
                               lvl271_se9Jy
                               (\ (y'_ae1TR :: d1_ae2Ya) ->
                                  return
                                    @ m_ae4Lf
                                    $dMonad_se9s3
                                    @ (b1_ae2Yb, Bool)
                                    (h_ae1TP y'_ae1TR, GHC.Types.True)))
                            (return
                               @ m_ae4Lf
                               $dMonad_se9s3
                               @ (b1_ae2Yb, Bool)
                               (h_ae1TP y_ae1TO, GHC.Types.False));
                        True ->
                          return
                            @ m_ae4Lf
                            $dMonad_se9s3
                            @ (b1_ae2Yb, Bool)
                            (h_ae1TP y_ae1TO, GHC.Types.True)
                      }
                      }) } in
         k_se9s2
           @ f_Xe5ZA
           @ (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA)
           $dData5_Xe5ZS
           ((k_se9s2
               @ e_Xe5Zx
               @ (f_Xe5ZA
                  -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA))
               $dData4_Xe5ZP
               ((k_se9s2
                   @ d_Xe5Zu
                   @ (e_Xe5Zx
                      -> f_Xe5ZA
                      -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA))
                   $dData3_Xe5ZM
                   ((k_se9s2
                       @ c_Xe5Zr
                       @ (d_Xe5Zu
                          -> e_Xe5Zx
                          -> f_Xe5ZA
                          -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA))
                       $dData2_Xe5ZJ
                       ((k_se9s2
                           @ b_Xe5Zo
                           @ (c_Xe5Zr
                              -> d_Xe5Zu
                              -> e_Xe5Zx
                              -> f_Xe5ZA
                              -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA))
                           $dData1_Xe5ZG
                           ((k_se9s2
                               @ a_Xe5kn
                               @ (b_Xe5Zo
                                  -> c_Xe5Zr
                                  -> d_Xe5Zu
                                  -> e_Xe5Zx
                                  -> f_Xe5ZA
                                  -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA))
                               $dData_Xe5ZD
                               ((return
                                   @ m_ae4Lf
                                   $dMonad_se9s3
                                   @ (a_Xe5kn
                                      -> b_Xe5Zo
                                      -> c_Xe5Zr
                                      -> d_Xe5Zu
                                      -> e_Xe5Zx
                                      -> f_Xe5ZA
                                      -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA),
                                      Bool)
                                   (lvl120_rejQb
                                      @ b_Xe5Zo @ a_Xe5kn @ c_Xe5Zr @ d_Xe5Zu @ e_Xe5Zx @ f_Xe5ZA))
                                `cast` (Sym (Data.Data.N:Mp[0]
                                                 <m_ae4Lf>_R
                                                 <a_Xe5kn
                                                  -> b_Xe5Zo
                                                  -> c_Xe5Zr
                                                  -> d_Xe5Zu
                                                  -> e_Xe5Zx
                                                  -> f_Xe5ZA
                                                  -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx,
                                                      f_Xe5ZA)>_N)
                                        :: (m_ae4Lf (a_Xe5kn
                                                     -> b_Xe5Zo
                                                     -> c_Xe5Zr
                                                     -> d_Xe5Zu
                                                     -> e_Xe5Zx
                                                     -> f_Xe5ZA
                                                     -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu,
                                                         e_Xe5Zx, f_Xe5ZA),
                                                     Bool) :: *)
                                           ~R# (Mp
                                                  m_ae4Lf
                                                  (a_Xe5kn
                                                   -> b_Xe5Zo
                                                   -> c_Xe5Zr
                                                   -> d_Xe5Zu
                                                   -> e_Xe5Zx
                                                   -> f_Xe5ZA
                                                   -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx,
                                                       f_Xe5ZA)) :: *)))
                               a1_ae2pE)
                            `cast` (Sym (Data.Data.N:Mp[0]
                                             <m_ae4Lf>_R
                                             <b_Xe5Zo
                                              -> c_Xe5Zr
                                              -> d_Xe5Zu
                                              -> e_Xe5Zx
                                              -> f_Xe5ZA
                                              -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx,
                                                  f_Xe5ZA)>_N)
                                    :: (m_ae4Lf (b_Xe5Zo
                                                 -> c_Xe5Zr
                                                 -> d_Xe5Zu
                                                 -> e_Xe5Zx
                                                 -> f_Xe5ZA
                                                 -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx,
                                                     f_Xe5ZA),
                                                 Bool) :: *)
                                       ~R# (Mp
                                              m_ae4Lf
                                              (b_Xe5Zo
                                               -> c_Xe5Zr
                                               -> d_Xe5Zu
                                               -> e_Xe5Zx
                                               -> f_Xe5ZA
                                               -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx,
                                                   f_Xe5ZA)) :: *)))
                           a2_ae2pF)
                        `cast` (Sym (Data.Data.N:Mp[0]
                                         <m_ae4Lf>_R
                                         <c_Xe5Zr
                                          -> d_Xe5Zu
                                          -> e_Xe5Zx
                                          -> f_Xe5ZA
                                          -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx,
                                              f_Xe5ZA)>_N)
                                :: (m_ae4Lf (c_Xe5Zr
                                             -> d_Xe5Zu
                                             -> e_Xe5Zx
                                             -> f_Xe5ZA
                                             -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx,
                                                 f_Xe5ZA),
                                             Bool) :: *)
                                   ~R# (Mp
                                          m_ae4Lf
                                          (c_Xe5Zr
                                           -> d_Xe5Zu
                                           -> e_Xe5Zx
                                           -> f_Xe5ZA
                                           -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx,
                                               f_Xe5ZA)) :: *)))
                       a3_ae2pG)
                    `cast` (Sym (Data.Data.N:Mp[0]
                                     <m_ae4Lf>_R
                                     <d_Xe5Zu
                                      -> e_Xe5Zx
                                      -> f_Xe5ZA
                                      -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA)>_N)
                            :: (m_ae4Lf (d_Xe5Zu
                                         -> e_Xe5Zx
                                         -> f_Xe5ZA
                                         -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA),
                                         Bool) :: *)
                               ~R# (Mp
                                      m_ae4Lf
                                      (d_Xe5Zu
                                       -> e_Xe5Zx
                                       -> f_Xe5ZA
                                       -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx,
                                           f_Xe5ZA)) :: *)))
                   a4_ae2pH)
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_ae4Lf>_R
                                 <e_Xe5Zx
                                  -> f_Xe5ZA
                                  -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA)>_N)
                        :: (m_ae4Lf (e_Xe5Zx
                                     -> f_Xe5ZA
                                     -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA),
                                     Bool) :: *)
                           ~R# (Mp
                                  m_ae4Lf
                                  (e_Xe5Zx
                                   -> f_Xe5ZA
                                   -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx,
                                       f_Xe5ZA)) :: *)))
               a5_ae2pI)
            `cast` (Sym (Data.Data.N:Mp[0]
                             <m_ae4Lf>_R
                             <f_Xe5ZA
                              -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA)>_N)
                    :: (m_ae4Lf (f_Xe5ZA
                                 -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA),
                                 Bool) :: *)
                       ~R# (Mp
                              m_ae4Lf
                              (f_Xe5ZA
                               -> (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA)) :: *)))
           a6_ae2pJ
         })
        (\ (ds1_de7pa
              :: ((a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA),
                  Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b1_ae1TT) ->
           case b1_ae1TT of {
             False -> lvl270_se9JA;
             True ->
               return
                 @ m_ae4Lf
                 $dMonad_se9s3
                 @ (a_Xe5kn, b_Xe5Zo, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA)
                 x'_ae1TS
           }
           })

-- RHS size: {terms: 11, types: 32, coercions: 0, joins: 0/0}
lvl121_rejQc :: forall f e d c b a. (a, b, c, d, e, f) -> Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []]
lvl121_rejQc
  = \ (@ f_Xe5ZA)
      (@ e_Xe5Zx)
      (@ d_Xe5Zu)
      (@ c_Xe5Zr)
      (@ b_Xe5ko)
      (@ a_Xe5km)
      (ds_de7Bc
         :: (a_Xe5km, b_Xe5ko, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA)) ->
      case ds_de7Bc of
      { (ds1_de7Bd, ds2_de7Be, ds3_de7Bf, ds4_de7Bg, ds5_de7Bh,
         ds6_de7Bi) ->
      Data.Data.$c(,,,,,)
      }

-- RHS size: {terms: 8, types: 19, coercions: 0, joins: 0/0}
lvl122_rejQd :: forall a b c d e f. (a, b, c, d, e, f) -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl122_rejQd
  = \ (@ a_Xe5km)
      (@ b_Xe5ko)
      (@ c_Xe5Zr)
      (@ d_Xe5Zu)
      (@ e_Xe5Zx)
      (@ f_Xe5ZA)
      _ [Occ=Dead] ->
      Data.Data.$t(,,,,,)

-- RHS size: {terms: 11, types: 41, coercions: 0, joins: 0/0}
lvl123_rejQe
  :: forall a b c1 d e f (t :: * -> *) (c2 :: * -> *).
     Typeable t =>
     (forall d1. Data d1 => c2 (t d1)) -> Maybe (c2 (a, b, c1, d, e, f))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl123_rejQe
  = \ (@ a_Xe5km)
      (@ b_Xe5ko)
      (@ c_Xe5Zr)
      (@ d_Xe5Zu)
      (@ e_Xe5Zx)
      (@ f_Xe5ZA)
      (@ (t_ae4IS :: * -> *))
      (@ (c1_ae4IT :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing
        @ (c1_ae4IT (a_Xe5km, b_Xe5ko, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA))

-- RHS size: {terms: 11, types: 50, coercions: 0, joins: 0/0}
lvl124_rejQf
  :: forall a b c1 d e f (t :: * -> * -> *) (c2 :: * -> *).
     Typeable t =>
     (forall d1 e1. (Data d1, Data e1) => c2 (t d1 e1))
     -> Maybe (c2 (a, b, c1, d, e, f))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl124_rejQf
  = \ (@ a_Xe5km)
      (@ b_Xe5ko)
      (@ c_Xe5Zr)
      (@ d_Xe5Zu)
      (@ e_Xe5Zx)
      (@ f_Xe5ZA)
      (@ (t_ae4Jb :: * -> * -> *))
      (@ (c1_ae4Jc :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing
        @ (c1_ae4Jc (a_Xe5km, b_Xe5ko, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA))

-- RHS size: {terms: 100, types: 143, coercions: 72, joins: 0/0}
Data.Data.$fData(,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e f.
     (Data a, Data b, Data c, Data d, Data e, Data f) =>
     Data (a, b, c, d, e, f)
[GblId[DFunId],
 Arity=6,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_ae1XC)
             (@ b_ae1XD)
             (@ c_ae1XE)
             (@ d_ae1XF)
             (@ e_ae1XG)
             (@ f_ae1XH)
             (v_XF6 :: Data a_ae1XC)
             (v1_XF8 :: Data b_ae1XD)
             (v2_XFa :: Data c_ae1XE)
             (v3_XFc :: Data d_ae1XF)
             (v4_B5 :: Data e_ae1XG)
             (v5_B6 :: Data f_ae1XH) ->
       Data.Data.C:Data TYPE: (a_ae1XC, b_ae1XD, c_ae1XE, d_ae1XF,
                               e_ae1XG, f_ae1XH)
                        (Data.Data.$fData(,,,,,)7
                           @ a_ae1XC
                           @ b_ae1XD
                           @ c_ae1XE
                           @ d_ae1XF
                           @ e_ae1XG
                           @ f_ae1XH
                           v_XF6
                           v1_XF8
                           v2_XFa
                           v3_XFc
                           v4_B5
                           v5_B6)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <(a_ae1XC,
                                                                                   b_ae1XD, c_ae1XE,
                                                                                   d_ae1XF, e_ae1XG,
                                                                                   f_ae1XH)>_N
                                :: (Data.Typeable.Internal.TypeRep
                                      (a_ae1XC, b_ae1XD, c_ae1XE, d_ae1XF, e_ae1XG, f_ae1XH) :: *)
                                   ~R# (Typeable
                                          (a_ae1XC, b_ae1XD, c_ae1XE, d_ae1XF, e_ae1XG,
                                           f_ae1XH) :: Constraint))
                        Data.Data.$fData(,,,,,)_$cgfoldl
                          @ a_ae1XC
                          @ b_ae1XD
                          @ c_ae1XE
                          @ d_ae1XF
                          @ e_ae1XG
                          @ f_ae1XH
                          v_XF6
                          v1_XF8
                          v2_XFa
                          v3_XFc
                          v4_B5
                          v5_B6
                        Data.Data.$fData(,,,,,)_$cgunfold
                          @ a_ae1XC
                          @ b_ae1XD
                          @ c_ae1XE
                          @ d_ae1XF
                          @ e_ae1XG
                          @ f_ae1XH
                          v_XF6
                          v1_XF8
                          v2_XFa
                          v3_XFc
                          v4_B5
                          v5_B6
                        \ (ds_de7Bc [Occ=Once!]
                             :: (a_ae1XC, b_ae1XD, c_ae1XE, d_ae1XF, e_ae1XG, f_ae1XH)) ->
                          case ds_de7Bc of
                          { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead],
                             _ [Occ=Dead], _ [Occ=Dead]) ->
                          Data.Data.$c(,,,,,)
                          }
                        \ _ [Occ=Dead] -> Data.Data.$t(,,,,,)
                        \ (@ (t_ae4IS :: * -> *))
                          (@ (c1_ae4IT :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing
                            @ (c1_ae4IT (a_ae1XC, b_ae1XD, c_ae1XE, d_ae1XF, e_ae1XG, f_ae1XH))
                        \ (@ (t_ae4Jb :: * -> * -> *))
                          (@ (c1_ae4Jc :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing
                            @ (c1_ae4Jc (a_ae1XC, b_ae1XD, c_ae1XE, d_ae1XF, e_ae1XG, f_ae1XH))
                        (Data.Data.$fData(,,,,,)2
                           @ a_ae1XC
                           @ b_ae1XD
                           @ c_ae1XE
                           @ d_ae1XF
                           @ e_ae1XG
                           @ f_ae1XH
                           v_XF6
                           v1_XF8
                           v2_XFa
                           v3_XFc
                           v4_B5
                           v5_B6)
                        `cast` (<forall b1. Data b1 => b1 -> b1>_R
                                ->_R <(a_ae1XC, b_ae1XD, c_ae1XE, d_ae1XF, e_ae1XG, f_ae1XH)>_R
                                ->_R Data.Functor.Identity.N:Identity[0]
                                         <(a_ae1XC, b_ae1XD, c_ae1XE, d_ae1XF, e_ae1XG, f_ae1XH)>_R
                                :: ((forall b1. Data b1 => b1 -> b1)
                                    -> (a_ae1XC, b_ae1XD, c_ae1XE, d_ae1XF, e_ae1XG, f_ae1XH)
                                    -> Identity
                                         (a_ae1XC, b_ae1XD, c_ae1XE, d_ae1XF, e_ae1XG,
                                          f_ae1XH) :: *)
                                   ~R# ((forall b1. Data b1 => b1 -> b1)
                                        -> (a_ae1XC, b_ae1XD, c_ae1XE, d_ae1XF, e_ae1XG, f_ae1XH)
                                        -> (a_ae1XC, b_ae1XD, c_ae1XE, d_ae1XF, e_ae1XG,
                                            f_ae1XH) :: *))
                        (Data.Data.$fData(,,,,,)1
                           @ a_ae1XC
                           @ b_ae1XD
                           @ c_ae1XE
                           @ d_ae1XF
                           @ e_ae1XG
                           @ f_ae1XH
                           v_XF6
                           v1_XF8
                           v2_XFa
                           v3_XFc
                           v4_B5
                           v5_B6)
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d1. Data d1 => d1 -> r'>_R
                                ->_R <(a_ae1XC, b_ae1XD, c_ae1XE, d_ae1XF, e_ae1XG, f_ae1XH)>_R
                                ->_R Data.Functor.Const.N:Const[0]
                                         <*>_N
                                         <r>_R
                                         <(a_ae1XC, b_ae1XD, c_ae1XE, d_ae1XF, e_ae1XG, f_ae1XH)>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d1. Data d1 => d1 -> r')
                                    -> (a_ae1XC, b_ae1XD, c_ae1XE, d_ae1XF, e_ae1XG, f_ae1XH)
                                    -> Const
                                         r
                                         (a_ae1XC, b_ae1XD, c_ae1XE, d_ae1XF, e_ae1XG,
                                          f_ae1XH) :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d1. Data d1 => d1 -> r')
                                        -> (a_ae1XC, b_ae1XD, c_ae1XE, d_ae1XF, e_ae1XG, f_ae1XH)
                                        -> r :: *))
                        Data.Data.$fData(,,,,,)_$cgmapQr
                          @ a_ae1XC
                          @ b_ae1XD
                          @ c_ae1XE
                          @ d_ae1XF
                          @ e_ae1XG
                          @ f_ae1XH
                          v_XF6
                          v1_XF8
                          v2_XFa
                          v3_XFc
                          v4_B5
                          v5_B6
                        Data.Data.$fData(,,,,,)_$cgmapQ
                          @ a_ae1XC
                          @ b_ae1XD
                          @ c_ae1XE
                          @ d_ae1XF
                          @ e_ae1XG
                          @ f_ae1XH
                          v_XF6
                          v1_XF8
                          v2_XFa
                          v3_XFc
                          v4_B5
                          v5_B6
                        Data.Data.$fData(,,,,,)_$cgmapQi
                          @ a_ae1XC
                          @ b_ae1XD
                          @ c_ae1XE
                          @ d_ae1XF
                          @ e_ae1XG
                          @ f_ae1XH
                          v_XF6
                          v1_XF8
                          v2_XFa
                          v3_XFc
                          v4_B5
                          v5_B6
                        Data.Data.$fData(,,,,,)_$cgmapM
                          @ a_ae1XC
                          @ b_ae1XD
                          @ c_ae1XE
                          @ d_ae1XF
                          @ e_ae1XG
                          @ f_ae1XH
                          v_XF6
                          v1_XF8
                          v2_XFa
                          v3_XFc
                          v4_B5
                          v5_B6
                        Data.Data.$fData(,,,,,)_$cgmapMp
                          @ a_ae1XC
                          @ b_ae1XD
                          @ c_ae1XE
                          @ d_ae1XF
                          @ e_ae1XG
                          @ f_ae1XH
                          v_XF6
                          v1_XF8
                          v2_XFa
                          v3_XFc
                          v4_B5
                          v5_B6
                        Data.Data.$fData(,,,,,)_$cgmapMo
                          @ a_ae1XC
                          @ b_ae1XD
                          @ c_ae1XE
                          @ d_ae1XF
                          @ e_ae1XG
                          @ f_ae1XH
                          v_XF6
                          v1_XF8
                          v2_XFa
                          v3_XFc
                          v4_B5
                          v5_B6]
Data.Data.$fData(,,,,,)
  = \ (@ a_Xe5km)
      (@ b_Xe5ko)
      (@ c_Xe5Zr)
      (@ d_Xe5Zu)
      (@ e_Xe5Zx)
      (@ f_Xe5ZA)
      ($dData_Xe5ZD :: Data a_Xe5km)
      ($dData1_Xe5ZG :: Data b_Xe5ko)
      ($dData2_Xe5ZJ :: Data c_Xe5Zr)
      ($dData3_Xe5ZM :: Data d_Xe5Zu)
      ($dData4_Xe5ZP :: Data e_Xe5Zx)
      ($dData5_Xe5ZS :: Data f_Xe5ZA) ->
      Data.Data.C:Data
        @ (a_Xe5km, b_Xe5ko, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA)
        ((Data.Data.$fData(,,,,,)7
            @ a_Xe5km
            @ b_Xe5ko
            @ c_Xe5Zr
            @ d_Xe5Zu
            @ e_Xe5Zx
            @ f_Xe5ZA
            $dData_Xe5ZD
            $dData1_Xe5ZG
            $dData2_Xe5ZJ
            $dData3_Xe5ZM
            $dData4_Xe5ZP
            $dData5_Xe5ZS)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <(a_Xe5km,
                                                                    b_Xe5ko, c_Xe5Zr, d_Xe5Zu,
                                                                    e_Xe5Zx, f_Xe5ZA)>_N
                 :: (Data.Typeable.Internal.TypeRep
                       (a_Xe5km, b_Xe5ko, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA) :: *)
                    ~R# (Typeable
                           (a_Xe5km, b_Xe5ko, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx,
                            f_Xe5ZA) :: Constraint)))
        (Data.Data.$fData(,,,,,)_$cgfoldl
           @ a_Xe5km
           @ b_Xe5ko
           @ c_Xe5Zr
           @ d_Xe5Zu
           @ e_Xe5Zx
           @ f_Xe5ZA
           $dData_Xe5ZD
           $dData1_Xe5ZG
           $dData2_Xe5ZJ
           $dData3_Xe5ZM
           $dData4_Xe5ZP
           $dData5_Xe5ZS)
        (\ (@ (c1_sefRl :: * -> *))
           (w_sefRm
              :: forall b1 r. Data b1 => c1_sefRl (b1 -> r) -> c1_sefRl r)
           (w1_sefRn :: forall r. r -> c1_sefRl r)
           _ [Occ=Dead] ->
           Data.Data.$w$cgunfold1
             @ a_Xe5km
             @ b_Xe5ko
             @ c_Xe5Zr
             @ d_Xe5Zu
             @ e_Xe5Zx
             @ f_Xe5ZA
             $dData_Xe5ZD
             $dData1_Xe5ZG
             $dData2_Xe5ZJ
             $dData3_Xe5ZM
             $dData4_Xe5ZP
             $dData5_Xe5ZS
             @ c1_sefRl
             w_sefRm
             w1_sefRn)
        (lvl121_rejQc
           @ f_Xe5ZA @ e_Xe5Zx @ d_Xe5Zu @ c_Xe5Zr @ b_Xe5ko @ a_Xe5km)
        (lvl122_rejQd
           @ a_Xe5km @ b_Xe5ko @ c_Xe5Zr @ d_Xe5Zu @ e_Xe5Zx @ f_Xe5ZA)
        (lvl123_rejQe
           @ a_Xe5km @ b_Xe5ko @ c_Xe5Zr @ d_Xe5Zu @ e_Xe5Zx @ f_Xe5ZA)
        (lvl124_rejQf
           @ a_Xe5km @ b_Xe5ko @ c_Xe5Zr @ d_Xe5Zu @ e_Xe5Zx @ f_Xe5ZA)
        ((Data.Data.$fData(,,,,,)2
            @ a_Xe5km
            @ b_Xe5ko
            @ c_Xe5Zr
            @ d_Xe5Zu
            @ e_Xe5Zx
            @ f_Xe5ZA
            $dData_Xe5ZD
            $dData1_Xe5ZG
            $dData2_Xe5ZJ
            $dData3_Xe5ZM
            $dData4_Xe5ZP
            $dData5_Xe5ZS)
         `cast` (<forall b1. Data b1 => b1 -> b1>_R
                 ->_R <(a_Xe5km, b_Xe5ko, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA)>_R
                 ->_R Data.Functor.Identity.N:Identity[0]
                          <(a_Xe5km, b_Xe5ko, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA)>_R
                 :: ((forall b1. Data b1 => b1 -> b1)
                     -> (a_Xe5km, b_Xe5ko, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA)
                     -> Identity
                          (a_Xe5km, b_Xe5ko, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA) :: *)
                    ~R# ((forall b1. Data b1 => b1 -> b1)
                         -> (a_Xe5km, b_Xe5ko, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA)
                         -> (a_Xe5km, b_Xe5ko, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA) :: *)))
        ((Data.Data.$fData(,,,,,)1
            @ a_Xe5km
            @ b_Xe5ko
            @ c_Xe5Zr
            @ d_Xe5Zu
            @ e_Xe5Zx
            @ f_Xe5ZA
            $dData_Xe5ZD
            $dData1_Xe5ZG
            $dData2_Xe5ZJ
            $dData3_Xe5ZM
            $dData4_Xe5ZP
            $dData5_Xe5ZS)
         `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                 <r -> r' -> r>_R
                 ->_R <r>_R
                 ->_R <forall d1. Data d1 => d1 -> r'>_R
                 ->_R <(a_Xe5km, b_Xe5ko, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA)>_R
                 ->_R Data.Functor.Const.N:Const[0]
                          <*>_N
                          <r>_R
                          <(a_Xe5km, b_Xe5ko, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA)>_P
                 :: (forall r r'.
                     (r -> r' -> r)
                     -> r
                     -> (forall d1. Data d1 => d1 -> r')
                     -> (a_Xe5km, b_Xe5ko, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA)
                     -> Const
                          r (a_Xe5km, b_Xe5ko, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA) :: *)
                    ~R# (forall r r'.
                         (r -> r' -> r)
                         -> r
                         -> (forall d1. Data d1 => d1 -> r')
                         -> (a_Xe5km, b_Xe5ko, c_Xe5Zr, d_Xe5Zu, e_Xe5Zx, f_Xe5ZA)
                         -> r :: *)))
        (Data.Data.$fData(,,,,,)_$cgmapQr
           @ a_Xe5km
           @ b_Xe5ko
           @ c_Xe5Zr
           @ d_Xe5Zu
           @ e_Xe5Zx
           @ f_Xe5ZA
           $dData_Xe5ZD
           $dData1_Xe5ZG
           $dData2_Xe5ZJ
           $dData3_Xe5ZM
           $dData4_Xe5ZP
           $dData5_Xe5ZS)
        (Data.Data.$fData(,,,,,)_$cgmapQ
           @ a_Xe5km
           @ b_Xe5ko
           @ c_Xe5Zr
           @ d_Xe5Zu
           @ e_Xe5Zx
           @ f_Xe5ZA
           $dData_Xe5ZD
           $dData1_Xe5ZG
           $dData2_Xe5ZJ
           $dData3_Xe5ZM
           $dData4_Xe5ZP
           $dData5_Xe5ZS)
        (Data.Data.$fData(,,,,,)_$cgmapQi
           @ a_Xe5km
           @ b_Xe5ko
           @ c_Xe5Zr
           @ d_Xe5Zu
           @ e_Xe5Zx
           @ f_Xe5ZA
           $dData_Xe5ZD
           $dData1_Xe5ZG
           $dData2_Xe5ZJ
           $dData3_Xe5ZM
           $dData4_Xe5ZP
           $dData5_Xe5ZS)
        (Data.Data.$fData(,,,,,)_$cgmapM
           @ a_Xe5km
           @ b_Xe5ko
           @ c_Xe5Zr
           @ d_Xe5Zu
           @ e_Xe5Zx
           @ f_Xe5ZA
           $dData_Xe5ZD
           $dData1_Xe5ZG
           $dData2_Xe5ZJ
           $dData3_Xe5ZM
           $dData4_Xe5ZP
           $dData5_Xe5ZS)
        (Data.Data.$fData(,,,,,)_$cgmapMp
           @ a_Xe5km
           @ b_Xe5ko
           @ c_Xe5Zr
           @ d_Xe5Zu
           @ e_Xe5Zx
           @ f_Xe5ZA
           $dData_Xe5ZD
           $dData1_Xe5ZG
           $dData2_Xe5ZJ
           $dData3_Xe5ZM
           $dData4_Xe5ZP
           $dData5_Xe5ZS)
        (Data.Data.$fData(,,,,,)_$cgmapMo
           @ a_Xe5km
           @ b_Xe5ko
           @ c_Xe5Zr
           @ d_Xe5Zu
           @ e_Xe5Zx
           @ f_Xe5ZA
           $dData_Xe5ZD
           $dData1_Xe5ZG
           $dData2_Xe5ZJ
           $dData3_Xe5ZM
           $dData4_Xe5ZP
           $dData5_Xe5ZS)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,,,)6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fData(,,,,,,)6 = "(,,,,,,)"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,,,)5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fData(,,,,,,)5
  = unpackCString# Data.Data.$fData(,,,,,,)6

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go17_rejQg :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go17_rejQg
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fData(,,,,,,)5 of {
                False -> go17_rejQg ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$c(,,,,,,)1_rejQh :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$c(,,,,,,)1_rejQh = Data.Data.AlgConstr $c(,,,,,,)2_rejQi

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,,,)4 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData(,,,,,,)4
  = GHC.Types.: @ Constr Data.Data.$c(,,,,,,) (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,,,)3 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fData(,,,,,,)3
  = Data.Data.AlgRep Data.Data.$fData(,,,,,,)4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$t(,,,,,,) :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$t(,,,,,,)
  = Data.Data.DataType
      Data.Data.$fData(,,,,,,)5 Data.Data.$fData(,,,,,,)3

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$c(,,,,,,) [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$c(,,,,,,)
  = Data.Data.Constr
      $c(,,,,,,)1_rejQh
      Data.Data.$fData(,,,,,,)5
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$t(,,,,,,)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$c(,,,,,,)2_rejQi :: ConIndex
[GblId]
$c(,,,,,,)2_rejQi
  = go17_rejQg Data.Data.$fData(,,,,,,)4 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 10, types: 37, coercions: 0, joins: 0/0}
lvl125_rejQj
  :: forall b a c d e f g.
     (a -> b -> c -> d -> e -> f -> g -> (a, b, c, d, e, f, g), Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl125_rejQj
  = \ (@ b_Xe5gC)
      (@ a_Xe5gA)
      (@ c_Xe5gE)
      (@ d_Xe5gG)
      (@ e_Xe5gI)
      (@ f_Xe5gK)
      (@ g_Xe5gM) ->
      (GHC.Tuple.(,,,,,,)
         @ a_Xe5gA
         @ b_Xe5gC
         @ c_Xe5gE
         @ d_Xe5gG
         @ e_Xe5gI
         @ f_Xe5gK
         @ g_Xe5gM,
       GHC.Types.False)

-- RHS size: {terms: 100, types: 322, coercions: 109, joins: 0/4}
Data.Data.$fData(,,,,,,)_$cgmapMp
  :: forall a b c d e f g.
     (Data a, Data b, Data c, Data d, Data e, Data f, Data g) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d1. Data d1 => d1 -> m d1)
     -> (a, b, c, d, e, f, g) -> m (a, b, c, d, e, f, g)
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U,U,U,U,U,U)>,
 Unf=OtherCon []]
Data.Data.$fData(,,,,,,)_$cgmapMp
  = \ (@ a_Xe5gA)
      (@ b_Xe5gC)
      (@ c_Xe5gE)
      (@ d_Xe5gG)
      (@ e_Xe5gI)
      (@ f_Xe5gK)
      (@ g_Xe5gM)
      ($dData_Xe5gO :: Data a_Xe5gA)
      ($dData1_Xe5gQ :: Data b_Xe5gC)
      ($dData2_Xe5gS :: Data c_Xe5gE)
      ($dData3_Xe5gU :: Data d_Xe5gG)
      ($dData4_Xe5gW :: Data e_Xe5gI)
      ($dData5_Xe5gY :: Data f_Xe5gK)
      ($dData6_Xe5h0 :: Data g_Xe5gM)
      (@ (m_ae4GW :: * -> *))
      ($dMonadPlus_ae4GY :: MonadPlus m_ae4GW)
      (ds_de7B8 :: forall d1. Data d1 => d1 -> m_ae4GW d1)
      (eta_XFo
         :: (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK,
             g_Xe5gM)) ->
      let {
        lvl270_se9JN
          :: m_ae4GW (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK,
                      g_Xe5gM)
        [LclId]
        lvl270_se9JN
          = mzero
              @ m_ae4GW
              $dMonadPlus_ae4GY
              @ (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK,
                 g_Xe5gM) } in
      let {
        $dMonad_se9rZ [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae4GW
        [LclId]
        $dMonad_se9rZ
          = GHC.Base.$p2MonadPlus @ m_ae4GW $dMonadPlus_ae4GY } in
      >>=
        @ m_ae4GW
        $dMonad_se9rZ
        @ ((a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK, g_Xe5gM),
           Bool)
        @ (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK, g_Xe5gM)
        (case eta_XFo of
         { (a1_ae2pt, a2_ae2pu, a3_ae2pv, a4_ae2pw, a5_ae2px, a6_ae2py,
            a7_ae2pz) ->
         let {
           k_se9rY [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
             :: forall d1 b1.
                Data d1 =>
                Mp m_ae4GW (d1 -> b1) -> d1 -> m_ae4GW (b1, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_se9rY
             = \ (@ d1_ae2Ws)
                 (@ b1_ae2Wt)
                 ($dData7_ae2Wv :: Data d1_ae2Ws)
                 (ds1_de7oC [OS=OneShot] :: Mp m_ae4GW (d1_ae2Ws -> b1_ae2Wt))
                 (y_ae1Tz [OS=OneShot] :: d1_ae2Ws) ->
                 let {
                   lvl271_se9JL :: m_ae4GW d1_ae2Ws
                   [LclId]
                   lvl271_se9JL = ds_de7B8 @ d1_ae2Ws $dData7_ae2Wv y_ae1Tz } in
                 >>=
                   @ m_ae4GW
                   $dMonad_se9rZ
                   @ (d1_ae2Ws -> b1_ae2Wt, Bool)
                   @ (b1_ae2Wt, Bool)
                   (ds1_de7oC
                    `cast` (Data.Data.N:Mp[0] <m_ae4GW>_R <d1_ae2Ws -> b1_ae2Wt>_N
                            :: (Mp m_ae4GW (d1_ae2Ws -> b1_ae2Wt) :: *)
                               ~R# (m_ae4GW (d1_ae2Ws -> b1_ae2Wt, Bool) :: *)))
                   (\ (ds2_de7oD :: (d1_ae2Ws -> b1_ae2Wt, Bool)) ->
                      case ds2_de7oD of { (h_ae1TA, b2_ae1TB) ->
                      mplus
                        @ m_ae4GW
                        $dMonadPlus_ae4GY
                        @ (b1_ae2Wt, Bool)
                        (>>=
                           @ m_ae4GW
                           $dMonad_se9rZ
                           @ d1_ae2Ws
                           @ (b1_ae2Wt, Bool)
                           lvl271_se9JL
                           (\ (y'_ae1TC :: d1_ae2Ws) ->
                              return
                                @ m_ae4GW
                                $dMonad_se9rZ
                                @ (b1_ae2Wt, Bool)
                                (h_ae1TA y'_ae1TC, GHC.Types.True)))
                        (return
                           @ m_ae4GW
                           $dMonad_se9rZ
                           @ (b1_ae2Wt, Bool)
                           (h_ae1TA y_ae1Tz, b2_ae1TB))
                      }) } in
         k_se9rY
           @ g_Xe5gM
           @ (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK, g_Xe5gM)
           $dData6_Xe5h0
           ((k_se9rY
               @ f_Xe5gK
               @ (g_Xe5gM
                  -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK, g_Xe5gM))
               $dData5_Xe5gY
               ((k_se9rY
                   @ e_Xe5gI
                   @ (f_Xe5gK
                      -> g_Xe5gM
                      -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK, g_Xe5gM))
                   $dData4_Xe5gW
                   ((k_se9rY
                       @ d_Xe5gG
                       @ (e_Xe5gI
                          -> f_Xe5gK
                          -> g_Xe5gM
                          -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK, g_Xe5gM))
                       $dData3_Xe5gU
                       ((k_se9rY
                           @ c_Xe5gE
                           @ (d_Xe5gG
                              -> e_Xe5gI
                              -> f_Xe5gK
                              -> g_Xe5gM
                              -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK, g_Xe5gM))
                           $dData2_Xe5gS
                           ((k_se9rY
                               @ b_Xe5gC
                               @ (c_Xe5gE
                                  -> d_Xe5gG
                                  -> e_Xe5gI
                                  -> f_Xe5gK
                                  -> g_Xe5gM
                                  -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK,
                                      g_Xe5gM))
                               $dData1_Xe5gQ
                               ((k_se9rY
                                   @ a_Xe5gA
                                   @ (b_Xe5gC
                                      -> c_Xe5gE
                                      -> d_Xe5gG
                                      -> e_Xe5gI
                                      -> f_Xe5gK
                                      -> g_Xe5gM
                                      -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK,
                                          g_Xe5gM))
                                   $dData_Xe5gO
                                   ((return
                                       @ m_ae4GW
                                       $dMonad_se9rZ
                                       @ (a_Xe5gA
                                          -> b_Xe5gC
                                          -> c_Xe5gE
                                          -> d_Xe5gG
                                          -> e_Xe5gI
                                          -> f_Xe5gK
                                          -> g_Xe5gM
                                          -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK,
                                              g_Xe5gM),
                                          Bool)
                                       (lvl125_rejQj
                                          @ b_Xe5gC
                                          @ a_Xe5gA
                                          @ c_Xe5gE
                                          @ d_Xe5gG
                                          @ e_Xe5gI
                                          @ f_Xe5gK
                                          @ g_Xe5gM))
                                    `cast` (Sym (Data.Data.N:Mp[0]
                                                     <m_ae4GW>_R
                                                     <a_Xe5gA
                                                      -> b_Xe5gC
                                                      -> c_Xe5gE
                                                      -> d_Xe5gG
                                                      -> e_Xe5gI
                                                      -> f_Xe5gK
                                                      -> g_Xe5gM
                                                      -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG,
                                                          e_Xe5gI, f_Xe5gK, g_Xe5gM)>_N)
                                            :: (m_ae4GW (a_Xe5gA
                                                         -> b_Xe5gC
                                                         -> c_Xe5gE
                                                         -> d_Xe5gG
                                                         -> e_Xe5gI
                                                         -> f_Xe5gK
                                                         -> g_Xe5gM
                                                         -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG,
                                                             e_Xe5gI, f_Xe5gK, g_Xe5gM),
                                                         Bool) :: *)
                                               ~R# (Mp
                                                      m_ae4GW
                                                      (a_Xe5gA
                                                       -> b_Xe5gC
                                                       -> c_Xe5gE
                                                       -> d_Xe5gG
                                                       -> e_Xe5gI
                                                       -> f_Xe5gK
                                                       -> g_Xe5gM
                                                       -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG,
                                                           e_Xe5gI, f_Xe5gK, g_Xe5gM)) :: *)))
                                   a1_ae2pt)
                                `cast` (Sym (Data.Data.N:Mp[0]
                                                 <m_ae4GW>_R
                                                 <b_Xe5gC
                                                  -> c_Xe5gE
                                                  -> d_Xe5gG
                                                  -> e_Xe5gI
                                                  -> f_Xe5gK
                                                  -> g_Xe5gM
                                                  -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI,
                                                      f_Xe5gK, g_Xe5gM)>_N)
                                        :: (m_ae4GW (b_Xe5gC
                                                     -> c_Xe5gE
                                                     -> d_Xe5gG
                                                     -> e_Xe5gI
                                                     -> f_Xe5gK
                                                     -> g_Xe5gM
                                                     -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG,
                                                         e_Xe5gI, f_Xe5gK, g_Xe5gM),
                                                     Bool) :: *)
                                           ~R# (Mp
                                                  m_ae4GW
                                                  (b_Xe5gC
                                                   -> c_Xe5gE
                                                   -> d_Xe5gG
                                                   -> e_Xe5gI
                                                   -> f_Xe5gK
                                                   -> g_Xe5gM
                                                   -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI,
                                                       f_Xe5gK, g_Xe5gM)) :: *)))
                               a2_ae2pu)
                            `cast` (Sym (Data.Data.N:Mp[0]
                                             <m_ae4GW>_R
                                             <c_Xe5gE
                                              -> d_Xe5gG
                                              -> e_Xe5gI
                                              -> f_Xe5gK
                                              -> g_Xe5gM
                                              -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI,
                                                  f_Xe5gK, g_Xe5gM)>_N)
                                    :: (m_ae4GW (c_Xe5gE
                                                 -> d_Xe5gG
                                                 -> e_Xe5gI
                                                 -> f_Xe5gK
                                                 -> g_Xe5gM
                                                 -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI,
                                                     f_Xe5gK, g_Xe5gM),
                                                 Bool) :: *)
                                       ~R# (Mp
                                              m_ae4GW
                                              (c_Xe5gE
                                               -> d_Xe5gG
                                               -> e_Xe5gI
                                               -> f_Xe5gK
                                               -> g_Xe5gM
                                               -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI,
                                                   f_Xe5gK, g_Xe5gM)) :: *)))
                           a3_ae2pv)
                        `cast` (Sym (Data.Data.N:Mp[0]
                                         <m_ae4GW>_R
                                         <d_Xe5gG
                                          -> e_Xe5gI
                                          -> f_Xe5gK
                                          -> g_Xe5gM
                                          -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK,
                                              g_Xe5gM)>_N)
                                :: (m_ae4GW (d_Xe5gG
                                             -> e_Xe5gI
                                             -> f_Xe5gK
                                             -> g_Xe5gM
                                             -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI,
                                                 f_Xe5gK, g_Xe5gM),
                                             Bool) :: *)
                                   ~R# (Mp
                                          m_ae4GW
                                          (d_Xe5gG
                                           -> e_Xe5gI
                                           -> f_Xe5gK
                                           -> g_Xe5gM
                                           -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK,
                                               g_Xe5gM)) :: *)))
                       a4_ae2pw)
                    `cast` (Sym (Data.Data.N:Mp[0]
                                     <m_ae4GW>_R
                                     <e_Xe5gI
                                      -> f_Xe5gK
                                      -> g_Xe5gM
                                      -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK,
                                          g_Xe5gM)>_N)
                            :: (m_ae4GW (e_Xe5gI
                                         -> f_Xe5gK
                                         -> g_Xe5gM
                                         -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK,
                                             g_Xe5gM),
                                         Bool) :: *)
                               ~R# (Mp
                                      m_ae4GW
                                      (e_Xe5gI
                                       -> f_Xe5gK
                                       -> g_Xe5gM
                                       -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK,
                                           g_Xe5gM)) :: *)))
                   a5_ae2px)
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_ae4GW>_R
                                 <f_Xe5gK
                                  -> g_Xe5gM
                                  -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK,
                                      g_Xe5gM)>_N)
                        :: (m_ae4GW (f_Xe5gK
                                     -> g_Xe5gM
                                     -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK,
                                         g_Xe5gM),
                                     Bool) :: *)
                           ~R# (Mp
                                  m_ae4GW
                                  (f_Xe5gK
                                   -> g_Xe5gM
                                   -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK,
                                       g_Xe5gM)) :: *)))
               a6_ae2py)
            `cast` (Sym (Data.Data.N:Mp[0]
                             <m_ae4GW>_R
                             <g_Xe5gM
                              -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK,
                                  g_Xe5gM)>_N)
                    :: (m_ae4GW (g_Xe5gM
                                 -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK, g_Xe5gM),
                                 Bool) :: *)
                       ~R# (Mp
                              m_ae4GW
                              (g_Xe5gM
                               -> (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK,
                                   g_Xe5gM)) :: *)))
           a7_ae2pz
         })
        (\ (ds1_de7oa
              :: ((a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK,
                   g_Xe5gM),
                  Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b1_ae1TE) ->
           case b1_ae1TE of {
             False -> lvl270_se9JN;
             True ->
               return
                 @ m_ae4GW
                 $dMonad_se9rZ
                 @ (a_Xe5gA, b_Xe5gC, c_Xe5gE, d_Xe5gG, e_Xe5gI, f_Xe5gK, g_Xe5gM)
                 x'_ae1TD
           }
           })

-- RHS size: {terms: 67, types: 208, coercions: 0, joins: 0/2}
Data.Data.$fData(,,,,,,)_$cgmapM
  :: forall a b c d e f g.
     (Data a, Data b, Data c, Data d, Data e, Data f, Data g) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d1. Data d1 => d1 -> m d1)
     -> (a, b, c, d, e, f, g) -> m (a, b, c, d, e, f, g)
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U,U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 0 120 60 20] 550 0}]
Data.Data.$fData(,,,,,,)_$cgmapM
  = \ (@ a_Xe5gz)
      (@ b_Xe5gB)
      (@ c_Xe5gD)
      (@ d_Xe5gF)
      (@ e_Xe5gH)
      (@ f_Xe5gJ)
      (@ g_Xe5gL)
      ($dData_Xe5gN :: Data a_Xe5gz)
      ($dData1_Xe5gP :: Data b_Xe5gB)
      ($dData2_Xe5gR :: Data c_Xe5gD)
      ($dData3_Xe5gT :: Data d_Xe5gF)
      ($dData4_Xe5gV :: Data e_Xe5gH)
      ($dData5_Xe5gX :: Data f_Xe5gJ)
      ($dData6_Xe5gZ :: Data g_Xe5gL)
      (@ (m_ae4GG :: * -> *))
      ($dMonad_ae4GI :: Monad m_ae4GG)
      (ds_de7B7 :: forall d1. Data d1 => d1 -> m_ae4GG d1)
      (eta_XFp
         :: (a_Xe5gz, b_Xe5gB, c_Xe5gD, d_Xe5gF, e_Xe5gH, f_Xe5gJ,
             g_Xe5gL)) ->
      case eta_XFp of
      { (a1_ae2pt, a2_ae2pu, a3_ae2pv, a4_ae2pw, a5_ae2px, a6_ae2py,
         a7_ae2pz) ->
      let {
        k_se9rV [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
          :: forall d1 b1. Data d1 => m_ae4GG (d1 -> b1) -> d1 -> m_ae4GG b1
        [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
        k_se9rV
          = \ (@ d1_ae2Vh)
              (@ b1_ae2Vi)
              ($dData7_ae2Vk :: Data d1_ae2Vh)
              (c1_ae1Tm [OS=OneShot] :: m_ae4GG (d1_ae2Vh -> b1_ae2Vi))
              (x_ae1Tn [OS=OneShot] :: d1_ae2Vh) ->
              let {
                lvl270_se9JO :: m_ae4GG d1_ae2Vh
                [LclId]
                lvl270_se9JO = ds_de7B7 @ d1_ae2Vh $dData7_ae2Vk x_ae1Tn } in
              >>=
                @ m_ae4GG
                $dMonad_ae4GI
                @ (d1_ae2Vh -> b1_ae2Vi)
                @ b1_ae2Vi
                c1_ae1Tm
                (\ (c'_ae1To :: d1_ae2Vh -> b1_ae2Vi) ->
                   >>=
                     @ m_ae4GG
                     $dMonad_ae4GI
                     @ d1_ae2Vh
                     @ b1_ae2Vi
                     lvl270_se9JO
                     (\ (x'_ae1Tp :: d1_ae2Vh) ->
                        return
                          @ m_ae4GG $dMonad_ae4GI @ b1_ae2Vi (c'_ae1To x'_ae1Tp))) } in
      k_se9rV
        @ g_Xe5gL
        @ (a_Xe5gz, b_Xe5gB, c_Xe5gD, d_Xe5gF, e_Xe5gH, f_Xe5gJ, g_Xe5gL)
        $dData6_Xe5gZ
        (k_se9rV
           @ f_Xe5gJ
           @ (g_Xe5gL
              -> (a_Xe5gz, b_Xe5gB, c_Xe5gD, d_Xe5gF, e_Xe5gH, f_Xe5gJ, g_Xe5gL))
           $dData5_Xe5gX
           (k_se9rV
              @ e_Xe5gH
              @ (f_Xe5gJ
                 -> g_Xe5gL
                 -> (a_Xe5gz, b_Xe5gB, c_Xe5gD, d_Xe5gF, e_Xe5gH, f_Xe5gJ, g_Xe5gL))
              $dData4_Xe5gV
              (k_se9rV
                 @ d_Xe5gF
                 @ (e_Xe5gH
                    -> f_Xe5gJ
                    -> g_Xe5gL
                    -> (a_Xe5gz, b_Xe5gB, c_Xe5gD, d_Xe5gF, e_Xe5gH, f_Xe5gJ, g_Xe5gL))
                 $dData3_Xe5gT
                 (k_se9rV
                    @ c_Xe5gD
                    @ (d_Xe5gF
                       -> e_Xe5gH
                       -> f_Xe5gJ
                       -> g_Xe5gL
                       -> (a_Xe5gz, b_Xe5gB, c_Xe5gD, d_Xe5gF, e_Xe5gH, f_Xe5gJ, g_Xe5gL))
                    $dData2_Xe5gR
                    (k_se9rV
                       @ b_Xe5gB
                       @ (c_Xe5gD
                          -> d_Xe5gF
                          -> e_Xe5gH
                          -> f_Xe5gJ
                          -> g_Xe5gL
                          -> (a_Xe5gz, b_Xe5gB, c_Xe5gD, d_Xe5gF, e_Xe5gH, f_Xe5gJ, g_Xe5gL))
                       $dData1_Xe5gP
                       (k_se9rV
                          @ a_Xe5gz
                          @ (b_Xe5gB
                             -> c_Xe5gD
                             -> d_Xe5gF
                             -> e_Xe5gH
                             -> f_Xe5gJ
                             -> g_Xe5gL
                             -> (a_Xe5gz, b_Xe5gB, c_Xe5gD, d_Xe5gF, e_Xe5gH, f_Xe5gJ, g_Xe5gL))
                          $dData_Xe5gN
                          (return
                             @ m_ae4GG
                             $dMonad_ae4GI
                             @ (a_Xe5gz
                                -> b_Xe5gB
                                -> c_Xe5gD
                                -> d_Xe5gF
                                -> e_Xe5gH
                                -> f_Xe5gJ
                                -> g_Xe5gL
                                -> (a_Xe5gz, b_Xe5gB, c_Xe5gD, d_Xe5gF, e_Xe5gH, f_Xe5gJ, g_Xe5gL))
                             (GHC.Tuple.(,,,,,,)
                                @ a_Xe5gz
                                @ b_Xe5gB
                                @ c_Xe5gD
                                @ d_Xe5gF
                                @ e_Xe5gH
                                @ f_Xe5gJ
                                @ g_Xe5gL))
                          a1_ae2pt)
                       a2_ae2pu)
                    a3_ae2pv)
                 a4_ae2pw)
              a5_ae2px)
           a6_ae2py)
        a7_ae2pz
      }

-- RHS size: {terms: 56, types: 71, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,,,)_$cgmapQi
  :: forall a b c d e f g.
     (Data a, Data b, Data c, Data d, Data e, Data f, Data g) =>
     forall u.
     Int
     -> (forall d1. Data d1 => d1 -> u) -> (a, b, c, d, e, f, g) -> u
[GblId,
 Arity=10,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U,U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 0 20 420 20] 310 0}]
Data.Data.$fData(,,,,,,)_$cgmapQi
  = \ (@ a_Xe5gy)
      (@ b_Xe5gA)
      (@ c_Xe5gC)
      (@ d_Xe5gE)
      (@ e_Xe5gG)
      (@ f_Xe5gI)
      (@ g_Xe5gK)
      ($dData_Xe5gM :: Data a_Xe5gy)
      ($dData1_Xe5gO :: Data b_Xe5gA)
      ($dData2_Xe5gQ :: Data c_Xe5gC)
      ($dData3_Xe5gS :: Data d_Xe5gE)
      ($dData4_Xe5gU :: Data e_Xe5gG)
      ($dData5_Xe5gW :: Data f_Xe5gI)
      ($dData6_Xe5gY :: Data g_Xe5gK)
      (@ u_ae4Gs)
      (ds_de7B5 :: Int)
      (ds1_de7B6 :: forall d1. Data d1 => d1 -> u_ae4Gs)
      (x_ae1T7
         :: (a_Xe5gy, b_Xe5gA, c_Xe5gC, d_Xe5gE, e_Xe5gG, f_Xe5gI,
             g_Xe5gK)) ->
      case x_ae1T7 of
      { (a1_ae2pt, a2_ae2pu, a3_ae2pv, a4_ae2pw, a5_ae2px, a6_ae2py,
         a7_ae2pz) ->
      case ds_de7B5 of { I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_ae4Gs;
        0# -> ds1_de7B6 @ a_Xe5gy $dData_Xe5gM a1_ae2pt;
        1# -> ds1_de7B6 @ b_Xe5gA $dData1_Xe5gO a2_ae2pu;
        2# -> ds1_de7B6 @ c_Xe5gC $dData2_Xe5gQ a3_ae2pv;
        3# -> ds1_de7B6 @ d_Xe5gE $dData3_Xe5gS a4_ae2pw;
        4# -> ds1_de7B6 @ e_Xe5gG $dData4_Xe5gU a5_ae2px;
        5# -> ds1_de7B6 @ f_Xe5gI $dData5_Xe5gW a6_ae2py;
        6# -> ds1_de7B6 @ g_Xe5gK $dData6_Xe5gY a7_ae2pz
      }
      }
      }

-- RHS size: {terms: 52, types: 72, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,,,)_$cgmapQr
  :: forall a b c d e f g.
     (Data a, Data b, Data c, Data d, Data e, Data f, Data g) =>
     forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d1. Data d1 => d1 -> r')
     -> (a, b, c, d, e, f, g)
     -> r
[GblId,
 Arity=11,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U,U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 0 60 0 420 20] 430 0}]
Data.Data.$fData(,,,,,,)_$cgmapQr
  = \ (@ a_Xe5gw)
      (@ b_Xe5gy)
      (@ c_Xe5gA)
      (@ d_Xe5gC)
      (@ e_Xe5gE)
      (@ f_Xe5gG)
      (@ g_Xe5gI)
      ($dData_Xe5gK :: Data a_Xe5gw)
      ($dData1_Xe5gM :: Data b_Xe5gy)
      ($dData2_Xe5gO :: Data c_Xe5gA)
      ($dData3_Xe5gQ :: Data d_Xe5gC)
      ($dData4_Xe5gS :: Data e_Xe5gE)
      ($dData5_Xe5gU :: Data f_Xe5gG)
      ($dData6_Xe5gW :: Data g_Xe5gI)
      (@ r_ae4FX)
      (@ r'_ae4FY)
      (ds_de7B1 :: r'_ae4FY -> r_ae4FX -> r_ae4FX)
      (ds1_de7B2 :: r_ae4FX)
      (ds2_de7B3 :: forall d1. Data d1 => d1 -> r'_ae4FY)
      (x0_ae1SX
         :: (a_Xe5gw, b_Xe5gy, c_Xe5gA, d_Xe5gC, e_Xe5gE, f_Xe5gG,
             g_Xe5gI)) ->
      case x0_ae1SX of
      { (a1_ae2pt, a2_ae2pu, a3_ae2pv, a4_ae2pw, a5_ae2px, a6_ae2py,
         a7_ae2pz) ->
      ds_de7B1
        (ds2_de7B3 @ a_Xe5gw $dData_Xe5gK a1_ae2pt)
        (ds_de7B1
           (ds2_de7B3 @ b_Xe5gy $dData1_Xe5gM a2_ae2pu)
           (ds_de7B1
              (ds2_de7B3 @ c_Xe5gA $dData2_Xe5gO a3_ae2pv)
              (ds_de7B1
                 (ds2_de7B3 @ d_Xe5gC $dData3_Xe5gQ a4_ae2pw)
                 (ds_de7B1
                    (ds2_de7B3 @ e_Xe5gE $dData4_Xe5gS a5_ae2px)
                    (ds_de7B1
                       (ds2_de7B3 @ f_Xe5gG $dData5_Xe5gU a6_ae2py)
                       (ds_de7B1
                          (ds2_de7B3 @ g_Xe5gI $dData6_Xe5gW a7_ae2pz) ds1_de7B2))))))
      }

-- RHS size: {terms: 27, types: 48, coercions: 0, joins: 0/0}
Data.Data.$fData(,,,,,,)_$cgmapQ
  :: forall a b c d e f g.
     (Data a, Data b, Data c, Data d, Data e, Data f, Data g) =>
     forall u.
     (forall d1. Data d1 => d1 -> u) -> (a, b, c, d, e, f, g) -> [u]
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,C(C1(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=8,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe5gx)
                 (@ b_Xe5gz)
                 (@ c_Xe5gB)
                 (@ d_Xe5gD)
                 (@ e_Xe5gF)
                 (@ f_Xe5gH)
                 (@ g_Xe5gJ)
                 ($dData_Xe5gL [Occ=Once] :: Data a_Xe5gx)
                 ($dData1_Xe5gN [Occ=Once] :: Data b_Xe5gz)
                 ($dData2_Xe5gP [Occ=Once] :: Data c_Xe5gB)
                 ($dData3_Xe5gR [Occ=Once] :: Data d_Xe5gD)
                 ($dData4_Xe5gT [Occ=Once] :: Data e_Xe5gF)
                 ($dData5_Xe5gV [Occ=Once] :: Data f_Xe5gH)
                 ($dData6_Xe5gX [Occ=Once] :: Data g_Xe5gJ)
                 (@ u_ae4Ge)
                 (ds_de7B4 [Occ=Once] :: forall d1. Data d1 => d1 -> u_ae4Ge) ->
                 Data.Data.$fData(,,,,,,)_$cgmapQr
                   @ a_Xe5gx
                   @ b_Xe5gz
                   @ c_Xe5gB
                   @ d_Xe5gD
                   @ e_Xe5gF
                   @ f_Xe5gH
                   @ g_Xe5gJ
                   $dData_Xe5gL
                   $dData1_Xe5gN
                   $dData2_Xe5gP
                   $dData3_Xe5gR
                   $dData4_Xe5gT
                   $dData5_Xe5gV
                   $dData6_Xe5gX
                   @ [u_ae4Ge]
                   @ u_ae4Ge
                   (GHC.Types.: @ u_ae4Ge)
                   (GHC.Types.[] @ u_ae4Ge)
                   ds_de7B4}]
Data.Data.$fData(,,,,,,)_$cgmapQ
  = \ (@ a_Xe5gx)
      (@ b_Xe5gz)
      (@ c_Xe5gB)
      (@ d_Xe5gD)
      (@ e_Xe5gF)
      (@ f_Xe5gH)
      (@ g_Xe5gJ)
      ($dData_Xe5gL :: Data a_Xe5gx)
      ($dData1_Xe5gN :: Data b_Xe5gz)
      ($dData2_Xe5gP :: Data c_Xe5gB)
      ($dData3_Xe5gR :: Data d_Xe5gD)
      ($dData4_Xe5gT :: Data e_Xe5gF)
      ($dData5_Xe5gV :: Data f_Xe5gH)
      ($dData6_Xe5gX :: Data g_Xe5gJ)
      (@ u_ae4Ge)
      (ds_de7B4 :: forall d1. Data d1 => d1 -> u_ae4Ge) ->
      Data.Data.$fData(,,,,,,)_$cgmapQr
        @ a_Xe5gx
        @ b_Xe5gz
        @ c_Xe5gB
        @ d_Xe5gD
        @ e_Xe5gF
        @ f_Xe5gH
        @ g_Xe5gJ
        $dData_Xe5gL
        $dData1_Xe5gN
        $dData2_Xe5gP
        $dData3_Xe5gR
        $dData4_Xe5gT
        $dData5_Xe5gV
        $dData6_Xe5gX
        @ [u_ae4Ge]
        @ u_ae4Ge
        (GHC.Types.: @ u_ae4Ge)
        (GHC.Types.[] @ u_ae4Ge)
        ds_de7B4

-- RHS size: {terms: 52, types: 72, coercions: 13, joins: 0/0}
Data.Data.$fData(,,,,,,)1
  :: forall a b c d e f g.
     (Data a, Data b, Data c, Data d, Data e, Data f, Data g) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d1. Data d1 => d1 -> r')
     -> (a, b, c, d, e, f, g)
     -> Const r (a, b, c, d, e, f, g)
[GblId,
 Arity=11,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U,U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 0 60 0 420 20] 430 0}]
Data.Data.$fData(,,,,,,)1
  = \ (@ a_Xe5gv)
      (@ b_Xe5gx)
      (@ c_Xe5gz)
      (@ d_Xe5gB)
      (@ e_Xe5gD)
      (@ f_Xe5gF)
      (@ g_Xe5gH)
      ($dData_Xe5gJ :: Data a_Xe5gv)
      ($dData1_Xe5gL :: Data b_Xe5gx)
      ($dData2_Xe5gN :: Data c_Xe5gz)
      ($dData3_Xe5gP :: Data d_Xe5gB)
      ($dData4_Xe5gR :: Data e_Xe5gD)
      ($dData5_Xe5gT :: Data f_Xe5gF)
      ($dData6_Xe5gV :: Data g_Xe5gH)
      (@ r_ae4FG)
      (@ r'_ae4FH)
      (ds_de7AY :: r_ae4FG -> r'_ae4FH -> r_ae4FG)
      (ds1_de7AZ :: r_ae4FG)
      (ds2_de7B0 :: forall d1. Data d1 => d1 -> r'_ae4FH)
      (eta_XFv
         :: (a_Xe5gv, b_Xe5gx, c_Xe5gz, d_Xe5gB, e_Xe5gD, f_Xe5gF,
             g_Xe5gH)) ->
      case eta_XFv of
      { (a1_ae2pt, a2_ae2pu, a3_ae2pv, a4_ae2pw, a5_ae2px, a6_ae2py,
         a7_ae2pz) ->
      (ds_de7AY
         (ds_de7AY
            (ds_de7AY
               (ds_de7AY
                  (ds_de7AY
                     (ds_de7AY
                        (ds_de7AY ds1_de7AZ (ds2_de7B0 @ a_Xe5gv $dData_Xe5gJ a1_ae2pt))
                        (ds2_de7B0 @ b_Xe5gx $dData1_Xe5gL a2_ae2pu))
                     (ds2_de7B0 @ c_Xe5gz $dData2_Xe5gN a3_ae2pv))
                  (ds2_de7B0 @ d_Xe5gB $dData3_Xe5gP a4_ae2pw))
               (ds2_de7B0 @ e_Xe5gD $dData4_Xe5gR a5_ae2px))
            (ds2_de7B0 @ f_Xe5gF $dData5_Xe5gT a6_ae2py))
         (ds2_de7B0 @ g_Xe5gH $dData6_Xe5gV a7_ae2pz))
      `cast` (Sym (Data.Functor.Const.N:Const[0]
                       <*>_N
                       <r_ae4FG>_R
                       <(a_Xe5gv, b_Xe5gx, c_Xe5gz, d_Xe5gB, e_Xe5gD, f_Xe5gF,
                         g_Xe5gH)>_P)
              :: (r_ae4FG :: *)
                 ~R# (Const
                        r_ae4FG
                        (a_Xe5gv, b_Xe5gx, c_Xe5gz, d_Xe5gB, e_Xe5gD, f_Xe5gF,
                         g_Xe5gH) :: *))
      }

-- RHS size: {terms: 41, types: 71, coercions: 10, joins: 0/0}
Data.Data.$fData(,,,,,,)2
  :: forall a b c d e f g.
     (Data a, Data b, Data c, Data d, Data e, Data f, Data g) =>
     (forall b1. Data b1 => b1 -> b1)
     -> (a, b, c, d, e, f, g) -> Identity (a, b, c, d, e, f, g)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,C(C1(U))><S,1*U(U,U,U,U,U,U,U)>m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 0 420 20] 230 80}]
Data.Data.$fData(,,,,,,)2
  = \ (@ a_Xe5gu)
      (@ b_Xe5gw)
      (@ c_Xe5gy)
      (@ d_Xe5gA)
      (@ e_Xe5gC)
      (@ f_Xe5gE)
      (@ g_Xe5gG)
      ($dData_Xe5gI :: Data a_Xe5gu)
      ($dData1_Xe5gK :: Data b_Xe5gw)
      ($dData2_Xe5gM :: Data c_Xe5gy)
      ($dData3_Xe5gO :: Data d_Xe5gA)
      ($dData4_Xe5gQ :: Data e_Xe5gC)
      ($dData5_Xe5gS :: Data f_Xe5gE)
      ($dData6_Xe5gU :: Data g_Xe5gG)
      (ds_de7AX :: forall b1. Data b1 => b1 -> b1)
      (x0_Xe2Z8
         :: (a_Xe5gu, b_Xe5gw, c_Xe5gy, d_Xe5gA, e_Xe5gC, f_Xe5gE,
             g_Xe5gG)) ->
      case x0_Xe2Z8 of
      { (a1_ae2pt, a2_ae2pu, a3_ae2pv, a4_ae2pw, a5_ae2px, a6_ae2py,
         a7_ae2pz) ->
      (ds_de7AX @ a_Xe5gu $dData_Xe5gI a1_ae2pt,
       ds_de7AX @ b_Xe5gw $dData1_Xe5gK a2_ae2pu,
       ds_de7AX @ c_Xe5gy $dData2_Xe5gM a3_ae2pv,
       ds_de7AX @ d_Xe5gA $dData3_Xe5gO a4_ae2pw,
       ds_de7AX @ e_Xe5gC $dData4_Xe5gQ a5_ae2px,
       ds_de7AX @ f_Xe5gE $dData5_Xe5gS a6_ae2py,
       ds_de7AX @ g_Xe5gG $dData6_Xe5gU a7_ae2pz)
      `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                       <(a_Xe5gu, b_Xe5gw, c_Xe5gy, d_Xe5gA, e_Xe5gC, f_Xe5gE,
                         g_Xe5gG)>_R)
              :: ((a_Xe5gu, b_Xe5gw, c_Xe5gy, d_Xe5gA, e_Xe5gC, f_Xe5gE,
                   g_Xe5gG) :: *)
                 ~R# (Identity
                        (a_Xe5gu, b_Xe5gw, c_Xe5gy, d_Xe5gA, e_Xe5gC, f_Xe5gE,
                         g_Xe5gG) :: *))
      }

-- RHS size: {terms: 110, types: 329, coercions: 109, joins: 0/4}
Data.Data.$fData(,,,,,,)_$cgmapMo
  :: forall a b c d e f g.
     (Data a, Data b, Data c, Data d, Data e, Data f, Data g) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d1. Data d1 => d1 -> m d1)
     -> (a, b, c, d, e, f, g) -> m (a, b, c, d, e, f, g)
[GblId,
 Arity=10,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U,U,U,U,U,U)>,
 Unf=OtherCon []]
Data.Data.$fData(,,,,,,)_$cgmapMo
  = \ (@ a_Xe5gs)
      (@ b_Xe5Wj)
      (@ c_Xe5Wm)
      (@ d_Xe5Wp)
      (@ e_Xe5Ws)
      (@ f_Xe5Wv)
      (@ g_Xe5Wy)
      ($dData_Xe5WB :: Data a_Xe5gs)
      ($dData1_Xe5WE :: Data b_Xe5Wj)
      ($dData2_Xe5WH :: Data c_Xe5Wm)
      ($dData3_Xe5WK :: Data d_Xe5Wp)
      ($dData4_Xe5WN :: Data e_Xe5Ws)
      ($dData5_Xe5WQ :: Data f_Xe5Wv)
      ($dData6_Xe5WT :: Data g_Xe5Wy)
      (@ (m_ae4Hc :: * -> *))
      ($dMonadPlus_ae4He :: MonadPlus m_ae4Hc)
      (ds_de7B9 :: forall d1. Data d1 => d1 -> m_ae4Hc d1)
      (eta_XG6
         :: (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
             g_Xe5Wy)) ->
      let {
        lvl270_se9JT
          :: m_ae4Hc (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                      g_Xe5Wy)
        [LclId]
        lvl270_se9JT
          = mzero
              @ m_ae4Hc
              $dMonadPlus_ae4He
              @ (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                 g_Xe5Wy) } in
      let {
        $dMonad_se9rR [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae4Hc
        [LclId]
        $dMonad_se9rR
          = GHC.Base.$p2MonadPlus @ m_ae4Hc $dMonadPlus_ae4He } in
      >>=
        @ m_ae4Hc
        $dMonad_se9rR
        @ ((a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv, g_Xe5Wy),
           Bool)
        @ (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv, g_Xe5Wy)
        (case eta_XG6 of
         { (a1_ae2pt, a2_ae2pu, a3_ae2pv, a4_ae2pw, a5_ae2px, a6_ae2py,
            a7_ae2pz) ->
         let {
           k_se9rQ [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
             :: forall d1 b1.
                Data d1 =>
                Mp m_ae4Hc (d1 -> b1) -> d1 -> m_ae4Hc (b1, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_se9rQ
             = \ (@ d1_ae2Ya)
                 (@ b1_ae2Yb)
                 ($dData7_ae2Yd :: Data d1_ae2Ya)
                 (ds1_de7pC [OS=OneShot] :: Mp m_ae4Hc (d1_ae2Ya -> b1_ae2Yb))
                 (y_ae1TO [OS=OneShot] :: d1_ae2Ya) ->
                 let {
                   lvl271_se9JR :: m_ae4Hc d1_ae2Ya
                   [LclId]
                   lvl271_se9JR = ds_de7B9 @ d1_ae2Ya $dData7_ae2Yd y_ae1TO } in
                 >>=
                   @ m_ae4Hc
                   $dMonad_se9rR
                   @ (d1_ae2Ya -> b1_ae2Yb, Bool)
                   @ (b1_ae2Yb, Bool)
                   (ds1_de7pC
                    `cast` (Data.Data.N:Mp[0] <m_ae4Hc>_R <d1_ae2Ya -> b1_ae2Yb>_N
                            :: (Mp m_ae4Hc (d1_ae2Ya -> b1_ae2Yb) :: *)
                               ~R# (m_ae4Hc (d1_ae2Ya -> b1_ae2Yb, Bool) :: *)))
                   (\ (ds2_de7pD :: (d1_ae2Ya -> b1_ae2Yb, Bool)) ->
                      case ds2_de7pD of { (h_ae1TP, b2_ae1TQ) ->
                      case b2_ae1TQ of {
                        False ->
                          mplus
                            @ m_ae4Hc
                            $dMonadPlus_ae4He
                            @ (b1_ae2Yb, Bool)
                            (>>=
                               @ m_ae4Hc
                               $dMonad_se9rR
                               @ d1_ae2Ya
                               @ (b1_ae2Yb, Bool)
                               lvl271_se9JR
                               (\ (y'_ae1TR :: d1_ae2Ya) ->
                                  return
                                    @ m_ae4Hc
                                    $dMonad_se9rR
                                    @ (b1_ae2Yb, Bool)
                                    (h_ae1TP y'_ae1TR, GHC.Types.True)))
                            (return
                               @ m_ae4Hc
                               $dMonad_se9rR
                               @ (b1_ae2Yb, Bool)
                               (h_ae1TP y_ae1TO, GHC.Types.False));
                        True ->
                          return
                            @ m_ae4Hc
                            $dMonad_se9rR
                            @ (b1_ae2Yb, Bool)
                            (h_ae1TP y_ae1TO, GHC.Types.True)
                      }
                      }) } in
         k_se9rQ
           @ g_Xe5Wy
           @ (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv, g_Xe5Wy)
           $dData6_Xe5WT
           ((k_se9rQ
               @ f_Xe5Wv
               @ (g_Xe5Wy
                  -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv, g_Xe5Wy))
               $dData5_Xe5WQ
               ((k_se9rQ
                   @ e_Xe5Ws
                   @ (f_Xe5Wv
                      -> g_Xe5Wy
                      -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv, g_Xe5Wy))
                   $dData4_Xe5WN
                   ((k_se9rQ
                       @ d_Xe5Wp
                       @ (e_Xe5Ws
                          -> f_Xe5Wv
                          -> g_Xe5Wy
                          -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv, g_Xe5Wy))
                       $dData3_Xe5WK
                       ((k_se9rQ
                           @ c_Xe5Wm
                           @ (d_Xe5Wp
                              -> e_Xe5Ws
                              -> f_Xe5Wv
                              -> g_Xe5Wy
                              -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv, g_Xe5Wy))
                           $dData2_Xe5WH
                           ((k_se9rQ
                               @ b_Xe5Wj
                               @ (c_Xe5Wm
                                  -> d_Xe5Wp
                                  -> e_Xe5Ws
                                  -> f_Xe5Wv
                                  -> g_Xe5Wy
                                  -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                                      g_Xe5Wy))
                               $dData1_Xe5WE
                               ((k_se9rQ
                                   @ a_Xe5gs
                                   @ (b_Xe5Wj
                                      -> c_Xe5Wm
                                      -> d_Xe5Wp
                                      -> e_Xe5Ws
                                      -> f_Xe5Wv
                                      -> g_Xe5Wy
                                      -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                                          g_Xe5Wy))
                                   $dData_Xe5WB
                                   ((return
                                       @ m_ae4Hc
                                       $dMonad_se9rR
                                       @ (a_Xe5gs
                                          -> b_Xe5Wj
                                          -> c_Xe5Wm
                                          -> d_Xe5Wp
                                          -> e_Xe5Ws
                                          -> f_Xe5Wv
                                          -> g_Xe5Wy
                                          -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                                              g_Xe5Wy),
                                          Bool)
                                       (lvl125_rejQj
                                          @ b_Xe5Wj
                                          @ a_Xe5gs
                                          @ c_Xe5Wm
                                          @ d_Xe5Wp
                                          @ e_Xe5Ws
                                          @ f_Xe5Wv
                                          @ g_Xe5Wy))
                                    `cast` (Sym (Data.Data.N:Mp[0]
                                                     <m_ae4Hc>_R
                                                     <a_Xe5gs
                                                      -> b_Xe5Wj
                                                      -> c_Xe5Wm
                                                      -> d_Xe5Wp
                                                      -> e_Xe5Ws
                                                      -> f_Xe5Wv
                                                      -> g_Xe5Wy
                                                      -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp,
                                                          e_Xe5Ws, f_Xe5Wv, g_Xe5Wy)>_N)
                                            :: (m_ae4Hc (a_Xe5gs
                                                         -> b_Xe5Wj
                                                         -> c_Xe5Wm
                                                         -> d_Xe5Wp
                                                         -> e_Xe5Ws
                                                         -> f_Xe5Wv
                                                         -> g_Xe5Wy
                                                         -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp,
                                                             e_Xe5Ws, f_Xe5Wv, g_Xe5Wy),
                                                         Bool) :: *)
                                               ~R# (Mp
                                                      m_ae4Hc
                                                      (a_Xe5gs
                                                       -> b_Xe5Wj
                                                       -> c_Xe5Wm
                                                       -> d_Xe5Wp
                                                       -> e_Xe5Ws
                                                       -> f_Xe5Wv
                                                       -> g_Xe5Wy
                                                       -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp,
                                                           e_Xe5Ws, f_Xe5Wv, g_Xe5Wy)) :: *)))
                                   a1_ae2pt)
                                `cast` (Sym (Data.Data.N:Mp[0]
                                                 <m_ae4Hc>_R
                                                 <b_Xe5Wj
                                                  -> c_Xe5Wm
                                                  -> d_Xe5Wp
                                                  -> e_Xe5Ws
                                                  -> f_Xe5Wv
                                                  -> g_Xe5Wy
                                                  -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws,
                                                      f_Xe5Wv, g_Xe5Wy)>_N)
                                        :: (m_ae4Hc (b_Xe5Wj
                                                     -> c_Xe5Wm
                                                     -> d_Xe5Wp
                                                     -> e_Xe5Ws
                                                     -> f_Xe5Wv
                                                     -> g_Xe5Wy
                                                     -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp,
                                                         e_Xe5Ws, f_Xe5Wv, g_Xe5Wy),
                                                     Bool) :: *)
                                           ~R# (Mp
                                                  m_ae4Hc
                                                  (b_Xe5Wj
                                                   -> c_Xe5Wm
                                                   -> d_Xe5Wp
                                                   -> e_Xe5Ws
                                                   -> f_Xe5Wv
                                                   -> g_Xe5Wy
                                                   -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws,
                                                       f_Xe5Wv, g_Xe5Wy)) :: *)))
                               a2_ae2pu)
                            `cast` (Sym (Data.Data.N:Mp[0]
                                             <m_ae4Hc>_R
                                             <c_Xe5Wm
                                              -> d_Xe5Wp
                                              -> e_Xe5Ws
                                              -> f_Xe5Wv
                                              -> g_Xe5Wy
                                              -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws,
                                                  f_Xe5Wv, g_Xe5Wy)>_N)
                                    :: (m_ae4Hc (c_Xe5Wm
                                                 -> d_Xe5Wp
                                                 -> e_Xe5Ws
                                                 -> f_Xe5Wv
                                                 -> g_Xe5Wy
                                                 -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws,
                                                     f_Xe5Wv, g_Xe5Wy),
                                                 Bool) :: *)
                                       ~R# (Mp
                                              m_ae4Hc
                                              (c_Xe5Wm
                                               -> d_Xe5Wp
                                               -> e_Xe5Ws
                                               -> f_Xe5Wv
                                               -> g_Xe5Wy
                                               -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws,
                                                   f_Xe5Wv, g_Xe5Wy)) :: *)))
                           a3_ae2pv)
                        `cast` (Sym (Data.Data.N:Mp[0]
                                         <m_ae4Hc>_R
                                         <d_Xe5Wp
                                          -> e_Xe5Ws
                                          -> f_Xe5Wv
                                          -> g_Xe5Wy
                                          -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                                              g_Xe5Wy)>_N)
                                :: (m_ae4Hc (d_Xe5Wp
                                             -> e_Xe5Ws
                                             -> f_Xe5Wv
                                             -> g_Xe5Wy
                                             -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws,
                                                 f_Xe5Wv, g_Xe5Wy),
                                             Bool) :: *)
                                   ~R# (Mp
                                          m_ae4Hc
                                          (d_Xe5Wp
                                           -> e_Xe5Ws
                                           -> f_Xe5Wv
                                           -> g_Xe5Wy
                                           -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                                               g_Xe5Wy)) :: *)))
                       a4_ae2pw)
                    `cast` (Sym (Data.Data.N:Mp[0]
                                     <m_ae4Hc>_R
                                     <e_Xe5Ws
                                      -> f_Xe5Wv
                                      -> g_Xe5Wy
                                      -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                                          g_Xe5Wy)>_N)
                            :: (m_ae4Hc (e_Xe5Ws
                                         -> f_Xe5Wv
                                         -> g_Xe5Wy
                                         -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                                             g_Xe5Wy),
                                         Bool) :: *)
                               ~R# (Mp
                                      m_ae4Hc
                                      (e_Xe5Ws
                                       -> f_Xe5Wv
                                       -> g_Xe5Wy
                                       -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                                           g_Xe5Wy)) :: *)))
                   a5_ae2px)
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_ae4Hc>_R
                                 <f_Xe5Wv
                                  -> g_Xe5Wy
                                  -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                                      g_Xe5Wy)>_N)
                        :: (m_ae4Hc (f_Xe5Wv
                                     -> g_Xe5Wy
                                     -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                                         g_Xe5Wy),
                                     Bool) :: *)
                           ~R# (Mp
                                  m_ae4Hc
                                  (f_Xe5Wv
                                   -> g_Xe5Wy
                                   -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                                       g_Xe5Wy)) :: *)))
               a6_ae2py)
            `cast` (Sym (Data.Data.N:Mp[0]
                             <m_ae4Hc>_R
                             <g_Xe5Wy
                              -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                                  g_Xe5Wy)>_N)
                    :: (m_ae4Hc (g_Xe5Wy
                                 -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv, g_Xe5Wy),
                                 Bool) :: *)
                       ~R# (Mp
                              m_ae4Hc
                              (g_Xe5Wy
                               -> (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                                   g_Xe5Wy)) :: *)))
           a7_ae2pz
         })
        (\ (ds1_de7pa
              :: ((a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                   g_Xe5Wy),
                  Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b1_ae1TT) ->
           case b1_ae1TT of {
             False -> lvl270_se9JT;
             True ->
               return
                 @ m_ae4Hc
                 $dMonad_se9rR
                 @ (a_Xe5gs, b_Xe5Wj, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv, g_Xe5Wy)
                 x'_ae1TS
           }
           })

-- RHS size: {terms: 12, types: 37, coercions: 0, joins: 0/0}
lvl126_rejQk
  :: forall g f e d c b a. (a, b, c, d, e, f, g) -> Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []]
lvl126_rejQk
  = \ (@ g_Xe5Wy)
      (@ f_Xe5Wv)
      (@ e_Xe5Ws)
      (@ d_Xe5Wp)
      (@ c_Xe5Wm)
      (@ b_Xe5gt)
      (@ a_Xe5gr)
      (ds_de7AM
         :: (a_Xe5gr, b_Xe5gt, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
             g_Xe5Wy)) ->
      case ds_de7AM of
      { (ds1_de7AN, ds2_de7AO, ds3_de7AP, ds4_de7AQ, ds5_de7AR,
         ds6_de7AS, ds7_de7AT) ->
      Data.Data.$c(,,,,,,)
      }

-- RHS size: {terms: 9, types: 22, coercions: 0, joins: 0/0}
lvl127_rejQl
  :: forall a b c d e f g. (a, b, c, d, e, f, g) -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl127_rejQl
  = \ (@ a_Xe5gr)
      (@ b_Xe5gt)
      (@ c_Xe5Wm)
      (@ d_Xe5Wp)
      (@ e_Xe5Ws)
      (@ f_Xe5Wv)
      (@ g_Xe5Wy)
      _ [Occ=Dead] ->
      Data.Data.$t(,,,,,,)

-- RHS size: {terms: 12, types: 44, coercions: 0, joins: 0/0}
lvl128_rejQm
  :: forall a b c1 d e f g (t :: * -> *) (c2 :: * -> *).
     Typeable t =>
     (forall d1. Data d1 => c2 (t d1))
     -> Maybe (c2 (a, b, c1, d, e, f, g))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl128_rejQm
  = \ (@ a_Xe5gr)
      (@ b_Xe5gt)
      (@ c_Xe5Wm)
      (@ d_Xe5Wp)
      (@ e_Xe5Ws)
      (@ f_Xe5Wv)
      (@ g_Xe5Wy)
      (@ (t_ae4EP :: * -> *))
      (@ (c1_ae4EQ :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing
        @ (c1_ae4EQ (a_Xe5gr, b_Xe5gt, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                     g_Xe5Wy))

-- RHS size: {terms: 12, types: 53, coercions: 0, joins: 0/0}
lvl129_rejQn
  :: forall a b c1 d e f g (t :: * -> * -> *) (c2 :: * -> *).
     Typeable t =>
     (forall d1 e1. (Data d1, Data e1) => c2 (t d1 e1))
     -> Maybe (c2 (a, b, c1, d, e, f, g))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl129_rejQn
  = \ (@ a_Xe5gr)
      (@ b_Xe5gt)
      (@ c_Xe5Wm)
      (@ d_Xe5Wp)
      (@ e_Xe5Ws)
      (@ f_Xe5Wv)
      (@ g_Xe5Wy)
      (@ (t_ae4F8 :: * -> * -> *))
      (@ (c1_ae4F9 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing
        @ (c1_ae4F9 (a_Xe5gr, b_Xe5gt, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                     g_Xe5Wy))

-- RHS size: {terms: 113, types: 163, coercions: 77, joins: 0/0}
Data.Data.$fData(,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e f g.
     (Data a, Data b, Data c, Data d, Data e, Data f, Data g) =>
     Data (a, b, c, d, e, f, g)
[GblId[DFunId],
 Arity=7,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_ae1Xv)
             (@ b_ae1Xw)
             (@ c_ae1Xx)
             (@ d_ae1Xy)
             (@ e_ae1Xz)
             (@ f_ae1XA)
             (@ g_ae1XB)
             (v_XFX :: Data a_ae1Xv)
             (v1_XFZ :: Data b_ae1Xw)
             (v2_XG1 :: Data c_ae1Xx)
             (v3_XG3 :: Data d_ae1Xy)
             (v4_B5 :: Data e_ae1Xz)
             (v5_B6 :: Data f_ae1XA)
             (v6_B7 :: Data g_ae1XB) ->
       Data.Data.C:Data TYPE: (a_ae1Xv, b_ae1Xw, c_ae1Xx, d_ae1Xy,
                               e_ae1Xz, f_ae1XA, g_ae1XB)
                        (Data.Data.$fData(,,,,,,)7
                           @ a_ae1Xv
                           @ b_ae1Xw
                           @ c_ae1Xx
                           @ d_ae1Xy
                           @ e_ae1Xz
                           @ f_ae1XA
                           @ g_ae1XB
                           v_XFX
                           v1_XFZ
                           v2_XG1
                           v3_XG3
                           v4_B5
                           v5_B6
                           v6_B7)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <(a_ae1Xv,
                                                                                   b_ae1Xw, c_ae1Xx,
                                                                                   d_ae1Xy, e_ae1Xz,
                                                                                   f_ae1XA,
                                                                                   g_ae1XB)>_N
                                :: (Data.Typeable.Internal.TypeRep
                                      (a_ae1Xv, b_ae1Xw, c_ae1Xx, d_ae1Xy, e_ae1Xz, f_ae1XA,
                                       g_ae1XB) :: *)
                                   ~R# (Typeable
                                          (a_ae1Xv, b_ae1Xw, c_ae1Xx, d_ae1Xy, e_ae1Xz, f_ae1XA,
                                           g_ae1XB) :: Constraint))
                        Data.Data.$fData(,,,,,,)_$cgfoldl
                          @ a_ae1Xv
                          @ b_ae1Xw
                          @ c_ae1Xx
                          @ d_ae1Xy
                          @ e_ae1Xz
                          @ f_ae1XA
                          @ g_ae1XB
                          v_XFX
                          v1_XFZ
                          v2_XG1
                          v3_XG3
                          v4_B5
                          v5_B6
                          v6_B7
                        Data.Data.$fData(,,,,,,)_$cgunfold
                          @ a_ae1Xv
                          @ b_ae1Xw
                          @ c_ae1Xx
                          @ d_ae1Xy
                          @ e_ae1Xz
                          @ f_ae1XA
                          @ g_ae1XB
                          v_XFX
                          v1_XFZ
                          v2_XG1
                          v3_XG3
                          v4_B5
                          v5_B6
                          v6_B7
                        \ (ds_de7AM [Occ=Once!]
                             :: (a_ae1Xv, b_ae1Xw, c_ae1Xx, d_ae1Xy, e_ae1Xz, f_ae1XA,
                                 g_ae1XB)) ->
                          case ds_de7AM of
                          { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead],
                             _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
                          Data.Data.$c(,,,,,,)
                          }
                        \ _ [Occ=Dead] -> Data.Data.$t(,,,,,,)
                        \ (@ (t_ae4EP :: * -> *))
                          (@ (c1_ae4EQ :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing
                            @ (c1_ae4EQ (a_ae1Xv, b_ae1Xw, c_ae1Xx, d_ae1Xy, e_ae1Xz, f_ae1XA,
                                         g_ae1XB))
                        \ (@ (t_ae4F8 :: * -> * -> *))
                          (@ (c1_ae4F9 :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing
                            @ (c1_ae4F9 (a_ae1Xv, b_ae1Xw, c_ae1Xx, d_ae1Xy, e_ae1Xz, f_ae1XA,
                                         g_ae1XB))
                        (Data.Data.$fData(,,,,,,)2
                           @ a_ae1Xv
                           @ b_ae1Xw
                           @ c_ae1Xx
                           @ d_ae1Xy
                           @ e_ae1Xz
                           @ f_ae1XA
                           @ g_ae1XB
                           v_XFX
                           v1_XFZ
                           v2_XG1
                           v3_XG3
                           v4_B5
                           v5_B6
                           v6_B7)
                        `cast` (<forall b1. Data b1 => b1 -> b1>_R
                                ->_R <(a_ae1Xv, b_ae1Xw, c_ae1Xx, d_ae1Xy, e_ae1Xz, f_ae1XA,
                                       g_ae1XB)>_R
                                ->_R Data.Functor.Identity.N:Identity[0]
                                         <(a_ae1Xv, b_ae1Xw, c_ae1Xx, d_ae1Xy, e_ae1Xz, f_ae1XA,
                                           g_ae1XB)>_R
                                :: ((forall b1. Data b1 => b1 -> b1)
                                    -> (a_ae1Xv, b_ae1Xw, c_ae1Xx, d_ae1Xy, e_ae1Xz, f_ae1XA,
                                        g_ae1XB)
                                    -> Identity
                                         (a_ae1Xv, b_ae1Xw, c_ae1Xx, d_ae1Xy, e_ae1Xz, f_ae1XA,
                                          g_ae1XB) :: *)
                                   ~R# ((forall b1. Data b1 => b1 -> b1)
                                        -> (a_ae1Xv, b_ae1Xw, c_ae1Xx, d_ae1Xy, e_ae1Xz, f_ae1XA,
                                            g_ae1XB)
                                        -> (a_ae1Xv, b_ae1Xw, c_ae1Xx, d_ae1Xy, e_ae1Xz, f_ae1XA,
                                            g_ae1XB) :: *))
                        (Data.Data.$fData(,,,,,,)1
                           @ a_ae1Xv
                           @ b_ae1Xw
                           @ c_ae1Xx
                           @ d_ae1Xy
                           @ e_ae1Xz
                           @ f_ae1XA
                           @ g_ae1XB
                           v_XFX
                           v1_XFZ
                           v2_XG1
                           v3_XG3
                           v4_B5
                           v5_B6
                           v6_B7)
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d1. Data d1 => d1 -> r'>_R
                                ->_R <(a_ae1Xv, b_ae1Xw, c_ae1Xx, d_ae1Xy, e_ae1Xz, f_ae1XA,
                                       g_ae1XB)>_R
                                ->_R Data.Functor.Const.N:Const[0]
                                         <*>_N
                                         <r>_R
                                         <(a_ae1Xv, b_ae1Xw, c_ae1Xx, d_ae1Xy, e_ae1Xz, f_ae1XA,
                                           g_ae1XB)>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d1. Data d1 => d1 -> r')
                                    -> (a_ae1Xv, b_ae1Xw, c_ae1Xx, d_ae1Xy, e_ae1Xz, f_ae1XA,
                                        g_ae1XB)
                                    -> Const
                                         r
                                         (a_ae1Xv, b_ae1Xw, c_ae1Xx, d_ae1Xy, e_ae1Xz, f_ae1XA,
                                          g_ae1XB) :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d1. Data d1 => d1 -> r')
                                        -> (a_ae1Xv, b_ae1Xw, c_ae1Xx, d_ae1Xy, e_ae1Xz, f_ae1XA,
                                            g_ae1XB)
                                        -> r :: *))
                        Data.Data.$fData(,,,,,,)_$cgmapQr
                          @ a_ae1Xv
                          @ b_ae1Xw
                          @ c_ae1Xx
                          @ d_ae1Xy
                          @ e_ae1Xz
                          @ f_ae1XA
                          @ g_ae1XB
                          v_XFX
                          v1_XFZ
                          v2_XG1
                          v3_XG3
                          v4_B5
                          v5_B6
                          v6_B7
                        Data.Data.$fData(,,,,,,)_$cgmapQ
                          @ a_ae1Xv
                          @ b_ae1Xw
                          @ c_ae1Xx
                          @ d_ae1Xy
                          @ e_ae1Xz
                          @ f_ae1XA
                          @ g_ae1XB
                          v_XFX
                          v1_XFZ
                          v2_XG1
                          v3_XG3
                          v4_B5
                          v5_B6
                          v6_B7
                        Data.Data.$fData(,,,,,,)_$cgmapQi
                          @ a_ae1Xv
                          @ b_ae1Xw
                          @ c_ae1Xx
                          @ d_ae1Xy
                          @ e_ae1Xz
                          @ f_ae1XA
                          @ g_ae1XB
                          v_XFX
                          v1_XFZ
                          v2_XG1
                          v3_XG3
                          v4_B5
                          v5_B6
                          v6_B7
                        Data.Data.$fData(,,,,,,)_$cgmapM
                          @ a_ae1Xv
                          @ b_ae1Xw
                          @ c_ae1Xx
                          @ d_ae1Xy
                          @ e_ae1Xz
                          @ f_ae1XA
                          @ g_ae1XB
                          v_XFX
                          v1_XFZ
                          v2_XG1
                          v3_XG3
                          v4_B5
                          v5_B6
                          v6_B7
                        Data.Data.$fData(,,,,,,)_$cgmapMp
                          @ a_ae1Xv
                          @ b_ae1Xw
                          @ c_ae1Xx
                          @ d_ae1Xy
                          @ e_ae1Xz
                          @ f_ae1XA
                          @ g_ae1XB
                          v_XFX
                          v1_XFZ
                          v2_XG1
                          v3_XG3
                          v4_B5
                          v5_B6
                          v6_B7
                        Data.Data.$fData(,,,,,,)_$cgmapMo
                          @ a_ae1Xv
                          @ b_ae1Xw
                          @ c_ae1Xx
                          @ d_ae1Xy
                          @ e_ae1Xz
                          @ f_ae1XA
                          @ g_ae1XB
                          v_XFX
                          v1_XFZ
                          v2_XG1
                          v3_XG3
                          v4_B5
                          v5_B6
                          v6_B7]
Data.Data.$fData(,,,,,,)
  = \ (@ a_Xe5gr)
      (@ b_Xe5gt)
      (@ c_Xe5Wm)
      (@ d_Xe5Wp)
      (@ e_Xe5Ws)
      (@ f_Xe5Wv)
      (@ g_Xe5Wy)
      ($dData_Xe5WB :: Data a_Xe5gr)
      ($dData1_Xe5WE :: Data b_Xe5gt)
      ($dData2_Xe5WH :: Data c_Xe5Wm)
      ($dData3_Xe5WK :: Data d_Xe5Wp)
      ($dData4_Xe5WN :: Data e_Xe5Ws)
      ($dData5_Xe5WQ :: Data f_Xe5Wv)
      ($dData6_Xe5WT :: Data g_Xe5Wy) ->
      Data.Data.C:Data
        @ (a_Xe5gr, b_Xe5gt, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv, g_Xe5Wy)
        ((Data.Data.$fData(,,,,,,)7
            @ a_Xe5gr
            @ b_Xe5gt
            @ c_Xe5Wm
            @ d_Xe5Wp
            @ e_Xe5Ws
            @ f_Xe5Wv
            @ g_Xe5Wy
            $dData_Xe5WB
            $dData1_Xe5WE
            $dData2_Xe5WH
            $dData3_Xe5WK
            $dData4_Xe5WN
            $dData5_Xe5WQ
            $dData6_Xe5WT)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <(a_Xe5gr,
                                                                    b_Xe5gt, c_Xe5Wm, d_Xe5Wp,
                                                                    e_Xe5Ws, f_Xe5Wv, g_Xe5Wy)>_N
                 :: (Data.Typeable.Internal.TypeRep
                       (a_Xe5gr, b_Xe5gt, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                        g_Xe5Wy) :: *)
                    ~R# (Typeable
                           (a_Xe5gr, b_Xe5gt, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                            g_Xe5Wy) :: Constraint)))
        (Data.Data.$fData(,,,,,,)_$cgfoldl
           @ a_Xe5gr
           @ b_Xe5gt
           @ c_Xe5Wm
           @ d_Xe5Wp
           @ e_Xe5Ws
           @ f_Xe5Wv
           @ g_Xe5Wy
           $dData_Xe5WB
           $dData1_Xe5WE
           $dData2_Xe5WH
           $dData3_Xe5WK
           $dData4_Xe5WN
           $dData5_Xe5WQ
           $dData6_Xe5WT)
        (\ (@ (c1_sefSf :: * -> *))
           (w_sefSg
              :: forall b1 r. Data b1 => c1_sefSf (b1 -> r) -> c1_sefSf r)
           (w1_sefSh :: forall r. r -> c1_sefSf r)
           _ [Occ=Dead] ->
           Data.Data.$w$cgunfold2
             @ a_Xe5gr
             @ b_Xe5gt
             @ c_Xe5Wm
             @ d_Xe5Wp
             @ e_Xe5Ws
             @ f_Xe5Wv
             @ g_Xe5Wy
             $dData_Xe5WB
             $dData1_Xe5WE
             $dData2_Xe5WH
             $dData3_Xe5WK
             $dData4_Xe5WN
             $dData5_Xe5WQ
             $dData6_Xe5WT
             @ c1_sefSf
             w_sefSg
             w1_sefSh)
        (lvl126_rejQk
           @ g_Xe5Wy
           @ f_Xe5Wv
           @ e_Xe5Ws
           @ d_Xe5Wp
           @ c_Xe5Wm
           @ b_Xe5gt
           @ a_Xe5gr)
        (lvl127_rejQl
           @ a_Xe5gr
           @ b_Xe5gt
           @ c_Xe5Wm
           @ d_Xe5Wp
           @ e_Xe5Ws
           @ f_Xe5Wv
           @ g_Xe5Wy)
        (lvl128_rejQm
           @ a_Xe5gr
           @ b_Xe5gt
           @ c_Xe5Wm
           @ d_Xe5Wp
           @ e_Xe5Ws
           @ f_Xe5Wv
           @ g_Xe5Wy)
        (lvl129_rejQn
           @ a_Xe5gr
           @ b_Xe5gt
           @ c_Xe5Wm
           @ d_Xe5Wp
           @ e_Xe5Ws
           @ f_Xe5Wv
           @ g_Xe5Wy)
        ((Data.Data.$fData(,,,,,,)2
            @ a_Xe5gr
            @ b_Xe5gt
            @ c_Xe5Wm
            @ d_Xe5Wp
            @ e_Xe5Ws
            @ f_Xe5Wv
            @ g_Xe5Wy
            $dData_Xe5WB
            $dData1_Xe5WE
            $dData2_Xe5WH
            $dData3_Xe5WK
            $dData4_Xe5WN
            $dData5_Xe5WQ
            $dData6_Xe5WT)
         `cast` (<forall b1. Data b1 => b1 -> b1>_R
                 ->_R <(a_Xe5gr, b_Xe5gt, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                        g_Xe5Wy)>_R
                 ->_R Data.Functor.Identity.N:Identity[0]
                          <(a_Xe5gr, b_Xe5gt, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv, g_Xe5Wy)>_R
                 :: ((forall b1. Data b1 => b1 -> b1)
                     -> (a_Xe5gr, b_Xe5gt, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv, g_Xe5Wy)
                     -> Identity
                          (a_Xe5gr, b_Xe5gt, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                           g_Xe5Wy) :: *)
                    ~R# ((forall b1. Data b1 => b1 -> b1)
                         -> (a_Xe5gr, b_Xe5gt, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv, g_Xe5Wy)
                         -> (a_Xe5gr, b_Xe5gt, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                             g_Xe5Wy) :: *)))
        ((Data.Data.$fData(,,,,,,)1
            @ a_Xe5gr
            @ b_Xe5gt
            @ c_Xe5Wm
            @ d_Xe5Wp
            @ e_Xe5Ws
            @ f_Xe5Wv
            @ g_Xe5Wy
            $dData_Xe5WB
            $dData1_Xe5WE
            $dData2_Xe5WH
            $dData3_Xe5WK
            $dData4_Xe5WN
            $dData5_Xe5WQ
            $dData6_Xe5WT)
         `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                 <r -> r' -> r>_R
                 ->_R <r>_R
                 ->_R <forall d1. Data d1 => d1 -> r'>_R
                 ->_R <(a_Xe5gr, b_Xe5gt, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                        g_Xe5Wy)>_R
                 ->_R Data.Functor.Const.N:Const[0]
                          <*>_N
                          <r>_R
                          <(a_Xe5gr, b_Xe5gt, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv, g_Xe5Wy)>_P
                 :: (forall r r'.
                     (r -> r' -> r)
                     -> r
                     -> (forall d1. Data d1 => d1 -> r')
                     -> (a_Xe5gr, b_Xe5gt, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv, g_Xe5Wy)
                     -> Const
                          r
                          (a_Xe5gr, b_Xe5gt, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv,
                           g_Xe5Wy) :: *)
                    ~R# (forall r r'.
                         (r -> r' -> r)
                         -> r
                         -> (forall d1. Data d1 => d1 -> r')
                         -> (a_Xe5gr, b_Xe5gt, c_Xe5Wm, d_Xe5Wp, e_Xe5Ws, f_Xe5Wv, g_Xe5Wy)
                         -> r :: *)))
        (Data.Data.$fData(,,,,,,)_$cgmapQr
           @ a_Xe5gr
           @ b_Xe5gt
           @ c_Xe5Wm
           @ d_Xe5Wp
           @ e_Xe5Ws
           @ f_Xe5Wv
           @ g_Xe5Wy
           $dData_Xe5WB
           $dData1_Xe5WE
           $dData2_Xe5WH
           $dData3_Xe5WK
           $dData4_Xe5WN
           $dData5_Xe5WQ
           $dData6_Xe5WT)
        (Data.Data.$fData(,,,,,,)_$cgmapQ
           @ a_Xe5gr
           @ b_Xe5gt
           @ c_Xe5Wm
           @ d_Xe5Wp
           @ e_Xe5Ws
           @ f_Xe5Wv
           @ g_Xe5Wy
           $dData_Xe5WB
           $dData1_Xe5WE
           $dData2_Xe5WH
           $dData3_Xe5WK
           $dData4_Xe5WN
           $dData5_Xe5WQ
           $dData6_Xe5WT)
        (Data.Data.$fData(,,,,,,)_$cgmapQi
           @ a_Xe5gr
           @ b_Xe5gt
           @ c_Xe5Wm
           @ d_Xe5Wp
           @ e_Xe5Ws
           @ f_Xe5Wv
           @ g_Xe5Wy
           $dData_Xe5WB
           $dData1_Xe5WE
           $dData2_Xe5WH
           $dData3_Xe5WK
           $dData4_Xe5WN
           $dData5_Xe5WQ
           $dData6_Xe5WT)
        (Data.Data.$fData(,,,,,,)_$cgmapM
           @ a_Xe5gr
           @ b_Xe5gt
           @ c_Xe5Wm
           @ d_Xe5Wp
           @ e_Xe5Ws
           @ f_Xe5Wv
           @ g_Xe5Wy
           $dData_Xe5WB
           $dData1_Xe5WE
           $dData2_Xe5WH
           $dData3_Xe5WK
           $dData4_Xe5WN
           $dData5_Xe5WQ
           $dData6_Xe5WT)
        (Data.Data.$fData(,,,,,,)_$cgmapMp
           @ a_Xe5gr
           @ b_Xe5gt
           @ c_Xe5Wm
           @ d_Xe5Wp
           @ e_Xe5Ws
           @ f_Xe5Wv
           @ g_Xe5Wy
           $dData_Xe5WB
           $dData1_Xe5WE
           $dData2_Xe5WH
           $dData3_Xe5WK
           $dData4_Xe5WN
           $dData5_Xe5WQ
           $dData6_Xe5WT)
        (Data.Data.$fData(,,,,,,)_$cgmapMo
           @ a_Xe5gr
           @ b_Xe5gt
           @ c_Xe5Wm
           @ d_Xe5Wp
           @ e_Xe5Ws
           @ f_Xe5Wv
           @ g_Xe5Wy
           $dData_Xe5WB
           $dData1_Xe5WE
           $dData2_Xe5WH
           $dData3_Xe5WK
           $dData4_Xe5WN
           $dData5_Xe5WQ
           $dData6_Xe5WT)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataIntPtr7 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fDataIntPtr7 = "IntPtr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataIntPtr6 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataIntPtr6 = unpackCString# Data.Data.$fDataIntPtr7

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go18_rejQo :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go18_rejQo
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fDataIntPtr6 of {
                False -> go18_rejQo ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cIntPtr1_rejQp :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cIntPtr1_rejQp = Data.Data.AlgConstr $cIntPtr2_rejQq

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataIntPtr5 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataIntPtr5
  = GHC.Types.: @ Constr Data.Data.$cIntPtr (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataIntPtr4 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataIntPtr4 = Data.Data.AlgRep Data.Data.$fDataIntPtr5

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tIntPtr :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$tIntPtr
  = Data.Data.DataType
      Data.Data.$fDataIntPtr6 Data.Data.$fDataIntPtr4

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cIntPtr [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cIntPtr
  = Data.Data.Constr
      $cIntPtr1_rejQp
      Data.Data.$fDataIntPtr6
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tIntPtr

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cIntPtr2_rejQq :: ConIndex
[GblId]
$cIntPtr2_rejQq
  = go18_rejQo Data.Data.$fDataIntPtr5 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataIntPtr_$cdataTypeOf :: IntPtr -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Data.$tIntPtr}]
Data.Data.$fDataIntPtr_$cdataTypeOf
  = \ _ [Occ=Dead] -> Data.Data.$tIntPtr

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataIntPtr_$ctoConstr :: IntPtr -> Constr
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Data.$cIntPtr}]
Data.Data.$fDataIntPtr_$ctoConstr
  = \ _ [Occ=Dead] -> Data.Data.$cIntPtr

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataIntPtr_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c IntPtr)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae4AC :: * -> *))
                 (@ (c_ae4AD :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae4AD IntPtr)}]
Data.Data.$fDataIntPtr_$cdataCast1
  = \ (@ (t_ae4AC :: * -> *))
      (@ (c_ae4AD :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae4AD IntPtr)

-- RHS size: {terms: 3, types: 3, coercions: 4, joins: 0/0}
Data.Data.$fDataIntPtr1 :: (Int -> IntPtr, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataIntPtr1
  = (Data.Data.$fDataIntPtr2
     `cast` (<Int>_R ->_R Sym (Foreign.Ptr.N:IntPtr[0])
             :: (Int -> Int :: *) ~R# (Int -> IntPtr :: *)),
     GHC.Types.False)

-- RHS size: {terms: 55, types: 86, coercions: 2, joins: 0/3}
Data.Data.$fDataIntPtr_$cgmapMp
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> IntPtr -> m IntPtr
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 60 0] 510 0}]
Data.Data.$fDataIntPtr_$cgmapMp
  = \ (@ (m_ae4CJ :: * -> *))
      ($dMonadPlus_ae4CL :: MonadPlus m_ae4CJ)
      (ds_de7AI :: forall d. Data d => d -> m_ae4CJ d)
      (eta_XG2 :: IntPtr) ->
      let {
        lvl270_se9K7 :: m_ae4CJ IntPtr
        [LclId]
        lvl270_se9K7 = mzero @ m_ae4CJ $dMonadPlus_ae4CL @ IntPtr } in
      let {
        $dMonad_se9rN [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae4CJ
        [LclId]
        $dMonad_se9rN
          = GHC.Base.$p2MonadPlus @ m_ae4CJ $dMonadPlus_ae4CL } in
      >>=
        @ m_ae4CJ
        $dMonad_se9rN
        @ (IntPtr, Bool)
        @ IntPtr
        (let {
           lvl271_se9K6 :: m_ae4CJ Int
           [LclId]
           lvl271_se9K6
             = ds_de7AI
                 @ Int
                 Data.Data.$fDataInt
                 (eta_XG2
                  `cast` (Foreign.Ptr.N:IntPtr[0]
                          :: (IntPtr :: *) ~R# (Int :: *))) } in
         >>=
           @ m_ae4CJ
           $dMonad_se9rN
           @ (Int -> IntPtr, Bool)
           @ (IntPtr, Bool)
           (return
              @ m_ae4CJ
              $dMonad_se9rN
              @ (Int -> IntPtr, Bool)
              Data.Data.$fDataIntPtr1)
           (\ (ds1_de7oD :: (Int -> IntPtr, Bool)) ->
              case ds1_de7oD of { (h_ae1TA, b_ae1TB) ->
              mplus
                @ m_ae4CJ
                $dMonadPlus_ae4CL
                @ (IntPtr, Bool)
                (>>=
                   @ m_ae4CJ
                   $dMonad_se9rN
                   @ Int
                   @ (IntPtr, Bool)
                   lvl271_se9K6
                   (\ (y'_ae1TC :: Int) ->
                      return
                        @ m_ae4CJ
                        $dMonad_se9rN
                        @ (IntPtr, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_ae4CJ
                   $dMonad_se9rN
                   @ (IntPtr, Bool)
                   (h_ae1TA
                      (eta_XG2
                       `cast` (Foreign.Ptr.N:IntPtr[0] :: (IntPtr :: *) ~R# (Int :: *))),
                    b_ae1TB))
              }))
        (\ (ds1_de7oa :: (IntPtr, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9K7;
             True -> return @ m_ae4CJ $dMonad_se9rN @ IntPtr x'_ae1TD
           }
           })

-- RHS size: {terms: 22, types: 32, coercions: 5, joins: 0/1}
Data.Data.$fDataIntPtr_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> IntPtr -> m IntPtr
[GblId,
 Arity=3,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [120 60 0] 220 0}]
Data.Data.$fDataIntPtr_$cgmapM
  = \ (@ (m_ae4Ct :: * -> *))
      ($dMonad_ae4Cv :: Monad m_ae4Ct)
      (ds_de7AH :: forall d. Data d => d -> m_ae4Ct d)
      (eta_XG3 :: IntPtr) ->
      let {
        lvl270_se9K9 :: m_ae4Ct Int
        [LclId]
        lvl270_se9K9
          = ds_de7AH
              @ Int
              Data.Data.$fDataInt
              (eta_XG3
               `cast` (Foreign.Ptr.N:IntPtr[0]
                       :: (IntPtr :: *) ~R# (Int :: *))) } in
      >>=
        @ m_ae4Ct
        $dMonad_ae4Cv
        @ (Int -> IntPtr)
        @ IntPtr
        (return
           @ m_ae4Ct
           $dMonad_ae4Cv
           @ (Int -> IntPtr)
           (Data.Data.$fDataIntPtr2
            `cast` (<Int>_R ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                    :: (Int -> Int :: *) ~R# (Int -> IntPtr :: *))))
        (\ (c'_ae1To :: Int -> IntPtr) ->
           >>=
             @ m_ae4Ct
             $dMonad_ae4Cv
             @ Int
             @ IntPtr
             lvl270_se9K9
             (\ (x'_ae1Tp :: Int) ->
                return @ m_ae4Ct $dMonad_ae4Cv @ IntPtr (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 15, types: 15, coercions: 1, joins: 0/0}
Data.Data.$fDataIntPtr_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> IntPtr -> u
[GblId,
 Arity=3,
 Str=<S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae4Cf)
                 (ds_de7AF [Occ=Once!] :: Int)
                 (ds1_de7AG [Occ=Once!] :: forall d. Data d => d -> u_ae4Cf)
                 (x_ae1T7 [Occ=Once] :: IntPtr) ->
                 case ds_de7AF of { I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_ae4Cf;
                   0# ->
                     ds1_de7AG
                       @ Int
                       Data.Data.$fDataInt
                       (x_ae1T7
                        `cast` (Foreign.Ptr.N:IntPtr[0] :: (IntPtr :: *) ~R# (Int :: *)))
                 }
                 }}]
Data.Data.$fDataIntPtr_$cgmapQi
  = \ (@ u_ae4Cf)
      (ds_de7AF :: Int)
      (ds1_de7AG :: forall d. Data d => d -> u_ae4Cf)
      (x_ae1T7 :: IntPtr) ->
      case ds_de7AF of { I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_ae4Cf;
        0# ->
          ds1_de7AG
            @ Int
            Data.Data.$fDataInt
            (x_ae1T7
             `cast` (Foreign.Ptr.N:IntPtr[0] :: (IntPtr :: *) ~R# (Int :: *)))
      }
      }

-- RHS size: {terms: 11, types: 16, coercions: 1, joins: 0/0}
Data.Data.$fDataIntPtr_$cgmapQr
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> IntPtr -> r
[GblId,
 Arity=4,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_ae4BK)
                 (@ r'_ae4BL)
                 (ds_de7AB [Occ=Once!] :: r'_ae4BL -> r_ae4BK -> r_ae4BK)
                 (ds1_de7AC [Occ=Once] :: r_ae4BK)
                 (ds2_de7AD [Occ=Once!] :: forall d. Data d => d -> r'_ae4BL)
                 (x0_ae1SX [Occ=Once] :: IntPtr) ->
                 ds_de7AB
                   (ds2_de7AD
                      @ Int
                      Data.Data.$fDataInt
                      (x0_ae1SX
                       `cast` (Foreign.Ptr.N:IntPtr[0] :: (IntPtr :: *) ~R# (Int :: *))))
                   ds1_de7AC}]
Data.Data.$fDataIntPtr_$cgmapQr
  = \ (@ r_ae4BK)
      (@ r'_ae4BL)
      (ds_de7AB :: r'_ae4BL -> r_ae4BK -> r_ae4BK)
      (ds1_de7AC :: r_ae4BK)
      (ds2_de7AD :: forall d. Data d => d -> r'_ae4BL)
      (x0_ae1SX :: IntPtr) ->
      ds_de7AB
        (ds2_de7AD
           @ Int
           Data.Data.$fDataInt
           (x0_ae1SX
            `cast` (Foreign.Ptr.N:IntPtr[0] :: (IntPtr :: *) ~R# (Int :: *))))
        ds1_de7AC

-- RHS size: {terms: 8, types: 12, coercions: 1, joins: 0/0}
Data.Data.$fDataIntPtr_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> IntPtr -> [u]
[GblId,
 Arity=2,
 Str=<L,1*C1(C1(U))><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae4C1)
                 (ds_de7AE [Occ=Once!] :: forall d. Data d => d -> u_ae4C1)
                 (x0_ae1SX [Occ=Once] :: IntPtr) ->
                 GHC.Types.:
                   @ u_ae4C1
                   (ds_de7AE
                      @ Int
                      Data.Data.$fDataInt
                      (x0_ae1SX
                       `cast` (Foreign.Ptr.N:IntPtr[0] :: (IntPtr :: *) ~R# (Int :: *))))
                   (GHC.Types.[] @ u_ae4C1)}]
Data.Data.$fDataIntPtr_$cgmapQ
  = \ (@ u_ae4C1)
      (ds_de7AE :: forall d. Data d => d -> u_ae4C1)
      (x0_ae1SX :: IntPtr) ->
      GHC.Types.:
        @ u_ae4C1
        (ds_de7AE
           @ Int
           Data.Data.$fDataInt
           (x0_ae1SX
            `cast` (Foreign.Ptr.N:IntPtr[0] :: (IntPtr :: *) ~R# (Int :: *))))
        (GHC.Types.[] @ u_ae4C1)

-- RHS size: {terms: 11, types: 16, coercions: 1, joins: 0/0}
Data.Data.$fDataIntPtr_$cgmapQl
  :: forall r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> IntPtr -> r
[GblId,
 Arity=4,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_ae4Bt)
                 (@ r'_ae4Bu)
                 (ds_de7Ay [Occ=Once!] :: r_ae4Bt -> r'_ae4Bu -> r_ae4Bt)
                 (ds1_de7Az [Occ=Once] :: r_ae4Bt)
                 (ds2_de7AA [Occ=Once!] :: forall d. Data d => d -> r'_ae4Bu)
                 (eta_XG9 [Occ=Once] :: IntPtr) ->
                 ds_de7Ay
                   ds1_de7Az
                   (ds2_de7AA
                      @ Int
                      Data.Data.$fDataInt
                      (eta_XG9
                       `cast` (Foreign.Ptr.N:IntPtr[0]
                               :: (IntPtr :: *) ~R# (Int :: *))))}]
Data.Data.$fDataIntPtr_$cgmapQl
  = \ (@ r_ae4Bt)
      (@ r'_ae4Bu)
      (ds_de7Ay :: r_ae4Bt -> r'_ae4Bu -> r_ae4Bt)
      (ds1_de7Az :: r_ae4Bt)
      (ds2_de7AA :: forall d. Data d => d -> r'_ae4Bu)
      (eta_XG9 :: IntPtr) ->
      ds_de7Ay
        ds1_de7Az
        (ds2_de7AA
           @ Int
           Data.Data.$fDataInt
           (eta_XG9
            `cast` (Foreign.Ptr.N:IntPtr[0] :: (IntPtr :: *) ~R# (Int :: *))))

-- RHS size: {terms: 5, types: 8, coercions: 1, joins: 0/0}
Data.Data.$fDataIntPtr3
  :: (forall b. Data b => b -> b) -> IntPtr -> Int
[GblId,
 Arity=2,
 Str=<C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (ds_de7Ax [Occ=Once!] :: forall b. Data b => b -> b)
                 (x0_Xe2Zr [Occ=Once] :: IntPtr) ->
                 ds_de7Ax
                   @ Int
                   Data.Data.$fDataInt
                   (x0_Xe2Zr
                    `cast` (Foreign.Ptr.N:IntPtr[0] :: (IntPtr :: *) ~R# (Int :: *)))}]
Data.Data.$fDataIntPtr3
  = \ (ds_de7Ax :: forall b. Data b => b -> b)
      (x0_Xe2Zr :: IntPtr) ->
      ds_de7Ax
        @ Int
        Data.Data.$fDataInt
        (x0_Xe2Zr
         `cast` (Foreign.Ptr.N:IntPtr[0] :: (IntPtr :: *) ~R# (Int :: *)))

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataIntPtr_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c IntPtr)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae4AV :: * -> * -> *))
                 (@ (c_ae4AW :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae4AW IntPtr)}]
Data.Data.$fDataIntPtr_$cdataCast2
  = \ (@ (t_ae4AV :: * -> * -> *))
      (@ (c_ae4AW :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae4AW IntPtr)

-- RHS size: {terms: 65, types: 93, coercions: 3, joins: 0/3}
Data.Data.$fDataIntPtr_$cgmapMo
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> IntPtr -> m IntPtr
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 60 0] 590 0}]
Data.Data.$fDataIntPtr_$cgmapMo
  = \ (@ (m_ae4CZ :: * -> *))
      ($dMonadPlus_ae4D1 :: MonadPlus m_ae4CZ)
      (ds_de7AJ :: forall d. Data d => d -> m_ae4CZ d)
      (eta_XGb :: IntPtr) ->
      let {
        lvl270_se9Ke :: m_ae4CZ IntPtr
        [LclId]
        lvl270_se9Ke = mzero @ m_ae4CZ $dMonadPlus_ae4D1 @ IntPtr } in
      let {
        $dMonad_se9rL [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae4CZ
        [LclId]
        $dMonad_se9rL
          = GHC.Base.$p2MonadPlus @ m_ae4CZ $dMonadPlus_ae4D1 } in
      >>=
        @ m_ae4CZ
        $dMonad_se9rL
        @ (IntPtr, Bool)
        @ IntPtr
        (let {
           lvl271_se9Kd :: m_ae4CZ Int
           [LclId]
           lvl271_se9Kd
             = ds_de7AJ
                 @ Int
                 Data.Data.$fDataInt
                 (eta_XGb
                  `cast` (Foreign.Ptr.N:IntPtr[0]
                          :: (IntPtr :: *) ~R# (Int :: *))) } in
         >>=
           @ m_ae4CZ
           $dMonad_se9rL
           @ (Int -> IntPtr, Bool)
           @ (IntPtr, Bool)
           (return
              @ m_ae4CZ
              $dMonad_se9rL
              @ (Int -> IntPtr, Bool)
              Data.Data.$fDataIntPtr1)
           (\ (ds1_de7pD :: (Int -> IntPtr, Bool)) ->
              case ds1_de7pD of { (h_ae1TP, b_ae1TQ) ->
              case b_ae1TQ of {
                False ->
                  mplus
                    @ m_ae4CZ
                    $dMonadPlus_ae4D1
                    @ (IntPtr, Bool)
                    (>>=
                       @ m_ae4CZ
                       $dMonad_se9rL
                       @ Int
                       @ (IntPtr, Bool)
                       lvl271_se9Kd
                       (\ (y'_ae1TR :: Int) ->
                          return
                            @ m_ae4CZ
                            $dMonad_se9rL
                            @ (IntPtr, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_ae4CZ
                       $dMonad_se9rL
                       @ (IntPtr, Bool)
                       (h_ae1TP
                          (eta_XGb
                           `cast` (Foreign.Ptr.N:IntPtr[0] :: (IntPtr :: *) ~R# (Int :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_ae4CZ
                    $dMonad_se9rL
                    @ (IntPtr, Bool)
                    (h_ae1TP
                       (eta_XGb
                        `cast` (Foreign.Ptr.N:IntPtr[0] :: (IntPtr :: *) ~R# (Int :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds1_de7pa :: (IntPtr, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9Ke;
             True -> return @ m_ae4CZ $dMonad_se9rL @ IntPtr x'_ae1TS
           }
           })

-- RHS size: {terms: 16, types: 1, coercions: 16, joins: 0/0}
Data.Data.$fDataIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Data IntPtr
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: IntPtr
                        Data.Data.$fDataIntPtr8
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <IntPtr>_N
                                :: (Data.Typeable.Internal.TypeRep IntPtr :: *)
                                   ~R# (Typeable IntPtr :: Constraint))
                        Data.Data.$fDataIntPtr_$cgfoldl
                        Data.Data.$fDataIntPtr_$cgunfold
                        Data.Data.$fDataIntPtr_$ctoConstr
                        Data.Data.$fDataIntPtr_$cdataTypeOf
                        Data.Data.$fDataIntPtr_$cdataCast1
                        Data.Data.$fDataIntPtr_$cdataCast2
                        Data.Data.$fDataIntPtr3
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <IntPtr>_R
                                ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                :: ((forall b. Data b => b -> b) -> IntPtr -> Int :: *)
                                   ~R# ((forall b. Data b => b -> b) -> IntPtr -> IntPtr :: *))
                        Data.Data.$fDataIntPtr_$cgmapQl
                        Data.Data.$fDataIntPtr_$cgmapQr
                        Data.Data.$fDataIntPtr_$cgmapQ
                        Data.Data.$fDataIntPtr_$cgmapQi
                        Data.Data.$fDataIntPtr_$cgmapM
                        Data.Data.$fDataIntPtr_$cgmapMp
                        Data.Data.$fDataIntPtr_$cgmapMo]
Data.Data.$fDataIntPtr
  = Data.Data.C:Data
      @ IntPtr
      (Data.Data.$fDataIntPtr8
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <IntPtr>_N
               :: (Data.Typeable.Internal.TypeRep IntPtr :: *)
                  ~R# (Typeable IntPtr :: Constraint)))
      Data.Data.$fDataIntPtr_$cgfoldl
      Data.Data.$fDataIntPtr_$cgunfold
      Data.Data.$fDataIntPtr_$ctoConstr
      Data.Data.$fDataIntPtr_$cdataTypeOf
      Data.Data.$fDataIntPtr_$cdataCast1
      Data.Data.$fDataIntPtr_$cdataCast2
      (Data.Data.$fDataIntPtr3
       `cast` (<forall b. Data b => b -> b>_R
               ->_R <IntPtr>_R
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: ((forall b. Data b => b -> b) -> IntPtr -> Int :: *)
                  ~R# ((forall b. Data b => b -> b) -> IntPtr -> IntPtr :: *)))
      Data.Data.$fDataIntPtr_$cgmapQl
      Data.Data.$fDataIntPtr_$cgmapQr
      Data.Data.$fDataIntPtr_$cgmapQ
      Data.Data.$fDataIntPtr_$cgmapQi
      Data.Data.$fDataIntPtr_$cgmapM
      Data.Data.$fDataIntPtr_$cgmapMp
      Data.Data.$fDataIntPtr_$cgmapMo

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataWordPtr7 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fDataWordPtr7 = "WordPtr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataWordPtr6 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataWordPtr6 = unpackCString# Data.Data.$fDataWordPtr7

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go19_rejQr :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go19_rejQr
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fDataWordPtr6 of {
                False -> go19_rejQr ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cWordPtr1_rejQs :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cWordPtr1_rejQs = Data.Data.AlgConstr $cWordPtr2_rejQt

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataWordPtr5 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataWordPtr5
  = GHC.Types.: @ Constr Data.Data.$cWordPtr (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataWordPtr4 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataWordPtr4
  = Data.Data.AlgRep Data.Data.$fDataWordPtr5

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tWordPtr :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$tWordPtr
  = Data.Data.DataType
      Data.Data.$fDataWordPtr6 Data.Data.$fDataWordPtr4

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cWordPtr [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cWordPtr
  = Data.Data.Constr
      $cWordPtr1_rejQs
      Data.Data.$fDataWordPtr6
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tWordPtr

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cWordPtr2_rejQt :: ConIndex
[GblId]
$cWordPtr2_rejQt
  = go19_rejQr Data.Data.$fDataWordPtr5 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataWordPtr_$cdataTypeOf :: WordPtr -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Data.$tWordPtr}]
Data.Data.$fDataWordPtr_$cdataTypeOf
  = \ _ [Occ=Dead] -> Data.Data.$tWordPtr

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataWordPtr_$ctoConstr :: WordPtr -> Constr
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Data.$cWordPtr}]
Data.Data.$fDataWordPtr_$ctoConstr
  = \ _ [Occ=Dead] -> Data.Data.$cWordPtr

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataWordPtr_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c WordPtr)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae4xr :: * -> *))
                 (@ (c_ae4xs :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae4xs WordPtr)}]
Data.Data.$fDataWordPtr_$cdataCast1
  = \ (@ (t_ae4xr :: * -> *))
      (@ (c_ae4xs :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae4xs WordPtr)

-- RHS size: {terms: 3, types: 3, coercions: 4, joins: 0/0}
Data.Data.$fDataWordPtr1 :: (Word -> WordPtr, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataWordPtr1
  = (Data.Data.$fDataWordPtr2
     `cast` (<Word>_R ->_R Sym (Foreign.Ptr.N:WordPtr[0])
             :: (Word -> Word :: *) ~R# (Word -> WordPtr :: *)),
     GHC.Types.False)

-- RHS size: {terms: 55, types: 86, coercions: 2, joins: 0/3}
Data.Data.$fDataWordPtr_$cgmapMp
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> WordPtr -> m WordPtr
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 60 0] 510 0}]
Data.Data.$fDataWordPtr_$cgmapMp
  = \ (@ (m_ae4zy :: * -> *))
      ($dMonadPlus_ae4zA :: MonadPlus m_ae4zy)
      (ds_de7Ao :: forall d. Data d => d -> m_ae4zy d)
      (eta_XGl :: WordPtr) ->
      let {
        lvl270_se9Ko :: m_ae4zy WordPtr
        [LclId]
        lvl270_se9Ko = mzero @ m_ae4zy $dMonadPlus_ae4zA @ WordPtr } in
      let {
        $dMonad_se9rJ [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae4zy
        [LclId]
        $dMonad_se9rJ
          = GHC.Base.$p2MonadPlus @ m_ae4zy $dMonadPlus_ae4zA } in
      >>=
        @ m_ae4zy
        $dMonad_se9rJ
        @ (WordPtr, Bool)
        @ WordPtr
        (let {
           lvl271_se9Kn :: m_ae4zy Word
           [LclId]
           lvl271_se9Kn
             = ds_de7Ao
                 @ Word
                 Data.Data.$fDataWord
                 (eta_XGl
                  `cast` (Foreign.Ptr.N:WordPtr[0]
                          :: (WordPtr :: *) ~R# (Word :: *))) } in
         >>=
           @ m_ae4zy
           $dMonad_se9rJ
           @ (Word -> WordPtr, Bool)
           @ (WordPtr, Bool)
           (return
              @ m_ae4zy
              $dMonad_se9rJ
              @ (Word -> WordPtr, Bool)
              Data.Data.$fDataWordPtr1)
           (\ (ds1_de7oD :: (Word -> WordPtr, Bool)) ->
              case ds1_de7oD of { (h_ae1TA, b_ae1TB) ->
              mplus
                @ m_ae4zy
                $dMonadPlus_ae4zA
                @ (WordPtr, Bool)
                (>>=
                   @ m_ae4zy
                   $dMonad_se9rJ
                   @ Word
                   @ (WordPtr, Bool)
                   lvl271_se9Kn
                   (\ (y'_ae1TC :: Word) ->
                      return
                        @ m_ae4zy
                        $dMonad_se9rJ
                        @ (WordPtr, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_ae4zy
                   $dMonad_se9rJ
                   @ (WordPtr, Bool)
                   (h_ae1TA
                      (eta_XGl
                       `cast` (Foreign.Ptr.N:WordPtr[0]
                               :: (WordPtr :: *) ~R# (Word :: *))),
                    b_ae1TB))
              }))
        (\ (ds1_de7oa :: (WordPtr, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9Ko;
             True -> return @ m_ae4zy $dMonad_se9rJ @ WordPtr x'_ae1TD
           }
           })

-- RHS size: {terms: 22, types: 32, coercions: 5, joins: 0/1}
Data.Data.$fDataWordPtr_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> WordPtr -> m WordPtr
[GblId,
 Arity=3,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [120 60 0] 220 0}]
Data.Data.$fDataWordPtr_$cgmapM
  = \ (@ (m_ae4zi :: * -> *))
      ($dMonad_ae4zk :: Monad m_ae4zi)
      (ds_de7An :: forall d. Data d => d -> m_ae4zi d)
      (eta_XGm :: WordPtr) ->
      let {
        lvl270_se9Kq :: m_ae4zi Word
        [LclId]
        lvl270_se9Kq
          = ds_de7An
              @ Word
              Data.Data.$fDataWord
              (eta_XGm
               `cast` (Foreign.Ptr.N:WordPtr[0]
                       :: (WordPtr :: *) ~R# (Word :: *))) } in
      >>=
        @ m_ae4zi
        $dMonad_ae4zk
        @ (Word -> WordPtr)
        @ WordPtr
        (return
           @ m_ae4zi
           $dMonad_ae4zk
           @ (Word -> WordPtr)
           (Data.Data.$fDataWordPtr2
            `cast` (<Word>_R ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                    :: (Word -> Word :: *) ~R# (Word -> WordPtr :: *))))
        (\ (c'_ae1To :: Word -> WordPtr) ->
           >>=
             @ m_ae4zi
             $dMonad_ae4zk
             @ Word
             @ WordPtr
             lvl270_se9Kq
             (\ (x'_ae1Tp :: Word) ->
                return @ m_ae4zi $dMonad_ae4zk @ WordPtr (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 15, types: 15, coercions: 1, joins: 0/0}
Data.Data.$fDataWordPtr_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> WordPtr -> u
[GblId,
 Arity=3,
 Str=<S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae4z4)
                 (ds_de7Al [Occ=Once!] :: Int)
                 (ds1_de7Am [Occ=Once!] :: forall d. Data d => d -> u_ae4z4)
                 (x_ae1T7 [Occ=Once] :: WordPtr) ->
                 case ds_de7Al of { I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_ae4z4;
                   0# ->
                     ds1_de7Am
                       @ Word
                       Data.Data.$fDataWord
                       (x_ae1T7
                        `cast` (Foreign.Ptr.N:WordPtr[0]
                                :: (WordPtr :: *) ~R# (Word :: *)))
                 }
                 }}]
Data.Data.$fDataWordPtr_$cgmapQi
  = \ (@ u_ae4z4)
      (ds_de7Al :: Int)
      (ds1_de7Am :: forall d. Data d => d -> u_ae4z4)
      (x_ae1T7 :: WordPtr) ->
      case ds_de7Al of { I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_ae4z4;
        0# ->
          ds1_de7Am
            @ Word
            Data.Data.$fDataWord
            (x_ae1T7
             `cast` (Foreign.Ptr.N:WordPtr[0]
                     :: (WordPtr :: *) ~R# (Word :: *)))
      }
      }

-- RHS size: {terms: 11, types: 16, coercions: 1, joins: 0/0}
Data.Data.$fDataWordPtr_$cgmapQr
  :: forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> WordPtr -> r
[GblId,
 Arity=4,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_ae4yz)
                 (@ r'_ae4yA)
                 (ds_de7Ah [Occ=Once!] :: r'_ae4yA -> r_ae4yz -> r_ae4yz)
                 (ds1_de7Ai [Occ=Once] :: r_ae4yz)
                 (ds2_de7Aj [Occ=Once!] :: forall d. Data d => d -> r'_ae4yA)
                 (x0_ae1SX [Occ=Once] :: WordPtr) ->
                 ds_de7Ah
                   (ds2_de7Aj
                      @ Word
                      Data.Data.$fDataWord
                      (x0_ae1SX
                       `cast` (Foreign.Ptr.N:WordPtr[0]
                               :: (WordPtr :: *) ~R# (Word :: *))))
                   ds1_de7Ai}]
Data.Data.$fDataWordPtr_$cgmapQr
  = \ (@ r_ae4yz)
      (@ r'_ae4yA)
      (ds_de7Ah :: r'_ae4yA -> r_ae4yz -> r_ae4yz)
      (ds1_de7Ai :: r_ae4yz)
      (ds2_de7Aj :: forall d. Data d => d -> r'_ae4yA)
      (x0_ae1SX :: WordPtr) ->
      ds_de7Ah
        (ds2_de7Aj
           @ Word
           Data.Data.$fDataWord
           (x0_ae1SX
            `cast` (Foreign.Ptr.N:WordPtr[0]
                    :: (WordPtr :: *) ~R# (Word :: *))))
        ds1_de7Ai

-- RHS size: {terms: 8, types: 12, coercions: 1, joins: 0/0}
Data.Data.$fDataWordPtr_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> WordPtr -> [u]
[GblId,
 Arity=2,
 Str=<L,1*C1(C1(U))><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae4yQ)
                 (ds_de7Ak [Occ=Once!] :: forall d. Data d => d -> u_ae4yQ)
                 (x0_ae1SX [Occ=Once] :: WordPtr) ->
                 GHC.Types.:
                   @ u_ae4yQ
                   (ds_de7Ak
                      @ Word
                      Data.Data.$fDataWord
                      (x0_ae1SX
                       `cast` (Foreign.Ptr.N:WordPtr[0]
                               :: (WordPtr :: *) ~R# (Word :: *))))
                   (GHC.Types.[] @ u_ae4yQ)}]
Data.Data.$fDataWordPtr_$cgmapQ
  = \ (@ u_ae4yQ)
      (ds_de7Ak :: forall d. Data d => d -> u_ae4yQ)
      (x0_ae1SX :: WordPtr) ->
      GHC.Types.:
        @ u_ae4yQ
        (ds_de7Ak
           @ Word
           Data.Data.$fDataWord
           (x0_ae1SX
            `cast` (Foreign.Ptr.N:WordPtr[0]
                    :: (WordPtr :: *) ~R# (Word :: *))))
        (GHC.Types.[] @ u_ae4yQ)

-- RHS size: {terms: 11, types: 16, coercions: 1, joins: 0/0}
Data.Data.$fDataWordPtr_$cgmapQl
  :: forall r r'.
     (r -> r' -> r)
     -> r -> (forall d. Data d => d -> r') -> WordPtr -> r
[GblId,
 Arity=4,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_ae4yi)
                 (@ r'_ae4yj)
                 (ds_de7Ae [Occ=Once!] :: r_ae4yi -> r'_ae4yj -> r_ae4yi)
                 (ds1_de7Af [Occ=Once] :: r_ae4yi)
                 (ds2_de7Ag [Occ=Once!] :: forall d. Data d => d -> r'_ae4yj)
                 (eta_XGs [Occ=Once] :: WordPtr) ->
                 ds_de7Ae
                   ds1_de7Af
                   (ds2_de7Ag
                      @ Word
                      Data.Data.$fDataWord
                      (eta_XGs
                       `cast` (Foreign.Ptr.N:WordPtr[0]
                               :: (WordPtr :: *) ~R# (Word :: *))))}]
Data.Data.$fDataWordPtr_$cgmapQl
  = \ (@ r_ae4yi)
      (@ r'_ae4yj)
      (ds_de7Ae :: r_ae4yi -> r'_ae4yj -> r_ae4yi)
      (ds1_de7Af :: r_ae4yi)
      (ds2_de7Ag :: forall d. Data d => d -> r'_ae4yj)
      (eta_XGs :: WordPtr) ->
      ds_de7Ae
        ds1_de7Af
        (ds2_de7Ag
           @ Word
           Data.Data.$fDataWord
           (eta_XGs
            `cast` (Foreign.Ptr.N:WordPtr[0]
                    :: (WordPtr :: *) ~R# (Word :: *))))

-- RHS size: {terms: 5, types: 8, coercions: 1, joins: 0/0}
Data.Data.$fDataWordPtr3
  :: (forall b. Data b => b -> b) -> WordPtr -> Word
[GblId,
 Arity=2,
 Str=<C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (ds_de7Ad [Occ=Once!] :: forall b. Data b => b -> b)
                 (x0_Xe2ZK [Occ=Once] :: WordPtr) ->
                 ds_de7Ad
                   @ Word
                   Data.Data.$fDataWord
                   (x0_Xe2ZK
                    `cast` (Foreign.Ptr.N:WordPtr[0]
                            :: (WordPtr :: *) ~R# (Word :: *)))}]
Data.Data.$fDataWordPtr3
  = \ (ds_de7Ad :: forall b. Data b => b -> b)
      (x0_Xe2ZK :: WordPtr) ->
      ds_de7Ad
        @ Word
        Data.Data.$fDataWord
        (x0_Xe2ZK
         `cast` (Foreign.Ptr.N:WordPtr[0]
                 :: (WordPtr :: *) ~R# (Word :: *)))

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataWordPtr_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c WordPtr)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae4xK :: * -> * -> *))
                 (@ (c_ae4xL :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae4xL WordPtr)}]
Data.Data.$fDataWordPtr_$cdataCast2
  = \ (@ (t_ae4xK :: * -> * -> *))
      (@ (c_ae4xL :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae4xL WordPtr)

-- RHS size: {terms: 65, types: 93, coercions: 3, joins: 0/3}
Data.Data.$fDataWordPtr_$cgmapMo
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> WordPtr -> m WordPtr
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 60 0] 590 0}]
Data.Data.$fDataWordPtr_$cgmapMo
  = \ (@ (m_ae4zO :: * -> *))
      ($dMonadPlus_ae4zQ :: MonadPlus m_ae4zO)
      (ds_de7Ap :: forall d. Data d => d -> m_ae4zO d)
      (eta_XGu :: WordPtr) ->
      let {
        lvl270_se9Kv :: m_ae4zO WordPtr
        [LclId]
        lvl270_se9Kv = mzero @ m_ae4zO $dMonadPlus_ae4zQ @ WordPtr } in
      let {
        $dMonad_se9rH [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae4zO
        [LclId]
        $dMonad_se9rH
          = GHC.Base.$p2MonadPlus @ m_ae4zO $dMonadPlus_ae4zQ } in
      >>=
        @ m_ae4zO
        $dMonad_se9rH
        @ (WordPtr, Bool)
        @ WordPtr
        (let {
           lvl271_se9Ku :: m_ae4zO Word
           [LclId]
           lvl271_se9Ku
             = ds_de7Ap
                 @ Word
                 Data.Data.$fDataWord
                 (eta_XGu
                  `cast` (Foreign.Ptr.N:WordPtr[0]
                          :: (WordPtr :: *) ~R# (Word :: *))) } in
         >>=
           @ m_ae4zO
           $dMonad_se9rH
           @ (Word -> WordPtr, Bool)
           @ (WordPtr, Bool)
           (return
              @ m_ae4zO
              $dMonad_se9rH
              @ (Word -> WordPtr, Bool)
              Data.Data.$fDataWordPtr1)
           (\ (ds1_de7pD :: (Word -> WordPtr, Bool)) ->
              case ds1_de7pD of { (h_ae1TP, b_ae1TQ) ->
              case b_ae1TQ of {
                False ->
                  mplus
                    @ m_ae4zO
                    $dMonadPlus_ae4zQ
                    @ (WordPtr, Bool)
                    (>>=
                       @ m_ae4zO
                       $dMonad_se9rH
                       @ Word
                       @ (WordPtr, Bool)
                       lvl271_se9Ku
                       (\ (y'_ae1TR :: Word) ->
                          return
                            @ m_ae4zO
                            $dMonad_se9rH
                            @ (WordPtr, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_ae4zO
                       $dMonad_se9rH
                       @ (WordPtr, Bool)
                       (h_ae1TP
                          (eta_XGu
                           `cast` (Foreign.Ptr.N:WordPtr[0]
                                   :: (WordPtr :: *) ~R# (Word :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_ae4zO
                    $dMonad_se9rH
                    @ (WordPtr, Bool)
                    (h_ae1TP
                       (eta_XGu
                        `cast` (Foreign.Ptr.N:WordPtr[0]
                                :: (WordPtr :: *) ~R# (Word :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds1_de7pa :: (WordPtr, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9Kv;
             True -> return @ m_ae4zO $dMonad_se9rH @ WordPtr x'_ae1TS
           }
           })

-- RHS size: {terms: 16, types: 1, coercions: 16, joins: 0/0}
Data.Data.$fDataWordPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Data WordPtr
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: WordPtr
                        Data.Data.$fDataWordPtr8
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <WordPtr>_N
                                :: (Data.Typeable.Internal.TypeRep WordPtr :: *)
                                   ~R# (Typeable WordPtr :: Constraint))
                        Data.Data.$fDataWordPtr_$cgfoldl
                        Data.Data.$fDataWordPtr_$cgunfold
                        Data.Data.$fDataWordPtr_$ctoConstr
                        Data.Data.$fDataWordPtr_$cdataTypeOf
                        Data.Data.$fDataWordPtr_$cdataCast1
                        Data.Data.$fDataWordPtr_$cdataCast2
                        Data.Data.$fDataWordPtr3
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <WordPtr>_R
                                ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                :: ((forall b. Data b => b -> b) -> WordPtr -> Word :: *)
                                   ~R# ((forall b. Data b => b -> b) -> WordPtr -> WordPtr :: *))
                        Data.Data.$fDataWordPtr_$cgmapQl
                        Data.Data.$fDataWordPtr_$cgmapQr
                        Data.Data.$fDataWordPtr_$cgmapQ
                        Data.Data.$fDataWordPtr_$cgmapQi
                        Data.Data.$fDataWordPtr_$cgmapM
                        Data.Data.$fDataWordPtr_$cgmapMp
                        Data.Data.$fDataWordPtr_$cgmapMo]
Data.Data.$fDataWordPtr
  = Data.Data.C:Data
      @ WordPtr
      (Data.Data.$fDataWordPtr8
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <WordPtr>_N
               :: (Data.Typeable.Internal.TypeRep WordPtr :: *)
                  ~R# (Typeable WordPtr :: Constraint)))
      Data.Data.$fDataWordPtr_$cgfoldl
      Data.Data.$fDataWordPtr_$cgunfold
      Data.Data.$fDataWordPtr_$ctoConstr
      Data.Data.$fDataWordPtr_$cdataTypeOf
      Data.Data.$fDataWordPtr_$cdataCast1
      Data.Data.$fDataWordPtr_$cdataCast2
      (Data.Data.$fDataWordPtr3
       `cast` (<forall b. Data b => b -> b>_R
               ->_R <WordPtr>_R
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: ((forall b. Data b => b -> b) -> WordPtr -> Word :: *)
                  ~R# ((forall b. Data b => b -> b) -> WordPtr -> WordPtr :: *)))
      Data.Data.$fDataWordPtr_$cgmapQl
      Data.Data.$fDataWordPtr_$cgmapQr
      Data.Data.$fDataWordPtr_$cgmapQ
      Data.Data.$fDataWordPtr_$cgmapQi
      Data.Data.$fDataWordPtr_$cgmapM
      Data.Data.$fDataWordPtr_$cgmapMp
      Data.Data.$fDataWordPtr_$cgmapMo

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataProxy5 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fDataProxy5 = "Proxy"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataProxy4 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataProxy4 = unpackCString# Data.Data.$fDataProxy5

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go20_rejQu :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go20_rejQu
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fDataProxy4 of {
                False -> go20_rejQu ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cProxy1_rejQv :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cProxy1_rejQv = Data.Data.AlgConstr $cProxy2_rejQw

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataProxy3 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataProxy3
  = GHC.Types.: @ Constr Data.Data.$cProxy (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataProxy2 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataProxy2 = Data.Data.AlgRep Data.Data.$fDataProxy3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tProxy :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$tProxy
  = Data.Data.DataType Data.Data.$fDataProxy4 Data.Data.$fDataProxy2

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cProxy [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cProxy
  = Data.Data.Constr
      $cProxy1_rejQv
      Data.Data.$fDataProxy4
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tProxy

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cProxy2_rejQw :: ConIndex
[GblId]
$cProxy2_rejQw
  = go20_rejQu Data.Data.$fDataProxy3 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
Data.Data.$fDataProxy1 :: forall t. (Proxy t, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataProxy1
  = \ (@ t_Xe581) ->
      (Data.Proxy.Proxy @ * @ t_Xe581, GHC.Types.False)

-- RHS size: {terms: 30, types: 71, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp27 [InlPrag=NOUSERINLINE[0]]
  :: forall t (m :: * -> *). MonadPlus m => Proxy t -> m (Proxy t)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*H>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 20] 210 0}]
Data.Data.$w$cgmapMp27
  = \ (@ t_segoM)
      (@ (m_segoO :: * -> *))
      (w_segoP :: MonadPlus m_segoO)
      (w1_segoR :: Proxy t_segoM) ->
      let {
        lvl270_se9KD :: m_segoO (Proxy t_segoM)
        [LclId]
        lvl270_se9KD = mzero @ m_segoO w_segoP @ (Proxy t_segoM) } in
      let {
        $dMonad_se9rF [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_segoO
        [LclId]
        $dMonad_se9rF = GHC.Base.$p2MonadPlus @ m_segoO w_segoP } in
      >>=
        @ m_segoO
        $dMonad_se9rF
        @ (Proxy t_segoM, Bool)
        @ (Proxy t_segoM)
        (case w1_segoR of { Proxy ->
         return
           @ m_segoO
           $dMonad_se9rF
           @ (Proxy t_segoM, Bool)
           (Data.Data.$fDataProxy1 @ t_segoM)
         })
        (\ (ds_de7oa :: (Proxy t_segoM, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9KD;
             True -> return @ m_segoO $dMonad_se9rF @ (Proxy t_segoM) x'_ae1TD
           }
           })

-- RHS size: {terms: 9, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataProxy_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall t.
     Data t =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Proxy t -> m (Proxy t)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ t_segoM)
                 _ [Occ=Dead]
                 (@ (m_segoO :: * -> *))
                 (w1_segoP [Occ=Once] :: MonadPlus m_segoO)
                 _ [Occ=Dead]
                 (w3_segoR [Occ=Once] :: Proxy t_segoM) ->
                 Data.Data.$w$cgmapMp27 @ t_segoM @ m_segoO w1_segoP w3_segoR}]
Data.Data.$fDataProxy_$cgmapMp
  = \ (@ t_segoM)
      _ [Occ=Dead]
      (@ (m_segoO :: * -> *))
      (w1_segoP :: MonadPlus m_segoO)
      _ [Occ=Dead]
      (w3_segoR :: Proxy t_segoM) ->
      Data.Data.$w$cgmapMp27 @ t_segoM @ m_segoO w1_segoP w3_segoR

-- RHS size: {terms: 30, types: 71, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo26 [InlPrag=NOUSERINLINE[0]]
  :: forall t (m :: * -> *). MonadPlus m => Proxy t -> m (Proxy t)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*H>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 20] 210 0}]
Data.Data.$w$cgmapMo26
  = \ (@ t_segoT)
      (@ (m_segoV :: * -> *))
      (w_segoW :: MonadPlus m_segoV)
      (w1_segoY :: Proxy t_segoT) ->
      let {
        lvl270_se9KH :: m_segoV (Proxy t_segoT)
        [LclId]
        lvl270_se9KH = mzero @ m_segoV w_segoW @ (Proxy t_segoT) } in
      let {
        $dMonad_se9rD [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_segoV
        [LclId]
        $dMonad_se9rD = GHC.Base.$p2MonadPlus @ m_segoV w_segoW } in
      >>=
        @ m_segoV
        $dMonad_se9rD
        @ (Proxy t_segoT, Bool)
        @ (Proxy t_segoT)
        (case w1_segoY of { Proxy ->
         return
           @ m_segoV
           $dMonad_se9rD
           @ (Proxy t_segoT, Bool)
           (Data.Data.$fDataProxy1 @ t_segoT)
         })
        (\ (ds_de7pa :: (Proxy t_segoT, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9KH;
             True -> return @ m_segoV $dMonad_se9rD @ (Proxy t_segoT) x'_ae1TS
           }
           })

-- RHS size: {terms: 9, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataProxy_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall t.
     Data t =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Proxy t -> m (Proxy t)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ t_segoT)
                 _ [Occ=Dead]
                 (@ (m_segoV :: * -> *))
                 (w1_segoW [Occ=Once] :: MonadPlus m_segoV)
                 _ [Occ=Dead]
                 (w3_segoY [Occ=Once] :: Proxy t_segoT) ->
                 Data.Data.$w$cgmapMo26 @ t_segoT @ m_segoV w1_segoW w3_segoY}]
Data.Data.$fDataProxy_$cgmapMo
  = \ (@ t_segoT)
      _ [Occ=Dead]
      (@ (m_segoV :: * -> *))
      (w1_segoW :: MonadPlus m_segoV)
      _ [Occ=Dead]
      (w3_segoY :: Proxy t_segoT) ->
      Data.Data.$w$cgmapMo26 @ t_segoT @ m_segoV w1_segoW w3_segoY

-- RHS size: {terms: 10, types: 38, coercions: 0, joins: 0/0}
lvl130_rejQx
  :: forall t (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Proxy t -> c (Proxy t)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*H>,
 Unf=OtherCon []]
lvl130_rejQx
  = \ (@ t_Xe57S)
      (@ (c_ae4tS :: * -> *))
      _ [Occ=Dead]
      (z_ae2pe :: forall g. g -> c_ae4tS g)
      (ds_de7zN :: Proxy t_Xe57S) ->
      case ds_de7zN of { Proxy ->
      z_ae2pe @ (Proxy t_Xe57S) (Data.Proxy.Proxy @ * @ t_Xe57S)
      }

-- RHS size: {terms: 7, types: 30, coercions: 0, joins: 0/0}
lvl131_rejQy
  :: forall t (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c (Proxy t)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,A>,
 Unf=OtherCon []]
lvl131_rejQy
  = \ (@ t_Xe57S)
      (@ (c_ae4u0 :: * -> *))
      _ [Occ=Dead]
      (z_ae2pg :: forall r. r -> c_ae4u0 r)
      _ [Occ=Dead] ->
      z_ae2pg @ (Proxy t_Xe57S) (Data.Proxy.Proxy @ * @ t_Xe57S)

-- RHS size: {terms: 6, types: 10, coercions: 0, joins: 0/0}
lvl132_rejQz :: forall t. Proxy t -> Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []]
lvl132_rejQz
  = \ (@ t_Xe57S) (ds_de7zP :: Proxy t_Xe57S) ->
      case ds_de7zP of { Proxy -> Data.Data.$cProxy }

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
lvl133_rejQA :: forall t. Proxy t -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl133_rejQA = \ (@ t_Xe57S) _ [Occ=Dead] -> Data.Data.$tProxy

-- RHS size: {terms: 6, types: 28, coercions: 0, joins: 0/0}
lvl134_rejQB
  :: forall t1 (t2 :: * -> *) (c :: * -> *).
     Typeable t2 =>
     (forall d. Data d => c (t2 d)) -> Maybe (c (Proxy t1))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl134_rejQB
  = \ (@ t_Xe57S)
      (@ (t1_ae4ug :: * -> *))
      (@ (c_ae4uh :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae4uh (Proxy t_Xe57S))

-- RHS size: {terms: 6, types: 37, coercions: 0, joins: 0/0}
lvl135_rejQC
  :: forall t1 (t2 :: * -> * -> *) (c :: * -> *).
     Typeable t2 =>
     (forall d e. (Data d, Data e) => c (t2 d e))
     -> Maybe (c (Proxy t1))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl135_rejQC
  = \ (@ t_Xe57S)
      (@ (t1_ae4uz :: * -> * -> *))
      (@ (c_ae4uA :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae4uA (Proxy t_Xe57S))

-- RHS size: {terms: 4, types: 12, coercions: 0, joins: 0/0}
lvl136_rejQD
  :: forall t. (forall b. Data b => b -> b) -> Proxy t -> Proxy t
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U()>m,
 Unf=OtherCon []]
lvl136_rejQD
  = \ (@ t_Xe57S) _ [Occ=Dead] (x0_Xe30c :: Proxy t_Xe57S) ->
      x0_Xe30c

-- RHS size: {terms: 11, types: 24, coercions: 9, joins: 0/0}
lvl137_rejQE
  :: forall t r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data d => d -> r')
     -> Proxy t
     -> Const r (Proxy t)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*H>,
 Unf=OtherCon []]
lvl137_rejQE
  = \ (@ t_Xe57S)
      (@ r_Xe5bZ)
      (@ r'_Xe5c1)
      _ [Occ=Dead]
      (ds1_Xe8gQ :: r_Xe5bZ)
      _ [Occ=Dead]
      (eta_X1nI :: Proxy t_Xe57S) ->
      case eta_X1nI of { Proxy ->
      ds1_Xe8gQ
      `cast` (Sym (Data.Functor.Const.N:Const[0]
                       <*>_N <r_Xe5bZ>_R <Proxy t_Xe57S>_P)
              :: (r_Xe5bZ :: *) ~R# (Const r_Xe5bZ (Proxy t_Xe57S) :: *))
      }

-- RHS size: {terms: 11, types: 24, coercions: 0, joins: 0/0}
lvl138_rejQF
  :: forall t r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> Proxy t -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*H>,
 Unf=OtherCon []]
lvl138_rejQF
  = \ (@ t_Xe57S)
      (@ r_ae4vo)
      (@ r'_ae4vp)
      _ [Occ=Dead]
      (ds1_de7zY :: r_ae4vo)
      _ [Occ=Dead]
      (x0_ae1SX :: Proxy t_Xe57S) ->
      case x0_ae1SX of { Proxy -> ds1_de7zY }

-- RHS size: {terms: 8, types: 19, coercions: 0, joins: 0/0}
lvl139_rejQG
  :: forall t u. (forall d. Data d => d -> u) -> Proxy t -> [u]
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><S,1*H>, Unf=OtherCon []]
lvl139_rejQG
  = \ (@ t_Xe57S)
      (@ u_ae4vF)
      _ [Occ=Dead]
      (x0_ae1SX :: Proxy t_Xe57S) ->
      case x0_ae1SX of { Proxy -> GHC.Types.[] @ u_ae4vF }

-- RHS size: {terms: 11, types: 31, coercions: 0, joins: 0/0}
lvl140_rejQH
  :: forall t (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Proxy t -> m (Proxy t)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><L,A><S,1*H>,
 Unf=OtherCon []]
lvl140_rejQH
  = \ (@ t_Xe57S)
      (@ (m_ae4w7 :: * -> *))
      ($dMonad_ae4w9 :: Monad m_ae4w7)
      _ [Occ=Dead]
      (eta_XGF :: Proxy t_Xe57S) ->
      case eta_XGF of { Proxy ->
      return
        @ m_ae4w7
        $dMonad_ae4w9
        @ (Proxy t_Xe57S)
        (Data.Proxy.Proxy @ * @ t_Xe57S)
      }

-- RHS size: {terms: 9, types: 20, coercions: 0, joins: 0/0}
lvl141_rejQI
  :: forall t u. Int -> (forall d. Data d => d -> u) -> Proxy t -> u
[GblId, Arity=3, Str=<B,A><B,A><B,1*H>x, Unf=OtherCon []]
lvl141_rejQI
  = \ (@ t_Xe57S)
      (@ u_ae4vT)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (x_ae1T7 :: Proxy t_Xe57S) ->
      case x_ae1T7 of { Proxy -> Data.Maybe.fromJust1 @ u_ae4vT }

-- RHS size: {terms: 8, types: 21, coercions: 0, joins: 0/0}
lvl142_rejQJ
  :: forall t (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Proxy t -> m (Proxy t)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*H>,
 Unf=OtherCon []]
lvl142_rejQJ
  = \ (@ t_Xe57S)
      (@ (m_segoO :: * -> *))
      (w_segoP :: MonadPlus m_segoO)
      _ [Occ=Dead]
      (w2_segoR :: Proxy t_Xe57S) ->
      Data.Data.$w$cgmapMp27 @ t_Xe57S @ m_segoO w_segoP w2_segoR

-- RHS size: {terms: 8, types: 21, coercions: 0, joins: 0/0}
lvl143_rejQK
  :: forall t (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Proxy t -> m (Proxy t)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*H>,
 Unf=OtherCon []]
lvl143_rejQK
  = \ (@ t_Xe57S)
      (@ (m_segoV :: * -> *))
      (w_segoW :: MonadPlus m_segoV)
      _ [Occ=Dead]
      (w2_segoY :: Proxy t_Xe57S) ->
      Data.Data.$w$cgmapMo26 @ t_Xe57S @ m_segoV w_segoW w2_segoY

-- RHS size: {terms: 19, types: 23, coercions: 40, joins: 0/0}
Data.Data.$fDataProxy [InlPrag=NOUSERINLINE CONLIKE]
  :: forall t. Data t => Data (Proxy t)
[GblId[DFunId],
 Arity=1,
 Str=<L,1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=DFun: \ (@ t_ae1Xu) (v_XGS :: Data t_ae1Xu) ->
       Data.Data.C:Data TYPE: Proxy t_ae1Xu
                        (Data.Data.$fDataProxy6 @ t_ae1Xu v_XGS)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Proxy
                                                                                    t_ae1Xu>_N
                                :: (Data.Typeable.Internal.TypeRep (Proxy t_ae1Xu) :: *)
                                   ~R# (Typeable (Proxy t_ae1Xu) :: Constraint))
                        \ (@ (c_ae4tS :: * -> *))
                          _ [Occ=Dead]
                          (z_ae2pe [Occ=Once!] :: forall g. g -> c_ae4tS g)
                          (ds_de7zN [Occ=Once!] :: Proxy t_ae1Xu) ->
                          case ds_de7zN of { Proxy ->
                          z_ae2pe @ (Proxy t_ae1Xu) (Data.Proxy.Proxy @ * @ t_ae1Xu)
                          }
                        \ (@ (c_ae4u0 :: * -> *))
                          _ [Occ=Dead]
                          (z_ae2pg [Occ=Once!] :: forall r. r -> c_ae4u0 r)
                          _ [Occ=Dead] ->
                          z_ae2pg @ (Proxy t_ae1Xu) (Data.Proxy.Proxy @ * @ t_ae1Xu)
                        \ (ds_de7zP [Occ=Once!] :: Proxy t_ae1Xu) ->
                          case ds_de7zP of { Proxy -> Data.Data.$cProxy }
                        \ _ [Occ=Dead] -> Data.Data.$tProxy
                        \ (@ (t1_ae4ug :: * -> *))
                          (@ (c_ae4uh :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae4uh (Proxy t_ae1Xu))
                        \ (@ (t1_ae4uz :: * -> * -> *))
                          (@ (c_ae4uA :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae4uA (Proxy t_ae1Xu))
                        \ _ [Occ=Dead] (x0_Xe30c [Occ=Once] :: Proxy t_ae1Xu) -> x0_Xe30c
                        (\ (@ r_Xe5bZ)
                           (@ r'_Xe5c1)
                           _ [Occ=Dead]
                           (ds1_Xe8gQ [Occ=Once] :: r_Xe5bZ)
                           _ [Occ=Dead]
                           (eta_X1nI [Occ=Once!] :: Proxy t_ae1Xu) ->
                           case eta_X1nI of { Proxy ->
                           ds1_Xe8gQ
                           `cast` (Sym (Data.Functor.Const.N:Const[0]
                                            <*>_N <r_Xe5bZ>_R <Proxy t_ae1Xu>_P)
                                   :: (r_Xe5bZ :: *) ~R# (Const r_Xe5bZ (Proxy t_ae1Xu) :: *))
                           })
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <Proxy t_ae1Xu>_R
                                ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <Proxy t_ae1Xu>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> Proxy t_ae1Xu
                                    -> Const r (Proxy t_ae1Xu) :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d. Data d => d -> r')
                                        -> Proxy t_ae1Xu
                                        -> r :: *))
                        \ (@ r_ae4vo)
                          (@ r'_ae4vp)
                          _ [Occ=Dead]
                          (ds1_de7zY [Occ=Once] :: r_ae4vo)
                          _ [Occ=Dead]
                          (x0_ae1SX [Occ=Once!] :: Proxy t_ae1Xu) ->
                          case x0_ae1SX of { Proxy -> ds1_de7zY }
                        \ (@ u_ae4vF)
                          _ [Occ=Dead]
                          (x0_ae1SX [Occ=Once!] :: Proxy t_ae1Xu) ->
                          case x0_ae1SX of { Proxy -> GHC.Types.[] @ u_ae4vF }
                        \ (@ u_ae4vT)
                          _ [Occ=Dead]
                          _ [Occ=Dead]
                          (x_ae1T7 [Occ=Once!] :: Proxy t_ae1Xu) ->
                          case x_ae1T7 of { Proxy -> Data.Maybe.fromJust1 @ u_ae4vT }
                        \ (@ (m_ae4w7 :: * -> *))
                          ($dMonad_ae4w9 [Occ=Once] :: Monad m_ae4w7)
                          _ [Occ=Dead]
                          (eta_XGF [Occ=Once!] :: Proxy t_ae1Xu) ->
                          case eta_XGF of { Proxy ->
                          return
                            @ m_ae4w7
                            $dMonad_ae4w9
                            @ (Proxy t_ae1Xu)
                            (Data.Proxy.Proxy @ * @ t_ae1Xu)
                          }
                        Data.Data.$fDataProxy_$cgmapMp @ t_ae1Xu v_XGS
                        Data.Data.$fDataProxy_$cgmapMo @ t_ae1Xu v_XGS]
Data.Data.$fDataProxy
  = \ (@ t_Xe57S) ($dData_Xe57U :: Data t_Xe57S) ->
      Data.Data.C:Data
        @ (Proxy t_Xe57S)
        ((Data.Data.$fDataProxy6 @ t_Xe57S $dData_Xe57U)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Proxy
                                                                     t_Xe57S>_N
                 :: (Data.Typeable.Internal.TypeRep (Proxy t_Xe57S) :: *)
                    ~R# (Typeable (Proxy t_Xe57S) :: Constraint)))
        (lvl130_rejQx @ t_Xe57S)
        (lvl131_rejQy @ t_Xe57S)
        (lvl132_rejQz @ t_Xe57S)
        (lvl133_rejQA @ t_Xe57S)
        (lvl134_rejQB @ t_Xe57S)
        (lvl135_rejQC @ t_Xe57S)
        (lvl136_rejQD @ t_Xe57S)
        ((lvl137_rejQE @ t_Xe57S)
         `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                 <r -> r' -> r>_R
                 ->_R <r>_R
                 ->_R <forall d. Data d => d -> r'>_R
                 ->_R <Proxy t_Xe57S>_R
                 ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <Proxy t_Xe57S>_P
                 :: (forall r r'.
                     (r -> r' -> r)
                     -> r
                     -> (forall d. Data d => d -> r')
                     -> Proxy t_Xe57S
                     -> Const r (Proxy t_Xe57S) :: *)
                    ~R# (forall r r'.
                         (r -> r' -> r)
                         -> r -> (forall d. Data d => d -> r') -> Proxy t_Xe57S -> r :: *)))
        (lvl138_rejQF @ t_Xe57S)
        (lvl139_rejQG @ t_Xe57S)
        (lvl141_rejQI @ t_Xe57S)
        (lvl140_rejQH @ t_Xe57S)
        (lvl142_rejQJ @ t_Xe57S)
        (lvl143_rejQK @ t_Xe57S)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData:~:5 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fData:~:5 = ":~:"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData:~:4 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fData:~:4 = unpackCString# Data.Data.$fData:~:5

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str20_rejQL :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str20_rejQL = "Refl"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str21_rejQM :: String
[GblId]
str21_rejQM = unpackCString# str20_rejQL

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go21_rejQN :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go21_rejQN
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str21_rejQM of {
                False -> go21_rejQN ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cRefl1_rejQO :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cRefl1_rejQO = Data.Data.AlgConstr $cRefl2_rejQP

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fData:~:3 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData:~:3
  = GHC.Types.: @ Constr Data.Data.$cRefl (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData:~:2 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fData:~:2 = Data.Data.AlgRep Data.Data.$fData:~:3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$t:~: :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$t:~:
  = Data.Data.DataType Data.Data.$fData:~:4 Data.Data.$fData:~:2

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cRefl [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cRefl
  = Data.Data.Constr
      $cRefl1_rejQO
      str21_rejQM
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$t:~:

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cRefl2_rejQP :: ConIndex
[GblId]
$cRefl2_rejQP = go21_rejQN Data.Data.$fData:~:3 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 4, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fData:~:1 :: forall b. (b :~: b, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData:~:1
  = \ (@ b_ae4qr) ->
      (Data.Type.Equality.$WRefl @ * @ b_ae4qr, GHC.Types.False)

-- RHS size: {terms: 40, types: 122, coercions: 24, joins: 0/2}
Data.Data.$w$cgmapMp4 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     ((a :: *) ~ (b :: *)) =>
     forall (m :: * -> *). MonadPlus m => (a :~: b) -> m (a :~: b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),U(U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*H>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 60 20] 270 0}]
Data.Data.$w$cgmapMp4
  = \ (@ a_segp2)
      (@ b_segp3)
      (w_segp4 :: (a_segp2 :: *) ~ (b_segp3 :: *))
      (@ (m_segp6 :: * -> *))
      (w1_segp7 :: MonadPlus m_segp6)
      (w2_segp9 :: a_segp2 :~: b_segp3) ->
      case GHC.Types.heq_sel
             @ *
             @ *
             @ a_segp2
             @ b_segp3
             (w_segp4
              `cast` (Data.Type.Equality.N:~[0] <*>_N <a_segp2>_N <b_segp3>_N
                      :: ((a_segp2 :: *) ~ (b_segp3 :: *) :: Constraint)
                         ~R# ((a_segp2 :: *) ~~ (b_segp3 :: *) :: Constraint)))
      of co_ae6JW
      { __DEFAULT ->
      let {
        lvl270_se9L0 :: m_segp6 (a_segp2 :~: b_segp3)
        [LclId]
        lvl270_se9L0
          = mzero @ m_segp6 w1_segp7 @ (a_segp2 :~: b_segp3) } in
      let {
        $dMonad_se9rB [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_segp6
        [LclId]
        $dMonad_se9rB = GHC.Base.$p2MonadPlus @ m_segp6 w1_segp7 } in
      >>=
        @ m_segp6
        $dMonad_se9rB
        @ (a_segp2 :~: b_segp3, Bool)
        @ (a_segp2 :~: b_segp3)
        (case GHC.Types.heq_sel
                @ *
                @ *
                @ b_segp3
                @ b_segp3
                (w_segp4
                 `cast` (Data.Type.Equality.N:~[0] <*>_N co_ae6JW <b_segp3>_N
                         :: ((a_segp2 :: *) ~ (b_segp3 :: *) :: Constraint)
                            ~R# ((b_segp3 :: *) ~~ (b_segp3 :: *) :: Constraint)))
         of co1_Xe7oY [Dmd=<L,A>]
         { __DEFAULT ->
         case w2_segp9
              `cast` (((:~:) <*>_N co_ae6JW <b_segp3>_N)_R
                      :: (a_segp2 :~: b_segp3 :: *) ~R# (b_segp3 :~: b_segp3 :: *))
         of
         { Refl co2_ae4qD [Dmd=<L,A>] ->
         (return
            @ m_segp6
            $dMonad_se9rB
            @ (b_segp3 :~: b_segp3, Bool)
            (Data.Data.$fData:~:1 @ b_segp3))
         `cast` (<m_segp6>_R ((,)
                                ((:~:) <*>_N (Sym co_ae6JW) <b_segp3>_N)_N <Bool>_N)_N
                 :: (m_segp6 (b_segp3 :~: b_segp3, Bool) :: *)
                    ~R# (m_segp6 (a_segp2 :~: b_segp3, Bool) :: *))
         }
         })
        (\ (ds_de7oa :: (a_segp2 :~: b_segp3, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b1_ae1TE) ->
           case b1_ae1TE of {
             False -> lvl270_se9L0;
             True ->
               return @ m_segp6 $dMonad_se9rB @ (a_segp2 :~: b_segp3) x'_ae1TD
           }
           })
      }

-- RHS size: {terms: 12, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fData:~:_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     ((a :: *) ~ (b :: *), Data a) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> (a :~: b) -> m (a :~: b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S),U(U)><L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_segp2)
                 (@ b_segp3)
                 (w_segp4 [Occ=Once] :: (a_segp2 :: *) ~ (b_segp3 :: *))
                 _ [Occ=Dead]
                 (@ (m_segp6 :: * -> *))
                 (w2_segp7 [Occ=Once] :: MonadPlus m_segp6)
                 _ [Occ=Dead]
                 (w4_segp9 [Occ=Once] :: a_segp2 :~: b_segp3) ->
                 Data.Data.$w$cgmapMp4
                   @ a_segp2 @ b_segp3 w_segp4 @ m_segp6 w2_segp7 w4_segp9}]
Data.Data.$fData:~:_$cgmapMp
  = \ (@ a_segp2)
      (@ b_segp3)
      (w_segp4 :: (a_segp2 :: *) ~ (b_segp3 :: *))
      _ [Occ=Dead]
      (@ (m_segp6 :: * -> *))
      (w2_segp7 :: MonadPlus m_segp6)
      _ [Occ=Dead]
      (w4_segp9 :: a_segp2 :~: b_segp3) ->
      Data.Data.$w$cgmapMp4
        @ a_segp2 @ b_segp3 w_segp4 @ m_segp6 w2_segp7 w4_segp9

-- RHS size: {terms: 22, types: 76, coercions: 22, joins: 0/0}
Data.Data.$fData:~:_$cgmapM
  :: forall a b.
     ((a :: *) ~ (b :: *), Data a) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> (a :~: b) -> m (a :~: b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S),U(U)><L,A><S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><L,A><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae4qq)
                 (@ b_ae4qr)
                 ($d~_ae4qs :: (a_ae4qq :: *) ~ (b_ae4qr :: *))
                 _ [Occ=Dead]
                 (@ (m_ae4sY :: * -> *))
                 (eta_XH4 [Occ=Once] :: Monad m_ae4sY)
                 _ [Occ=Dead]
                 (eta2_B1 [Occ=Once] :: a_ae4qq :~: b_ae4qr) ->
                 case GHC.Types.heq_sel
                        @ *
                        @ *
                        @ a_ae4qq
                        @ b_ae4qr
                        ($d~_ae4qs
                         `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae4qq>_N <b_ae4qr>_N
                                 :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                                    ~R# ((a_ae4qq :: *) ~~ (b_ae4qr :: *) :: Constraint)))
                 of co_ae6JW
                 { __DEFAULT ->
                 case GHC.Types.heq_sel
                        @ *
                        @ *
                        @ b_ae4qr
                        @ b_ae4qr
                        ($d~_ae4qs
                         `cast` (Data.Type.Equality.N:~[0] <*>_N co_ae6JW <b_ae4qr>_N
                                 :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                                    ~R# ((b_ae4qr :: *) ~~ (b_ae4qr :: *) :: Constraint)))
                 of
                 { __DEFAULT ->
                 case eta2_B1
                      `cast` (((:~:) <*>_N co_ae6JW <b_ae4qr>_N)_R
                              :: (a_ae4qq :~: b_ae4qr :: *) ~R# (b_ae4qr :~: b_ae4qr :: *))
                 of
                 { Refl _ [Occ=Dead] ->
                 (return
                    @ m_ae4sY
                    eta_XH4
                    @ (b_ae4qr :~: b_ae4qr)
                    (Data.Type.Equality.$WRefl @ * @ b_ae4qr))
                 `cast` (<m_ae4sY>_R ((:~:) <*>_N (Sym co_ae6JW) <b_ae4qr>_N)_N
                         :: (m_ae4sY (b_ae4qr :~: b_ae4qr) :: *)
                            ~R# (m_ae4sY (a_ae4qq :~: b_ae4qr) :: *))
                 }
                 }
                 }}]
Data.Data.$fData:~:_$cgmapM
  = \ (@ a_ae4qq)
      (@ b_ae4qr)
      ($d~_ae4qs :: (a_ae4qq :: *) ~ (b_ae4qr :: *))
      _ [Occ=Dead]
      (@ (m_ae4sY :: * -> *))
      (eta_XH4 :: Monad m_ae4sY)
      _ [Occ=Dead]
      (eta2_B1 :: a_ae4qq :~: b_ae4qr) ->
      case GHC.Types.heq_sel
             @ *
             @ *
             @ a_ae4qq
             @ b_ae4qr
             ($d~_ae4qs
              `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae4qq>_N <b_ae4qr>_N
                      :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                         ~R# ((a_ae4qq :: *) ~~ (b_ae4qr :: *) :: Constraint)))
      of co_ae6JW
      { __DEFAULT ->
      case GHC.Types.heq_sel
             @ *
             @ *
             @ b_ae4qr
             @ b_ae4qr
             ($d~_ae4qs
              `cast` (Data.Type.Equality.N:~[0] <*>_N co_ae6JW <b_ae4qr>_N
                      :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                         ~R# ((b_ae4qr :: *) ~~ (b_ae4qr :: *) :: Constraint)))
      of co1_Xe7oT [Dmd=<L,A>]
      { __DEFAULT ->
      case eta2_B1
           `cast` (((:~:) <*>_N co_ae6JW <b_ae4qr>_N)_R
                   :: (a_ae4qq :~: b_ae4qr :: *) ~R# (b_ae4qr :~: b_ae4qr :: *))
      of
      { Refl co2_ae4qD [Dmd=<L,A>] ->
      (return
         @ m_ae4sY
         eta_XH4
         @ (b_ae4qr :~: b_ae4qr)
         (Data.Type.Equality.$WRefl @ * @ b_ae4qr))
      `cast` (<m_ae4sY>_R ((:~:) <*>_N (Sym co_ae6JW) <b_ae4qr>_N)_N
              :: (m_ae4sY (b_ae4qr :~: b_ae4qr) :: *)
                 ~R# (m_ae4sY (a_ae4qq :~: b_ae4qr) :: *))
      }
      }
      }

-- RHS size: {terms: 14, types: 43, coercions: 10, joins: 0/0}
Data.Data.$w$cgmapQi2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b. ((a :: *) ~ (b :: *)) => forall u. (a :~: b) -> u
[GblId, Arity=2, Str=<B,U(U)><B,A>x, Unf=OtherCon []]
Data.Data.$w$cgmapQi2
  = \ (@ a_segpb)
      (@ b_segpc)
      (w_segpd :: (a_segpb :: *) ~ (b_segpc :: *))
      (@ u_segpf)
      _ [Occ=Dead] ->
      case GHC.Types.heq_sel
             @ *
             @ *
             @ a_segpb
             @ b_segpc
             (w_segpd
              `cast` (Data.Type.Equality.N:~[0] <*>_N <a_segpb>_N <b_segpc>_N
                      :: ((a_segpb :: *) ~ (b_segpc :: *) :: Constraint)
                         ~R# ((a_segpb :: *) ~~ (b_segpc :: *) :: Constraint)))
      of co_ae6JW [Dmd=<B,U>]
      { __DEFAULT ->
      case GHC.Types.heq_sel
             @ *
             @ *
             @ b_segpc
             @ b_segpc
             (w_segpd
              `cast` (Data.Type.Equality.N:~[0] <*>_N co_ae6JW <b_segpc>_N
                      :: ((a_segpb :: *) ~ (b_segpc :: *) :: Constraint)
                         ~R# ((b_segpc :: *) ~~ (b_segpc :: *) :: Constraint)))
      of co1_Xe7oU [Dmd=<B,A>]
      { __DEFAULT ->
      Data.Maybe.fromJust1 @ u_segpf
      }
      }

-- RHS size: {terms: 11, types: 28, coercions: 0, joins: 0/0}
Data.Data.$fData:~:_$cgmapQi [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     ((a :: *) ~ (b :: *), Data a) =>
     forall u. Int -> (forall d. Data d => d -> u) -> (a :~: b) -> u
[GblId,
 Arity=5,
 Str=<B,U(U)><B,A><B,A><B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_segpb)
                 (@ b_segpc)
                 (w_segpd [Occ=Once] :: (a_segpb :: *) ~ (b_segpc :: *))
                 _ [Occ=Dead]
                 (@ u_segpf)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w4_segpi [Occ=Once] :: a_segpb :~: b_segpc) ->
                 Data.Data.$w$cgmapQi2
                   @ a_segpb @ b_segpc w_segpd @ u_segpf w4_segpi}]
Data.Data.$fData:~:_$cgmapQi
  = \ (@ a_segpb)
      (@ b_segpc)
      (w_segpd :: (a_segpb :: *) ~ (b_segpc :: *))
      _ [Occ=Dead]
      (@ u_segpf)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w4_segpi :: a_segpb :~: b_segpc) ->
      Data.Data.$w$cgmapQi2
        @ a_segpb @ b_segpc w_segpd @ u_segpf w4_segpi

-- RHS size: {terms: 19, types: 63, coercions: 15, joins: 0/0}
Data.Data.$fData:~:_$cgmapQ
  :: forall a b.
     ((a :: *) ~ (b :: *), Data a) =>
     forall u. (forall d. Data d => d -> u) -> (a :~: b) -> [u]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),U(U)><L,A><L,A><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae4qq)
                 (@ b_ae4qr)
                 ($d~_ae4qs :: (a_ae4qq :: *) ~ (b_ae4qr :: *))
                 _ [Occ=Dead]
                 (@ u_ae4sw)
                 _ [Occ=Dead]
                 (eta1_B1 [Occ=Once] :: a_ae4qq :~: b_ae4qr) ->
                 case GHC.Types.heq_sel
                        @ *
                        @ *
                        @ a_ae4qq
                        @ b_ae4qr
                        ($d~_ae4qs
                         `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae4qq>_N <b_ae4qr>_N
                                 :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                                    ~R# ((a_ae4qq :: *) ~~ (b_ae4qr :: *) :: Constraint)))
                 of co_ae6JW
                 { __DEFAULT ->
                 case GHC.Types.heq_sel
                        @ *
                        @ *
                        @ b_ae4qr
                        @ b_ae4qr
                        ($d~_ae4qs
                         `cast` (Data.Type.Equality.N:~[0] <*>_N co_ae6JW <b_ae4qr>_N
                                 :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                                    ~R# ((b_ae4qr :: *) ~~ (b_ae4qr :: *) :: Constraint)))
                 of
                 { __DEFAULT ->
                 case GHC.Types.heq_sel
                        @ *
                        @ *
                        @ b_ae4qr
                        @ b_ae4qr
                        ($d~_ae4qs
                         `cast` (Data.Type.Equality.N:~[0] <*>_N co_ae6JW <b_ae4qr>_N
                                 :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                                    ~R# ((b_ae4qr :: *) ~~ (b_ae4qr :: *) :: Constraint)))
                 of
                 { __DEFAULT ->
                 case eta1_B1
                      `cast` (((:~:) <*>_N co_ae6JW <b_ae4qr>_N)_R
                              :: (a_ae4qq :~: b_ae4qr :: *) ~R# (b_ae4qr :~: b_ae4qr :: *))
                 of
                 { Refl _ [Occ=Dead] ->
                 GHC.Types.[] @ u_ae4sw
                 }
                 }
                 }
                 }}]
Data.Data.$fData:~:_$cgmapQ
  = \ (@ a_ae4qq)
      (@ b_ae4qr)
      ($d~_ae4qs :: (a_ae4qq :: *) ~ (b_ae4qr :: *))
      _ [Occ=Dead]
      (@ u_ae4sw)
      _ [Occ=Dead]
      (eta1_B1 :: a_ae4qq :~: b_ae4qr) ->
      case GHC.Types.heq_sel
             @ *
             @ *
             @ a_ae4qq
             @ b_ae4qr
             ($d~_ae4qs
              `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae4qq>_N <b_ae4qr>_N
                      :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                         ~R# ((a_ae4qq :: *) ~~ (b_ae4qr :: *) :: Constraint)))
      of co_ae6JW
      { __DEFAULT ->
      case GHC.Types.heq_sel
             @ *
             @ *
             @ b_ae4qr
             @ b_ae4qr
             ($d~_ae4qs
              `cast` (Data.Type.Equality.N:~[0] <*>_N co_ae6JW <b_ae4qr>_N
                      :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                         ~R# ((b_ae4qr :: *) ~~ (b_ae4qr :: *) :: Constraint)))
      of co1_Xe7r9 [Dmd=<L,A>]
      { __DEFAULT ->
      case eta1_B1
           `cast` (((:~:) <*>_N co_ae6JW <b_ae4qr>_N)_R
                   :: (a_ae4qq :~: b_ae4qr :: *) ~R# (b_ae4qr :~: b_ae4qr :: *))
      of
      { Refl co2_ae4qD [Dmd=<L,A>] ->
      GHC.Types.[] @ u_ae4sw
      }
      }
      }

-- RHS size: {terms: 18, types: 63, coercions: 21, joins: 0/0}
Data.Data.$fData:~:_$cgmapT
  :: forall a b.
     ((a :: *) ~ (b :: *), Data a) =>
     (forall b1. Data b1 => b1 -> b1) -> (a :~: b) -> a :~: b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),U(U)><L,A><L,A><S,1*H>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_ae4qq)
                 (@ b_ae4qr)
                 ($d~_ae4qs :: (a_ae4qq :: *) ~ (b_ae4qr :: *))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (eta1_B1 [Occ=Once] :: a_ae4qq :~: b_ae4qr) ->
                 case GHC.Types.heq_sel
                        @ *
                        @ *
                        @ a_ae4qq
                        @ b_ae4qr
                        ($d~_ae4qs
                         `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae4qq>_N <b_ae4qr>_N
                                 :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                                    ~R# ((a_ae4qq :: *) ~~ (b_ae4qr :: *) :: Constraint)))
                 of co_ae6JW
                 { __DEFAULT ->
                 case GHC.Types.heq_sel
                        @ *
                        @ *
                        @ b_ae4qr
                        @ b_ae4qr
                        ($d~_ae4qs
                         `cast` (Data.Type.Equality.N:~[0] <*>_N co_ae6JW <b_ae4qr>_N
                                 :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                                    ~R# ((b_ae4qr :: *) ~~ (b_ae4qr :: *) :: Constraint)))
                 of
                 { __DEFAULT ->
                 case eta1_B1
                      `cast` (((:~:) <*>_N co_ae6JW <b_ae4qr>_N)_R
                              :: (a_ae4qq :~: b_ae4qr :: *) ~R# (b_ae4qr :~: b_ae4qr :: *))
                 of
                 { Refl _ [Occ=Dead] ->
                 (Data.Type.Equality.$WRefl @ * @ b_ae4qr)
                 `cast` (((:~:) <*>_N (Sym co_ae6JW) <b_ae4qr>_N)_R
                         :: (b_ae4qr :~: b_ae4qr :: *) ~R# (a_ae4qq :~: b_ae4qr :: *))
                 }
                 }
                 }}]
Data.Data.$fData:~:_$cgmapT
  = \ (@ a_ae4qq)
      (@ b_ae4qr)
      ($d~_ae4qs :: (a_ae4qq :: *) ~ (b_ae4qr :: *))
      _ [Occ=Dead]
      _ [Occ=Dead]
      (eta1_B1 :: a_ae4qq :~: b_ae4qr) ->
      case GHC.Types.heq_sel
             @ *
             @ *
             @ a_ae4qq
             @ b_ae4qr
             ($d~_ae4qs
              `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae4qq>_N <b_ae4qr>_N
                      :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                         ~R# ((a_ae4qq :: *) ~~ (b_ae4qr :: *) :: Constraint)))
      of co_ae6JW
      { __DEFAULT ->
      case GHC.Types.heq_sel
             @ *
             @ *
             @ b_ae4qr
             @ b_ae4qr
             ($d~_ae4qs
              `cast` (Data.Type.Equality.N:~[0] <*>_N co_ae6JW <b_ae4qr>_N
                      :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                         ~R# ((b_ae4qr :: *) ~~ (b_ae4qr :: *) :: Constraint)))
      of co1_Xe7oN [Dmd=<L,A>]
      { __DEFAULT ->
      case eta1_B1
           `cast` (((:~:) <*>_N co_ae6JW <b_ae4qr>_N)_R
                   :: (a_ae4qq :~: b_ae4qr :: *) ~R# (b_ae4qr :~: b_ae4qr :: *))
      of
      { Refl co2_ae4qD [Dmd=<L,A>] ->
      (Data.Type.Equality.$WRefl @ * @ b_ae4qr)
      `cast` (((:~:) <*>_N (Sym co_ae6JW) <b_ae4qr>_N)_R
              :: (b_ae4qr :~: b_ae4qr :: *) ~R# (a_ae4qq :~: b_ae4qr :: *))
      }
      }
      }

-- RHS size: {terms: 40, types: 122, coercions: 24, joins: 0/2}
Data.Data.$w$cgmapMo4 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     ((a :: *) ~ (b :: *)) =>
     forall (m :: * -> *). MonadPlus m => (a :~: b) -> m (a :~: b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),U(U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*H>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 60 20] 270 0}]
Data.Data.$w$cgmapMo4
  = \ (@ a_segpk)
      (@ b_segpl)
      (w_segpm :: (a_segpk :: *) ~ (b_segpl :: *))
      (@ (m_segpo :: * -> *))
      (w1_segpp :: MonadPlus m_segpo)
      (w2_segpr :: a_segpk :~: b_segpl) ->
      case GHC.Types.heq_sel
             @ *
             @ *
             @ a_segpk
             @ b_segpl
             (w_segpm
              `cast` (Data.Type.Equality.N:~[0] <*>_N <a_segpk>_N <b_segpl>_N
                      :: ((a_segpk :: *) ~ (b_segpl :: *) :: Constraint)
                         ~R# ((a_segpk :: *) ~~ (b_segpl :: *) :: Constraint)))
      of co_ae6JW
      { __DEFAULT ->
      let {
        lvl270_se9L4 :: m_segpo (a_segpk :~: b_segpl)
        [LclId]
        lvl270_se9L4
          = mzero @ m_segpo w1_segpp @ (a_segpk :~: b_segpl) } in
      let {
        $dMonad_se9rz [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_segpo
        [LclId]
        $dMonad_se9rz = GHC.Base.$p2MonadPlus @ m_segpo w1_segpp } in
      >>=
        @ m_segpo
        $dMonad_se9rz
        @ (a_segpk :~: b_segpl, Bool)
        @ (a_segpk :~: b_segpl)
        (case GHC.Types.heq_sel
                @ *
                @ *
                @ b_segpl
                @ b_segpl
                (w_segpm
                 `cast` (Data.Type.Equality.N:~[0] <*>_N co_ae6JW <b_segpl>_N
                         :: ((a_segpk :: *) ~ (b_segpl :: *) :: Constraint)
                            ~R# ((b_segpl :: *) ~~ (b_segpl :: *) :: Constraint)))
         of co1_Xe7oQ [Dmd=<L,A>]
         { __DEFAULT ->
         case w2_segpr
              `cast` (((:~:) <*>_N co_ae6JW <b_segpl>_N)_R
                      :: (a_segpk :~: b_segpl :: *) ~R# (b_segpl :~: b_segpl :: *))
         of
         { Refl co2_ae4qD [Dmd=<L,A>] ->
         (return
            @ m_segpo
            $dMonad_se9rz
            @ (b_segpl :~: b_segpl, Bool)
            (Data.Data.$fData:~:1 @ b_segpl))
         `cast` (<m_segpo>_R ((,)
                                ((:~:) <*>_N (Sym co_ae6JW) <b_segpl>_N)_N <Bool>_N)_N
                 :: (m_segpo (b_segpl :~: b_segpl, Bool) :: *)
                    ~R# (m_segpo (a_segpk :~: b_segpl, Bool) :: *))
         }
         })
        (\ (ds_de7pa :: (a_segpk :~: b_segpl, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b1_ae1TT) ->
           case b1_ae1TT of {
             False -> lvl270_se9L4;
             True ->
               return @ m_segpo $dMonad_se9rz @ (a_segpk :~: b_segpl) x'_ae1TS
           }
           })
      }

-- RHS size: {terms: 12, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fData:~:_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     ((a :: *) ~ (b :: *), Data a) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> (a :~: b) -> m (a :~: b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(S),U(U)><L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_segpk)
                 (@ b_segpl)
                 (w_segpm [Occ=Once] :: (a_segpk :: *) ~ (b_segpl :: *))
                 _ [Occ=Dead]
                 (@ (m_segpo :: * -> *))
                 (w2_segpp [Occ=Once] :: MonadPlus m_segpo)
                 _ [Occ=Dead]
                 (w4_segpr [Occ=Once] :: a_segpk :~: b_segpl) ->
                 Data.Data.$w$cgmapMo4
                   @ a_segpk @ b_segpl w_segpm @ m_segpo w2_segpp w4_segpr}]
Data.Data.$fData:~:_$cgmapMo
  = \ (@ a_segpk)
      (@ b_segpl)
      (w_segpm :: (a_segpk :: *) ~ (b_segpl :: *))
      _ [Occ=Dead]
      (@ (m_segpo :: * -> *))
      (w2_segpp :: MonadPlus m_segpo)
      _ [Occ=Dead]
      (w4_segpr :: a_segpk :~: b_segpl) ->
      Data.Data.$w$cgmapMo4
        @ a_segpk @ b_segpl w_segpm @ m_segpo w2_segpp w4_segpr

-- RHS size: {terms: 132, types: 435, coercions: 72, joins: 0/0}
Data.Data.$fData:~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. ((a :: *) ~ (b :: *), Data a) => Data (a :~: b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U)><L,1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=DFun: \ (@ a_ae1Xs)
             (@ b_ae1Xt)
             (v_XH9 :: (a_ae1Xs :: *) ~ (b_ae1Xt :: *))
             (v1_XHb :: Data a_ae1Xs) ->
       Data.Data.C:Data TYPE: a_ae1Xs :~: b_ae1Xt
                        Data.Data.$fData:~:_$cp1Data @ a_ae1Xs @ b_ae1Xt v_XH9 v1_XHb
                        \ (@ (c_ae4qB :: * -> *))
                          _ [Occ=Dead]
                          (eta1_XEA [Occ=Once!] :: forall g. g -> c_ae4qB g)
                          (eta2_X1j9 [Occ=Once!] :: a_ae1Xs :~: b_ae1Xt) ->
                          case GHC.Types.heq_sel
                                 @ *
                                 @ *
                                 @ a_ae1Xs
                                 @ b_ae1Xt
                                 (v_XH9
                                  `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae1Xs>_N <b_ae1Xt>_N
                                          :: ((a_ae1Xs :: *) ~ (b_ae1Xt :: *) :: Constraint)
                                             ~R# ((a_ae1Xs :: *) ~~ (b_ae1Xt :: *) :: Constraint)))
                          of co_ae6JW
                          { __DEFAULT ->
                          case eta2_X1j9 of { Refl _ [Occ=Dead] ->
                          (eta1_XEA
                             @ (a_ae1Xs :~: a_ae1Xs) (Data.Type.Equality.$WRefl @ * @ a_ae1Xs))
                          `cast` (<c_ae4qB>_R ((:~:) <*>_N <a_ae1Xs>_N co_ae6JW)_N
                                  :: (c_ae4qB (a_ae1Xs :~: a_ae1Xs) :: *)
                                     ~R# (c_ae4qB (a_ae1Xs :~: b_ae1Xt) :: *))
                          }
                          }
                        \ (@ (c_ae4qN :: * -> *))
                          _ [Occ=Dead]
                          (eta1_X1os [Occ=Once!] :: forall r. r -> c_ae4qN r)
                          _ [Occ=Dead] ->
                          case GHC.Types.heq_sel
                                 @ *
                                 @ *
                                 @ a_ae1Xs
                                 @ b_ae1Xt
                                 (v_XH9
                                  `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae1Xs>_N <b_ae1Xt>_N
                                          :: ((a_ae1Xs :: *) ~ (b_ae1Xt :: *) :: Constraint)
                                             ~R# ((a_ae1Xs :: *) ~~ (b_ae1Xt :: *) :: Constraint)))
                          of co_ae6JW
                          { __DEFAULT ->
                          (eta1_X1os
                             @ (a_ae1Xs :~: a_ae1Xs) (Data.Type.Equality.$WRefl @ * @ a_ae1Xs))
                          `cast` (<c_ae4qN>_R ((:~:) <*>_N <a_ae1Xs>_N co_ae6JW)_N
                                  :: (c_ae4qN (a_ae1Xs :~: a_ae1Xs) :: *)
                                     ~R# (c_ae4qN (a_ae1Xs :~: b_ae1Xt) :: *))
                          }
                        \ (eta_XEx [Occ=Once!] :: a_ae1Xs :~: b_ae1Xt) ->
                          case GHC.Types.heq_sel
                                 @ *
                                 @ *
                                 @ a_ae1Xs
                                 @ b_ae1Xt
                                 (v_XH9
                                  `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae1Xs>_N <b_ae1Xt>_N
                                          :: ((a_ae1Xs :: *) ~ (b_ae1Xt :: *) :: Constraint)
                                             ~R# ((a_ae1Xs :: *) ~~ (b_ae1Xt :: *) :: Constraint)))
                          of
                          { __DEFAULT ->
                          case eta_XEx of { Refl _ [Occ=Dead] -> Data.Data.$cRefl }
                          }
                        \ _ [Occ=Dead] ->
                          case GHC.Types.heq_sel
                                 @ *
                                 @ *
                                 @ a_ae1Xs
                                 @ b_ae1Xt
                                 (v_XH9
                                  `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae1Xs>_N <b_ae1Xt>_N
                                          :: ((a_ae1Xs :: *) ~ (b_ae1Xt :: *) :: Constraint)
                                             ~R# ((a_ae1Xs :: *) ~~ (b_ae1Xt :: *) :: Constraint)))
                          of
                          { __DEFAULT ->
                          Data.Data.$t:~:
                          }
                        \ (@ (t_ae4r7 :: * -> *))
                          (@ (c_ae4r8 :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          case GHC.Types.heq_sel
                                 @ *
                                 @ *
                                 @ a_ae1Xs
                                 @ b_ae1Xt
                                 (v_XH9
                                  `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae1Xs>_N <b_ae1Xt>_N
                                          :: ((a_ae1Xs :: *) ~ (b_ae1Xt :: *) :: Constraint)
                                             ~R# ((a_ae1Xs :: *) ~~ (b_ae1Xt :: *) :: Constraint)))
                          of
                          { __DEFAULT ->
                          GHC.Base.Nothing @ (c_ae4r8 (a_ae1Xs :~: b_ae1Xt))
                          }
                        \ (@ (t_ae4rq :: * -> * -> *))
                          (@ (c_ae4rr :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          case GHC.Types.heq_sel
                                 @ *
                                 @ *
                                 @ a_ae1Xs
                                 @ b_ae1Xt
                                 (v_XH9
                                  `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae1Xs>_N <b_ae1Xt>_N
                                          :: ((a_ae1Xs :: *) ~ (b_ae1Xt :: *) :: Constraint)
                                             ~R# ((a_ae1Xs :: *) ~~ (b_ae1Xt :: *) :: Constraint)))
                          of
                          { __DEFAULT ->
                          GHC.Base.Nothing @ (c_ae4rr (a_ae1Xs :~: b_ae1Xt))
                          }
                        Data.Data.$fData:~:_$cgmapT @ a_ae1Xs @ b_ae1Xt v_XH9 v1_XHb
                        \ (@ r_ae4rY)
                          (@ r'_ae4rZ)
                          _ [Occ=Dead]
                          (eta1_B3 [Occ=Once] :: r_ae4rY)
                          _ [Occ=Dead]
                          (eta3_B1 [Occ=Once] :: a_ae1Xs :~: b_ae1Xt) ->
                          case GHC.Types.heq_sel
                                 @ *
                                 @ *
                                 @ a_ae1Xs
                                 @ b_ae1Xt
                                 (v_XH9
                                  `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae1Xs>_N <b_ae1Xt>_N
                                          :: ((a_ae1Xs :: *) ~ (b_ae1Xt :: *) :: Constraint)
                                             ~R# ((a_ae1Xs :: *) ~~ (b_ae1Xt :: *) :: Constraint)))
                          of co_ae6JW
                          { __DEFAULT ->
                          case GHC.Types.heq_sel
                                 @ *
                                 @ *
                                 @ b_ae1Xt
                                 @ b_ae1Xt
                                 (v_XH9
                                  `cast` (Data.Type.Equality.N:~[0] <*>_N co_ae6JW <b_ae1Xt>_N
                                          :: ((a_ae1Xs :: *) ~ (b_ae1Xt :: *) :: Constraint)
                                             ~R# ((b_ae1Xt :: *) ~~ (b_ae1Xt :: *) :: Constraint)))
                          of
                          { __DEFAULT ->
                          case eta3_B1
                               `cast` (((:~:) <*>_N co_ae6JW <b_ae1Xt>_N)_R
                                       :: (a_ae1Xs :~: b_ae1Xt :: *) ~R# (b_ae1Xt :~: b_ae1Xt :: *))
                          of
                          { Refl _ [Occ=Dead] ->
                          eta1_B3
                          }
                          }
                          }
                        \ (@ r_ae4sf)
                          (@ r'_ae4sg)
                          _ [Occ=Dead]
                          (eta1_B3 [Occ=Once] :: r_ae4sf)
                          _ [Occ=Dead]
                          (eta3_B1 [Occ=Once] :: a_ae1Xs :~: b_ae1Xt) ->
                          case GHC.Types.heq_sel
                                 @ *
                                 @ *
                                 @ a_ae1Xs
                                 @ b_ae1Xt
                                 (v_XH9
                                  `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae1Xs>_N <b_ae1Xt>_N
                                          :: ((a_ae1Xs :: *) ~ (b_ae1Xt :: *) :: Constraint)
                                             ~R# ((a_ae1Xs :: *) ~~ (b_ae1Xt :: *) :: Constraint)))
                          of co_ae6JW
                          { __DEFAULT ->
                          case GHC.Types.heq_sel
                                 @ *
                                 @ *
                                 @ b_ae1Xt
                                 @ b_ae1Xt
                                 (v_XH9
                                  `cast` (Data.Type.Equality.N:~[0] <*>_N co_ae6JW <b_ae1Xt>_N
                                          :: ((a_ae1Xs :: *) ~ (b_ae1Xt :: *) :: Constraint)
                                             ~R# ((b_ae1Xt :: *) ~~ (b_ae1Xt :: *) :: Constraint)))
                          of
                          { __DEFAULT ->
                          case eta3_B1
                               `cast` (((:~:) <*>_N co_ae6JW <b_ae1Xt>_N)_R
                                       :: (a_ae1Xs :~: b_ae1Xt :: *) ~R# (b_ae1Xt :~: b_ae1Xt :: *))
                          of
                          { Refl _ [Occ=Dead] ->
                          eta1_B3
                          }
                          }
                          }
                        Data.Data.$fData:~:_$cgmapQ @ a_ae1Xs @ b_ae1Xt v_XH9 v1_XHb
                        Data.Data.$fData:~:_$cgmapQi @ a_ae1Xs @ b_ae1Xt v_XH9 v1_XHb
                        Data.Data.$fData:~:_$cgmapM @ a_ae1Xs @ b_ae1Xt v_XH9 v1_XHb
                        Data.Data.$fData:~:_$cgmapMp @ a_ae1Xs @ b_ae1Xt v_XH9 v1_XHb
                        Data.Data.$fData:~:_$cgmapMo @ a_ae1Xs @ b_ae1Xt v_XH9 v1_XHb]
Data.Data.$fData:~:
  = \ (@ a_ae4qq)
      (@ b_ae4qr)
      ($d~_ae4qs :: (a_ae4qq :: *) ~ (b_ae4qr :: *))
      ($dData_ae4qt :: Data a_ae4qq) ->
      Data.Data.C:Data
        @ (a_ae4qq :~: b_ae4qr)
        (Data.Data.$fData:~:_$cp1Data
           @ a_ae4qq @ b_ae4qr $d~_ae4qs $dData_ae4qt)
        (\ (@ (c_ae4qB :: * -> *))
           _ [Occ=Dead]
           (eta1_X1oq :: forall g. g -> c_ae4qB g)
           (eta2_X1or :: a_ae4qq :~: b_ae4qr) ->
           case GHC.Types.heq_sel
                  @ *
                  @ *
                  @ a_ae4qq
                  @ b_ae4qr
                  ($d~_ae4qs
                   `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae4qq>_N <b_ae4qr>_N
                           :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                              ~R# ((a_ae4qq :: *) ~~ (b_ae4qr :: *) :: Constraint)))
           of co_ae6JW
           { __DEFAULT ->
           case eta2_X1or of { Refl co1_ae4qD [Dmd=<L,A>] ->
           (eta1_X1oq
              @ (a_ae4qq :~: a_ae4qq) (Data.Type.Equality.$WRefl @ * @ a_ae4qq))
           `cast` (<c_ae4qB>_R ((:~:) <*>_N <a_ae4qq>_N co_ae6JW)_N
                   :: (c_ae4qB (a_ae4qq :~: a_ae4qq) :: *)
                      ~R# (c_ae4qB (a_ae4qq :~: b_ae4qr) :: *))
           }
           })
        (\ (@ (c_ae4qN :: * -> *))
           _ [Occ=Dead]
           (eta1_X1os :: forall r. r -> c_ae4qN r)
           _ [Occ=Dead] ->
           case GHC.Types.heq_sel
                  @ *
                  @ *
                  @ a_ae4qq
                  @ b_ae4qr
                  ($d~_ae4qs
                   `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae4qq>_N <b_ae4qr>_N
                           :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                              ~R# ((a_ae4qq :: *) ~~ (b_ae4qr :: *) :: Constraint)))
           of co_ae6JW
           { __DEFAULT ->
           (eta1_X1os
              @ (a_ae4qq :~: a_ae4qq) (Data.Type.Equality.$WRefl @ * @ a_ae4qq))
           `cast` (<c_ae4qN>_R ((:~:) <*>_N <a_ae4qq>_N co_ae6JW)_N
                   :: (c_ae4qN (a_ae4qq :~: a_ae4qq) :: *)
                      ~R# (c_ae4qN (a_ae4qq :~: b_ae4qr) :: *))
           })
        (\ (eta_XHb :: a_ae4qq :~: b_ae4qr) ->
           case GHC.Types.heq_sel
                  @ *
                  @ *
                  @ a_ae4qq
                  @ b_ae4qr
                  ($d~_ae4qs
                   `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae4qq>_N <b_ae4qr>_N
                           :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                              ~R# ((a_ae4qq :: *) ~~ (b_ae4qr :: *) :: Constraint)))
           of co_ae6JW [Dmd=<L,A>]
           { __DEFAULT ->
           case eta_XHb of { Refl co1_ae4qY [Dmd=<L,A>] -> Data.Data.$cRefl }
           })
        (\ _ [Occ=Dead] ->
           case GHC.Types.heq_sel
                  @ *
                  @ *
                  @ a_ae4qq
                  @ b_ae4qr
                  ($d~_ae4qs
                   `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae4qq>_N <b_ae4qr>_N
                           :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                              ~R# ((a_ae4qq :: *) ~~ (b_ae4qr :: *) :: Constraint)))
           of co_ae6JW [Dmd=<L,A>]
           { __DEFAULT ->
           Data.Data.$t:~:
           })
        (\ (@ (t_ae4r7 :: * -> *))
           (@ (c_ae4r8 :: * -> *))
           _ [Occ=Dead]
           _ [Occ=Dead] ->
           case GHC.Types.heq_sel
                  @ *
                  @ *
                  @ a_ae4qq
                  @ b_ae4qr
                  ($d~_ae4qs
                   `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae4qq>_N <b_ae4qr>_N
                           :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                              ~R# ((a_ae4qq :: *) ~~ (b_ae4qr :: *) :: Constraint)))
           of co_ae6JW [Dmd=<L,A>]
           { __DEFAULT ->
           GHC.Base.Nothing @ (c_ae4r8 (a_ae4qq :~: b_ae4qr))
           })
        (\ (@ (t_ae4rq :: * -> * -> *))
           (@ (c_ae4rr :: * -> *))
           _ [Occ=Dead]
           _ [Occ=Dead] ->
           case GHC.Types.heq_sel
                  @ *
                  @ *
                  @ a_ae4qq
                  @ b_ae4qr
                  ($d~_ae4qs
                   `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae4qq>_N <b_ae4qr>_N
                           :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                              ~R# ((a_ae4qq :: *) ~~ (b_ae4qr :: *) :: Constraint)))
           of co_ae6JW [Dmd=<L,A>]
           { __DEFAULT ->
           GHC.Base.Nothing @ (c_ae4rr (a_ae4qq :~: b_ae4qr))
           })
        (Data.Data.$fData:~:_$cgmapT
           @ a_ae4qq @ b_ae4qr $d~_ae4qs $dData_ae4qt)
        (\ (@ r_ae4rY)
           (@ r'_ae4rZ)
           _ [Occ=Dead]
           (eta1_B3 :: r_ae4rY)
           _ [Occ=Dead]
           (eta3_B1 :: a_ae4qq :~: b_ae4qr) ->
           case GHC.Types.heq_sel
                  @ *
                  @ *
                  @ a_ae4qq
                  @ b_ae4qr
                  ($d~_ae4qs
                   `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae4qq>_N <b_ae4qr>_N
                           :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                              ~R# ((a_ae4qq :: *) ~~ (b_ae4qr :: *) :: Constraint)))
           of co_ae6JW
           { __DEFAULT ->
           case GHC.Types.heq_sel
                  @ *
                  @ *
                  @ b_ae4qr
                  @ b_ae4qr
                  ($d~_ae4qs
                   `cast` (Data.Type.Equality.N:~[0] <*>_N co_ae6JW <b_ae4qr>_N
                           :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                              ~R# ((b_ae4qr :: *) ~~ (b_ae4qr :: *) :: Constraint)))
           of co1_Xe7oT [Dmd=<L,A>]
           { __DEFAULT ->
           case eta3_B1
                `cast` (((:~:) <*>_N co_ae6JW <b_ae4qr>_N)_R
                        :: (a_ae4qq :~: b_ae4qr :: *) ~R# (b_ae4qr :~: b_ae4qr :: *))
           of
           { Refl co2_ae4qD [Dmd=<L,A>] ->
           eta1_B3
           }
           }
           })
        (\ (@ r_ae4sf)
           (@ r'_ae4sg)
           _ [Occ=Dead]
           (eta1_B3 :: r_ae4sf)
           _ [Occ=Dead]
           (eta3_B1 :: a_ae4qq :~: b_ae4qr) ->
           case GHC.Types.heq_sel
                  @ *
                  @ *
                  @ a_ae4qq
                  @ b_ae4qr
                  ($d~_ae4qs
                   `cast` (Data.Type.Equality.N:~[0] <*>_N <a_ae4qq>_N <b_ae4qr>_N
                           :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                              ~R# ((a_ae4qq :: *) ~~ (b_ae4qr :: *) :: Constraint)))
           of co_ae6JW
           { __DEFAULT ->
           case GHC.Types.heq_sel
                  @ *
                  @ *
                  @ b_ae4qr
                  @ b_ae4qr
                  ($d~_ae4qs
                   `cast` (Data.Type.Equality.N:~[0] <*>_N co_ae6JW <b_ae4qr>_N
                           :: ((a_ae4qq :: *) ~ (b_ae4qr :: *) :: Constraint)
                              ~R# ((b_ae4qr :: *) ~~ (b_ae4qr :: *) :: Constraint)))
           of co1_Xe7oV [Dmd=<L,A>]
           { __DEFAULT ->
           case eta3_B1
                `cast` (((:~:) <*>_N co_ae6JW <b_ae4qr>_N)_R
                        :: (a_ae4qq :~: b_ae4qr :: *) ~R# (b_ae4qr :~: b_ae4qr :: *))
           of
           { Refl co2_ae4qD [Dmd=<L,A>] ->
           eta1_B3
           }
           }
           })
        (Data.Data.$fData:~:_$cgmapQ
           @ a_ae4qq @ b_ae4qr $d~_ae4qs $dData_ae4qt)
        (\ (@ u_segpf)
           _ [Occ=Dead]
           _ [Occ=Dead]
           (w2_segpi :: a_ae4qq :~: b_ae4qr) ->
           Data.Data.$w$cgmapQi2
             @ a_ae4qq @ b_ae4qr $d~_ae4qs @ u_segpf w2_segpi)
        (Data.Data.$fData:~:_$cgmapM
           @ a_ae4qq @ b_ae4qr $d~_ae4qs $dData_ae4qt)
        (\ (@ (m_segp6 :: * -> *))
           (w_segp7 :: MonadPlus m_segp6)
           _ [Occ=Dead]
           (w2_segp9 :: a_ae4qq :~: b_ae4qr) ->
           Data.Data.$w$cgmapMp4
             @ a_ae4qq @ b_ae4qr $d~_ae4qs @ m_segp6 w_segp7 w2_segp9)
        (\ (@ (m_segpo :: * -> *))
           (w_segpp :: MonadPlus m_segpo)
           _ [Occ=Dead]
           (w2_segpr :: a_ae4qq :~: b_ae4qr) ->
           Data.Data.$w$cgmapMo4
             @ a_ae4qq @ b_ae4qr $d~_ae4qs @ m_segpo w_segpp w2_segpr)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData:~~:5 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fData:~~:5 = ":~~:"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData:~~:4 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fData:~~:4 = unpackCString# Data.Data.$fData:~~:5

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str22_rejQQ :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str22_rejQQ = "HRefl"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str23_rejQR :: String
[GblId]
str23_rejQR = unpackCString# str22_rejQQ

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go22_rejQS :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go22_rejQS
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str23_rejQR of {
                False -> go22_rejQS ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cHRefl1_rejQT :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cHRefl1_rejQT = Data.Data.AlgConstr $cHRefl2_rejQU

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fData:~~:3 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData:~~:3
  = GHC.Types.: @ Constr Data.Data.$cHRefl (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData:~~:2 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fData:~~:2 = Data.Data.AlgRep Data.Data.$fData:~~:3

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$t:~~: :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$t:~~:
  = Data.Data.DataType Data.Data.$fData:~~:4 Data.Data.$fData:~~:2

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cHRefl [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cHRefl
  = Data.Data.Constr
      $cHRefl1_rejQT
      str23_rejQR
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$t:~~:

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cHRefl2_rejQU :: ConIndex
[GblId]
$cHRefl2_rejQU
  = go22_rejQS Data.Data.$fData:~~:3 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fData:~~:1 :: forall j (b :: j). (b :~~: b, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData:~~:1
  = \ (@ j_ae4mZ) (@ (b_ae4n1 :: j_ae4mZ)) ->
      (Data.Type.Equality.$WHRefl @ j_ae4mZ @ b_ae4n1, GHC.Types.False)

-- RHS size: {terms: 42, types: 122, coercions: 69, joins: 0/2}
Data.Data.$w$cgmapMp5 [InlPrag=NOUSERINLINE[0]]
  :: forall i j (a :: i) (b :: j).
     ((a :: i) ~~ (b :: j)) =>
     forall (m :: * -> *). MonadPlus m => (a :~~: b) -> m (a :~~: b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),U(U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*H>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 60 20] 270 0}]
Data.Data.$w$cgmapMp5
  = \ (@ i_segpv)
      (@ j_segpw)
      (@ (a_segpx :: i_segpv))
      (@ (b_segpy :: j_segpw))
      (w_segpD :: (a_segpx :: i_segpv) ~~ (b_segpy :: j_segpw))
      (@ (m_segpE :: * -> *))
      (w1_segpF :: MonadPlus m_segpE)
      (w2_segpH :: a_segpx :~~: b_segpy) ->
      case GHC.Types.heq_sel
             @ i_segpv @ j_segpw @ a_segpx @ b_segpy w_segpD
      of co_ae6J2
      { __DEFAULT ->
      let {
        lvl270_se9Lc :: m_segpE (a_segpx :~~: b_segpy)
        [LclId]
        lvl270_se9Lc
          = mzero @ m_segpE w1_segpF @ (a_segpx :~~: b_segpy) } in
      let {
        $dMonad_se9rx [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_segpE
        [LclId]
        $dMonad_se9rx = GHC.Base.$p2MonadPlus @ m_segpE w1_segpF } in
      >>=
        @ m_segpE
        $dMonad_se9rx
        @ (a_segpx :~~: b_segpy, Bool)
        @ (a_segpx :~~: b_segpy)
        (case GHC.Types.heq_sel
                @ j_segpw
                @ j_segpw
                @ b_segpy
                @ b_segpy
                (w_segpD
                 `cast` (((~~)
                            (Kind co_ae6J2)
                            <j_segpw>_N
                            (Sym (Coh (Sym co_ae6J2)
                                      (Sym (Kind co_ae6J2))) ; (Coh (Sym (Coh <b_segpy>_N
                                                                              (Sym (Kind
                                                                                        co_ae6J2))))
                                                                    (Sym (Kind
                                                                              co_ae6J2)) ; Coh <b_segpy>_N
                                                                                               (Sym (Kind
                                                                                                         co_ae6J2))))
                            <b_segpy>_N)_R
                         :: ((a_segpx :: i_segpv) ~~ (b_segpy :: j_segpw) :: Constraint)
                            ~R# ((b_segpy :: j_segpw) ~~ (b_segpy :: j_segpw) :: Constraint)))
         of co1_Xe7ou [Dmd=<L,A>]
         { __DEFAULT ->
         case w2_segpH
              `cast` (((:~~:)
                         (Kind co_ae6J2)
                         <j_segpw>_N
                         (Sym (Coh (Sym co_ae6J2) (Sym (Kind co_ae6J2))) ; Coh <b_segpy>_N
                                                                               (Sym (Kind
                                                                                         co_ae6J2)))
                         <b_segpy>_N)_R
                      :: (a_segpx :~~: b_segpy :: *) ~R# (b_segpy :~~: b_segpy :: *))
         of
         { HRefl co2_ae4ng [Dmd=<L,A>] co3_ae4nh [Dmd=<L,A>] ->
         (return
            @ m_segpE
            $dMonad_se9rx
            @ (b_segpy :~~: b_segpy, Bool)
            (Data.Data.$fData:~~:1 @ j_segpw @ b_segpy))
         `cast` (<m_segpE>_R ((,)
                                ((:~~:)
                                   (Sym (Kind co_ae6J2))
                                   <j_segpw>_N
                                   (Sym (Coh <b_segpy>_N (Sym (Kind co_ae6J2))) ; Coh (Sym co_ae6J2)
                                                                                      (Sym (Kind
                                                                                                co_ae6J2)))
                                   <b_segpy>_N)_N
                                <Bool>_N)_N
                 :: (m_segpE (b_segpy :~~: b_segpy, Bool) :: *)
                    ~R# (m_segpE (a_segpx :~~: b_segpy, Bool) :: *))
         }
         })
        (\ (ds_de7oa :: (a_segpx :~~: b_segpy, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b1_ae1TE) ->
           case b1_ae1TE of {
             False -> lvl270_se9Lc;
             True ->
               return @ m_segpE $dMonad_se9rx @ (a_segpx :~~: b_segpy) x'_ae1TD
           }
           })
      }

-- RHS size: {terms: 17, types: 48, coercions: 0, joins: 0/0}
Data.Data.$fData:~~:_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall i j (a :: i) (b :: j).
     (Typeable i, Typeable j, Typeable a, Typeable b,
      (a :: i) ~~ (b :: j)) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> (a :~~: b) -> m (a :~~: b)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><S(S),U(U)><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=8,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ i_segpv)
                 (@ j_segpw)
                 (@ (a_segpx :: i_segpv))
                 (@ (b_segpy :: j_segpw))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w4_segpD [Occ=Once]
                    :: (a_segpx :: i_segpv) ~~ (b_segpy :: j_segpw))
                 (@ (m_segpE :: * -> *))
                 (w5_segpF [Occ=Once] :: MonadPlus m_segpE)
                 _ [Occ=Dead]
                 (w7_segpH [Occ=Once] :: a_segpx :~~: b_segpy) ->
                 Data.Data.$w$cgmapMp5
                   @ i_segpv
                   @ j_segpw
                   @ a_segpx
                   @ b_segpy
                   w4_segpD
                   @ m_segpE
                   w5_segpF
                   w7_segpH}]
Data.Data.$fData:~~:_$cgmapMp
  = \ (@ i_segpv)
      (@ j_segpw)
      (@ (a_segpx :: i_segpv))
      (@ (b_segpy :: j_segpw))
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w4_segpD :: (a_segpx :: i_segpv) ~~ (b_segpy :: j_segpw))
      (@ (m_segpE :: * -> *))
      (w5_segpF :: MonadPlus m_segpE)
      _ [Occ=Dead]
      (w7_segpH :: a_segpx :~~: b_segpy) ->
      Data.Data.$w$cgmapMp5
        @ i_segpv
        @ j_segpw
        @ a_segpx
        @ b_segpy
        w4_segpD
        @ m_segpE
        w5_segpF
        w7_segpH

-- RHS size: {terms: 27, types: 86, coercions: 67, joins: 0/0}
Data.Data.$fData:~~:_$cgmapM
  :: forall i j (a :: i) (b :: j).
     (Typeable i, Typeable j, Typeable a, Typeable b,
      (a :: i) ~~ (b :: j)) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> (a :~~: b) -> m (a :~~: b)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><S(S),U(U)><S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><L,A><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=8,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ i_ae4mY)
                 (@ j_ae4mZ)
                 (@ (a_ae4n0 :: i_ae4mY))
                 (@ (b_ae4n1 :: j_ae4mZ))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 ($d~~_ae4n6 :: (a_ae4n0 :: i_ae4mY) ~~ (b_ae4n1 :: j_ae4mZ))
                 (@ (m_ae4pF :: * -> *))
                 (eta_XHp [Occ=Once] :: Monad m_ae4pF)
                 _ [Occ=Dead]
                 (eta2_B1 [Occ=Once] :: a_ae4n0 :~~: b_ae4n1) ->
                 case GHC.Types.heq_sel
                        @ i_ae4mY @ j_ae4mZ @ a_ae4n0 @ b_ae4n1 $d~~_ae4n6
                 of co_ae6J2
                 { __DEFAULT ->
                 case GHC.Types.heq_sel
                        @ j_ae4mZ
                        @ j_ae4mZ
                        @ b_ae4n1
                        @ b_ae4n1
                        ($d~~_ae4n6
                         `cast` (((~~)
                                    (Kind co_ae6J2)
                                    <j_ae4mZ>_N
                                    (Sym (Coh (Sym co_ae6J2)
                                              (Sym (Kind co_ae6J2))) ; (Coh (Sym (Coh <b_ae4n1>_N
                                                                                      (Sym (Kind
                                                                                                co_ae6J2))))
                                                                            (Sym (Kind
                                                                                      co_ae6J2)) ; Coh <b_ae4n1>_N
                                                                                                       (Sym (Kind
                                                                                                                 co_ae6J2))))
                                    <b_ae4n1>_N)_R
                                 :: ((a_ae4n0 :: i_ae4mY) ~~ (b_ae4n1 :: j_ae4mZ) :: Constraint)
                                    ~R# ((b_ae4n1 :: j_ae4mZ)
                                         ~~ (b_ae4n1 :: j_ae4mZ) :: Constraint)))
                 of
                 { __DEFAULT ->
                 case eta2_B1
                      `cast` (((:~~:)
                                 (Kind co_ae6J2)
                                 <j_ae4mZ>_N
                                 (Sym (Coh (Sym co_ae6J2) (Sym (Kind co_ae6J2))) ; Coh <b_ae4n1>_N
                                                                                       (Sym (Kind
                                                                                                 co_ae6J2)))
                                 <b_ae4n1>_N)_R
                              :: (a_ae4n0 :~~: b_ae4n1 :: *) ~R# (b_ae4n1 :~~: b_ae4n1 :: *))
                 of
                 { HRefl _ [Occ=Dead] _ [Occ=Dead] ->
                 (return
                    @ m_ae4pF
                    eta_XHp
                    @ (b_ae4n1 :~~: b_ae4n1)
                    (Data.Type.Equality.$WHRefl @ j_ae4mZ @ b_ae4n1))
                 `cast` (<m_ae4pF>_R ((:~~:)
                                        (Sym (Kind co_ae6J2))
                                        <j_ae4mZ>_N
                                        (Sym (Coh <b_ae4n1>_N
                                                  (Sym (Kind co_ae6J2))) ; Coh (Sym co_ae6J2)
                                                                               (Sym (Kind
                                                                                         co_ae6J2)))
                                        <b_ae4n1>_N)_N
                         :: (m_ae4pF (b_ae4n1 :~~: b_ae4n1) :: *)
                            ~R# (m_ae4pF (a_ae4n0 :~~: b_ae4n1) :: *))
                 }
                 }
                 }}]
Data.Data.$fData:~~:_$cgmapM
  = \ (@ i_ae4mY)
      (@ j_ae4mZ)
      (@ (a_ae4n0 :: i_ae4mY))
      (@ (b_ae4n1 :: j_ae4mZ))
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      ($d~~_ae4n6 :: (a_ae4n0 :: i_ae4mY) ~~ (b_ae4n1 :: j_ae4mZ))
      (@ (m_ae4pF :: * -> *))
      (eta_XHp :: Monad m_ae4pF)
      _ [Occ=Dead]
      (eta2_B1 :: a_ae4n0 :~~: b_ae4n1) ->
      case GHC.Types.heq_sel
             @ i_ae4mY @ j_ae4mZ @ a_ae4n0 @ b_ae4n1 $d~~_ae4n6
      of co_ae6J2
      { __DEFAULT ->
      case GHC.Types.heq_sel
             @ j_ae4mZ
             @ j_ae4mZ
             @ b_ae4n1
             @ b_ae4n1
             ($d~~_ae4n6
              `cast` (((~~)
                         (Kind co_ae6J2)
                         <j_ae4mZ>_N
                         (Sym (Coh (Sym co_ae6J2)
                                   (Sym (Kind co_ae6J2))) ; (Coh (Sym (Coh <b_ae4n1>_N
                                                                           (Sym (Kind co_ae6J2))))
                                                                 (Sym (Kind
                                                                           co_ae6J2)) ; Coh <b_ae4n1>_N
                                                                                            (Sym (Kind
                                                                                                      co_ae6J2))))
                         <b_ae4n1>_N)_R
                      :: ((a_ae4n0 :: i_ae4mY) ~~ (b_ae4n1 :: j_ae4mZ) :: Constraint)
                         ~R# ((b_ae4n1 :: j_ae4mZ) ~~ (b_ae4n1 :: j_ae4mZ) :: Constraint)))
      of co1_Xe7op [Dmd=<L,A>]
      { __DEFAULT ->
      case eta2_B1
           `cast` (((:~~:)
                      (Kind co_ae6J2)
                      <j_ae4mZ>_N
                      (Sym (Coh (Sym co_ae6J2) (Sym (Kind co_ae6J2))) ; Coh <b_ae4n1>_N
                                                                            (Sym (Kind co_ae6J2)))
                      <b_ae4n1>_N)_R
                   :: (a_ae4n0 :~~: b_ae4n1 :: *) ~R# (b_ae4n1 :~~: b_ae4n1 :: *))
      of
      { HRefl co2_ae4ng [Dmd=<L,A>] co3_ae4nh [Dmd=<L,A>] ->
      (return
         @ m_ae4pF
         eta_XHp
         @ (b_ae4n1 :~~: b_ae4n1)
         (Data.Type.Equality.$WHRefl @ j_ae4mZ @ b_ae4n1))
      `cast` (<m_ae4pF>_R ((:~~:)
                             (Sym (Kind co_ae6J2))
                             <j_ae4mZ>_N
                             (Sym (Coh <b_ae4n1>_N (Sym (Kind co_ae6J2))) ; Coh (Sym co_ae6J2)
                                                                                (Sym (Kind
                                                                                          co_ae6J2)))
                             <b_ae4n1>_N)_N
              :: (m_ae4pF (b_ae4n1 :~~: b_ae4n1) :: *)
                 ~R# (m_ae4pF (a_ae4n0 :~~: b_ae4n1) :: *))
      }
      }
      }

-- RHS size: {terms: 24, types: 74, coercions: 47, joins: 0/0}
Data.Data.$fData:~~:_$cgmapQ
  :: forall i j (a :: i) (b :: j).
     (Typeable i, Typeable j, Typeable a, Typeable b,
      (a :: i) ~~ (b :: j)) =>
     forall u. (forall d. Data d => d -> u) -> (a :~~: b) -> [u]
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,A><S(S),U(U)><L,A><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=7,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ i_ae4mY)
                 (@ j_ae4mZ)
                 (@ (a_ae4n0 :: i_ae4mY))
                 (@ (b_ae4n1 :: j_ae4mZ))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 ($d~~_ae4n6 :: (a_ae4n0 :: i_ae4mY) ~~ (b_ae4n1 :: j_ae4mZ))
                 (@ u_ae4pd)
                 _ [Occ=Dead]
                 (eta1_B1 [Occ=Once] :: a_ae4n0 :~~: b_ae4n1) ->
                 case GHC.Types.heq_sel
                        @ i_ae4mY @ j_ae4mZ @ a_ae4n0 @ b_ae4n1 $d~~_ae4n6
                 of co_ae6J2
                 { __DEFAULT ->
                 case GHC.Types.heq_sel
                        @ j_ae4mZ
                        @ j_ae4mZ
                        @ b_ae4n1
                        @ b_ae4n1
                        ($d~~_ae4n6
                         `cast` (((~~)
                                    (Kind co_ae6J2)
                                    <j_ae4mZ>_N
                                    (Sym (Coh (Sym co_ae6J2)
                                              (Sym (Kind co_ae6J2))) ; (Coh (Sym (Coh <b_ae4n1>_N
                                                                                      (Sym (Kind
                                                                                                co_ae6J2))))
                                                                            (Sym (Kind
                                                                                      co_ae6J2)) ; Coh <b_ae4n1>_N
                                                                                                       (Sym (Kind
                                                                                                                 co_ae6J2))))
                                    <b_ae4n1>_N)_R
                                 :: ((a_ae4n0 :: i_ae4mY) ~~ (b_ae4n1 :: j_ae4mZ) :: Constraint)
                                    ~R# ((b_ae4n1 :: j_ae4mZ)
                                         ~~ (b_ae4n1 :: j_ae4mZ) :: Constraint)))
                 of
                 { __DEFAULT ->
                 case GHC.Types.heq_sel
                        @ j_ae4mZ
                        @ j_ae4mZ
                        @ b_ae4n1
                        @ b_ae4n1
                        ($d~~_ae4n6
                         `cast` (((~~)
                                    (Kind co_ae6J2)
                                    <j_ae4mZ>_N
                                    (Sym (Coh (Sym co_ae6J2)
                                              (Sym (Kind co_ae6J2))) ; (Coh (Sym (Coh <b_ae4n1>_N
                                                                                      (Sym (Kind
                                                                                                co_ae6J2))))
                                                                            (Sym (Kind
                                                                                      co_ae6J2)) ; Coh <b_ae4n1>_N
                                                                                                       (Sym (Kind
                                                                                                                 co_ae6J2))))
                                    <b_ae4n1>_N)_R
                                 :: ((a_ae4n0 :: i_ae4mY) ~~ (b_ae4n1 :: j_ae4mZ) :: Constraint)
                                    ~R# ((b_ae4n1 :: j_ae4mZ)
                                         ~~ (b_ae4n1 :: j_ae4mZ) :: Constraint)))
                 of
                 { __DEFAULT ->
                 case eta1_B1
                      `cast` (((:~~:)
                                 (Kind co_ae6J2)
                                 <j_ae4mZ>_N
                                 (Sym (Coh (Sym co_ae6J2) (Sym (Kind co_ae6J2))) ; Coh <b_ae4n1>_N
                                                                                       (Sym (Kind
                                                                                                 co_ae6J2)))
                                 <b_ae4n1>_N)_R
                              :: (a_ae4n0 :~~: b_ae4n1 :: *) ~R# (b_ae4n1 :~~: b_ae4n1 :: *))
                 of
                 { HRefl _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.[] @ u_ae4pd
                 }
                 }
                 }
                 }}]
Data.Data.$fData:~~:_$cgmapQ
  = \ (@ i_ae4mY)
      (@ j_ae4mZ)
      (@ (a_ae4n0 :: i_ae4mY))
      (@ (b_ae4n1 :: j_ae4mZ))
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      ($d~~_ae4n6 :: (a_ae4n0 :: i_ae4mY) ~~ (b_ae4n1 :: j_ae4mZ))
      (@ u_ae4pd)
      _ [Occ=Dead]
      (eta1_B1 :: a_ae4n0 :~~: b_ae4n1) ->
      case GHC.Types.heq_sel
             @ i_ae4mY @ j_ae4mZ @ a_ae4n0 @ b_ae4n1 $d~~_ae4n6
      of co_ae6J2
      { __DEFAULT ->
      case GHC.Types.heq_sel
             @ j_ae4mZ
             @ j_ae4mZ
             @ b_ae4n1
             @ b_ae4n1
             ($d~~_ae4n6
              `cast` (((~~)
                         (Kind co_ae6J2)
                         <j_ae4mZ>_N
                         (Sym (Coh (Sym co_ae6J2)
                                   (Sym (Kind co_ae6J2))) ; (Coh (Sym (Coh <b_ae4n1>_N
                                                                           (Sym (Kind co_ae6J2))))
                                                                 (Sym (Kind
                                                                           co_ae6J2)) ; Coh <b_ae4n1>_N
                                                                                            (Sym (Kind
                                                                                                      co_ae6J2))))
                         <b_ae4n1>_N)_R
                      :: ((a_ae4n0 :: i_ae4mY) ~~ (b_ae4n1 :: j_ae4mZ) :: Constraint)
                         ~R# ((b_ae4n1 :: j_ae4mZ) ~~ (b_ae4n1 :: j_ae4mZ) :: Constraint)))
      of co1_Xe7qA [Dmd=<L,A>]
      { __DEFAULT ->
      case eta1_B1
           `cast` (((:~~:)
                      (Kind co_ae6J2)
                      <j_ae4mZ>_N
                      (Sym (Coh (Sym co_ae6J2) (Sym (Kind co_ae6J2))) ; Coh <b_ae4n1>_N
                                                                            (Sym (Kind co_ae6J2)))
                      <b_ae4n1>_N)_R
                   :: (a_ae4n0 :~~: b_ae4n1 :: *) ~R# (b_ae4n1 :~~: b_ae4n1 :: *))
      of
      { HRefl co2_ae4ng [Dmd=<L,A>] co3_ae4nh [Dmd=<L,A>] ->
      GHC.Types.[] @ u_ae4pd
      }
      }
      }

-- RHS size: {terms: 161, types: 499, coercions: 227, joins: 0/0}
Data.Data.$fData:~~: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i j (a :: i) (b :: j).
     (Typeable i, Typeable j, Typeable a, Typeable b,
      (a :: i) ~~ (b :: j)) =>
     Data (a :~~: b)
[GblId[DFunId],
 Arity=5,
 Str=<L,U><L,A><L,U><L,A><L,U(U)>,
 Unf=DFun: \ (@ i_ae1Xo)
             (@ j_ae1Xp)
             (@ (a_ae1Xq :: i_ae1Xo))
             (@ (b_ae1Xr :: j_ae1Xp))
             (v_XHr :: Typeable i_ae1Xo)
             (v1_XHt :: Typeable j_ae1Xp)
             (v2_XHv :: Typeable a_ae1Xq)
             (v3_XHx :: Typeable b_ae1Xr)
             (v4_B5 :: (a_ae1Xq :: i_ae1Xo) ~~ (b_ae1Xr :: j_ae1Xp)) ->
       Data.Data.C:Data TYPE: a_ae1Xq :~~: b_ae1Xr
                        Data.Data.$fData:~~:_$cp1Data
                          @ i_ae1Xo
                          @ j_ae1Xp
                          @ a_ae1Xq
                          @ b_ae1Xr
                          v_XHr
                          v1_XHt
                          v2_XHv
                          v3_XHx
                          v4_B5
                        \ (@ (c_ae4ne :: * -> *))
                          _ [Occ=Dead]
                          (eta1_X1jS [Occ=Once!] :: forall g. g -> c_ae4ne g)
                          (eta2_X1jT [Occ=Once!] :: a_ae1Xq :~~: b_ae1Xr) ->
                          case GHC.Types.heq_sel
                                 @ i_ae1Xo @ j_ae1Xp @ a_ae1Xq @ b_ae1Xr v4_B5
                          of co_ae6J2
                          { __DEFAULT ->
                          case eta2_X1jT of { HRefl _ [Occ=Dead] _ [Occ=Dead] ->
                          (eta1_X1jS
                             @ (a_ae1Xq :~~: a_ae1Xq)
                             (Data.Type.Equality.$WHRefl @ i_ae1Xo @ a_ae1Xq))
                          `cast` (<c_ae4ne>_R ((:~~:)
                                                 <i_ae1Xo>_N
                                                 (Kind co_ae6J2)
                                                 <a_ae1Xq>_N
                                                 (Sym (Coh (Sym co_ae6J2)
                                                           (Sym (Kind co_ae6J2))) ; Coh <b_ae1Xr>_N
                                                                                        (Sym (Kind
                                                                                                  co_ae6J2))))_N
                                  :: (c_ae4ne (a_ae1Xq :~~: a_ae1Xq) :: *)
                                     ~R# (c_ae4ne (a_ae1Xq :~~: b_ae1Xr) :: *))
                          }
                          }
                        \ (@ (c_ae4ns :: * -> *))
                          _ [Occ=Dead]
                          (eta1_X1p8 [Occ=Once!] :: forall r. r -> c_ae4ns r)
                          _ [Occ=Dead] ->
                          case GHC.Types.heq_sel
                                 @ i_ae1Xo @ j_ae1Xp @ a_ae1Xq @ b_ae1Xr v4_B5
                          of co_ae6J2
                          { __DEFAULT ->
                          (eta1_X1p8
                             @ (a_ae1Xq :~~: a_ae1Xq)
                             (Data.Type.Equality.$WHRefl @ i_ae1Xo @ a_ae1Xq))
                          `cast` (<c_ae4ns>_R ((:~~:)
                                                 <i_ae1Xo>_N
                                                 (Kind co_ae6J2)
                                                 <a_ae1Xq>_N
                                                 (Sym (Coh (Sym co_ae6J2)
                                                           (Sym (Kind co_ae6J2))) ; Coh <b_ae1Xr>_N
                                                                                        (Sym (Kind
                                                                                                  co_ae6J2))))_N
                                  :: (c_ae4ns (a_ae1Xq :~~: a_ae1Xq) :: *)
                                     ~R# (c_ae4ns (a_ae1Xq :~~: b_ae1Xr) :: *))
                          }
                        \ (eta_XEU [Occ=Once!] :: a_ae1Xq :~~: b_ae1Xr) ->
                          case GHC.Types.heq_sel
                                 @ i_ae1Xo @ j_ae1Xp @ a_ae1Xq @ b_ae1Xr v4_B5
                          of
                          { __DEFAULT ->
                          case eta_XEU of { HRefl _ [Occ=Dead] _ [Occ=Dead] ->
                          Data.Data.$cHRefl
                          }
                          }
                        \ _ [Occ=Dead] ->
                          case GHC.Types.heq_sel
                                 @ i_ae1Xo @ j_ae1Xp @ a_ae1Xq @ b_ae1Xr v4_B5
                          of
                          { __DEFAULT ->
                          Data.Data.$t:~~:
                          }
                        \ (@ (t_ae4nO :: * -> *))
                          (@ (c_ae4nP :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          case GHC.Types.heq_sel
                                 @ i_ae1Xo @ j_ae1Xp @ a_ae1Xq @ b_ae1Xr v4_B5
                          of
                          { __DEFAULT ->
                          GHC.Base.Nothing @ (c_ae4nP (a_ae1Xq :~~: b_ae1Xr))
                          }
                        \ (@ (t_ae4o7 :: * -> * -> *))
                          (@ (c_ae4o8 :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          case GHC.Types.heq_sel
                                 @ i_ae1Xo @ j_ae1Xp @ a_ae1Xq @ b_ae1Xr v4_B5
                          of
                          { __DEFAULT ->
                          GHC.Base.Nothing @ (c_ae4o8 (a_ae1Xq :~~: b_ae1Xr))
                          }
                        \ _ [Occ=Dead] (eta1_B1 [Occ=Once] :: a_ae1Xq :~~: b_ae1Xr) ->
                          case GHC.Types.heq_sel
                                 @ i_ae1Xo @ j_ae1Xp @ a_ae1Xq @ b_ae1Xr v4_B5
                          of co_ae6J2
                          { __DEFAULT ->
                          case GHC.Types.heq_sel
                                 @ j_ae1Xp
                                 @ j_ae1Xp
                                 @ b_ae1Xr
                                 @ b_ae1Xr
                                 (v4_B5
                                  `cast` (((~~)
                                             (Kind co_ae6J2)
                                             <j_ae1Xp>_N
                                             (Sym (Coh (Sym co_ae6J2)
                                                       (Sym (Kind
                                                                 co_ae6J2))) ; (Coh (Sym (Coh <b_ae1Xr>_N
                                                                                              (Sym (Kind
                                                                                                        co_ae6J2))))
                                                                                    (Sym (Kind
                                                                                              co_ae6J2)) ; Coh <b_ae1Xr>_N
                                                                                                               (Sym (Kind
                                                                                                                         co_ae6J2))))
                                             <b_ae1Xr>_N)_R
                                          :: ((a_ae1Xq :: i_ae1Xo)
                                              ~~ (b_ae1Xr :: j_ae1Xp) :: Constraint)
                                             ~R# ((b_ae1Xr :: j_ae1Xp)
                                                  ~~ (b_ae1Xr :: j_ae1Xp) :: Constraint)))
                          of
                          { __DEFAULT ->
                          case eta1_B1
                               `cast` (((:~~:)
                                          (Kind co_ae6J2)
                                          <j_ae1Xp>_N
                                          (Sym (Coh (Sym co_ae6J2)
                                                    (Sym (Kind co_ae6J2))) ; Coh <b_ae1Xr>_N
                                                                                 (Sym (Kind
                                                                                           co_ae6J2)))
                                          <b_ae1Xr>_N)_R
                                       :: (a_ae1Xq :~~: b_ae1Xr :: *)
                                          ~R# (b_ae1Xr :~~: b_ae1Xr :: *))
                          of
                          { HRefl _ [Occ=Dead] _ [Occ=Dead] ->
                          (Data.Type.Equality.$WHRefl @ j_ae1Xp @ b_ae1Xr)
                          `cast` (((:~~:)
                                     (Sym (Kind co_ae6J2))
                                     <j_ae1Xp>_N
                                     (Sym (Coh <b_ae1Xr>_N
                                               (Sym (Kind co_ae6J2))) ; Coh (Sym co_ae6J2)
                                                                            (Sym (Kind co_ae6J2)))
                                     <b_ae1Xr>_N)_R
                                  :: (b_ae1Xr :~~: b_ae1Xr :: *) ~R# (a_ae1Xq :~~: b_ae1Xr :: *))
                          }
                          }
                          }
                        \ (@ r_ae4oF)
                          (@ r'_ae4oG)
                          _ [Occ=Dead]
                          (eta1_B3 [Occ=Once] :: r_ae4oF)
                          _ [Occ=Dead]
                          (eta3_B1 [Occ=Once] :: a_ae1Xq :~~: b_ae1Xr) ->
                          case GHC.Types.heq_sel
                                 @ i_ae1Xo @ j_ae1Xp @ a_ae1Xq @ b_ae1Xr v4_B5
                          of co_ae6J2
                          { __DEFAULT ->
                          case GHC.Types.heq_sel
                                 @ j_ae1Xp
                                 @ j_ae1Xp
                                 @ b_ae1Xr
                                 @ b_ae1Xr
                                 (v4_B5
                                  `cast` (((~~)
                                             (Kind co_ae6J2)
                                             <j_ae1Xp>_N
                                             (Sym (Coh (Sym co_ae6J2)
                                                       (Sym (Kind
                                                                 co_ae6J2))) ; (Coh (Sym (Coh <b_ae1Xr>_N
                                                                                              (Sym (Kind
                                                                                                        co_ae6J2))))
                                                                                    (Sym (Kind
                                                                                              co_ae6J2)) ; Coh <b_ae1Xr>_N
                                                                                                               (Sym (Kind
                                                                                                                         co_ae6J2))))
                                             <b_ae1Xr>_N)_R
                                          :: ((a_ae1Xq :: i_ae1Xo)
                                              ~~ (b_ae1Xr :: j_ae1Xp) :: Constraint)
                                             ~R# ((b_ae1Xr :: j_ae1Xp)
                                                  ~~ (b_ae1Xr :: j_ae1Xp) :: Constraint)))
                          of
                          { __DEFAULT ->
                          case eta3_B1
                               `cast` (((:~~:)
                                          (Kind co_ae6J2)
                                          <j_ae1Xp>_N
                                          (Sym (Coh (Sym co_ae6J2)
                                                    (Sym (Kind co_ae6J2))) ; Coh <b_ae1Xr>_N
                                                                                 (Sym (Kind
                                                                                           co_ae6J2)))
                                          <b_ae1Xr>_N)_R
                                       :: (a_ae1Xq :~~: b_ae1Xr :: *)
                                          ~R# (b_ae1Xr :~~: b_ae1Xr :: *))
                          of
                          { HRefl _ [Occ=Dead] _ [Occ=Dead] ->
                          eta1_B3
                          }
                          }
                          }
                        \ (@ r_ae4oW)
                          (@ r'_ae4oX)
                          _ [Occ=Dead]
                          (eta1_X1pb [Occ=Once] :: r_ae4oW)
                          _ [Occ=Dead]
                          (eta3_X1pd [Occ=Once] :: a_ae1Xq :~~: b_ae1Xr) ->
                          case GHC.Types.heq_sel
                                 @ i_ae1Xo @ j_ae1Xp @ a_ae1Xq @ b_ae1Xr v4_B5
                          of co_ae6J2
                          { __DEFAULT ->
                          case GHC.Types.heq_sel
                                 @ j_ae1Xp
                                 @ j_ae1Xp
                                 @ b_ae1Xr
                                 @ b_ae1Xr
                                 (v4_B5
                                  `cast` (((~~)
                                             (Kind co_ae6J2)
                                             <j_ae1Xp>_N
                                             (Sym (Coh (Sym co_ae6J2)
                                                       (Sym (Kind
                                                                 co_ae6J2))) ; (Coh (Sym (Coh <b_ae1Xr>_N
                                                                                              (Sym (Kind
                                                                                                        co_ae6J2))))
                                                                                    (Sym (Kind
                                                                                              co_ae6J2)) ; Coh <b_ae1Xr>_N
                                                                                                               (Sym (Kind
                                                                                                                         co_ae6J2))))
                                             <b_ae1Xr>_N)_R
                                          :: ((a_ae1Xq :: i_ae1Xo)
                                              ~~ (b_ae1Xr :: j_ae1Xp) :: Constraint)
                                             ~R# ((b_ae1Xr :: j_ae1Xp)
                                                  ~~ (b_ae1Xr :: j_ae1Xp) :: Constraint)))
                          of
                          { __DEFAULT ->
                          case eta3_X1pd
                               `cast` (((:~~:)
                                          (Kind co_ae6J2)
                                          <j_ae1Xp>_N
                                          (Sym (Coh (Sym co_ae6J2)
                                                    (Sym (Kind co_ae6J2))) ; Coh <b_ae1Xr>_N
                                                                                 (Sym (Kind
                                                                                           co_ae6J2)))
                                          <b_ae1Xr>_N)_R
                                       :: (a_ae1Xq :~~: b_ae1Xr :: *)
                                          ~R# (b_ae1Xr :~~: b_ae1Xr :: *))
                          of
                          { HRefl _ [Occ=Dead] _ [Occ=Dead] ->
                          eta1_X1pb
                          }
                          }
                          }
                        Data.Data.$fData:~~:_$cgmapQ
                          @ i_ae1Xo
                          @ j_ae1Xp
                          @ a_ae1Xq
                          @ b_ae1Xr
                          v_XHr
                          v1_XHt
                          v2_XHv
                          v3_XHx
                          v4_B5
                        \ (@ u_ae4pr)
                          _ [Occ=Dead]
                          _ [Occ=Dead]
                          (eta2_B1 [Occ=Once] :: a_ae1Xq :~~: b_ae1Xr) ->
                          case GHC.Types.heq_sel
                                 @ i_ae1Xo @ j_ae1Xp @ a_ae1Xq @ b_ae1Xr v4_B5
                          of co_ae6J2
                          { __DEFAULT ->
                          case GHC.Types.heq_sel
                                 @ j_ae1Xp
                                 @ j_ae1Xp
                                 @ b_ae1Xr
                                 @ b_ae1Xr
                                 (v4_B5
                                  `cast` (((~~)
                                             (Kind co_ae6J2)
                                             <j_ae1Xp>_N
                                             (Sym (Coh (Sym co_ae6J2)
                                                       (Sym (Kind
                                                                 co_ae6J2))) ; (Coh (Sym (Coh <b_ae1Xr>_N
                                                                                              (Sym (Kind
                                                                                                        co_ae6J2))))
                                                                                    (Sym (Kind
                                                                                              co_ae6J2)) ; Coh <b_ae1Xr>_N
                                                                                                               (Sym (Kind
                                                                                                                         co_ae6J2))))
                                             <b_ae1Xr>_N)_R
                                          :: ((a_ae1Xq :: i_ae1Xo)
                                              ~~ (b_ae1Xr :: j_ae1Xp) :: Constraint)
                                             ~R# ((b_ae1Xr :: j_ae1Xp)
                                                  ~~ (b_ae1Xr :: j_ae1Xp) :: Constraint)))
                          of
                          { __DEFAULT ->
                          case eta2_B1
                               `cast` (((:~~:)
                                          (Kind co_ae6J2)
                                          <j_ae1Xp>_N
                                          (Sym (Coh (Sym co_ae6J2)
                                                    (Sym (Kind co_ae6J2))) ; Coh <b_ae1Xr>_N
                                                                                 (Sym (Kind
                                                                                           co_ae6J2)))
                                          <b_ae1Xr>_N)_R
                                       :: (a_ae1Xq :~~: b_ae1Xr :: *)
                                          ~R# (b_ae1Xr :~~: b_ae1Xr :: *))
                          of
                          { HRefl _ [Occ=Dead] _ [Occ=Dead] ->
                          Data.Maybe.fromJust1 @ u_ae4pr
                          }
                          }
                          }
                        Data.Data.$fData:~~:_$cgmapM
                          @ i_ae1Xo
                          @ j_ae1Xp
                          @ a_ae1Xq
                          @ b_ae1Xr
                          v_XHr
                          v1_XHt
                          v2_XHv
                          v3_XHx
                          v4_B5
                        Data.Data.$fData:~~:_$cgmapMp
                          @ i_ae1Xo
                          @ j_ae1Xp
                          @ a_ae1Xq
                          @ b_ae1Xr
                          v_XHr
                          v1_XHt
                          v2_XHv
                          v3_XHx
                          v4_B5
                        Data.Data.$fData:~~:_$cgmapMp
                          @ i_ae1Xo
                          @ j_ae1Xp
                          @ a_ae1Xq
                          @ b_ae1Xr
                          v_XHr
                          v1_XHt
                          v2_XHv
                          v3_XHx
                          v4_B5]
Data.Data.$fData:~~:
  = \ (@ i_ae4mY)
      (@ j_ae4mZ)
      (@ (a_ae4n0 :: i_ae4mY))
      (@ (b_ae4n1 :: j_ae4mZ))
      ($dTypeable_ae4n2 :: Typeable i_ae4mY)
      ($dTypeable1_ae4n3 :: Typeable j_ae4mZ)
      ($dTypeable2_ae4n4 :: Typeable a_ae4n0)
      ($dTypeable3_ae4n5 :: Typeable b_ae4n1)
      ($d~~_ae4n6 :: (a_ae4n0 :: i_ae4mY) ~~ (b_ae4n1 :: j_ae4mZ)) ->
      Data.Data.C:Data
        @ (a_ae4n0 :~~: b_ae4n1)
        (Data.Data.$w$cp1Data
           @ i_ae4mY
           @ j_ae4mZ
           @ a_ae4n0
           @ b_ae4n1
           $dTypeable_ae4n2
           $dTypeable2_ae4n4
           $d~~_ae4n6)
        (\ (@ (c_ae4ne :: * -> *))
           _ [Occ=Dead]
           (eta1_X1p6 :: forall g. g -> c_ae4ne g)
           (eta2_X1p7 :: a_ae4n0 :~~: b_ae4n1) ->
           case GHC.Types.heq_sel
                  @ i_ae4mY @ j_ae4mZ @ a_ae4n0 @ b_ae4n1 $d~~_ae4n6
           of co_ae6J2
           { __DEFAULT ->
           case eta2_X1p7 of
           { HRefl co1_ae4ng [Dmd=<L,A>] co2_ae4nh [Dmd=<L,A>] ->
           (eta1_X1p6
              @ (a_ae4n0 :~~: a_ae4n0)
              (Data.Type.Equality.$WHRefl @ i_ae4mY @ a_ae4n0))
           `cast` (<c_ae4ne>_R ((:~~:)
                                  <i_ae4mY>_N
                                  (Kind co_ae6J2)
                                  <a_ae4n0>_N
                                  (Sym (Coh (Sym co_ae6J2) (Sym (Kind co_ae6J2))) ; Coh <b_ae4n1>_N
                                                                                        (Sym (Kind
                                                                                                  co_ae6J2))))_N
                   :: (c_ae4ne (a_ae4n0 :~~: a_ae4n0) :: *)
                      ~R# (c_ae4ne (a_ae4n0 :~~: b_ae4n1) :: *))
           }
           })
        (\ (@ (c_ae4ns :: * -> *))
           _ [Occ=Dead]
           (eta1_X1p8 :: forall r. r -> c_ae4ns r)
           _ [Occ=Dead] ->
           case GHC.Types.heq_sel
                  @ i_ae4mY @ j_ae4mZ @ a_ae4n0 @ b_ae4n1 $d~~_ae4n6
           of co_ae6J2
           { __DEFAULT ->
           (eta1_X1p8
              @ (a_ae4n0 :~~: a_ae4n0)
              (Data.Type.Equality.$WHRefl @ i_ae4mY @ a_ae4n0))
           `cast` (<c_ae4ns>_R ((:~~:)
                                  <i_ae4mY>_N
                                  (Kind co_ae6J2)
                                  <a_ae4n0>_N
                                  (Sym (Coh (Sym co_ae6J2) (Sym (Kind co_ae6J2))) ; Coh <b_ae4n1>_N
                                                                                        (Sym (Kind
                                                                                                  co_ae6J2))))_N
                   :: (c_ae4ns (a_ae4n0 :~~: a_ae4n0) :: *)
                      ~R# (c_ae4ns (a_ae4n0 :~~: b_ae4n1) :: *))
           })
        (\ (eta_XHw :: a_ae4n0 :~~: b_ae4n1) ->
           case GHC.Types.heq_sel
                  @ i_ae4mY @ j_ae4mZ @ a_ae4n0 @ b_ae4n1 $d~~_ae4n6
           of co_ae6J2 [Dmd=<L,A>]
           { __DEFAULT ->
           case eta_XHw of
           { HRefl co1_ae4nE [Dmd=<L,A>] co2_ae4nF [Dmd=<L,A>] ->
           Data.Data.$cHRefl
           }
           })
        (\ _ [Occ=Dead] ->
           case GHC.Types.heq_sel
                  @ i_ae4mY @ j_ae4mZ @ a_ae4n0 @ b_ae4n1 $d~~_ae4n6
           of co_ae6J2 [Dmd=<L,A>]
           { __DEFAULT ->
           Data.Data.$t:~~:
           })
        (\ (@ (t_ae4nO :: * -> *))
           (@ (c_ae4nP :: * -> *))
           _ [Occ=Dead]
           _ [Occ=Dead] ->
           case GHC.Types.heq_sel
                  @ i_ae4mY @ j_ae4mZ @ a_ae4n0 @ b_ae4n1 $d~~_ae4n6
           of co_ae6J2 [Dmd=<L,A>]
           { __DEFAULT ->
           GHC.Base.Nothing @ (c_ae4nP (a_ae4n0 :~~: b_ae4n1))
           })
        (\ (@ (t_ae4o7 :: * -> * -> *))
           (@ (c_ae4o8 :: * -> *))
           _ [Occ=Dead]
           _ [Occ=Dead] ->
           case GHC.Types.heq_sel
                  @ i_ae4mY @ j_ae4mZ @ a_ae4n0 @ b_ae4n1 $d~~_ae4n6
           of co_ae6J2 [Dmd=<L,A>]
           { __DEFAULT ->
           GHC.Base.Nothing @ (c_ae4o8 (a_ae4n0 :~~: b_ae4n1))
           })
        (\ _ [Occ=Dead] (eta1_B1 :: a_ae4n0 :~~: b_ae4n1) ->
           case GHC.Types.heq_sel
                  @ i_ae4mY @ j_ae4mZ @ a_ae4n0 @ b_ae4n1 $d~~_ae4n6
           of co_ae6J2
           { __DEFAULT ->
           case GHC.Types.heq_sel
                  @ j_ae4mZ
                  @ j_ae4mZ
                  @ b_ae4n1
                  @ b_ae4n1
                  ($d~~_ae4n6
                   `cast` (((~~)
                              (Kind co_ae6J2)
                              <j_ae4mZ>_N
                              (Sym (Coh (Sym co_ae6J2)
                                        (Sym (Kind co_ae6J2))) ; (Coh (Sym (Coh <b_ae4n1>_N
                                                                                (Sym (Kind
                                                                                          co_ae6J2))))
                                                                      (Sym (Kind
                                                                                co_ae6J2)) ; Coh <b_ae4n1>_N
                                                                                                 (Sym (Kind
                                                                                                           co_ae6J2))))
                              <b_ae4n1>_N)_R
                           :: ((a_ae4n0 :: i_ae4mY) ~~ (b_ae4n1 :: j_ae4mZ) :: Constraint)
                              ~R# ((b_ae4n1 :: j_ae4mZ) ~~ (b_ae4n1 :: j_ae4mZ) :: Constraint)))
           of co1_Xe7oj [Dmd=<L,A>]
           { __DEFAULT ->
           case eta1_B1
                `cast` (((:~~:)
                           (Kind co_ae6J2)
                           <j_ae4mZ>_N
                           (Sym (Coh (Sym co_ae6J2) (Sym (Kind co_ae6J2))) ; Coh <b_ae4n1>_N
                                                                                 (Sym (Kind
                                                                                           co_ae6J2)))
                           <b_ae4n1>_N)_R
                        :: (a_ae4n0 :~~: b_ae4n1 :: *) ~R# (b_ae4n1 :~~: b_ae4n1 :: *))
           of
           { HRefl co2_ae4ng [Dmd=<L,A>] co3_ae4nh [Dmd=<L,A>] ->
           (Data.Type.Equality.$WHRefl @ j_ae4mZ @ b_ae4n1)
           `cast` (((:~~:)
                      (Sym (Kind co_ae6J2))
                      <j_ae4mZ>_N
                      (Sym (Coh <b_ae4n1>_N (Sym (Kind co_ae6J2))) ; Coh (Sym co_ae6J2)
                                                                         (Sym (Kind co_ae6J2)))
                      <b_ae4n1>_N)_R
                   :: (b_ae4n1 :~~: b_ae4n1 :: *) ~R# (a_ae4n0 :~~: b_ae4n1 :: *))
           }
           }
           })
        (\ (@ r_ae4oF)
           (@ r'_ae4oG)
           _ [Occ=Dead]
           (eta1_B3 :: r_ae4oF)
           _ [Occ=Dead]
           (eta3_B1 :: a_ae4n0 :~~: b_ae4n1) ->
           case GHC.Types.heq_sel
                  @ i_ae4mY @ j_ae4mZ @ a_ae4n0 @ b_ae4n1 $d~~_ae4n6
           of co_ae6J2
           { __DEFAULT ->
           case GHC.Types.heq_sel
                  @ j_ae4mZ
                  @ j_ae4mZ
                  @ b_ae4n1
                  @ b_ae4n1
                  ($d~~_ae4n6
                   `cast` (((~~)
                              (Kind co_ae6J2)
                              <j_ae4mZ>_N
                              (Sym (Coh (Sym co_ae6J2)
                                        (Sym (Kind co_ae6J2))) ; (Coh (Sym (Coh <b_ae4n1>_N
                                                                                (Sym (Kind
                                                                                          co_ae6J2))))
                                                                      (Sym (Kind
                                                                                co_ae6J2)) ; Coh <b_ae4n1>_N
                                                                                                 (Sym (Kind
                                                                                                           co_ae6J2))))
                              <b_ae4n1>_N)_R
                           :: ((a_ae4n0 :: i_ae4mY) ~~ (b_ae4n1 :: j_ae4mZ) :: Constraint)
                              ~R# ((b_ae4n1 :: j_ae4mZ) ~~ (b_ae4n1 :: j_ae4mZ) :: Constraint)))
           of co1_Xe7op [Dmd=<L,A>]
           { __DEFAULT ->
           case eta3_B1
                `cast` (((:~~:)
                           (Kind co_ae6J2)
                           <j_ae4mZ>_N
                           (Sym (Coh (Sym co_ae6J2) (Sym (Kind co_ae6J2))) ; Coh <b_ae4n1>_N
                                                                                 (Sym (Kind
                                                                                           co_ae6J2)))
                           <b_ae4n1>_N)_R
                        :: (a_ae4n0 :~~: b_ae4n1 :: *) ~R# (b_ae4n1 :~~: b_ae4n1 :: *))
           of
           { HRefl co2_ae4ng [Dmd=<L,A>] co3_ae4nh [Dmd=<L,A>] ->
           eta1_B3
           }
           }
           })
        (\ (@ r_ae4oW)
           (@ r'_ae4oX)
           _ [Occ=Dead]
           (eta1_X1pb :: r_ae4oW)
           _ [Occ=Dead]
           (eta3_X1pd :: a_ae4n0 :~~: b_ae4n1) ->
           case GHC.Types.heq_sel
                  @ i_ae4mY @ j_ae4mZ @ a_ae4n0 @ b_ae4n1 $d~~_ae4n6
           of co_ae6J2
           { __DEFAULT ->
           case GHC.Types.heq_sel
                  @ j_ae4mZ
                  @ j_ae4mZ
                  @ b_ae4n1
                  @ b_ae4n1
                  ($d~~_ae4n6
                   `cast` (((~~)
                              (Kind co_ae6J2)
                              <j_ae4mZ>_N
                              (Sym (Coh (Sym co_ae6J2)
                                        (Sym (Kind co_ae6J2))) ; (Coh (Sym (Coh <b_ae4n1>_N
                                                                                (Sym (Kind
                                                                                          co_ae6J2))))
                                                                      (Sym (Kind
                                                                                co_ae6J2)) ; Coh <b_ae4n1>_N
                                                                                                 (Sym (Kind
                                                                                                           co_ae6J2))))
                              <b_ae4n1>_N)_R
                           :: ((a_ae4n0 :: i_ae4mY) ~~ (b_ae4n1 :: j_ae4mZ) :: Constraint)
                              ~R# ((b_ae4n1 :: j_ae4mZ) ~~ (b_ae4n1 :: j_ae4mZ) :: Constraint)))
           of co1_Xe7or [Dmd=<L,A>]
           { __DEFAULT ->
           case eta3_X1pd
                `cast` (((:~~:)
                           (Kind co_ae6J2)
                           <j_ae4mZ>_N
                           (Sym (Coh (Sym co_ae6J2) (Sym (Kind co_ae6J2))) ; Coh <b_ae4n1>_N
                                                                                 (Sym (Kind
                                                                                           co_ae6J2)))
                           <b_ae4n1>_N)_R
                        :: (a_ae4n0 :~~: b_ae4n1 :: *) ~R# (b_ae4n1 :~~: b_ae4n1 :: *))
           of
           { HRefl co2_ae4ng [Dmd=<L,A>] co3_ae4nh [Dmd=<L,A>] ->
           eta1_X1pb
           }
           }
           })
        (Data.Data.$fData:~~:_$cgmapQ
           @ i_ae4mY
           @ j_ae4mZ
           @ a_ae4n0
           @ b_ae4n1
           $dTypeable_ae4n2
           $dTypeable1_ae4n3
           $dTypeable2_ae4n4
           $dTypeable3_ae4n5
           $d~~_ae4n6)
        (\ (@ u_ae4pr) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
           case GHC.Types.heq_sel
                  @ i_ae4mY @ j_ae4mZ @ a_ae4n0 @ b_ae4n1 $d~~_ae4n6
           of co_ae6J2 [Dmd=<B,U>]
           { __DEFAULT ->
           case GHC.Types.heq_sel
                  @ j_ae4mZ
                  @ j_ae4mZ
                  @ b_ae4n1
                  @ b_ae4n1
                  ($d~~_ae4n6
                   `cast` (((~~)
                              (Kind co_ae6J2)
                              <j_ae4mZ>_N
                              (Sym (Coh (Sym co_ae6J2)
                                        (Sym (Kind co_ae6J2))) ; (Coh (Sym (Coh <b_ae4n1>_N
                                                                                (Sym (Kind
                                                                                          co_ae6J2))))
                                                                      (Sym (Kind
                                                                                co_ae6J2)) ; Coh <b_ae4n1>_N
                                                                                                 (Sym (Kind
                                                                                                           co_ae6J2))))
                              <b_ae4n1>_N)_R
                           :: ((a_ae4n0 :: i_ae4mY) ~~ (b_ae4n1 :: j_ae4mZ) :: Constraint)
                              ~R# ((b_ae4n1 :: j_ae4mZ) ~~ (b_ae4n1 :: j_ae4mZ) :: Constraint)))
           of co1_Xe7oq [Dmd=<B,A>]
           { __DEFAULT ->
           Data.Maybe.fromJust1 @ u_ae4pr
           }
           })
        (Data.Data.$fData:~~:_$cgmapM
           @ i_ae4mY
           @ j_ae4mZ
           @ a_ae4n0
           @ b_ae4n1
           $dTypeable_ae4n2
           $dTypeable1_ae4n3
           $dTypeable2_ae4n4
           $dTypeable3_ae4n5
           $d~~_ae4n6)
        (\ (@ (m_segpE :: * -> *))
           (w_segpF :: MonadPlus m_segpE)
           _ [Occ=Dead]
           (w2_segpH :: a_ae4n0 :~~: b_ae4n1) ->
           Data.Data.$w$cgmapMp5
             @ i_ae4mY
             @ j_ae4mZ
             @ a_ae4n0
             @ b_ae4n1
             $d~~_ae4n6
             @ m_segpE
             w_segpF
             w2_segpH)
        (\ (@ (m_segpS :: * -> *))
           (w_segpT :: MonadPlus m_segpS)
           _ [Occ=Dead]
           (w2_segpV :: a_ae4n0 :~~: b_ae4n1) ->
           Data.Data.$w$cgmapMp5
             @ i_ae4mY
             @ j_ae4mZ
             @ a_ae4n0
             @ b_ae4n1
             $d~~_ae4n6
             @ m_segpS
             w_segpT
             w2_segpV)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataCoercion4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fDataCoercion4 = "Coercion"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataCoercion3 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataCoercion3
  = unpackCString# Data.Data.$fDataCoercion4

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go23_rejQV :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go23_rejQV
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fDataCoercion3 of {
                False -> go23_rejQV ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cCoercion1_rejQW :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cCoercion1_rejQW = Data.Data.AlgConstr $cCoercion2_rejQX

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataCoercion2 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataCoercion2
  = GHC.Types.: @ Constr Data.Data.$cCoercion (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataCoercion1 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataCoercion1
  = Data.Data.AlgRep Data.Data.$fDataCoercion2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tCoercion :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$tCoercion
  = Data.Data.DataType
      Data.Data.$fDataCoercion3 Data.Data.$fDataCoercion1

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cCoercion [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cCoercion
  = Data.Data.Constr
      $cCoercion1_rejQW
      Data.Data.$fDataCoercion3
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tCoercion

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cCoercion2_rejQX :: ConIndex
[GblId]
$cCoercion2_rejQX
  = go23_rejQV Data.Data.$fDataCoercion2 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 35, types: 103, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp12 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Coercible a b =>
     forall (m :: * -> *).
     MonadPlus m =>
     Coercion a b -> m (Coercion a b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*H>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 60 20] 230 0}]
Data.Data.$w$cgmapMp12
  = \ (@ a_segpZ)
      (@ b_segq0)
      (w_segq1 :: Coercible a_segpZ b_segq0)
      (@ (m_segq4 :: * -> *))
      (w1_segq5 :: MonadPlus m_segq4)
      (w2_segq7 :: Coercion a_segpZ b_segq0) ->
      let {
        lvl270_se9Ln :: m_segq4 (Coercion a_segpZ b_segq0)
        [LclId]
        lvl270_se9Ln
          = mzero @ m_segq4 w1_segq5 @ (Coercion a_segpZ b_segq0) } in
      let {
        $dMonad_se9rt [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_segq4
        [LclId]
        $dMonad_se9rt = GHC.Base.$p2MonadPlus @ m_segq4 w1_segq5 } in
      >>=
        @ m_segq4
        $dMonad_se9rt
        @ (Coercion a_segpZ b_segq0, Bool)
        @ (Coercion a_segpZ b_segq0)
        (case w2_segq7 of { Coercion $dCoercible_ae4jQ ->
         return
           @ m_segq4
           $dMonad_se9rt
           @ (Coercion a_segpZ b_segq0, Bool)
           (Data.Type.Coercion.Coercion @ * @ a_segpZ @ b_segq0 w_segq1,
            GHC.Types.False)
         })
        (\ (ds_de7oa :: (Coercion a_segpZ b_segq0, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b1_ae1TE) ->
           case b1_ae1TE of {
             False -> lvl270_se9Ln;
             True ->
               return
                 @ m_segq4 $dMonad_se9rt @ (Coercion a_segpZ b_segq0) x'_ae1TD
           }
           })

-- RHS size: {terms: 13, types: 34, coercions: 0, joins: 0/0}
Data.Data.$fDataCoercion_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Coercible a b, Data a, Data b) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Coercion a b -> m (Coercion a b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,A><L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_segpZ)
                 (@ b_segq0)
                 (w_segq1 [Occ=Once] :: Coercible a_segpZ b_segq0)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (@ (m_segq4 :: * -> *))
                 (w3_segq5 [Occ=Once] :: MonadPlus m_segq4)
                 _ [Occ=Dead]
                 (w5_segq7 [Occ=Once] :: Coercion a_segpZ b_segq0) ->
                 Data.Data.$w$cgmapMp12
                   @ a_segpZ @ b_segq0 w_segq1 @ m_segq4 w3_segq5 w5_segq7}]
Data.Data.$fDataCoercion_$cgmapMp
  = \ (@ a_segpZ)
      (@ b_segq0)
      (w_segq1 :: Coercible a_segpZ b_segq0)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (@ (m_segq4 :: * -> *))
      (w3_segq5 :: MonadPlus m_segq4)
      _ [Occ=Dead]
      (w5_segq7 :: Coercion a_segpZ b_segq0) ->
      Data.Data.$w$cgmapMp12
        @ a_segpZ @ b_segq0 w_segq1 @ m_segq4 w3_segq5 w5_segq7

-- RHS size: {terms: 35, types: 103, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo11 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     Coercible a b =>
     forall (m :: * -> *).
     MonadPlus m =>
     Coercion a b -> m (Coercion a b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*H>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 60 20] 230 0}]
Data.Data.$w$cgmapMo11
  = \ (@ a_segq9)
      (@ b_segqa)
      (w_segqb :: Coercible a_segq9 b_segqa)
      (@ (m_segqe :: * -> *))
      (w1_segqf :: MonadPlus m_segqe)
      (w2_segqh :: Coercion a_segq9 b_segqa) ->
      let {
        lvl270_se9Lo :: m_segqe (Coercion a_segq9 b_segqa)
        [LclId]
        lvl270_se9Lo
          = mzero @ m_segqe w1_segqf @ (Coercion a_segq9 b_segqa) } in
      let {
        $dMonad_se9rr [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_segqe
        [LclId]
        $dMonad_se9rr = GHC.Base.$p2MonadPlus @ m_segqe w1_segqf } in
      >>=
        @ m_segqe
        $dMonad_se9rr
        @ (Coercion a_segq9 b_segqa, Bool)
        @ (Coercion a_segq9 b_segqa)
        (case w2_segqh of { Coercion $dCoercible_ae4jQ ->
         return
           @ m_segqe
           $dMonad_se9rr
           @ (Coercion a_segq9 b_segqa, Bool)
           (Data.Type.Coercion.Coercion @ * @ a_segq9 @ b_segqa w_segqb,
            GHC.Types.False)
         })
        (\ (ds_de7pa :: (Coercion a_segq9 b_segqa, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b1_ae1TT) ->
           case b1_ae1TT of {
             False -> lvl270_se9Lo;
             True ->
               return
                 @ m_segqe $dMonad_se9rr @ (Coercion a_segq9 b_segqa) x'_ae1TS
           }
           })

-- RHS size: {terms: 13, types: 34, coercions: 0, joins: 0/0}
Data.Data.$fDataCoercion_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Coercible a b, Data a, Data b) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Coercion a b -> m (Coercion a b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,A><L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_segq9)
                 (@ b_segqa)
                 (w_segqb [Occ=Once] :: Coercible a_segq9 b_segqa)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (@ (m_segqe :: * -> *))
                 (w3_segqf [Occ=Once] :: MonadPlus m_segqe)
                 _ [Occ=Dead]
                 (w5_segqh [Occ=Once] :: Coercion a_segq9 b_segqa) ->
                 Data.Data.$w$cgmapMo11
                   @ a_segq9 @ b_segqa w_segqb @ m_segqe w3_segqf w5_segqh}]
Data.Data.$fDataCoercion_$cgmapMo
  = \ (@ a_segq9)
      (@ b_segqa)
      (w_segqb :: Coercible a_segq9 b_segqa)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (@ (m_segqe :: * -> *))
      (w3_segqf :: MonadPlus m_segqe)
      _ [Occ=Dead]
      (w5_segqh :: Coercion a_segq9 b_segqa) ->
      Data.Data.$w$cgmapMo11
        @ a_segq9 @ b_segqa w_segqb @ m_segqe w3_segqf w5_segqh

-- RHS size: {terms: 7, types: 19, coercions: 0, joins: 0/0}
lvl144_rejQY :: forall a b. Coercion a b -> Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []]
lvl144_rejQY
  = \ (@ a_Xe4YD)
      (@ b_Xe4YF)
      (ds_de7yQ :: Coercion a_Xe4YD b_Xe4YF) ->
      case ds_de7yQ of { Coercion $dCoercible_ae4kd ->
      Data.Data.$cCoercion
      }

-- RHS size: {terms: 4, types: 9, coercions: 0, joins: 0/0}
lvl145_rejQZ :: forall a b. Coercion a b -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl145_rejQZ
  = \ (@ a_Xe4YD) (@ b_Xe4YF) _ [Occ=Dead] -> Data.Data.$tCoercion

-- RHS size: {terms: 7, types: 31, coercions: 0, joins: 0/0}
lvl146_rejR0
  :: forall a b (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Coercion a b))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl146_rejR0
  = \ (@ a_Xe4YD)
      (@ b_Xe4YF)
      (@ (t_ae4km :: * -> *))
      (@ (c_ae4kn :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae4kn (Coercion a_Xe4YD b_Xe4YF))

-- RHS size: {terms: 7, types: 40, coercions: 0, joins: 0/0}
lvl147_rejR1
  :: forall a b (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e))
     -> Maybe (c (Coercion a b))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl147_rejR1
  = \ (@ a_Xe4YD)
      (@ b_Xe4YF)
      (@ (t_ae4kF :: * -> * -> *))
      (@ (c_ae4kG :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae4kG (Coercion a_Xe4YD b_Xe4YF))

-- RHS size: {terms: 12, types: 33, coercions: 10, joins: 0/0}
lvl148_rejR2
  :: forall a b r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data d => d -> r')
     -> Coercion a b
     -> Const r (Coercion a b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*H>,
 Unf=OtherCon []]
lvl148_rejR2
  = \ (@ a_Xe4YD)
      (@ b_Xe4YF)
      (@ r_Xe53c)
      (@ r'_Xe53e)
      _ [Occ=Dead]
      (ds1_Xe8gY :: r_Xe53c)
      _ [Occ=Dead]
      (eta_X1pN :: Coercion a_Xe4YD b_Xe4YF) ->
      case eta_X1pN of { Coercion $dCoercible_ae4jQ ->
      ds1_Xe8gY
      `cast` (Sym (Data.Functor.Const.N:Const[0]
                       <*>_N <r_Xe53c>_R <Coercion a_Xe4YD b_Xe4YF>_P)
              :: (r_Xe53c :: *)
                 ~R# (Const r_Xe53c (Coercion a_Xe4YD b_Xe4YF) :: *))
      }

-- RHS size: {terms: 12, types: 33, coercions: 0, joins: 0/0}
lvl149_rejR3
  :: forall a b r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> Coercion a b -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*H>,
 Unf=OtherCon []]
lvl149_rejR3
  = \ (@ a_Xe4YD)
      (@ b_Xe4YF)
      (@ r_ae4lu)
      (@ r'_ae4lv)
      _ [Occ=Dead]
      (ds1_de7yZ :: r_ae4lu)
      _ [Occ=Dead]
      (x0_ae1SX :: Coercion a_Xe4YD b_Xe4YF) ->
      case x0_ae1SX of { Coercion $dCoercible_ae4jQ -> ds1_de7yZ }

-- RHS size: {terms: 9, types: 28, coercions: 0, joins: 0/0}
lvl150_rejR4
  :: forall a b u.
     (forall d. Data d => d -> u) -> Coercion a b -> [u]
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><S,1*H>, Unf=OtherCon []]
lvl150_rejR4
  = \ (@ a_Xe4YD)
      (@ b_Xe4YF)
      (@ u_ae4lL)
      _ [Occ=Dead]
      (x0_ae1SX :: Coercion a_Xe4YD b_Xe4YF) ->
      case x0_ae1SX of { Coercion $dCoercible_ae4jQ ->
      GHC.Types.[] @ u_ae4lL
      }

-- RHS size: {terms: 10, types: 29, coercions: 0, joins: 0/0}
lvl151_rejR5
  :: forall a b u.
     Int -> (forall d. Data d => d -> u) -> Coercion a b -> u
[GblId, Arity=3, Str=<B,A><B,A><B,1*H>x, Unf=OtherCon []]
lvl151_rejR5
  = \ (@ a_Xe4YD)
      (@ b_Xe4YF)
      (@ u_ae4lZ)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (x_ae1T7 :: Coercion a_Xe4YD b_Xe4YF) ->
      case x_ae1T7 of { Coercion $dCoercible_ae4jQ ->
      Data.Maybe.fromJust1 @ u_ae4lZ
      }

-- RHS size: {terms: 68, types: 209, coercions: 69, joins: 0/1}
Data.Data.$fDataCoercion [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (Coercible a b, Data a, Data b) =>
     Data (Coercion a b)
[GblId[DFunId],
 Arity=3,
 Str=<L,U><L,1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=DFun: \ (@ a_ae1Xm)
             (@ b_ae1Xn)
             (v_XHX :: Coercible a_ae1Xm b_ae1Xn)
             (v1_XHZ :: Data a_ae1Xm)
             (v2_XI1 :: Data b_ae1Xn) ->
       Data.Data.C:Data TYPE: Coercion a_ae1Xm b_ae1Xn
                        (Data.Data.$fDataCoercion5 @ a_ae1Xm @ b_ae1Xn v_XHX v1_XHZ v2_XI1)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Coercion
                                                                                    a_ae1Xm
                                                                                    b_ae1Xn>_N
                                :: (Data.Typeable.Internal.TypeRep (Coercion a_ae1Xm b_ae1Xn) :: *)
                                   ~R# (Typeable (Coercion a_ae1Xm b_ae1Xn) :: Constraint))
                        \ (@ (c_ae4jO :: * -> *))
                          _ [Occ=Dead]
                          (z_ae2p2 [Occ=Once!] :: forall g. g -> c_ae4jO g)
                          (ds_de7yO [Occ=Once!] :: Coercion a_ae1Xm b_ae1Xn) ->
                          case ds_de7yO of { Coercion _ [Occ=Dead] ->
                          z_ae2p2
                            @ (Coercion a_ae1Xm b_ae1Xn)
                            (Data.Type.Coercion.Coercion @ * @ a_ae1Xm @ b_ae1Xn v_XHX)
                          }
                        \ (@ (c_ae4k1 :: * -> *))
                          _ [Occ=Dead]
                          (z_ae2p4 [Occ=Once!] :: forall r. r -> c_ae4k1 r)
                          _ [Occ=Dead] ->
                          z_ae2p4
                            @ (Coercion a_ae1Xm b_ae1Xn)
                            (Data.Type.Coercion.Coercion @ * @ a_ae1Xm @ b_ae1Xn v_XHX)
                        \ (ds_de7yQ [Occ=Once!] :: Coercion a_ae1Xm b_ae1Xn) ->
                          case ds_de7yQ of { Coercion _ [Occ=Dead] -> Data.Data.$cCoercion }
                        \ _ [Occ=Dead] -> Data.Data.$tCoercion
                        \ (@ (t_ae4km :: * -> *))
                          (@ (c_ae4kn :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae4kn (Coercion a_ae1Xm b_ae1Xn))
                        \ (@ (t_ae4kF :: * -> * -> *))
                          (@ (c_ae4kG :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae4kG (Coercion a_ae1Xm b_ae1Xn))
                        (\ _ [Occ=Dead]
                           (x0_Xe31d [Occ=Once!] :: Coercion a_ae1Xm b_ae1Xn) ->
                           case x0_Xe31d of { Coercion _ [Occ=Dead] ->
                           (Data.Type.Coercion.Coercion @ * @ a_ae1Xm @ b_ae1Xn v_XHX)
                           `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                                            <Coercion a_ae1Xm b_ae1Xn>_R)
                                   :: (Coercion a_ae1Xm b_ae1Xn :: *)
                                      ~R# (Identity (Coercion a_ae1Xm b_ae1Xn) :: *))
                           })
                        `cast` (<forall b1. Data b1 => b1 -> b1>_R
                                ->_R <Coercion a_ae1Xm b_ae1Xn>_R
                                ->_R Data.Functor.Identity.N:Identity[0]
                                         <Coercion a_ae1Xm b_ae1Xn>_R
                                :: ((forall b1. Data b1 => b1 -> b1)
                                    -> Coercion a_ae1Xm b_ae1Xn
                                    -> Identity (Coercion a_ae1Xm b_ae1Xn) :: *)
                                   ~R# ((forall b1. Data b1 => b1 -> b1)
                                        -> Coercion a_ae1Xm b_ae1Xn
                                        -> Coercion a_ae1Xm b_ae1Xn :: *))
                        (\ (@ r_Xe53c)
                           (@ r'_Xe53e)
                           _ [Occ=Dead]
                           (ds1_Xe8gY [Occ=Once] :: r_Xe53c)
                           _ [Occ=Dead]
                           (eta_X1pN [Occ=Once!] :: Coercion a_ae1Xm b_ae1Xn) ->
                           case eta_X1pN of { Coercion _ [Occ=Dead] ->
                           ds1_Xe8gY
                           `cast` (Sym (Data.Functor.Const.N:Const[0]
                                            <*>_N <r_Xe53c>_R <Coercion a_ae1Xm b_ae1Xn>_P)
                                   :: (r_Xe53c :: *)
                                      ~R# (Const r_Xe53c (Coercion a_ae1Xm b_ae1Xn) :: *))
                           })
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <Coercion a_ae1Xm b_ae1Xn>_R
                                ->_R Data.Functor.Const.N:Const[0]
                                         <*>_N <r>_R <Coercion a_ae1Xm b_ae1Xn>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> Coercion a_ae1Xm b_ae1Xn
                                    -> Const r (Coercion a_ae1Xm b_ae1Xn) :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d. Data d => d -> r')
                                        -> Coercion a_ae1Xm b_ae1Xn
                                        -> r :: *))
                        \ (@ r_ae4lu)
                          (@ r'_ae4lv)
                          _ [Occ=Dead]
                          (ds1_de7yZ [Occ=Once] :: r_ae4lu)
                          _ [Occ=Dead]
                          (x0_ae1SX [Occ=Once!] :: Coercion a_ae1Xm b_ae1Xn) ->
                          case x0_ae1SX of { Coercion _ [Occ=Dead] -> ds1_de7yZ }
                        \ (@ u_ae4lL)
                          _ [Occ=Dead]
                          (x0_ae1SX [Occ=Once!] :: Coercion a_ae1Xm b_ae1Xn) ->
                          case x0_ae1SX of { Coercion _ [Occ=Dead] ->
                          GHC.Types.[] @ u_ae4lL
                          }
                        \ (@ u_ae4lZ)
                          _ [Occ=Dead]
                          _ [Occ=Dead]
                          (x_ae1T7 [Occ=Once!] :: Coercion a_ae1Xm b_ae1Xn) ->
                          case x_ae1T7 of { Coercion _ [Occ=Dead] ->
                          Data.Maybe.fromJust1 @ u_ae4lZ
                          }
                        \ (@ (m_ae4md :: * -> *))
                          ($dMonad_ae4mf [Occ=Once] :: Monad m_ae4md)
                          _ [Occ=Dead]
                          (eta_XHD [Occ=Once!] :: Coercion a_ae1Xm b_ae1Xn) ->
                          case eta_XHD of { Coercion _ [Occ=Dead] ->
                          return
                            @ m_ae4md
                            $dMonad_ae4mf
                            @ (Coercion a_ae1Xm b_ae1Xn)
                            (Data.Type.Coercion.Coercion @ * @ a_ae1Xm @ b_ae1Xn v_XHX)
                          }
                        Data.Data.$fDataCoercion_$cgmapMp
                          @ a_ae1Xm @ b_ae1Xn v_XHX v1_XHZ v2_XI1
                        Data.Data.$fDataCoercion_$cgmapMo
                          @ a_ae1Xm @ b_ae1Xn v_XHX v1_XHZ v2_XI1]
Data.Data.$fDataCoercion
  = \ (@ a_Xe4YD)
      (@ b_Xe4YF)
      ($dCoercible_Xe5GD :: Coercible a_Xe4YD b_Xe4YF)
      ($dData_Xe5GG :: Data a_Xe4YD)
      ($dData1_Xe5GJ :: Data b_Xe4YF) ->
      let {
        lvl270_se9LC :: Coercion a_Xe4YD b_Xe4YF
        [LclId, Unf=OtherCon []]
        lvl270_se9LC
          = Data.Type.Coercion.Coercion
              @ * @ a_Xe4YD @ b_Xe4YF $dCoercible_Xe5GD } in
      Data.Data.C:Data
        @ (Coercion a_Xe4YD b_Xe4YF)
        ((Data.Data.$fDataCoercion5
            @ a_Xe4YD @ b_Xe4YF $dCoercible_Xe5GD $dData_Xe5GG $dData1_Xe5GJ)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Coercion
                                                                     a_Xe4YD b_Xe4YF>_N
                 :: (Data.Typeable.Internal.TypeRep (Coercion a_Xe4YD b_Xe4YF) :: *)
                    ~R# (Typeable (Coercion a_Xe4YD b_Xe4YF) :: Constraint)))
        (\ (@ (c_ae4jO :: * -> *))
           _ [Occ=Dead]
           (z_ae2p2 :: forall g. g -> c_ae4jO g)
           (ds_de7yO :: Coercion a_Xe4YD b_Xe4YF) ->
           case ds_de7yO of { Coercion $dCoercible1_ae4jQ ->
           z_ae2p2 @ (Coercion a_Xe4YD b_Xe4YF) lvl270_se9LC
           })
        (\ (@ (c_ae4k1 :: * -> *))
           _ [Occ=Dead]
           (z_ae2p4 :: forall r. r -> c_ae4k1 r)
           _ [Occ=Dead] ->
           z_ae2p4 @ (Coercion a_Xe4YD b_Xe4YF) lvl270_se9LC)
        (lvl144_rejQY @ a_Xe4YD @ b_Xe4YF)
        (lvl145_rejQZ @ a_Xe4YD @ b_Xe4YF)
        (lvl146_rejR0 @ a_Xe4YD @ b_Xe4YF)
        (lvl147_rejR1 @ a_Xe4YD @ b_Xe4YF)
        ((\ _ [Occ=Dead] (x0_Xe31d :: Coercion a_Xe4YD b_Xe4YF) ->
            case x0_Xe31d of { Coercion $dCoercible1_ae4jQ ->
            lvl270_se9LC
            `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                             <Coercion a_Xe4YD b_Xe4YF>_R)
                    :: (Coercion a_Xe4YD b_Xe4YF :: *)
                       ~R# (Identity (Coercion a_Xe4YD b_Xe4YF) :: *))
            })
         `cast` (<forall b1. Data b1 => b1 -> b1>_R
                 ->_R <Coercion a_Xe4YD b_Xe4YF>_R
                 ->_R Data.Functor.Identity.N:Identity[0]
                          <Coercion a_Xe4YD b_Xe4YF>_R
                 :: ((forall b1. Data b1 => b1 -> b1)
                     -> Coercion a_Xe4YD b_Xe4YF
                     -> Identity (Coercion a_Xe4YD b_Xe4YF) :: *)
                    ~R# ((forall b1. Data b1 => b1 -> b1)
                         -> Coercion a_Xe4YD b_Xe4YF -> Coercion a_Xe4YD b_Xe4YF :: *)))
        ((lvl148_rejR2 @ a_Xe4YD @ b_Xe4YF)
         `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                 <r -> r' -> r>_R
                 ->_R <r>_R
                 ->_R <forall d. Data d => d -> r'>_R
                 ->_R <Coercion a_Xe4YD b_Xe4YF>_R
                 ->_R Data.Functor.Const.N:Const[0]
                          <*>_N <r>_R <Coercion a_Xe4YD b_Xe4YF>_P
                 :: (forall r r'.
                     (r -> r' -> r)
                     -> r
                     -> (forall d. Data d => d -> r')
                     -> Coercion a_Xe4YD b_Xe4YF
                     -> Const r (Coercion a_Xe4YD b_Xe4YF) :: *)
                    ~R# (forall r r'.
                         (r -> r' -> r)
                         -> r
                         -> (forall d. Data d => d -> r')
                         -> Coercion a_Xe4YD b_Xe4YF
                         -> r :: *)))
        (lvl149_rejR3 @ a_Xe4YD @ b_Xe4YF)
        (lvl150_rejR4 @ a_Xe4YD @ b_Xe4YF)
        (lvl151_rejR5 @ a_Xe4YD @ b_Xe4YF)
        (\ (@ (m_ae4md :: * -> *))
           ($dMonad_ae4mf :: Monad m_ae4md)
           _ [Occ=Dead]
           (eta_XHD :: Coercion a_Xe4YD b_Xe4YF) ->
           case eta_XHD of { Coercion $dCoercible1_ae4jQ ->
           return
             @ m_ae4md $dMonad_ae4mf @ (Coercion a_Xe4YD b_Xe4YF) lvl270_se9LC
           })
        (\ (@ (m_segq4 :: * -> *))
           (w_segq5 :: MonadPlus m_segq4)
           _ [Occ=Dead]
           (w2_segq7 :: Coercion a_Xe4YD b_Xe4YF) ->
           Data.Data.$w$cgmapMp12
             @ a_Xe4YD @ b_Xe4YF $dCoercible_Xe5GD @ m_segq4 w_segq5 w2_segq7)
        (\ (@ (m_segqe :: * -> *))
           (w_segqf :: MonadPlus m_segqe)
           _ [Occ=Dead]
           (w2_segqh :: Coercion a_Xe4YD b_Xe4YF) ->
           Data.Data.$w$cgmapMo11
             @ a_Xe4YD @ b_Xe4YF $dCoercible_Xe5GD @ m_segqe w_segqf w2_segqh)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataIdentity6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fDataIdentity6 = "Identity"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataIdentity5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataIdentity5
  = unpackCString# Data.Data.$fDataIdentity6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$cIdentity1_rejR6 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$cIdentity1_rejR6 = "runIdentity"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cIdentity2_rejR7 :: [Char]
[GblId]
$cIdentity2_rejR7 = unpackCString# $cIdentity1_rejR6

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$cIdentity3_rejR8 :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cIdentity3_rejR8
  = GHC.Types.: @ String $cIdentity2_rejR7 (GHC.Types.[] @ String)

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go24_rejR9 :: [Constr] -> [Int] -> Int
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go24_rejR9
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fDataIdentity5 of {
                False -> go24_rejR9 ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cIdentity4_rejRa :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cIdentity4_rejRa = Data.Data.AlgConstr $cIdentity5_rejRb

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataIdentity4 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataIdentity4
  = GHC.Types.: @ Constr Data.Data.$cIdentity (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataIdentity3 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataIdentity3
  = Data.Data.AlgRep Data.Data.$fDataIdentity4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tIdentity :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$tIdentity
  = Data.Data.DataType
      Data.Data.$fDataIdentity5 Data.Data.$fDataIdentity3

-- RHS size: {terms: 6, types: 0, coercions: 0, joins: 0/0}
Data.Data.$cIdentity [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cIdentity
  = Data.Data.Constr
      $cIdentity4_rejRa
      Data.Data.$fDataIdentity5
      $cIdentity3_rejR8
      Data.Data.Prefix
      Data.Data.$tIdentity

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cIdentity5_rejRb :: Int
[GblId]
$cIdentity5_rejRb
  = go24_rejR9 Data.Data.$fDataIdentity4 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 4, types: 7, coercions: 5, joins: 0/0}
Data.Data.$fDataIdentity1 :: forall a. (a -> Identity a, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataIdentity1
  = \ (@ a_Xe4VP) ->
      ((Data.Data.$fDataConst2 @ a_Xe4VP)
       `cast` (<a_Xe4VP>_R
               ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_Xe4VP>_R)
               :: (a_Xe4VP -> a_Xe4VP :: *)
                  ~R# (a_Xe4VP -> Identity a_Xe4VP :: *)),
       GHC.Types.False)

-- RHS size: {terms: 57, types: 112, coercions: 4, joins: 0/3}
Data.Data.$fDataIdentity_$cgmapMp
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Identity a -> m (Identity a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 510 0}]
Data.Data.$fDataIdentity_$cgmapMp
  = \ (@ a_Xe4VP)
      ($dData_Xe4VR :: Data a_Xe4VP)
      (@ (m_ae4j7 :: * -> *))
      ($dMonadPlus_ae4j9 :: MonadPlus m_ae4j7)
      (ds_de7yM :: forall d. Data d => d -> m_ae4j7 d)
      (eta_XI7 :: Identity a_Xe4VP) ->
      let {
        lvl270_se9LR :: m_ae4j7 (Identity a_Xe4VP)
        [LclId]
        lvl270_se9LR
          = mzero @ m_ae4j7 $dMonadPlus_ae4j9 @ (Identity a_Xe4VP) } in
      let {
        $dMonad_se9rp [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae4j7
        [LclId]
        $dMonad_se9rp
          = GHC.Base.$p2MonadPlus @ m_ae4j7 $dMonadPlus_ae4j9 } in
      >>=
        @ m_ae4j7
        $dMonad_se9rp
        @ (Identity a_Xe4VP, Bool)
        @ (Identity a_Xe4VP)
        (let {
           lvl271_se9LQ :: m_ae4j7 a_Xe4VP
           [LclId]
           lvl271_se9LQ
             = ds_de7yM
                 @ a_Xe4VP
                 $dData_Xe4VR
                 (eta_XI7
                  `cast` (Data.Functor.Identity.N:Identity[0] <a_Xe4VP>_R
                          :: (Identity a_Xe4VP :: *) ~R# (a_Xe4VP :: *))) } in
         >>=
           @ m_ae4j7
           $dMonad_se9rp
           @ (a_Xe4VP -> Identity a_Xe4VP, Bool)
           @ (Identity a_Xe4VP, Bool)
           (return
              @ m_ae4j7
              $dMonad_se9rp
              @ (a_Xe4VP -> Identity a_Xe4VP, Bool)
              (Data.Data.$fDataIdentity1 @ a_Xe4VP))
           (\ (ds1_de7oD :: (a_Xe4VP -> Identity a_Xe4VP, Bool)) ->
              case ds1_de7oD of { (h_ae1TA, b_ae1TB) ->
              mplus
                @ m_ae4j7
                $dMonadPlus_ae4j9
                @ (Identity a_Xe4VP, Bool)
                (>>=
                   @ m_ae4j7
                   $dMonad_se9rp
                   @ a_Xe4VP
                   @ (Identity a_Xe4VP, Bool)
                   lvl271_se9LQ
                   (\ (y'_ae1TC :: a_Xe4VP) ->
                      return
                        @ m_ae4j7
                        $dMonad_se9rp
                        @ (Identity a_Xe4VP, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_ae4j7
                   $dMonad_se9rp
                   @ (Identity a_Xe4VP, Bool)
                   (h_ae1TA
                      (eta_XI7
                       `cast` (Data.Functor.Identity.N:Identity[0] <a_Xe4VP>_R
                               :: (Identity a_Xe4VP :: *) ~R# (a_Xe4VP :: *))),
                    b_ae1TB))
              }))
        (\ (ds1_de7oa :: (Identity a_Xe4VP, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9LR;
             True ->
               return @ m_ae4j7 $dMonad_se9rp @ (Identity a_Xe4VP) x'_ae1TD
           }
           })

-- RHS size: {terms: 24, types: 44, coercions: 7, joins: 0/1}
Data.Data.$fDataIdentity_$cgmapM
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Identity a -> m (Identity a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120 60 0] 220 0}]
Data.Data.$fDataIdentity_$cgmapM
  = \ (@ a_Xe4VO)
      ($dData_Xe4VQ :: Data a_Xe4VO)
      (@ (m_ae4iR :: * -> *))
      ($dMonad_ae4iT :: Monad m_ae4iR)
      (ds_de7yL :: forall d. Data d => d -> m_ae4iR d)
      (eta_XI8 :: Identity a_Xe4VO) ->
      let {
        lvl270_se9LT :: m_ae4iR a_Xe4VO
        [LclId]
        lvl270_se9LT
          = ds_de7yL
              @ a_Xe4VO
              $dData_Xe4VQ
              (eta_XI8
               `cast` (Data.Functor.Identity.N:Identity[0] <a_Xe4VO>_R
                       :: (Identity a_Xe4VO :: *) ~R# (a_Xe4VO :: *))) } in
      >>=
        @ m_ae4iR
        $dMonad_ae4iT
        @ (a_Xe4VO -> Identity a_Xe4VO)
        @ (Identity a_Xe4VO)
        (return
           @ m_ae4iR
           $dMonad_ae4iT
           @ (a_Xe4VO -> Identity a_Xe4VO)
           ((Data.Data.$fDataConst2 @ a_Xe4VO)
            `cast` (<a_Xe4VO>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_Xe4VO>_R)
                    :: (a_Xe4VO -> a_Xe4VO :: *)
                       ~R# (a_Xe4VO -> Identity a_Xe4VO :: *))))
        (\ (c'_ae1To :: a_Xe4VO -> Identity a_Xe4VO) ->
           >>=
             @ m_ae4iR
             $dMonad_ae4iT
             @ a_Xe4VO
             @ (Identity a_Xe4VO)
             lvl270_se9LT
             (\ (x'_ae1Tp :: a_Xe4VO) ->
                return
                  @ m_ae4iR $dMonad_ae4iT @ (Identity a_Xe4VO) (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 17, types: 20, coercions: 2, joins: 0/0}
Data.Data.$fDataIdentity_$cgmapQi
  :: forall a.
     Data a =>
     forall u. Int -> (forall d. Data d => d -> u) -> Identity a -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe4VN)
                 ($dData_Xe4VP [Occ=Once] :: Data a_Xe4VN)
                 (@ u_ae4iD)
                 (ds_de7yJ [Occ=Once!] :: Int)
                 (ds1_de7yK [Occ=Once!] :: forall d. Data d => d -> u_ae4iD)
                 (x_ae1T7 [Occ=Once] :: Identity a_Xe4VN) ->
                 case ds_de7yJ of { I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_ae4iD;
                   0# ->
                     ds1_de7yK
                       @ a_Xe4VN
                       $dData_Xe4VP
                       (x_ae1T7
                        `cast` (Data.Functor.Identity.N:Identity[0] <a_Xe4VN>_R
                                :: (Identity a_Xe4VN :: *) ~R# (a_Xe4VN :: *)))
                 }
                 }}]
Data.Data.$fDataIdentity_$cgmapQi
  = \ (@ a_Xe4VN)
      ($dData_Xe4VP :: Data a_Xe4VN)
      (@ u_ae4iD)
      (ds_de7yJ :: Int)
      (ds1_de7yK :: forall d. Data d => d -> u_ae4iD)
      (x_ae1T7 :: Identity a_Xe4VN) ->
      case ds_de7yJ of { I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_ae4iD;
        0# ->
          ds1_de7yK
            @ a_Xe4VN
            $dData_Xe4VP
            (x_ae1T7
             `cast` (Data.Functor.Identity.N:Identity[0] <a_Xe4VN>_R
                     :: (Identity a_Xe4VN :: *) ~R# (a_Xe4VN :: *)))
      }
      }

-- RHS size: {terms: 67, types: 121, coercions: 6, joins: 0/3}
Data.Data.$fDataIdentity_$cgmapMo
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Identity a -> m (Identity a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 590 0}]
Data.Data.$fDataIdentity_$cgmapMo
  = \ (@ a_Xe4VI)
      ($dData_Xe4VK :: Data a_Xe4VI)
      (@ (m_ae4jn :: * -> *))
      ($dMonadPlus_ae4jp :: MonadPlus m_ae4jn)
      (ds_de7yN :: forall d. Data d => d -> m_ae4jn d)
      (eta_XIh :: Identity a_Xe4VI) ->
      let {
        lvl270_se9LY :: m_ae4jn (Identity a_Xe4VI)
        [LclId]
        lvl270_se9LY
          = mzero @ m_ae4jn $dMonadPlus_ae4jp @ (Identity a_Xe4VI) } in
      let {
        $dMonad_se9rn [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae4jn
        [LclId]
        $dMonad_se9rn
          = GHC.Base.$p2MonadPlus @ m_ae4jn $dMonadPlus_ae4jp } in
      >>=
        @ m_ae4jn
        $dMonad_se9rn
        @ (Identity a_Xe4VI, Bool)
        @ (Identity a_Xe4VI)
        (let {
           lvl271_se9LX :: m_ae4jn a_Xe4VI
           [LclId]
           lvl271_se9LX
             = ds_de7yN
                 @ a_Xe4VI
                 $dData_Xe4VK
                 (eta_XIh
                  `cast` (Data.Functor.Identity.N:Identity[0] <a_Xe4VI>_R
                          :: (Identity a_Xe4VI :: *) ~R# (a_Xe4VI :: *))) } in
         >>=
           @ m_ae4jn
           $dMonad_se9rn
           @ (a_Xe4VI -> Identity a_Xe4VI, Bool)
           @ (Identity a_Xe4VI, Bool)
           (return
              @ m_ae4jn
              $dMonad_se9rn
              @ (a_Xe4VI -> Identity a_Xe4VI, Bool)
              (Data.Data.$fDataIdentity1 @ a_Xe4VI))
           (\ (ds1_de7pD :: (a_Xe4VI -> Identity a_Xe4VI, Bool)) ->
              case ds1_de7pD of { (h_ae1TP, b_ae1TQ) ->
              case b_ae1TQ of {
                False ->
                  mplus
                    @ m_ae4jn
                    $dMonadPlus_ae4jp
                    @ (Identity a_Xe4VI, Bool)
                    (>>=
                       @ m_ae4jn
                       $dMonad_se9rn
                       @ a_Xe4VI
                       @ (Identity a_Xe4VI, Bool)
                       lvl271_se9LX
                       (\ (y'_ae1TR :: a_Xe4VI) ->
                          return
                            @ m_ae4jn
                            $dMonad_se9rn
                            @ (Identity a_Xe4VI, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_ae4jn
                       $dMonad_se9rn
                       @ (Identity a_Xe4VI, Bool)
                       (h_ae1TP
                          (eta_XIh
                           `cast` (Data.Functor.Identity.N:Identity[0] <a_Xe4VI>_R
                                   :: (Identity a_Xe4VI :: *) ~R# (a_Xe4VI :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_ae4jn
                    $dMonad_se9rn
                    @ (Identity a_Xe4VI, Bool)
                    (h_ae1TP
                       (eta_XIh
                        `cast` (Data.Functor.Identity.N:Identity[0] <a_Xe4VI>_R
                                :: (Identity a_Xe4VI :: *) ~R# (a_Xe4VI :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds1_de7pa :: (Identity a_Xe4VI, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9LY;
             True ->
               return @ m_ae4jn $dMonad_se9rn @ (Identity a_Xe4VI) x'_ae1TS
           }
           })

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl152_rejRc :: forall a. Identity a -> Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl152_rejRc = \ (@ a_Xe4VH) _ [Occ=Dead] -> Data.Data.$cIdentity

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl153_rejRd :: forall a. Identity a -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl153_rejRd = \ (@ a_Xe4VH) _ [Occ=Dead] -> Data.Data.$tIdentity

-- RHS size: {terms: 6, types: 35, coercions: 0, joins: 0/0}
lvl154_rejRe
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e))
     -> Maybe (c (Identity a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl154_rejRe
  = \ (@ a_Xe4VH)
      (@ (t_ae4hj :: * -> * -> *))
      (@ (c_ae4hk :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae4hk (Identity a_Xe4VH))

-- RHS size: {terms: 63, types: 100, coercions: 32, joins: 0/0}
Data.Data.$fDataIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data a => Data (Identity a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_ae1Xl) (v_XIe :: Data a_ae1Xl) ->
       Data.Data.C:Data TYPE: Identity a_ae1Xl
                        (Data.Data.$fDataIdentity7 @ a_ae1Xl v_XIe)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Identity
                                                                                    a_ae1Xl>_N
                                :: (Data.Typeable.Internal.TypeRep (Identity a_ae1Xl) :: *)
                                   ~R# (Typeable (Identity a_ae1Xl) :: Constraint))
                        Data.Data.$fDataIdentity_$cgfoldl @ a_ae1Xl v_XIe
                        \ (@ (c_ae4gI :: * -> *))
                          (k_ae2oY [Occ=Once!]
                             :: forall b r. Data b => c_ae4gI (b -> r) -> c_ae4gI r)
                          (z_ae2oZ [Occ=Once!] :: forall r. r -> c_ae4gI r)
                          _ [Occ=Dead] ->
                          k_ae2oY
                            @ a_ae1Xl
                            @ (Identity a_ae1Xl)
                            v_XIe
                            (z_ae2oZ
                               @ (a_ae1Xl -> Identity a_ae1Xl)
                               ((Data.Data.$fDataConst2 @ a_ae1Xl)
                                `cast` (<a_ae1Xl>_R
                                        ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_ae1Xl>_R)
                                        :: (a_ae1Xl -> a_ae1Xl :: *)
                                           ~R# (a_ae1Xl -> Identity a_ae1Xl :: *))))
                        \ _ [Occ=Dead] -> Data.Data.$cIdentity
                        \ _ [Occ=Dead] -> Data.Data.$tIdentity
                        Data.Data.$fDataIdentity_$cdataCast1 @ a_ae1Xl v_XIe
                        \ (@ (t_ae4hj :: * -> * -> *))
                          (@ (c_ae4hk :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae4hk (Identity a_ae1Xl))
                        (\ (ds_de7yB [Occ=Once!] :: forall b. Data b => b -> b)
                           (x0_Xe31w [Occ=Once] :: Identity a_ae1Xl) ->
                           ds_de7yB
                             @ a_ae1Xl
                             v_XIe
                             (x0_Xe31w
                              `cast` (Data.Functor.Identity.N:Identity[0] <a_ae1Xl>_R
                                      :: (Identity a_ae1Xl :: *) ~R# (a_ae1Xl :: *))))
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <Identity a_ae1Xl>_R
                                ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_ae1Xl>_R)
                                :: ((forall b. Data b => b -> b)
                                    -> Identity a_ae1Xl -> a_ae1Xl :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> Identity a_ae1Xl -> Identity a_ae1Xl :: *))
                        \ (@ r_ae4hR)
                          (@ r'_ae4hS)
                          (ds_de7yC [Occ=Once!] :: r_ae4hR -> r'_ae4hS -> r_ae4hR)
                          (ds1_de7yD [Occ=Once] :: r_ae4hR)
                          (ds2_de7yE [Occ=Once!] :: forall d. Data d => d -> r'_ae4hS)
                          (eta_X1qy [Occ=Once] :: Identity a_ae1Xl) ->
                          ds_de7yC
                            ds1_de7yD
                            (ds2_de7yE
                               @ a_ae1Xl
                               v_XIe
                               (eta_X1qy
                                `cast` (Data.Functor.Identity.N:Identity[0] <a_ae1Xl>_R
                                        :: (Identity a_ae1Xl :: *) ~R# (a_ae1Xl :: *))))
                        \ (@ r_ae4i8)
                          (@ r'_ae4i9)
                          (ds_de7yF [Occ=Once!] :: r'_ae4i9 -> r_ae4i8 -> r_ae4i8)
                          (ds1_de7yG [Occ=Once] :: r_ae4i8)
                          (ds2_de7yH [Occ=Once!] :: forall d. Data d => d -> r'_ae4i9)
                          (x0_ae1SX [Occ=Once] :: Identity a_ae1Xl) ->
                          ds_de7yF
                            (ds2_de7yH
                               @ a_ae1Xl
                               v_XIe
                               (x0_ae1SX
                                `cast` (Data.Functor.Identity.N:Identity[0] <a_ae1Xl>_R
                                        :: (Identity a_ae1Xl :: *) ~R# (a_ae1Xl :: *))))
                            ds1_de7yG
                        \ (@ u_ae4ip)
                          (ds_de7yI [Occ=Once!] :: forall d. Data d => d -> u_ae4ip)
                          (x0_ae1SX [Occ=Once] :: Identity a_ae1Xl) ->
                          GHC.Types.:
                            @ u_ae4ip
                            (ds_de7yI
                               @ a_ae1Xl
                               v_XIe
                               (x0_ae1SX
                                `cast` (Data.Functor.Identity.N:Identity[0] <a_ae1Xl>_R
                                        :: (Identity a_ae1Xl :: *) ~R# (a_ae1Xl :: *))))
                            (GHC.Types.[] @ u_ae4ip)
                        Data.Data.$fDataIdentity_$cgmapQi @ a_ae1Xl v_XIe
                        Data.Data.$fDataIdentity_$cgmapM @ a_ae1Xl v_XIe
                        Data.Data.$fDataIdentity_$cgmapMp @ a_ae1Xl v_XIe
                        Data.Data.$fDataIdentity_$cgmapMo @ a_ae1Xl v_XIe]
Data.Data.$fDataIdentity
  = \ (@ a_Xe4VH) ($dData_Xe5DW :: Data a_Xe4VH) ->
      Data.Data.C:Data
        @ (Identity a_Xe4VH)
        ((Data.Data.$fDataIdentity7 @ a_Xe4VH $dData_Xe5DW)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Identity
                                                                     a_Xe4VH>_N
                 :: (Data.Typeable.Internal.TypeRep (Identity a_Xe4VH) :: *)
                    ~R# (Typeable (Identity a_Xe4VH) :: Constraint)))
        (Data.Data.$fDataIdentity_$cgfoldl @ a_Xe4VH $dData_Xe5DW)
        (\ (@ (c_ae4gI :: * -> *))
           (k_ae2oY :: forall b r. Data b => c_ae4gI (b -> r) -> c_ae4gI r)
           (z_ae2oZ :: forall r. r -> c_ae4gI r)
           _ [Occ=Dead] ->
           k_ae2oY
             @ a_Xe4VH
             @ (Identity a_Xe4VH)
             $dData_Xe5DW
             (z_ae2oZ
                @ (a_Xe4VH -> Identity a_Xe4VH)
                ((Data.Data.$fDataConst2 @ a_Xe4VH)
                 `cast` (<a_Xe4VH>_R
                         ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_Xe4VH>_R)
                         :: (a_Xe4VH -> a_Xe4VH :: *)
                            ~R# (a_Xe4VH -> Identity a_Xe4VH :: *)))))
        (lvl152_rejRc @ a_Xe4VH)
        (lvl153_rejRd @ a_Xe4VH)
        (Data.Data.$fDataIdentity_$cdataCast1 @ a_Xe4VH $dData_Xe5DW)
        (lvl154_rejRe @ a_Xe4VH)
        ((\ (ds_de7yB :: forall b. Data b => b -> b)
            (x0_Xe31w :: Identity a_Xe4VH) ->
            ds_de7yB
              @ a_Xe4VH
              $dData_Xe5DW
              (x0_Xe31w
               `cast` (Data.Functor.Identity.N:Identity[0] <a_Xe4VH>_R
                       :: (Identity a_Xe4VH :: *) ~R# (a_Xe4VH :: *))))
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <Identity a_Xe4VH>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0] <a_Xe4VH>_R)
                 :: ((forall b. Data b => b -> b)
                     -> Identity a_Xe4VH -> a_Xe4VH :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> Identity a_Xe4VH -> Identity a_Xe4VH :: *)))
        (\ (@ r_ae4hR)
           (@ r'_ae4hS)
           (ds_de7yC :: r_ae4hR -> r'_ae4hS -> r_ae4hR)
           (ds1_de7yD :: r_ae4hR)
           (ds2_de7yE :: forall d. Data d => d -> r'_ae4hS)
           (eta_XIe :: Identity a_Xe4VH) ->
           ds_de7yC
             ds1_de7yD
             (ds2_de7yE
                @ a_Xe4VH
                $dData_Xe5DW
                (eta_XIe
                 `cast` (Data.Functor.Identity.N:Identity[0] <a_Xe4VH>_R
                         :: (Identity a_Xe4VH :: *) ~R# (a_Xe4VH :: *)))))
        (\ (@ r_ae4i8)
           (@ r'_ae4i9)
           (ds_de7yF :: r'_ae4i9 -> r_ae4i8 -> r_ae4i8)
           (ds1_de7yG :: r_ae4i8)
           (ds2_de7yH :: forall d. Data d => d -> r'_ae4i9)
           (x0_ae1SX :: Identity a_Xe4VH) ->
           ds_de7yF
             (ds2_de7yH
                @ a_Xe4VH
                $dData_Xe5DW
                (x0_ae1SX
                 `cast` (Data.Functor.Identity.N:Identity[0] <a_Xe4VH>_R
                         :: (Identity a_Xe4VH :: *) ~R# (a_Xe4VH :: *))))
             ds1_de7yG)
        (\ (@ u_ae4ip)
           (ds_de7yI :: forall d. Data d => d -> u_ae4ip)
           (x0_ae1SX :: Identity a_Xe4VH) ->
           GHC.Types.:
             @ u_ae4ip
             (ds_de7yI
                @ a_Xe4VH
                $dData_Xe5DW
                (x0_ae1SX
                 `cast` (Data.Functor.Identity.N:Identity[0] <a_Xe4VH>_R
                         :: (Identity a_Xe4VH :: *) ~R# (a_Xe4VH :: *))))
             (GHC.Types.[] @ u_ae4ip))
        (Data.Data.$fDataIdentity_$cgmapQi @ a_Xe4VH $dData_Xe5DW)
        (Data.Data.$fDataIdentity_$cgmapM @ a_Xe4VH $dData_Xe5DW)
        (Data.Data.$fDataIdentity_$cgmapMp @ a_Xe4VH $dData_Xe5DW)
        (Data.Data.$fDataIdentity_$cgmapMo @ a_Xe4VH $dData_Xe5DW)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataConst6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fDataConst6 = "Const"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataConst5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataConst5 = unpackCString# Data.Data.$fDataConst6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$cConst1_rejRf :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$cConst1_rejRf = "getConst"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cConst2_rejRg :: [Char]
[GblId]
$cConst2_rejRg = unpackCString# $cConst1_rejRf

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$cConst3_rejRh :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cConst3_rejRh
  = GHC.Types.: @ String $cConst2_rejRg (GHC.Types.[] @ String)

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go25_rejRi :: [Constr] -> [Int] -> Int
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go25_rejRi
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fDataConst5 of {
                False -> go25_rejRi ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cConst4_rejRj :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cConst4_rejRj = Data.Data.AlgConstr $cConst5_rejRk

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataConst4 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataConst4
  = GHC.Types.: @ Constr Data.Data.$cConst (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataConst3 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataConst3 = Data.Data.AlgRep Data.Data.$fDataConst4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tConst :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$tConst
  = Data.Data.DataType Data.Data.$fDataConst5 Data.Data.$fDataConst3

-- RHS size: {terms: 6, types: 0, coercions: 0, joins: 0/0}
Data.Data.$cConst [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cConst
  = Data.Data.Constr
      $cConst4_rejRj
      Data.Data.$fDataConst5
      $cConst3_rejRh
      Data.Data.Prefix
      Data.Data.$tConst

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cConst5_rejRk :: Int
[GblId]
$cConst5_rejRk
  = go25_rejRi Data.Data.$fDataConst4 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 6, types: 12, coercions: 7, joins: 0/0}
Data.Data.$fDataConst1
  :: forall a k (b :: k). (a -> Const a b, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataConst1
  = \ (@ a_Xe4SM) (@ k_Xe4SK) (@ (b_Xe4SO :: k_Xe4SK)) ->
      ((Data.Data.$fDataConst2 @ a_Xe4SM)
       `cast` (<a_Xe4SM>_R
               ->_R Sym (Data.Functor.Const.N:Const[0]
                             <k_Xe4SK>_N <a_Xe4SM>_R <b_Xe4SO>_P)
               :: (a_Xe4SM -> a_Xe4SM :: *)
                  ~R# (a_Xe4SM -> Const a_Xe4SM b_Xe4SO :: *)),
       GHC.Types.False)

-- RHS size: {terms: 59, types: 159, coercions: 8, joins: 0/3}
Data.Data.$w$cgmapMp13 [InlPrag=NOUSERINLINE[0]]
  :: forall k a (b :: k).
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Const a b -> m (Const a b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 510 0}]
Data.Data.$w$cgmapMp13
  = \ (@ k_segqF)
      (@ a_segqG)
      (@ (b_segqH :: k_segqF))
      (w_segqJ :: Data a_segqG)
      (@ (m_segqL :: * -> *))
      (w1_segqM :: MonadPlus m_segqL)
      (w2_segqN :: forall d. Data d => d -> m_segqL d)
      (w3_segqO :: Const a_segqG b_segqH) ->
      let {
        lvl270_se9Mg :: m_segqL (Const a_segqG b_segqH)
        [LclId]
        lvl270_se9Mg
          = mzero @ m_segqL w1_segqM @ (Const a_segqG b_segqH) } in
      let {
        $dMonad_se9rl [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_segqL
        [LclId]
        $dMonad_se9rl = GHC.Base.$p2MonadPlus @ m_segqL w1_segqM } in
      >>=
        @ m_segqL
        $dMonad_se9rl
        @ (Const a_segqG b_segqH, Bool)
        @ (Const a_segqG b_segqH)
        (let {
           lvl271_se9Mf :: m_segqL a_segqG
           [LclId]
           lvl271_se9Mf
             = w2_segqN
                 @ a_segqG
                 w_segqJ
                 (w3_segqO
                  `cast` (Data.Functor.Const.N:Const[0]
                              <k_segqF>_N <a_segqG>_R <b_segqH>_P
                          :: (Const a_segqG b_segqH :: *) ~R# (a_segqG :: *))) } in
         >>=
           @ m_segqL
           $dMonad_se9rl
           @ (a_segqG -> Const a_segqG b_segqH, Bool)
           @ (Const a_segqG b_segqH, Bool)
           (return
              @ m_segqL
              $dMonad_se9rl
              @ (a_segqG -> Const a_segqG b_segqH, Bool)
              (Data.Data.$fDataConst1 @ a_segqG @ k_segqF @ b_segqH))
           (\ (ds_de7oD :: (a_segqG -> Const a_segqG b_segqH, Bool)) ->
              case ds_de7oD of { (h_ae1TA, b1_ae1TB) ->
              mplus
                @ m_segqL
                w1_segqM
                @ (Const a_segqG b_segqH, Bool)
                (>>=
                   @ m_segqL
                   $dMonad_se9rl
                   @ a_segqG
                   @ (Const a_segqG b_segqH, Bool)
                   lvl271_se9Mf
                   (\ (y'_ae1TC :: a_segqG) ->
                      return
                        @ m_segqL
                        $dMonad_se9rl
                        @ (Const a_segqG b_segqH, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_segqL
                   $dMonad_se9rl
                   @ (Const a_segqG b_segqH, Bool)
                   (h_ae1TA
                      (w3_segqO
                       `cast` (Data.Functor.Const.N:Const[0]
                                   <k_segqF>_N <a_segqG>_R <b_segqH>_P
                               :: (Const a_segqG b_segqH :: *) ~R# (a_segqG :: *))),
                    b1_ae1TB))
              }))
        (\ (ds_de7oa :: (Const a_segqG b_segqH, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b1_ae1TE) ->
           case b1_ae1TE of {
             False -> lvl270_se9Mg;
             True ->
               return @ m_segqL $dMonad_se9rl @ (Const a_segqG b_segqH) x'_ae1TD
           }
           })

-- RHS size: {terms: 15, types: 35, coercions: 0, joins: 0/0}
Data.Data.$fDataConst_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall k a (b :: k).
     (Typeable k, Data a, Typeable b) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Const a b -> m (Const a b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,A><L,U><L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ k_segqF)
                 (@ a_segqG)
                 (@ (b_segqH :: k_segqF))
                 _ [Occ=Dead]
                 (w1_segqJ [Occ=Once] :: Data a_segqG)
                 _ [Occ=Dead]
                 (@ (m_segqL :: * -> *))
                 (w3_segqM [Occ=Once] :: MonadPlus m_segqL)
                 (w4_segqN [Occ=Once] :: forall d. Data d => d -> m_segqL d)
                 (w5_segqO [Occ=Once] :: Const a_segqG b_segqH) ->
                 Data.Data.$w$cgmapMp13
                   @ k_segqF
                   @ a_segqG
                   @ b_segqH
                   w1_segqJ
                   @ m_segqL
                   w3_segqM
                   w4_segqN
                   w5_segqO}]
Data.Data.$fDataConst_$cgmapMp
  = \ (@ k_segqF)
      (@ a_segqG)
      (@ (b_segqH :: k_segqF))
      _ [Occ=Dead]
      (w1_segqJ :: Data a_segqG)
      _ [Occ=Dead]
      (@ (m_segqL :: * -> *))
      (w3_segqM :: MonadPlus m_segqL)
      (w4_segqN :: forall d. Data d => d -> m_segqL d)
      (w5_segqO :: Const a_segqG b_segqH) ->
      Data.Data.$w$cgmapMp13
        @ k_segqF
        @ a_segqG
        @ b_segqH
        w1_segqJ
        @ m_segqL
        w3_segqM
        w4_segqN
        w5_segqO

-- RHS size: {terms: 26, types: 61, coercions: 11, joins: 0/1}
Data.Data.$w$cgmapM9 [InlPrag=NOUSERINLINE[0]]
  :: forall k a (b :: k).
     Data a =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Const a b -> m (Const a b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120 60 0] 220 0}]
Data.Data.$w$cgmapM9
  = \ (@ k_segqQ)
      (@ a_segqR)
      (@ (b_segqS :: k_segqQ))
      (w_segqU :: Data a_segqR)
      (@ (m_segqW :: * -> *))
      (w1_segqX :: Monad m_segqW)
      (w2_segqY :: forall d. Data d => d -> m_segqW d)
      (w3_segqZ :: Const a_segqR b_segqS) ->
      let {
        lvl270_se9Mi :: m_segqW a_segqR
        [LclId]
        lvl270_se9Mi
          = w2_segqY
              @ a_segqR
              w_segqU
              (w3_segqZ
               `cast` (Data.Functor.Const.N:Const[0]
                           <k_segqQ>_N <a_segqR>_R <b_segqS>_P
                       :: (Const a_segqR b_segqS :: *) ~R# (a_segqR :: *))) } in
      >>=
        @ m_segqW
        w1_segqX
        @ (a_segqR -> Const a_segqR b_segqS)
        @ (Const a_segqR b_segqS)
        (return
           @ m_segqW
           w1_segqX
           @ (a_segqR -> Const a_segqR b_segqS)
           ((Data.Data.$fDataConst2 @ a_segqR)
            `cast` (<a_segqR>_R
                    ->_R Sym (Data.Functor.Const.N:Const[0]
                                  <k_segqQ>_N <a_segqR>_R <b_segqS>_P)
                    :: (a_segqR -> a_segqR :: *)
                       ~R# (a_segqR -> Const a_segqR b_segqS :: *))))
        (\ (c'_ae1To :: a_segqR -> Const a_segqR b_segqS) ->
           >>=
             @ m_segqW
             w1_segqX
             @ a_segqR
             @ (Const a_segqR b_segqS)
             lvl270_se9Mi
             (\ (x'_ae1Tp :: a_segqR) ->
                return
                  @ m_segqW w1_segqX @ (Const a_segqR b_segqS) (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 15, types: 35, coercions: 0, joins: 0/0}
Data.Data.$fDataConst_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall k a (b :: k).
     (Typeable k, Data a, Typeable b) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Const a b -> m (Const a b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,A><L,U><L,A><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ k_segqQ)
                 (@ a_segqR)
                 (@ (b_segqS :: k_segqQ))
                 _ [Occ=Dead]
                 (w1_segqU [Occ=Once] :: Data a_segqR)
                 _ [Occ=Dead]
                 (@ (m_segqW :: * -> *))
                 (w3_segqX [Occ=Once] :: Monad m_segqW)
                 (w4_segqY [Occ=Once] :: forall d. Data d => d -> m_segqW d)
                 (w5_segqZ [Occ=Once] :: Const a_segqR b_segqS) ->
                 Data.Data.$w$cgmapM9
                   @ k_segqQ
                   @ a_segqR
                   @ b_segqS
                   w1_segqU
                   @ m_segqW
                   w3_segqX
                   w4_segqY
                   w5_segqZ}]
Data.Data.$fDataConst_$cgmapM
  = \ (@ k_segqQ)
      (@ a_segqR)
      (@ (b_segqS :: k_segqQ))
      _ [Occ=Dead]
      (w1_segqU :: Data a_segqR)
      _ [Occ=Dead]
      (@ (m_segqW :: * -> *))
      (w3_segqX :: Monad m_segqW)
      (w4_segqY :: forall d. Data d => d -> m_segqW d)
      (w5_segqZ :: Const a_segqR b_segqS) ->
      Data.Data.$w$cgmapM9
        @ k_segqQ
        @ a_segqR
        @ b_segqS
        w1_segqU
        @ m_segqW
        w3_segqX
        w4_segqY
        w5_segqZ

-- RHS size: {terms: 69, types: 172, coercions: 12, joins: 0/3}
Data.Data.$w$cgmapMo12 [InlPrag=NOUSERINLINE[0]]
  :: forall k a (b :: k).
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Const a b -> m (Const a b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 590 0}]
Data.Data.$w$cgmapMo12
  = \ (@ k_segr1)
      (@ a_segr2)
      (@ (b_segr3 :: k_segr1))
      (w_segr5 :: Data a_segr2)
      (@ (m_segr7 :: * -> *))
      (w1_segr8 :: MonadPlus m_segr7)
      (w2_segr9 :: forall d. Data d => d -> m_segr7 d)
      (w3_segra :: Const a_segr2 b_segr3) ->
      let {
        lvl270_se9Mn :: m_segr7 (Const a_segr2 b_segr3)
        [LclId]
        lvl270_se9Mn
          = mzero @ m_segr7 w1_segr8 @ (Const a_segr2 b_segr3) } in
      let {
        $dMonad_se9rj [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_segr7
        [LclId]
        $dMonad_se9rj = GHC.Base.$p2MonadPlus @ m_segr7 w1_segr8 } in
      >>=
        @ m_segr7
        $dMonad_se9rj
        @ (Const a_segr2 b_segr3, Bool)
        @ (Const a_segr2 b_segr3)
        (let {
           lvl271_se9Mm :: m_segr7 a_segr2
           [LclId]
           lvl271_se9Mm
             = w2_segr9
                 @ a_segr2
                 w_segr5
                 (w3_segra
                  `cast` (Data.Functor.Const.N:Const[0]
                              <k_segr1>_N <a_segr2>_R <b_segr3>_P
                          :: (Const a_segr2 b_segr3 :: *) ~R# (a_segr2 :: *))) } in
         >>=
           @ m_segr7
           $dMonad_se9rj
           @ (a_segr2 -> Const a_segr2 b_segr3, Bool)
           @ (Const a_segr2 b_segr3, Bool)
           (return
              @ m_segr7
              $dMonad_se9rj
              @ (a_segr2 -> Const a_segr2 b_segr3, Bool)
              (Data.Data.$fDataConst1 @ a_segr2 @ k_segr1 @ b_segr3))
           (\ (ds_de7pD :: (a_segr2 -> Const a_segr2 b_segr3, Bool)) ->
              case ds_de7pD of { (h_ae1TP, b1_ae1TQ) ->
              case b1_ae1TQ of {
                False ->
                  mplus
                    @ m_segr7
                    w1_segr8
                    @ (Const a_segr2 b_segr3, Bool)
                    (>>=
                       @ m_segr7
                       $dMonad_se9rj
                       @ a_segr2
                       @ (Const a_segr2 b_segr3, Bool)
                       lvl271_se9Mm
                       (\ (y'_ae1TR :: a_segr2) ->
                          return
                            @ m_segr7
                            $dMonad_se9rj
                            @ (Const a_segr2 b_segr3, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_segr7
                       $dMonad_se9rj
                       @ (Const a_segr2 b_segr3, Bool)
                       (h_ae1TP
                          (w3_segra
                           `cast` (Data.Functor.Const.N:Const[0]
                                       <k_segr1>_N <a_segr2>_R <b_segr3>_P
                                   :: (Const a_segr2 b_segr3 :: *) ~R# (a_segr2 :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_segr7
                    $dMonad_se9rj
                    @ (Const a_segr2 b_segr3, Bool)
                    (h_ae1TP
                       (w3_segra
                        `cast` (Data.Functor.Const.N:Const[0]
                                    <k_segr1>_N <a_segr2>_R <b_segr3>_P
                                :: (Const a_segr2 b_segr3 :: *) ~R# (a_segr2 :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds_de7pa :: (Const a_segr2 b_segr3, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b1_ae1TT) ->
           case b1_ae1TT of {
             False -> lvl270_se9Mn;
             True ->
               return @ m_segr7 $dMonad_se9rj @ (Const a_segr2 b_segr3) x'_ae1TS
           }
           })

-- RHS size: {terms: 15, types: 35, coercions: 0, joins: 0/0}
Data.Data.$fDataConst_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall k a (b :: k).
     (Typeable k, Data a, Typeable b) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Const a b -> m (Const a b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,A><L,U><L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ k_segr1)
                 (@ a_segr2)
                 (@ (b_segr3 :: k_segr1))
                 _ [Occ=Dead]
                 (w1_segr5 [Occ=Once] :: Data a_segr2)
                 _ [Occ=Dead]
                 (@ (m_segr7 :: * -> *))
                 (w3_segr8 [Occ=Once] :: MonadPlus m_segr7)
                 (w4_segr9 [Occ=Once] :: forall d. Data d => d -> m_segr7 d)
                 (w5_segra [Occ=Once] :: Const a_segr2 b_segr3) ->
                 Data.Data.$w$cgmapMo12
                   @ k_segr1
                   @ a_segr2
                   @ b_segr3
                   w1_segr5
                   @ m_segr7
                   w3_segr8
                   w4_segr9
                   w5_segra}]
Data.Data.$fDataConst_$cgmapMo
  = \ (@ k_segr1)
      (@ a_segr2)
      (@ (b_segr3 :: k_segr1))
      _ [Occ=Dead]
      (w1_segr5 :: Data a_segr2)
      _ [Occ=Dead]
      (@ (m_segr7 :: * -> *))
      (w3_segr8 :: MonadPlus m_segr7)
      (w4_segr9 :: forall d. Data d => d -> m_segr7 d)
      (w5_segra :: Const a_segr2 b_segr3) ->
      Data.Data.$w$cgmapMo12
        @ k_segr1
        @ a_segr2
        @ b_segr3
        w1_segr5
        @ m_segr7
        w3_segr8
        w4_segr9
        w5_segra

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
lvl155_rejRl :: forall a k (b :: k). Const a b -> Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl155_rejRl
  = \ (@ a_Xe4SD)
      (@ k_Xe4SB)
      (@ (b_Xe4SF :: k_Xe4SB))
      _ [Occ=Dead] ->
      Data.Data.$cConst

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
lvl156_rejRm :: forall a k (b :: k). Const a b -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl156_rejRm
  = \ (@ a_Xe4SD)
      (@ k_Xe4SB)
      (@ (b_Xe4SF :: k_Xe4SB))
      _ [Occ=Dead] ->
      Data.Data.$tConst

-- RHS size: {terms: 8, types: 31, coercions: 0, joins: 0/0}
lvl157_rejRn
  :: forall a k (b :: k) (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Const a b))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl157_rejRn
  = \ (@ a_Xe4SD)
      (@ k_Xe4SB)
      (@ (b_Xe4SF :: k_Xe4SB))
      (@ (t_ae4dM :: * -> *))
      (@ (c_ae4dN :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae4dN (Const a_Xe4SD b_Xe4SF))

-- RHS size: {terms: 8, types: 40, coercions: 0, joins: 0/0}
lvl158_rejRo
  :: forall a k (b :: k) (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e))
     -> Maybe (c (Const a b))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl158_rejRo
  = \ (@ a_Xe4SD)
      (@ k_Xe4SB)
      (@ (b_Xe4SF :: k_Xe4SB))
      (@ (t_ae4e5 :: * -> * -> *))
      (@ (c_ae4e6 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae4e6 (Const a_Xe4SD b_Xe4SF))

-- RHS size: {terms: 109, types: 246, coercions: 63, joins: 0/0}
Data.Data.$fDataConst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k a (b :: k).
     (Typeable k, Data a, Typeable b) =>
     Data (Const a b)
[GblId[DFunId],
 Arity=3,
 Str=<L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U>,
 Unf=DFun: \ (@ k_ae1Xi)
             (@ a_ae1Xj)
             (@ (b_ae1Xk :: k_ae1Xi))
             (v_XID :: Typeable k_ae1Xi)
             (v1_XIF :: Data a_ae1Xj)
             (v2_XIH :: Typeable b_ae1Xk) ->
       Data.Data.C:Data TYPE: Const a_ae1Xj b_ae1Xk
                        (Data.Data.$fDataConst7
                           @ k_ae1Xi @ a_ae1Xj @ b_ae1Xk v_XID v1_XIF v2_XIH)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Const
                                                                                    a_ae1Xj
                                                                                    b_ae1Xk>_N
                                :: (Data.Typeable.Internal.TypeRep (Const a_ae1Xj b_ae1Xk) :: *)
                                   ~R# (Typeable (Const a_ae1Xj b_ae1Xk) :: Constraint))
                        \ (@ (c_ae4de :: * -> *))
                          (k1_ae2oQ [Occ=Once!]
                             :: forall d b1. Data d => c_ae4de (d -> b1) -> d -> c_ae4de b1)
                          (z_ae2oR [Occ=Once!] :: forall g. g -> c_ae4de g)
                          (ds_de7yb [Occ=Once] :: Const a_ae1Xj b_ae1Xk) ->
                          k1_ae2oQ
                            @ a_ae1Xj
                            @ (Const a_ae1Xj b_ae1Xk)
                            v1_XIF
                            (z_ae2oR
                               @ (a_ae1Xj -> Const a_ae1Xj b_ae1Xk)
                               ((\ (v3_XFM [Occ=Once] :: a_ae1Xj) -> v3_XFM)
                                `cast` (<a_ae1Xj>_R
                                        ->_R Sym (Data.Functor.Const.N:Const[0]
                                                      <k_ae1Xi>_N <a_ae1Xj>_R <b_ae1Xk>_P)
                                        :: (a_ae1Xj -> a_ae1Xj :: *)
                                           ~R# (a_ae1Xj -> Const a_ae1Xj b_ae1Xk :: *))))
                            (ds_de7yb
                             `cast` (Data.Functor.Const.N:Const[0]
                                         <k_ae1Xi>_N <a_ae1Xj>_R <b_ae1Xk>_P
                                     :: (Const a_ae1Xj b_ae1Xk :: *) ~R# (a_ae1Xj :: *)))
                        \ (@ (c_ae4dr :: * -> *))
                          (k1_ae2oT [Occ=Once!]
                             :: forall b1 r. Data b1 => c_ae4dr (b1 -> r) -> c_ae4dr r)
                          (z_ae2oU [Occ=Once!] :: forall r. r -> c_ae4dr r)
                          _ [Occ=Dead] ->
                          k1_ae2oT
                            @ a_ae1Xj
                            @ (Const a_ae1Xj b_ae1Xk)
                            v1_XIF
                            (z_ae2oU
                               @ (a_ae1Xj -> Const a_ae1Xj b_ae1Xk)
                               ((\ (v3_XFM [Occ=Once] :: a_ae1Xj) -> v3_XFM)
                                `cast` (<a_ae1Xj>_R
                                        ->_R Sym (Data.Functor.Const.N:Const[0]
                                                      <k_ae1Xi>_N <a_ae1Xj>_R <b_ae1Xk>_P)
                                        :: (a_ae1Xj -> a_ae1Xj :: *)
                                           ~R# (a_ae1Xj -> Const a_ae1Xj b_ae1Xk :: *))))
                        \ _ [Occ=Dead] -> Data.Data.$cConst
                        \ _ [Occ=Dead] -> Data.Data.$tConst
                        \ (@ (t_ae4dM :: * -> *))
                          (@ (c_ae4dN :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae4dN (Const a_ae1Xj b_ae1Xk))
                        \ (@ (t_ae4e5 :: * -> * -> *))
                          (@ (c_ae4e6 :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae4e6 (Const a_ae1Xj b_ae1Xk))
                        (\ (ds_de7yi [Occ=Once!] :: forall b1. Data b1 => b1 -> b1)
                           (x0_Xe31S [Occ=Once] :: Const a_ae1Xj b_ae1Xk) ->
                           ds_de7yi
                             @ a_ae1Xj
                             v1_XIF
                             (x0_Xe31S
                              `cast` (Data.Functor.Const.N:Const[0]
                                          <k_ae1Xi>_N <a_ae1Xj>_R <b_ae1Xk>_P
                                      :: (Const a_ae1Xj b_ae1Xk :: *) ~R# (a_ae1Xj :: *))))
                        `cast` (<forall b1. Data b1 => b1 -> b1>_R
                                ->_R <Const a_ae1Xj b_ae1Xk>_R
                                ->_R Sym (Data.Functor.Const.N:Const[0]
                                              <k_ae1Xi>_N <a_ae1Xj>_R <b_ae1Xk>_P)
                                :: ((forall b1. Data b1 => b1 -> b1)
                                    -> Const a_ae1Xj b_ae1Xk -> a_ae1Xj :: *)
                                   ~R# ((forall b1. Data b1 => b1 -> b1)
                                        -> Const a_ae1Xj b_ae1Xk -> Const a_ae1Xj b_ae1Xk :: *))
                        \ (@ r_ae4eD)
                          (@ r'_ae4eE)
                          (ds_de7yj [Occ=Once!] :: r_ae4eD -> r'_ae4eE -> r_ae4eD)
                          (ds1_de7yk [Occ=Once] :: r_ae4eD)
                          (ds2_de7yl [Occ=Once!] :: forall d. Data d => d -> r'_ae4eE)
                          (eta_XIA [Occ=Once] :: Const a_ae1Xj b_ae1Xk) ->
                          ds_de7yj
                            ds1_de7yk
                            (ds2_de7yl
                               @ a_ae1Xj
                               v1_XIF
                               (eta_XIA
                                `cast` (Data.Functor.Const.N:Const[0]
                                            <k_ae1Xi>_N <a_ae1Xj>_R <b_ae1Xk>_P
                                        :: (Const a_ae1Xj b_ae1Xk :: *) ~R# (a_ae1Xj :: *))))
                        \ (@ r_ae4eU)
                          (@ r'_ae4eV)
                          (ds_de7ym [Occ=Once!] :: r'_ae4eV -> r_ae4eU -> r_ae4eU)
                          (ds1_de7yn [Occ=Once] :: r_ae4eU)
                          (ds2_de7yo [Occ=Once!] :: forall d. Data d => d -> r'_ae4eV)
                          (x0_ae1SX [Occ=Once] :: Const a_ae1Xj b_ae1Xk) ->
                          ds_de7ym
                            (ds2_de7yo
                               @ a_ae1Xj
                               v1_XIF
                               (x0_ae1SX
                                `cast` (Data.Functor.Const.N:Const[0]
                                            <k_ae1Xi>_N <a_ae1Xj>_R <b_ae1Xk>_P
                                        :: (Const a_ae1Xj b_ae1Xk :: *) ~R# (a_ae1Xj :: *))))
                            ds1_de7yn
                        \ (@ u_ae4fb)
                          (ds_de7yp [Occ=Once!] :: forall d. Data d => d -> u_ae4fb)
                          (x0_ae1SX [Occ=Once] :: Const a_ae1Xj b_ae1Xk) ->
                          GHC.Types.:
                            @ u_ae4fb
                            (ds_de7yp
                               @ a_ae1Xj
                               v1_XIF
                               (x0_ae1SX
                                `cast` (Data.Functor.Const.N:Const[0]
                                            <k_ae1Xi>_N <a_ae1Xj>_R <b_ae1Xk>_P
                                        :: (Const a_ae1Xj b_ae1Xk :: *) ~R# (a_ae1Xj :: *))))
                            (GHC.Types.[] @ u_ae4fb)
                        \ (@ u_ae4fp)
                          (ds_de7yq [Occ=Once!] :: Int)
                          (ds1_de7yr [Occ=Once!] :: forall d. Data d => d -> u_ae4fp)
                          (x_ae1T7 [Occ=Once] :: Const a_ae1Xj b_ae1Xk) ->
                          case ds_de7yq of { I# x1_a22G [Occ=Once!] ->
                          case x1_a22G of {
                            __DEFAULT -> Data.Maybe.fromJust1 @ u_ae4fp;
                            0# ->
                              ds1_de7yr
                                @ a_ae1Xj
                                v1_XIF
                                (x_ae1T7
                                 `cast` (Data.Functor.Const.N:Const[0]
                                             <k_ae1Xi>_N <a_ae1Xj>_R <b_ae1Xk>_P
                                         :: (Const a_ae1Xj b_ae1Xk :: *) ~R# (a_ae1Xj :: *)))
                          }
                          }
                        Data.Data.$fDataConst_$cgmapM
                          @ k_ae1Xi @ a_ae1Xj @ b_ae1Xk v_XID v1_XIF v2_XIH
                        Data.Data.$fDataConst_$cgmapMp
                          @ k_ae1Xi @ a_ae1Xj @ b_ae1Xk v_XID v1_XIF v2_XIH
                        Data.Data.$fDataConst_$cgmapMo
                          @ k_ae1Xi @ a_ae1Xj @ b_ae1Xk v_XID v1_XIF v2_XIH]
Data.Data.$fDataConst
  = \ (@ k_Xe4SB)
      (@ a_Xe4SD)
      (@ (b_Xe4SF :: k_Xe4SB))
      ($dTypeable_Xe4SH :: Typeable k_Xe4SB)
      ($dData_Xe4SJ :: Data a_Xe4SD)
      ($dTypeable1_Xe4SL :: Typeable b_Xe4SF) ->
      Data.Data.C:Data
        @ (Const a_Xe4SD b_Xe4SF)
        ((Data.Data.$fDataConst7
            @ k_Xe4SB
            @ a_Xe4SD
            @ b_Xe4SF
            $dTypeable_Xe4SH
            $dData_Xe4SJ
            $dTypeable1_Xe4SL)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Const
                                                                     a_Xe4SD b_Xe4SF>_N
                 :: (Data.Typeable.Internal.TypeRep (Const a_Xe4SD b_Xe4SF) :: *)
                    ~R# (Typeable (Const a_Xe4SD b_Xe4SF) :: Constraint)))
        (\ (@ (c_ae4de :: * -> *))
           (k1_ae2oQ
              :: forall d b1. Data d => c_ae4de (d -> b1) -> d -> c_ae4de b1)
           (z_ae2oR :: forall g. g -> c_ae4de g)
           (ds_de7yb :: Const a_Xe4SD b_Xe4SF) ->
           k1_ae2oQ
             @ a_Xe4SD
             @ (Const a_Xe4SD b_Xe4SF)
             $dData_Xe4SJ
             (z_ae2oR
                @ (a_Xe4SD -> Const a_Xe4SD b_Xe4SF)
                ((Data.Data.$fDataConst2 @ a_Xe4SD)
                 `cast` (<a_Xe4SD>_R
                         ->_R Sym (Data.Functor.Const.N:Const[0]
                                       <k_Xe4SB>_N <a_Xe4SD>_R <b_Xe4SF>_P)
                         :: (a_Xe4SD -> a_Xe4SD :: *)
                            ~R# (a_Xe4SD -> Const a_Xe4SD b_Xe4SF :: *))))
             (ds_de7yb
              `cast` (Data.Functor.Const.N:Const[0]
                          <k_Xe4SB>_N <a_Xe4SD>_R <b_Xe4SF>_P
                      :: (Const a_Xe4SD b_Xe4SF :: *) ~R# (a_Xe4SD :: *))))
        (\ (@ (c_ae4dr :: * -> *))
           (k1_ae2oT
              :: forall b1 r. Data b1 => c_ae4dr (b1 -> r) -> c_ae4dr r)
           (z_ae2oU :: forall r. r -> c_ae4dr r)
           _ [Occ=Dead] ->
           k1_ae2oT
             @ a_Xe4SD
             @ (Const a_Xe4SD b_Xe4SF)
             $dData_Xe4SJ
             (z_ae2oU
                @ (a_Xe4SD -> Const a_Xe4SD b_Xe4SF)
                ((Data.Data.$fDataConst2 @ a_Xe4SD)
                 `cast` (<a_Xe4SD>_R
                         ->_R Sym (Data.Functor.Const.N:Const[0]
                                       <k_Xe4SB>_N <a_Xe4SD>_R <b_Xe4SF>_P)
                         :: (a_Xe4SD -> a_Xe4SD :: *)
                            ~R# (a_Xe4SD -> Const a_Xe4SD b_Xe4SF :: *)))))
        (lvl155_rejRl @ a_Xe4SD @ k_Xe4SB @ b_Xe4SF)
        (lvl156_rejRm @ a_Xe4SD @ k_Xe4SB @ b_Xe4SF)
        (lvl157_rejRn @ a_Xe4SD @ k_Xe4SB @ b_Xe4SF)
        (lvl158_rejRo @ a_Xe4SD @ k_Xe4SB @ b_Xe4SF)
        ((\ (ds_de7yi :: forall b1. Data b1 => b1 -> b1)
            (x0_Xe31S :: Const a_Xe4SD b_Xe4SF) ->
            ds_de7yi
              @ a_Xe4SD
              $dData_Xe4SJ
              (x0_Xe31S
               `cast` (Data.Functor.Const.N:Const[0]
                           <k_Xe4SB>_N <a_Xe4SD>_R <b_Xe4SF>_P
                       :: (Const a_Xe4SD b_Xe4SF :: *) ~R# (a_Xe4SD :: *))))
         `cast` (<forall b1. Data b1 => b1 -> b1>_R
                 ->_R <Const a_Xe4SD b_Xe4SF>_R
                 ->_R Sym (Data.Functor.Const.N:Const[0]
                               <k_Xe4SB>_N <a_Xe4SD>_R <b_Xe4SF>_P)
                 :: ((forall b1. Data b1 => b1 -> b1)
                     -> Const a_Xe4SD b_Xe4SF -> a_Xe4SD :: *)
                    ~R# ((forall b1. Data b1 => b1 -> b1)
                         -> Const a_Xe4SD b_Xe4SF -> Const a_Xe4SD b_Xe4SF :: *)))
        (\ (@ r_ae4eD)
           (@ r'_ae4eE)
           (ds_de7yj :: r_ae4eD -> r'_ae4eE -> r_ae4eD)
           (ds1_de7yk :: r_ae4eD)
           (ds2_de7yl :: forall d. Data d => d -> r'_ae4eE)
           (eta_XIA :: Const a_Xe4SD b_Xe4SF) ->
           ds_de7yj
             ds1_de7yk
             (ds2_de7yl
                @ a_Xe4SD
                $dData_Xe4SJ
                (eta_XIA
                 `cast` (Data.Functor.Const.N:Const[0]
                             <k_Xe4SB>_N <a_Xe4SD>_R <b_Xe4SF>_P
                         :: (Const a_Xe4SD b_Xe4SF :: *) ~R# (a_Xe4SD :: *)))))
        (\ (@ r_ae4eU)
           (@ r'_ae4eV)
           (ds_de7ym :: r'_ae4eV -> r_ae4eU -> r_ae4eU)
           (ds1_de7yn :: r_ae4eU)
           (ds2_de7yo :: forall d. Data d => d -> r'_ae4eV)
           (x0_ae1SX :: Const a_Xe4SD b_Xe4SF) ->
           ds_de7ym
             (ds2_de7yo
                @ a_Xe4SD
                $dData_Xe4SJ
                (x0_ae1SX
                 `cast` (Data.Functor.Const.N:Const[0]
                             <k_Xe4SB>_N <a_Xe4SD>_R <b_Xe4SF>_P
                         :: (Const a_Xe4SD b_Xe4SF :: *) ~R# (a_Xe4SD :: *))))
             ds1_de7yn)
        (\ (@ u_ae4fb)
           (ds_de7yp :: forall d. Data d => d -> u_ae4fb)
           (x0_ae1SX :: Const a_Xe4SD b_Xe4SF) ->
           GHC.Types.:
             @ u_ae4fb
             (ds_de7yp
                @ a_Xe4SD
                $dData_Xe4SJ
                (x0_ae1SX
                 `cast` (Data.Functor.Const.N:Const[0]
                             <k_Xe4SB>_N <a_Xe4SD>_R <b_Xe4SF>_P
                         :: (Const a_Xe4SD b_Xe4SF :: *) ~R# (a_Xe4SD :: *))))
             (GHC.Types.[] @ u_ae4fb))
        (\ (@ u_ae4fp)
           (ds_de7yq :: Int)
           (ds1_de7yr :: forall d. Data d => d -> u_ae4fp)
           (x_ae1T7 :: Const a_Xe4SD b_Xe4SF) ->
           case ds_de7yq of { I# x1_a22G ->
           case x1_a22G of {
             __DEFAULT -> Data.Maybe.fromJust1 @ u_ae4fp;
             0# ->
               ds1_de7yr
                 @ a_Xe4SD
                 $dData_Xe4SJ
                 (x_ae1T7
                  `cast` (Data.Functor.Const.N:Const[0]
                              <k_Xe4SB>_N <a_Xe4SD>_R <b_Xe4SF>_P
                          :: (Const a_Xe4SD b_Xe4SF :: *) ~R# (a_Xe4SD :: *)))
           }
           })
        (\ (@ (m_segqW :: * -> *))
           (w_segqX :: Monad m_segqW)
           (w1_segqY :: forall d. Data d => d -> m_segqW d)
           (w2_segqZ :: Const a_Xe4SD b_Xe4SF) ->
           Data.Data.$w$cgmapM9
             @ k_Xe4SB
             @ a_Xe4SD
             @ b_Xe4SF
             $dData_Xe4SJ
             @ m_segqW
             w_segqX
             w1_segqY
             w2_segqZ)
        (\ (@ (m_segqL :: * -> *))
           (w_segqM :: MonadPlus m_segqL)
           (w1_segqN :: forall d. Data d => d -> m_segqL d)
           (w2_segqO :: Const a_Xe4SD b_Xe4SF) ->
           Data.Data.$w$cgmapMp13
             @ k_Xe4SB
             @ a_Xe4SD
             @ b_Xe4SF
             $dData_Xe4SJ
             @ m_segqL
             w_segqM
             w1_segqN
             w2_segqO)
        (\ (@ (m_segr7 :: * -> *))
           (w_segr8 :: MonadPlus m_segr7)
           (w1_segr9 :: forall d. Data d => d -> m_segr7 d)
           (w2_segra :: Const a_Xe4SD b_Xe4SF) ->
           Data.Data.$w$cgmapMo12
             @ k_Xe4SB
             @ a_Xe4SD
             @ b_Xe4SF
             $dData_Xe4SJ
             @ m_segr7
             w_segr8
             w1_segr9
             w2_segra)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataVersion7 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fDataVersion7 = "Version"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataVersion6 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataVersion6 = unpackCString# Data.Data.$fDataVersion7

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$cVersion1_rejRp :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$cVersion1_rejRp = "versionBranch"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cVersion2_rejRq :: [Char]
[GblId]
$cVersion2_rejRq = unpackCString# $cVersion1_rejRp

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$cVersion3_rejRr :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$cVersion3_rejRr = "versionTags"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cVersion4_rejRs :: [Char]
[GblId]
$cVersion4_rejRs = unpackCString# $cVersion3_rejRr

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$cVersion5_rejRt :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cVersion5_rejRt
  = GHC.Types.: @ String $cVersion4_rejRs (GHC.Types.[] @ String)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$cVersion6_rejRu :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cVersion6_rejRu
  = GHC.Types.: @ String $cVersion2_rejRq $cVersion5_rejRt

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go26_rejRv :: [Constr] -> [Int] -> Int
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go26_rejRv
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fDataVersion6 of {
                False -> go26_rejRv ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cVersion7_rejRw :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cVersion7_rejRw = Data.Data.AlgConstr $cVersion8_rejRx

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataVersion5 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataVersion5
  = GHC.Types.: @ Constr Data.Data.$cVersion (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataVersion4 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataVersion4
  = Data.Data.AlgRep Data.Data.$fDataVersion5

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tVersion :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$tVersion
  = Data.Data.DataType
      Data.Data.$fDataVersion6 Data.Data.$fDataVersion4

-- RHS size: {terms: 6, types: 0, coercions: 0, joins: 0/0}
Data.Data.$cVersion [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cVersion
  = Data.Data.Constr
      $cVersion7_rejRw
      Data.Data.$fDataVersion6
      $cVersion6_rejRu
      Data.Data.Prefix
      Data.Data.$tVersion

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cVersion8_rejRx :: Int
[GblId]
$cVersion8_rejRx
  = go26_rejRv Data.Data.$fDataVersion5 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataVersion_$cdataTypeOf :: Version -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Data.$tVersion}]
Data.Data.$fDataVersion_$cdataTypeOf
  = \ _ [Occ=Dead] -> Data.Data.$tVersion

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Data.$fDataVersion_$ctoConstr :: Version -> Constr
[GblId,
 Arity=1,
 Str=<S,1*H>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_de7xS [Occ=Once!] :: Version) ->
                 case ds_de7xS of { Version _ [Occ=Dead] _ [Occ=Dead] ->
                 Data.Data.$cVersion
                 }}]
Data.Data.$fDataVersion_$ctoConstr
  = \ (ds_de7xS :: Version) ->
      case ds_de7xS of { Version ds1_de7xT ds2_de7xU ->
      Data.Data.$cVersion
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataDual6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataDual6 = "Dual"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataDual5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataDual5 = unpackCString# Data.Data.$fDataDual6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$cDual1_rejRy :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$cDual1_rejRy = "getDual"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cDual2_rejRz :: [Char]
[GblId]
$cDual2_rejRz = unpackCString# $cDual1_rejRy

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$cDual3_rejRA :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cDual3_rejRA
  = GHC.Types.: @ String $cDual2_rejRz (GHC.Types.[] @ String)

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go27_rejRB :: [Constr] -> [Int] -> Int
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go27_rejRB
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fDataDual5 of {
                False -> go27_rejRB ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cDual4_rejRC :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cDual4_rejRC = Data.Data.AlgConstr $cDual5_rejRD

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataDual4 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataDual4
  = GHC.Types.: @ Constr Data.Data.$cDual (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataDual3 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataDual3 = Data.Data.AlgRep Data.Data.$fDataDual4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tDual :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$tDual
  = Data.Data.DataType Data.Data.$fDataDual5 Data.Data.$fDataDual3

-- RHS size: {terms: 6, types: 0, coercions: 0, joins: 0/0}
Data.Data.$cDual [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cDual
  = Data.Data.Constr
      $cDual4_rejRC
      Data.Data.$fDataDual5
      $cDual3_rejRA
      Data.Data.Prefix
      Data.Data.$tDual

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cDual5_rejRD :: Int
[GblId]
$cDual5_rejRD
  = go27_rejRB Data.Data.$fDataDual4 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 4, types: 7, coercions: 5, joins: 0/0}
Data.Data.$fDataDual1 :: forall a. (a -> Dual a, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataDual1
  = \ (@ a_Xe4MD) ->
      ((Data.Data.$fDataConst2 @ a_Xe4MD)
       `cast` (<a_Xe4MD>_R
               ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <a_Xe4MD>_R)
               :: (a_Xe4MD -> a_Xe4MD :: *) ~R# (a_Xe4MD -> Dual a_Xe4MD :: *)),
       GHC.Types.False)

-- RHS size: {terms: 57, types: 112, coercions: 4, joins: 0/3}
Data.Data.$fDataDual_$cgmapMp
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Dual a -> m (Dual a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 510 0}]
Data.Data.$fDataDual_$cgmapMp
  = \ (@ a_Xe4MD)
      ($dData_Xe4MF :: Data a_Xe4MD)
      (@ (m_ae49f :: * -> *))
      ($dMonadPlus_ae49h :: MonadPlus m_ae49f)
      (ds_de7xO :: forall d. Data d => d -> m_ae49f d)
      (eta_XIT :: Dual a_Xe4MD) ->
      let {
        lvl270_se9MW :: m_ae49f (Dual a_Xe4MD)
        [LclId]
        lvl270_se9MW
          = mzero @ m_ae49f $dMonadPlus_ae49h @ (Dual a_Xe4MD) } in
      let {
        $dMonad_se9rh [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae49f
        [LclId]
        $dMonad_se9rh
          = GHC.Base.$p2MonadPlus @ m_ae49f $dMonadPlus_ae49h } in
      >>=
        @ m_ae49f
        $dMonad_se9rh
        @ (Dual a_Xe4MD, Bool)
        @ (Dual a_Xe4MD)
        (let {
           lvl271_se9MV :: m_ae49f a_Xe4MD
           [LclId]
           lvl271_se9MV
             = ds_de7xO
                 @ a_Xe4MD
                 $dData_Xe4MF
                 (eta_XIT
                  `cast` (Data.Semigroup.Internal.N:Dual[0] <a_Xe4MD>_R
                          :: (Dual a_Xe4MD :: *) ~R# (a_Xe4MD :: *))) } in
         >>=
           @ m_ae49f
           $dMonad_se9rh
           @ (a_Xe4MD -> Dual a_Xe4MD, Bool)
           @ (Dual a_Xe4MD, Bool)
           (return
              @ m_ae49f
              $dMonad_se9rh
              @ (a_Xe4MD -> Dual a_Xe4MD, Bool)
              (Data.Data.$fDataDual1 @ a_Xe4MD))
           (\ (ds1_de7oD :: (a_Xe4MD -> Dual a_Xe4MD, Bool)) ->
              case ds1_de7oD of { (h_ae1TA, b_ae1TB) ->
              mplus
                @ m_ae49f
                $dMonadPlus_ae49h
                @ (Dual a_Xe4MD, Bool)
                (>>=
                   @ m_ae49f
                   $dMonad_se9rh
                   @ a_Xe4MD
                   @ (Dual a_Xe4MD, Bool)
                   lvl271_se9MV
                   (\ (y'_ae1TC :: a_Xe4MD) ->
                      return
                        @ m_ae49f
                        $dMonad_se9rh
                        @ (Dual a_Xe4MD, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_ae49f
                   $dMonad_se9rh
                   @ (Dual a_Xe4MD, Bool)
                   (h_ae1TA
                      (eta_XIT
                       `cast` (Data.Semigroup.Internal.N:Dual[0] <a_Xe4MD>_R
                               :: (Dual a_Xe4MD :: *) ~R# (a_Xe4MD :: *))),
                    b_ae1TB))
              }))
        (\ (ds1_de7oa :: (Dual a_Xe4MD, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9MW;
             True -> return @ m_ae49f $dMonad_se9rh @ (Dual a_Xe4MD) x'_ae1TD
           }
           })

-- RHS size: {terms: 24, types: 44, coercions: 7, joins: 0/1}
Data.Data.$fDataDual_$cgmapM
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Dual a -> m (Dual a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120 60 0] 220 0}]
Data.Data.$fDataDual_$cgmapM
  = \ (@ a_Xe4MC)
      ($dData_Xe4ME :: Data a_Xe4MC)
      (@ (m_ae48Z :: * -> *))
      ($dMonad_ae491 :: Monad m_ae48Z)
      (ds_de7xN :: forall d. Data d => d -> m_ae48Z d)
      (eta_XIU :: Dual a_Xe4MC) ->
      let {
        lvl270_se9MY :: m_ae48Z a_Xe4MC
        [LclId]
        lvl270_se9MY
          = ds_de7xN
              @ a_Xe4MC
              $dData_Xe4ME
              (eta_XIU
               `cast` (Data.Semigroup.Internal.N:Dual[0] <a_Xe4MC>_R
                       :: (Dual a_Xe4MC :: *) ~R# (a_Xe4MC :: *))) } in
      >>=
        @ m_ae48Z
        $dMonad_ae491
        @ (a_Xe4MC -> Dual a_Xe4MC)
        @ (Dual a_Xe4MC)
        (return
           @ m_ae48Z
           $dMonad_ae491
           @ (a_Xe4MC -> Dual a_Xe4MC)
           ((Data.Data.$fDataConst2 @ a_Xe4MC)
            `cast` (<a_Xe4MC>_R
                    ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <a_Xe4MC>_R)
                    :: (a_Xe4MC -> a_Xe4MC :: *) ~R# (a_Xe4MC -> Dual a_Xe4MC :: *))))
        (\ (c'_ae1To :: a_Xe4MC -> Dual a_Xe4MC) ->
           >>=
             @ m_ae48Z
             $dMonad_ae491
             @ a_Xe4MC
             @ (Dual a_Xe4MC)
             lvl270_se9MY
             (\ (x'_ae1Tp :: a_Xe4MC) ->
                return
                  @ m_ae48Z $dMonad_ae491 @ (Dual a_Xe4MC) (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 17, types: 20, coercions: 2, joins: 0/0}
Data.Data.$fDataDual_$cgmapQi
  :: forall a.
     Data a =>
     forall u. Int -> (forall d. Data d => d -> u) -> Dual a -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe4MB)
                 ($dData_Xe4MD [Occ=Once] :: Data a_Xe4MB)
                 (@ u_ae48L)
                 (ds_de7xL [Occ=Once!] :: Int)
                 (ds1_de7xM [Occ=Once!] :: forall d. Data d => d -> u_ae48L)
                 (x_ae1T7 [Occ=Once] :: Dual a_Xe4MB) ->
                 case ds_de7xL of { I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_ae48L;
                   0# ->
                     ds1_de7xM
                       @ a_Xe4MB
                       $dData_Xe4MD
                       (x_ae1T7
                        `cast` (Data.Semigroup.Internal.N:Dual[0] <a_Xe4MB>_R
                                :: (Dual a_Xe4MB :: *) ~R# (a_Xe4MB :: *)))
                 }
                 }}]
Data.Data.$fDataDual_$cgmapQi
  = \ (@ a_Xe4MB)
      ($dData_Xe4MD :: Data a_Xe4MB)
      (@ u_ae48L)
      (ds_de7xL :: Int)
      (ds1_de7xM :: forall d. Data d => d -> u_ae48L)
      (x_ae1T7 :: Dual a_Xe4MB) ->
      case ds_de7xL of { I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_ae48L;
        0# ->
          ds1_de7xM
            @ a_Xe4MB
            $dData_Xe4MD
            (x_ae1T7
             `cast` (Data.Semigroup.Internal.N:Dual[0] <a_Xe4MB>_R
                     :: (Dual a_Xe4MB :: *) ~R# (a_Xe4MB :: *)))
      }
      }

-- RHS size: {terms: 67, types: 121, coercions: 6, joins: 0/3}
Data.Data.$fDataDual_$cgmapMo
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Dual a -> m (Dual a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 590 0}]
Data.Data.$fDataDual_$cgmapMo
  = \ (@ a_Xe4Mw)
      ($dData_Xe4My :: Data a_Xe4Mw)
      (@ (m_ae49v :: * -> *))
      ($dMonadPlus_ae49x :: MonadPlus m_ae49v)
      (ds_de7xP :: forall d. Data d => d -> m_ae49v d)
      (eta_XJ3 :: Dual a_Xe4Mw) ->
      let {
        lvl270_se9N3 :: m_ae49v (Dual a_Xe4Mw)
        [LclId]
        lvl270_se9N3
          = mzero @ m_ae49v $dMonadPlus_ae49x @ (Dual a_Xe4Mw) } in
      let {
        $dMonad_se9rf [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae49v
        [LclId]
        $dMonad_se9rf
          = GHC.Base.$p2MonadPlus @ m_ae49v $dMonadPlus_ae49x } in
      >>=
        @ m_ae49v
        $dMonad_se9rf
        @ (Dual a_Xe4Mw, Bool)
        @ (Dual a_Xe4Mw)
        (let {
           lvl271_se9N2 :: m_ae49v a_Xe4Mw
           [LclId]
           lvl271_se9N2
             = ds_de7xP
                 @ a_Xe4Mw
                 $dData_Xe4My
                 (eta_XJ3
                  `cast` (Data.Semigroup.Internal.N:Dual[0] <a_Xe4Mw>_R
                          :: (Dual a_Xe4Mw :: *) ~R# (a_Xe4Mw :: *))) } in
         >>=
           @ m_ae49v
           $dMonad_se9rf
           @ (a_Xe4Mw -> Dual a_Xe4Mw, Bool)
           @ (Dual a_Xe4Mw, Bool)
           (return
              @ m_ae49v
              $dMonad_se9rf
              @ (a_Xe4Mw -> Dual a_Xe4Mw, Bool)
              (Data.Data.$fDataDual1 @ a_Xe4Mw))
           (\ (ds1_de7pD :: (a_Xe4Mw -> Dual a_Xe4Mw, Bool)) ->
              case ds1_de7pD of { (h_ae1TP, b_ae1TQ) ->
              case b_ae1TQ of {
                False ->
                  mplus
                    @ m_ae49v
                    $dMonadPlus_ae49x
                    @ (Dual a_Xe4Mw, Bool)
                    (>>=
                       @ m_ae49v
                       $dMonad_se9rf
                       @ a_Xe4Mw
                       @ (Dual a_Xe4Mw, Bool)
                       lvl271_se9N2
                       (\ (y'_ae1TR :: a_Xe4Mw) ->
                          return
                            @ m_ae49v
                            $dMonad_se9rf
                            @ (Dual a_Xe4Mw, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_ae49v
                       $dMonad_se9rf
                       @ (Dual a_Xe4Mw, Bool)
                       (h_ae1TP
                          (eta_XJ3
                           `cast` (Data.Semigroup.Internal.N:Dual[0] <a_Xe4Mw>_R
                                   :: (Dual a_Xe4Mw :: *) ~R# (a_Xe4Mw :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_ae49v
                    $dMonad_se9rf
                    @ (Dual a_Xe4Mw, Bool)
                    (h_ae1TP
                       (eta_XJ3
                        `cast` (Data.Semigroup.Internal.N:Dual[0] <a_Xe4Mw>_R
                                :: (Dual a_Xe4Mw :: *) ~R# (a_Xe4Mw :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds1_de7pa :: (Dual a_Xe4Mw, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9N3;
             True -> return @ m_ae49v $dMonad_se9rf @ (Dual a_Xe4Mw) x'_ae1TS
           }
           })

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl159_rejRE :: forall a. Dual a -> Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl159_rejRE = \ (@ a_Xe4Mv) _ [Occ=Dead] -> Data.Data.$cDual

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl160_rejRF :: forall a. Dual a -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl160_rejRF = \ (@ a_Xe4Mv) _ [Occ=Dead] -> Data.Data.$tDual

-- RHS size: {terms: 6, types: 35, coercions: 0, joins: 0/0}
lvl161_rejRG
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c (Dual a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl161_rejRG
  = \ (@ a_Xe4Mv)
      (@ (t_ae47r :: * -> * -> *))
      (@ (c_ae47s :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae47s (Dual a_Xe4Mv))

-- RHS size: {terms: 63, types: 100, coercions: 32, joins: 0/0}
Data.Data.$fDataDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data a => Data (Dual a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_ae1Xh) (v_XJ0 :: Data a_ae1Xh) ->
       Data.Data.C:Data TYPE: Dual a_ae1Xh
                        (Data.Data.$fDataDual7 @ a_ae1Xh v_XJ0)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Dual
                                                                                    a_ae1Xh>_N
                                :: (Data.Typeable.Internal.TypeRep (Dual a_ae1Xh) :: *)
                                   ~R# (Typeable (Dual a_ae1Xh) :: Constraint))
                        Data.Data.$fDataDual_$cgfoldl @ a_ae1Xh v_XJ0
                        \ (@ (c_ae46Q :: * -> *))
                          (k_ae2oH [Occ=Once!]
                             :: forall b r. Data b => c_ae46Q (b -> r) -> c_ae46Q r)
                          (z_ae2oI [Occ=Once!] :: forall r. r -> c_ae46Q r)
                          _ [Occ=Dead] ->
                          k_ae2oH
                            @ a_ae1Xh
                            @ (Dual a_ae1Xh)
                            v_XJ0
                            (z_ae2oI
                               @ (a_ae1Xh -> Dual a_ae1Xh)
                               ((Data.Data.$fDataConst2 @ a_ae1Xh)
                                `cast` (<a_ae1Xh>_R
                                        ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <a_ae1Xh>_R)
                                        :: (a_ae1Xh -> a_ae1Xh :: *)
                                           ~R# (a_ae1Xh -> Dual a_ae1Xh :: *))))
                        \ _ [Occ=Dead] -> Data.Data.$cDual
                        \ _ [Occ=Dead] -> Data.Data.$tDual
                        Data.Data.$fDataDual_$cdataCast1 @ a_ae1Xh v_XJ0
                        \ (@ (t_ae47r :: * -> * -> *))
                          (@ (c_ae47s :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae47s (Dual a_ae1Xh))
                        (\ (ds_de7xD [Occ=Once!] :: forall b. Data b => b -> b)
                           (x0_Xe32i [Occ=Once] :: Dual a_ae1Xh) ->
                           ds_de7xD
                             @ a_ae1Xh
                             v_XJ0
                             (x0_Xe32i
                              `cast` (Data.Semigroup.Internal.N:Dual[0] <a_ae1Xh>_R
                                      :: (Dual a_ae1Xh :: *) ~R# (a_ae1Xh :: *))))
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <Dual a_ae1Xh>_R
                                ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <a_ae1Xh>_R)
                                :: ((forall b. Data b => b -> b) -> Dual a_ae1Xh -> a_ae1Xh :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> Dual a_ae1Xh -> Dual a_ae1Xh :: *))
                        \ (@ r_ae47Z)
                          (@ r'_ae480)
                          (ds_de7xE [Occ=Once!] :: r_ae47Z -> r'_ae480 -> r_ae47Z)
                          (ds1_de7xF [Occ=Once] :: r_ae47Z)
                          (ds2_de7xG [Occ=Once!] :: forall d. Data d => d -> r'_ae480)
                          (eta_X1s6 [Occ=Once] :: Dual a_ae1Xh) ->
                          ds_de7xE
                            ds1_de7xF
                            (ds2_de7xG
                               @ a_ae1Xh
                               v_XJ0
                               (eta_X1s6
                                `cast` (Data.Semigroup.Internal.N:Dual[0] <a_ae1Xh>_R
                                        :: (Dual a_ae1Xh :: *) ~R# (a_ae1Xh :: *))))
                        \ (@ r_ae48g)
                          (@ r'_ae48h)
                          (ds_de7xH [Occ=Once!] :: r'_ae48h -> r_ae48g -> r_ae48g)
                          (ds1_de7xI [Occ=Once] :: r_ae48g)
                          (ds2_de7xJ [Occ=Once!] :: forall d. Data d => d -> r'_ae48h)
                          (x0_ae1SX [Occ=Once] :: Dual a_ae1Xh) ->
                          ds_de7xH
                            (ds2_de7xJ
                               @ a_ae1Xh
                               v_XJ0
                               (x0_ae1SX
                                `cast` (Data.Semigroup.Internal.N:Dual[0] <a_ae1Xh>_R
                                        :: (Dual a_ae1Xh :: *) ~R# (a_ae1Xh :: *))))
                            ds1_de7xI
                        \ (@ u_ae48x)
                          (ds_de7xK [Occ=Once!] :: forall d. Data d => d -> u_ae48x)
                          (x0_ae1SX [Occ=Once] :: Dual a_ae1Xh) ->
                          GHC.Types.:
                            @ u_ae48x
                            (ds_de7xK
                               @ a_ae1Xh
                               v_XJ0
                               (x0_ae1SX
                                `cast` (Data.Semigroup.Internal.N:Dual[0] <a_ae1Xh>_R
                                        :: (Dual a_ae1Xh :: *) ~R# (a_ae1Xh :: *))))
                            (GHC.Types.[] @ u_ae48x)
                        Data.Data.$fDataDual_$cgmapQi @ a_ae1Xh v_XJ0
                        Data.Data.$fDataDual_$cgmapM @ a_ae1Xh v_XJ0
                        Data.Data.$fDataDual_$cgmapMp @ a_ae1Xh v_XJ0
                        Data.Data.$fDataDual_$cgmapMo @ a_ae1Xh v_XJ0]
Data.Data.$fDataDual
  = \ (@ a_Xe4Mv) ($dData_Xe5vw :: Data a_Xe4Mv) ->
      Data.Data.C:Data
        @ (Dual a_Xe4Mv)
        ((Data.Data.$fDataDual7 @ a_Xe4Mv $dData_Xe5vw)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Dual
                                                                     a_Xe4Mv>_N
                 :: (Data.Typeable.Internal.TypeRep (Dual a_Xe4Mv) :: *)
                    ~R# (Typeable (Dual a_Xe4Mv) :: Constraint)))
        (Data.Data.$fDataDual_$cgfoldl @ a_Xe4Mv $dData_Xe5vw)
        (\ (@ (c_ae46Q :: * -> *))
           (k_ae2oH :: forall b r. Data b => c_ae46Q (b -> r) -> c_ae46Q r)
           (z_ae2oI :: forall r. r -> c_ae46Q r)
           _ [Occ=Dead] ->
           k_ae2oH
             @ a_Xe4Mv
             @ (Dual a_Xe4Mv)
             $dData_Xe5vw
             (z_ae2oI
                @ (a_Xe4Mv -> Dual a_Xe4Mv)
                ((Data.Data.$fDataConst2 @ a_Xe4Mv)
                 `cast` (<a_Xe4Mv>_R
                         ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <a_Xe4Mv>_R)
                         :: (a_Xe4Mv -> a_Xe4Mv :: *) ~R# (a_Xe4Mv -> Dual a_Xe4Mv :: *)))))
        (lvl159_rejRE @ a_Xe4Mv)
        (lvl160_rejRF @ a_Xe4Mv)
        (Data.Data.$fDataDual_$cdataCast1 @ a_Xe4Mv $dData_Xe5vw)
        (lvl161_rejRG @ a_Xe4Mv)
        ((\ (ds_de7xD :: forall b. Data b => b -> b)
            (x0_Xe32i :: Dual a_Xe4Mv) ->
            ds_de7xD
              @ a_Xe4Mv
              $dData_Xe5vw
              (x0_Xe32i
               `cast` (Data.Semigroup.Internal.N:Dual[0] <a_Xe4Mv>_R
                       :: (Dual a_Xe4Mv :: *) ~R# (a_Xe4Mv :: *))))
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <Dual a_Xe4Mv>_R
                 ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <a_Xe4Mv>_R)
                 :: ((forall b. Data b => b -> b) -> Dual a_Xe4Mv -> a_Xe4Mv :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> Dual a_Xe4Mv -> Dual a_Xe4Mv :: *)))
        (\ (@ r_ae47Z)
           (@ r'_ae480)
           (ds_de7xE :: r_ae47Z -> r'_ae480 -> r_ae47Z)
           (ds1_de7xF :: r_ae47Z)
           (ds2_de7xG :: forall d. Data d => d -> r'_ae480)
           (eta_XJ0 :: Dual a_Xe4Mv) ->
           ds_de7xE
             ds1_de7xF
             (ds2_de7xG
                @ a_Xe4Mv
                $dData_Xe5vw
                (eta_XJ0
                 `cast` (Data.Semigroup.Internal.N:Dual[0] <a_Xe4Mv>_R
                         :: (Dual a_Xe4Mv :: *) ~R# (a_Xe4Mv :: *)))))
        (\ (@ r_ae48g)
           (@ r'_ae48h)
           (ds_de7xH :: r'_ae48h -> r_ae48g -> r_ae48g)
           (ds1_de7xI :: r_ae48g)
           (ds2_de7xJ :: forall d. Data d => d -> r'_ae48h)
           (x0_ae1SX :: Dual a_Xe4Mv) ->
           ds_de7xH
             (ds2_de7xJ
                @ a_Xe4Mv
                $dData_Xe5vw
                (x0_ae1SX
                 `cast` (Data.Semigroup.Internal.N:Dual[0] <a_Xe4Mv>_R
                         :: (Dual a_Xe4Mv :: *) ~R# (a_Xe4Mv :: *))))
             ds1_de7xI)
        (\ (@ u_ae48x)
           (ds_de7xK :: forall d. Data d => d -> u_ae48x)
           (x0_ae1SX :: Dual a_Xe4Mv) ->
           GHC.Types.:
             @ u_ae48x
             (ds_de7xK
                @ a_Xe4Mv
                $dData_Xe5vw
                (x0_ae1SX
                 `cast` (Data.Semigroup.Internal.N:Dual[0] <a_Xe4Mv>_R
                         :: (Dual a_Xe4Mv :: *) ~R# (a_Xe4Mv :: *))))
             (GHC.Types.[] @ u_ae48x))
        (Data.Data.$fDataDual_$cgmapQi @ a_Xe4Mv $dData_Xe5vw)
        (Data.Data.$fDataDual_$cgmapM @ a_Xe4Mv $dData_Xe5vw)
        (Data.Data.$fDataDual_$cgmapMp @ a_Xe4Mv $dData_Xe5vw)
        (Data.Data.$fDataDual_$cgmapMo @ a_Xe4Mv $dData_Xe5vw)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataAll7 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataAll7 = "All"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataAll6 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataAll6 = unpackCString# Data.Data.$fDataAll7

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$cAll1_rejRH :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$cAll1_rejRH = "getAll"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cAll2_rejRI :: [Char]
[GblId]
$cAll2_rejRI = unpackCString# $cAll1_rejRH

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$cAll3_rejRJ :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cAll3_rejRJ
  = GHC.Types.: @ String $cAll2_rejRI (GHC.Types.[] @ String)

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go28_rejRK :: [Constr] -> [Int] -> Int
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go28_rejRK
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fDataAll6 of {
                False -> go28_rejRK ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cAll4_rejRL :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cAll4_rejRL = Data.Data.AlgConstr $cAll5_rejRM

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataAll5 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataAll5
  = GHC.Types.: @ Constr Data.Data.$cAll (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataAll4 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataAll4 = Data.Data.AlgRep Data.Data.$fDataAll5

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tAll :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$tAll
  = Data.Data.DataType Data.Data.$fDataAll6 Data.Data.$fDataAll4

-- RHS size: {terms: 6, types: 0, coercions: 0, joins: 0/0}
Data.Data.$cAll [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cAll
  = Data.Data.Constr
      $cAll4_rejRL
      Data.Data.$fDataAll6
      $cAll3_rejRJ
      Data.Data.Prefix
      Data.Data.$tAll

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cAll5_rejRM :: Int
[GblId]
$cAll5_rejRM = go28_rejRK Data.Data.$fDataAll5 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataAll_$cdataTypeOf :: All -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Data.$tAll}]
Data.Data.$fDataAll_$cdataTypeOf
  = \ _ [Occ=Dead] -> Data.Data.$tAll

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataAll_$ctoConstr :: All -> Constr
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Data.$cAll}]
Data.Data.$fDataAll_$ctoConstr = \ _ [Occ=Dead] -> Data.Data.$cAll

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataAll_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c All)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae43U :: * -> *))
                 (@ (c_ae43V :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae43V All)}]
Data.Data.$fDataAll_$cdataCast1
  = \ (@ (t_ae43U :: * -> *))
      (@ (c_ae43V :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae43V All)

-- RHS size: {terms: 3, types: 3, coercions: 4, joins: 0/0}
Data.Data.$fDataAll1 :: (Bool -> All, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataAll1
  = (Data.Data.$fDataAll2
     `cast` (<Bool>_R ->_R Sym (Data.Semigroup.Internal.N:All[0])
             :: (Bool -> Bool :: *) ~R# (Bool -> All :: *)),
     GHC.Types.False)

-- RHS size: {terms: 55, types: 86, coercions: 2, joins: 0/3}
Data.Data.$fDataAll_$cgmapMp
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> All -> m All
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 60 0] 510 0}]
Data.Data.$fDataAll_$cgmapMp
  = \ (@ (m_ae461 :: * -> *))
      ($dMonadPlus_ae463 :: MonadPlus m_ae461)
      (ds_de7xv :: forall d. Data d => d -> m_ae461 d)
      (eta_XJb :: All) ->
      let {
        lvl270_se9Nl :: m_ae461 All
        [LclId]
        lvl270_se9Nl = mzero @ m_ae461 $dMonadPlus_ae463 @ All } in
      let {
        $dMonad_se9rd [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae461
        [LclId]
        $dMonad_se9rd
          = GHC.Base.$p2MonadPlus @ m_ae461 $dMonadPlus_ae463 } in
      >>=
        @ m_ae461
        $dMonad_se9rd
        @ (All, Bool)
        @ All
        (let {
           lvl271_se9Nk :: m_ae461 Bool
           [LclId]
           lvl271_se9Nk
             = ds_de7xv
                 @ Bool
                 Data.Data.$fDataBool
                 (eta_XJb
                  `cast` (Data.Semigroup.Internal.N:All[0]
                          :: (All :: *) ~R# (Bool :: *))) } in
         >>=
           @ m_ae461
           $dMonad_se9rd
           @ (Bool -> All, Bool)
           @ (All, Bool)
           (return
              @ m_ae461 $dMonad_se9rd @ (Bool -> All, Bool) Data.Data.$fDataAll1)
           (\ (ds1_de7oD :: (Bool -> All, Bool)) ->
              case ds1_de7oD of { (h_ae1TA, b_ae1TB) ->
              mplus
                @ m_ae461
                $dMonadPlus_ae463
                @ (All, Bool)
                (>>=
                   @ m_ae461
                   $dMonad_se9rd
                   @ Bool
                   @ (All, Bool)
                   lvl271_se9Nk
                   (\ (y'_ae1TC :: Bool) ->
                      return
                        @ m_ae461
                        $dMonad_se9rd
                        @ (All, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_ae461
                   $dMonad_se9rd
                   @ (All, Bool)
                   (h_ae1TA
                      (eta_XJb
                       `cast` (Data.Semigroup.Internal.N:All[0]
                               :: (All :: *) ~R# (Bool :: *))),
                    b_ae1TB))
              }))
        (\ (ds1_de7oa :: (All, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9Nl;
             True -> return @ m_ae461 $dMonad_se9rd @ All x'_ae1TD
           }
           })

-- RHS size: {terms: 22, types: 32, coercions: 5, joins: 0/1}
Data.Data.$fDataAll_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> All -> m All
[GblId,
 Arity=3,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [120 60 0] 220 0}]
Data.Data.$fDataAll_$cgmapM
  = \ (@ (m_ae45L :: * -> *))
      ($dMonad_ae45N :: Monad m_ae45L)
      (ds_de7xu :: forall d. Data d => d -> m_ae45L d)
      (eta_XJc :: All) ->
      let {
        lvl270_se9Nn :: m_ae45L Bool
        [LclId]
        lvl270_se9Nn
          = ds_de7xu
              @ Bool
              Data.Data.$fDataBool
              (eta_XJc
               `cast` (Data.Semigroup.Internal.N:All[0]
                       :: (All :: *) ~R# (Bool :: *))) } in
      >>=
        @ m_ae45L
        $dMonad_ae45N
        @ (Bool -> All)
        @ All
        (return
           @ m_ae45L
           $dMonad_ae45N
           @ (Bool -> All)
           (Data.Data.$fDataAll2
            `cast` (<Bool>_R ->_R Sym (Data.Semigroup.Internal.N:All[0])
                    :: (Bool -> Bool :: *) ~R# (Bool -> All :: *))))
        (\ (c'_ae1To :: Bool -> All) ->
           >>=
             @ m_ae45L
             $dMonad_ae45N
             @ Bool
             @ All
             lvl270_se9Nn
             (\ (x'_ae1Tp :: Bool) ->
                return @ m_ae45L $dMonad_ae45N @ All (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 15, types: 15, coercions: 1, joins: 0/0}
Data.Data.$fDataAll_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> All -> u
[GblId,
 Arity=3,
 Str=<S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae45x)
                 (ds_de7xs [Occ=Once!] :: Int)
                 (ds1_de7xt [Occ=Once!] :: forall d. Data d => d -> u_ae45x)
                 (x_ae1T7 [Occ=Once] :: All) ->
                 case ds_de7xs of { I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_ae45x;
                   0# ->
                     ds1_de7xt
                       @ Bool
                       Data.Data.$fDataBool
                       (x_ae1T7
                        `cast` (Data.Semigroup.Internal.N:All[0]
                                :: (All :: *) ~R# (Bool :: *)))
                 }
                 }}]
Data.Data.$fDataAll_$cgmapQi
  = \ (@ u_ae45x)
      (ds_de7xs :: Int)
      (ds1_de7xt :: forall d. Data d => d -> u_ae45x)
      (x_ae1T7 :: All) ->
      case ds_de7xs of { I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_ae45x;
        0# ->
          ds1_de7xt
            @ Bool
            Data.Data.$fDataBool
            (x_ae1T7
             `cast` (Data.Semigroup.Internal.N:All[0]
                     :: (All :: *) ~R# (Bool :: *)))
      }
      }

-- RHS size: {terms: 11, types: 16, coercions: 1, joins: 0/0}
Data.Data.$fDataAll_$cgmapQr
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> All -> r
[GblId,
 Arity=4,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_ae452)
                 (@ r'_ae453)
                 (ds_de7xo [Occ=Once!] :: r'_ae453 -> r_ae452 -> r_ae452)
                 (ds1_de7xp [Occ=Once] :: r_ae452)
                 (ds2_de7xq [Occ=Once!] :: forall d. Data d => d -> r'_ae453)
                 (x0_ae1SX [Occ=Once] :: All) ->
                 ds_de7xo
                   (ds2_de7xq
                      @ Bool
                      Data.Data.$fDataBool
                      (x0_ae1SX
                       `cast` (Data.Semigroup.Internal.N:All[0]
                               :: (All :: *) ~R# (Bool :: *))))
                   ds1_de7xp}]
Data.Data.$fDataAll_$cgmapQr
  = \ (@ r_ae452)
      (@ r'_ae453)
      (ds_de7xo :: r'_ae453 -> r_ae452 -> r_ae452)
      (ds1_de7xp :: r_ae452)
      (ds2_de7xq :: forall d. Data d => d -> r'_ae453)
      (x0_ae1SX :: All) ->
      ds_de7xo
        (ds2_de7xq
           @ Bool
           Data.Data.$fDataBool
           (x0_ae1SX
            `cast` (Data.Semigroup.Internal.N:All[0]
                    :: (All :: *) ~R# (Bool :: *))))
        ds1_de7xp

-- RHS size: {terms: 8, types: 12, coercions: 1, joins: 0/0}
Data.Data.$fDataAll_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> All -> [u]
[GblId,
 Arity=2,
 Str=<L,1*C1(C1(U))><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae45j)
                 (ds_de7xr [Occ=Once!] :: forall d. Data d => d -> u_ae45j)
                 (x0_ae1SX [Occ=Once] :: All) ->
                 GHC.Types.:
                   @ u_ae45j
                   (ds_de7xr
                      @ Bool
                      Data.Data.$fDataBool
                      (x0_ae1SX
                       `cast` (Data.Semigroup.Internal.N:All[0]
                               :: (All :: *) ~R# (Bool :: *))))
                   (GHC.Types.[] @ u_ae45j)}]
Data.Data.$fDataAll_$cgmapQ
  = \ (@ u_ae45j)
      (ds_de7xr :: forall d. Data d => d -> u_ae45j)
      (x0_ae1SX :: All) ->
      GHC.Types.:
        @ u_ae45j
        (ds_de7xr
           @ Bool
           Data.Data.$fDataBool
           (x0_ae1SX
            `cast` (Data.Semigroup.Internal.N:All[0]
                    :: (All :: *) ~R# (Bool :: *))))
        (GHC.Types.[] @ u_ae45j)

-- RHS size: {terms: 11, types: 16, coercions: 1, joins: 0/0}
Data.Data.$fDataAll_$cgmapQl
  :: forall r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> All -> r
[GblId,
 Arity=4,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_ae44L)
                 (@ r'_ae44M)
                 (ds_de7xl [Occ=Once!] :: r_ae44L -> r'_ae44M -> r_ae44L)
                 (ds1_de7xm [Occ=Once] :: r_ae44L)
                 (ds2_de7xn [Occ=Once!] :: forall d. Data d => d -> r'_ae44M)
                 (eta_XJi [Occ=Once] :: All) ->
                 ds_de7xl
                   ds1_de7xm
                   (ds2_de7xn
                      @ Bool
                      Data.Data.$fDataBool
                      (eta_XJi
                       `cast` (Data.Semigroup.Internal.N:All[0]
                               :: (All :: *) ~R# (Bool :: *))))}]
Data.Data.$fDataAll_$cgmapQl
  = \ (@ r_ae44L)
      (@ r'_ae44M)
      (ds_de7xl :: r_ae44L -> r'_ae44M -> r_ae44L)
      (ds1_de7xm :: r_ae44L)
      (ds2_de7xn :: forall d. Data d => d -> r'_ae44M)
      (eta_XJi :: All) ->
      ds_de7xl
        ds1_de7xm
        (ds2_de7xn
           @ Bool
           Data.Data.$fDataBool
           (eta_XJi
            `cast` (Data.Semigroup.Internal.N:All[0]
                    :: (All :: *) ~R# (Bool :: *))))

-- RHS size: {terms: 5, types: 8, coercions: 1, joins: 0/0}
Data.Data.$fDataAll3 :: (forall b. Data b => b -> b) -> All -> Bool
[GblId,
 Arity=2,
 Str=<C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (ds_de7xk [Occ=Once!] :: forall b. Data b => b -> b)
                 (x0_Xe32A [Occ=Once] :: All) ->
                 ds_de7xk
                   @ Bool
                   Data.Data.$fDataBool
                   (x0_Xe32A
                    `cast` (Data.Semigroup.Internal.N:All[0]
                            :: (All :: *) ~R# (Bool :: *)))}]
Data.Data.$fDataAll3
  = \ (ds_de7xk :: forall b. Data b => b -> b) (x0_Xe32A :: All) ->
      ds_de7xk
        @ Bool
        Data.Data.$fDataBool
        (x0_Xe32A
         `cast` (Data.Semigroup.Internal.N:All[0]
                 :: (All :: *) ~R# (Bool :: *)))

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataAll_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c All)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae44d :: * -> * -> *))
                 (@ (c_ae44e :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae44e All)}]
Data.Data.$fDataAll_$cdataCast2
  = \ (@ (t_ae44d :: * -> * -> *))
      (@ (c_ae44e :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae44e All)

-- RHS size: {terms: 65, types: 93, coercions: 3, joins: 0/3}
Data.Data.$fDataAll_$cgmapMo
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> All -> m All
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 60 0] 590 0}]
Data.Data.$fDataAll_$cgmapMo
  = \ (@ (m_ae46h :: * -> *))
      ($dMonadPlus_ae46j :: MonadPlus m_ae46h)
      (ds_de7xw :: forall d. Data d => d -> m_ae46h d)
      (eta_XJk :: All) ->
      let {
        lvl270_se9Ns :: m_ae46h All
        [LclId]
        lvl270_se9Ns = mzero @ m_ae46h $dMonadPlus_ae46j @ All } in
      let {
        $dMonad_se9rb [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae46h
        [LclId]
        $dMonad_se9rb
          = GHC.Base.$p2MonadPlus @ m_ae46h $dMonadPlus_ae46j } in
      >>=
        @ m_ae46h
        $dMonad_se9rb
        @ (All, Bool)
        @ All
        (let {
           lvl271_se9Nr :: m_ae46h Bool
           [LclId]
           lvl271_se9Nr
             = ds_de7xw
                 @ Bool
                 Data.Data.$fDataBool
                 (eta_XJk
                  `cast` (Data.Semigroup.Internal.N:All[0]
                          :: (All :: *) ~R# (Bool :: *))) } in
         >>=
           @ m_ae46h
           $dMonad_se9rb
           @ (Bool -> All, Bool)
           @ (All, Bool)
           (return
              @ m_ae46h $dMonad_se9rb @ (Bool -> All, Bool) Data.Data.$fDataAll1)
           (\ (ds1_de7pD :: (Bool -> All, Bool)) ->
              case ds1_de7pD of { (h_ae1TP, b_ae1TQ) ->
              case b_ae1TQ of {
                False ->
                  mplus
                    @ m_ae46h
                    $dMonadPlus_ae46j
                    @ (All, Bool)
                    (>>=
                       @ m_ae46h
                       $dMonad_se9rb
                       @ Bool
                       @ (All, Bool)
                       lvl271_se9Nr
                       (\ (y'_ae1TR :: Bool) ->
                          return
                            @ m_ae46h
                            $dMonad_se9rb
                            @ (All, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_ae46h
                       $dMonad_se9rb
                       @ (All, Bool)
                       (h_ae1TP
                          (eta_XJk
                           `cast` (Data.Semigroup.Internal.N:All[0]
                                   :: (All :: *) ~R# (Bool :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_ae46h
                    $dMonad_se9rb
                    @ (All, Bool)
                    (h_ae1TP
                       (eta_XJk
                        `cast` (Data.Semigroup.Internal.N:All[0]
                                :: (All :: *) ~R# (Bool :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds1_de7pa :: (All, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9Ns;
             True -> return @ m_ae46h $dMonad_se9rb @ All x'_ae1TS
           }
           })

-- RHS size: {terms: 16, types: 1, coercions: 16, joins: 0/0}
Data.Data.$fDataAll [InlPrag=NOUSERINLINE CONLIKE] :: Data All
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: All
                        Data.Data.$fDataAll8
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <All>_N
                                :: (Data.Typeable.Internal.TypeRep All :: *)
                                   ~R# (Typeable All :: Constraint))
                        Data.Data.$fDataAll_$cgfoldl
                        Data.Data.$fDataAll_$cgunfold
                        Data.Data.$fDataAll_$ctoConstr
                        Data.Data.$fDataAll_$cdataTypeOf
                        Data.Data.$fDataAll_$cdataCast1
                        Data.Data.$fDataAll_$cdataCast2
                        Data.Data.$fDataAll3
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <All>_R
                                ->_R Sym (Data.Semigroup.Internal.N:All[0])
                                :: ((forall b. Data b => b -> b) -> All -> Bool :: *)
                                   ~R# ((forall b. Data b => b -> b) -> All -> All :: *))
                        Data.Data.$fDataAll_$cgmapQl
                        Data.Data.$fDataAll_$cgmapQr
                        Data.Data.$fDataAll_$cgmapQ
                        Data.Data.$fDataAll_$cgmapQi
                        Data.Data.$fDataAll_$cgmapM
                        Data.Data.$fDataAll_$cgmapMp
                        Data.Data.$fDataAll_$cgmapMo]
Data.Data.$fDataAll
  = Data.Data.C:Data
      @ All
      (Data.Data.$fDataAll8
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <All>_N
               :: (Data.Typeable.Internal.TypeRep All :: *)
                  ~R# (Typeable All :: Constraint)))
      Data.Data.$fDataAll_$cgfoldl
      Data.Data.$fDataAll_$cgunfold
      Data.Data.$fDataAll_$ctoConstr
      Data.Data.$fDataAll_$cdataTypeOf
      Data.Data.$fDataAll_$cdataCast1
      Data.Data.$fDataAll_$cdataCast2
      (Data.Data.$fDataAll3
       `cast` (<forall b. Data b => b -> b>_R
               ->_R <All>_R
               ->_R Sym (Data.Semigroup.Internal.N:All[0])
               :: ((forall b. Data b => b -> b) -> All -> Bool :: *)
                  ~R# ((forall b. Data b => b -> b) -> All -> All :: *)))
      Data.Data.$fDataAll_$cgmapQl
      Data.Data.$fDataAll_$cgmapQr
      Data.Data.$fDataAll_$cgmapQ
      Data.Data.$fDataAll_$cgmapQi
      Data.Data.$fDataAll_$cgmapM
      Data.Data.$fDataAll_$cgmapMp
      Data.Data.$fDataAll_$cgmapMo

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataAny6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataAny6 = "Any"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataAny5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataAny5 = unpackCString# Data.Data.$fDataAny6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$cAny1_rejRN :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$cAny1_rejRN = "getAny"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cAny2_rejRO :: [Char]
[GblId]
$cAny2_rejRO = unpackCString# $cAny1_rejRN

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$cAny3_rejRP :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cAny3_rejRP
  = GHC.Types.: @ String $cAny2_rejRO (GHC.Types.[] @ String)

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go29_rejRQ :: [Constr] -> [Int] -> Int
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go29_rejRQ
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fDataAny5 of {
                False -> go29_rejRQ ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cAny4_rejRR :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cAny4_rejRR = Data.Data.AlgConstr $cAny5_rejRS

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataAny4 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataAny4
  = GHC.Types.: @ Constr Data.Data.$cAny (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataAny3 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataAny3 = Data.Data.AlgRep Data.Data.$fDataAny4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tAny :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$tAny
  = Data.Data.DataType Data.Data.$fDataAny5 Data.Data.$fDataAny3

-- RHS size: {terms: 6, types: 0, coercions: 0, joins: 0/0}
Data.Data.$cAny [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cAny
  = Data.Data.Constr
      $cAny4_rejRR
      Data.Data.$fDataAny5
      $cAny3_rejRP
      Data.Data.Prefix
      Data.Data.$tAny

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cAny5_rejRS :: Int
[GblId]
$cAny5_rejRS = go29_rejRQ Data.Data.$fDataAny4 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataAny_$cdataTypeOf :: Any -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Data.$tAny}]
Data.Data.$fDataAny_$cdataTypeOf
  = \ _ [Occ=Dead] -> Data.Data.$tAny

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataAny_$ctoConstr :: Any -> Constr
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Data.$cAny}]
Data.Data.$fDataAny_$ctoConstr = \ _ [Occ=Dead] -> Data.Data.$cAny

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataAny_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c Any)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae40J :: * -> *))
                 (@ (c_ae40K :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae40K Any)}]
Data.Data.$fDataAny_$cdataCast1
  = \ (@ (t_ae40J :: * -> *))
      (@ (c_ae40K :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae40K Any)

-- RHS size: {terms: 3, types: 3, coercions: 4, joins: 0/0}
Data.Data.$fDataAny1 :: (Bool -> Any, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataAny1
  = (Data.Data.$fDataAll2
     `cast` (<Bool>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
             :: (Bool -> Bool :: *) ~R# (Bool -> Any :: *)),
     GHC.Types.False)

-- RHS size: {terms: 55, types: 86, coercions: 2, joins: 0/3}
Data.Data.$fDataAny_$cgmapMp
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Any -> m Any
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 60 0] 510 0}]
Data.Data.$fDataAny_$cgmapMp
  = \ (@ (m_ae42Q :: * -> *))
      ($dMonadPlus_ae42S :: MonadPlus m_ae42Q)
      (ds_de7xb :: forall d. Data d => d -> m_ae42Q d)
      (eta_XJu :: Any) ->
      let {
        lvl270_se9NH :: m_ae42Q Any
        [LclId]
        lvl270_se9NH = mzero @ m_ae42Q $dMonadPlus_ae42S @ Any } in
      let {
        $dMonad_se9r9 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae42Q
        [LclId]
        $dMonad_se9r9
          = GHC.Base.$p2MonadPlus @ m_ae42Q $dMonadPlus_ae42S } in
      >>=
        @ m_ae42Q
        $dMonad_se9r9
        @ (Any, Bool)
        @ Any
        (let {
           lvl271_se9NG :: m_ae42Q Bool
           [LclId]
           lvl271_se9NG
             = ds_de7xb
                 @ Bool
                 Data.Data.$fDataBool
                 (eta_XJu
                  `cast` (Data.Semigroup.Internal.N:Any[0]
                          :: (Any :: *) ~R# (Bool :: *))) } in
         >>=
           @ m_ae42Q
           $dMonad_se9r9
           @ (Bool -> Any, Bool)
           @ (Any, Bool)
           (return
              @ m_ae42Q $dMonad_se9r9 @ (Bool -> Any, Bool) Data.Data.$fDataAny1)
           (\ (ds1_de7oD :: (Bool -> Any, Bool)) ->
              case ds1_de7oD of { (h_ae1TA, b_ae1TB) ->
              mplus
                @ m_ae42Q
                $dMonadPlus_ae42S
                @ (Any, Bool)
                (>>=
                   @ m_ae42Q
                   $dMonad_se9r9
                   @ Bool
                   @ (Any, Bool)
                   lvl271_se9NG
                   (\ (y'_ae1TC :: Bool) ->
                      return
                        @ m_ae42Q
                        $dMonad_se9r9
                        @ (Any, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_ae42Q
                   $dMonad_se9r9
                   @ (Any, Bool)
                   (h_ae1TA
                      (eta_XJu
                       `cast` (Data.Semigroup.Internal.N:Any[0]
                               :: (Any :: *) ~R# (Bool :: *))),
                    b_ae1TB))
              }))
        (\ (ds1_de7oa :: (Any, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9NH;
             True -> return @ m_ae42Q $dMonad_se9r9 @ Any x'_ae1TD
           }
           })

-- RHS size: {terms: 22, types: 32, coercions: 5, joins: 0/1}
Data.Data.$fDataAny_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Any -> m Any
[GblId,
 Arity=3,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [120 60 0] 220 0}]
Data.Data.$fDataAny_$cgmapM
  = \ (@ (m_ae42A :: * -> *))
      ($dMonad_ae42C :: Monad m_ae42A)
      (ds_de7xa :: forall d. Data d => d -> m_ae42A d)
      (eta_XJv :: Any) ->
      let {
        lvl270_se9NJ :: m_ae42A Bool
        [LclId]
        lvl270_se9NJ
          = ds_de7xa
              @ Bool
              Data.Data.$fDataBool
              (eta_XJv
               `cast` (Data.Semigroup.Internal.N:Any[0]
                       :: (Any :: *) ~R# (Bool :: *))) } in
      >>=
        @ m_ae42A
        $dMonad_ae42C
        @ (Bool -> Any)
        @ Any
        (return
           @ m_ae42A
           $dMonad_ae42C
           @ (Bool -> Any)
           (Data.Data.$fDataAll2
            `cast` (<Bool>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                    :: (Bool -> Bool :: *) ~R# (Bool -> Any :: *))))
        (\ (c'_ae1To :: Bool -> Any) ->
           >>=
             @ m_ae42A
             $dMonad_ae42C
             @ Bool
             @ Any
             lvl270_se9NJ
             (\ (x'_ae1Tp :: Bool) ->
                return @ m_ae42A $dMonad_ae42C @ Any (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 15, types: 15, coercions: 1, joins: 0/0}
Data.Data.$fDataAny_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> Any -> u
[GblId,
 Arity=3,
 Str=<S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae42m)
                 (ds_de7x8 [Occ=Once!] :: Int)
                 (ds1_de7x9 [Occ=Once!] :: forall d. Data d => d -> u_ae42m)
                 (x_ae1T7 [Occ=Once] :: Any) ->
                 case ds_de7x8 of { I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_ae42m;
                   0# ->
                     ds1_de7x9
                       @ Bool
                       Data.Data.$fDataBool
                       (x_ae1T7
                        `cast` (Data.Semigroup.Internal.N:Any[0]
                                :: (Any :: *) ~R# (Bool :: *)))
                 }
                 }}]
Data.Data.$fDataAny_$cgmapQi
  = \ (@ u_ae42m)
      (ds_de7x8 :: Int)
      (ds1_de7x9 :: forall d. Data d => d -> u_ae42m)
      (x_ae1T7 :: Any) ->
      case ds_de7x8 of { I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_ae42m;
        0# ->
          ds1_de7x9
            @ Bool
            Data.Data.$fDataBool
            (x_ae1T7
             `cast` (Data.Semigroup.Internal.N:Any[0]
                     :: (Any :: *) ~R# (Bool :: *)))
      }
      }

-- RHS size: {terms: 11, types: 16, coercions: 1, joins: 0/0}
Data.Data.$fDataAny_$cgmapQr
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> Any -> r
[GblId,
 Arity=4,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_ae41R)
                 (@ r'_ae41S)
                 (ds_de7x4 [Occ=Once!] :: r'_ae41S -> r_ae41R -> r_ae41R)
                 (ds1_de7x5 [Occ=Once] :: r_ae41R)
                 (ds2_de7x6 [Occ=Once!] :: forall d. Data d => d -> r'_ae41S)
                 (x0_ae1SX [Occ=Once] :: Any) ->
                 ds_de7x4
                   (ds2_de7x6
                      @ Bool
                      Data.Data.$fDataBool
                      (x0_ae1SX
                       `cast` (Data.Semigroup.Internal.N:Any[0]
                               :: (Any :: *) ~R# (Bool :: *))))
                   ds1_de7x5}]
Data.Data.$fDataAny_$cgmapQr
  = \ (@ r_ae41R)
      (@ r'_ae41S)
      (ds_de7x4 :: r'_ae41S -> r_ae41R -> r_ae41R)
      (ds1_de7x5 :: r_ae41R)
      (ds2_de7x6 :: forall d. Data d => d -> r'_ae41S)
      (x0_ae1SX :: Any) ->
      ds_de7x4
        (ds2_de7x6
           @ Bool
           Data.Data.$fDataBool
           (x0_ae1SX
            `cast` (Data.Semigroup.Internal.N:Any[0]
                    :: (Any :: *) ~R# (Bool :: *))))
        ds1_de7x5

-- RHS size: {terms: 8, types: 12, coercions: 1, joins: 0/0}
Data.Data.$fDataAny_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> Any -> [u]
[GblId,
 Arity=2,
 Str=<L,1*C1(C1(U))><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae428)
                 (ds_de7x7 [Occ=Once!] :: forall d. Data d => d -> u_ae428)
                 (x0_ae1SX [Occ=Once] :: Any) ->
                 GHC.Types.:
                   @ u_ae428
                   (ds_de7x7
                      @ Bool
                      Data.Data.$fDataBool
                      (x0_ae1SX
                       `cast` (Data.Semigroup.Internal.N:Any[0]
                               :: (Any :: *) ~R# (Bool :: *))))
                   (GHC.Types.[] @ u_ae428)}]
Data.Data.$fDataAny_$cgmapQ
  = \ (@ u_ae428)
      (ds_de7x7 :: forall d. Data d => d -> u_ae428)
      (x0_ae1SX :: Any) ->
      GHC.Types.:
        @ u_ae428
        (ds_de7x7
           @ Bool
           Data.Data.$fDataBool
           (x0_ae1SX
            `cast` (Data.Semigroup.Internal.N:Any[0]
                    :: (Any :: *) ~R# (Bool :: *))))
        (GHC.Types.[] @ u_ae428)

-- RHS size: {terms: 11, types: 16, coercions: 1, joins: 0/0}
Data.Data.$fDataAny_$cgmapQl
  :: forall r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> Any -> r
[GblId,
 Arity=4,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_ae41A)
                 (@ r'_ae41B)
                 (ds_de7x1 [Occ=Once!] :: r_ae41A -> r'_ae41B -> r_ae41A)
                 (ds1_de7x2 [Occ=Once] :: r_ae41A)
                 (ds2_de7x3 [Occ=Once!] :: forall d. Data d => d -> r'_ae41B)
                 (eta_XJB [Occ=Once] :: Any) ->
                 ds_de7x1
                   ds1_de7x2
                   (ds2_de7x3
                      @ Bool
                      Data.Data.$fDataBool
                      (eta_XJB
                       `cast` (Data.Semigroup.Internal.N:Any[0]
                               :: (Any :: *) ~R# (Bool :: *))))}]
Data.Data.$fDataAny_$cgmapQl
  = \ (@ r_ae41A)
      (@ r'_ae41B)
      (ds_de7x1 :: r_ae41A -> r'_ae41B -> r_ae41A)
      (ds1_de7x2 :: r_ae41A)
      (ds2_de7x3 :: forall d. Data d => d -> r'_ae41B)
      (eta_XJB :: Any) ->
      ds_de7x1
        ds1_de7x2
        (ds2_de7x3
           @ Bool
           Data.Data.$fDataBool
           (eta_XJB
            `cast` (Data.Semigroup.Internal.N:Any[0]
                    :: (Any :: *) ~R# (Bool :: *))))

-- RHS size: {terms: 5, types: 8, coercions: 1, joins: 0/0}
Data.Data.$fDataAny2 :: (forall b. Data b => b -> b) -> Any -> Bool
[GblId,
 Arity=2,
 Str=<C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (ds_de7x0 [Occ=Once!] :: forall b. Data b => b -> b)
                 (x0_Xe32T [Occ=Once] :: Any) ->
                 ds_de7x0
                   @ Bool
                   Data.Data.$fDataBool
                   (x0_Xe32T
                    `cast` (Data.Semigroup.Internal.N:Any[0]
                            :: (Any :: *) ~R# (Bool :: *)))}]
Data.Data.$fDataAny2
  = \ (ds_de7x0 :: forall b. Data b => b -> b) (x0_Xe32T :: Any) ->
      ds_de7x0
        @ Bool
        Data.Data.$fDataBool
        (x0_Xe32T
         `cast` (Data.Semigroup.Internal.N:Any[0]
                 :: (Any :: *) ~R# (Bool :: *)))

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataAny_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c Any)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae412 :: * -> * -> *))
                 (@ (c_ae413 :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae413 Any)}]
Data.Data.$fDataAny_$cdataCast2
  = \ (@ (t_ae412 :: * -> * -> *))
      (@ (c_ae413 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae413 Any)

-- RHS size: {terms: 65, types: 93, coercions: 3, joins: 0/3}
Data.Data.$fDataAny_$cgmapMo
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Any -> m Any
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 60 0] 590 0}]
Data.Data.$fDataAny_$cgmapMo
  = \ (@ (m_ae436 :: * -> *))
      ($dMonadPlus_ae438 :: MonadPlus m_ae436)
      (ds_de7xc :: forall d. Data d => d -> m_ae436 d)
      (eta_XJD :: Any) ->
      let {
        lvl270_se9NO :: m_ae436 Any
        [LclId]
        lvl270_se9NO = mzero @ m_ae436 $dMonadPlus_ae438 @ Any } in
      let {
        $dMonad_se9r7 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae436
        [LclId]
        $dMonad_se9r7
          = GHC.Base.$p2MonadPlus @ m_ae436 $dMonadPlus_ae438 } in
      >>=
        @ m_ae436
        $dMonad_se9r7
        @ (Any, Bool)
        @ Any
        (let {
           lvl271_se9NN :: m_ae436 Bool
           [LclId]
           lvl271_se9NN
             = ds_de7xc
                 @ Bool
                 Data.Data.$fDataBool
                 (eta_XJD
                  `cast` (Data.Semigroup.Internal.N:Any[0]
                          :: (Any :: *) ~R# (Bool :: *))) } in
         >>=
           @ m_ae436
           $dMonad_se9r7
           @ (Bool -> Any, Bool)
           @ (Any, Bool)
           (return
              @ m_ae436 $dMonad_se9r7 @ (Bool -> Any, Bool) Data.Data.$fDataAny1)
           (\ (ds1_de7pD :: (Bool -> Any, Bool)) ->
              case ds1_de7pD of { (h_ae1TP, b_ae1TQ) ->
              case b_ae1TQ of {
                False ->
                  mplus
                    @ m_ae436
                    $dMonadPlus_ae438
                    @ (Any, Bool)
                    (>>=
                       @ m_ae436
                       $dMonad_se9r7
                       @ Bool
                       @ (Any, Bool)
                       lvl271_se9NN
                       (\ (y'_ae1TR :: Bool) ->
                          return
                            @ m_ae436
                            $dMonad_se9r7
                            @ (Any, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_ae436
                       $dMonad_se9r7
                       @ (Any, Bool)
                       (h_ae1TP
                          (eta_XJD
                           `cast` (Data.Semigroup.Internal.N:Any[0]
                                   :: (Any :: *) ~R# (Bool :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_ae436
                    $dMonad_se9r7
                    @ (Any, Bool)
                    (h_ae1TP
                       (eta_XJD
                        `cast` (Data.Semigroup.Internal.N:Any[0]
                                :: (Any :: *) ~R# (Bool :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds1_de7pa :: (Any, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9NO;
             True -> return @ m_ae436 $dMonad_se9r7 @ Any x'_ae1TS
           }
           })

-- RHS size: {terms: 16, types: 1, coercions: 16, joins: 0/0}
Data.Data.$fDataAny [InlPrag=NOUSERINLINE CONLIKE] :: Data Any
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: Any
                        Data.Data.$fDataAny7
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Any>_N
                                :: (Data.Typeable.Internal.TypeRep Any :: *)
                                   ~R# (Typeable Any :: Constraint))
                        Data.Data.$fDataAny_$cgfoldl
                        Data.Data.$fDataAny_$cgunfold
                        Data.Data.$fDataAny_$ctoConstr
                        Data.Data.$fDataAny_$cdataTypeOf
                        Data.Data.$fDataAny_$cdataCast1
                        Data.Data.$fDataAny_$cdataCast2
                        Data.Data.$fDataAny2
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <Any>_R
                                ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                                :: ((forall b. Data b => b -> b) -> Any -> Bool :: *)
                                   ~R# ((forall b. Data b => b -> b) -> Any -> Any :: *))
                        Data.Data.$fDataAny_$cgmapQl
                        Data.Data.$fDataAny_$cgmapQr
                        Data.Data.$fDataAny_$cgmapQ
                        Data.Data.$fDataAny_$cgmapQi
                        Data.Data.$fDataAny_$cgmapM
                        Data.Data.$fDataAny_$cgmapMp
                        Data.Data.$fDataAny_$cgmapMo]
Data.Data.$fDataAny
  = Data.Data.C:Data
      @ Any
      (Data.Data.$fDataAny7
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Any>_N
               :: (Data.Typeable.Internal.TypeRep Any :: *)
                  ~R# (Typeable Any :: Constraint)))
      Data.Data.$fDataAny_$cgfoldl
      Data.Data.$fDataAny_$cgunfold
      Data.Data.$fDataAny_$ctoConstr
      Data.Data.$fDataAny_$cdataTypeOf
      Data.Data.$fDataAny_$cdataCast1
      Data.Data.$fDataAny_$cdataCast2
      (Data.Data.$fDataAny2
       `cast` (<forall b. Data b => b -> b>_R
               ->_R <Any>_R
               ->_R Sym (Data.Semigroup.Internal.N:Any[0])
               :: ((forall b. Data b => b -> b) -> Any -> Bool :: *)
                  ~R# ((forall b. Data b => b -> b) -> Any -> Any :: *)))
      Data.Data.$fDataAny_$cgmapQl
      Data.Data.$fDataAny_$cgmapQr
      Data.Data.$fDataAny_$cgmapQ
      Data.Data.$fDataAny_$cgmapQi
      Data.Data.$fDataAny_$cgmapM
      Data.Data.$fDataAny_$cgmapMp
      Data.Data.$fDataAny_$cgmapMo

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataSum6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataSum6 = "Sum"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataSum5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataSum5 = unpackCString# Data.Data.$fDataSum6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$cSum1_rejRT :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$cSum1_rejRT = "getSum"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cSum2_rejRU :: [Char]
[GblId]
$cSum2_rejRU = unpackCString# $cSum1_rejRT

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$cSum3_rejRV :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cSum3_rejRV
  = GHC.Types.: @ String $cSum2_rejRU (GHC.Types.[] @ String)

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go30_rejRW :: [Constr] -> [Int] -> Int
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go30_rejRW
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fDataSum5 of {
                False -> go30_rejRW ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cSum4_rejRX :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cSum4_rejRX = Data.Data.AlgConstr $cSum5_rejRY

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataSum4 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataSum4
  = GHC.Types.: @ Constr Data.Data.$cSum (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataSum3 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataSum3 = Data.Data.AlgRep Data.Data.$fDataSum4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tSum :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$tSum
  = Data.Data.DataType Data.Data.$fDataSum5 Data.Data.$fDataSum3

-- RHS size: {terms: 6, types: 0, coercions: 0, joins: 0/0}
Data.Data.$cSum [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cSum
  = Data.Data.Constr
      $cSum4_rejRX
      Data.Data.$fDataSum5
      $cSum3_rejRV
      Data.Data.Prefix
      Data.Data.$tSum

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cSum5_rejRY :: Int
[GblId]
$cSum5_rejRY = go30_rejRW Data.Data.$fDataSum4 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 4, types: 7, coercions: 5, joins: 0/0}
Data.Data.$fDataSum1 :: forall a. (a -> Sum a, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataSum1
  = \ (@ a_Xe4DY) ->
      ((Data.Data.$fDataConst2 @ a_Xe4DY)
       `cast` (<a_Xe4DY>_R
               ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_Xe4DY>_R)
               :: (a_Xe4DY -> a_Xe4DY :: *) ~R# (a_Xe4DY -> Sum a_Xe4DY :: *)),
       GHC.Types.False)

-- RHS size: {terms: 57, types: 112, coercions: 4, joins: 0/3}
Data.Data.$fDataSum_$cgmapMp
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Sum a -> m (Sum a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 510 0}]
Data.Data.$fDataSum_$cgmapMp
  = \ (@ a_Xe4DY)
      ($dData_Xe4E0 :: Data a_Xe4DY)
      (@ (m_ae3ZF :: * -> *))
      ($dMonadPlus_ae3ZH :: MonadPlus m_ae3ZF)
      (ds_de7wR :: forall d. Data d => d -> m_ae3ZF d)
      (eta_XJN :: Sum a_Xe4DY) ->
      let {
        lvl270_se9O3 :: m_ae3ZF (Sum a_Xe4DY)
        [LclId]
        lvl270_se9O3
          = mzero @ m_ae3ZF $dMonadPlus_ae3ZH @ (Sum a_Xe4DY) } in
      let {
        $dMonad_se9r5 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae3ZF
        [LclId]
        $dMonad_se9r5
          = GHC.Base.$p2MonadPlus @ m_ae3ZF $dMonadPlus_ae3ZH } in
      >>=
        @ m_ae3ZF
        $dMonad_se9r5
        @ (Sum a_Xe4DY, Bool)
        @ (Sum a_Xe4DY)
        (let {
           lvl271_se9O2 :: m_ae3ZF a_Xe4DY
           [LclId]
           lvl271_se9O2
             = ds_de7wR
                 @ a_Xe4DY
                 $dData_Xe4E0
                 (eta_XJN
                  `cast` (Data.Semigroup.Internal.N:Sum[0] <a_Xe4DY>_R
                          :: (Sum a_Xe4DY :: *) ~R# (a_Xe4DY :: *))) } in
         >>=
           @ m_ae3ZF
           $dMonad_se9r5
           @ (a_Xe4DY -> Sum a_Xe4DY, Bool)
           @ (Sum a_Xe4DY, Bool)
           (return
              @ m_ae3ZF
              $dMonad_se9r5
              @ (a_Xe4DY -> Sum a_Xe4DY, Bool)
              (Data.Data.$fDataSum1 @ a_Xe4DY))
           (\ (ds1_de7oD :: (a_Xe4DY -> Sum a_Xe4DY, Bool)) ->
              case ds1_de7oD of { (h_ae1TA, b_ae1TB) ->
              mplus
                @ m_ae3ZF
                $dMonadPlus_ae3ZH
                @ (Sum a_Xe4DY, Bool)
                (>>=
                   @ m_ae3ZF
                   $dMonad_se9r5
                   @ a_Xe4DY
                   @ (Sum a_Xe4DY, Bool)
                   lvl271_se9O2
                   (\ (y'_ae1TC :: a_Xe4DY) ->
                      return
                        @ m_ae3ZF
                        $dMonad_se9r5
                        @ (Sum a_Xe4DY, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_ae3ZF
                   $dMonad_se9r5
                   @ (Sum a_Xe4DY, Bool)
                   (h_ae1TA
                      (eta_XJN
                       `cast` (Data.Semigroup.Internal.N:Sum[0] <a_Xe4DY>_R
                               :: (Sum a_Xe4DY :: *) ~R# (a_Xe4DY :: *))),
                    b_ae1TB))
              }))
        (\ (ds1_de7oa :: (Sum a_Xe4DY, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9O3;
             True -> return @ m_ae3ZF $dMonad_se9r5 @ (Sum a_Xe4DY) x'_ae1TD
           }
           })

-- RHS size: {terms: 24, types: 44, coercions: 7, joins: 0/1}
Data.Data.$fDataSum_$cgmapM
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Sum a -> m (Sum a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120 60 0] 220 0}]
Data.Data.$fDataSum_$cgmapM
  = \ (@ a_Xe4DX)
      ($dData_Xe4DZ :: Data a_Xe4DX)
      (@ (m_ae3Zp :: * -> *))
      ($dMonad_ae3Zr :: Monad m_ae3Zp)
      (ds_de7wQ :: forall d. Data d => d -> m_ae3Zp d)
      (eta_XJO :: Sum a_Xe4DX) ->
      let {
        lvl270_se9O5 :: m_ae3Zp a_Xe4DX
        [LclId]
        lvl270_se9O5
          = ds_de7wQ
              @ a_Xe4DX
              $dData_Xe4DZ
              (eta_XJO
               `cast` (Data.Semigroup.Internal.N:Sum[0] <a_Xe4DX>_R
                       :: (Sum a_Xe4DX :: *) ~R# (a_Xe4DX :: *))) } in
      >>=
        @ m_ae3Zp
        $dMonad_ae3Zr
        @ (a_Xe4DX -> Sum a_Xe4DX)
        @ (Sum a_Xe4DX)
        (return
           @ m_ae3Zp
           $dMonad_ae3Zr
           @ (a_Xe4DX -> Sum a_Xe4DX)
           ((Data.Data.$fDataConst2 @ a_Xe4DX)
            `cast` (<a_Xe4DX>_R
                    ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_Xe4DX>_R)
                    :: (a_Xe4DX -> a_Xe4DX :: *) ~R# (a_Xe4DX -> Sum a_Xe4DX :: *))))
        (\ (c'_ae1To :: a_Xe4DX -> Sum a_Xe4DX) ->
           >>=
             @ m_ae3Zp
             $dMonad_ae3Zr
             @ a_Xe4DX
             @ (Sum a_Xe4DX)
             lvl270_se9O5
             (\ (x'_ae1Tp :: a_Xe4DX) ->
                return
                  @ m_ae3Zp $dMonad_ae3Zr @ (Sum a_Xe4DX) (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 17, types: 20, coercions: 2, joins: 0/0}
Data.Data.$fDataSum_$cgmapQi
  :: forall a.
     Data a =>
     forall u. Int -> (forall d. Data d => d -> u) -> Sum a -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe4DW)
                 ($dData_Xe4DY [Occ=Once] :: Data a_Xe4DW)
                 (@ u_ae3Zb)
                 (ds_de7wO [Occ=Once!] :: Int)
                 (ds1_de7wP [Occ=Once!] :: forall d. Data d => d -> u_ae3Zb)
                 (x_ae1T7 [Occ=Once] :: Sum a_Xe4DW) ->
                 case ds_de7wO of { I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3Zb;
                   0# ->
                     ds1_de7wP
                       @ a_Xe4DW
                       $dData_Xe4DY
                       (x_ae1T7
                        `cast` (Data.Semigroup.Internal.N:Sum[0] <a_Xe4DW>_R
                                :: (Sum a_Xe4DW :: *) ~R# (a_Xe4DW :: *)))
                 }
                 }}]
Data.Data.$fDataSum_$cgmapQi
  = \ (@ a_Xe4DW)
      ($dData_Xe4DY :: Data a_Xe4DW)
      (@ u_ae3Zb)
      (ds_de7wO :: Int)
      (ds1_de7wP :: forall d. Data d => d -> u_ae3Zb)
      (x_ae1T7 :: Sum a_Xe4DW) ->
      case ds_de7wO of { I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3Zb;
        0# ->
          ds1_de7wP
            @ a_Xe4DW
            $dData_Xe4DY
            (x_ae1T7
             `cast` (Data.Semigroup.Internal.N:Sum[0] <a_Xe4DW>_R
                     :: (Sum a_Xe4DW :: *) ~R# (a_Xe4DW :: *)))
      }
      }

-- RHS size: {terms: 67, types: 121, coercions: 6, joins: 0/3}
Data.Data.$fDataSum_$cgmapMo
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Sum a -> m (Sum a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 590 0}]
Data.Data.$fDataSum_$cgmapMo
  = \ (@ a_Xe4DR)
      ($dData_Xe4DT :: Data a_Xe4DR)
      (@ (m_ae3ZV :: * -> *))
      ($dMonadPlus_ae3ZX :: MonadPlus m_ae3ZV)
      (ds_de7wS :: forall d. Data d => d -> m_ae3ZV d)
      (eta_XJX :: Sum a_Xe4DR) ->
      let {
        lvl270_se9Oa :: m_ae3ZV (Sum a_Xe4DR)
        [LclId]
        lvl270_se9Oa
          = mzero @ m_ae3ZV $dMonadPlus_ae3ZX @ (Sum a_Xe4DR) } in
      let {
        $dMonad_se9r3 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae3ZV
        [LclId]
        $dMonad_se9r3
          = GHC.Base.$p2MonadPlus @ m_ae3ZV $dMonadPlus_ae3ZX } in
      >>=
        @ m_ae3ZV
        $dMonad_se9r3
        @ (Sum a_Xe4DR, Bool)
        @ (Sum a_Xe4DR)
        (let {
           lvl271_se9O9 :: m_ae3ZV a_Xe4DR
           [LclId]
           lvl271_se9O9
             = ds_de7wS
                 @ a_Xe4DR
                 $dData_Xe4DT
                 (eta_XJX
                  `cast` (Data.Semigroup.Internal.N:Sum[0] <a_Xe4DR>_R
                          :: (Sum a_Xe4DR :: *) ~R# (a_Xe4DR :: *))) } in
         >>=
           @ m_ae3ZV
           $dMonad_se9r3
           @ (a_Xe4DR -> Sum a_Xe4DR, Bool)
           @ (Sum a_Xe4DR, Bool)
           (return
              @ m_ae3ZV
              $dMonad_se9r3
              @ (a_Xe4DR -> Sum a_Xe4DR, Bool)
              (Data.Data.$fDataSum1 @ a_Xe4DR))
           (\ (ds1_de7pD :: (a_Xe4DR -> Sum a_Xe4DR, Bool)) ->
              case ds1_de7pD of { (h_ae1TP, b_ae1TQ) ->
              case b_ae1TQ of {
                False ->
                  mplus
                    @ m_ae3ZV
                    $dMonadPlus_ae3ZX
                    @ (Sum a_Xe4DR, Bool)
                    (>>=
                       @ m_ae3ZV
                       $dMonad_se9r3
                       @ a_Xe4DR
                       @ (Sum a_Xe4DR, Bool)
                       lvl271_se9O9
                       (\ (y'_ae1TR :: a_Xe4DR) ->
                          return
                            @ m_ae3ZV
                            $dMonad_se9r3
                            @ (Sum a_Xe4DR, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_ae3ZV
                       $dMonad_se9r3
                       @ (Sum a_Xe4DR, Bool)
                       (h_ae1TP
                          (eta_XJX
                           `cast` (Data.Semigroup.Internal.N:Sum[0] <a_Xe4DR>_R
                                   :: (Sum a_Xe4DR :: *) ~R# (a_Xe4DR :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_ae3ZV
                    $dMonad_se9r3
                    @ (Sum a_Xe4DR, Bool)
                    (h_ae1TP
                       (eta_XJX
                        `cast` (Data.Semigroup.Internal.N:Sum[0] <a_Xe4DR>_R
                                :: (Sum a_Xe4DR :: *) ~R# (a_Xe4DR :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds1_de7pa :: (Sum a_Xe4DR, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9Oa;
             True -> return @ m_ae3ZV $dMonad_se9r3 @ (Sum a_Xe4DR) x'_ae1TS
           }
           })

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl162_rejRZ :: forall a. Sum a -> Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl162_rejRZ = \ (@ a_Xe4DQ) _ [Occ=Dead] -> Data.Data.$cSum

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl163_rejS0 :: forall a. Sum a -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl163_rejS0 = \ (@ a_Xe4DQ) _ [Occ=Dead] -> Data.Data.$tSum

-- RHS size: {terms: 6, types: 35, coercions: 0, joins: 0/0}
lvl164_rejS1
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c (Sum a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl164_rejS1
  = \ (@ a_Xe4DQ)
      (@ (t_ae3XR :: * -> * -> *))
      (@ (c_ae3XS :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae3XS (Sum a_Xe4DQ))

-- RHS size: {terms: 63, types: 100, coercions: 32, joins: 0/0}
Data.Data.$fDataSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data a => Data (Sum a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_ae1Xg) (v_XJU :: Data a_ae1Xg) ->
       Data.Data.C:Data TYPE: Sum a_ae1Xg
                        (Data.Data.$fDataSum7 @ a_ae1Xg v_XJU)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Sum
                                                                                    a_ae1Xg>_N
                                :: (Data.Typeable.Internal.TypeRep (Sum a_ae1Xg) :: *)
                                   ~R# (Typeable (Sum a_ae1Xg) :: Constraint))
                        Data.Data.$fDataSum_$cgfoldl @ a_ae1Xg v_XJU
                        \ (@ (c_ae3Xg :: * -> *))
                          (k_ae2or [Occ=Once!]
                             :: forall b r. Data b => c_ae3Xg (b -> r) -> c_ae3Xg r)
                          (z_ae2os [Occ=Once!] :: forall r. r -> c_ae3Xg r)
                          _ [Occ=Dead] ->
                          k_ae2or
                            @ a_ae1Xg
                            @ (Sum a_ae1Xg)
                            v_XJU
                            (z_ae2os
                               @ (a_ae1Xg -> Sum a_ae1Xg)
                               ((Data.Data.$fDataConst2 @ a_ae1Xg)
                                `cast` (<a_ae1Xg>_R
                                        ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_ae1Xg>_R)
                                        :: (a_ae1Xg -> a_ae1Xg :: *)
                                           ~R# (a_ae1Xg -> Sum a_ae1Xg :: *))))
                        \ _ [Occ=Dead] -> Data.Data.$cSum
                        \ _ [Occ=Dead] -> Data.Data.$tSum
                        Data.Data.$fDataSum_$cdataCast1 @ a_ae1Xg v_XJU
                        \ (@ (t_ae3XR :: * -> * -> *))
                          (@ (c_ae3XS :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae3XS (Sum a_ae1Xg))
                        (\ (ds_de7wG [Occ=Once!] :: forall b. Data b => b -> b)
                           (x0_Xe33c [Occ=Once] :: Sum a_ae1Xg) ->
                           ds_de7wG
                             @ a_ae1Xg
                             v_XJU
                             (x0_Xe33c
                              `cast` (Data.Semigroup.Internal.N:Sum[0] <a_ae1Xg>_R
                                      :: (Sum a_ae1Xg :: *) ~R# (a_ae1Xg :: *))))
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <Sum a_ae1Xg>_R
                                ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_ae1Xg>_R)
                                :: ((forall b. Data b => b -> b) -> Sum a_ae1Xg -> a_ae1Xg :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> Sum a_ae1Xg -> Sum a_ae1Xg :: *))
                        \ (@ r_ae3Yp)
                          (@ r'_ae3Yq)
                          (ds_de7wH [Occ=Once!] :: r_ae3Yp -> r'_ae3Yq -> r_ae3Yp)
                          (ds1_de7wI [Occ=Once] :: r_ae3Yp)
                          (ds2_de7wJ [Occ=Once!] :: forall d. Data d => d -> r'_ae3Yq)
                          (eta_X1tU [Occ=Once] :: Sum a_ae1Xg) ->
                          ds_de7wH
                            ds1_de7wI
                            (ds2_de7wJ
                               @ a_ae1Xg
                               v_XJU
                               (eta_X1tU
                                `cast` (Data.Semigroup.Internal.N:Sum[0] <a_ae1Xg>_R
                                        :: (Sum a_ae1Xg :: *) ~R# (a_ae1Xg :: *))))
                        \ (@ r_ae3YG)
                          (@ r'_ae3YH)
                          (ds_de7wK [Occ=Once!] :: r'_ae3YH -> r_ae3YG -> r_ae3YG)
                          (ds1_de7wL [Occ=Once] :: r_ae3YG)
                          (ds2_de7wM [Occ=Once!] :: forall d. Data d => d -> r'_ae3YH)
                          (x0_ae1SX [Occ=Once] :: Sum a_ae1Xg) ->
                          ds_de7wK
                            (ds2_de7wM
                               @ a_ae1Xg
                               v_XJU
                               (x0_ae1SX
                                `cast` (Data.Semigroup.Internal.N:Sum[0] <a_ae1Xg>_R
                                        :: (Sum a_ae1Xg :: *) ~R# (a_ae1Xg :: *))))
                            ds1_de7wL
                        \ (@ u_ae3YX)
                          (ds_de7wN [Occ=Once!] :: forall d. Data d => d -> u_ae3YX)
                          (x0_ae1SX [Occ=Once] :: Sum a_ae1Xg) ->
                          GHC.Types.:
                            @ u_ae3YX
                            (ds_de7wN
                               @ a_ae1Xg
                               v_XJU
                               (x0_ae1SX
                                `cast` (Data.Semigroup.Internal.N:Sum[0] <a_ae1Xg>_R
                                        :: (Sum a_ae1Xg :: *) ~R# (a_ae1Xg :: *))))
                            (GHC.Types.[] @ u_ae3YX)
                        Data.Data.$fDataSum_$cgmapQi @ a_ae1Xg v_XJU
                        Data.Data.$fDataSum_$cgmapM @ a_ae1Xg v_XJU
                        Data.Data.$fDataSum_$cgmapMp @ a_ae1Xg v_XJU
                        Data.Data.$fDataSum_$cgmapMo @ a_ae1Xg v_XJU]
Data.Data.$fDataSum
  = \ (@ a_Xe4DQ) ($dData_Xe5nL :: Data a_Xe4DQ) ->
      Data.Data.C:Data
        @ (Sum a_Xe4DQ)
        ((Data.Data.$fDataSum7 @ a_Xe4DQ $dData_Xe5nL)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Sum
                                                                     a_Xe4DQ>_N
                 :: (Data.Typeable.Internal.TypeRep (Sum a_Xe4DQ) :: *)
                    ~R# (Typeable (Sum a_Xe4DQ) :: Constraint)))
        (Data.Data.$fDataSum_$cgfoldl @ a_Xe4DQ $dData_Xe5nL)
        (\ (@ (c_ae3Xg :: * -> *))
           (k_ae2or :: forall b r. Data b => c_ae3Xg (b -> r) -> c_ae3Xg r)
           (z_ae2os :: forall r. r -> c_ae3Xg r)
           _ [Occ=Dead] ->
           k_ae2or
             @ a_Xe4DQ
             @ (Sum a_Xe4DQ)
             $dData_Xe5nL
             (z_ae2os
                @ (a_Xe4DQ -> Sum a_Xe4DQ)
                ((Data.Data.$fDataConst2 @ a_Xe4DQ)
                 `cast` (<a_Xe4DQ>_R
                         ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_Xe4DQ>_R)
                         :: (a_Xe4DQ -> a_Xe4DQ :: *) ~R# (a_Xe4DQ -> Sum a_Xe4DQ :: *)))))
        (lvl162_rejRZ @ a_Xe4DQ)
        (lvl163_rejS0 @ a_Xe4DQ)
        (Data.Data.$fDataSum_$cdataCast1 @ a_Xe4DQ $dData_Xe5nL)
        (lvl164_rejS1 @ a_Xe4DQ)
        ((\ (ds_de7wG :: forall b. Data b => b -> b)
            (x0_Xe33c :: Sum a_Xe4DQ) ->
            ds_de7wG
              @ a_Xe4DQ
              $dData_Xe5nL
              (x0_Xe33c
               `cast` (Data.Semigroup.Internal.N:Sum[0] <a_Xe4DQ>_R
                       :: (Sum a_Xe4DQ :: *) ~R# (a_Xe4DQ :: *))))
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <Sum a_Xe4DQ>_R
                 ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_Xe4DQ>_R)
                 :: ((forall b. Data b => b -> b) -> Sum a_Xe4DQ -> a_Xe4DQ :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> Sum a_Xe4DQ -> Sum a_Xe4DQ :: *)))
        (\ (@ r_ae3Yp)
           (@ r'_ae3Yq)
           (ds_de7wH :: r_ae3Yp -> r'_ae3Yq -> r_ae3Yp)
           (ds1_de7wI :: r_ae3Yp)
           (ds2_de7wJ :: forall d. Data d => d -> r'_ae3Yq)
           (eta_XJU :: Sum a_Xe4DQ) ->
           ds_de7wH
             ds1_de7wI
             (ds2_de7wJ
                @ a_Xe4DQ
                $dData_Xe5nL
                (eta_XJU
                 `cast` (Data.Semigroup.Internal.N:Sum[0] <a_Xe4DQ>_R
                         :: (Sum a_Xe4DQ :: *) ~R# (a_Xe4DQ :: *)))))
        (\ (@ r_ae3YG)
           (@ r'_ae3YH)
           (ds_de7wK :: r'_ae3YH -> r_ae3YG -> r_ae3YG)
           (ds1_de7wL :: r_ae3YG)
           (ds2_de7wM :: forall d. Data d => d -> r'_ae3YH)
           (x0_ae1SX :: Sum a_Xe4DQ) ->
           ds_de7wK
             (ds2_de7wM
                @ a_Xe4DQ
                $dData_Xe5nL
                (x0_ae1SX
                 `cast` (Data.Semigroup.Internal.N:Sum[0] <a_Xe4DQ>_R
                         :: (Sum a_Xe4DQ :: *) ~R# (a_Xe4DQ :: *))))
             ds1_de7wL)
        (\ (@ u_ae3YX)
           (ds_de7wN :: forall d. Data d => d -> u_ae3YX)
           (x0_ae1SX :: Sum a_Xe4DQ) ->
           GHC.Types.:
             @ u_ae3YX
             (ds_de7wN
                @ a_Xe4DQ
                $dData_Xe5nL
                (x0_ae1SX
                 `cast` (Data.Semigroup.Internal.N:Sum[0] <a_Xe4DQ>_R
                         :: (Sum a_Xe4DQ :: *) ~R# (a_Xe4DQ :: *))))
             (GHC.Types.[] @ u_ae3YX))
        (Data.Data.$fDataSum_$cgmapQi @ a_Xe4DQ $dData_Xe5nL)
        (Data.Data.$fDataSum_$cgmapM @ a_Xe4DQ $dData_Xe5nL)
        (Data.Data.$fDataSum_$cgmapMp @ a_Xe4DQ $dData_Xe5nL)
        (Data.Data.$fDataSum_$cgmapMo @ a_Xe4DQ $dData_Xe5nL)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataProduct6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fDataProduct6 = "Product"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataProduct5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataProduct5 = unpackCString# Data.Data.$fDataProduct6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$cProduct1_rejS2 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$cProduct1_rejS2 = "getProduct"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cProduct2_rejS3 :: [Char]
[GblId]
$cProduct2_rejS3 = unpackCString# $cProduct1_rejS2

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$cProduct3_rejS4 :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cProduct3_rejS4
  = GHC.Types.: @ String $cProduct2_rejS3 (GHC.Types.[] @ String)

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go31_rejS5 :: [Constr] -> [Int] -> Int
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go31_rejS5
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fDataProduct5 of {
                False -> go31_rejS5 ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cProduct4_rejS6 :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cProduct4_rejS6 = Data.Data.AlgConstr $cProduct5_rejS7

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataProduct4 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataProduct4
  = GHC.Types.: @ Constr Data.Data.$cProduct (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataProduct3 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataProduct3
  = Data.Data.AlgRep Data.Data.$fDataProduct4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tProduct :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$tProduct
  = Data.Data.DataType
      Data.Data.$fDataProduct5 Data.Data.$fDataProduct3

-- RHS size: {terms: 6, types: 0, coercions: 0, joins: 0/0}
Data.Data.$cProduct [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cProduct
  = Data.Data.Constr
      $cProduct4_rejS6
      Data.Data.$fDataProduct5
      $cProduct3_rejS4
      Data.Data.Prefix
      Data.Data.$tProduct

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cProduct5_rejS7 :: Int
[GblId]
$cProduct5_rejS7
  = go31_rejS5 Data.Data.$fDataProduct4 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 4, types: 7, coercions: 5, joins: 0/0}
Data.Data.$fDataProduct1 :: forall a. (a -> Product a, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataProduct1
  = \ (@ a_Xe4B1) ->
      ((Data.Data.$fDataConst2 @ a_Xe4B1)
       `cast` (<a_Xe4B1>_R
               ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_Xe4B1>_R)
               :: (a_Xe4B1 -> a_Xe4B1 :: *)
                  ~R# (a_Xe4B1 -> Product a_Xe4B1 :: *)),
       GHC.Types.False)

-- RHS size: {terms: 57, types: 112, coercions: 4, joins: 0/3}
Data.Data.$fDataProduct_$cgmapMp
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Product a -> m (Product a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 510 0}]
Data.Data.$fDataProduct_$cgmapMp
  = \ (@ a_Xe4B1)
      ($dData_Xe4B3 :: Data a_Xe4B1)
      (@ (m_ae3Wr :: * -> *))
      ($dMonadPlus_ae3Wt :: MonadPlus m_ae3Wr)
      (ds_de7wy :: forall d. Data d => d -> m_ae3Wr d)
      (eta_XK5 :: Product a_Xe4B1) ->
      let {
        lvl270_se9Os :: m_ae3Wr (Product a_Xe4B1)
        [LclId]
        lvl270_se9Os
          = mzero @ m_ae3Wr $dMonadPlus_ae3Wt @ (Product a_Xe4B1) } in
      let {
        $dMonad_se9r1 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae3Wr
        [LclId]
        $dMonad_se9r1
          = GHC.Base.$p2MonadPlus @ m_ae3Wr $dMonadPlus_ae3Wt } in
      >>=
        @ m_ae3Wr
        $dMonad_se9r1
        @ (Product a_Xe4B1, Bool)
        @ (Product a_Xe4B1)
        (let {
           lvl271_se9Or :: m_ae3Wr a_Xe4B1
           [LclId]
           lvl271_se9Or
             = ds_de7wy
                 @ a_Xe4B1
                 $dData_Xe4B3
                 (eta_XK5
                  `cast` (Data.Semigroup.Internal.N:Product[0] <a_Xe4B1>_R
                          :: (Product a_Xe4B1 :: *) ~R# (a_Xe4B1 :: *))) } in
         >>=
           @ m_ae3Wr
           $dMonad_se9r1
           @ (a_Xe4B1 -> Product a_Xe4B1, Bool)
           @ (Product a_Xe4B1, Bool)
           (return
              @ m_ae3Wr
              $dMonad_se9r1
              @ (a_Xe4B1 -> Product a_Xe4B1, Bool)
              (Data.Data.$fDataProduct1 @ a_Xe4B1))
           (\ (ds1_de7oD :: (a_Xe4B1 -> Product a_Xe4B1, Bool)) ->
              case ds1_de7oD of { (h_ae1TA, b_ae1TB) ->
              mplus
                @ m_ae3Wr
                $dMonadPlus_ae3Wt
                @ (Product a_Xe4B1, Bool)
                (>>=
                   @ m_ae3Wr
                   $dMonad_se9r1
                   @ a_Xe4B1
                   @ (Product a_Xe4B1, Bool)
                   lvl271_se9Or
                   (\ (y'_ae1TC :: a_Xe4B1) ->
                      return
                        @ m_ae3Wr
                        $dMonad_se9r1
                        @ (Product a_Xe4B1, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_ae3Wr
                   $dMonad_se9r1
                   @ (Product a_Xe4B1, Bool)
                   (h_ae1TA
                      (eta_XK5
                       `cast` (Data.Semigroup.Internal.N:Product[0] <a_Xe4B1>_R
                               :: (Product a_Xe4B1 :: *) ~R# (a_Xe4B1 :: *))),
                    b_ae1TB))
              }))
        (\ (ds1_de7oa :: (Product a_Xe4B1, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9Os;
             True -> return @ m_ae3Wr $dMonad_se9r1 @ (Product a_Xe4B1) x'_ae1TD
           }
           })

-- RHS size: {terms: 24, types: 44, coercions: 7, joins: 0/1}
Data.Data.$fDataProduct_$cgmapM
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Product a -> m (Product a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120 60 0] 220 0}]
Data.Data.$fDataProduct_$cgmapM
  = \ (@ a_Xe4B0)
      ($dData_Xe4B2 :: Data a_Xe4B0)
      (@ (m_ae3Wb :: * -> *))
      ($dMonad_ae3Wd :: Monad m_ae3Wb)
      (ds_de7wx :: forall d. Data d => d -> m_ae3Wb d)
      (eta_XK6 :: Product a_Xe4B0) ->
      let {
        lvl270_se9Ou :: m_ae3Wb a_Xe4B0
        [LclId]
        lvl270_se9Ou
          = ds_de7wx
              @ a_Xe4B0
              $dData_Xe4B2
              (eta_XK6
               `cast` (Data.Semigroup.Internal.N:Product[0] <a_Xe4B0>_R
                       :: (Product a_Xe4B0 :: *) ~R# (a_Xe4B0 :: *))) } in
      >>=
        @ m_ae3Wb
        $dMonad_ae3Wd
        @ (a_Xe4B0 -> Product a_Xe4B0)
        @ (Product a_Xe4B0)
        (return
           @ m_ae3Wb
           $dMonad_ae3Wd
           @ (a_Xe4B0 -> Product a_Xe4B0)
           ((Data.Data.$fDataConst2 @ a_Xe4B0)
            `cast` (<a_Xe4B0>_R
                    ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_Xe4B0>_R)
                    :: (a_Xe4B0 -> a_Xe4B0 :: *)
                       ~R# (a_Xe4B0 -> Product a_Xe4B0 :: *))))
        (\ (c'_ae1To :: a_Xe4B0 -> Product a_Xe4B0) ->
           >>=
             @ m_ae3Wb
             $dMonad_ae3Wd
             @ a_Xe4B0
             @ (Product a_Xe4B0)
             lvl270_se9Ou
             (\ (x'_ae1Tp :: a_Xe4B0) ->
                return
                  @ m_ae3Wb $dMonad_ae3Wd @ (Product a_Xe4B0) (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 17, types: 20, coercions: 2, joins: 0/0}
Data.Data.$fDataProduct_$cgmapQi
  :: forall a.
     Data a =>
     forall u. Int -> (forall d. Data d => d -> u) -> Product a -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe4AZ)
                 ($dData_Xe4B1 [Occ=Once] :: Data a_Xe4AZ)
                 (@ u_ae3VX)
                 (ds_de7wv [Occ=Once!] :: Int)
                 (ds1_de7ww [Occ=Once!] :: forall d. Data d => d -> u_ae3VX)
                 (x_ae1T7 [Occ=Once] :: Product a_Xe4AZ) ->
                 case ds_de7wv of { I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3VX;
                   0# ->
                     ds1_de7ww
                       @ a_Xe4AZ
                       $dData_Xe4B1
                       (x_ae1T7
                        `cast` (Data.Semigroup.Internal.N:Product[0] <a_Xe4AZ>_R
                                :: (Product a_Xe4AZ :: *) ~R# (a_Xe4AZ :: *)))
                 }
                 }}]
Data.Data.$fDataProduct_$cgmapQi
  = \ (@ a_Xe4AZ)
      ($dData_Xe4B1 :: Data a_Xe4AZ)
      (@ u_ae3VX)
      (ds_de7wv :: Int)
      (ds1_de7ww :: forall d. Data d => d -> u_ae3VX)
      (x_ae1T7 :: Product a_Xe4AZ) ->
      case ds_de7wv of { I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3VX;
        0# ->
          ds1_de7ww
            @ a_Xe4AZ
            $dData_Xe4B1
            (x_ae1T7
             `cast` (Data.Semigroup.Internal.N:Product[0] <a_Xe4AZ>_R
                     :: (Product a_Xe4AZ :: *) ~R# (a_Xe4AZ :: *)))
      }
      }

-- RHS size: {terms: 67, types: 121, coercions: 6, joins: 0/3}
Data.Data.$fDataProduct_$cgmapMo
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Product a -> m (Product a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 590 0}]
Data.Data.$fDataProduct_$cgmapMo
  = \ (@ a_Xe4AU)
      ($dData_Xe4AW :: Data a_Xe4AU)
      (@ (m_ae3WH :: * -> *))
      ($dMonadPlus_ae3WJ :: MonadPlus m_ae3WH)
      (ds_de7wz :: forall d. Data d => d -> m_ae3WH d)
      (eta_XKf :: Product a_Xe4AU) ->
      let {
        lvl270_se9Oz :: m_ae3WH (Product a_Xe4AU)
        [LclId]
        lvl270_se9Oz
          = mzero @ m_ae3WH $dMonadPlus_ae3WJ @ (Product a_Xe4AU) } in
      let {
        $dMonad_se9qZ [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae3WH
        [LclId]
        $dMonad_se9qZ
          = GHC.Base.$p2MonadPlus @ m_ae3WH $dMonadPlus_ae3WJ } in
      >>=
        @ m_ae3WH
        $dMonad_se9qZ
        @ (Product a_Xe4AU, Bool)
        @ (Product a_Xe4AU)
        (let {
           lvl271_se9Oy :: m_ae3WH a_Xe4AU
           [LclId]
           lvl271_se9Oy
             = ds_de7wz
                 @ a_Xe4AU
                 $dData_Xe4AW
                 (eta_XKf
                  `cast` (Data.Semigroup.Internal.N:Product[0] <a_Xe4AU>_R
                          :: (Product a_Xe4AU :: *) ~R# (a_Xe4AU :: *))) } in
         >>=
           @ m_ae3WH
           $dMonad_se9qZ
           @ (a_Xe4AU -> Product a_Xe4AU, Bool)
           @ (Product a_Xe4AU, Bool)
           (return
              @ m_ae3WH
              $dMonad_se9qZ
              @ (a_Xe4AU -> Product a_Xe4AU, Bool)
              (Data.Data.$fDataProduct1 @ a_Xe4AU))
           (\ (ds1_de7pD :: (a_Xe4AU -> Product a_Xe4AU, Bool)) ->
              case ds1_de7pD of { (h_ae1TP, b_ae1TQ) ->
              case b_ae1TQ of {
                False ->
                  mplus
                    @ m_ae3WH
                    $dMonadPlus_ae3WJ
                    @ (Product a_Xe4AU, Bool)
                    (>>=
                       @ m_ae3WH
                       $dMonad_se9qZ
                       @ a_Xe4AU
                       @ (Product a_Xe4AU, Bool)
                       lvl271_se9Oy
                       (\ (y'_ae1TR :: a_Xe4AU) ->
                          return
                            @ m_ae3WH
                            $dMonad_se9qZ
                            @ (Product a_Xe4AU, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_ae3WH
                       $dMonad_se9qZ
                       @ (Product a_Xe4AU, Bool)
                       (h_ae1TP
                          (eta_XKf
                           `cast` (Data.Semigroup.Internal.N:Product[0] <a_Xe4AU>_R
                                   :: (Product a_Xe4AU :: *) ~R# (a_Xe4AU :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_ae3WH
                    $dMonad_se9qZ
                    @ (Product a_Xe4AU, Bool)
                    (h_ae1TP
                       (eta_XKf
                        `cast` (Data.Semigroup.Internal.N:Product[0] <a_Xe4AU>_R
                                :: (Product a_Xe4AU :: *) ~R# (a_Xe4AU :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds1_de7pa :: (Product a_Xe4AU, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9Oz;
             True -> return @ m_ae3WH $dMonad_se9qZ @ (Product a_Xe4AU) x'_ae1TS
           }
           })

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl165_rejS8 :: forall a. Product a -> Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl165_rejS8 = \ (@ a_Xe4AT) _ [Occ=Dead] -> Data.Data.$cProduct

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl166_rejS9 :: forall a. Product a -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl166_rejS9 = \ (@ a_Xe4AT) _ [Occ=Dead] -> Data.Data.$tProduct

-- RHS size: {terms: 6, types: 35, coercions: 0, joins: 0/0}
lvl167_rejSa
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e))
     -> Maybe (c (Product a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl167_rejSa
  = \ (@ a_Xe4AT)
      (@ (t_ae3UD :: * -> * -> *))
      (@ (c_ae3UE :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae3UE (Product a_Xe4AT))

-- RHS size: {terms: 63, types: 100, coercions: 32, joins: 0/0}
Data.Data.$fDataProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data a => Data (Product a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_ae1Xf) (v_XKc :: Data a_ae1Xf) ->
       Data.Data.C:Data TYPE: Product a_ae1Xf
                        (Data.Data.$fDataProduct7 @ a_ae1Xf v_XKc)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Product
                                                                                    a_ae1Xf>_N
                                :: (Data.Typeable.Internal.TypeRep (Product a_ae1Xf) :: *)
                                   ~R# (Typeable (Product a_ae1Xf) :: Constraint))
                        Data.Data.$fDataProduct_$cgfoldl @ a_ae1Xf v_XKc
                        \ (@ (c_ae3U2 :: * -> *))
                          (k_ae2ol [Occ=Once!]
                             :: forall b r. Data b => c_ae3U2 (b -> r) -> c_ae3U2 r)
                          (z_ae2om [Occ=Once!] :: forall r. r -> c_ae3U2 r)
                          _ [Occ=Dead] ->
                          k_ae2ol
                            @ a_ae1Xf
                            @ (Product a_ae1Xf)
                            v_XKc
                            (z_ae2om
                               @ (a_ae1Xf -> Product a_ae1Xf)
                               ((Data.Data.$fDataConst2 @ a_ae1Xf)
                                `cast` (<a_ae1Xf>_R
                                        ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_ae1Xf>_R)
                                        :: (a_ae1Xf -> a_ae1Xf :: *)
                                           ~R# (a_ae1Xf -> Product a_ae1Xf :: *))))
                        \ _ [Occ=Dead] -> Data.Data.$cProduct
                        \ _ [Occ=Dead] -> Data.Data.$tProduct
                        Data.Data.$fDataProduct_$cdataCast1 @ a_ae1Xf v_XKc
                        \ (@ (t_ae3UD :: * -> * -> *))
                          (@ (c_ae3UE :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae3UE (Product a_ae1Xf))
                        (\ (ds_de7wn [Occ=Once!] :: forall b. Data b => b -> b)
                           (x0_Xe33u [Occ=Once] :: Product a_ae1Xf) ->
                           ds_de7wn
                             @ a_ae1Xf
                             v_XKc
                             (x0_Xe33u
                              `cast` (Data.Semigroup.Internal.N:Product[0] <a_ae1Xf>_R
                                      :: (Product a_ae1Xf :: *) ~R# (a_ae1Xf :: *))))
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <Product a_ae1Xf>_R
                                ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_ae1Xf>_R)
                                :: ((forall b. Data b => b -> b)
                                    -> Product a_ae1Xf -> a_ae1Xf :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> Product a_ae1Xf -> Product a_ae1Xf :: *))
                        \ (@ r_ae3Vb)
                          (@ r'_ae3Vc)
                          (ds_de7wo [Occ=Once!] :: r_ae3Vb -> r'_ae3Vc -> r_ae3Vb)
                          (ds1_de7wp [Occ=Once] :: r_ae3Vb)
                          (ds2_de7wq [Occ=Once!] :: forall d. Data d => d -> r'_ae3Vc)
                          (eta_X1uu [Occ=Once] :: Product a_ae1Xf) ->
                          ds_de7wo
                            ds1_de7wp
                            (ds2_de7wq
                               @ a_ae1Xf
                               v_XKc
                               (eta_X1uu
                                `cast` (Data.Semigroup.Internal.N:Product[0] <a_ae1Xf>_R
                                        :: (Product a_ae1Xf :: *) ~R# (a_ae1Xf :: *))))
                        \ (@ r_ae3Vs)
                          (@ r'_ae3Vt)
                          (ds_de7wr [Occ=Once!] :: r'_ae3Vt -> r_ae3Vs -> r_ae3Vs)
                          (ds1_de7ws [Occ=Once] :: r_ae3Vs)
                          (ds2_de7wt [Occ=Once!] :: forall d. Data d => d -> r'_ae3Vt)
                          (x0_ae1SX [Occ=Once] :: Product a_ae1Xf) ->
                          ds_de7wr
                            (ds2_de7wt
                               @ a_ae1Xf
                               v_XKc
                               (x0_ae1SX
                                `cast` (Data.Semigroup.Internal.N:Product[0] <a_ae1Xf>_R
                                        :: (Product a_ae1Xf :: *) ~R# (a_ae1Xf :: *))))
                            ds1_de7ws
                        \ (@ u_ae3VJ)
                          (ds_de7wu [Occ=Once!] :: forall d. Data d => d -> u_ae3VJ)
                          (x0_ae1SX [Occ=Once] :: Product a_ae1Xf) ->
                          GHC.Types.:
                            @ u_ae3VJ
                            (ds_de7wu
                               @ a_ae1Xf
                               v_XKc
                               (x0_ae1SX
                                `cast` (Data.Semigroup.Internal.N:Product[0] <a_ae1Xf>_R
                                        :: (Product a_ae1Xf :: *) ~R# (a_ae1Xf :: *))))
                            (GHC.Types.[] @ u_ae3VJ)
                        Data.Data.$fDataProduct_$cgmapQi @ a_ae1Xf v_XKc
                        Data.Data.$fDataProduct_$cgmapM @ a_ae1Xf v_XKc
                        Data.Data.$fDataProduct_$cgmapMp @ a_ae1Xf v_XKc
                        Data.Data.$fDataProduct_$cgmapMo @ a_ae1Xf v_XKc]
Data.Data.$fDataProduct
  = \ (@ a_Xe4AT) ($dData_Xe5l6 :: Data a_Xe4AT) ->
      Data.Data.C:Data
        @ (Product a_Xe4AT)
        ((Data.Data.$fDataProduct7 @ a_Xe4AT $dData_Xe5l6)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Product
                                                                     a_Xe4AT>_N
                 :: (Data.Typeable.Internal.TypeRep (Product a_Xe4AT) :: *)
                    ~R# (Typeable (Product a_Xe4AT) :: Constraint)))
        (Data.Data.$fDataProduct_$cgfoldl @ a_Xe4AT $dData_Xe5l6)
        (\ (@ (c_ae3U2 :: * -> *))
           (k_ae2ol :: forall b r. Data b => c_ae3U2 (b -> r) -> c_ae3U2 r)
           (z_ae2om :: forall r. r -> c_ae3U2 r)
           _ [Occ=Dead] ->
           k_ae2ol
             @ a_Xe4AT
             @ (Product a_Xe4AT)
             $dData_Xe5l6
             (z_ae2om
                @ (a_Xe4AT -> Product a_Xe4AT)
                ((Data.Data.$fDataConst2 @ a_Xe4AT)
                 `cast` (<a_Xe4AT>_R
                         ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_Xe4AT>_R)
                         :: (a_Xe4AT -> a_Xe4AT :: *)
                            ~R# (a_Xe4AT -> Product a_Xe4AT :: *)))))
        (lvl165_rejS8 @ a_Xe4AT)
        (lvl166_rejS9 @ a_Xe4AT)
        (Data.Data.$fDataProduct_$cdataCast1 @ a_Xe4AT $dData_Xe5l6)
        (lvl167_rejSa @ a_Xe4AT)
        ((\ (ds_de7wn :: forall b. Data b => b -> b)
            (x0_Xe33u :: Product a_Xe4AT) ->
            ds_de7wn
              @ a_Xe4AT
              $dData_Xe5l6
              (x0_Xe33u
               `cast` (Data.Semigroup.Internal.N:Product[0] <a_Xe4AT>_R
                       :: (Product a_Xe4AT :: *) ~R# (a_Xe4AT :: *))))
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <Product a_Xe4AT>_R
                 ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_Xe4AT>_R)
                 :: ((forall b. Data b => b -> b)
                     -> Product a_Xe4AT -> a_Xe4AT :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> Product a_Xe4AT -> Product a_Xe4AT :: *)))
        (\ (@ r_ae3Vb)
           (@ r'_ae3Vc)
           (ds_de7wo :: r_ae3Vb -> r'_ae3Vc -> r_ae3Vb)
           (ds1_de7wp :: r_ae3Vb)
           (ds2_de7wq :: forall d. Data d => d -> r'_ae3Vc)
           (eta_XKc :: Product a_Xe4AT) ->
           ds_de7wo
             ds1_de7wp
             (ds2_de7wq
                @ a_Xe4AT
                $dData_Xe5l6
                (eta_XKc
                 `cast` (Data.Semigroup.Internal.N:Product[0] <a_Xe4AT>_R
                         :: (Product a_Xe4AT :: *) ~R# (a_Xe4AT :: *)))))
        (\ (@ r_ae3Vs)
           (@ r'_ae3Vt)
           (ds_de7wr :: r'_ae3Vt -> r_ae3Vs -> r_ae3Vs)
           (ds1_de7ws :: r_ae3Vs)
           (ds2_de7wt :: forall d. Data d => d -> r'_ae3Vt)
           (x0_ae1SX :: Product a_Xe4AT) ->
           ds_de7wr
             (ds2_de7wt
                @ a_Xe4AT
                $dData_Xe5l6
                (x0_ae1SX
                 `cast` (Data.Semigroup.Internal.N:Product[0] <a_Xe4AT>_R
                         :: (Product a_Xe4AT :: *) ~R# (a_Xe4AT :: *))))
             ds1_de7ws)
        (\ (@ u_ae3VJ)
           (ds_de7wu :: forall d. Data d => d -> u_ae3VJ)
           (x0_ae1SX :: Product a_Xe4AT) ->
           GHC.Types.:
             @ u_ae3VJ
             (ds_de7wu
                @ a_Xe4AT
                $dData_Xe5l6
                (x0_ae1SX
                 `cast` (Data.Semigroup.Internal.N:Product[0] <a_Xe4AT>_R
                         :: (Product a_Xe4AT :: *) ~R# (a_Xe4AT :: *))))
             (GHC.Types.[] @ u_ae3VJ))
        (Data.Data.$fDataProduct_$cgmapQi @ a_Xe4AT $dData_Xe5l6)
        (Data.Data.$fDataProduct_$cgmapM @ a_Xe4AT $dData_Xe5l6)
        (Data.Data.$fDataProduct_$cgmapMp @ a_Xe4AT $dData_Xe5l6)
        (Data.Data.$fDataProduct_$cgmapMo @ a_Xe4AT $dData_Xe5l6)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataFirst8 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Data.$fDataFirst8 = "First"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataFirst7 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataFirst7 = unpackCString# Data.Data.$fDataFirst8

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$cFirst1_rejSb :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$cFirst1_rejSb = "getFirst"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cFirst2_rejSc :: [Char]
[GblId]
$cFirst2_rejSc = unpackCString# $cFirst1_rejSb

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$cFirst3_rejSd :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cFirst3_rejSd
  = GHC.Types.: @ String $cFirst2_rejSc (GHC.Types.[] @ String)

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go32_rejSe :: [Constr] -> [Int] -> Int
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go32_rejSe
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fDataFirst7 of {
                False -> go32_rejSe ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cFirst4_rejSf :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cFirst4_rejSf = Data.Data.AlgConstr $cFirst5_rejSg

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataFirst6 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataFirst6
  = GHC.Types.: @ Constr Data.Data.$cFirst (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataFirst5 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataFirst5 = Data.Data.AlgRep Data.Data.$fDataFirst6

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tFirst :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$tFirst
  = Data.Data.DataType Data.Data.$fDataFirst7 Data.Data.$fDataFirst5

-- RHS size: {terms: 6, types: 0, coercions: 0, joins: 0/0}
Data.Data.$cFirst [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cFirst
  = Data.Data.Constr
      $cFirst4_rejSf
      Data.Data.$fDataFirst7
      $cFirst3_rejSd
      Data.Data.Prefix
      Data.Data.$tFirst

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cFirst5_rejSg :: Int
[GblId]
$cFirst5_rejSg
  = go32_rejSe Data.Data.$fDataFirst6 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 4, types: 8, coercions: 6, joins: 0/0}
Data.Data.$fDataFirst1 :: forall a. (Maybe a -> First a, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataFirst1
  = \ (@ a_Xe4y4) ->
      ((Data.Data.$fDataFirst2 @ a_Xe4y4)
       `cast` (<Maybe a_Xe4y4>_R
               ->_R Sym (Data.Monoid.N:First[0]) <a_Xe4y4>_N
               :: (Maybe a_Xe4y4 -> Maybe a_Xe4y4 :: *)
                  ~R# (Maybe a_Xe4y4 -> First a_Xe4y4 :: *)),
       GHC.Types.False)

-- RHS size: {terms: 58, types: 122, coercions: 4, joins: 0/3}
Data.Data.$fDataFirst_$cgmapMp
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> First a -> m (First a)
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 530 0}]
Data.Data.$fDataFirst_$cgmapMp
  = \ (@ a_Xe4y4)
      ($dData_Xe4y6 :: Data a_Xe4y4)
      (@ (m_ae3Td :: * -> *))
      ($dMonadPlus_ae3Tf :: MonadPlus m_ae3Td)
      (ds_de7wf :: forall d. Data d => d -> m_ae3Td d)
      (eta_XKn :: First a_Xe4y4) ->
      let {
        lvl270_se9OR :: m_ae3Td (First a_Xe4y4)
        [LclId]
        lvl270_se9OR
          = mzero @ m_ae3Td $dMonadPlus_ae3Tf @ (First a_Xe4y4) } in
      let {
        $dMonad_se9qX [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae3Td
        [LclId]
        $dMonad_se9qX
          = GHC.Base.$p2MonadPlus @ m_ae3Td $dMonadPlus_ae3Tf } in
      >>=
        @ m_ae3Td
        $dMonad_se9qX
        @ (First a_Xe4y4, Bool)
        @ (First a_Xe4y4)
        (let {
           lvl271_se9OQ :: m_ae3Td (Maybe a_Xe4y4)
           [LclId]
           lvl271_se9OQ
             = ds_de7wf
                 @ (Maybe a_Xe4y4)
                 (Data.Data.$fDataMaybe @ a_Xe4y4 $dData_Xe4y6)
                 (eta_XKn
                  `cast` (Data.Monoid.N:First[0] <a_Xe4y4>_N
                          :: (First a_Xe4y4 :: *) ~R# (Maybe a_Xe4y4 :: *))) } in
         >>=
           @ m_ae3Td
           $dMonad_se9qX
           @ (Maybe a_Xe4y4 -> First a_Xe4y4, Bool)
           @ (First a_Xe4y4, Bool)
           (return
              @ m_ae3Td
              $dMonad_se9qX
              @ (Maybe a_Xe4y4 -> First a_Xe4y4, Bool)
              (Data.Data.$fDataFirst1 @ a_Xe4y4))
           (\ (ds1_de7oD :: (Maybe a_Xe4y4 -> First a_Xe4y4, Bool)) ->
              case ds1_de7oD of { (h_ae1TA, b_ae1TB) ->
              mplus
                @ m_ae3Td
                $dMonadPlus_ae3Tf
                @ (First a_Xe4y4, Bool)
                (>>=
                   @ m_ae3Td
                   $dMonad_se9qX
                   @ (Maybe a_Xe4y4)
                   @ (First a_Xe4y4, Bool)
                   lvl271_se9OQ
                   (\ (y'_ae1TC :: Maybe a_Xe4y4) ->
                      return
                        @ m_ae3Td
                        $dMonad_se9qX
                        @ (First a_Xe4y4, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_ae3Td
                   $dMonad_se9qX
                   @ (First a_Xe4y4, Bool)
                   (h_ae1TA
                      (eta_XKn
                       `cast` (Data.Monoid.N:First[0] <a_Xe4y4>_N
                               :: (First a_Xe4y4 :: *) ~R# (Maybe a_Xe4y4 :: *))),
                    b_ae1TB))
              }))
        (\ (ds1_de7oa :: (First a_Xe4y4, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9OR;
             True -> return @ m_ae3Td $dMonad_se9qX @ (First a_Xe4y4) x'_ae1TD
           }
           })

-- RHS size: {terms: 29, types: 60, coercions: 8, joins: 0/3}
Data.Data.$fDataFirst_$cgmapM
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> First a -> m (First a)
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120 60] 270 60}]
Data.Data.$fDataFirst_$cgmapM
  = \ (@ a_Xe4y3)
      ($dData_Xe4y5 :: Data a_Xe4y3)
      (@ (m_ae3SX :: * -> *))
      ($dMonad_ae3SZ :: Monad m_ae3SX)
      (ds_de7we :: forall d. Data d => d -> m_ae3SX d) ->
      let {
        $dData1_se9qT :: Data (Maybe a_Xe4y3)
        [LclId]
        $dData1_se9qT = Data.Data.$fDataMaybe @ a_Xe4y3 $dData_Xe4y5 } in
      let {
        lvl270_se9OT :: m_ae3SX (Maybe a_Xe4y3 -> First a_Xe4y3)
        [LclId]
        lvl270_se9OT
          = return
              @ m_ae3SX
              $dMonad_ae3SZ
              @ (Maybe a_Xe4y3 -> First a_Xe4y3)
              ((Data.Data.$fDataFirst2 @ a_Xe4y3)
               `cast` (<Maybe a_Xe4y3>_R
                       ->_R Sym (Data.Monoid.N:First[0]) <a_Xe4y3>_N
                       :: (Maybe a_Xe4y3 -> Maybe a_Xe4y3 :: *)
                          ~R# (Maybe a_Xe4y3 -> First a_Xe4y3 :: *))) } in
      \ (ds1_de7vY :: First a_Xe4y3) ->
        let {
          lvl271_se9OU :: m_ae3SX (Maybe a_Xe4y3)
          [LclId]
          lvl271_se9OU
            = ds_de7we
                @ (Maybe a_Xe4y3)
                $dData1_se9qT
                (ds1_de7vY
                 `cast` (Data.Monoid.N:First[0] <a_Xe4y3>_N
                         :: (First a_Xe4y3 :: *) ~R# (Maybe a_Xe4y3 :: *))) } in
        >>=
          @ m_ae3SX
          $dMonad_ae3SZ
          @ (Maybe a_Xe4y3 -> First a_Xe4y3)
          @ (First a_Xe4y3)
          lvl270_se9OT
          (\ (c'_ae1To :: Maybe a_Xe4y3 -> First a_Xe4y3) ->
             >>=
               @ m_ae3SX
               $dMonad_ae3SZ
               @ (Maybe a_Xe4y3)
               @ (First a_Xe4y3)
               lvl271_se9OU
               (\ (x'_ae1Tp :: Maybe a_Xe4y3) ->
                  return
                    @ m_ae3SX $dMonad_ae3SZ @ (First a_Xe4y3) (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 18, types: 22, coercions: 2, joins: 0/0}
Data.Data.$fDataFirst_$cgmapQi
  :: forall a.
     Data a =>
     forall u. Int -> (forall d. Data d => d -> u) -> First a -> u
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe4y2)
                 ($dData_Xe4y4 [Occ=Once] :: Data a_Xe4y2)
                 (@ u_ae3SJ)
                 (ds_de7wc [Occ=Once!] :: Int)
                 (ds1_de7wd [Occ=Once!] :: forall d. Data d => d -> u_ae3SJ)
                 (x_ae1T7 [Occ=Once] :: First a_Xe4y2) ->
                 case ds_de7wc of { I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3SJ;
                   0# ->
                     ds1_de7wd
                       @ (Maybe a_Xe4y2)
                       (Data.Data.$fDataMaybe @ a_Xe4y2 $dData_Xe4y4)
                       (x_ae1T7
                        `cast` (Data.Monoid.N:First[0] <a_Xe4y2>_N
                                :: (First a_Xe4y2 :: *) ~R# (Maybe a_Xe4y2 :: *)))
                 }
                 }}]
Data.Data.$fDataFirst_$cgmapQi
  = \ (@ a_Xe4y2)
      ($dData_Xe4y4 :: Data a_Xe4y2)
      (@ u_ae3SJ)
      (ds_de7wc :: Int)
      (ds1_de7wd :: forall d. Data d => d -> u_ae3SJ)
      (x_ae1T7 :: First a_Xe4y2) ->
      case ds_de7wc of { I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3SJ;
        0# ->
          ds1_de7wd
            @ (Maybe a_Xe4y2)
            (Data.Data.$fDataMaybe @ a_Xe4y2 $dData_Xe4y4)
            (x_ae1T7
             `cast` (Data.Monoid.N:First[0] <a_Xe4y2>_N
                     :: (First a_Xe4y2 :: *) ~R# (Maybe a_Xe4y2 :: *)))
      }
      }

-- RHS size: {terms: 14, types: 23, coercions: 2, joins: 0/0}
Data.Data.$fDataFirst_$cgmapQr
  :: forall a.
     Data a =>
     forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> First a -> r
[GblId,
 Arity=5,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe4y0)
                 ($dData_Xe4y2 [Occ=Once] :: Data a_Xe4y0)
                 (@ r_ae3Se)
                 (@ r'_ae3Sf)
                 (ds_de7w8 [Occ=Once!] :: r'_ae3Sf -> r_ae3Se -> r_ae3Se)
                 (ds1_de7w9 [Occ=Once] :: r_ae3Se)
                 (ds2_de7wa [Occ=Once!] :: forall d. Data d => d -> r'_ae3Sf)
                 (x0_ae1SX [Occ=Once] :: First a_Xe4y0) ->
                 ds_de7w8
                   (ds2_de7wa
                      @ (Maybe a_Xe4y0)
                      (Data.Data.$fDataMaybe @ a_Xe4y0 $dData_Xe4y2)
                      (x0_ae1SX
                       `cast` (Data.Monoid.N:First[0] <a_Xe4y0>_N
                               :: (First a_Xe4y0 :: *) ~R# (Maybe a_Xe4y0 :: *))))
                   ds1_de7w9}]
Data.Data.$fDataFirst_$cgmapQr
  = \ (@ a_Xe4y0)
      ($dData_Xe4y2 :: Data a_Xe4y0)
      (@ r_ae3Se)
      (@ r'_ae3Sf)
      (ds_de7w8 :: r'_ae3Sf -> r_ae3Se -> r_ae3Se)
      (ds1_de7w9 :: r_ae3Se)
      (ds2_de7wa :: forall d. Data d => d -> r'_ae3Sf)
      (x0_ae1SX :: First a_Xe4y0) ->
      ds_de7w8
        (ds2_de7wa
           @ (Maybe a_Xe4y0)
           (Data.Data.$fDataMaybe @ a_Xe4y0 $dData_Xe4y2)
           (x0_ae1SX
            `cast` (Data.Monoid.N:First[0] <a_Xe4y0>_N
                    :: (First a_Xe4y0 :: *) ~R# (Maybe a_Xe4y0 :: *))))
        ds1_de7w9

-- RHS size: {terms: 11, types: 19, coercions: 2, joins: 0/0}
Data.Data.$fDataFirst_$cgmapQ
  :: forall a.
     Data a =>
     forall u. (forall d. Data d => d -> u) -> First a -> [u]
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,1*C1(C1(U))><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe4y1)
                 ($dData_Xe4y3 [Occ=Once] :: Data a_Xe4y1)
                 (@ u_ae3Sv)
                 (ds_de7wb [Occ=Once!] :: forall d. Data d => d -> u_ae3Sv)
                 (x0_ae1SX [Occ=Once] :: First a_Xe4y1) ->
                 GHC.Types.:
                   @ u_ae3Sv
                   (ds_de7wb
                      @ (Maybe a_Xe4y1)
                      (Data.Data.$fDataMaybe @ a_Xe4y1 $dData_Xe4y3)
                      (x0_ae1SX
                       `cast` (Data.Monoid.N:First[0] <a_Xe4y1>_N
                               :: (First a_Xe4y1 :: *) ~R# (Maybe a_Xe4y1 :: *))))
                   (GHC.Types.[] @ u_ae3Sv)}]
Data.Data.$fDataFirst_$cgmapQ
  = \ (@ a_Xe4y1)
      ($dData_Xe4y3 :: Data a_Xe4y1)
      (@ u_ae3Sv)
      (ds_de7wb :: forall d. Data d => d -> u_ae3Sv)
      (x0_ae1SX :: First a_Xe4y1) ->
      GHC.Types.:
        @ u_ae3Sv
        (ds_de7wb
           @ (Maybe a_Xe4y1)
           (Data.Data.$fDataMaybe @ a_Xe4y1 $dData_Xe4y3)
           (x0_ae1SX
            `cast` (Data.Monoid.N:First[0] <a_Xe4y1>_N
                    :: (First a_Xe4y1 :: *) ~R# (Maybe a_Xe4y1 :: *))))
        (GHC.Types.[] @ u_ae3Sv)

-- RHS size: {terms: 16, types: 26, coercions: 2, joins: 0/1}
Data.Data.$fDataFirst_$cgmapQl
  :: forall a.
     Data a =>
     forall r r'.
     (r -> r' -> r)
     -> r -> (forall d. Data d => d -> r') -> First a -> r
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe4xZ)
                 ($dData_Xe4y1 [Occ=OnceL] :: Data a_Xe4xZ)
                 (@ r_ae3RX)
                 (@ r'_ae3RY)
                 (ds_de7w5 [Occ=OnceL!] :: r_ae3RX -> r'_ae3RY -> r_ae3RX)
                 (ds1_de7w6 [Occ=OnceL] :: r_ae3RX)
                 (ds2_de7w7 [Occ=OnceL!] :: forall d. Data d => d -> r'_ae3RY) ->
                 let {
                   $dData1_se9qP [Occ=OnceL] :: Data (Maybe a_Xe4xZ)
                   [LclId]
                   $dData1_se9qP = Data.Data.$fDataMaybe @ a_Xe4xZ $dData_Xe4y1 } in
                 \ (x_i7Rxi [Occ=Once] :: First a_Xe4xZ) ->
                   ds_de7w5
                     ds1_de7w6
                     (ds2_de7w7
                        @ (Maybe a_Xe4xZ)
                        $dData1_se9qP
                        (x_i7Rxi
                         `cast` (Data.Monoid.N:First[0] <a_Xe4xZ>_N
                                 :: (First a_Xe4xZ :: *) ~R# (Maybe a_Xe4xZ :: *))))}]
Data.Data.$fDataFirst_$cgmapQl
  = \ (@ a_Xe4xZ)
      ($dData_Xe4y1 :: Data a_Xe4xZ)
      (@ r_ae3RX)
      (@ r'_ae3RY)
      (ds_de7w5 :: r_ae3RX -> r'_ae3RY -> r_ae3RX)
      (ds1_de7w6 :: r_ae3RX)
      (ds2_de7w7 :: forall d. Data d => d -> r'_ae3RY) ->
      let {
        $dData1_se9qP :: Data (Maybe a_Xe4xZ)
        [LclId]
        $dData1_se9qP = Data.Data.$fDataMaybe @ a_Xe4xZ $dData_Xe4y1 } in
      \ (x_i7Rxi :: First a_Xe4xZ) ->
        ds_de7w5
          ds1_de7w6
          (ds2_de7w7
             @ (Maybe a_Xe4xZ)
             $dData1_se9qP
             (x_i7Rxi
              `cast` (Data.Monoid.N:First[0] <a_Xe4xZ>_N
                      :: (First a_Xe4xZ :: *) ~R# (Maybe a_Xe4xZ :: *))))

-- RHS size: {terms: 8, types: 15, coercions: 2, joins: 0/0}
Data.Data.$fDataFirst3
  :: forall a.
     Data a =>
     (forall b. Data b => b -> b) -> First a -> Maybe a
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe4xY)
                 ($dData_Xe4y0 [Occ=Once] :: Data a_Xe4xY)
                 (ds_de7w4 [Occ=Once!] :: forall b. Data b => b -> b)
                 (x0_Xe33M [Occ=Once] :: First a_Xe4xY) ->
                 ds_de7w4
                   @ (Maybe a_Xe4xY)
                   (Data.Data.$fDataMaybe @ a_Xe4xY $dData_Xe4y0)
                   (x0_Xe33M
                    `cast` (Data.Monoid.N:First[0] <a_Xe4xY>_N
                            :: (First a_Xe4xY :: *) ~R# (Maybe a_Xe4xY :: *)))}]
Data.Data.$fDataFirst3
  = \ (@ a_Xe4xY)
      ($dData_Xe4y0 :: Data a_Xe4xY)
      (ds_de7w4 :: forall b. Data b => b -> b)
      (x0_Xe33M :: First a_Xe4xY) ->
      ds_de7w4
        @ (Maybe a_Xe4xY)
        (Data.Data.$fDataMaybe @ a_Xe4xY $dData_Xe4y0)
        (x0_Xe33M
         `cast` (Data.Monoid.N:First[0] <a_Xe4xY>_N
                 :: (First a_Xe4xY :: *) ~R# (Maybe a_Xe4xY :: *)))

-- RHS size: {terms: 68, types: 131, coercions: 6, joins: 0/3}
Data.Data.$fDataFirst_$cgmapMo
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> First a -> m (First a)
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 610 0}]
Data.Data.$fDataFirst_$cgmapMo
  = \ (@ a_Xe4xX)
      ($dData_Xe4xZ :: Data a_Xe4xX)
      (@ (m_ae3Tt :: * -> *))
      ($dMonadPlus_ae3Tv :: MonadPlus m_ae3Tt)
      (ds_de7wg :: forall d. Data d => d -> m_ae3Tt d)
      (eta_XKx :: First a_Xe4xX) ->
      let {
        lvl270_se9OZ :: m_ae3Tt (First a_Xe4xX)
        [LclId]
        lvl270_se9OZ
          = mzero @ m_ae3Tt $dMonadPlus_ae3Tv @ (First a_Xe4xX) } in
      let {
        $dMonad_se9qN [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae3Tt
        [LclId]
        $dMonad_se9qN
          = GHC.Base.$p2MonadPlus @ m_ae3Tt $dMonadPlus_ae3Tv } in
      >>=
        @ m_ae3Tt
        $dMonad_se9qN
        @ (First a_Xe4xX, Bool)
        @ (First a_Xe4xX)
        (let {
           lvl271_se9OY :: m_ae3Tt (Maybe a_Xe4xX)
           [LclId]
           lvl271_se9OY
             = ds_de7wg
                 @ (Maybe a_Xe4xX)
                 (Data.Data.$fDataMaybe @ a_Xe4xX $dData_Xe4xZ)
                 (eta_XKx
                  `cast` (Data.Monoid.N:First[0] <a_Xe4xX>_N
                          :: (First a_Xe4xX :: *) ~R# (Maybe a_Xe4xX :: *))) } in
         >>=
           @ m_ae3Tt
           $dMonad_se9qN
           @ (Maybe a_Xe4xX -> First a_Xe4xX, Bool)
           @ (First a_Xe4xX, Bool)
           (return
              @ m_ae3Tt
              $dMonad_se9qN
              @ (Maybe a_Xe4xX -> First a_Xe4xX, Bool)
              (Data.Data.$fDataFirst1 @ a_Xe4xX))
           (\ (ds1_de7pD :: (Maybe a_Xe4xX -> First a_Xe4xX, Bool)) ->
              case ds1_de7pD of { (h_ae1TP, b_ae1TQ) ->
              case b_ae1TQ of {
                False ->
                  mplus
                    @ m_ae3Tt
                    $dMonadPlus_ae3Tv
                    @ (First a_Xe4xX, Bool)
                    (>>=
                       @ m_ae3Tt
                       $dMonad_se9qN
                       @ (Maybe a_Xe4xX)
                       @ (First a_Xe4xX, Bool)
                       lvl271_se9OY
                       (\ (y'_ae1TR :: Maybe a_Xe4xX) ->
                          return
                            @ m_ae3Tt
                            $dMonad_se9qN
                            @ (First a_Xe4xX, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_ae3Tt
                       $dMonad_se9qN
                       @ (First a_Xe4xX, Bool)
                       (h_ae1TP
                          (eta_XKx
                           `cast` (Data.Monoid.N:First[0] <a_Xe4xX>_N
                                   :: (First a_Xe4xX :: *) ~R# (Maybe a_Xe4xX :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_ae3Tt
                    $dMonad_se9qN
                    @ (First a_Xe4xX, Bool)
                    (h_ae1TP
                       (eta_XKx
                        `cast` (Data.Monoid.N:First[0] <a_Xe4xX>_N
                                :: (First a_Xe4xX :: *) ~R# (Maybe a_Xe4xX :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds1_de7pa :: (First a_Xe4xX, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9OZ;
             True -> return @ m_ae3Tt $dMonad_se9qN @ (First a_Xe4xX) x'_ae1TS
           }
           })

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl168_rejSh :: forall a. First a -> Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl168_rejSh = \ (@ a_Xe4xW) _ [Occ=Dead] -> Data.Data.$cFirst

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl169_rejSi :: forall a. First a -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl169_rejSi = \ (@ a_Xe4xW) _ [Occ=Dead] -> Data.Data.$tFirst

-- RHS size: {terms: 6, types: 35, coercions: 0, joins: 0/0}
lvl170_rejSj
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c (First a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl170_rejSj
  = \ (@ a_Xe4xW)
      (@ (t_ae3Rp :: * -> * -> *))
      (@ (c_ae3Rq :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae3Rq (First a_Xe4xW))

-- RHS size: {terms: 30, types: 21, coercions: 19, joins: 0/0}
Data.Data.$fDataFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data a => Data (First a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_ae1Xe) (v_XKu :: Data a_ae1Xe) ->
       Data.Data.C:Data TYPE: First a_ae1Xe
                        (Data.Data.$fDataFirst9 @ a_ae1Xe v_XKu)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <First
                                                                                    a_ae1Xe>_N
                                :: (Data.Typeable.Internal.TypeRep (First a_ae1Xe) :: *)
                                   ~R# (Typeable (First a_ae1Xe) :: Constraint))
                        Data.Data.$fDataFirst_$cgfoldl @ a_ae1Xe v_XKu
                        Data.Data.$fDataFirst_$cgunfold @ a_ae1Xe v_XKu
                        \ _ [Occ=Dead] -> Data.Data.$cFirst
                        \ _ [Occ=Dead] -> Data.Data.$tFirst
                        Data.Data.$fDataFirst_$cdataCast1 @ a_ae1Xe v_XKu
                        \ (@ (t_ae3Rp :: * -> * -> *))
                          (@ (c_ae3Rq :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae3Rq (First a_ae1Xe))
                        (Data.Data.$fDataFirst3 @ a_ae1Xe v_XKu)
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <First a_ae1Xe>_R
                                ->_R Sym (Data.Monoid.N:First[0]) <a_ae1Xe>_N
                                :: ((forall b. Data b => b -> b)
                                    -> First a_ae1Xe -> Maybe a_ae1Xe :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> First a_ae1Xe -> First a_ae1Xe :: *))
                        Data.Data.$fDataFirst_$cgmapQl @ a_ae1Xe v_XKu
                        Data.Data.$fDataFirst_$cgmapQr @ a_ae1Xe v_XKu
                        Data.Data.$fDataFirst_$cgmapQ @ a_ae1Xe v_XKu
                        Data.Data.$fDataFirst_$cgmapQi @ a_ae1Xe v_XKu
                        Data.Data.$fDataFirst_$cgmapM @ a_ae1Xe v_XKu
                        Data.Data.$fDataFirst_$cgmapMp @ a_ae1Xe v_XKu
                        Data.Data.$fDataFirst_$cgmapMo @ a_ae1Xe v_XKu]
Data.Data.$fDataFirst
  = \ (@ a_Xe4xW) ($dData_Xe5ir :: Data a_Xe4xW) ->
      Data.Data.C:Data
        @ (First a_Xe4xW)
        ((Data.Data.$fDataFirst9 @ a_Xe4xW $dData_Xe5ir)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <First
                                                                     a_Xe4xW>_N
                 :: (Data.Typeable.Internal.TypeRep (First a_Xe4xW) :: *)
                    ~R# (Typeable (First a_Xe4xW) :: Constraint)))
        (Data.Data.$fDataFirst_$cgfoldl @ a_Xe4xW $dData_Xe5ir)
        (Data.Data.$fDataFirst_$cgunfold @ a_Xe4xW $dData_Xe5ir)
        (lvl168_rejSh @ a_Xe4xW)
        (lvl169_rejSi @ a_Xe4xW)
        (Data.Data.$fDataFirst_$cdataCast1 @ a_Xe4xW $dData_Xe5ir)
        (lvl170_rejSj @ a_Xe4xW)
        ((Data.Data.$fDataFirst3 @ a_Xe4xW $dData_Xe5ir)
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <First a_Xe4xW>_R
                 ->_R Sym (Data.Monoid.N:First[0]) <a_Xe4xW>_N
                 :: ((forall b. Data b => b -> b)
                     -> First a_Xe4xW -> Maybe a_Xe4xW :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> First a_Xe4xW -> First a_Xe4xW :: *)))
        (Data.Data.$fDataFirst_$cgmapQl @ a_Xe4xW $dData_Xe5ir)
        (Data.Data.$fDataFirst_$cgmapQr @ a_Xe4xW $dData_Xe5ir)
        (Data.Data.$fDataFirst_$cgmapQ @ a_Xe4xW $dData_Xe5ir)
        (Data.Data.$fDataFirst_$cgmapQi @ a_Xe4xW $dData_Xe5ir)
        (Data.Data.$fDataFirst_$cgmapM @ a_Xe4xW $dData_Xe5ir)
        (Data.Data.$fDataFirst_$cgmapMp @ a_Xe4xW $dData_Xe5ir)
        (Data.Data.$fDataFirst_$cgmapMo @ a_Xe4xW $dData_Xe5ir)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataLast7 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataLast7 = "Last"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataLast6 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataLast6 = unpackCString# Data.Data.$fDataLast7

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$cLast1_rejSk :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$cLast1_rejSk = "getLast"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cLast2_rejSl :: [Char]
[GblId]
$cLast2_rejSl = unpackCString# $cLast1_rejSk

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$cLast3_rejSm :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cLast3_rejSm
  = GHC.Types.: @ String $cLast2_rejSl (GHC.Types.[] @ String)

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go33_rejSn :: [Constr] -> [Int] -> Int
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go33_rejSn
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fDataLast6 of {
                False -> go33_rejSn ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cLast4_rejSo :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cLast4_rejSo = Data.Data.AlgConstr $cLast5_rejSp

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataLast5 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataLast5
  = GHC.Types.: @ Constr Data.Data.$cLast (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataLast4 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataLast4 = Data.Data.AlgRep Data.Data.$fDataLast5

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tLast :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$tLast
  = Data.Data.DataType Data.Data.$fDataLast6 Data.Data.$fDataLast4

-- RHS size: {terms: 6, types: 0, coercions: 0, joins: 0/0}
Data.Data.$cLast [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cLast
  = Data.Data.Constr
      $cLast4_rejSo
      Data.Data.$fDataLast6
      $cLast3_rejSm
      Data.Data.Prefix
      Data.Data.$tLast

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cLast5_rejSp :: Int
[GblId]
$cLast5_rejSp
  = go33_rejSn Data.Data.$fDataLast5 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 4, types: 8, coercions: 6, joins: 0/0}
Data.Data.$fDataLast1 :: forall a. (Maybe a -> Last a, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataLast1
  = \ (@ a_Xe4v7) ->
      ((Data.Data.$fDataFirst2 @ a_Xe4v7)
       `cast` (<Maybe a_Xe4v7>_R
               ->_R Sym (Data.Monoid.N:Last[0]) <a_Xe4v7>_N
               :: (Maybe a_Xe4v7 -> Maybe a_Xe4v7 :: *)
                  ~R# (Maybe a_Xe4v7 -> Last a_Xe4v7 :: *)),
       GHC.Types.False)

-- RHS size: {terms: 58, types: 122, coercions: 4, joins: 0/3}
Data.Data.$fDataLast_$cgmapMp
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Last a -> m (Last a)
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 530 0}]
Data.Data.$fDataLast_$cgmapMp
  = \ (@ a_Xe4v7)
      ($dData_Xe4v9 :: Data a_Xe4v7)
      (@ (m_ae3PZ :: * -> *))
      ($dMonadPlus_ae3Q1 :: MonadPlus m_ae3PZ)
      (ds_de7vW :: forall d. Data d => d -> m_ae3PZ d)
      (eta_XKF :: Last a_Xe4v7) ->
      let {
        lvl270_se9Ph :: m_ae3PZ (Last a_Xe4v7)
        [LclId]
        lvl270_se9Ph
          = mzero @ m_ae3PZ $dMonadPlus_ae3Q1 @ (Last a_Xe4v7) } in
      let {
        $dMonad_se9qJ [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae3PZ
        [LclId]
        $dMonad_se9qJ
          = GHC.Base.$p2MonadPlus @ m_ae3PZ $dMonadPlus_ae3Q1 } in
      >>=
        @ m_ae3PZ
        $dMonad_se9qJ
        @ (Last a_Xe4v7, Bool)
        @ (Last a_Xe4v7)
        (let {
           lvl271_se9Pg :: m_ae3PZ (Maybe a_Xe4v7)
           [LclId]
           lvl271_se9Pg
             = ds_de7vW
                 @ (Maybe a_Xe4v7)
                 (Data.Data.$fDataMaybe @ a_Xe4v7 $dData_Xe4v9)
                 (eta_XKF
                  `cast` (Data.Monoid.N:Last[0] <a_Xe4v7>_N
                          :: (Last a_Xe4v7 :: *) ~R# (Maybe a_Xe4v7 :: *))) } in
         >>=
           @ m_ae3PZ
           $dMonad_se9qJ
           @ (Maybe a_Xe4v7 -> Last a_Xe4v7, Bool)
           @ (Last a_Xe4v7, Bool)
           (return
              @ m_ae3PZ
              $dMonad_se9qJ
              @ (Maybe a_Xe4v7 -> Last a_Xe4v7, Bool)
              (Data.Data.$fDataLast1 @ a_Xe4v7))
           (\ (ds1_de7oD :: (Maybe a_Xe4v7 -> Last a_Xe4v7, Bool)) ->
              case ds1_de7oD of { (h_ae1TA, b_ae1TB) ->
              mplus
                @ m_ae3PZ
                $dMonadPlus_ae3Q1
                @ (Last a_Xe4v7, Bool)
                (>>=
                   @ m_ae3PZ
                   $dMonad_se9qJ
                   @ (Maybe a_Xe4v7)
                   @ (Last a_Xe4v7, Bool)
                   lvl271_se9Pg
                   (\ (y'_ae1TC :: Maybe a_Xe4v7) ->
                      return
                        @ m_ae3PZ
                        $dMonad_se9qJ
                        @ (Last a_Xe4v7, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_ae3PZ
                   $dMonad_se9qJ
                   @ (Last a_Xe4v7, Bool)
                   (h_ae1TA
                      (eta_XKF
                       `cast` (Data.Monoid.N:Last[0] <a_Xe4v7>_N
                               :: (Last a_Xe4v7 :: *) ~R# (Maybe a_Xe4v7 :: *))),
                    b_ae1TB))
              }))
        (\ (ds1_de7oa :: (Last a_Xe4v7, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9Ph;
             True -> return @ m_ae3PZ $dMonad_se9qJ @ (Last a_Xe4v7) x'_ae1TD
           }
           })

-- RHS size: {terms: 29, types: 60, coercions: 8, joins: 0/3}
Data.Data.$fDataLast_$cgmapM
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Last a -> m (Last a)
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120 60] 270 60}]
Data.Data.$fDataLast_$cgmapM
  = \ (@ a_Xe4v6)
      ($dData_Xe4v8 :: Data a_Xe4v6)
      (@ (m_ae3PJ :: * -> *))
      ($dMonad_ae3PL :: Monad m_ae3PJ)
      (ds_de7vV :: forall d. Data d => d -> m_ae3PJ d) ->
      let {
        $dData1_se9qF :: Data (Maybe a_Xe4v6)
        [LclId]
        $dData1_se9qF = Data.Data.$fDataMaybe @ a_Xe4v6 $dData_Xe4v8 } in
      let {
        lvl270_se9Pj :: m_ae3PJ (Maybe a_Xe4v6 -> Last a_Xe4v6)
        [LclId]
        lvl270_se9Pj
          = return
              @ m_ae3PJ
              $dMonad_ae3PL
              @ (Maybe a_Xe4v6 -> Last a_Xe4v6)
              ((Data.Data.$fDataFirst2 @ a_Xe4v6)
               `cast` (<Maybe a_Xe4v6>_R
                       ->_R Sym (Data.Monoid.N:Last[0]) <a_Xe4v6>_N
                       :: (Maybe a_Xe4v6 -> Maybe a_Xe4v6 :: *)
                          ~R# (Maybe a_Xe4v6 -> Last a_Xe4v6 :: *))) } in
      \ (ds1_de7vF :: Last a_Xe4v6) ->
        let {
          lvl271_se9Pk :: m_ae3PJ (Maybe a_Xe4v6)
          [LclId]
          lvl271_se9Pk
            = ds_de7vV
                @ (Maybe a_Xe4v6)
                $dData1_se9qF
                (ds1_de7vF
                 `cast` (Data.Monoid.N:Last[0] <a_Xe4v6>_N
                         :: (Last a_Xe4v6 :: *) ~R# (Maybe a_Xe4v6 :: *))) } in
        >>=
          @ m_ae3PJ
          $dMonad_ae3PL
          @ (Maybe a_Xe4v6 -> Last a_Xe4v6)
          @ (Last a_Xe4v6)
          lvl270_se9Pj
          (\ (c'_ae1To :: Maybe a_Xe4v6 -> Last a_Xe4v6) ->
             >>=
               @ m_ae3PJ
               $dMonad_ae3PL
               @ (Maybe a_Xe4v6)
               @ (Last a_Xe4v6)
               lvl271_se9Pk
               (\ (x'_ae1Tp :: Maybe a_Xe4v6) ->
                  return
                    @ m_ae3PJ $dMonad_ae3PL @ (Last a_Xe4v6) (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 18, types: 22, coercions: 2, joins: 0/0}
Data.Data.$fDataLast_$cgmapQi
  :: forall a.
     Data a =>
     forall u. Int -> (forall d. Data d => d -> u) -> Last a -> u
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe4v5)
                 ($dData_Xe4v7 [Occ=Once] :: Data a_Xe4v5)
                 (@ u_ae3Pv)
                 (ds_de7vT [Occ=Once!] :: Int)
                 (ds1_de7vU [Occ=Once!] :: forall d. Data d => d -> u_ae3Pv)
                 (x_ae1T7 [Occ=Once] :: Last a_Xe4v5) ->
                 case ds_de7vT of { I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3Pv;
                   0# ->
                     ds1_de7vU
                       @ (Maybe a_Xe4v5)
                       (Data.Data.$fDataMaybe @ a_Xe4v5 $dData_Xe4v7)
                       (x_ae1T7
                        `cast` (Data.Monoid.N:Last[0] <a_Xe4v5>_N
                                :: (Last a_Xe4v5 :: *) ~R# (Maybe a_Xe4v5 :: *)))
                 }
                 }}]
Data.Data.$fDataLast_$cgmapQi
  = \ (@ a_Xe4v5)
      ($dData_Xe4v7 :: Data a_Xe4v5)
      (@ u_ae3Pv)
      (ds_de7vT :: Int)
      (ds1_de7vU :: forall d. Data d => d -> u_ae3Pv)
      (x_ae1T7 :: Last a_Xe4v5) ->
      case ds_de7vT of { I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3Pv;
        0# ->
          ds1_de7vU
            @ (Maybe a_Xe4v5)
            (Data.Data.$fDataMaybe @ a_Xe4v5 $dData_Xe4v7)
            (x_ae1T7
             `cast` (Data.Monoid.N:Last[0] <a_Xe4v5>_N
                     :: (Last a_Xe4v5 :: *) ~R# (Maybe a_Xe4v5 :: *)))
      }
      }

-- RHS size: {terms: 14, types: 23, coercions: 2, joins: 0/0}
Data.Data.$fDataLast_$cgmapQr
  :: forall a.
     Data a =>
     forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> Last a -> r
[GblId,
 Arity=5,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe4v3)
                 ($dData_Xe4v5 [Occ=Once] :: Data a_Xe4v3)
                 (@ r_ae3P0)
                 (@ r'_ae3P1)
                 (ds_de7vP [Occ=Once!] :: r'_ae3P1 -> r_ae3P0 -> r_ae3P0)
                 (ds1_de7vQ [Occ=Once] :: r_ae3P0)
                 (ds2_de7vR [Occ=Once!] :: forall d. Data d => d -> r'_ae3P1)
                 (x0_ae1SX [Occ=Once] :: Last a_Xe4v3) ->
                 ds_de7vP
                   (ds2_de7vR
                      @ (Maybe a_Xe4v3)
                      (Data.Data.$fDataMaybe @ a_Xe4v3 $dData_Xe4v5)
                      (x0_ae1SX
                       `cast` (Data.Monoid.N:Last[0] <a_Xe4v3>_N
                               :: (Last a_Xe4v3 :: *) ~R# (Maybe a_Xe4v3 :: *))))
                   ds1_de7vQ}]
Data.Data.$fDataLast_$cgmapQr
  = \ (@ a_Xe4v3)
      ($dData_Xe4v5 :: Data a_Xe4v3)
      (@ r_ae3P0)
      (@ r'_ae3P1)
      (ds_de7vP :: r'_ae3P1 -> r_ae3P0 -> r_ae3P0)
      (ds1_de7vQ :: r_ae3P0)
      (ds2_de7vR :: forall d. Data d => d -> r'_ae3P1)
      (x0_ae1SX :: Last a_Xe4v3) ->
      ds_de7vP
        (ds2_de7vR
           @ (Maybe a_Xe4v3)
           (Data.Data.$fDataMaybe @ a_Xe4v3 $dData_Xe4v5)
           (x0_ae1SX
            `cast` (Data.Monoid.N:Last[0] <a_Xe4v3>_N
                    :: (Last a_Xe4v3 :: *) ~R# (Maybe a_Xe4v3 :: *))))
        ds1_de7vQ

-- RHS size: {terms: 11, types: 19, coercions: 2, joins: 0/0}
Data.Data.$fDataLast_$cgmapQ
  :: forall a.
     Data a =>
     forall u. (forall d. Data d => d -> u) -> Last a -> [u]
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,1*C1(C1(U))><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe4v4)
                 ($dData_Xe4v6 [Occ=Once] :: Data a_Xe4v4)
                 (@ u_ae3Ph)
                 (ds_de7vS [Occ=Once!] :: forall d. Data d => d -> u_ae3Ph)
                 (x0_ae1SX [Occ=Once] :: Last a_Xe4v4) ->
                 GHC.Types.:
                   @ u_ae3Ph
                   (ds_de7vS
                      @ (Maybe a_Xe4v4)
                      (Data.Data.$fDataMaybe @ a_Xe4v4 $dData_Xe4v6)
                      (x0_ae1SX
                       `cast` (Data.Monoid.N:Last[0] <a_Xe4v4>_N
                               :: (Last a_Xe4v4 :: *) ~R# (Maybe a_Xe4v4 :: *))))
                   (GHC.Types.[] @ u_ae3Ph)}]
Data.Data.$fDataLast_$cgmapQ
  = \ (@ a_Xe4v4)
      ($dData_Xe4v6 :: Data a_Xe4v4)
      (@ u_ae3Ph)
      (ds_de7vS :: forall d. Data d => d -> u_ae3Ph)
      (x0_ae1SX :: Last a_Xe4v4) ->
      GHC.Types.:
        @ u_ae3Ph
        (ds_de7vS
           @ (Maybe a_Xe4v4)
           (Data.Data.$fDataMaybe @ a_Xe4v4 $dData_Xe4v6)
           (x0_ae1SX
            `cast` (Data.Monoid.N:Last[0] <a_Xe4v4>_N
                    :: (Last a_Xe4v4 :: *) ~R# (Maybe a_Xe4v4 :: *))))
        (GHC.Types.[] @ u_ae3Ph)

-- RHS size: {terms: 16, types: 26, coercions: 2, joins: 0/1}
Data.Data.$fDataLast_$cgmapQl
  :: forall a.
     Data a =>
     forall r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> Last a -> r
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe4v2)
                 ($dData_Xe4v4 [Occ=OnceL] :: Data a_Xe4v2)
                 (@ r_ae3OJ)
                 (@ r'_ae3OK)
                 (ds_de7vM [Occ=OnceL!] :: r_ae3OJ -> r'_ae3OK -> r_ae3OJ)
                 (ds1_de7vN [Occ=OnceL] :: r_ae3OJ)
                 (ds2_de7vO [Occ=OnceL!] :: forall d. Data d => d -> r'_ae3OK) ->
                 let {
                   $dData1_se9qB [Occ=OnceL] :: Data (Maybe a_Xe4v2)
                   [LclId]
                   $dData1_se9qB = Data.Data.$fDataMaybe @ a_Xe4v2 $dData_Xe4v4 } in
                 \ (x_i7Rxi [Occ=Once] :: Last a_Xe4v2) ->
                   ds_de7vM
                     ds1_de7vN
                     (ds2_de7vO
                        @ (Maybe a_Xe4v2)
                        $dData1_se9qB
                        (x_i7Rxi
                         `cast` (Data.Monoid.N:Last[0] <a_Xe4v2>_N
                                 :: (Last a_Xe4v2 :: *) ~R# (Maybe a_Xe4v2 :: *))))}]
Data.Data.$fDataLast_$cgmapQl
  = \ (@ a_Xe4v2)
      ($dData_Xe4v4 :: Data a_Xe4v2)
      (@ r_ae3OJ)
      (@ r'_ae3OK)
      (ds_de7vM :: r_ae3OJ -> r'_ae3OK -> r_ae3OJ)
      (ds1_de7vN :: r_ae3OJ)
      (ds2_de7vO :: forall d. Data d => d -> r'_ae3OK) ->
      let {
        $dData1_se9qB :: Data (Maybe a_Xe4v2)
        [LclId]
        $dData1_se9qB = Data.Data.$fDataMaybe @ a_Xe4v2 $dData_Xe4v4 } in
      \ (x_i7Rxi :: Last a_Xe4v2) ->
        ds_de7vM
          ds1_de7vN
          (ds2_de7vO
             @ (Maybe a_Xe4v2)
             $dData1_se9qB
             (x_i7Rxi
              `cast` (Data.Monoid.N:Last[0] <a_Xe4v2>_N
                      :: (Last a_Xe4v2 :: *) ~R# (Maybe a_Xe4v2 :: *))))

-- RHS size: {terms: 8, types: 15, coercions: 2, joins: 0/0}
Data.Data.$fDataLast2
  :: forall a.
     Data a =>
     (forall b. Data b => b -> b) -> Last a -> Maybe a
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe4v1)
                 ($dData_Xe4v3 [Occ=Once] :: Data a_Xe4v1)
                 (ds_de7vL [Occ=Once!] :: forall b. Data b => b -> b)
                 (x0_Xe344 [Occ=Once] :: Last a_Xe4v1) ->
                 ds_de7vL
                   @ (Maybe a_Xe4v1)
                   (Data.Data.$fDataMaybe @ a_Xe4v1 $dData_Xe4v3)
                   (x0_Xe344
                    `cast` (Data.Monoid.N:Last[0] <a_Xe4v1>_N
                            :: (Last a_Xe4v1 :: *) ~R# (Maybe a_Xe4v1 :: *)))}]
Data.Data.$fDataLast2
  = \ (@ a_Xe4v1)
      ($dData_Xe4v3 :: Data a_Xe4v1)
      (ds_de7vL :: forall b. Data b => b -> b)
      (x0_Xe344 :: Last a_Xe4v1) ->
      ds_de7vL
        @ (Maybe a_Xe4v1)
        (Data.Data.$fDataMaybe @ a_Xe4v1 $dData_Xe4v3)
        (x0_Xe344
         `cast` (Data.Monoid.N:Last[0] <a_Xe4v1>_N
                 :: (Last a_Xe4v1 :: *) ~R# (Maybe a_Xe4v1 :: *)))

-- RHS size: {terms: 68, types: 131, coercions: 6, joins: 0/3}
Data.Data.$fDataLast_$cgmapMo
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Last a -> m (Last a)
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 610 0}]
Data.Data.$fDataLast_$cgmapMo
  = \ (@ a_Xe4v0)
      ($dData_Xe4v2 :: Data a_Xe4v0)
      (@ (m_ae3Qf :: * -> *))
      ($dMonadPlus_ae3Qh :: MonadPlus m_ae3Qf)
      (ds_de7vX :: forall d. Data d => d -> m_ae3Qf d)
      (eta_XKP :: Last a_Xe4v0) ->
      let {
        lvl270_se9Pp :: m_ae3Qf (Last a_Xe4v0)
        [LclId]
        lvl270_se9Pp
          = mzero @ m_ae3Qf $dMonadPlus_ae3Qh @ (Last a_Xe4v0) } in
      let {
        $dMonad_se9qz [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae3Qf
        [LclId]
        $dMonad_se9qz
          = GHC.Base.$p2MonadPlus @ m_ae3Qf $dMonadPlus_ae3Qh } in
      >>=
        @ m_ae3Qf
        $dMonad_se9qz
        @ (Last a_Xe4v0, Bool)
        @ (Last a_Xe4v0)
        (let {
           lvl271_se9Po :: m_ae3Qf (Maybe a_Xe4v0)
           [LclId]
           lvl271_se9Po
             = ds_de7vX
                 @ (Maybe a_Xe4v0)
                 (Data.Data.$fDataMaybe @ a_Xe4v0 $dData_Xe4v2)
                 (eta_XKP
                  `cast` (Data.Monoid.N:Last[0] <a_Xe4v0>_N
                          :: (Last a_Xe4v0 :: *) ~R# (Maybe a_Xe4v0 :: *))) } in
         >>=
           @ m_ae3Qf
           $dMonad_se9qz
           @ (Maybe a_Xe4v0 -> Last a_Xe4v0, Bool)
           @ (Last a_Xe4v0, Bool)
           (return
              @ m_ae3Qf
              $dMonad_se9qz
              @ (Maybe a_Xe4v0 -> Last a_Xe4v0, Bool)
              (Data.Data.$fDataLast1 @ a_Xe4v0))
           (\ (ds1_de7pD :: (Maybe a_Xe4v0 -> Last a_Xe4v0, Bool)) ->
              case ds1_de7pD of { (h_ae1TP, b_ae1TQ) ->
              case b_ae1TQ of {
                False ->
                  mplus
                    @ m_ae3Qf
                    $dMonadPlus_ae3Qh
                    @ (Last a_Xe4v0, Bool)
                    (>>=
                       @ m_ae3Qf
                       $dMonad_se9qz
                       @ (Maybe a_Xe4v0)
                       @ (Last a_Xe4v0, Bool)
                       lvl271_se9Po
                       (\ (y'_ae1TR :: Maybe a_Xe4v0) ->
                          return
                            @ m_ae3Qf
                            $dMonad_se9qz
                            @ (Last a_Xe4v0, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_ae3Qf
                       $dMonad_se9qz
                       @ (Last a_Xe4v0, Bool)
                       (h_ae1TP
                          (eta_XKP
                           `cast` (Data.Monoid.N:Last[0] <a_Xe4v0>_N
                                   :: (Last a_Xe4v0 :: *) ~R# (Maybe a_Xe4v0 :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_ae3Qf
                    $dMonad_se9qz
                    @ (Last a_Xe4v0, Bool)
                    (h_ae1TP
                       (eta_XKP
                        `cast` (Data.Monoid.N:Last[0] <a_Xe4v0>_N
                                :: (Last a_Xe4v0 :: *) ~R# (Maybe a_Xe4v0 :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds1_de7pa :: (Last a_Xe4v0, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9Pp;
             True -> return @ m_ae3Qf $dMonad_se9qz @ (Last a_Xe4v0) x'_ae1TS
           }
           })

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl171_rejSq :: forall a. Last a -> Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl171_rejSq = \ (@ a_Xe4uZ) _ [Occ=Dead] -> Data.Data.$cLast

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl172_rejSr :: forall a. Last a -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl172_rejSr = \ (@ a_Xe4uZ) _ [Occ=Dead] -> Data.Data.$tLast

-- RHS size: {terms: 6, types: 35, coercions: 0, joins: 0/0}
lvl173_rejSs
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c (Last a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl173_rejSs
  = \ (@ a_Xe4uZ)
      (@ (t_ae3Ob :: * -> * -> *))
      (@ (c_ae3Oc :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae3Oc (Last a_Xe4uZ))

-- RHS size: {terms: 30, types: 21, coercions: 19, joins: 0/0}
Data.Data.$fDataLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data a => Data (Last a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_ae1Xd) (v_XKM :: Data a_ae1Xd) ->
       Data.Data.C:Data TYPE: Last a_ae1Xd
                        (Data.Data.$fDataLast8 @ a_ae1Xd v_XKM)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Last
                                                                                    a_ae1Xd>_N
                                :: (Data.Typeable.Internal.TypeRep (Last a_ae1Xd) :: *)
                                   ~R# (Typeable (Last a_ae1Xd) :: Constraint))
                        Data.Data.$fDataLast_$cgfoldl @ a_ae1Xd v_XKM
                        Data.Data.$fDataLast_$cgunfold @ a_ae1Xd v_XKM
                        \ _ [Occ=Dead] -> Data.Data.$cLast
                        \ _ [Occ=Dead] -> Data.Data.$tLast
                        Data.Data.$fDataLast_$cdataCast1 @ a_ae1Xd v_XKM
                        \ (@ (t_ae3Ob :: * -> * -> *))
                          (@ (c_ae3Oc :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae3Oc (Last a_ae1Xd))
                        (Data.Data.$fDataLast2 @ a_ae1Xd v_XKM)
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <Last a_ae1Xd>_R
                                ->_R Sym (Data.Monoid.N:Last[0]) <a_ae1Xd>_N
                                :: ((forall b. Data b => b -> b)
                                    -> Last a_ae1Xd -> Maybe a_ae1Xd :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> Last a_ae1Xd -> Last a_ae1Xd :: *))
                        Data.Data.$fDataLast_$cgmapQl @ a_ae1Xd v_XKM
                        Data.Data.$fDataLast_$cgmapQr @ a_ae1Xd v_XKM
                        Data.Data.$fDataLast_$cgmapQ @ a_ae1Xd v_XKM
                        Data.Data.$fDataLast_$cgmapQi @ a_ae1Xd v_XKM
                        Data.Data.$fDataLast_$cgmapM @ a_ae1Xd v_XKM
                        Data.Data.$fDataLast_$cgmapMp @ a_ae1Xd v_XKM
                        Data.Data.$fDataLast_$cgmapMo @ a_ae1Xd v_XKM]
Data.Data.$fDataLast
  = \ (@ a_Xe4uZ) ($dData_Xe5fM :: Data a_Xe4uZ) ->
      Data.Data.C:Data
        @ (Last a_Xe4uZ)
        ((Data.Data.$fDataLast8 @ a_Xe4uZ $dData_Xe5fM)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Last
                                                                     a_Xe4uZ>_N
                 :: (Data.Typeable.Internal.TypeRep (Last a_Xe4uZ) :: *)
                    ~R# (Typeable (Last a_Xe4uZ) :: Constraint)))
        (Data.Data.$fDataLast_$cgfoldl @ a_Xe4uZ $dData_Xe5fM)
        (Data.Data.$fDataLast_$cgunfold @ a_Xe4uZ $dData_Xe5fM)
        (lvl171_rejSq @ a_Xe4uZ)
        (lvl172_rejSr @ a_Xe4uZ)
        (Data.Data.$fDataLast_$cdataCast1 @ a_Xe4uZ $dData_Xe5fM)
        (lvl173_rejSs @ a_Xe4uZ)
        ((Data.Data.$fDataLast2 @ a_Xe4uZ $dData_Xe5fM)
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <Last a_Xe4uZ>_R
                 ->_R Sym (Data.Monoid.N:Last[0]) <a_Xe4uZ>_N
                 :: ((forall b. Data b => b -> b)
                     -> Last a_Xe4uZ -> Maybe a_Xe4uZ :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> Last a_Xe4uZ -> Last a_Xe4uZ :: *)))
        (Data.Data.$fDataLast_$cgmapQl @ a_Xe4uZ $dData_Xe5fM)
        (Data.Data.$fDataLast_$cgmapQr @ a_Xe4uZ $dData_Xe5fM)
        (Data.Data.$fDataLast_$cgmapQ @ a_Xe4uZ $dData_Xe5fM)
        (Data.Data.$fDataLast_$cgmapQi @ a_Xe4uZ $dData_Xe5fM)
        (Data.Data.$fDataLast_$cgmapM @ a_Xe4uZ $dData_Xe5fM)
        (Data.Data.$fDataLast_$cgmapMp @ a_Xe4uZ $dData_Xe5fM)
        (Data.Data.$fDataLast_$cgmapMo @ a_Xe4uZ $dData_Xe5fM)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataAlt6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataAlt6 = "Alt"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataAlt5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataAlt5 = unpackCString# Data.Data.$fDataAlt6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$cAlt1_rejSt :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$cAlt1_rejSt = "getAlt"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cAlt2_rejSu :: [Char]
[GblId]
$cAlt2_rejSu = unpackCString# $cAlt1_rejSt

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$cAlt3_rejSv :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cAlt3_rejSv
  = GHC.Types.: @ String $cAlt2_rejSu (GHC.Types.[] @ String)

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go34_rejSw :: [Constr] -> [Int] -> Int
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go34_rejSw
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fDataAlt5 of {
                False -> go34_rejSw ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cAlt4_rejSx :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cAlt4_rejSx = Data.Data.AlgConstr $cAlt5_rejSy

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataAlt4 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataAlt4
  = GHC.Types.: @ Constr Data.Data.$cAlt (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataAlt3 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataAlt3 = Data.Data.AlgRep Data.Data.$fDataAlt4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tAlt :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$tAlt
  = Data.Data.DataType Data.Data.$fDataAlt5 Data.Data.$fDataAlt3

-- RHS size: {terms: 6, types: 0, coercions: 0, joins: 0/0}
Data.Data.$cAlt [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cAlt
  = Data.Data.Constr
      $cAlt4_rejSx
      Data.Data.$fDataAlt5
      $cAlt3_rejSv
      Data.Data.Prefix
      Data.Data.$tAlt

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cAlt5_rejSy :: Int
[GblId]
$cAlt5_rejSy = go34_rejSw Data.Data.$fDataAlt4 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 4, types: 8, coercions: 0, joins: 0/0}
Data.Data.$fDataAlt2 :: forall (f :: * -> *) a. f a -> f a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (f_Xe4s3 :: * -> *))
                 (@ a_Xe4s5)
                 (v_XIb [Occ=Once] :: f_Xe4s3 a_Xe4s5) ->
                 v_XIb}]
Data.Data.$fDataAlt2
  = \ (@ (f_Xe4s3 :: * -> *))
      (@ a_Xe4s5)
      (v_XIb :: f_Xe4s3 a_Xe4s5) ->
      v_XIb

-- RHS size: {terms: 5, types: 16, coercions: 9, joins: 0/0}
Data.Data.$fDataAlt1
  :: forall (f :: * -> *) a. (f a -> Alt f a, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataAlt1
  = \ (@ (f_Xe4s3 :: * -> *)) (@ a_Xe4s5) ->
      ((Data.Data.$fDataAlt2 @ f_Xe4s3 @ a_Xe4s5)
       `cast` (<f_Xe4s3 a_Xe4s5>_R
               ->_R Sym (Data.Semigroup.Internal.N:Alt[0]
                             <*>_N <f_Xe4s3>_R) <a_Xe4s5>_N
               :: (f_Xe4s3 a_Xe4s5 -> f_Xe4s3 a_Xe4s5 :: *)
                  ~R# (f_Xe4s3 a_Xe4s5 -> Alt f_Xe4s3 a_Xe4s5 :: *)),
       GHC.Types.False)

-- RHS size: {terms: 58, types: 190, coercions: 10, joins: 0/3}
Data.Data.$w$cgmapMp7 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     Data (f a) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Alt f a -> m (Alt f a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 510 0}]
Data.Data.$w$cgmapMp7
  = \ (@ (f_segti :: * -> *))
      (@ a_segtj)
      (w_segtk :: Data (f_segti a_segtj))
      (@ (m_segtn :: * -> *))
      (w1_segto :: MonadPlus m_segtn)
      (w2_segtp :: forall d. Data d => d -> m_segtn d)
      (w3_segtq :: Alt f_segti a_segtj) ->
      let {
        lvl270_se9PH :: m_segtn (Alt f_segti a_segtj)
        [LclId]
        lvl270_se9PH
          = mzero @ m_segtn w1_segto @ (Alt f_segti a_segtj) } in
      let {
        $dMonad_se9qv [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_segtn
        [LclId]
        $dMonad_se9qv = GHC.Base.$p2MonadPlus @ m_segtn w1_segto } in
      >>=
        @ m_segtn
        $dMonad_se9qv
        @ (Alt f_segti a_segtj, Bool)
        @ (Alt f_segti a_segtj)
        (let {
           lvl271_se9PG :: m_segtn (f_segti a_segtj)
           [LclId]
           lvl271_se9PG
             = w2_segtp
                 @ (f_segti a_segtj)
                 w_segtk
                 (w3_segtq
                  `cast` (Data.Semigroup.Internal.N:Alt[0]
                              <*>_N <f_segti>_R <a_segtj>_N
                          :: (Alt f_segti a_segtj :: *) ~R# (f_segti a_segtj :: *))) } in
         >>=
           @ m_segtn
           $dMonad_se9qv
           @ (f_segti a_segtj -> Alt f_segti a_segtj, Bool)
           @ (Alt f_segti a_segtj, Bool)
           (return
              @ m_segtn
              $dMonad_se9qv
              @ (f_segti a_segtj -> Alt f_segti a_segtj, Bool)
              (Data.Data.$fDataAlt1 @ f_segti @ a_segtj))
           (\ (ds_de7oD :: (f_segti a_segtj -> Alt f_segti a_segtj, Bool)) ->
              case ds_de7oD of { (h_ae1TA, b_ae1TB) ->
              mplus
                @ m_segtn
                w1_segto
                @ (Alt f_segti a_segtj, Bool)
                (>>=
                   @ m_segtn
                   $dMonad_se9qv
                   @ (f_segti a_segtj)
                   @ (Alt f_segti a_segtj, Bool)
                   lvl271_se9PG
                   (\ (y'_ae1TC :: f_segti a_segtj) ->
                      return
                        @ m_segtn
                        $dMonad_se9qv
                        @ (Alt f_segti a_segtj, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_segtn
                   $dMonad_se9qv
                   @ (Alt f_segti a_segtj, Bool)
                   (h_ae1TA
                      (w3_segtq
                       `cast` (Data.Semigroup.Internal.N:Alt[0]
                                   <*>_N <f_segti>_R <a_segtj>_N
                               :: (Alt f_segti a_segtj :: *) ~R# (f_segti a_segtj :: *))),
                    b_ae1TB))
              }))
        (\ (ds_de7oa :: (Alt f_segti a_segtj, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9PH;
             True ->
               return @ m_segtn $dMonad_se9qv @ (Alt f_segti a_segtj) x'_ae1TD
           }
           })

-- RHS size: {terms: 14, types: 38, coercions: 0, joins: 0/0}
Data.Data.$fDataAlt_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     (Data (f a), Data a, Typeable f) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Alt f a -> m (Alt f a)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,A><L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (f_segti :: * -> *))
                 (@ a_segtj)
                 (w_segtk [Occ=Once] :: Data (f_segti a_segtj))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (@ (m_segtn :: * -> *))
                 (w3_segto [Occ=Once] :: MonadPlus m_segtn)
                 (w4_segtp [Occ=Once] :: forall d. Data d => d -> m_segtn d)
                 (w5_segtq [Occ=Once] :: Alt f_segti a_segtj) ->
                 Data.Data.$w$cgmapMp7
                   @ f_segti @ a_segtj w_segtk @ m_segtn w3_segto w4_segtp w5_segtq}]
Data.Data.$fDataAlt_$cgmapMp
  = \ (@ (f_segti :: * -> *))
      (@ a_segtj)
      (w_segtk :: Data (f_segti a_segtj))
      _ [Occ=Dead]
      _ [Occ=Dead]
      (@ (m_segtn :: * -> *))
      (w3_segto :: MonadPlus m_segtn)
      (w4_segtp :: forall d. Data d => d -> m_segtn d)
      (w5_segtq :: Alt f_segti a_segtj) ->
      Data.Data.$w$cgmapMp7
        @ f_segti @ a_segtj w_segtk @ m_segtn w3_segto w4_segtp w5_segtq

-- RHS size: {terms: 25, types: 78, coercions: 14, joins: 0/1}
Data.Data.$w$cgmapM6 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     Data (f a) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Alt f a -> m (Alt f a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120 60 0] 220 0}]
Data.Data.$w$cgmapM6
  = \ (@ (f_segts :: * -> *))
      (@ a_segtt)
      (w_segtu :: Data (f_segts a_segtt))
      (@ (m_segtx :: * -> *))
      (w1_segty :: Monad m_segtx)
      (w2_segtz :: forall d. Data d => d -> m_segtx d)
      (w3_segtA :: Alt f_segts a_segtt) ->
      let {
        lvl270_se9PJ :: m_segtx (f_segts a_segtt)
        [LclId]
        lvl270_se9PJ
          = w2_segtz
              @ (f_segts a_segtt)
              w_segtu
              (w3_segtA
               `cast` (Data.Semigroup.Internal.N:Alt[0]
                           <*>_N <f_segts>_R <a_segtt>_N
                       :: (Alt f_segts a_segtt :: *) ~R# (f_segts a_segtt :: *))) } in
      >>=
        @ m_segtx
        w1_segty
        @ (f_segts a_segtt -> Alt f_segts a_segtt)
        @ (Alt f_segts a_segtt)
        (return
           @ m_segtx
           w1_segty
           @ (f_segts a_segtt -> Alt f_segts a_segtt)
           ((Data.Data.$fDataAlt2 @ f_segts @ a_segtt)
            `cast` (<f_segts a_segtt>_R
                    ->_R Sym (Data.Semigroup.Internal.N:Alt[0]
                                  <*>_N <f_segts>_R) <a_segtt>_N
                    :: (f_segts a_segtt -> f_segts a_segtt :: *)
                       ~R# (f_segts a_segtt -> Alt f_segts a_segtt :: *))))
        (\ (c'_ae1To :: f_segts a_segtt -> Alt f_segts a_segtt) ->
           >>=
             @ m_segtx
             w1_segty
             @ (f_segts a_segtt)
             @ (Alt f_segts a_segtt)
             lvl270_se9PJ
             (\ (x'_ae1Tp :: f_segts a_segtt) ->
                return
                  @ m_segtx w1_segty @ (Alt f_segts a_segtt) (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 14, types: 38, coercions: 0, joins: 0/0}
Data.Data.$fDataAlt_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     (Data (f a), Data a, Typeable f) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Alt f a -> m (Alt f a)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,A><L,A><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (f_segts :: * -> *))
                 (@ a_segtt)
                 (w_segtu [Occ=Once] :: Data (f_segts a_segtt))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (@ (m_segtx :: * -> *))
                 (w3_segty [Occ=Once] :: Monad m_segtx)
                 (w4_segtz [Occ=Once] :: forall d. Data d => d -> m_segtx d)
                 (w5_segtA [Occ=Once] :: Alt f_segts a_segtt) ->
                 Data.Data.$w$cgmapM6
                   @ f_segts @ a_segtt w_segtu @ m_segtx w3_segty w4_segtz w5_segtA}]
Data.Data.$fDataAlt_$cgmapM
  = \ (@ (f_segts :: * -> *))
      (@ a_segtt)
      (w_segtu :: Data (f_segts a_segtt))
      _ [Occ=Dead]
      _ [Occ=Dead]
      (@ (m_segtx :: * -> *))
      (w3_segty :: Monad m_segtx)
      (w4_segtz :: forall d. Data d => d -> m_segtx d)
      (w5_segtA :: Alt f_segts a_segtt) ->
      Data.Data.$w$cgmapM6
        @ f_segts @ a_segtt w_segtu @ m_segtx w3_segty w4_segtz w5_segtA

-- RHS size: {terms: 68, types: 205, coercions: 15, joins: 0/3}
Data.Data.$w$cgmapMo6 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     Data (f a) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Alt f a -> m (Alt f a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 590 0}]
Data.Data.$w$cgmapMo6
  = \ (@ (f_segtC :: * -> *))
      (@ a_segtD)
      (w_segtE :: Data (f_segtC a_segtD))
      (@ (m_segtH :: * -> *))
      (w1_segtI :: MonadPlus m_segtH)
      (w2_segtJ :: forall d. Data d => d -> m_segtH d)
      (w3_segtK :: Alt f_segtC a_segtD) ->
      let {
        lvl270_se9PO :: m_segtH (Alt f_segtC a_segtD)
        [LclId]
        lvl270_se9PO
          = mzero @ m_segtH w1_segtI @ (Alt f_segtC a_segtD) } in
      let {
        $dMonad_se9qt [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_segtH
        [LclId]
        $dMonad_se9qt = GHC.Base.$p2MonadPlus @ m_segtH w1_segtI } in
      >>=
        @ m_segtH
        $dMonad_se9qt
        @ (Alt f_segtC a_segtD, Bool)
        @ (Alt f_segtC a_segtD)
        (let {
           lvl271_se9PN :: m_segtH (f_segtC a_segtD)
           [LclId]
           lvl271_se9PN
             = w2_segtJ
                 @ (f_segtC a_segtD)
                 w_segtE
                 (w3_segtK
                  `cast` (Data.Semigroup.Internal.N:Alt[0]
                              <*>_N <f_segtC>_R <a_segtD>_N
                          :: (Alt f_segtC a_segtD :: *) ~R# (f_segtC a_segtD :: *))) } in
         >>=
           @ m_segtH
           $dMonad_se9qt
           @ (f_segtC a_segtD -> Alt f_segtC a_segtD, Bool)
           @ (Alt f_segtC a_segtD, Bool)
           (return
              @ m_segtH
              $dMonad_se9qt
              @ (f_segtC a_segtD -> Alt f_segtC a_segtD, Bool)
              (Data.Data.$fDataAlt1 @ f_segtC @ a_segtD))
           (\ (ds_de7pD :: (f_segtC a_segtD -> Alt f_segtC a_segtD, Bool)) ->
              case ds_de7pD of { (h_ae1TP, b_ae1TQ) ->
              case b_ae1TQ of {
                False ->
                  mplus
                    @ m_segtH
                    w1_segtI
                    @ (Alt f_segtC a_segtD, Bool)
                    (>>=
                       @ m_segtH
                       $dMonad_se9qt
                       @ (f_segtC a_segtD)
                       @ (Alt f_segtC a_segtD, Bool)
                       lvl271_se9PN
                       (\ (y'_ae1TR :: f_segtC a_segtD) ->
                          return
                            @ m_segtH
                            $dMonad_se9qt
                            @ (Alt f_segtC a_segtD, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_segtH
                       $dMonad_se9qt
                       @ (Alt f_segtC a_segtD, Bool)
                       (h_ae1TP
                          (w3_segtK
                           `cast` (Data.Semigroup.Internal.N:Alt[0]
                                       <*>_N <f_segtC>_R <a_segtD>_N
                                   :: (Alt f_segtC a_segtD :: *) ~R# (f_segtC a_segtD :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_segtH
                    $dMonad_se9qt
                    @ (Alt f_segtC a_segtD, Bool)
                    (h_ae1TP
                       (w3_segtK
                        `cast` (Data.Semigroup.Internal.N:Alt[0]
                                    <*>_N <f_segtC>_R <a_segtD>_N
                                :: (Alt f_segtC a_segtD :: *) ~R# (f_segtC a_segtD :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds_de7pa :: (Alt f_segtC a_segtD, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9PO;
             True ->
               return @ m_segtH $dMonad_se9qt @ (Alt f_segtC a_segtD) x'_ae1TS
           }
           })

-- RHS size: {terms: 14, types: 38, coercions: 0, joins: 0/0}
Data.Data.$fDataAlt_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     (Data (f a), Data a, Typeable f) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Alt f a -> m (Alt f a)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,A><L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (f_segtC :: * -> *))
                 (@ a_segtD)
                 (w_segtE [Occ=Once] :: Data (f_segtC a_segtD))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (@ (m_segtH :: * -> *))
                 (w3_segtI [Occ=Once] :: MonadPlus m_segtH)
                 (w4_segtJ [Occ=Once] :: forall d. Data d => d -> m_segtH d)
                 (w5_segtK [Occ=Once] :: Alt f_segtC a_segtD) ->
                 Data.Data.$w$cgmapMo6
                   @ f_segtC @ a_segtD w_segtE @ m_segtH w3_segtI w4_segtJ w5_segtK}]
Data.Data.$fDataAlt_$cgmapMo
  = \ (@ (f_segtC :: * -> *))
      (@ a_segtD)
      (w_segtE :: Data (f_segtC a_segtD))
      _ [Occ=Dead]
      _ [Occ=Dead]
      (@ (m_segtH :: * -> *))
      (w3_segtI :: MonadPlus m_segtH)
      (w4_segtJ :: forall d. Data d => d -> m_segtH d)
      (w5_segtK :: Alt f_segtC a_segtD) ->
      Data.Data.$w$cgmapMo6
        @ f_segtC @ a_segtD w_segtE @ m_segtH w3_segtI w4_segtJ w5_segtK

-- RHS size: {terms: 4, types: 11, coercions: 0, joins: 0/0}
lvl174_rejSz :: forall (f :: * -> *) a. Alt f a -> Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl174_rejSz
  = \ (@ (f_Xe4rU :: * -> *)) (@ a_Xe4rW) _ [Occ=Dead] ->
      Data.Data.$cAlt

-- RHS size: {terms: 4, types: 11, coercions: 0, joins: 0/0}
lvl175_rejSA :: forall (f :: * -> *) a. Alt f a -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl175_rejSA
  = \ (@ (f_Xe4rU :: * -> *)) (@ a_Xe4rW) _ [Occ=Dead] ->
      Data.Data.$tAlt

-- RHS size: {terms: 7, types: 33, coercions: 0, joins: 0/0}
lvl176_rejSB
  :: forall (f :: * -> *) a (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Alt f a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl176_rejSB
  = \ (@ (f_Xe4rU :: * -> *))
      (@ a_Xe4rW)
      (@ (t_ae3KE :: * -> *))
      (@ (c_ae3KF :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae3KF (Alt f_Xe4rU a_Xe4rW))

-- RHS size: {terms: 7, types: 42, coercions: 0, joins: 0/0}
lvl177_rejSC
  :: forall (f :: * -> *) a (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c (Alt f a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl177_rejSC
  = \ (@ (f_Xe4rU :: * -> *))
      (@ a_Xe4rW)
      (@ (t_ae3KX :: * -> * -> *))
      (@ (c_ae3KY :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae3KY (Alt f_Xe4rU a_Xe4rW))

-- RHS size: {terms: 108, types: 266, coercions: 76, joins: 0/0}
Data.Data.$fDataAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) a.
     (Data (f a), Data a, Typeable f) =>
     Data (Alt f a)
[GblId[DFunId],
 Arity=3,
 Str=<L,U><L,1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=DFun: \ (@ (f_ae1Xb :: * -> *))
             (@ a_ae1Xc)
             (v_XL9 :: Data (f_ae1Xb a_ae1Xc))
             (v1_XLb :: Data a_ae1Xc)
             (v2_XLd :: Typeable f_ae1Xb) ->
       Data.Data.C:Data TYPE: Alt f_ae1Xb a_ae1Xc
                        (Data.Data.$fDataAlt7 @ f_ae1Xb @ a_ae1Xc v_XL9 v1_XLb v2_XLd)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Alt
                                                                                    f_ae1Xb
                                                                                    a_ae1Xc>_N
                                :: (Data.Typeable.Internal.TypeRep (Alt f_ae1Xb a_ae1Xc) :: *)
                                   ~R# (Typeable (Alt f_ae1Xb a_ae1Xc) :: Constraint))
                        \ (@ (c_ae3K6 :: * -> *))
                          (k_ae2o1 [Occ=Once!]
                             :: forall d b. Data d => c_ae3K6 (d -> b) -> d -> c_ae3K6 b)
                          (z_ae2o2 [Occ=Once!] :: forall g. g -> c_ae3K6 g)
                          (ds_de7vl [Occ=Once] :: Alt f_ae1Xb a_ae1Xc) ->
                          k_ae2o1
                            @ (f_ae1Xb a_ae1Xc)
                            @ (Alt f_ae1Xb a_ae1Xc)
                            v_XL9
                            (z_ae2o2
                               @ (f_ae1Xb a_ae1Xc -> Alt f_ae1Xb a_ae1Xc)
                               ((\ (v3_XIb [Occ=Once] :: f_ae1Xb a_ae1Xc) -> v3_XIb)
                                `cast` (<f_ae1Xb a_ae1Xc>_R
                                        ->_R Sym (Data.Semigroup.Internal.N:Alt[0]
                                                      <*>_N <f_ae1Xb>_R) <a_ae1Xc>_N
                                        :: (f_ae1Xb a_ae1Xc -> f_ae1Xb a_ae1Xc :: *)
                                           ~R# (f_ae1Xb a_ae1Xc -> Alt f_ae1Xb a_ae1Xc :: *))))
                            (ds_de7vl
                             `cast` (Data.Semigroup.Internal.N:Alt[0]
                                         <*>_N <f_ae1Xb>_R <a_ae1Xc>_N
                                     :: (Alt f_ae1Xb a_ae1Xc :: *) ~R# (f_ae1Xb a_ae1Xc :: *)))
                        \ (@ (c_ae3Kj :: * -> *))
                          (k_ae2o4 [Occ=Once!]
                             :: forall b r. Data b => c_ae3Kj (b -> r) -> c_ae3Kj r)
                          (z_ae2o5 [Occ=Once!] :: forall r. r -> c_ae3Kj r)
                          _ [Occ=Dead] ->
                          k_ae2o4
                            @ (f_ae1Xb a_ae1Xc)
                            @ (Alt f_ae1Xb a_ae1Xc)
                            v_XL9
                            (z_ae2o5
                               @ (f_ae1Xb a_ae1Xc -> Alt f_ae1Xb a_ae1Xc)
                               ((\ (v3_XIb [Occ=Once] :: f_ae1Xb a_ae1Xc) -> v3_XIb)
                                `cast` (<f_ae1Xb a_ae1Xc>_R
                                        ->_R Sym (Data.Semigroup.Internal.N:Alt[0]
                                                      <*>_N <f_ae1Xb>_R) <a_ae1Xc>_N
                                        :: (f_ae1Xb a_ae1Xc -> f_ae1Xb a_ae1Xc :: *)
                                           ~R# (f_ae1Xb a_ae1Xc -> Alt f_ae1Xb a_ae1Xc :: *))))
                        \ _ [Occ=Dead] -> Data.Data.$cAlt
                        \ _ [Occ=Dead] -> Data.Data.$tAlt
                        \ (@ (t_ae3KE :: * -> *))
                          (@ (c_ae3KF :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae3KF (Alt f_ae1Xb a_ae1Xc))
                        \ (@ (t_ae3KX :: * -> * -> *))
                          (@ (c_ae3KY :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae3KY (Alt f_ae1Xb a_ae1Xc))
                        (\ (ds_de7vs [Occ=Once!] :: forall b. Data b => b -> b)
                           (x0_Xe34p [Occ=Once] :: Alt f_ae1Xb a_ae1Xc) ->
                           ds_de7vs
                             @ (f_ae1Xb a_ae1Xc)
                             v_XL9
                             (x0_Xe34p
                              `cast` (Data.Semigroup.Internal.N:Alt[0]
                                          <*>_N <f_ae1Xb>_R <a_ae1Xc>_N
                                      :: (Alt f_ae1Xb a_ae1Xc :: *) ~R# (f_ae1Xb a_ae1Xc :: *))))
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <Alt f_ae1Xb a_ae1Xc>_R
                                ->_R Sym (Data.Semigroup.Internal.N:Alt[0]
                                              <*>_N <f_ae1Xb>_R) <a_ae1Xc>_N
                                :: ((forall b. Data b => b -> b)
                                    -> Alt f_ae1Xb a_ae1Xc -> f_ae1Xb a_ae1Xc :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> Alt f_ae1Xb a_ae1Xc -> Alt f_ae1Xb a_ae1Xc :: *))
                        \ (@ r_ae3Lv)
                          (@ r'_ae3Lw)
                          (ds_de7vt [Occ=Once!] :: r_ae3Lv -> r'_ae3Lw -> r_ae3Lv)
                          (ds1_de7vu [Occ=Once] :: r_ae3Lv)
                          (ds2_de7vv [Occ=Once!] :: forall d. Data d => d -> r'_ae3Lw)
                          (eta_XL7 [Occ=Once] :: Alt f_ae1Xb a_ae1Xc) ->
                          ds_de7vt
                            ds1_de7vu
                            (ds2_de7vv
                               @ (f_ae1Xb a_ae1Xc)
                               v_XL9
                               (eta_XL7
                                `cast` (Data.Semigroup.Internal.N:Alt[0]
                                            <*>_N <f_ae1Xb>_R <a_ae1Xc>_N
                                        :: (Alt f_ae1Xb a_ae1Xc :: *) ~R# (f_ae1Xb a_ae1Xc :: *))))
                        \ (@ r_ae3LM)
                          (@ r'_ae3LN)
                          (ds_de7vw [Occ=Once!] :: r'_ae3LN -> r_ae3LM -> r_ae3LM)
                          (ds1_de7vx [Occ=Once] :: r_ae3LM)
                          (ds2_de7vy [Occ=Once!] :: forall d. Data d => d -> r'_ae3LN)
                          (x0_ae1SX [Occ=Once] :: Alt f_ae1Xb a_ae1Xc) ->
                          ds_de7vw
                            (ds2_de7vy
                               @ (f_ae1Xb a_ae1Xc)
                               v_XL9
                               (x0_ae1SX
                                `cast` (Data.Semigroup.Internal.N:Alt[0]
                                            <*>_N <f_ae1Xb>_R <a_ae1Xc>_N
                                        :: (Alt f_ae1Xb a_ae1Xc :: *) ~R# (f_ae1Xb a_ae1Xc :: *))))
                            ds1_de7vx
                        \ (@ u_ae3M3)
                          (ds_de7vz [Occ=Once!] :: forall d. Data d => d -> u_ae3M3)
                          (x0_ae1SX [Occ=Once] :: Alt f_ae1Xb a_ae1Xc) ->
                          GHC.Types.:
                            @ u_ae3M3
                            (ds_de7vz
                               @ (f_ae1Xb a_ae1Xc)
                               v_XL9
                               (x0_ae1SX
                                `cast` (Data.Semigroup.Internal.N:Alt[0]
                                            <*>_N <f_ae1Xb>_R <a_ae1Xc>_N
                                        :: (Alt f_ae1Xb a_ae1Xc :: *) ~R# (f_ae1Xb a_ae1Xc :: *))))
                            (GHC.Types.[] @ u_ae3M3)
                        \ (@ u_ae3Mh)
                          (ds_de7vA [Occ=Once!] :: Int)
                          (ds1_de7vB [Occ=Once!] :: forall d. Data d => d -> u_ae3Mh)
                          (x_ae1T7 [Occ=Once] :: Alt f_ae1Xb a_ae1Xc) ->
                          case ds_de7vA of { I# x1_a22G [Occ=Once!] ->
                          case x1_a22G of {
                            __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3Mh;
                            0# ->
                              ds1_de7vB
                                @ (f_ae1Xb a_ae1Xc)
                                v_XL9
                                (x_ae1T7
                                 `cast` (Data.Semigroup.Internal.N:Alt[0]
                                             <*>_N <f_ae1Xb>_R <a_ae1Xc>_N
                                         :: (Alt f_ae1Xb a_ae1Xc :: *) ~R# (f_ae1Xb a_ae1Xc :: *)))
                          }
                          }
                        Data.Data.$fDataAlt_$cgmapM @ f_ae1Xb @ a_ae1Xc v_XL9 v1_XLb v2_XLd
                        Data.Data.$fDataAlt_$cgmapMp
                          @ f_ae1Xb @ a_ae1Xc v_XL9 v1_XLb v2_XLd
                        Data.Data.$fDataAlt_$cgmapMo
                          @ f_ae1Xb @ a_ae1Xc v_XL9 v1_XLb v2_XLd]
Data.Data.$fDataAlt
  = \ (@ (f_Xe4rU :: * -> *))
      (@ a_Xe4rW)
      ($dData_Xe4rY :: Data (f_Xe4rU a_Xe4rW))
      ($dData1_Xe4s0 :: Data a_Xe4rW)
      ($dTypeable_Xe4s2 :: Typeable f_Xe4rU) ->
      Data.Data.C:Data
        @ (Alt f_Xe4rU a_Xe4rW)
        ((Data.Data.$fDataAlt7
            @ f_Xe4rU @ a_Xe4rW $dData_Xe4rY $dData1_Xe4s0 $dTypeable_Xe4s2)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Alt
                                                                     f_Xe4rU a_Xe4rW>_N
                 :: (Data.Typeable.Internal.TypeRep (Alt f_Xe4rU a_Xe4rW) :: *)
                    ~R# (Typeable (Alt f_Xe4rU a_Xe4rW) :: Constraint)))
        (\ (@ (c_ae3K6 :: * -> *))
           (k_ae2o1
              :: forall d b. Data d => c_ae3K6 (d -> b) -> d -> c_ae3K6 b)
           (z_ae2o2 :: forall g. g -> c_ae3K6 g)
           (ds_de7vl :: Alt f_Xe4rU a_Xe4rW) ->
           k_ae2o1
             @ (f_Xe4rU a_Xe4rW)
             @ (Alt f_Xe4rU a_Xe4rW)
             $dData_Xe4rY
             (z_ae2o2
                @ (f_Xe4rU a_Xe4rW -> Alt f_Xe4rU a_Xe4rW)
                ((Data.Data.$fDataAlt2 @ f_Xe4rU @ a_Xe4rW)
                 `cast` (<f_Xe4rU a_Xe4rW>_R
                         ->_R Sym (Data.Semigroup.Internal.N:Alt[0]
                                       <*>_N <f_Xe4rU>_R) <a_Xe4rW>_N
                         :: (f_Xe4rU a_Xe4rW -> f_Xe4rU a_Xe4rW :: *)
                            ~R# (f_Xe4rU a_Xe4rW -> Alt f_Xe4rU a_Xe4rW :: *))))
             (ds_de7vl
              `cast` (Data.Semigroup.Internal.N:Alt[0]
                          <*>_N <f_Xe4rU>_R <a_Xe4rW>_N
                      :: (Alt f_Xe4rU a_Xe4rW :: *) ~R# (f_Xe4rU a_Xe4rW :: *))))
        (\ (@ (c_ae3Kj :: * -> *))
           (k_ae2o4 :: forall b r. Data b => c_ae3Kj (b -> r) -> c_ae3Kj r)
           (z_ae2o5 :: forall r. r -> c_ae3Kj r)
           _ [Occ=Dead] ->
           k_ae2o4
             @ (f_Xe4rU a_Xe4rW)
             @ (Alt f_Xe4rU a_Xe4rW)
             $dData_Xe4rY
             (z_ae2o5
                @ (f_Xe4rU a_Xe4rW -> Alt f_Xe4rU a_Xe4rW)
                ((Data.Data.$fDataAlt2 @ f_Xe4rU @ a_Xe4rW)
                 `cast` (<f_Xe4rU a_Xe4rW>_R
                         ->_R Sym (Data.Semigroup.Internal.N:Alt[0]
                                       <*>_N <f_Xe4rU>_R) <a_Xe4rW>_N
                         :: (f_Xe4rU a_Xe4rW -> f_Xe4rU a_Xe4rW :: *)
                            ~R# (f_Xe4rU a_Xe4rW -> Alt f_Xe4rU a_Xe4rW :: *)))))
        (lvl174_rejSz @ f_Xe4rU @ a_Xe4rW)
        (lvl175_rejSA @ f_Xe4rU @ a_Xe4rW)
        (lvl176_rejSB @ f_Xe4rU @ a_Xe4rW)
        (lvl177_rejSC @ f_Xe4rU @ a_Xe4rW)
        ((\ (ds_de7vs :: forall b. Data b => b -> b)
            (x0_Xe34p :: Alt f_Xe4rU a_Xe4rW) ->
            ds_de7vs
              @ (f_Xe4rU a_Xe4rW)
              $dData_Xe4rY
              (x0_Xe34p
               `cast` (Data.Semigroup.Internal.N:Alt[0]
                           <*>_N <f_Xe4rU>_R <a_Xe4rW>_N
                       :: (Alt f_Xe4rU a_Xe4rW :: *) ~R# (f_Xe4rU a_Xe4rW :: *))))
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <Alt f_Xe4rU a_Xe4rW>_R
                 ->_R Sym (Data.Semigroup.Internal.N:Alt[0]
                               <*>_N <f_Xe4rU>_R) <a_Xe4rW>_N
                 :: ((forall b. Data b => b -> b)
                     -> Alt f_Xe4rU a_Xe4rW -> f_Xe4rU a_Xe4rW :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> Alt f_Xe4rU a_Xe4rW -> Alt f_Xe4rU a_Xe4rW :: *)))
        (\ (@ r_ae3Lv)
           (@ r'_ae3Lw)
           (ds_de7vt :: r_ae3Lv -> r'_ae3Lw -> r_ae3Lv)
           (ds1_de7vu :: r_ae3Lv)
           (ds2_de7vv :: forall d. Data d => d -> r'_ae3Lw)
           (eta_XL7 :: Alt f_Xe4rU a_Xe4rW) ->
           ds_de7vt
             ds1_de7vu
             (ds2_de7vv
                @ (f_Xe4rU a_Xe4rW)
                $dData_Xe4rY
                (eta_XL7
                 `cast` (Data.Semigroup.Internal.N:Alt[0]
                             <*>_N <f_Xe4rU>_R <a_Xe4rW>_N
                         :: (Alt f_Xe4rU a_Xe4rW :: *) ~R# (f_Xe4rU a_Xe4rW :: *)))))
        (\ (@ r_ae3LM)
           (@ r'_ae3LN)
           (ds_de7vw :: r'_ae3LN -> r_ae3LM -> r_ae3LM)
           (ds1_de7vx :: r_ae3LM)
           (ds2_de7vy :: forall d. Data d => d -> r'_ae3LN)
           (x0_ae1SX :: Alt f_Xe4rU a_Xe4rW) ->
           ds_de7vw
             (ds2_de7vy
                @ (f_Xe4rU a_Xe4rW)
                $dData_Xe4rY
                (x0_ae1SX
                 `cast` (Data.Semigroup.Internal.N:Alt[0]
                             <*>_N <f_Xe4rU>_R <a_Xe4rW>_N
                         :: (Alt f_Xe4rU a_Xe4rW :: *) ~R# (f_Xe4rU a_Xe4rW :: *))))
             ds1_de7vx)
        (\ (@ u_ae3M3)
           (ds_de7vz :: forall d. Data d => d -> u_ae3M3)
           (x0_ae1SX :: Alt f_Xe4rU a_Xe4rW) ->
           GHC.Types.:
             @ u_ae3M3
             (ds_de7vz
                @ (f_Xe4rU a_Xe4rW)
                $dData_Xe4rY
                (x0_ae1SX
                 `cast` (Data.Semigroup.Internal.N:Alt[0]
                             <*>_N <f_Xe4rU>_R <a_Xe4rW>_N
                         :: (Alt f_Xe4rU a_Xe4rW :: *) ~R# (f_Xe4rU a_Xe4rW :: *))))
             (GHC.Types.[] @ u_ae3M3))
        (\ (@ u_ae3Mh)
           (ds_de7vA :: Int)
           (ds1_de7vB :: forall d. Data d => d -> u_ae3Mh)
           (x_ae1T7 :: Alt f_Xe4rU a_Xe4rW) ->
           case ds_de7vA of { I# x1_a22G ->
           case x1_a22G of {
             __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3Mh;
             0# ->
               ds1_de7vB
                 @ (f_Xe4rU a_Xe4rW)
                 $dData_Xe4rY
                 (x_ae1T7
                  `cast` (Data.Semigroup.Internal.N:Alt[0]
                              <*>_N <f_Xe4rU>_R <a_Xe4rW>_N
                          :: (Alt f_Xe4rU a_Xe4rW :: *) ~R# (f_Xe4rU a_Xe4rW :: *)))
           }
           })
        (\ (@ (m_segtx :: * -> *))
           (w_segty :: Monad m_segtx)
           (w1_segtz :: forall d. Data d => d -> m_segtx d)
           (w2_segtA :: Alt f_Xe4rU a_Xe4rW) ->
           Data.Data.$w$cgmapM6
             @ f_Xe4rU
             @ a_Xe4rW
             $dData_Xe4rY
             @ m_segtx
             w_segty
             w1_segtz
             w2_segtA)
        (\ (@ (m_segtn :: * -> *))
           (w_segto :: MonadPlus m_segtn)
           (w1_segtp :: forall d. Data d => d -> m_segtn d)
           (w2_segtq :: Alt f_Xe4rU a_Xe4rW) ->
           Data.Data.$w$cgmapMp7
             @ f_Xe4rU
             @ a_Xe4rW
             $dData_Xe4rY
             @ m_segtn
             w_segto
             w1_segtp
             w2_segtq)
        (\ (@ (m_segtH :: * -> *))
           (w_segtI :: MonadPlus m_segtH)
           (w1_segtJ :: forall d. Data d => d -> m_segtH d)
           (w2_segtK :: Alt f_Xe4rU a_Xe4rW) ->
           Data.Data.$w$cgmapMo6
             @ f_Xe4rU
             @ a_Xe4rW
             $dData_Xe4rY
             @ m_segtH
             w_segtI
             w1_segtJ
             w2_segtK)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataU6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataU6 = "U1"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataU5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataU5 = unpackCString# Data.Data.$fDataU6

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go35_rejSD :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go35_rejSD
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fDataU5 of {
                False -> go35_rejSD ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cU2_rejSE :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cU2_rejSE = Data.Data.AlgConstr $cU3_rejSF

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataU4 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataU4
  = GHC.Types.: @ Constr Data.Data.$cU1 (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataU3 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataU3 = Data.Data.AlgRep Data.Data.$fDataU4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tU1 :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$tU1
  = Data.Data.DataType Data.Data.$fDataU5 Data.Data.$fDataU3

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cU1 [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cU1
  = Data.Data.Constr
      $cU2_rejSE
      Data.Data.$fDataU5
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tU1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cU3_rejSF :: ConIndex
[GblId]
$cU3_rejSF = go35_rejSD Data.Data.$fDataU4 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
Data.Data.$fDataU2 :: forall p. (U1 p, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataU2
  = \ (@ p_Xe4pc) -> (GHC.Generics.U1 @ * @ p_Xe4pc, GHC.Types.False)

-- RHS size: {terms: 30, types: 71, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp32 [InlPrag=NOUSERINLINE[0]]
  :: forall p (m :: * -> *). MonadPlus m => U1 p -> m (U1 p)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*H>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 20] 210 0}]
Data.Data.$w$cgmapMp32
  = \ (@ p_segtO)
      (@ (m_segtQ :: * -> *))
      (w_segtR :: MonadPlus m_segtQ)
      (w1_segtT :: U1 p_segtO) ->
      let {
        lvl270_se9Q2 :: m_segtQ (U1 p_segtO)
        [LclId]
        lvl270_se9Q2 = mzero @ m_segtQ w_segtR @ (U1 p_segtO) } in
      let {
        $dMonad_se9qr [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_segtQ
        [LclId]
        $dMonad_se9qr = GHC.Base.$p2MonadPlus @ m_segtQ w_segtR } in
      >>=
        @ m_segtQ
        $dMonad_se9qr
        @ (U1 p_segtO, Bool)
        @ (U1 p_segtO)
        (case w1_segtT of { U1 ->
         return
           @ m_segtQ
           $dMonad_se9qr
           @ (U1 p_segtO, Bool)
           (Data.Data.$fDataU2 @ p_segtO)
         })
        (\ (ds_de7oa :: (U1 p_segtO, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9Q2;
             True -> return @ m_segtQ $dMonad_se9qr @ (U1 p_segtO) x'_ae1TD
           }
           })

-- RHS size: {terms: 9, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataU1_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall p.
     Data p =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> U1 p -> m (U1 p)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ p_segtO)
                 _ [Occ=Dead]
                 (@ (m_segtQ :: * -> *))
                 (w1_segtR [Occ=Once] :: MonadPlus m_segtQ)
                 _ [Occ=Dead]
                 (w3_segtT [Occ=Once] :: U1 p_segtO) ->
                 Data.Data.$w$cgmapMp32 @ p_segtO @ m_segtQ w1_segtR w3_segtT}]
Data.Data.$fDataU1_$cgmapMp
  = \ (@ p_segtO)
      _ [Occ=Dead]
      (@ (m_segtQ :: * -> *))
      (w1_segtR :: MonadPlus m_segtQ)
      _ [Occ=Dead]
      (w3_segtT :: U1 p_segtO) ->
      Data.Data.$w$cgmapMp32 @ p_segtO @ m_segtQ w1_segtR w3_segtT

-- RHS size: {terms: 30, types: 71, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo31 [InlPrag=NOUSERINLINE[0]]
  :: forall p (m :: * -> *). MonadPlus m => U1 p -> m (U1 p)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*H>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 20] 210 0}]
Data.Data.$w$cgmapMo31
  = \ (@ p_segtV)
      (@ (m_segtX :: * -> *))
      (w_segtY :: MonadPlus m_segtX)
      (w1_segu0 :: U1 p_segtV) ->
      let {
        lvl270_se9Q6 :: m_segtX (U1 p_segtV)
        [LclId]
        lvl270_se9Q6 = mzero @ m_segtX w_segtY @ (U1 p_segtV) } in
      let {
        $dMonad_se9qp [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_segtX
        [LclId]
        $dMonad_se9qp = GHC.Base.$p2MonadPlus @ m_segtX w_segtY } in
      >>=
        @ m_segtX
        $dMonad_se9qp
        @ (U1 p_segtV, Bool)
        @ (U1 p_segtV)
        (case w1_segu0 of { U1 ->
         return
           @ m_segtX
           $dMonad_se9qp
           @ (U1 p_segtV, Bool)
           (Data.Data.$fDataU2 @ p_segtV)
         })
        (\ (ds_de7pa :: (U1 p_segtV, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9Q6;
             True -> return @ m_segtX $dMonad_se9qp @ (U1 p_segtV) x'_ae1TS
           }
           })

-- RHS size: {terms: 9, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataU1_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall p.
     Data p =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> U1 p -> m (U1 p)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ p_segtV)
                 _ [Occ=Dead]
                 (@ (m_segtX :: * -> *))
                 (w1_segtY [Occ=Once] :: MonadPlus m_segtX)
                 _ [Occ=Dead]
                 (w3_segu0 [Occ=Once] :: U1 p_segtV) ->
                 Data.Data.$w$cgmapMo31 @ p_segtV @ m_segtX w1_segtY w3_segu0}]
Data.Data.$fDataU1_$cgmapMo
  = \ (@ p_segtV)
      _ [Occ=Dead]
      (@ (m_segtX :: * -> *))
      (w1_segtY :: MonadPlus m_segtX)
      _ [Occ=Dead]
      (w3_segu0 :: U1 p_segtV) ->
      Data.Data.$w$cgmapMo31 @ p_segtV @ m_segtX w1_segtY w3_segu0

-- RHS size: {terms: 10, types: 38, coercions: 0, joins: 0/0}
lvl178_rejSG
  :: forall p (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> U1 p -> c (U1 p)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*H>,
 Unf=OtherCon []]
lvl178_rejSG
  = \ (@ p_Xe4p3)
      (@ (c_ae3GU :: * -> *))
      _ [Occ=Dead]
      (z_ae2nY :: forall g. g -> c_ae3GU g)
      (ds_de7v2 :: U1 p_Xe4p3) ->
      case ds_de7v2 of { U1 ->
      z_ae2nY @ (U1 p_Xe4p3) (GHC.Generics.U1 @ * @ p_Xe4p3)
      }

-- RHS size: {terms: 7, types: 30, coercions: 0, joins: 0/0}
lvl179_rejSH
  :: forall p (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c (U1 p)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,A>,
 Unf=OtherCon []]
lvl179_rejSH
  = \ (@ p_Xe4p3)
      (@ (c_ae3H2 :: * -> *))
      _ [Occ=Dead]
      (z_ae2o0 :: forall r. r -> c_ae3H2 r)
      _ [Occ=Dead] ->
      z_ae2o0 @ (U1 p_Xe4p3) (GHC.Generics.U1 @ * @ p_Xe4p3)

-- RHS size: {terms: 6, types: 10, coercions: 0, joins: 0/0}
lvl180_rejSI :: forall p. U1 p -> Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []]
lvl180_rejSI
  = \ (@ p_Xe4p3) (ds_de7v4 :: U1 p_Xe4p3) ->
      case ds_de7v4 of { U1 -> Data.Data.$cU1 }

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
lvl181_rejSJ :: forall p. U1 p -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl181_rejSJ = \ (@ p_Xe4p3) _ [Occ=Dead] -> Data.Data.$tU1

-- RHS size: {terms: 6, types: 28, coercions: 0, joins: 0/0}
lvl182_rejSK
  :: forall p (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (U1 p))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl182_rejSK
  = \ (@ p_Xe4p3)
      (@ (t_ae3Hi :: * -> *))
      (@ (c_ae3Hj :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae3Hj (U1 p_Xe4p3))

-- RHS size: {terms: 6, types: 37, coercions: 0, joins: 0/0}
lvl183_rejSL
  :: forall p (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c (U1 p))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl183_rejSL
  = \ (@ p_Xe4p3)
      (@ (t_ae3HB :: * -> * -> *))
      (@ (c_ae3HC :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae3HC (U1 p_Xe4p3))

-- RHS size: {terms: 4, types: 12, coercions: 0, joins: 0/0}
lvl184_rejSM
  :: forall p. (forall b. Data b => b -> b) -> U1 p -> U1 p
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U()>m,
 Unf=OtherCon []]
lvl184_rejSM
  = \ (@ p_Xe4p3) _ [Occ=Dead] (x0_Xe34R :: U1 p_Xe4p3) -> x0_Xe34R

-- RHS size: {terms: 11, types: 24, coercions: 9, joins: 0/0}
lvl185_rejSN
  :: forall p r r'.
     (r -> r' -> r)
     -> r -> (forall d. Data d => d -> r') -> U1 p -> Const r (U1 p)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*H>,
 Unf=OtherCon []]
lvl185_rejSN
  = \ (@ p_Xe4p3)
      (@ r_Xe4tG)
      (@ r'_Xe4tI)
      _ [Occ=Dead]
      (ds1_Xe8gK :: r_Xe4tG)
      _ [Occ=Dead]
      (eta_X1x2 :: U1 p_Xe4p3) ->
      case eta_X1x2 of { U1 ->
      ds1_Xe8gK
      `cast` (Sym (Data.Functor.Const.N:Const[0]
                       <*>_N <r_Xe4tG>_R <U1 p_Xe4p3>_P)
              :: (r_Xe4tG :: *) ~R# (Const r_Xe4tG (U1 p_Xe4p3) :: *))
      }

-- RHS size: {terms: 11, types: 24, coercions: 0, joins: 0/0}
lvl186_rejSO
  :: forall p r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> U1 p -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*H>,
 Unf=OtherCon []]
lvl186_rejSO
  = \ (@ p_Xe4p3)
      (@ r_ae3Iq)
      (@ r'_ae3Ir)
      _ [Occ=Dead]
      (ds1_de7vd :: r_ae3Iq)
      _ [Occ=Dead]
      (x0_ae1SX :: U1 p_Xe4p3) ->
      case x0_ae1SX of { U1 -> ds1_de7vd }

-- RHS size: {terms: 8, types: 19, coercions: 0, joins: 0/0}
lvl187_rejSP
  :: forall p u. (forall d. Data d => d -> u) -> U1 p -> [u]
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><S,1*H>, Unf=OtherCon []]
lvl187_rejSP
  = \ (@ p_Xe4p3)
      (@ u_ae3IH)
      _ [Occ=Dead]
      (x0_ae1SX :: U1 p_Xe4p3) ->
      case x0_ae1SX of { U1 -> GHC.Types.[] @ u_ae3IH }

-- RHS size: {terms: 11, types: 31, coercions: 0, joins: 0/0}
lvl188_rejSQ
  :: forall p (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> U1 p -> m (U1 p)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><L,A><S,1*H>,
 Unf=OtherCon []]
lvl188_rejSQ
  = \ (@ p_Xe4p3)
      (@ (m_ae3J9 :: * -> *))
      ($dMonad_ae3Jb :: Monad m_ae3J9)
      _ [Occ=Dead]
      (eta_XLk :: U1 p_Xe4p3) ->
      case eta_XLk of { U1 ->
      return
        @ m_ae3J9
        $dMonad_ae3Jb
        @ (U1 p_Xe4p3)
        (GHC.Generics.U1 @ * @ p_Xe4p3)
      }

-- RHS size: {terms: 9, types: 20, coercions: 0, joins: 0/0}
lvl189_rejSR
  :: forall p u. Int -> (forall d. Data d => d -> u) -> U1 p -> u
[GblId, Arity=3, Str=<B,A><B,A><B,1*H>x, Unf=OtherCon []]
lvl189_rejSR
  = \ (@ p_Xe4p3)
      (@ u_ae3IV)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (x_ae1T7 :: U1 p_Xe4p3) ->
      case x_ae1T7 of { U1 -> Data.Maybe.fromJust1 @ u_ae3IV }

-- RHS size: {terms: 8, types: 21, coercions: 0, joins: 0/0}
lvl190_rejSS
  :: forall p (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> U1 p -> m (U1 p)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*H>,
 Unf=OtherCon []]
lvl190_rejSS
  = \ (@ p_Xe4p3)
      (@ (m_segtQ :: * -> *))
      (w_segtR :: MonadPlus m_segtQ)
      _ [Occ=Dead]
      (w2_segtT :: U1 p_Xe4p3) ->
      Data.Data.$w$cgmapMp32 @ p_Xe4p3 @ m_segtQ w_segtR w2_segtT

-- RHS size: {terms: 8, types: 21, coercions: 0, joins: 0/0}
lvl191_rejST
  :: forall p (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> U1 p -> m (U1 p)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*H>,
 Unf=OtherCon []]
lvl191_rejST
  = \ (@ p_Xe4p3)
      (@ (m_segtX :: * -> *))
      (w_segtY :: MonadPlus m_segtX)
      _ [Occ=Dead]
      (w2_segu0 :: U1 p_Xe4p3) ->
      Data.Data.$w$cgmapMo31 @ p_Xe4p3 @ m_segtX w_segtY w2_segu0

-- RHS size: {terms: 19, types: 23, coercions: 40, joins: 0/0}
Data.Data.$fDataU1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall p. Data p => Data (U1 p)
[GblId[DFunId],
 Arity=1,
 Str=<L,1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=DFun: \ (@ p_ae1Xa) (v_XLx :: Data p_ae1Xa) ->
       Data.Data.C:Data TYPE: U1 p_ae1Xa
                        (Data.Data.$fDataU7 @ p_ae1Xa v_XLx)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <U1
                                                                                    p_ae1Xa>_N
                                :: (Data.Typeable.Internal.TypeRep (U1 p_ae1Xa) :: *)
                                   ~R# (Typeable (U1 p_ae1Xa) :: Constraint))
                        \ (@ (c_ae3GU :: * -> *))
                          _ [Occ=Dead]
                          (z_ae2nY [Occ=Once!] :: forall g. g -> c_ae3GU g)
                          (ds_de7v2 [Occ=Once!] :: U1 p_ae1Xa) ->
                          case ds_de7v2 of { U1 ->
                          z_ae2nY @ (U1 p_ae1Xa) (GHC.Generics.U1 @ * @ p_ae1Xa)
                          }
                        \ (@ (c_ae3H2 :: * -> *))
                          _ [Occ=Dead]
                          (z_ae2o0 [Occ=Once!] :: forall r. r -> c_ae3H2 r)
                          _ [Occ=Dead] ->
                          z_ae2o0 @ (U1 p_ae1Xa) (GHC.Generics.U1 @ * @ p_ae1Xa)
                        \ (ds_de7v4 [Occ=Once!] :: U1 p_ae1Xa) ->
                          case ds_de7v4 of { U1 -> Data.Data.$cU1 }
                        \ _ [Occ=Dead] -> Data.Data.$tU1
                        \ (@ (t_ae3Hi :: * -> *))
                          (@ (c_ae3Hj :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae3Hj (U1 p_ae1Xa))
                        \ (@ (t_ae3HB :: * -> * -> *))
                          (@ (c_ae3HC :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae3HC (U1 p_ae1Xa))
                        \ _ [Occ=Dead] (x0_Xe34R [Occ=Once] :: U1 p_ae1Xa) -> x0_Xe34R
                        (\ (@ r_Xe4tG)
                           (@ r'_Xe4tI)
                           _ [Occ=Dead]
                           (ds1_Xe8gK [Occ=Once] :: r_Xe4tG)
                           _ [Occ=Dead]
                           (eta_X1x2 [Occ=Once!] :: U1 p_ae1Xa) ->
                           case eta_X1x2 of { U1 ->
                           ds1_Xe8gK
                           `cast` (Sym (Data.Functor.Const.N:Const[0]
                                            <*>_N <r_Xe4tG>_R <U1 p_ae1Xa>_P)
                                   :: (r_Xe4tG :: *) ~R# (Const r_Xe4tG (U1 p_ae1Xa) :: *))
                           })
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <U1 p_ae1Xa>_R
                                ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <U1 p_ae1Xa>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> U1 p_ae1Xa
                                    -> Const r (U1 p_ae1Xa) :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d. Data d => d -> r')
                                        -> U1 p_ae1Xa
                                        -> r :: *))
                        \ (@ r_ae3Iq)
                          (@ r'_ae3Ir)
                          _ [Occ=Dead]
                          (ds1_de7vd [Occ=Once] :: r_ae3Iq)
                          _ [Occ=Dead]
                          (x0_ae1SX [Occ=Once!] :: U1 p_ae1Xa) ->
                          case x0_ae1SX of { U1 -> ds1_de7vd }
                        \ (@ u_ae3IH) _ [Occ=Dead] (x0_ae1SX [Occ=Once!] :: U1 p_ae1Xa) ->
                          case x0_ae1SX of { U1 -> GHC.Types.[] @ u_ae3IH }
                        \ (@ u_ae3IV)
                          _ [Occ=Dead]
                          _ [Occ=Dead]
                          (x_ae1T7 [Occ=Once!] :: U1 p_ae1Xa) ->
                          case x_ae1T7 of { U1 -> Data.Maybe.fromJust1 @ u_ae3IV }
                        \ (@ (m_ae3J9 :: * -> *))
                          ($dMonad_ae3Jb [Occ=Once] :: Monad m_ae3J9)
                          _ [Occ=Dead]
                          (eta_XLk [Occ=Once!] :: U1 p_ae1Xa) ->
                          case eta_XLk of { U1 ->
                          return
                            @ m_ae3J9
                            $dMonad_ae3Jb
                            @ (U1 p_ae1Xa)
                            (GHC.Generics.U1 @ * @ p_ae1Xa)
                          }
                        Data.Data.$fDataU1_$cgmapMp @ p_ae1Xa v_XLx
                        Data.Data.$fDataU1_$cgmapMo @ p_ae1Xa v_XLx]
Data.Data.$fDataU1
  = \ (@ p_Xe4p3) ($dData_Xe4p5 :: Data p_Xe4p3) ->
      Data.Data.C:Data
        @ (U1 p_Xe4p3)
        ((Data.Data.$fDataU7 @ p_Xe4p3 $dData_Xe4p5)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <U1
                                                                     p_Xe4p3>_N
                 :: (Data.Typeable.Internal.TypeRep (U1 p_Xe4p3) :: *)
                    ~R# (Typeable (U1 p_Xe4p3) :: Constraint)))
        (lvl178_rejSG @ p_Xe4p3)
        (lvl179_rejSH @ p_Xe4p3)
        (lvl180_rejSI @ p_Xe4p3)
        (lvl181_rejSJ @ p_Xe4p3)
        (lvl182_rejSK @ p_Xe4p3)
        (lvl183_rejSL @ p_Xe4p3)
        (lvl184_rejSM @ p_Xe4p3)
        ((lvl185_rejSN @ p_Xe4p3)
         `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                 <r -> r' -> r>_R
                 ->_R <r>_R
                 ->_R <forall d. Data d => d -> r'>_R
                 ->_R <U1 p_Xe4p3>_R
                 ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <U1 p_Xe4p3>_P
                 :: (forall r r'.
                     (r -> r' -> r)
                     -> r
                     -> (forall d. Data d => d -> r')
                     -> U1 p_Xe4p3
                     -> Const r (U1 p_Xe4p3) :: *)
                    ~R# (forall r r'.
                         (r -> r' -> r)
                         -> r -> (forall d. Data d => d -> r') -> U1 p_Xe4p3 -> r :: *)))
        (lvl186_rejSO @ p_Xe4p3)
        (lvl187_rejSP @ p_Xe4p3)
        (lvl189_rejSR @ p_Xe4p3)
        (lvl188_rejSQ @ p_Xe4p3)
        (lvl190_rejSS @ p_Xe4p3)
        (lvl191_rejST @ p_Xe4p3)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataPar7 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataPar7 = "Par1"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataPar6 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataPar6 = unpackCString# Data.Data.$fDataPar7

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$cPar2_rejSU :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$cPar2_rejSU = "unPar1"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cPar3_rejSV :: [Char]
[GblId]
$cPar3_rejSV = unpackCString# $cPar2_rejSU

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$cPar4_rejSW :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cPar4_rejSW
  = GHC.Types.: @ String $cPar3_rejSV (GHC.Types.[] @ String)

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go36_rejSX :: [Constr] -> [Int] -> Int
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go36_rejSX
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fDataPar6 of {
                False -> go36_rejSX ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cPar5_rejSY :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cPar5_rejSY = Data.Data.AlgConstr $cPar6_rejSZ

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataPar5 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataPar5
  = GHC.Types.: @ Constr Data.Data.$cPar1 (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataPar4 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataPar4 = Data.Data.AlgRep Data.Data.$fDataPar5

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tPar1 :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$tPar1
  = Data.Data.DataType Data.Data.$fDataPar6 Data.Data.$fDataPar4

-- RHS size: {terms: 6, types: 0, coercions: 0, joins: 0/0}
Data.Data.$cPar1 [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cPar1
  = Data.Data.Constr
      $cPar5_rejSY
      Data.Data.$fDataPar6
      $cPar4_rejSW
      Data.Data.Prefix
      Data.Data.$tPar1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cPar6_rejSZ :: Int
[GblId]
$cPar6_rejSZ = go36_rejSX Data.Data.$fDataPar5 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 4, types: 7, coercions: 5, joins: 0/0}
Data.Data.$fDataPar2 :: forall p. (p -> Par1 p, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataPar2
  = \ (@ p_Xe4m8) ->
      ((Data.Data.$fDataConst2 @ p_Xe4m8)
       `cast` (<p_Xe4m8>_R ->_R Sym (GHC.Generics.N:Par1[0] <p_Xe4m8>_R)
               :: (p_Xe4m8 -> p_Xe4m8 :: *) ~R# (p_Xe4m8 -> Par1 p_Xe4m8 :: *)),
       GHC.Types.False)

-- RHS size: {terms: 57, types: 112, coercions: 4, joins: 0/3}
Data.Data.$fDataPar1_$cgmapMp
  :: forall p.
     Data p =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Par1 p -> m (Par1 p)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 510 0}]
Data.Data.$fDataPar1_$cgmapMp
  = \ (@ p_Xe4m8)
      ($dData_Xe4ma :: Data p_Xe4m8)
      (@ (m_ae3Gg :: * -> *))
      ($dMonadPlus_ae3Gi :: MonadPlus m_ae3Gg)
      (ds_de7v0 :: forall d. Data d => d -> m_ae3Gg d)
      (eta_XLI :: Par1 p_Xe4m8) ->
      let {
        lvl270_se9Qw :: m_ae3Gg (Par1 p_Xe4m8)
        [LclId]
        lvl270_se9Qw
          = mzero @ m_ae3Gg $dMonadPlus_ae3Gi @ (Par1 p_Xe4m8) } in
      let {
        $dMonad_se9qn [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae3Gg
        [LclId]
        $dMonad_se9qn
          = GHC.Base.$p2MonadPlus @ m_ae3Gg $dMonadPlus_ae3Gi } in
      >>=
        @ m_ae3Gg
        $dMonad_se9qn
        @ (Par1 p_Xe4m8, Bool)
        @ (Par1 p_Xe4m8)
        (let {
           lvl271_se9Qv :: m_ae3Gg p_Xe4m8
           [LclId]
           lvl271_se9Qv
             = ds_de7v0
                 @ p_Xe4m8
                 $dData_Xe4ma
                 (eta_XLI
                  `cast` (GHC.Generics.N:Par1[0] <p_Xe4m8>_R
                          :: (Par1 p_Xe4m8 :: *) ~R# (p_Xe4m8 :: *))) } in
         >>=
           @ m_ae3Gg
           $dMonad_se9qn
           @ (p_Xe4m8 -> Par1 p_Xe4m8, Bool)
           @ (Par1 p_Xe4m8, Bool)
           (return
              @ m_ae3Gg
              $dMonad_se9qn
              @ (p_Xe4m8 -> Par1 p_Xe4m8, Bool)
              (Data.Data.$fDataPar2 @ p_Xe4m8))
           (\ (ds1_de7oD :: (p_Xe4m8 -> Par1 p_Xe4m8, Bool)) ->
              case ds1_de7oD of { (h_ae1TA, b_ae1TB) ->
              mplus
                @ m_ae3Gg
                $dMonadPlus_ae3Gi
                @ (Par1 p_Xe4m8, Bool)
                (>>=
                   @ m_ae3Gg
                   $dMonad_se9qn
                   @ p_Xe4m8
                   @ (Par1 p_Xe4m8, Bool)
                   lvl271_se9Qv
                   (\ (y'_ae1TC :: p_Xe4m8) ->
                      return
                        @ m_ae3Gg
                        $dMonad_se9qn
                        @ (Par1 p_Xe4m8, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_ae3Gg
                   $dMonad_se9qn
                   @ (Par1 p_Xe4m8, Bool)
                   (h_ae1TA
                      (eta_XLI
                       `cast` (GHC.Generics.N:Par1[0] <p_Xe4m8>_R
                               :: (Par1 p_Xe4m8 :: *) ~R# (p_Xe4m8 :: *))),
                    b_ae1TB))
              }))
        (\ (ds1_de7oa :: (Par1 p_Xe4m8, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9Qw;
             True -> return @ m_ae3Gg $dMonad_se9qn @ (Par1 p_Xe4m8) x'_ae1TD
           }
           })

-- RHS size: {terms: 24, types: 44, coercions: 7, joins: 0/1}
Data.Data.$fDataPar1_$cgmapM
  :: forall p.
     Data p =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Par1 p -> m (Par1 p)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120 60 0] 220 0}]
Data.Data.$fDataPar1_$cgmapM
  = \ (@ p_Xe4m7)
      ($dData_Xe4m9 :: Data p_Xe4m7)
      (@ (m_ae3G0 :: * -> *))
      ($dMonad_ae3G2 :: Monad m_ae3G0)
      (ds_de7uZ :: forall d. Data d => d -> m_ae3G0 d)
      (eta_XLJ :: Par1 p_Xe4m7) ->
      let {
        lvl270_se9Qy :: m_ae3G0 p_Xe4m7
        [LclId]
        lvl270_se9Qy
          = ds_de7uZ
              @ p_Xe4m7
              $dData_Xe4m9
              (eta_XLJ
               `cast` (GHC.Generics.N:Par1[0] <p_Xe4m7>_R
                       :: (Par1 p_Xe4m7 :: *) ~R# (p_Xe4m7 :: *))) } in
      >>=
        @ m_ae3G0
        $dMonad_ae3G2
        @ (p_Xe4m7 -> Par1 p_Xe4m7)
        @ (Par1 p_Xe4m7)
        (return
           @ m_ae3G0
           $dMonad_ae3G2
           @ (p_Xe4m7 -> Par1 p_Xe4m7)
           ((Data.Data.$fDataConst2 @ p_Xe4m7)
            `cast` (<p_Xe4m7>_R ->_R Sym (GHC.Generics.N:Par1[0] <p_Xe4m7>_R)
                    :: (p_Xe4m7 -> p_Xe4m7 :: *) ~R# (p_Xe4m7 -> Par1 p_Xe4m7 :: *))))
        (\ (c'_ae1To :: p_Xe4m7 -> Par1 p_Xe4m7) ->
           >>=
             @ m_ae3G0
             $dMonad_ae3G2
             @ p_Xe4m7
             @ (Par1 p_Xe4m7)
             lvl270_se9Qy
             (\ (x'_ae1Tp :: p_Xe4m7) ->
                return
                  @ m_ae3G0 $dMonad_ae3G2 @ (Par1 p_Xe4m7) (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 17, types: 20, coercions: 2, joins: 0/0}
Data.Data.$fDataPar1_$cgmapQi
  :: forall p.
     Data p =>
     forall u. Int -> (forall d. Data d => d -> u) -> Par1 p -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ p_Xe4m6)
                 ($dData_Xe4m8 [Occ=Once] :: Data p_Xe4m6)
                 (@ u_ae3FM)
                 (ds_de7uX [Occ=Once!] :: Int)
                 (ds1_de7uY [Occ=Once!] :: forall d. Data d => d -> u_ae3FM)
                 (x_ae1T7 [Occ=Once] :: Par1 p_Xe4m6) ->
                 case ds_de7uX of { I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3FM;
                   0# ->
                     ds1_de7uY
                       @ p_Xe4m6
                       $dData_Xe4m8
                       (x_ae1T7
                        `cast` (GHC.Generics.N:Par1[0] <p_Xe4m6>_R
                                :: (Par1 p_Xe4m6 :: *) ~R# (p_Xe4m6 :: *)))
                 }
                 }}]
Data.Data.$fDataPar1_$cgmapQi
  = \ (@ p_Xe4m6)
      ($dData_Xe4m8 :: Data p_Xe4m6)
      (@ u_ae3FM)
      (ds_de7uX :: Int)
      (ds1_de7uY :: forall d. Data d => d -> u_ae3FM)
      (x_ae1T7 :: Par1 p_Xe4m6) ->
      case ds_de7uX of { I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3FM;
        0# ->
          ds1_de7uY
            @ p_Xe4m6
            $dData_Xe4m8
            (x_ae1T7
             `cast` (GHC.Generics.N:Par1[0] <p_Xe4m6>_R
                     :: (Par1 p_Xe4m6 :: *) ~R# (p_Xe4m6 :: *)))
      }
      }

-- RHS size: {terms: 67, types: 121, coercions: 6, joins: 0/3}
Data.Data.$fDataPar1_$cgmapMo
  :: forall p.
     Data p =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Par1 p -> m (Par1 p)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 590 0}]
Data.Data.$fDataPar1_$cgmapMo
  = \ (@ p_Xe4m1)
      ($dData_Xe4m3 :: Data p_Xe4m1)
      (@ (m_ae3Gw :: * -> *))
      ($dMonadPlus_ae3Gy :: MonadPlus m_ae3Gw)
      (ds_de7v1 :: forall d. Data d => d -> m_ae3Gw d)
      (eta_XLS :: Par1 p_Xe4m1) ->
      let {
        lvl270_se9QD :: m_ae3Gw (Par1 p_Xe4m1)
        [LclId]
        lvl270_se9QD
          = mzero @ m_ae3Gw $dMonadPlus_ae3Gy @ (Par1 p_Xe4m1) } in
      let {
        $dMonad_se9ql [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae3Gw
        [LclId]
        $dMonad_se9ql
          = GHC.Base.$p2MonadPlus @ m_ae3Gw $dMonadPlus_ae3Gy } in
      >>=
        @ m_ae3Gw
        $dMonad_se9ql
        @ (Par1 p_Xe4m1, Bool)
        @ (Par1 p_Xe4m1)
        (let {
           lvl271_se9QC :: m_ae3Gw p_Xe4m1
           [LclId]
           lvl271_se9QC
             = ds_de7v1
                 @ p_Xe4m1
                 $dData_Xe4m3
                 (eta_XLS
                  `cast` (GHC.Generics.N:Par1[0] <p_Xe4m1>_R
                          :: (Par1 p_Xe4m1 :: *) ~R# (p_Xe4m1 :: *))) } in
         >>=
           @ m_ae3Gw
           $dMonad_se9ql
           @ (p_Xe4m1 -> Par1 p_Xe4m1, Bool)
           @ (Par1 p_Xe4m1, Bool)
           (return
              @ m_ae3Gw
              $dMonad_se9ql
              @ (p_Xe4m1 -> Par1 p_Xe4m1, Bool)
              (Data.Data.$fDataPar2 @ p_Xe4m1))
           (\ (ds1_de7pD :: (p_Xe4m1 -> Par1 p_Xe4m1, Bool)) ->
              case ds1_de7pD of { (h_ae1TP, b_ae1TQ) ->
              case b_ae1TQ of {
                False ->
                  mplus
                    @ m_ae3Gw
                    $dMonadPlus_ae3Gy
                    @ (Par1 p_Xe4m1, Bool)
                    (>>=
                       @ m_ae3Gw
                       $dMonad_se9ql
                       @ p_Xe4m1
                       @ (Par1 p_Xe4m1, Bool)
                       lvl271_se9QC
                       (\ (y'_ae1TR :: p_Xe4m1) ->
                          return
                            @ m_ae3Gw
                            $dMonad_se9ql
                            @ (Par1 p_Xe4m1, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_ae3Gw
                       $dMonad_se9ql
                       @ (Par1 p_Xe4m1, Bool)
                       (h_ae1TP
                          (eta_XLS
                           `cast` (GHC.Generics.N:Par1[0] <p_Xe4m1>_R
                                   :: (Par1 p_Xe4m1 :: *) ~R# (p_Xe4m1 :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_ae3Gw
                    $dMonad_se9ql
                    @ (Par1 p_Xe4m1, Bool)
                    (h_ae1TP
                       (eta_XLS
                        `cast` (GHC.Generics.N:Par1[0] <p_Xe4m1>_R
                                :: (Par1 p_Xe4m1 :: *) ~R# (p_Xe4m1 :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds1_de7pa :: (Par1 p_Xe4m1, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9QD;
             True -> return @ m_ae3Gw $dMonad_se9ql @ (Par1 p_Xe4m1) x'_ae1TS
           }
           })

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl192_rejT0 :: forall p. Par1 p -> Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl192_rejT0 = \ (@ p_Xe4m0) _ [Occ=Dead] -> Data.Data.$cPar1

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl193_rejT1 :: forall p. Par1 p -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl193_rejT1 = \ (@ p_Xe4m0) _ [Occ=Dead] -> Data.Data.$tPar1

-- RHS size: {terms: 6, types: 35, coercions: 0, joins: 0/0}
lvl194_rejT2
  :: forall p (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c (Par1 p))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl194_rejT2
  = \ (@ p_Xe4m0)
      (@ (t_ae3Es :: * -> * -> *))
      (@ (c_ae3Et :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae3Et (Par1 p_Xe4m0))

-- RHS size: {terms: 63, types: 100, coercions: 32, joins: 0/0}
Data.Data.$fDataPar1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall p. Data p => Data (Par1 p)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ p_ae1X9) (v_XLP :: Data p_ae1X9) ->
       Data.Data.C:Data TYPE: Par1 p_ae1X9
                        (Data.Data.$fDataPar8 @ p_ae1X9 v_XLP)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Par1
                                                                                    p_ae1X9>_N
                                :: (Data.Typeable.Internal.TypeRep (Par1 p_ae1X9) :: *)
                                   ~R# (Typeable (Par1 p_ae1X9) :: Constraint))
                        Data.Data.$fDataPar1_$cgfoldl @ p_ae1X9 v_XLP
                        \ (@ (c_ae3DK :: * -> *))
                          (k_ae2nU [Occ=Once!]
                             :: forall b r. Data b => c_ae3DK (b -> r) -> c_ae3DK r)
                          (z_ae2nV [Occ=Once!] :: forall r. r -> c_ae3DK r)
                          _ [Occ=Dead] ->
                          k_ae2nU
                            @ p_ae1X9
                            @ (Par1 p_ae1X9)
                            v_XLP
                            (z_ae2nV
                               @ (p_ae1X9 -> Par1 p_ae1X9)
                               ((Data.Data.$fDataConst2 @ p_ae1X9)
                                `cast` (<p_ae1X9>_R ->_R Sym (GHC.Generics.N:Par1[0] <p_ae1X9>_R)
                                        :: (p_ae1X9 -> p_ae1X9 :: *)
                                           ~R# (p_ae1X9 -> Par1 p_ae1X9 :: *))))
                        \ _ [Occ=Dead] -> Data.Data.$cPar1
                        \ _ [Occ=Dead] -> Data.Data.$tPar1
                        Data.Data.$fDataPar1_$cdataCast1 @ p_ae1X9 v_XLP
                        \ (@ (t_ae3Es :: * -> * -> *))
                          (@ (c_ae3Et :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae3Et (Par1 p_ae1X9))
                        (\ (ds_de7uP [Occ=Once!] :: forall b. Data b => b -> b)
                           (x0_Xe357 [Occ=Once] :: Par1 p_ae1X9) ->
                           ds_de7uP
                             @ p_ae1X9
                             v_XLP
                             (x0_Xe357
                              `cast` (GHC.Generics.N:Par1[0] <p_ae1X9>_R
                                      :: (Par1 p_ae1X9 :: *) ~R# (p_ae1X9 :: *))))
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <Par1 p_ae1X9>_R
                                ->_R Sym (GHC.Generics.N:Par1[0] <p_ae1X9>_R)
                                :: ((forall b. Data b => b -> b) -> Par1 p_ae1X9 -> p_ae1X9 :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> Par1 p_ae1X9 -> Par1 p_ae1X9 :: *))
                        \ (@ r_ae3F0)
                          (@ r'_ae3F1)
                          (ds_de7uQ [Occ=Once!] :: r_ae3F0 -> r'_ae3F1 -> r_ae3F0)
                          (ds1_de7uR [Occ=Once] :: r_ae3F0)
                          (ds2_de7uS [Occ=Once!] :: forall d. Data d => d -> r'_ae3F1)
                          (eta_X1xK [Occ=Once] :: Par1 p_ae1X9) ->
                          ds_de7uQ
                            ds1_de7uR
                            (ds2_de7uS
                               @ p_ae1X9
                               v_XLP
                               (eta_X1xK
                                `cast` (GHC.Generics.N:Par1[0] <p_ae1X9>_R
                                        :: (Par1 p_ae1X9 :: *) ~R# (p_ae1X9 :: *))))
                        \ (@ r_ae3Fh)
                          (@ r'_ae3Fi)
                          (ds_de7uT [Occ=Once!] :: r'_ae3Fi -> r_ae3Fh -> r_ae3Fh)
                          (ds1_de7uU [Occ=Once] :: r_ae3Fh)
                          (ds2_de7uV [Occ=Once!] :: forall d. Data d => d -> r'_ae3Fi)
                          (x0_ae1SX [Occ=Once] :: Par1 p_ae1X9) ->
                          ds_de7uT
                            (ds2_de7uV
                               @ p_ae1X9
                               v_XLP
                               (x0_ae1SX
                                `cast` (GHC.Generics.N:Par1[0] <p_ae1X9>_R
                                        :: (Par1 p_ae1X9 :: *) ~R# (p_ae1X9 :: *))))
                            ds1_de7uU
                        \ (@ u_ae3Fy)
                          (ds_de7uW [Occ=Once!] :: forall d. Data d => d -> u_ae3Fy)
                          (x0_ae1SX [Occ=Once] :: Par1 p_ae1X9) ->
                          GHC.Types.:
                            @ u_ae3Fy
                            (ds_de7uW
                               @ p_ae1X9
                               v_XLP
                               (x0_ae1SX
                                `cast` (GHC.Generics.N:Par1[0] <p_ae1X9>_R
                                        :: (Par1 p_ae1X9 :: *) ~R# (p_ae1X9 :: *))))
                            (GHC.Types.[] @ u_ae3Fy)
                        Data.Data.$fDataPar1_$cgmapQi @ p_ae1X9 v_XLP
                        Data.Data.$fDataPar1_$cgmapM @ p_ae1X9 v_XLP
                        Data.Data.$fDataPar1_$cgmapMp @ p_ae1X9 v_XLP
                        Data.Data.$fDataPar1_$cgmapMo @ p_ae1X9 v_XLP]
Data.Data.$fDataPar1
  = \ (@ p_Xe4m0) ($dData_Xe57Q :: Data p_Xe4m0) ->
      Data.Data.C:Data
        @ (Par1 p_Xe4m0)
        ((Data.Data.$fDataPar8 @ p_Xe4m0 $dData_Xe57Q)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Par1
                                                                     p_Xe4m0>_N
                 :: (Data.Typeable.Internal.TypeRep (Par1 p_Xe4m0) :: *)
                    ~R# (Typeable (Par1 p_Xe4m0) :: Constraint)))
        (Data.Data.$fDataPar1_$cgfoldl @ p_Xe4m0 $dData_Xe57Q)
        (\ (@ (c_ae3DK :: * -> *))
           (k_ae2nU :: forall b r. Data b => c_ae3DK (b -> r) -> c_ae3DK r)
           (z_ae2nV :: forall r. r -> c_ae3DK r)
           _ [Occ=Dead] ->
           k_ae2nU
             @ p_Xe4m0
             @ (Par1 p_Xe4m0)
             $dData_Xe57Q
             (z_ae2nV
                @ (p_Xe4m0 -> Par1 p_Xe4m0)
                ((Data.Data.$fDataConst2 @ p_Xe4m0)
                 `cast` (<p_Xe4m0>_R ->_R Sym (GHC.Generics.N:Par1[0] <p_Xe4m0>_R)
                         :: (p_Xe4m0 -> p_Xe4m0 :: *) ~R# (p_Xe4m0 -> Par1 p_Xe4m0 :: *)))))
        (lvl192_rejT0 @ p_Xe4m0)
        (lvl193_rejT1 @ p_Xe4m0)
        (Data.Data.$fDataPar1_$cdataCast1 @ p_Xe4m0 $dData_Xe57Q)
        (lvl194_rejT2 @ p_Xe4m0)
        ((\ (ds_de7uP :: forall b. Data b => b -> b)
            (x0_Xe357 :: Par1 p_Xe4m0) ->
            ds_de7uP
              @ p_Xe4m0
              $dData_Xe57Q
              (x0_Xe357
               `cast` (GHC.Generics.N:Par1[0] <p_Xe4m0>_R
                       :: (Par1 p_Xe4m0 :: *) ~R# (p_Xe4m0 :: *))))
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <Par1 p_Xe4m0>_R
                 ->_R Sym (GHC.Generics.N:Par1[0] <p_Xe4m0>_R)
                 :: ((forall b. Data b => b -> b) -> Par1 p_Xe4m0 -> p_Xe4m0 :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> Par1 p_Xe4m0 -> Par1 p_Xe4m0 :: *)))
        (\ (@ r_ae3F0)
           (@ r'_ae3F1)
           (ds_de7uQ :: r_ae3F0 -> r'_ae3F1 -> r_ae3F0)
           (ds1_de7uR :: r_ae3F0)
           (ds2_de7uS :: forall d. Data d => d -> r'_ae3F1)
           (eta_XLP :: Par1 p_Xe4m0) ->
           ds_de7uQ
             ds1_de7uR
             (ds2_de7uS
                @ p_Xe4m0
                $dData_Xe57Q
                (eta_XLP
                 `cast` (GHC.Generics.N:Par1[0] <p_Xe4m0>_R
                         :: (Par1 p_Xe4m0 :: *) ~R# (p_Xe4m0 :: *)))))
        (\ (@ r_ae3Fh)
           (@ r'_ae3Fi)
           (ds_de7uT :: r'_ae3Fi -> r_ae3Fh -> r_ae3Fh)
           (ds1_de7uU :: r_ae3Fh)
           (ds2_de7uV :: forall d. Data d => d -> r'_ae3Fi)
           (x0_ae1SX :: Par1 p_Xe4m0) ->
           ds_de7uT
             (ds2_de7uV
                @ p_Xe4m0
                $dData_Xe57Q
                (x0_ae1SX
                 `cast` (GHC.Generics.N:Par1[0] <p_Xe4m0>_R
                         :: (Par1 p_Xe4m0 :: *) ~R# (p_Xe4m0 :: *))))
             ds1_de7uU)
        (\ (@ u_ae3Fy)
           (ds_de7uW :: forall d. Data d => d -> u_ae3Fy)
           (x0_ae1SX :: Par1 p_Xe4m0) ->
           GHC.Types.:
             @ u_ae3Fy
             (ds_de7uW
                @ p_Xe4m0
                $dData_Xe57Q
                (x0_ae1SX
                 `cast` (GHC.Generics.N:Par1[0] <p_Xe4m0>_R
                         :: (Par1 p_Xe4m0 :: *) ~R# (p_Xe4m0 :: *))))
             (GHC.Types.[] @ u_ae3Fy))
        (Data.Data.$fDataPar1_$cgmapQi @ p_Xe4m0 $dData_Xe57Q)
        (Data.Data.$fDataPar1_$cgmapM @ p_Xe4m0 $dData_Xe57Q)
        (Data.Data.$fDataPar1_$cgmapMp @ p_Xe4m0 $dData_Xe57Q)
        (Data.Data.$fDataPar1_$cgmapMo @ p_Xe4m0 $dData_Xe57Q)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataRec6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataRec6 = "Rec1"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataRec5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataRec5 = unpackCString# Data.Data.$fDataRec6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$cRec2_rejT3 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$cRec2_rejT3 = "unRec1"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cRec3_rejT4 :: [Char]
[GblId]
$cRec3_rejT4 = unpackCString# $cRec2_rejT3

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$cRec4_rejT5 :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cRec4_rejT5
  = GHC.Types.: @ String $cRec3_rejT4 (GHC.Types.[] @ String)

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go37_rejT6 :: [Constr] -> [Int] -> Int
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go37_rejT6
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fDataRec5 of {
                False -> go37_rejT6 ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cRec5_rejT7 :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cRec5_rejT7 = Data.Data.AlgConstr $cRec6_rejT8

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataRec4 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataRec4
  = GHC.Types.: @ Constr Data.Data.$cRec1 (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataRec3 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataRec3 = Data.Data.AlgRep Data.Data.$fDataRec4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tRec1 :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$tRec1
  = Data.Data.DataType Data.Data.$fDataRec5 Data.Data.$fDataRec3

-- RHS size: {terms: 6, types: 0, coercions: 0, joins: 0/0}
Data.Data.$cRec1 [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cRec1
  = Data.Data.Constr
      $cRec5_rejT7
      Data.Data.$fDataRec5
      $cRec4_rejT5
      Data.Data.Prefix
      Data.Data.$tRec1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cRec6_rejT8 :: Int
[GblId]
$cRec6_rejT8 = go37_rejT6 Data.Data.$fDataRec4 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 5, types: 16, coercions: 9, joins: 0/0}
Data.Data.$fDataRec2
  :: forall (f :: * -> *) p. (f p -> Rec1 f p, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataRec2
  = \ (@ (f_Xe4j4 :: * -> *)) (@ p_Xe4j6) ->
      ((Data.Data.$fDataAlt2 @ f_Xe4j4 @ p_Xe4j6)
       `cast` (<f_Xe4j4 p_Xe4j6>_R
               ->_R Sym (GHC.Generics.N:Rec1[0] <*>_N <f_Xe4j4>_R) <p_Xe4j6>_N
               :: (f_Xe4j4 p_Xe4j6 -> f_Xe4j4 p_Xe4j6 :: *)
                  ~R# (f_Xe4j4 p_Xe4j6 -> Rec1 f_Xe4j4 p_Xe4j6 :: *)),
       GHC.Types.False)

-- RHS size: {terms: 58, types: 190, coercions: 10, joins: 0/3}
Data.Data.$w$cgmapMp29 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) p.
     Data (f p) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Rec1 f p -> m (Rec1 f p)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 510 0}]
Data.Data.$w$cgmapMp29
  = \ (@ (f_seguo :: * -> *))
      (@ p_segup)
      (w_seguq :: Data (f_seguo p_segup))
      (@ (m_segut :: * -> *))
      (w1_seguu :: MonadPlus m_segut)
      (w2_seguv :: forall d. Data d => d -> m_segut d)
      (w3_seguw :: Rec1 f_seguo p_segup) ->
      let {
        lvl270_se9QV :: m_segut (Rec1 f_seguo p_segup)
        [LclId]
        lvl270_se9QV
          = mzero @ m_segut w1_seguu @ (Rec1 f_seguo p_segup) } in
      let {
        $dMonad_se9qj [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_segut
        [LclId]
        $dMonad_se9qj = GHC.Base.$p2MonadPlus @ m_segut w1_seguu } in
      >>=
        @ m_segut
        $dMonad_se9qj
        @ (Rec1 f_seguo p_segup, Bool)
        @ (Rec1 f_seguo p_segup)
        (let {
           lvl271_se9QU :: m_segut (f_seguo p_segup)
           [LclId]
           lvl271_se9QU
             = w2_seguv
                 @ (f_seguo p_segup)
                 w_seguq
                 (w3_seguw
                  `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_seguo>_R <p_segup>_N
                          :: (Rec1 f_seguo p_segup :: *) ~R# (f_seguo p_segup :: *))) } in
         >>=
           @ m_segut
           $dMonad_se9qj
           @ (f_seguo p_segup -> Rec1 f_seguo p_segup, Bool)
           @ (Rec1 f_seguo p_segup, Bool)
           (return
              @ m_segut
              $dMonad_se9qj
              @ (f_seguo p_segup -> Rec1 f_seguo p_segup, Bool)
              (Data.Data.$fDataRec2 @ f_seguo @ p_segup))
           (\ (ds_de7oD :: (f_seguo p_segup -> Rec1 f_seguo p_segup, Bool)) ->
              case ds_de7oD of { (h_ae1TA, b_ae1TB) ->
              mplus
                @ m_segut
                w1_seguu
                @ (Rec1 f_seguo p_segup, Bool)
                (>>=
                   @ m_segut
                   $dMonad_se9qj
                   @ (f_seguo p_segup)
                   @ (Rec1 f_seguo p_segup, Bool)
                   lvl271_se9QU
                   (\ (y'_ae1TC :: f_seguo p_segup) ->
                      return
                        @ m_segut
                        $dMonad_se9qj
                        @ (Rec1 f_seguo p_segup, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_segut
                   $dMonad_se9qj
                   @ (Rec1 f_seguo p_segup, Bool)
                   (h_ae1TA
                      (w3_seguw
                       `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_seguo>_R <p_segup>_N
                               :: (Rec1 f_seguo p_segup :: *) ~R# (f_seguo p_segup :: *))),
                    b_ae1TB))
              }))
        (\ (ds_de7oa :: (Rec1 f_seguo p_segup, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9QV;
             True ->
               return @ m_segut $dMonad_se9qj @ (Rec1 f_seguo p_segup) x'_ae1TD
           }
           })

-- RHS size: {terms: 14, types: 38, coercions: 0, joins: 0/0}
Data.Data.$fDataRec1_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) p.
     (Data (f p), Typeable f, Data p) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Rec1 f p -> m (Rec1 f p)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,A><L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (f_seguo :: * -> *))
                 (@ p_segup)
                 (w_seguq [Occ=Once] :: Data (f_seguo p_segup))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (@ (m_segut :: * -> *))
                 (w3_seguu [Occ=Once] :: MonadPlus m_segut)
                 (w4_seguv [Occ=Once] :: forall d. Data d => d -> m_segut d)
                 (w5_seguw [Occ=Once] :: Rec1 f_seguo p_segup) ->
                 Data.Data.$w$cgmapMp29
                   @ f_seguo @ p_segup w_seguq @ m_segut w3_seguu w4_seguv w5_seguw}]
Data.Data.$fDataRec1_$cgmapMp
  = \ (@ (f_seguo :: * -> *))
      (@ p_segup)
      (w_seguq :: Data (f_seguo p_segup))
      _ [Occ=Dead]
      _ [Occ=Dead]
      (@ (m_segut :: * -> *))
      (w3_seguu :: MonadPlus m_segut)
      (w4_seguv :: forall d. Data d => d -> m_segut d)
      (w5_seguw :: Rec1 f_seguo p_segup) ->
      Data.Data.$w$cgmapMp29
        @ f_seguo @ p_segup w_seguq @ m_segut w3_seguu w4_seguv w5_seguw

-- RHS size: {terms: 25, types: 78, coercions: 14, joins: 0/1}
Data.Data.$w$cgmapM15 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) p.
     Data (f p) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Rec1 f p -> m (Rec1 f p)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120 60 0] 220 0}]
Data.Data.$w$cgmapM15
  = \ (@ (f_seguy :: * -> *))
      (@ p_seguz)
      (w_seguA :: Data (f_seguy p_seguz))
      (@ (m_seguD :: * -> *))
      (w1_seguE :: Monad m_seguD)
      (w2_seguF :: forall d. Data d => d -> m_seguD d)
      (w3_seguG :: Rec1 f_seguy p_seguz) ->
      let {
        lvl270_se9QX :: m_seguD (f_seguy p_seguz)
        [LclId]
        lvl270_se9QX
          = w2_seguF
              @ (f_seguy p_seguz)
              w_seguA
              (w3_seguG
               `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_seguy>_R <p_seguz>_N
                       :: (Rec1 f_seguy p_seguz :: *) ~R# (f_seguy p_seguz :: *))) } in
      >>=
        @ m_seguD
        w1_seguE
        @ (f_seguy p_seguz -> Rec1 f_seguy p_seguz)
        @ (Rec1 f_seguy p_seguz)
        (return
           @ m_seguD
           w1_seguE
           @ (f_seguy p_seguz -> Rec1 f_seguy p_seguz)
           ((Data.Data.$fDataAlt2 @ f_seguy @ p_seguz)
            `cast` (<f_seguy p_seguz>_R
                    ->_R Sym (GHC.Generics.N:Rec1[0] <*>_N <f_seguy>_R) <p_seguz>_N
                    :: (f_seguy p_seguz -> f_seguy p_seguz :: *)
                       ~R# (f_seguy p_seguz -> Rec1 f_seguy p_seguz :: *))))
        (\ (c'_ae1To :: f_seguy p_seguz -> Rec1 f_seguy p_seguz) ->
           >>=
             @ m_seguD
             w1_seguE
             @ (f_seguy p_seguz)
             @ (Rec1 f_seguy p_seguz)
             lvl270_se9QX
             (\ (x'_ae1Tp :: f_seguy p_seguz) ->
                return
                  @ m_seguD w1_seguE @ (Rec1 f_seguy p_seguz) (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 14, types: 38, coercions: 0, joins: 0/0}
Data.Data.$fDataRec1_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) p.
     (Data (f p), Typeable f, Data p) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Rec1 f p -> m (Rec1 f p)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,A><L,A><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (f_seguy :: * -> *))
                 (@ p_seguz)
                 (w_seguA [Occ=Once] :: Data (f_seguy p_seguz))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (@ (m_seguD :: * -> *))
                 (w3_seguE [Occ=Once] :: Monad m_seguD)
                 (w4_seguF [Occ=Once] :: forall d. Data d => d -> m_seguD d)
                 (w5_seguG [Occ=Once] :: Rec1 f_seguy p_seguz) ->
                 Data.Data.$w$cgmapM15
                   @ f_seguy @ p_seguz w_seguA @ m_seguD w3_seguE w4_seguF w5_seguG}]
Data.Data.$fDataRec1_$cgmapM
  = \ (@ (f_seguy :: * -> *))
      (@ p_seguz)
      (w_seguA :: Data (f_seguy p_seguz))
      _ [Occ=Dead]
      _ [Occ=Dead]
      (@ (m_seguD :: * -> *))
      (w3_seguE :: Monad m_seguD)
      (w4_seguF :: forall d. Data d => d -> m_seguD d)
      (w5_seguG :: Rec1 f_seguy p_seguz) ->
      Data.Data.$w$cgmapM15
        @ f_seguy @ p_seguz w_seguA @ m_seguD w3_seguE w4_seguF w5_seguG

-- RHS size: {terms: 68, types: 205, coercions: 15, joins: 0/3}
Data.Data.$w$cgmapMo28 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) p.
     Data (f p) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Rec1 f p -> m (Rec1 f p)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 590 0}]
Data.Data.$w$cgmapMo28
  = \ (@ (f_seguI :: * -> *))
      (@ p_seguJ)
      (w_seguK :: Data (f_seguI p_seguJ))
      (@ (m_seguN :: * -> *))
      (w1_seguO :: MonadPlus m_seguN)
      (w2_seguP :: forall d. Data d => d -> m_seguN d)
      (w3_seguQ :: Rec1 f_seguI p_seguJ) ->
      let {
        lvl270_se9R2 :: m_seguN (Rec1 f_seguI p_seguJ)
        [LclId]
        lvl270_se9R2
          = mzero @ m_seguN w1_seguO @ (Rec1 f_seguI p_seguJ) } in
      let {
        $dMonad_se9qh [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_seguN
        [LclId]
        $dMonad_se9qh = GHC.Base.$p2MonadPlus @ m_seguN w1_seguO } in
      >>=
        @ m_seguN
        $dMonad_se9qh
        @ (Rec1 f_seguI p_seguJ, Bool)
        @ (Rec1 f_seguI p_seguJ)
        (let {
           lvl271_se9R1 :: m_seguN (f_seguI p_seguJ)
           [LclId]
           lvl271_se9R1
             = w2_seguP
                 @ (f_seguI p_seguJ)
                 w_seguK
                 (w3_seguQ
                  `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_seguI>_R <p_seguJ>_N
                          :: (Rec1 f_seguI p_seguJ :: *) ~R# (f_seguI p_seguJ :: *))) } in
         >>=
           @ m_seguN
           $dMonad_se9qh
           @ (f_seguI p_seguJ -> Rec1 f_seguI p_seguJ, Bool)
           @ (Rec1 f_seguI p_seguJ, Bool)
           (return
              @ m_seguN
              $dMonad_se9qh
              @ (f_seguI p_seguJ -> Rec1 f_seguI p_seguJ, Bool)
              (Data.Data.$fDataRec2 @ f_seguI @ p_seguJ))
           (\ (ds_de7pD :: (f_seguI p_seguJ -> Rec1 f_seguI p_seguJ, Bool)) ->
              case ds_de7pD of { (h_ae1TP, b_ae1TQ) ->
              case b_ae1TQ of {
                False ->
                  mplus
                    @ m_seguN
                    w1_seguO
                    @ (Rec1 f_seguI p_seguJ, Bool)
                    (>>=
                       @ m_seguN
                       $dMonad_se9qh
                       @ (f_seguI p_seguJ)
                       @ (Rec1 f_seguI p_seguJ, Bool)
                       lvl271_se9R1
                       (\ (y'_ae1TR :: f_seguI p_seguJ) ->
                          return
                            @ m_seguN
                            $dMonad_se9qh
                            @ (Rec1 f_seguI p_seguJ, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_seguN
                       $dMonad_se9qh
                       @ (Rec1 f_seguI p_seguJ, Bool)
                       (h_ae1TP
                          (w3_seguQ
                           `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_seguI>_R <p_seguJ>_N
                                   :: (Rec1 f_seguI p_seguJ :: *) ~R# (f_seguI p_seguJ :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_seguN
                    $dMonad_se9qh
                    @ (Rec1 f_seguI p_seguJ, Bool)
                    (h_ae1TP
                       (w3_seguQ
                        `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_seguI>_R <p_seguJ>_N
                                :: (Rec1 f_seguI p_seguJ :: *) ~R# (f_seguI p_seguJ :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds_de7pa :: (Rec1 f_seguI p_seguJ, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9R2;
             True ->
               return @ m_seguN $dMonad_se9qh @ (Rec1 f_seguI p_seguJ) x'_ae1TS
           }
           })

-- RHS size: {terms: 14, types: 38, coercions: 0, joins: 0/0}
Data.Data.$fDataRec1_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) p.
     (Data (f p), Typeable f, Data p) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Rec1 f p -> m (Rec1 f p)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,A><L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (f_seguI :: * -> *))
                 (@ p_seguJ)
                 (w_seguK [Occ=Once] :: Data (f_seguI p_seguJ))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (@ (m_seguN :: * -> *))
                 (w3_seguO [Occ=Once] :: MonadPlus m_seguN)
                 (w4_seguP [Occ=Once] :: forall d. Data d => d -> m_seguN d)
                 (w5_seguQ [Occ=Once] :: Rec1 f_seguI p_seguJ) ->
                 Data.Data.$w$cgmapMo28
                   @ f_seguI @ p_seguJ w_seguK @ m_seguN w3_seguO w4_seguP w5_seguQ}]
Data.Data.$fDataRec1_$cgmapMo
  = \ (@ (f_seguI :: * -> *))
      (@ p_seguJ)
      (w_seguK :: Data (f_seguI p_seguJ))
      _ [Occ=Dead]
      _ [Occ=Dead]
      (@ (m_seguN :: * -> *))
      (w3_seguO :: MonadPlus m_seguN)
      (w4_seguP :: forall d. Data d => d -> m_seguN d)
      (w5_seguQ :: Rec1 f_seguI p_seguJ) ->
      Data.Data.$w$cgmapMo28
        @ f_seguI @ p_seguJ w_seguK @ m_seguN w3_seguO w4_seguP w5_seguQ

-- RHS size: {terms: 4, types: 11, coercions: 0, joins: 0/0}
lvl195_rejT9 :: forall (f :: * -> *) p. Rec1 f p -> Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl195_rejT9
  = \ (@ (f_Xe4iV :: * -> *)) (@ p_Xe4iX) _ [Occ=Dead] ->
      Data.Data.$cRec1

-- RHS size: {terms: 4, types: 11, coercions: 0, joins: 0/0}
lvl196_rejTa :: forall (f :: * -> *) p. Rec1 f p -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl196_rejTa
  = \ (@ (f_Xe4iV :: * -> *)) (@ p_Xe4iX) _ [Occ=Dead] ->
      Data.Data.$tRec1

-- RHS size: {terms: 7, types: 33, coercions: 0, joins: 0/0}
lvl197_rejTb
  :: forall (f :: * -> *) p (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Rec1 f p))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl197_rejTb
  = \ (@ (f_Xe4iV :: * -> *))
      (@ p_Xe4iX)
      (@ (t_ae3AO :: * -> *))
      (@ (c_ae3AP :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae3AP (Rec1 f_Xe4iV p_Xe4iX))

-- RHS size: {terms: 7, types: 42, coercions: 0, joins: 0/0}
lvl198_rejTc
  :: forall (f :: * -> *) p (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c (Rec1 f p))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl198_rejTc
  = \ (@ (f_Xe4iV :: * -> *))
      (@ p_Xe4iX)
      (@ (t_ae3B7 :: * -> * -> *))
      (@ (c_ae3B8 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae3B8 (Rec1 f_Xe4iV p_Xe4iX))

-- RHS size: {terms: 108, types: 266, coercions: 76, joins: 0/0}
Data.Data.$fDataRec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) p.
     (Data (f p), Typeable f, Data p) =>
     Data (Rec1 f p)
[GblId[DFunId],
 Arity=3,
 Str=<L,U><L,U><L,1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=DFun: \ (@ (f_ae1X7 :: * -> *))
             (@ p_ae1X8)
             (v_XMc :: Data (f_ae1X7 p_ae1X8))
             (v1_XMe :: Typeable f_ae1X7)
             (v2_XMg :: Data p_ae1X8) ->
       Data.Data.C:Data TYPE: Rec1 f_ae1X7 p_ae1X8
                        (Data.Data.$fDataRec7 @ f_ae1X7 @ p_ae1X8 v_XMc v1_XMe v2_XMg)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Rec1
                                                                                    f_ae1X7
                                                                                    p_ae1X8>_N
                                :: (Data.Typeable.Internal.TypeRep (Rec1 f_ae1X7 p_ae1X8) :: *)
                                   ~R# (Typeable (Rec1 f_ae1X7 p_ae1X8) :: Constraint))
                        \ (@ (c_ae3Ag :: * -> *))
                          (k_ae2nM [Occ=Once!]
                             :: forall d b. Data d => c_ae3Ag (d -> b) -> d -> c_ae3Ag b)
                          (z_ae2nN [Occ=Once!] :: forall g. g -> c_ae3Ag g)
                          (ds_de7uc [Occ=Once] :: Rec1 f_ae1X7 p_ae1X8) ->
                          k_ae2nM
                            @ (f_ae1X7 p_ae1X8)
                            @ (Rec1 f_ae1X7 p_ae1X8)
                            v_XMc
                            (z_ae2nN
                               @ (f_ae1X7 p_ae1X8 -> Rec1 f_ae1X7 p_ae1X8)
                               ((\ (v3_XJ2 [Occ=Once] :: f_ae1X7 p_ae1X8) -> v3_XJ2)
                                `cast` (<f_ae1X7 p_ae1X8>_R
                                        ->_R Sym (GHC.Generics.N:Rec1[0]
                                                      <*>_N <f_ae1X7>_R) <p_ae1X8>_N
                                        :: (f_ae1X7 p_ae1X8 -> f_ae1X7 p_ae1X8 :: *)
                                           ~R# (f_ae1X7 p_ae1X8 -> Rec1 f_ae1X7 p_ae1X8 :: *))))
                            (ds_de7uc
                             `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_ae1X7>_R <p_ae1X8>_N
                                     :: (Rec1 f_ae1X7 p_ae1X8 :: *) ~R# (f_ae1X7 p_ae1X8 :: *)))
                        \ (@ (c_ae3At :: * -> *))
                          (k_ae2nP [Occ=Once!]
                             :: forall b r. Data b => c_ae3At (b -> r) -> c_ae3At r)
                          (z_ae2nQ [Occ=Once!] :: forall r. r -> c_ae3At r)
                          _ [Occ=Dead] ->
                          k_ae2nP
                            @ (f_ae1X7 p_ae1X8)
                            @ (Rec1 f_ae1X7 p_ae1X8)
                            v_XMc
                            (z_ae2nQ
                               @ (f_ae1X7 p_ae1X8 -> Rec1 f_ae1X7 p_ae1X8)
                               ((\ (v3_XJ2 [Occ=Once] :: f_ae1X7 p_ae1X8) -> v3_XJ2)
                                `cast` (<f_ae1X7 p_ae1X8>_R
                                        ->_R Sym (GHC.Generics.N:Rec1[0]
                                                      <*>_N <f_ae1X7>_R) <p_ae1X8>_N
                                        :: (f_ae1X7 p_ae1X8 -> f_ae1X7 p_ae1X8 :: *)
                                           ~R# (f_ae1X7 p_ae1X8 -> Rec1 f_ae1X7 p_ae1X8 :: *))))
                        \ _ [Occ=Dead] -> Data.Data.$cRec1
                        \ _ [Occ=Dead] -> Data.Data.$tRec1
                        \ (@ (t_ae3AO :: * -> *))
                          (@ (c_ae3AP :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae3AP (Rec1 f_ae1X7 p_ae1X8))
                        \ (@ (t_ae3B7 :: * -> * -> *))
                          (@ (c_ae3B8 :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae3B8 (Rec1 f_ae1X7 p_ae1X8))
                        (\ (ds_de7uj [Occ=Once!] :: forall b. Data b => b -> b)
                           (x0_Xe35s [Occ=Once] :: Rec1 f_ae1X7 p_ae1X8) ->
                           ds_de7uj
                             @ (f_ae1X7 p_ae1X8)
                             v_XMc
                             (x0_Xe35s
                              `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_ae1X7>_R <p_ae1X8>_N
                                      :: (Rec1 f_ae1X7 p_ae1X8 :: *) ~R# (f_ae1X7 p_ae1X8 :: *))))
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <Rec1 f_ae1X7 p_ae1X8>_R
                                ->_R Sym (GHC.Generics.N:Rec1[0] <*>_N <f_ae1X7>_R) <p_ae1X8>_N
                                :: ((forall b. Data b => b -> b)
                                    -> Rec1 f_ae1X7 p_ae1X8 -> f_ae1X7 p_ae1X8 :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> Rec1 f_ae1X7 p_ae1X8 -> Rec1 f_ae1X7 p_ae1X8 :: *))
                        \ (@ r_ae3BF)
                          (@ r'_ae3BG)
                          (ds_de7uk [Occ=Once!] :: r_ae3BF -> r'_ae3BG -> r_ae3BF)
                          (ds1_de7ul [Occ=Once] :: r_ae3BF)
                          (ds2_de7um [Occ=Once!] :: forall d. Data d => d -> r'_ae3BG)
                          (eta_XMa [Occ=Once] :: Rec1 f_ae1X7 p_ae1X8) ->
                          ds_de7uk
                            ds1_de7ul
                            (ds2_de7um
                               @ (f_ae1X7 p_ae1X8)
                               v_XMc
                               (eta_XMa
                                `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_ae1X7>_R <p_ae1X8>_N
                                        :: (Rec1 f_ae1X7 p_ae1X8 :: *) ~R# (f_ae1X7 p_ae1X8 :: *))))
                        \ (@ r_ae3BW)
                          (@ r'_ae3BX)
                          (ds_de7un [Occ=Once!] :: r'_ae3BX -> r_ae3BW -> r_ae3BW)
                          (ds1_de7uo [Occ=Once] :: r_ae3BW)
                          (ds2_de7up [Occ=Once!] :: forall d. Data d => d -> r'_ae3BX)
                          (x0_ae1SX [Occ=Once] :: Rec1 f_ae1X7 p_ae1X8) ->
                          ds_de7un
                            (ds2_de7up
                               @ (f_ae1X7 p_ae1X8)
                               v_XMc
                               (x0_ae1SX
                                `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_ae1X7>_R <p_ae1X8>_N
                                        :: (Rec1 f_ae1X7 p_ae1X8 :: *) ~R# (f_ae1X7 p_ae1X8 :: *))))
                            ds1_de7uo
                        \ (@ u_ae3Cd)
                          (ds_de7uq [Occ=Once!] :: forall d. Data d => d -> u_ae3Cd)
                          (x0_ae1SX [Occ=Once] :: Rec1 f_ae1X7 p_ae1X8) ->
                          GHC.Types.:
                            @ u_ae3Cd
                            (ds_de7uq
                               @ (f_ae1X7 p_ae1X8)
                               v_XMc
                               (x0_ae1SX
                                `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_ae1X7>_R <p_ae1X8>_N
                                        :: (Rec1 f_ae1X7 p_ae1X8 :: *) ~R# (f_ae1X7 p_ae1X8 :: *))))
                            (GHC.Types.[] @ u_ae3Cd)
                        \ (@ u_ae3Cr)
                          (ds_de7ur [Occ=Once!] :: Int)
                          (ds1_de7us [Occ=Once!] :: forall d. Data d => d -> u_ae3Cr)
                          (x_ae1T7 [Occ=Once] :: Rec1 f_ae1X7 p_ae1X8) ->
                          case ds_de7ur of { I# x1_a22G [Occ=Once!] ->
                          case x1_a22G of {
                            __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3Cr;
                            0# ->
                              ds1_de7us
                                @ (f_ae1X7 p_ae1X8)
                                v_XMc
                                (x_ae1T7
                                 `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_ae1X7>_R <p_ae1X8>_N
                                         :: (Rec1 f_ae1X7 p_ae1X8 :: *) ~R# (f_ae1X7 p_ae1X8 :: *)))
                          }
                          }
                        Data.Data.$fDataRec1_$cgmapM
                          @ f_ae1X7 @ p_ae1X8 v_XMc v1_XMe v2_XMg
                        Data.Data.$fDataRec1_$cgmapMp
                          @ f_ae1X7 @ p_ae1X8 v_XMc v1_XMe v2_XMg
                        Data.Data.$fDataRec1_$cgmapMo
                          @ f_ae1X7 @ p_ae1X8 v_XMc v1_XMe v2_XMg]
Data.Data.$fDataRec1
  = \ (@ (f_Xe4iV :: * -> *))
      (@ p_Xe4iX)
      ($dData_Xe4iZ :: Data (f_Xe4iV p_Xe4iX))
      ($dTypeable_Xe4j1 :: Typeable f_Xe4iV)
      ($dData1_Xe4j3 :: Data p_Xe4iX) ->
      Data.Data.C:Data
        @ (Rec1 f_Xe4iV p_Xe4iX)
        ((Data.Data.$fDataRec7
            @ f_Xe4iV @ p_Xe4iX $dData_Xe4iZ $dTypeable_Xe4j1 $dData1_Xe4j3)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Rec1
                                                                     f_Xe4iV p_Xe4iX>_N
                 :: (Data.Typeable.Internal.TypeRep (Rec1 f_Xe4iV p_Xe4iX) :: *)
                    ~R# (Typeable (Rec1 f_Xe4iV p_Xe4iX) :: Constraint)))
        (\ (@ (c_ae3Ag :: * -> *))
           (k_ae2nM
              :: forall d b. Data d => c_ae3Ag (d -> b) -> d -> c_ae3Ag b)
           (z_ae2nN :: forall g. g -> c_ae3Ag g)
           (ds_de7uc :: Rec1 f_Xe4iV p_Xe4iX) ->
           k_ae2nM
             @ (f_Xe4iV p_Xe4iX)
             @ (Rec1 f_Xe4iV p_Xe4iX)
             $dData_Xe4iZ
             (z_ae2nN
                @ (f_Xe4iV p_Xe4iX -> Rec1 f_Xe4iV p_Xe4iX)
                ((Data.Data.$fDataAlt2 @ f_Xe4iV @ p_Xe4iX)
                 `cast` (<f_Xe4iV p_Xe4iX>_R
                         ->_R Sym (GHC.Generics.N:Rec1[0] <*>_N <f_Xe4iV>_R) <p_Xe4iX>_N
                         :: (f_Xe4iV p_Xe4iX -> f_Xe4iV p_Xe4iX :: *)
                            ~R# (f_Xe4iV p_Xe4iX -> Rec1 f_Xe4iV p_Xe4iX :: *))))
             (ds_de7uc
              `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_Xe4iV>_R <p_Xe4iX>_N
                      :: (Rec1 f_Xe4iV p_Xe4iX :: *) ~R# (f_Xe4iV p_Xe4iX :: *))))
        (\ (@ (c_ae3At :: * -> *))
           (k_ae2nP :: forall b r. Data b => c_ae3At (b -> r) -> c_ae3At r)
           (z_ae2nQ :: forall r. r -> c_ae3At r)
           _ [Occ=Dead] ->
           k_ae2nP
             @ (f_Xe4iV p_Xe4iX)
             @ (Rec1 f_Xe4iV p_Xe4iX)
             $dData_Xe4iZ
             (z_ae2nQ
                @ (f_Xe4iV p_Xe4iX -> Rec1 f_Xe4iV p_Xe4iX)
                ((Data.Data.$fDataAlt2 @ f_Xe4iV @ p_Xe4iX)
                 `cast` (<f_Xe4iV p_Xe4iX>_R
                         ->_R Sym (GHC.Generics.N:Rec1[0] <*>_N <f_Xe4iV>_R) <p_Xe4iX>_N
                         :: (f_Xe4iV p_Xe4iX -> f_Xe4iV p_Xe4iX :: *)
                            ~R# (f_Xe4iV p_Xe4iX -> Rec1 f_Xe4iV p_Xe4iX :: *)))))
        (lvl195_rejT9 @ f_Xe4iV @ p_Xe4iX)
        (lvl196_rejTa @ f_Xe4iV @ p_Xe4iX)
        (lvl197_rejTb @ f_Xe4iV @ p_Xe4iX)
        (lvl198_rejTc @ f_Xe4iV @ p_Xe4iX)
        ((\ (ds_de7uj :: forall b. Data b => b -> b)
            (x0_Xe35s :: Rec1 f_Xe4iV p_Xe4iX) ->
            ds_de7uj
              @ (f_Xe4iV p_Xe4iX)
              $dData_Xe4iZ
              (x0_Xe35s
               `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_Xe4iV>_R <p_Xe4iX>_N
                       :: (Rec1 f_Xe4iV p_Xe4iX :: *) ~R# (f_Xe4iV p_Xe4iX :: *))))
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <Rec1 f_Xe4iV p_Xe4iX>_R
                 ->_R Sym (GHC.Generics.N:Rec1[0] <*>_N <f_Xe4iV>_R) <p_Xe4iX>_N
                 :: ((forall b. Data b => b -> b)
                     -> Rec1 f_Xe4iV p_Xe4iX -> f_Xe4iV p_Xe4iX :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> Rec1 f_Xe4iV p_Xe4iX -> Rec1 f_Xe4iV p_Xe4iX :: *)))
        (\ (@ r_ae3BF)
           (@ r'_ae3BG)
           (ds_de7uk :: r_ae3BF -> r'_ae3BG -> r_ae3BF)
           (ds1_de7ul :: r_ae3BF)
           (ds2_de7um :: forall d. Data d => d -> r'_ae3BG)
           (eta_XMa :: Rec1 f_Xe4iV p_Xe4iX) ->
           ds_de7uk
             ds1_de7ul
             (ds2_de7um
                @ (f_Xe4iV p_Xe4iX)
                $dData_Xe4iZ
                (eta_XMa
                 `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_Xe4iV>_R <p_Xe4iX>_N
                         :: (Rec1 f_Xe4iV p_Xe4iX :: *) ~R# (f_Xe4iV p_Xe4iX :: *)))))
        (\ (@ r_ae3BW)
           (@ r'_ae3BX)
           (ds_de7un :: r'_ae3BX -> r_ae3BW -> r_ae3BW)
           (ds1_de7uo :: r_ae3BW)
           (ds2_de7up :: forall d. Data d => d -> r'_ae3BX)
           (x0_ae1SX :: Rec1 f_Xe4iV p_Xe4iX) ->
           ds_de7un
             (ds2_de7up
                @ (f_Xe4iV p_Xe4iX)
                $dData_Xe4iZ
                (x0_ae1SX
                 `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_Xe4iV>_R <p_Xe4iX>_N
                         :: (Rec1 f_Xe4iV p_Xe4iX :: *) ~R# (f_Xe4iV p_Xe4iX :: *))))
             ds1_de7uo)
        (\ (@ u_ae3Cd)
           (ds_de7uq :: forall d. Data d => d -> u_ae3Cd)
           (x0_ae1SX :: Rec1 f_Xe4iV p_Xe4iX) ->
           GHC.Types.:
             @ u_ae3Cd
             (ds_de7uq
                @ (f_Xe4iV p_Xe4iX)
                $dData_Xe4iZ
                (x0_ae1SX
                 `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_Xe4iV>_R <p_Xe4iX>_N
                         :: (Rec1 f_Xe4iV p_Xe4iX :: *) ~R# (f_Xe4iV p_Xe4iX :: *))))
             (GHC.Types.[] @ u_ae3Cd))
        (\ (@ u_ae3Cr)
           (ds_de7ur :: Int)
           (ds1_de7us :: forall d. Data d => d -> u_ae3Cr)
           (x_ae1T7 :: Rec1 f_Xe4iV p_Xe4iX) ->
           case ds_de7ur of { I# x1_a22G ->
           case x1_a22G of {
             __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3Cr;
             0# ->
               ds1_de7us
                 @ (f_Xe4iV p_Xe4iX)
                 $dData_Xe4iZ
                 (x_ae1T7
                  `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_Xe4iV>_R <p_Xe4iX>_N
                          :: (Rec1 f_Xe4iV p_Xe4iX :: *) ~R# (f_Xe4iV p_Xe4iX :: *)))
           }
           })
        (\ (@ (m_seguD :: * -> *))
           (w_seguE :: Monad m_seguD)
           (w1_seguF :: forall d. Data d => d -> m_seguD d)
           (w2_seguG :: Rec1 f_Xe4iV p_Xe4iX) ->
           Data.Data.$w$cgmapM15
             @ f_Xe4iV
             @ p_Xe4iX
             $dData_Xe4iZ
             @ m_seguD
             w_seguE
             w1_seguF
             w2_seguG)
        (\ (@ (m_segut :: * -> *))
           (w_seguu :: MonadPlus m_segut)
           (w1_seguv :: forall d. Data d => d -> m_segut d)
           (w2_seguw :: Rec1 f_Xe4iV p_Xe4iX) ->
           Data.Data.$w$cgmapMp29
             @ f_Xe4iV
             @ p_Xe4iX
             $dData_Xe4iZ
             @ m_segut
             w_seguu
             w1_seguv
             w2_seguw)
        (\ (@ (m_seguN :: * -> *))
           (w_seguO :: MonadPlus m_seguN)
           (w1_seguP :: forall d. Data d => d -> m_seguN d)
           (w2_seguQ :: Rec1 f_Xe4iV p_Xe4iX) ->
           Data.Data.$w$cgmapMo28
             @ f_Xe4iV
             @ p_Xe4iX
             $dData_Xe4iZ
             @ m_seguN
             w_seguO
             w1_seguP
             w2_seguQ)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataK6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataK6 = "K1"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataK5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataK5 = unpackCString# Data.Data.$fDataK6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$cK2_rejTd :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$cK2_rejTd = "unK1"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cK3_rejTe :: [Char]
[GblId]
$cK3_rejTe = unpackCString# $cK2_rejTd

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$cK4_rejTf :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cK4_rejTf
  = GHC.Types.: @ String $cK3_rejTe (GHC.Types.[] @ String)

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go38_rejTg :: [Constr] -> [Int] -> Int
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go38_rejTg
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fDataK5 of {
                False -> go38_rejTg ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cK5_rejTh :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cK5_rejTh = Data.Data.AlgConstr $cK6_rejTi

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataK4 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataK4
  = GHC.Types.: @ Constr Data.Data.$cK1 (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataK3 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataK3 = Data.Data.AlgRep Data.Data.$fDataK4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tK1 :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$tK1
  = Data.Data.DataType Data.Data.$fDataK5 Data.Data.$fDataK3

-- RHS size: {terms: 6, types: 0, coercions: 0, joins: 0/0}
Data.Data.$cK1 [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cK1
  = Data.Data.Constr
      $cK5_rejTh
      Data.Data.$fDataK5
      $cK4_rejTf
      Data.Data.Prefix
      Data.Data.$tK1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cK6_rejTi :: Int
[GblId]
$cK6_rejTi = go38_rejTg Data.Data.$fDataK4 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 6, types: 14, coercions: 9, joins: 0/0}
Data.Data.$fDataK2 :: forall c i p. (c -> K1 i c p, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataK2
  = \ (@ c_Xe4g1) (@ i_Xe4fX) (@ p_Xe4fZ) ->
      ((Data.Data.$fDataConst2 @ c_Xe4g1)
       `cast` (<c_Xe4g1>_R
               ->_R Sym (GHC.Generics.N:K1[0]
                             <*>_N <i_Xe4fX>_P <c_Xe4g1>_R <p_Xe4fZ>_P)
               :: (c_Xe4g1 -> c_Xe4g1 :: *)
                  ~R# (c_Xe4g1 -> K1 i_Xe4fX c_Xe4g1 p_Xe4fZ :: *)),
       GHC.Types.False)

-- RHS size: {terms: 59, types: 201, coercions: 12, joins: 0/3}
Data.Data.$w$cgmapMp23 [InlPrag=NOUSERINLINE[0]]
  :: forall i p c.
     Data c =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> K1 i c p -> m (K1 i c p)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 510 0}]
Data.Data.$w$cgmapMp23
  = \ (@ i_seguU)
      (@ p_seguV)
      (@ c_seguW)
      (w_seguZ :: Data c_seguW)
      (@ (m_segv0 :: * -> *))
      (w1_segv1 :: MonadPlus m_segv0)
      (w2_segv2 :: forall d. Data d => d -> m_segv0 d)
      (w3_segv3 :: K1 i_seguU c_seguW p_seguV) ->
      let {
        lvl270_se9Rn :: m_segv0 (K1 i_seguU c_seguW p_seguV)
        [LclId]
        lvl270_se9Rn
          = mzero @ m_segv0 w1_segv1 @ (K1 i_seguU c_seguW p_seguV) } in
      let {
        $dMonad_se9qf [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_segv0
        [LclId]
        $dMonad_se9qf = GHC.Base.$p2MonadPlus @ m_segv0 w1_segv1 } in
      >>=
        @ m_segv0
        $dMonad_se9qf
        @ (K1 i_seguU c_seguW p_seguV, Bool)
        @ (K1 i_seguU c_seguW p_seguV)
        (let {
           lvl271_se9Rm :: m_segv0 c_seguW
           [LclId]
           lvl271_se9Rm
             = w2_segv2
                 @ c_seguW
                 w_seguZ
                 (w3_segv3
                  `cast` (GHC.Generics.N:K1[0]
                              <*>_N <i_seguU>_P <c_seguW>_R <p_seguV>_P
                          :: (K1 i_seguU c_seguW p_seguV :: *) ~R# (c_seguW :: *))) } in
         >>=
           @ m_segv0
           $dMonad_se9qf
           @ (c_seguW -> K1 i_seguU c_seguW p_seguV, Bool)
           @ (K1 i_seguU c_seguW p_seguV, Bool)
           (return
              @ m_segv0
              $dMonad_se9qf
              @ (c_seguW -> K1 i_seguU c_seguW p_seguV, Bool)
              (Data.Data.$fDataK2 @ c_seguW @ i_seguU @ p_seguV))
           (\ (ds_de7oD :: (c_seguW -> K1 i_seguU c_seguW p_seguV, Bool)) ->
              case ds_de7oD of { (h_ae1TA, b_ae1TB) ->
              mplus
                @ m_segv0
                w1_segv1
                @ (K1 i_seguU c_seguW p_seguV, Bool)
                (>>=
                   @ m_segv0
                   $dMonad_se9qf
                   @ c_seguW
                   @ (K1 i_seguU c_seguW p_seguV, Bool)
                   lvl271_se9Rm
                   (\ (y'_ae1TC :: c_seguW) ->
                      return
                        @ m_segv0
                        $dMonad_se9qf
                        @ (K1 i_seguU c_seguW p_seguV, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_segv0
                   $dMonad_se9qf
                   @ (K1 i_seguU c_seguW p_seguV, Bool)
                   (h_ae1TA
                      (w3_segv3
                       `cast` (GHC.Generics.N:K1[0]
                                   <*>_N <i_seguU>_P <c_seguW>_R <p_seguV>_P
                               :: (K1 i_seguU c_seguW p_seguV :: *) ~R# (c_seguW :: *))),
                    b_ae1TB))
              }))
        (\ (ds_de7oa :: (K1 i_seguU c_seguW p_seguV, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9Rn;
             True ->
               return
                 @ m_segv0 $dMonad_se9qf @ (K1 i_seguU c_seguW p_seguV) x'_ae1TD
           }
           })

-- RHS size: {terms: 15, types: 35, coercions: 0, joins: 0/0}
Data.Data.$fDataK1_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall i p c.
     (Typeable i, Data p, Data c) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> K1 i c p -> m (K1 i c p)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ i_seguU)
                 (@ p_seguV)
                 (@ c_seguW)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w2_seguZ [Occ=Once] :: Data c_seguW)
                 (@ (m_segv0 :: * -> *))
                 (w3_segv1 [Occ=Once] :: MonadPlus m_segv0)
                 (w4_segv2 [Occ=Once] :: forall d. Data d => d -> m_segv0 d)
                 (w5_segv3 [Occ=Once] :: K1 i_seguU c_seguW p_seguV) ->
                 Data.Data.$w$cgmapMp23
                   @ i_seguU
                   @ p_seguV
                   @ c_seguW
                   w2_seguZ
                   @ m_segv0
                   w3_segv1
                   w4_segv2
                   w5_segv3}]
Data.Data.$fDataK1_$cgmapMp
  = \ (@ i_seguU)
      (@ p_seguV)
      (@ c_seguW)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w2_seguZ :: Data c_seguW)
      (@ (m_segv0 :: * -> *))
      (w3_segv1 :: MonadPlus m_segv0)
      (w4_segv2 :: forall d. Data d => d -> m_segv0 d)
      (w5_segv3 :: K1 i_seguU c_seguW p_seguV) ->
      Data.Data.$w$cgmapMp23
        @ i_seguU
        @ p_seguV
        @ c_seguW
        w2_seguZ
        @ m_segv0
        w3_segv1
        w4_segv2
        w5_segv3

-- RHS size: {terms: 26, types: 75, coercions: 15, joins: 0/1}
Data.Data.$w$cgmapM11 [InlPrag=NOUSERINLINE[0]]
  :: forall i p c.
     Data c =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> K1 i c p -> m (K1 i c p)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120 60 0] 220 0}]
Data.Data.$w$cgmapM11
  = \ (@ i_segv5)
      (@ p_segv6)
      (@ c_segv7)
      (w_segva :: Data c_segv7)
      (@ (m_segvb :: * -> *))
      (w1_segvc :: Monad m_segvb)
      (w2_segvd :: forall d. Data d => d -> m_segvb d)
      (w3_segve :: K1 i_segv5 c_segv7 p_segv6) ->
      let {
        lvl270_se9Rp :: m_segvb c_segv7
        [LclId]
        lvl270_se9Rp
          = w2_segvd
              @ c_segv7
              w_segva
              (w3_segve
               `cast` (GHC.Generics.N:K1[0]
                           <*>_N <i_segv5>_P <c_segv7>_R <p_segv6>_P
                       :: (K1 i_segv5 c_segv7 p_segv6 :: *) ~R# (c_segv7 :: *))) } in
      >>=
        @ m_segvb
        w1_segvc
        @ (c_segv7 -> K1 i_segv5 c_segv7 p_segv6)
        @ (K1 i_segv5 c_segv7 p_segv6)
        (return
           @ m_segvb
           w1_segvc
           @ (c_segv7 -> K1 i_segv5 c_segv7 p_segv6)
           ((Data.Data.$fDataConst2 @ c_segv7)
            `cast` (<c_segv7>_R
                    ->_R Sym (GHC.Generics.N:K1[0]
                                  <*>_N <i_segv5>_P <c_segv7>_R <p_segv6>_P)
                    :: (c_segv7 -> c_segv7 :: *)
                       ~R# (c_segv7 -> K1 i_segv5 c_segv7 p_segv6 :: *))))
        (\ (c'_ae1To :: c_segv7 -> K1 i_segv5 c_segv7 p_segv6) ->
           >>=
             @ m_segvb
             w1_segvc
             @ c_segv7
             @ (K1 i_segv5 c_segv7 p_segv6)
             lvl270_se9Rp
             (\ (x'_ae1Tp :: c_segv7) ->
                return
                  @ m_segvb
                  w1_segvc
                  @ (K1 i_segv5 c_segv7 p_segv6)
                  (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 15, types: 35, coercions: 0, joins: 0/0}
Data.Data.$fDataK1_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall i p c.
     (Typeable i, Data p, Data c) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> K1 i c p -> m (K1 i c p)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ i_segv5)
                 (@ p_segv6)
                 (@ c_segv7)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w2_segva [Occ=Once] :: Data c_segv7)
                 (@ (m_segvb :: * -> *))
                 (w3_segvc [Occ=Once] :: Monad m_segvb)
                 (w4_segvd [Occ=Once] :: forall d. Data d => d -> m_segvb d)
                 (w5_segve [Occ=Once] :: K1 i_segv5 c_segv7 p_segv6) ->
                 Data.Data.$w$cgmapM11
                   @ i_segv5
                   @ p_segv6
                   @ c_segv7
                   w2_segva
                   @ m_segvb
                   w3_segvc
                   w4_segvd
                   w5_segve}]
Data.Data.$fDataK1_$cgmapM
  = \ (@ i_segv5)
      (@ p_segv6)
      (@ c_segv7)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w2_segva :: Data c_segv7)
      (@ (m_segvb :: * -> *))
      (w3_segvc :: Monad m_segvb)
      (w4_segvd :: forall d. Data d => d -> m_segvb d)
      (w5_segve :: K1 i_segv5 c_segv7 p_segv6) ->
      Data.Data.$w$cgmapM11
        @ i_segv5
        @ p_segv6
        @ c_segv7
        w2_segva
        @ m_segvb
        w3_segvc
        w4_segvd
        w5_segve

-- RHS size: {terms: 69, types: 218, coercions: 18, joins: 0/3}
Data.Data.$w$cgmapMo22 [InlPrag=NOUSERINLINE[0]]
  :: forall i p c.
     Data c =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> K1 i c p -> m (K1 i c p)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 590 0}]
Data.Data.$w$cgmapMo22
  = \ (@ i_segvg)
      (@ p_segvh)
      (@ c_segvi)
      (w_segvl :: Data c_segvi)
      (@ (m_segvm :: * -> *))
      (w1_segvn :: MonadPlus m_segvm)
      (w2_segvo :: forall d. Data d => d -> m_segvm d)
      (w3_segvp :: K1 i_segvg c_segvi p_segvh) ->
      let {
        lvl270_se9Ru :: m_segvm (K1 i_segvg c_segvi p_segvh)
        [LclId]
        lvl270_se9Ru
          = mzero @ m_segvm w1_segvn @ (K1 i_segvg c_segvi p_segvh) } in
      let {
        $dMonad_se9qd [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_segvm
        [LclId]
        $dMonad_se9qd = GHC.Base.$p2MonadPlus @ m_segvm w1_segvn } in
      >>=
        @ m_segvm
        $dMonad_se9qd
        @ (K1 i_segvg c_segvi p_segvh, Bool)
        @ (K1 i_segvg c_segvi p_segvh)
        (let {
           lvl271_se9Rt :: m_segvm c_segvi
           [LclId]
           lvl271_se9Rt
             = w2_segvo
                 @ c_segvi
                 w_segvl
                 (w3_segvp
                  `cast` (GHC.Generics.N:K1[0]
                              <*>_N <i_segvg>_P <c_segvi>_R <p_segvh>_P
                          :: (K1 i_segvg c_segvi p_segvh :: *) ~R# (c_segvi :: *))) } in
         >>=
           @ m_segvm
           $dMonad_se9qd
           @ (c_segvi -> K1 i_segvg c_segvi p_segvh, Bool)
           @ (K1 i_segvg c_segvi p_segvh, Bool)
           (return
              @ m_segvm
              $dMonad_se9qd
              @ (c_segvi -> K1 i_segvg c_segvi p_segvh, Bool)
              (Data.Data.$fDataK2 @ c_segvi @ i_segvg @ p_segvh))
           (\ (ds_de7pD :: (c_segvi -> K1 i_segvg c_segvi p_segvh, Bool)) ->
              case ds_de7pD of { (h_ae1TP, b_ae1TQ) ->
              case b_ae1TQ of {
                False ->
                  mplus
                    @ m_segvm
                    w1_segvn
                    @ (K1 i_segvg c_segvi p_segvh, Bool)
                    (>>=
                       @ m_segvm
                       $dMonad_se9qd
                       @ c_segvi
                       @ (K1 i_segvg c_segvi p_segvh, Bool)
                       lvl271_se9Rt
                       (\ (y'_ae1TR :: c_segvi) ->
                          return
                            @ m_segvm
                            $dMonad_se9qd
                            @ (K1 i_segvg c_segvi p_segvh, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_segvm
                       $dMonad_se9qd
                       @ (K1 i_segvg c_segvi p_segvh, Bool)
                       (h_ae1TP
                          (w3_segvp
                           `cast` (GHC.Generics.N:K1[0]
                                       <*>_N <i_segvg>_P <c_segvi>_R <p_segvh>_P
                                   :: (K1 i_segvg c_segvi p_segvh :: *) ~R# (c_segvi :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_segvm
                    $dMonad_se9qd
                    @ (K1 i_segvg c_segvi p_segvh, Bool)
                    (h_ae1TP
                       (w3_segvp
                        `cast` (GHC.Generics.N:K1[0]
                                    <*>_N <i_segvg>_P <c_segvi>_R <p_segvh>_P
                                :: (K1 i_segvg c_segvi p_segvh :: *) ~R# (c_segvi :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds_de7pa :: (K1 i_segvg c_segvi p_segvh, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9Ru;
             True ->
               return
                 @ m_segvm $dMonad_se9qd @ (K1 i_segvg c_segvi p_segvh) x'_ae1TS
           }
           })

-- RHS size: {terms: 15, types: 35, coercions: 0, joins: 0/0}
Data.Data.$fDataK1_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall i p c.
     (Typeable i, Data p, Data c) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> K1 i c p -> m (K1 i c p)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ i_segvg)
                 (@ p_segvh)
                 (@ c_segvi)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w2_segvl [Occ=Once] :: Data c_segvi)
                 (@ (m_segvm :: * -> *))
                 (w3_segvn [Occ=Once] :: MonadPlus m_segvm)
                 (w4_segvo [Occ=Once] :: forall d. Data d => d -> m_segvm d)
                 (w5_segvp [Occ=Once] :: K1 i_segvg c_segvi p_segvh) ->
                 Data.Data.$w$cgmapMo22
                   @ i_segvg
                   @ p_segvh
                   @ c_segvi
                   w2_segvl
                   @ m_segvm
                   w3_segvn
                   w4_segvo
                   w5_segvp}]
Data.Data.$fDataK1_$cgmapMo
  = \ (@ i_segvg)
      (@ p_segvh)
      (@ c_segvi)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w2_segvl :: Data c_segvi)
      (@ (m_segvm :: * -> *))
      (w3_segvn :: MonadPlus m_segvm)
      (w4_segvo :: forall d. Data d => d -> m_segvm d)
      (w5_segvp :: K1 i_segvg c_segvi p_segvh) ->
      Data.Data.$w$cgmapMo22
        @ i_segvg
        @ p_segvh
        @ c_segvi
        w2_segvl
        @ m_segvm
        w3_segvn
        w4_segvo
        w5_segvp

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl199_rejTj :: forall i c p. K1 i c p -> Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl199_rejTj
  = \ (@ i_Xe4fO) (@ c_Xe4fS) (@ p_Xe4fQ) _ [Occ=Dead] ->
      Data.Data.$cK1

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
lvl200_rejTk :: forall i c p. K1 i c p -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl200_rejTk
  = \ (@ i_Xe4fO) (@ c_Xe4fS) (@ p_Xe4fQ) _ [Occ=Dead] ->
      Data.Data.$tK1

-- RHS size: {terms: 8, types: 33, coercions: 0, joins: 0/0}
lvl201_rejTl
  :: forall i c1 p (t :: * -> *) (c2 :: * -> *).
     Typeable t =>
     (forall d. Data d => c2 (t d)) -> Maybe (c2 (K1 i c1 p))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl201_rejTl
  = \ (@ i_Xe4fO)
      (@ c_Xe4fS)
      (@ p_Xe4fQ)
      (@ (t_ae3xs :: * -> *))
      (@ (c1_ae3xt :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c1_ae3xt (K1 i_Xe4fO c_Xe4fS p_Xe4fQ))

-- RHS size: {terms: 8, types: 42, coercions: 0, joins: 0/0}
lvl202_rejTm
  :: forall i c1 p (t :: * -> * -> *) (c2 :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c2 (t d e))
     -> Maybe (c2 (K1 i c1 p))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl202_rejTm
  = \ (@ i_Xe4fO)
      (@ c_Xe4fS)
      (@ p_Xe4fQ)
      (@ (t_ae3xL :: * -> * -> *))
      (@ (c1_ae3xM :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c1_ae3xM (K1 i_Xe4fO c_Xe4fS p_Xe4fQ))

-- RHS size: {terms: 109, types: 272, coercions: 85, joins: 0/0}
Data.Data.$fDataK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i p c. (Typeable i, Data p, Data c) => Data (K1 i c p)
[GblId[DFunId],
 Arity=3,
 Str=<L,U><L,1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ i_ae1X4)
             (@ p_ae1X5)
             (@ c_ae1X6)
             (v_XMA :: Typeable i_ae1X4)
             (v1_XMC :: Data p_ae1X5)
             (v2_XME :: Data c_ae1X6) ->
       Data.Data.C:Data TYPE: K1 i_ae1X4 c_ae1X6 p_ae1X5
                        (Data.Data.$fDataK7
                           @ i_ae1X4 @ p_ae1X5 @ c_ae1X6 v_XMA v1_XMC v2_XME)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <K1
                                                                                    i_ae1X4
                                                                                    c_ae1X6
                                                                                    p_ae1X5>_N
                                :: (Data.Typeable.Internal.TypeRep
                                      (K1 i_ae1X4 c_ae1X6 p_ae1X5) :: *)
                                   ~R# (Typeable (K1 i_ae1X4 c_ae1X6 p_ae1X5) :: Constraint))
                        \ (@ (c1_ae3wS :: * -> *))
                          (k_ae2nH [Occ=Once!]
                             :: forall d b. Data d => c1_ae3wS (d -> b) -> d -> c1_ae3wS b)
                          (z_ae2nI [Occ=Once!] :: forall g. g -> c1_ae3wS g)
                          (ds_de7tS [Occ=Once] :: K1 i_ae1X4 c_ae1X6 p_ae1X5) ->
                          k_ae2nH
                            @ c_ae1X6
                            @ (K1 i_ae1X4 c_ae1X6 p_ae1X5)
                            v2_XME
                            (z_ae2nI
                               @ (c_ae1X6 -> K1 i_ae1X4 c_ae1X6 p_ae1X5)
                               ((\ (v3_XJl [Occ=Once] :: c_ae1X6) -> v3_XJl)
                                `cast` (<c_ae1X6>_R
                                        ->_R Sym (GHC.Generics.N:K1[0]
                                                      <*>_N <i_ae1X4>_P <c_ae1X6>_R <p_ae1X5>_P)
                                        :: (c_ae1X6 -> c_ae1X6 :: *)
                                           ~R# (c_ae1X6 -> K1 i_ae1X4 c_ae1X6 p_ae1X5 :: *))))
                            (ds_de7tS
                             `cast` (GHC.Generics.N:K1[0]
                                         <*>_N <i_ae1X4>_P <c_ae1X6>_R <p_ae1X5>_P
                                     :: (K1 i_ae1X4 c_ae1X6 p_ae1X5 :: *) ~R# (c_ae1X6 :: *)))
                        \ (@ (c1_ae3x6 :: * -> *))
                          (k_ae2nK [Occ=Once!]
                             :: forall b r. Data b => c1_ae3x6 (b -> r) -> c1_ae3x6 r)
                          (z_ae2nL [Occ=Once!] :: forall r. r -> c1_ae3x6 r)
                          _ [Occ=Dead] ->
                          k_ae2nK
                            @ c_ae1X6
                            @ (K1 i_ae1X4 c_ae1X6 p_ae1X5)
                            v2_XME
                            (z_ae2nL
                               @ (c_ae1X6 -> K1 i_ae1X4 c_ae1X6 p_ae1X5)
                               ((\ (v3_XJl [Occ=Once] :: c_ae1X6) -> v3_XJl)
                                `cast` (<c_ae1X6>_R
                                        ->_R Sym (GHC.Generics.N:K1[0]
                                                      <*>_N <i_ae1X4>_P <c_ae1X6>_R <p_ae1X5>_P)
                                        :: (c_ae1X6 -> c_ae1X6 :: *)
                                           ~R# (c_ae1X6 -> K1 i_ae1X4 c_ae1X6 p_ae1X5 :: *))))
                        \ _ [Occ=Dead] -> Data.Data.$cK1
                        \ _ [Occ=Dead] -> Data.Data.$tK1
                        \ (@ (t_ae3xs :: * -> *))
                          (@ (c1_ae3xt :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c1_ae3xt (K1 i_ae1X4 c_ae1X6 p_ae1X5))
                        \ (@ (t_ae3xL :: * -> * -> *))
                          (@ (c1_ae3xM :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c1_ae3xM (K1 i_ae1X4 c_ae1X6 p_ae1X5))
                        (\ (ds_de7tZ [Occ=Once!] :: forall b. Data b => b -> b)
                           (x0_Xe35P [Occ=Once] :: K1 i_ae1X4 c_ae1X6 p_ae1X5) ->
                           ds_de7tZ
                             @ c_ae1X6
                             v2_XME
                             (x0_Xe35P
                              `cast` (GHC.Generics.N:K1[0]
                                          <*>_N <i_ae1X4>_P <c_ae1X6>_R <p_ae1X5>_P
                                      :: (K1 i_ae1X4 c_ae1X6 p_ae1X5 :: *) ~R# (c_ae1X6 :: *))))
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <K1 i_ae1X4 c_ae1X6 p_ae1X5>_R
                                ->_R Sym (GHC.Generics.N:K1[0]
                                              <*>_N <i_ae1X4>_P <c_ae1X6>_R <p_ae1X5>_P)
                                :: ((forall b. Data b => b -> b)
                                    -> K1 i_ae1X4 c_ae1X6 p_ae1X5 -> c_ae1X6 :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> K1 i_ae1X4 c_ae1X6 p_ae1X5
                                        -> K1 i_ae1X4 c_ae1X6 p_ae1X5 :: *))
                        \ (@ r_ae3yj)
                          (@ r'_ae3yk)
                          (ds_de7u0 [Occ=Once!] :: r_ae3yj -> r'_ae3yk -> r_ae3yj)
                          (ds1_de7u1 [Occ=Once] :: r_ae3yj)
                          (ds2_de7u2 [Occ=Once!] :: forall d. Data d => d -> r'_ae3yk)
                          (eta_XMx [Occ=Once] :: K1 i_ae1X4 c_ae1X6 p_ae1X5) ->
                          ds_de7u0
                            ds1_de7u1
                            (ds2_de7u2
                               @ c_ae1X6
                               v2_XME
                               (eta_XMx
                                `cast` (GHC.Generics.N:K1[0]
                                            <*>_N <i_ae1X4>_P <c_ae1X6>_R <p_ae1X5>_P
                                        :: (K1 i_ae1X4 c_ae1X6 p_ae1X5 :: *) ~R# (c_ae1X6 :: *))))
                        \ (@ r_ae3yA)
                          (@ r'_ae3yB)
                          (ds_de7u3 [Occ=Once!] :: r'_ae3yB -> r_ae3yA -> r_ae3yA)
                          (ds1_de7u4 [Occ=Once] :: r_ae3yA)
                          (ds2_de7u5 [Occ=Once!] :: forall d. Data d => d -> r'_ae3yB)
                          (x0_ae1SX [Occ=Once] :: K1 i_ae1X4 c_ae1X6 p_ae1X5) ->
                          ds_de7u3
                            (ds2_de7u5
                               @ c_ae1X6
                               v2_XME
                               (x0_ae1SX
                                `cast` (GHC.Generics.N:K1[0]
                                            <*>_N <i_ae1X4>_P <c_ae1X6>_R <p_ae1X5>_P
                                        :: (K1 i_ae1X4 c_ae1X6 p_ae1X5 :: *) ~R# (c_ae1X6 :: *))))
                            ds1_de7u4
                        \ (@ u_ae3yR)
                          (ds_de7u6 [Occ=Once!] :: forall d. Data d => d -> u_ae3yR)
                          (x0_ae1SX [Occ=Once] :: K1 i_ae1X4 c_ae1X6 p_ae1X5) ->
                          GHC.Types.:
                            @ u_ae3yR
                            (ds_de7u6
                               @ c_ae1X6
                               v2_XME
                               (x0_ae1SX
                                `cast` (GHC.Generics.N:K1[0]
                                            <*>_N <i_ae1X4>_P <c_ae1X6>_R <p_ae1X5>_P
                                        :: (K1 i_ae1X4 c_ae1X6 p_ae1X5 :: *) ~R# (c_ae1X6 :: *))))
                            (GHC.Types.[] @ u_ae3yR)
                        \ (@ u_ae3z5)
                          (ds_de7u7 [Occ=Once!] :: Int)
                          (ds1_de7u8 [Occ=Once!] :: forall d. Data d => d -> u_ae3z5)
                          (x_ae1T7 [Occ=Once] :: K1 i_ae1X4 c_ae1X6 p_ae1X5) ->
                          case ds_de7u7 of { I# x1_a22G [Occ=Once!] ->
                          case x1_a22G of {
                            __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3z5;
                            0# ->
                              ds1_de7u8
                                @ c_ae1X6
                                v2_XME
                                (x_ae1T7
                                 `cast` (GHC.Generics.N:K1[0]
                                             <*>_N <i_ae1X4>_P <c_ae1X6>_R <p_ae1X5>_P
                                         :: (K1 i_ae1X4 c_ae1X6 p_ae1X5 :: *) ~R# (c_ae1X6 :: *)))
                          }
                          }
                        Data.Data.$fDataK1_$cgmapM
                          @ i_ae1X4 @ p_ae1X5 @ c_ae1X6 v_XMA v1_XMC v2_XME
                        Data.Data.$fDataK1_$cgmapMp
                          @ i_ae1X4 @ p_ae1X5 @ c_ae1X6 v_XMA v1_XMC v2_XME
                        Data.Data.$fDataK1_$cgmapMo
                          @ i_ae1X4 @ p_ae1X5 @ c_ae1X6 v_XMA v1_XMC v2_XME]
Data.Data.$fDataK1
  = \ (@ i_Xe4fO)
      (@ p_Xe4fQ)
      (@ c_Xe4fS)
      ($dTypeable_Xe4fU :: Typeable i_Xe4fO)
      ($dData_Xe4fW :: Data p_Xe4fQ)
      ($dData1_Xe4fY :: Data c_Xe4fS) ->
      Data.Data.C:Data
        @ (K1 i_Xe4fO c_Xe4fS p_Xe4fQ)
        ((Data.Data.$fDataK7
            @ i_Xe4fO
            @ p_Xe4fQ
            @ c_Xe4fS
            $dTypeable_Xe4fU
            $dData_Xe4fW
            $dData1_Xe4fY)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <K1
                                                                     i_Xe4fO c_Xe4fS p_Xe4fQ>_N
                 :: (Data.Typeable.Internal.TypeRep
                       (K1 i_Xe4fO c_Xe4fS p_Xe4fQ) :: *)
                    ~R# (Typeable (K1 i_Xe4fO c_Xe4fS p_Xe4fQ) :: Constraint)))
        (\ (@ (c1_ae3wS :: * -> *))
           (k_ae2nH
              :: forall d b. Data d => c1_ae3wS (d -> b) -> d -> c1_ae3wS b)
           (z_ae2nI :: forall g. g -> c1_ae3wS g)
           (ds_de7tS :: K1 i_Xe4fO c_Xe4fS p_Xe4fQ) ->
           k_ae2nH
             @ c_Xe4fS
             @ (K1 i_Xe4fO c_Xe4fS p_Xe4fQ)
             $dData1_Xe4fY
             (z_ae2nI
                @ (c_Xe4fS -> K1 i_Xe4fO c_Xe4fS p_Xe4fQ)
                ((Data.Data.$fDataConst2 @ c_Xe4fS)
                 `cast` (<c_Xe4fS>_R
                         ->_R Sym (GHC.Generics.N:K1[0]
                                       <*>_N <i_Xe4fO>_P <c_Xe4fS>_R <p_Xe4fQ>_P)
                         :: (c_Xe4fS -> c_Xe4fS :: *)
                            ~R# (c_Xe4fS -> K1 i_Xe4fO c_Xe4fS p_Xe4fQ :: *))))
             (ds_de7tS
              `cast` (GHC.Generics.N:K1[0]
                          <*>_N <i_Xe4fO>_P <c_Xe4fS>_R <p_Xe4fQ>_P
                      :: (K1 i_Xe4fO c_Xe4fS p_Xe4fQ :: *) ~R# (c_Xe4fS :: *))))
        (\ (@ (c1_ae3x6 :: * -> *))
           (k_ae2nK :: forall b r. Data b => c1_ae3x6 (b -> r) -> c1_ae3x6 r)
           (z_ae2nL :: forall r. r -> c1_ae3x6 r)
           _ [Occ=Dead] ->
           k_ae2nK
             @ c_Xe4fS
             @ (K1 i_Xe4fO c_Xe4fS p_Xe4fQ)
             $dData1_Xe4fY
             (z_ae2nL
                @ (c_Xe4fS -> K1 i_Xe4fO c_Xe4fS p_Xe4fQ)
                ((Data.Data.$fDataConst2 @ c_Xe4fS)
                 `cast` (<c_Xe4fS>_R
                         ->_R Sym (GHC.Generics.N:K1[0]
                                       <*>_N <i_Xe4fO>_P <c_Xe4fS>_R <p_Xe4fQ>_P)
                         :: (c_Xe4fS -> c_Xe4fS :: *)
                            ~R# (c_Xe4fS -> K1 i_Xe4fO c_Xe4fS p_Xe4fQ :: *)))))
        (lvl199_rejTj @ i_Xe4fO @ c_Xe4fS @ p_Xe4fQ)
        (lvl200_rejTk @ i_Xe4fO @ c_Xe4fS @ p_Xe4fQ)
        (lvl201_rejTl @ i_Xe4fO @ c_Xe4fS @ p_Xe4fQ)
        (lvl202_rejTm @ i_Xe4fO @ c_Xe4fS @ p_Xe4fQ)
        ((\ (ds_de7tZ :: forall b. Data b => b -> b)
            (x0_Xe35P :: K1 i_Xe4fO c_Xe4fS p_Xe4fQ) ->
            ds_de7tZ
              @ c_Xe4fS
              $dData1_Xe4fY
              (x0_Xe35P
               `cast` (GHC.Generics.N:K1[0]
                           <*>_N <i_Xe4fO>_P <c_Xe4fS>_R <p_Xe4fQ>_P
                       :: (K1 i_Xe4fO c_Xe4fS p_Xe4fQ :: *) ~R# (c_Xe4fS :: *))))
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <K1 i_Xe4fO c_Xe4fS p_Xe4fQ>_R
                 ->_R Sym (GHC.Generics.N:K1[0]
                               <*>_N <i_Xe4fO>_P <c_Xe4fS>_R <p_Xe4fQ>_P)
                 :: ((forall b. Data b => b -> b)
                     -> K1 i_Xe4fO c_Xe4fS p_Xe4fQ -> c_Xe4fS :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> K1 i_Xe4fO c_Xe4fS p_Xe4fQ -> K1 i_Xe4fO c_Xe4fS p_Xe4fQ :: *)))
        (\ (@ r_ae3yj)
           (@ r'_ae3yk)
           (ds_de7u0 :: r_ae3yj -> r'_ae3yk -> r_ae3yj)
           (ds1_de7u1 :: r_ae3yj)
           (ds2_de7u2 :: forall d. Data d => d -> r'_ae3yk)
           (eta_XMx :: K1 i_Xe4fO c_Xe4fS p_Xe4fQ) ->
           ds_de7u0
             ds1_de7u1
             (ds2_de7u2
                @ c_Xe4fS
                $dData1_Xe4fY
                (eta_XMx
                 `cast` (GHC.Generics.N:K1[0]
                             <*>_N <i_Xe4fO>_P <c_Xe4fS>_R <p_Xe4fQ>_P
                         :: (K1 i_Xe4fO c_Xe4fS p_Xe4fQ :: *) ~R# (c_Xe4fS :: *)))))
        (\ (@ r_ae3yA)
           (@ r'_ae3yB)
           (ds_de7u3 :: r'_ae3yB -> r_ae3yA -> r_ae3yA)
           (ds1_de7u4 :: r_ae3yA)
           (ds2_de7u5 :: forall d. Data d => d -> r'_ae3yB)
           (x0_ae1SX :: K1 i_Xe4fO c_Xe4fS p_Xe4fQ) ->
           ds_de7u3
             (ds2_de7u5
                @ c_Xe4fS
                $dData1_Xe4fY
                (x0_ae1SX
                 `cast` (GHC.Generics.N:K1[0]
                             <*>_N <i_Xe4fO>_P <c_Xe4fS>_R <p_Xe4fQ>_P
                         :: (K1 i_Xe4fO c_Xe4fS p_Xe4fQ :: *) ~R# (c_Xe4fS :: *))))
             ds1_de7u4)
        (\ (@ u_ae3yR)
           (ds_de7u6 :: forall d. Data d => d -> u_ae3yR)
           (x0_ae1SX :: K1 i_Xe4fO c_Xe4fS p_Xe4fQ) ->
           GHC.Types.:
             @ u_ae3yR
             (ds_de7u6
                @ c_Xe4fS
                $dData1_Xe4fY
                (x0_ae1SX
                 `cast` (GHC.Generics.N:K1[0]
                             <*>_N <i_Xe4fO>_P <c_Xe4fS>_R <p_Xe4fQ>_P
                         :: (K1 i_Xe4fO c_Xe4fS p_Xe4fQ :: *) ~R# (c_Xe4fS :: *))))
             (GHC.Types.[] @ u_ae3yR))
        (\ (@ u_ae3z5)
           (ds_de7u7 :: Int)
           (ds1_de7u8 :: forall d. Data d => d -> u_ae3z5)
           (x_ae1T7 :: K1 i_Xe4fO c_Xe4fS p_Xe4fQ) ->
           case ds_de7u7 of { I# x1_a22G ->
           case x1_a22G of {
             __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3z5;
             0# ->
               ds1_de7u8
                 @ c_Xe4fS
                 $dData1_Xe4fY
                 (x_ae1T7
                  `cast` (GHC.Generics.N:K1[0]
                              <*>_N <i_Xe4fO>_P <c_Xe4fS>_R <p_Xe4fQ>_P
                          :: (K1 i_Xe4fO c_Xe4fS p_Xe4fQ :: *) ~R# (c_Xe4fS :: *)))
           }
           })
        (\ (@ (m_segvb :: * -> *))
           (w_segvc :: Monad m_segvb)
           (w1_segvd :: forall d. Data d => d -> m_segvb d)
           (w2_segve :: K1 i_Xe4fO c_Xe4fS p_Xe4fQ) ->
           Data.Data.$w$cgmapM11
             @ i_Xe4fO
             @ p_Xe4fQ
             @ c_Xe4fS
             $dData1_Xe4fY
             @ m_segvb
             w_segvc
             w1_segvd
             w2_segve)
        (\ (@ (m_segv0 :: * -> *))
           (w_segv1 :: MonadPlus m_segv0)
           (w1_segv2 :: forall d. Data d => d -> m_segv0 d)
           (w2_segv3 :: K1 i_Xe4fO c_Xe4fS p_Xe4fQ) ->
           Data.Data.$w$cgmapMp23
             @ i_Xe4fO
             @ p_Xe4fQ
             @ c_Xe4fS
             $dData1_Xe4fY
             @ m_segv0
             w_segv1
             w1_segv2
             w2_segv3)
        (\ (@ (m_segvm :: * -> *))
           (w_segvn :: MonadPlus m_segvm)
           (w1_segvo :: forall d. Data d => d -> m_segvm d)
           (w2_segvp :: K1 i_Xe4fO c_Xe4fS p_Xe4fQ) ->
           Data.Data.$w$cgmapMo22
             @ i_Xe4fO
             @ p_Xe4fQ
             @ c_Xe4fS
             $dData1_Xe4fY
             @ m_segvm
             w_segvn
             w1_segvo
             w2_segvp)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataM6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataM6 = "M1"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataM5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataM5 = unpackCString# Data.Data.$fDataM6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$cM2_rejTn :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$cM2_rejTn = "unM1"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cM3_rejTo :: [Char]
[GblId]
$cM3_rejTo = unpackCString# $cM2_rejTn

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$cM4_rejTp :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cM4_rejTp
  = GHC.Types.: @ String $cM3_rejTo (GHC.Types.[] @ String)

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go39_rejTq :: [Constr] -> [Int] -> Int
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go39_rejTq
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fDataM5 of {
                False -> go39_rejTq ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cM5_rejTr :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cM5_rejTr = Data.Data.AlgConstr $cM6_rejTs

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataM4 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataM4
  = GHC.Types.: @ Constr Data.Data.$cM1 (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataM3 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataM3 = Data.Data.AlgRep Data.Data.$fDataM4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tM1 :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$tM1
  = Data.Data.DataType Data.Data.$fDataM5 Data.Data.$fDataM3

-- RHS size: {terms: 6, types: 0, coercions: 0, joins: 0/0}
Data.Data.$cM1 [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cM1
  = Data.Data.Constr
      $cM5_rejTr
      Data.Data.$fDataM5
      $cM4_rejTp
      Data.Data.Prefix
      Data.Data.$tM1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cM6_rejTs :: Int
[GblId]
$cM6_rejTs = go39_rejTq Data.Data.$fDataM4 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 7, types: 20, coercions: 11, joins: 0/0}
Data.Data.$fDataM2
  :: forall (f :: * -> *) p i (c :: Meta). (f p -> M1 i c f p, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataM2
  = \ (@ (f_Xe4cN :: * -> *))
      (@ p_Xe4cL)
      (@ i_Xe4cR)
      (@ (c_Xe4cP :: Meta)) ->
      ((Data.Data.$fDataAlt2 @ f_Xe4cN @ p_Xe4cL)
       `cast` (<f_Xe4cN p_Xe4cL>_R
               ->_R Sym (GHC.Generics.N:M1[0]
                             <*>_N <i_Xe4cR>_P <c_Xe4cP>_P <f_Xe4cN>_R) <p_Xe4cL>_N
               :: (f_Xe4cN p_Xe4cL -> f_Xe4cN p_Xe4cL :: *)
                  ~R# (f_Xe4cN p_Xe4cL -> M1 i_Xe4cR c_Xe4cP f_Xe4cN p_Xe4cL :: *)),
       GHC.Types.False)

-- RHS size: {terms: 60, types: 236, coercions: 14, joins: 0/3}
Data.Data.$w$cgmapMp24 [InlPrag=NOUSERINLINE[0]]
  :: forall p (f :: * -> *) (c :: Meta) i.
     Data (f p) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> M1 i c f p -> m (M1 i c f p)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 510 0}]
Data.Data.$w$cgmapMp24
  = \ (@ p_segvt)
      (@ (f_segvu :: * -> *))
      (@ (c_segvv :: Meta))
      (@ i_segvw)
      (w_segvy :: Data (f_segvu p_segvt))
      (@ (m_segvC :: * -> *))
      (w1_segvD :: MonadPlus m_segvC)
      (w2_segvE :: forall d. Data d => d -> m_segvC d)
      (w3_segvF :: M1 i_segvw c_segvv f_segvu p_segvt) ->
      let {
        lvl270_se9RP :: m_segvC (M1 i_segvw c_segvv f_segvu p_segvt)
        [LclId]
        lvl270_se9RP
          = mzero
              @ m_segvC w1_segvD @ (M1 i_segvw c_segvv f_segvu p_segvt) } in
      let {
        $dMonad_se9qb [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_segvC
        [LclId]
        $dMonad_se9qb = GHC.Base.$p2MonadPlus @ m_segvC w1_segvD } in
      >>=
        @ m_segvC
        $dMonad_se9qb
        @ (M1 i_segvw c_segvv f_segvu p_segvt, Bool)
        @ (M1 i_segvw c_segvv f_segvu p_segvt)
        (let {
           lvl271_se9RO :: m_segvC (f_segvu p_segvt)
           [LclId]
           lvl271_se9RO
             = w2_segvE
                 @ (f_segvu p_segvt)
                 w_segvy
                 (w3_segvF
                  `cast` (GHC.Generics.N:M1[0]
                              <*>_N <i_segvw>_P <c_segvv>_P <f_segvu>_R <p_segvt>_N
                          :: (M1 i_segvw c_segvv f_segvu p_segvt :: *)
                             ~R# (f_segvu p_segvt :: *))) } in
         >>=
           @ m_segvC
           $dMonad_se9qb
           @ (f_segvu p_segvt -> M1 i_segvw c_segvv f_segvu p_segvt, Bool)
           @ (M1 i_segvw c_segvv f_segvu p_segvt, Bool)
           (return
              @ m_segvC
              $dMonad_se9qb
              @ (f_segvu p_segvt -> M1 i_segvw c_segvv f_segvu p_segvt, Bool)
              (Data.Data.$fDataM2 @ f_segvu @ p_segvt @ i_segvw @ c_segvv))
           (\ (ds_de7oD
                 :: (f_segvu p_segvt -> M1 i_segvw c_segvv f_segvu p_segvt,
                     Bool)) ->
              case ds_de7oD of { (h_ae1TA, b_ae1TB) ->
              mplus
                @ m_segvC
                w1_segvD
                @ (M1 i_segvw c_segvv f_segvu p_segvt, Bool)
                (>>=
                   @ m_segvC
                   $dMonad_se9qb
                   @ (f_segvu p_segvt)
                   @ (M1 i_segvw c_segvv f_segvu p_segvt, Bool)
                   lvl271_se9RO
                   (\ (y'_ae1TC :: f_segvu p_segvt) ->
                      return
                        @ m_segvC
                        $dMonad_se9qb
                        @ (M1 i_segvw c_segvv f_segvu p_segvt, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_segvC
                   $dMonad_se9qb
                   @ (M1 i_segvw c_segvv f_segvu p_segvt, Bool)
                   (h_ae1TA
                      (w3_segvF
                       `cast` (GHC.Generics.N:M1[0]
                                   <*>_N <i_segvw>_P <c_segvv>_P <f_segvu>_R <p_segvt>_N
                               :: (M1 i_segvw c_segvv f_segvu p_segvt :: *)
                                  ~R# (f_segvu p_segvt :: *))),
                    b_ae1TB))
              }))
        (\ (ds_de7oa :: (M1 i_segvw c_segvv f_segvu p_segvt, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9RP;
             True ->
               return
                 @ m_segvC
                 $dMonad_se9qb
                 @ (M1 i_segvw c_segvv f_segvu p_segvt)
                 x'_ae1TD
           }
           })

-- RHS size: {terms: 18, types: 50, coercions: 0, joins: 0/0}
Data.Data.$fDataM1_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall p (f :: * -> *) (c :: Meta) i.
     (Data p, Data (f p), Typeable c, Typeable i, Typeable f) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> M1 i c f p -> m (M1 i c f p)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,A><L,U><L,A><L,A><L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=8,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ p_segvt)
                 (@ (f_segvu :: * -> *))
                 (@ (c_segvv :: Meta))
                 (@ i_segvw)
                 _ [Occ=Dead]
                 (w1_segvy [Occ=Once] :: Data (f_segvu p_segvt))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (@ (m_segvC :: * -> *))
                 (w5_segvD [Occ=Once] :: MonadPlus m_segvC)
                 (w6_segvE [Occ=Once] :: forall d. Data d => d -> m_segvC d)
                 (w7_segvF [Occ=Once] :: M1 i_segvw c_segvv f_segvu p_segvt) ->
                 Data.Data.$w$cgmapMp24
                   @ p_segvt
                   @ f_segvu
                   @ c_segvv
                   @ i_segvw
                   w1_segvy
                   @ m_segvC
                   w5_segvD
                   w6_segvE
                   w7_segvF}]
Data.Data.$fDataM1_$cgmapMp
  = \ (@ p_segvt)
      (@ (f_segvu :: * -> *))
      (@ (c_segvv :: Meta))
      (@ i_segvw)
      _ [Occ=Dead]
      (w1_segvy :: Data (f_segvu p_segvt))
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (@ (m_segvC :: * -> *))
      (w5_segvD :: MonadPlus m_segvC)
      (w6_segvE :: forall d. Data d => d -> m_segvC d)
      (w7_segvF :: M1 i_segvw c_segvv f_segvu p_segvt) ->
      Data.Data.$w$cgmapMp24
        @ p_segvt
        @ f_segvu
        @ c_segvv
        @ i_segvw
        w1_segvy
        @ m_segvC
        w5_segvD
        w6_segvE
        w7_segvF

-- RHS size: {terms: 27, types: 94, coercions: 18, joins: 0/1}
Data.Data.$w$cgmapM12 [InlPrag=NOUSERINLINE[0]]
  :: forall p (f :: * -> *) (c :: Meta) i.
     Data (f p) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> M1 i c f p -> m (M1 i c f p)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120 60 0] 220 0}]
Data.Data.$w$cgmapM12
  = \ (@ p_segvH)
      (@ (f_segvI :: * -> *))
      (@ (c_segvJ :: Meta))
      (@ i_segvK)
      (w_segvM :: Data (f_segvI p_segvH))
      (@ (m_segvQ :: * -> *))
      (w1_segvR :: Monad m_segvQ)
      (w2_segvS :: forall d. Data d => d -> m_segvQ d)
      (w3_segvT :: M1 i_segvK c_segvJ f_segvI p_segvH) ->
      let {
        lvl270_se9RR :: m_segvQ (f_segvI p_segvH)
        [LclId]
        lvl270_se9RR
          = w2_segvS
              @ (f_segvI p_segvH)
              w_segvM
              (w3_segvT
               `cast` (GHC.Generics.N:M1[0]
                           <*>_N <i_segvK>_P <c_segvJ>_P <f_segvI>_R <p_segvH>_N
                       :: (M1 i_segvK c_segvJ f_segvI p_segvH :: *)
                          ~R# (f_segvI p_segvH :: *))) } in
      >>=
        @ m_segvQ
        w1_segvR
        @ (f_segvI p_segvH -> M1 i_segvK c_segvJ f_segvI p_segvH)
        @ (M1 i_segvK c_segvJ f_segvI p_segvH)
        (return
           @ m_segvQ
           w1_segvR
           @ (f_segvI p_segvH -> M1 i_segvK c_segvJ f_segvI p_segvH)
           ((Data.Data.$fDataAlt2 @ f_segvI @ p_segvH)
            `cast` (<f_segvI p_segvH>_R
                    ->_R Sym (GHC.Generics.N:M1[0]
                                  <*>_N <i_segvK>_P <c_segvJ>_P <f_segvI>_R) <p_segvH>_N
                    :: (f_segvI p_segvH -> f_segvI p_segvH :: *)
                       ~R# (f_segvI p_segvH -> M1 i_segvK c_segvJ f_segvI p_segvH :: *))))
        (\ (c'_ae1To
              :: f_segvI p_segvH -> M1 i_segvK c_segvJ f_segvI p_segvH) ->
           >>=
             @ m_segvQ
             w1_segvR
             @ (f_segvI p_segvH)
             @ (M1 i_segvK c_segvJ f_segvI p_segvH)
             lvl270_se9RR
             (\ (x'_ae1Tp :: f_segvI p_segvH) ->
                return
                  @ m_segvQ
                  w1_segvR
                  @ (M1 i_segvK c_segvJ f_segvI p_segvH)
                  (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 18, types: 50, coercions: 0, joins: 0/0}
Data.Data.$fDataM1_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall p (f :: * -> *) (c :: Meta) i.
     (Data p, Data (f p), Typeable c, Typeable i, Typeable f) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> M1 i c f p -> m (M1 i c f p)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,A><L,U><L,A><L,A><L,A><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=8,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ p_segvH)
                 (@ (f_segvI :: * -> *))
                 (@ (c_segvJ :: Meta))
                 (@ i_segvK)
                 _ [Occ=Dead]
                 (w1_segvM [Occ=Once] :: Data (f_segvI p_segvH))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (@ (m_segvQ :: * -> *))
                 (w5_segvR [Occ=Once] :: Monad m_segvQ)
                 (w6_segvS [Occ=Once] :: forall d. Data d => d -> m_segvQ d)
                 (w7_segvT [Occ=Once] :: M1 i_segvK c_segvJ f_segvI p_segvH) ->
                 Data.Data.$w$cgmapM12
                   @ p_segvH
                   @ f_segvI
                   @ c_segvJ
                   @ i_segvK
                   w1_segvM
                   @ m_segvQ
                   w5_segvR
                   w6_segvS
                   w7_segvT}]
Data.Data.$fDataM1_$cgmapM
  = \ (@ p_segvH)
      (@ (f_segvI :: * -> *))
      (@ (c_segvJ :: Meta))
      (@ i_segvK)
      _ [Occ=Dead]
      (w1_segvM :: Data (f_segvI p_segvH))
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (@ (m_segvQ :: * -> *))
      (w5_segvR :: Monad m_segvQ)
      (w6_segvS :: forall d. Data d => d -> m_segvQ d)
      (w7_segvT :: M1 i_segvK c_segvJ f_segvI p_segvH) ->
      Data.Data.$w$cgmapM12
        @ p_segvH
        @ f_segvI
        @ c_segvJ
        @ i_segvK
        w1_segvM
        @ m_segvQ
        w5_segvR
        w6_segvS
        w7_segvT

-- RHS size: {terms: 70, types: 255, coercions: 21, joins: 0/3}
Data.Data.$w$cgmapMo23 [InlPrag=NOUSERINLINE[0]]
  :: forall p (f :: * -> *) (c :: Meta) i.
     Data (f p) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> M1 i c f p -> m (M1 i c f p)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 590 0}]
Data.Data.$w$cgmapMo23
  = \ (@ p_segvV)
      (@ (f_segvW :: * -> *))
      (@ (c_segvX :: Meta))
      (@ i_segvY)
      (w_segw0 :: Data (f_segvW p_segvV))
      (@ (m_segw4 :: * -> *))
      (w1_segw5 :: MonadPlus m_segw4)
      (w2_segw6 :: forall d. Data d => d -> m_segw4 d)
      (w3_segw7 :: M1 i_segvY c_segvX f_segvW p_segvV) ->
      let {
        lvl270_se9RW :: m_segw4 (M1 i_segvY c_segvX f_segvW p_segvV)
        [LclId]
        lvl270_se9RW
          = mzero
              @ m_segw4 w1_segw5 @ (M1 i_segvY c_segvX f_segvW p_segvV) } in
      let {
        $dMonad_se9q9 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_segw4
        [LclId]
        $dMonad_se9q9 = GHC.Base.$p2MonadPlus @ m_segw4 w1_segw5 } in
      >>=
        @ m_segw4
        $dMonad_se9q9
        @ (M1 i_segvY c_segvX f_segvW p_segvV, Bool)
        @ (M1 i_segvY c_segvX f_segvW p_segvV)
        (let {
           lvl271_se9RV :: m_segw4 (f_segvW p_segvV)
           [LclId]
           lvl271_se9RV
             = w2_segw6
                 @ (f_segvW p_segvV)
                 w_segw0
                 (w3_segw7
                  `cast` (GHC.Generics.N:M1[0]
                              <*>_N <i_segvY>_P <c_segvX>_P <f_segvW>_R <p_segvV>_N
                          :: (M1 i_segvY c_segvX f_segvW p_segvV :: *)
                             ~R# (f_segvW p_segvV :: *))) } in
         >>=
           @ m_segw4
           $dMonad_se9q9
           @ (f_segvW p_segvV -> M1 i_segvY c_segvX f_segvW p_segvV, Bool)
           @ (M1 i_segvY c_segvX f_segvW p_segvV, Bool)
           (return
              @ m_segw4
              $dMonad_se9q9
              @ (f_segvW p_segvV -> M1 i_segvY c_segvX f_segvW p_segvV, Bool)
              (Data.Data.$fDataM2 @ f_segvW @ p_segvV @ i_segvY @ c_segvX))
           (\ (ds_de7pD
                 :: (f_segvW p_segvV -> M1 i_segvY c_segvX f_segvW p_segvV,
                     Bool)) ->
              case ds_de7pD of { (h_ae1TP, b_ae1TQ) ->
              case b_ae1TQ of {
                False ->
                  mplus
                    @ m_segw4
                    w1_segw5
                    @ (M1 i_segvY c_segvX f_segvW p_segvV, Bool)
                    (>>=
                       @ m_segw4
                       $dMonad_se9q9
                       @ (f_segvW p_segvV)
                       @ (M1 i_segvY c_segvX f_segvW p_segvV, Bool)
                       lvl271_se9RV
                       (\ (y'_ae1TR :: f_segvW p_segvV) ->
                          return
                            @ m_segw4
                            $dMonad_se9q9
                            @ (M1 i_segvY c_segvX f_segvW p_segvV, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_segw4
                       $dMonad_se9q9
                       @ (M1 i_segvY c_segvX f_segvW p_segvV, Bool)
                       (h_ae1TP
                          (w3_segw7
                           `cast` (GHC.Generics.N:M1[0]
                                       <*>_N <i_segvY>_P <c_segvX>_P <f_segvW>_R <p_segvV>_N
                                   :: (M1 i_segvY c_segvX f_segvW p_segvV :: *)
                                      ~R# (f_segvW p_segvV :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_segw4
                    $dMonad_se9q9
                    @ (M1 i_segvY c_segvX f_segvW p_segvV, Bool)
                    (h_ae1TP
                       (w3_segw7
                        `cast` (GHC.Generics.N:M1[0]
                                    <*>_N <i_segvY>_P <c_segvX>_P <f_segvW>_R <p_segvV>_N
                                :: (M1 i_segvY c_segvX f_segvW p_segvV :: *)
                                   ~R# (f_segvW p_segvV :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds_de7pa :: (M1 i_segvY c_segvX f_segvW p_segvV, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9RW;
             True ->
               return
                 @ m_segw4
                 $dMonad_se9q9
                 @ (M1 i_segvY c_segvX f_segvW p_segvV)
                 x'_ae1TS
           }
           })

-- RHS size: {terms: 18, types: 50, coercions: 0, joins: 0/0}
Data.Data.$fDataM1_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall p (f :: * -> *) (c :: Meta) i.
     (Data p, Data (f p), Typeable c, Typeable i, Typeable f) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> M1 i c f p -> m (M1 i c f p)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,A><L,U><L,A><L,A><L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=8,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ p_segvV)
                 (@ (f_segvW :: * -> *))
                 (@ (c_segvX :: Meta))
                 (@ i_segvY)
                 _ [Occ=Dead]
                 (w1_segw0 [Occ=Once] :: Data (f_segvW p_segvV))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (@ (m_segw4 :: * -> *))
                 (w5_segw5 [Occ=Once] :: MonadPlus m_segw4)
                 (w6_segw6 [Occ=Once] :: forall d. Data d => d -> m_segw4 d)
                 (w7_segw7 [Occ=Once] :: M1 i_segvY c_segvX f_segvW p_segvV) ->
                 Data.Data.$w$cgmapMo23
                   @ p_segvV
                   @ f_segvW
                   @ c_segvX
                   @ i_segvY
                   w1_segw0
                   @ m_segw4
                   w5_segw5
                   w6_segw6
                   w7_segw7}]
Data.Data.$fDataM1_$cgmapMo
  = \ (@ p_segvV)
      (@ (f_segvW :: * -> *))
      (@ (c_segvX :: Meta))
      (@ i_segvY)
      _ [Occ=Dead]
      (w1_segw0 :: Data (f_segvW p_segvV))
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (@ (m_segw4 :: * -> *))
      (w5_segw5 :: MonadPlus m_segw4)
      (w6_segw6 :: forall d. Data d => d -> m_segw4 d)
      (w7_segw7 :: M1 i_segvY c_segvX f_segvW p_segvV) ->
      Data.Data.$w$cgmapMo23
        @ p_segvV
        @ f_segvW
        @ c_segvX
        @ i_segvY
        w1_segw0
        @ m_segw4
        w5_segw5
        w6_segw6
        w7_segw7

-- RHS size: {terms: 6, types: 15, coercions: 0, joins: 0/0}
lvl203_rejTt
  :: forall i (c :: Meta) (f :: * -> *) p. M1 i c f p -> Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl203_rejTt
  = \ (@ i_Xe4cI)
      (@ (c_Xe4cG :: Meta))
      (@ (f_Xe4cE :: * -> *))
      (@ p_Xe4cC)
      _ [Occ=Dead] ->
      Data.Data.$cM1

-- RHS size: {terms: 6, types: 15, coercions: 0, joins: 0/0}
lvl204_rejTu
  :: forall i (c :: Meta) (f :: * -> *) p. M1 i c f p -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl204_rejTu
  = \ (@ i_Xe4cI)
      (@ (c_Xe4cG :: Meta))
      (@ (f_Xe4cE :: * -> *))
      (@ p_Xe4cC)
      _ [Occ=Dead] ->
      Data.Data.$tM1

-- RHS size: {terms: 9, types: 37, coercions: 0, joins: 0/0}
lvl205_rejTv
  :: forall i (c1 :: Meta) (f :: * -> *) p (t :: * -> *) (c2 :: *
                                                                -> *).
     Typeable t =>
     (forall d. Data d => c2 (t d)) -> Maybe (c2 (M1 i c1 f p))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl205_rejTv
  = \ (@ i_Xe4cI)
      (@ (c_Xe4cG :: Meta))
      (@ (f_Xe4cE :: * -> *))
      (@ p_Xe4cC)
      (@ (t_ae3u3 :: * -> *))
      (@ (c1_ae3u4 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c1_ae3u4 (M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC))

-- RHS size: {terms: 9, types: 46, coercions: 0, joins: 0/0}
lvl206_rejTw
  :: forall i (c1 :: Meta) (f :: * -> *) p (t :: *
                                                 -> * -> *) (c2 :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c2 (t d e))
     -> Maybe (c2 (M1 i c1 f p))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl206_rejTw
  = \ (@ i_Xe4cI)
      (@ (c_Xe4cG :: Meta))
      (@ (f_Xe4cE :: * -> *))
      (@ p_Xe4cC)
      (@ (t_ae3um :: * -> * -> *))
      (@ (c1_ae3un :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c1_ae3un (M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC))

-- RHS size: {terms: 113, types: 318, coercions: 98, joins: 0/0}
Data.Data.$fDataM1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall p (f :: * -> *) (c :: Meta) i.
     (Data p, Data (f p), Typeable c, Typeable i, Typeable f) =>
     Data (M1 i c f p)
[GblId[DFunId],
 Arity=5,
 Str=<L,1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U><L,U>,
 Unf=DFun: \ (@ p_ae1X0)
             (@ (f_ae1X1 :: * -> *))
             (@ (c_ae1X2 :: Meta))
             (@ i_ae1X3)
             (v_XN1 :: Data p_ae1X0)
             (v1_XN3 :: Data (f_ae1X1 p_ae1X0))
             (v2_XN5 :: Typeable c_ae1X2)
             (v3_XN7 :: Typeable i_ae1X3)
             (v4_B5 :: Typeable f_ae1X1) ->
       Data.Data.C:Data TYPE: M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0
                        (Data.Data.$fDataM7
                           @ p_ae1X0
                           @ f_ae1X1
                           @ c_ae1X2
                           @ i_ae1X3
                           v_XN1
                           v1_XN3
                           v2_XN5
                           v3_XN7
                           v4_B5)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <M1
                                                                                    i_ae1X3
                                                                                    c_ae1X2
                                                                                    f_ae1X1
                                                                                    p_ae1X0>_N
                                :: (Data.Typeable.Internal.TypeRep
                                      (M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0) :: *)
                                   ~R# (Typeable
                                          (M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0) :: Constraint))
                        \ (@ (c1_ae3tr :: * -> *))
                          (k_ae2nC [Occ=Once!]
                             :: forall d b. Data d => c1_ae3tr (d -> b) -> d -> c1_ae3tr b)
                          (z_ae2nD [Occ=Once!] :: forall g. g -> c1_ae3tr g)
                          (ds_de7ty [Occ=Once] :: M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0) ->
                          k_ae2nC
                            @ (f_ae1X1 p_ae1X0)
                            @ (M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0)
                            v1_XN3
                            (z_ae2nD
                               @ (f_ae1X1 p_ae1X0 -> M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0)
                               ((\ (v5_XJG [Occ=Once] :: f_ae1X1 p_ae1X0) -> v5_XJG)
                                `cast` (<f_ae1X1 p_ae1X0>_R
                                        ->_R Sym (GHC.Generics.N:M1[0]
                                                      <*>_N
                                                      <i_ae1X3>_P
                                                      <c_ae1X2>_P
                                                      <f_ae1X1>_R) <p_ae1X0>_N
                                        :: (f_ae1X1 p_ae1X0 -> f_ae1X1 p_ae1X0 :: *)
                                           ~R# (f_ae1X1 p_ae1X0
                                                -> M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0 :: *))))
                            (ds_de7ty
                             `cast` (GHC.Generics.N:M1[0]
                                         <*>_N <i_ae1X3>_P <c_ae1X2>_P <f_ae1X1>_R <p_ae1X0>_N
                                     :: (M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0 :: *)
                                        ~R# (f_ae1X1 p_ae1X0 :: *)))
                        \ (@ (c1_ae3tG :: * -> *))
                          (k_ae2nF [Occ=Once!]
                             :: forall b r. Data b => c1_ae3tG (b -> r) -> c1_ae3tG r)
                          (z_ae2nG [Occ=Once!] :: forall r. r -> c1_ae3tG r)
                          _ [Occ=Dead] ->
                          k_ae2nF
                            @ (f_ae1X1 p_ae1X0)
                            @ (M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0)
                            v1_XN3
                            (z_ae2nG
                               @ (f_ae1X1 p_ae1X0 -> M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0)
                               ((\ (v5_XJG [Occ=Once] :: f_ae1X1 p_ae1X0) -> v5_XJG)
                                `cast` (<f_ae1X1 p_ae1X0>_R
                                        ->_R Sym (GHC.Generics.N:M1[0]
                                                      <*>_N
                                                      <i_ae1X3>_P
                                                      <c_ae1X2>_P
                                                      <f_ae1X1>_R) <p_ae1X0>_N
                                        :: (f_ae1X1 p_ae1X0 -> f_ae1X1 p_ae1X0 :: *)
                                           ~R# (f_ae1X1 p_ae1X0
                                                -> M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0 :: *))))
                        \ _ [Occ=Dead] -> Data.Data.$cM1
                        \ _ [Occ=Dead] -> Data.Data.$tM1
                        \ (@ (t_ae3u3 :: * -> *))
                          (@ (c1_ae3u4 :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c1_ae3u4 (M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0))
                        \ (@ (t_ae3um :: * -> * -> *))
                          (@ (c1_ae3un :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c1_ae3un (M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0))
                        (\ (ds_de7tF [Occ=Once!] :: forall b. Data b => b -> b)
                           (x0_Xe36f [Occ=Once] :: M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0) ->
                           ds_de7tF
                             @ (f_ae1X1 p_ae1X0)
                             v1_XN3
                             (x0_Xe36f
                              `cast` (GHC.Generics.N:M1[0]
                                          <*>_N <i_ae1X3>_P <c_ae1X2>_P <f_ae1X1>_R <p_ae1X0>_N
                                      :: (M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0 :: *)
                                         ~R# (f_ae1X1 p_ae1X0 :: *))))
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0>_R
                                ->_R Sym (GHC.Generics.N:M1[0]
                                              <*>_N <i_ae1X3>_P <c_ae1X2>_P <f_ae1X1>_R) <p_ae1X0>_N
                                :: ((forall b. Data b => b -> b)
                                    -> M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0 -> f_ae1X1 p_ae1X0 :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0
                                        -> M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0 :: *))
                        \ (@ r_ae3uU)
                          (@ r'_ae3uV)
                          (ds_de7tG [Occ=Once!] :: r_ae3uU -> r'_ae3uV -> r_ae3uU)
                          (ds1_de7tH [Occ=Once] :: r_ae3uU)
                          (ds2_de7tI [Occ=Once!] :: forall d. Data d => d -> r'_ae3uV)
                          (eta_XMX [Occ=Once] :: M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0) ->
                          ds_de7tG
                            ds1_de7tH
                            (ds2_de7tI
                               @ (f_ae1X1 p_ae1X0)
                               v1_XN3
                               (eta_XMX
                                `cast` (GHC.Generics.N:M1[0]
                                            <*>_N <i_ae1X3>_P <c_ae1X2>_P <f_ae1X1>_R <p_ae1X0>_N
                                        :: (M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0 :: *)
                                           ~R# (f_ae1X1 p_ae1X0 :: *))))
                        \ (@ r_ae3vb)
                          (@ r'_ae3vc)
                          (ds_de7tJ [Occ=Once!] :: r'_ae3vc -> r_ae3vb -> r_ae3vb)
                          (ds1_de7tK [Occ=Once] :: r_ae3vb)
                          (ds2_de7tL [Occ=Once!] :: forall d. Data d => d -> r'_ae3vc)
                          (x0_ae1SX [Occ=Once] :: M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0) ->
                          ds_de7tJ
                            (ds2_de7tL
                               @ (f_ae1X1 p_ae1X0)
                               v1_XN3
                               (x0_ae1SX
                                `cast` (GHC.Generics.N:M1[0]
                                            <*>_N <i_ae1X3>_P <c_ae1X2>_P <f_ae1X1>_R <p_ae1X0>_N
                                        :: (M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0 :: *)
                                           ~R# (f_ae1X1 p_ae1X0 :: *))))
                            ds1_de7tK
                        \ (@ u_ae3vs)
                          (ds_de7tM [Occ=Once!] :: forall d. Data d => d -> u_ae3vs)
                          (x0_ae1SX [Occ=Once] :: M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0) ->
                          GHC.Types.:
                            @ u_ae3vs
                            (ds_de7tM
                               @ (f_ae1X1 p_ae1X0)
                               v1_XN3
                               (x0_ae1SX
                                `cast` (GHC.Generics.N:M1[0]
                                            <*>_N <i_ae1X3>_P <c_ae1X2>_P <f_ae1X1>_R <p_ae1X0>_N
                                        :: (M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0 :: *)
                                           ~R# (f_ae1X1 p_ae1X0 :: *))))
                            (GHC.Types.[] @ u_ae3vs)
                        \ (@ u_ae3vG)
                          (ds_de7tN [Occ=Once] :: Int)
                          (ds1_de7tO [Occ=Once!] :: forall d. Data d => d -> u_ae3vG)
                          (x_ae1T7 [Occ=Once] :: M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0) ->
                          case eqInt ds_de7tN Data.Data.$fData:.:3 of {
                            False -> Data.Maybe.fromJust1 @ u_ae3vG;
                            True ->
                              ds1_de7tO
                                @ (f_ae1X1 p_ae1X0)
                                v1_XN3
                                (x_ae1T7
                                 `cast` (GHC.Generics.N:M1[0]
                                             <*>_N <i_ae1X3>_P <c_ae1X2>_P <f_ae1X1>_R <p_ae1X0>_N
                                         :: (M1 i_ae1X3 c_ae1X2 f_ae1X1 p_ae1X0 :: *)
                                            ~R# (f_ae1X1 p_ae1X0 :: *)))
                          }
                        Data.Data.$fDataM1_$cgmapM
                          @ p_ae1X0
                          @ f_ae1X1
                          @ c_ae1X2
                          @ i_ae1X3
                          v_XN1
                          v1_XN3
                          v2_XN5
                          v3_XN7
                          v4_B5
                        Data.Data.$fDataM1_$cgmapMp
                          @ p_ae1X0
                          @ f_ae1X1
                          @ c_ae1X2
                          @ i_ae1X3
                          v_XN1
                          v1_XN3
                          v2_XN5
                          v3_XN7
                          v4_B5
                        Data.Data.$fDataM1_$cgmapMo
                          @ p_ae1X0
                          @ f_ae1X1
                          @ c_ae1X2
                          @ i_ae1X3
                          v_XN1
                          v1_XN3
                          v2_XN5
                          v3_XN7
                          v4_B5]
Data.Data.$fDataM1
  = \ (@ p_Xe4cC)
      (@ (f_Xe4cE :: * -> *))
      (@ (c_Xe4cG :: Meta))
      (@ i_Xe4cI)
      ($dData_Xe4cK :: Data p_Xe4cC)
      ($dData1_Xe4cM :: Data (f_Xe4cE p_Xe4cC))
      ($dTypeable_Xe4cO :: Typeable c_Xe4cG)
      ($dTypeable1_Xe4cQ :: Typeable i_Xe4cI)
      ($dTypeable2_Xe4cS :: Typeable f_Xe4cE) ->
      Data.Data.C:Data
        @ (M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC)
        ((Data.Data.$w$cp1Data1
            @ p_Xe4cC
            @ f_Xe4cE
            @ c_Xe4cG
            @ i_Xe4cI
            $dData_Xe4cK
            $dTypeable_Xe4cO
            $dTypeable1_Xe4cQ
            $dTypeable2_Xe4cS)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <M1
                                                                     i_Xe4cI
                                                                     c_Xe4cG
                                                                     f_Xe4cE
                                                                     p_Xe4cC>_N
                 :: (Data.Typeable.Internal.TypeRep
                       (M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC) :: *)
                    ~R# (Typeable (M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC) :: Constraint)))
        (\ (@ (c1_ae3tr :: * -> *))
           (k_ae2nC
              :: forall d b. Data d => c1_ae3tr (d -> b) -> d -> c1_ae3tr b)
           (z_ae2nD :: forall g. g -> c1_ae3tr g)
           (ds_de7ty :: M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC) ->
           k_ae2nC
             @ (f_Xe4cE p_Xe4cC)
             @ (M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC)
             $dData1_Xe4cM
             (z_ae2nD
                @ (f_Xe4cE p_Xe4cC -> M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC)
                ((Data.Data.$fDataAlt2 @ f_Xe4cE @ p_Xe4cC)
                 `cast` (<f_Xe4cE p_Xe4cC>_R
                         ->_R Sym (GHC.Generics.N:M1[0]
                                       <*>_N <i_Xe4cI>_P <c_Xe4cG>_P <f_Xe4cE>_R) <p_Xe4cC>_N
                         :: (f_Xe4cE p_Xe4cC -> f_Xe4cE p_Xe4cC :: *)
                            ~R# (f_Xe4cE p_Xe4cC -> M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC :: *))))
             (ds_de7ty
              `cast` (GHC.Generics.N:M1[0]
                          <*>_N <i_Xe4cI>_P <c_Xe4cG>_P <f_Xe4cE>_R <p_Xe4cC>_N
                      :: (M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC :: *)
                         ~R# (f_Xe4cE p_Xe4cC :: *))))
        (\ (@ (c1_ae3tG :: * -> *))
           (k_ae2nF :: forall b r. Data b => c1_ae3tG (b -> r) -> c1_ae3tG r)
           (z_ae2nG :: forall r. r -> c1_ae3tG r)
           _ [Occ=Dead] ->
           k_ae2nF
             @ (f_Xe4cE p_Xe4cC)
             @ (M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC)
             $dData1_Xe4cM
             (z_ae2nG
                @ (f_Xe4cE p_Xe4cC -> M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC)
                ((Data.Data.$fDataAlt2 @ f_Xe4cE @ p_Xe4cC)
                 `cast` (<f_Xe4cE p_Xe4cC>_R
                         ->_R Sym (GHC.Generics.N:M1[0]
                                       <*>_N <i_Xe4cI>_P <c_Xe4cG>_P <f_Xe4cE>_R) <p_Xe4cC>_N
                         :: (f_Xe4cE p_Xe4cC -> f_Xe4cE p_Xe4cC :: *)
                            ~R# (f_Xe4cE p_Xe4cC
                                 -> M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC :: *)))))
        (lvl203_rejTt @ i_Xe4cI @ c_Xe4cG @ f_Xe4cE @ p_Xe4cC)
        (lvl204_rejTu @ i_Xe4cI @ c_Xe4cG @ f_Xe4cE @ p_Xe4cC)
        (lvl205_rejTv @ i_Xe4cI @ c_Xe4cG @ f_Xe4cE @ p_Xe4cC)
        (lvl206_rejTw @ i_Xe4cI @ c_Xe4cG @ f_Xe4cE @ p_Xe4cC)
        ((\ (ds_de7tF :: forall b. Data b => b -> b)
            (x0_Xe36f :: M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC) ->
            ds_de7tF
              @ (f_Xe4cE p_Xe4cC)
              $dData1_Xe4cM
              (x0_Xe36f
               `cast` (GHC.Generics.N:M1[0]
                           <*>_N <i_Xe4cI>_P <c_Xe4cG>_P <f_Xe4cE>_R <p_Xe4cC>_N
                       :: (M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC :: *)
                          ~R# (f_Xe4cE p_Xe4cC :: *))))
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC>_R
                 ->_R Sym (GHC.Generics.N:M1[0]
                               <*>_N <i_Xe4cI>_P <c_Xe4cG>_P <f_Xe4cE>_R) <p_Xe4cC>_N
                 :: ((forall b. Data b => b -> b)
                     -> M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC -> f_Xe4cE p_Xe4cC :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC
                         -> M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC :: *)))
        (\ (@ r_ae3uU)
           (@ r'_ae3uV)
           (ds_de7tG :: r_ae3uU -> r'_ae3uV -> r_ae3uU)
           (ds1_de7tH :: r_ae3uU)
           (ds2_de7tI :: forall d. Data d => d -> r'_ae3uV)
           (eta_XMX :: M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC) ->
           ds_de7tG
             ds1_de7tH
             (ds2_de7tI
                @ (f_Xe4cE p_Xe4cC)
                $dData1_Xe4cM
                (eta_XMX
                 `cast` (GHC.Generics.N:M1[0]
                             <*>_N <i_Xe4cI>_P <c_Xe4cG>_P <f_Xe4cE>_R <p_Xe4cC>_N
                         :: (M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC :: *)
                            ~R# (f_Xe4cE p_Xe4cC :: *)))))
        (\ (@ r_ae3vb)
           (@ r'_ae3vc)
           (ds_de7tJ :: r'_ae3vc -> r_ae3vb -> r_ae3vb)
           (ds1_de7tK :: r_ae3vb)
           (ds2_de7tL :: forall d. Data d => d -> r'_ae3vc)
           (x0_ae1SX :: M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC) ->
           ds_de7tJ
             (ds2_de7tL
                @ (f_Xe4cE p_Xe4cC)
                $dData1_Xe4cM
                (x0_ae1SX
                 `cast` (GHC.Generics.N:M1[0]
                             <*>_N <i_Xe4cI>_P <c_Xe4cG>_P <f_Xe4cE>_R <p_Xe4cC>_N
                         :: (M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC :: *)
                            ~R# (f_Xe4cE p_Xe4cC :: *))))
             ds1_de7tK)
        (\ (@ u_ae3vs)
           (ds_de7tM :: forall d. Data d => d -> u_ae3vs)
           (x0_ae1SX :: M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC) ->
           GHC.Types.:
             @ u_ae3vs
             (ds_de7tM
                @ (f_Xe4cE p_Xe4cC)
                $dData1_Xe4cM
                (x0_ae1SX
                 `cast` (GHC.Generics.N:M1[0]
                             <*>_N <i_Xe4cI>_P <c_Xe4cG>_P <f_Xe4cE>_R <p_Xe4cC>_N
                         :: (M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC :: *)
                            ~R# (f_Xe4cE p_Xe4cC :: *))))
             (GHC.Types.[] @ u_ae3vs))
        (\ (@ u_ae3vG)
           (ds_de7tN :: Int)
           (ds1_de7tO :: forall d. Data d => d -> u_ae3vG)
           (x_ae1T7 :: M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC) ->
           case ds_de7tN of { I# x1_a22G ->
           case x1_a22G of {
             __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3vG;
             0# ->
               ds1_de7tO
                 @ (f_Xe4cE p_Xe4cC)
                 $dData1_Xe4cM
                 (x_ae1T7
                  `cast` (GHC.Generics.N:M1[0]
                              <*>_N <i_Xe4cI>_P <c_Xe4cG>_P <f_Xe4cE>_R <p_Xe4cC>_N
                          :: (M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC :: *)
                             ~R# (f_Xe4cE p_Xe4cC :: *)))
           }
           })
        (\ (@ (m_segvQ :: * -> *))
           (w_segvR :: Monad m_segvQ)
           (w1_segvS :: forall d. Data d => d -> m_segvQ d)
           (w2_segvT :: M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC) ->
           Data.Data.$w$cgmapM12
             @ p_Xe4cC
             @ f_Xe4cE
             @ c_Xe4cG
             @ i_Xe4cI
             $dData1_Xe4cM
             @ m_segvQ
             w_segvR
             w1_segvS
             w2_segvT)
        (\ (@ (m_segvC :: * -> *))
           (w_segvD :: MonadPlus m_segvC)
           (w1_segvE :: forall d. Data d => d -> m_segvC d)
           (w2_segvF :: M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC) ->
           Data.Data.$w$cgmapMp24
             @ p_Xe4cC
             @ f_Xe4cE
             @ c_Xe4cG
             @ i_Xe4cI
             $dData1_Xe4cM
             @ m_segvC
             w_segvD
             w1_segvE
             w2_segvF)
        (\ (@ (m_segw4 :: * -> *))
           (w_segw5 :: MonadPlus m_segw4)
           (w1_segw6 :: forall d. Data d => d -> m_segw4 d)
           (w2_segw7 :: M1 i_Xe4cI c_Xe4cG f_Xe4cE p_Xe4cC) ->
           Data.Data.$w$cgmapMo23
             @ p_Xe4cC
             @ f_Xe4cE
             @ c_Xe4cG
             @ i_Xe4cI
             $dData1_Xe4cM
             @ m_segw4
             w_segw5
             w1_segw6
             w2_segw7)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$t:+:1_rejTx :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$t:+:1_rejTx = ":+:"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$t:+:2_rejTy :: [Char]
[GblId]
$t:+:2_rejTy = unpackCString# $t:+:1_rejTx

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str24_rejTz :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str24_rejTz = "L1"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str25_rejTA :: String
[GblId]
str25_rejTA = unpackCString# str24_rejTz

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str26_rejTB :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str26_rejTB = "R1"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str27_rejTC :: String
[GblId]
str27_rejTC = unpackCString# str26_rejTB

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go40_rejTD :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go40_rejTD
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str27_rejTC of {
                False -> go40_rejTD ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go41_rejTE :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go41_rejTE
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str25_rejTA of {
                False -> go41_rejTE ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cR2_rejTF :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cR2_rejTF = Data.Data.AlgConstr $cR3_rejTL

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cL2_rejTG :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cL2_rejTG = Data.Data.AlgConstr $cL3_rejTK

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cR1 [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cR1
  = Data.Data.Constr
      $cR2_rejTF
      str27_rejTC
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$t:+:

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$t:+:3_rejTH :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$t:+:3_rejTH
  = GHC.Types.: @ Constr Data.Data.$cR1 (GHC.Types.[] @ Constr)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$t:+:4_rejTI :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$t:+:4_rejTI = GHC.Types.: @ Constr Data.Data.$cL1 $t:+:3_rejTH

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$t:+:5_rejTJ :: DataRep
[GblId, Str=m1, Unf=OtherCon []]
$t:+:5_rejTJ = Data.Data.AlgRep $t:+:4_rejTI

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$t:+: [Occ=LoopBreaker] :: DataType
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$t:+: = Data.Data.DataType $t:+:2_rejTy $t:+:5_rejTJ

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cL1 [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cL1
  = Data.Data.Constr
      $cL2_rejTG
      str25_rejTA
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$t:+:

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cL3_rejTK :: ConIndex
[GblId]
$cL3_rejTK = go41_rejTE $t:+:4_rejTI Data.Data.mkConstr1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cR3_rejTL :: ConIndex
[GblId]
$cR3_rejTL = go40_rejTD $t:+:4_rejTI Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 6, types: 24, coercions: 0, joins: 0/0}
Data.Data.$fData:+:2
  :: forall (g :: * -> *) (f :: * -> *) p. (f p -> (:+:) f g p, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData:+:2
  = \ (@ (g_Xe49n :: * -> *)) (@ (f_Xe49l :: * -> *)) (@ p_Xe49p) ->
      (GHC.Generics.L1 @ * @ f_Xe49l @ g_Xe49n @ p_Xe49p,
       GHC.Types.False)

-- RHS size: {terms: 6, types: 24, coercions: 0, joins: 0/0}
Data.Data.$fData:+:1
  :: forall (g :: * -> *) (f :: * -> *) p. (g p -> (:+:) f g p, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData:+:1
  = \ (@ (g_Xe49n :: * -> *)) (@ (f_Xe49l :: * -> *)) (@ p_Xe49p) ->
      (GHC.Generics.R1 @ * @ f_Xe49l @ g_Xe49n @ p_Xe49p,
       GHC.Types.False)

-- RHS size: {terms: 80, types: 222, coercions: 26, joins: 0/4}
Data.Data.$w$cgmapMp2 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Data (f p), Data (g p)) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> (:+:) f g p -> m ((:+:) f g p)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 90 60 100] 680 0}]
Data.Data.$w$cgmapMp2
  = \ (@ (f_segwi :: * -> *))
      (@ (g_segwj :: * -> *))
      (@ p_segwk)
      (w_segwo :: Data (f_segwi p_segwk))
      (w1_segwp :: Data (g_segwj p_segwk))
      (@ (m_segwq :: * -> *))
      (w2_segwr :: MonadPlus m_segwq)
      (w3_segws :: forall d. Data d => d -> m_segwq d)
      (w4_segwt :: (:+:) f_segwi g_segwj p_segwk) ->
      let {
        lvl270_se9Sf :: m_segwq ((:+:) f_segwi g_segwj p_segwk)
        [LclId]
        lvl270_se9Sf
          = mzero @ m_segwq w2_segwr @ ((:+:) f_segwi g_segwj p_segwk) } in
      let {
        $dMonad_se9q7 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_segwq
        [LclId]
        $dMonad_se9q7 = GHC.Base.$p2MonadPlus @ m_segwq w2_segwr } in
      >>=
        @ m_segwq
        $dMonad_se9q7
        @ ((:+:) f_segwi g_segwj p_segwk, Bool)
        @ ((:+:) f_segwi g_segwj p_segwk)
        (let {
           k_se9q6 [Dmd=<C(C(C(S))),1*C1(C1(C1(U)))>]
             :: forall d b.
                Data d =>
                Mp m_segwq (d -> b) -> d -> m_segwq (b, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_se9q6
             = \ (@ d_ae2Ws)
                 (@ b_ae2Wt)
                 ($dData_ae2Wv [OS=OneShot] :: Data d_ae2Ws)
                 (ds_de7oC [OS=OneShot] :: Mp m_segwq (d_ae2Ws -> b_ae2Wt))
                 (y_ae1Tz [OS=OneShot] :: d_ae2Ws) ->
                 let {
                   lvl271_se9Sc :: m_segwq d_ae2Ws
                   [LclId]
                   lvl271_se9Sc = w3_segws @ d_ae2Ws $dData_ae2Wv y_ae1Tz } in
                 >>=
                   @ m_segwq
                   $dMonad_se9q7
                   @ (d_ae2Ws -> b_ae2Wt, Bool)
                   @ (b_ae2Wt, Bool)
                   (ds_de7oC
                    `cast` (Data.Data.N:Mp[0] <m_segwq>_R <d_ae2Ws -> b_ae2Wt>_N
                            :: (Mp m_segwq (d_ae2Ws -> b_ae2Wt) :: *)
                               ~R# (m_segwq (d_ae2Ws -> b_ae2Wt, Bool) :: *)))
                   (\ (ds1_de7oD :: (d_ae2Ws -> b_ae2Wt, Bool)) ->
                      case ds1_de7oD of { (h_ae1TA, b1_ae1TB) ->
                      mplus
                        @ m_segwq
                        w2_segwr
                        @ (b_ae2Wt, Bool)
                        (>>=
                           @ m_segwq
                           $dMonad_se9q7
                           @ d_ae2Ws
                           @ (b_ae2Wt, Bool)
                           lvl271_se9Sc
                           (\ (y'_ae1TC :: d_ae2Ws) ->
                              return
                                @ m_segwq
                                $dMonad_se9q7
                                @ (b_ae2Wt, Bool)
                                (h_ae1TA y'_ae1TC, GHC.Types.True)))
                        (return
                           @ m_segwq
                           $dMonad_se9q7
                           @ (b_ae2Wt, Bool)
                           (h_ae1TA y_ae1Tz, b1_ae1TB))
                      }) } in
         case w4_segwt of {
           L1 a1_ae2nv ->
             k_se9q6
               @ (f_segwi p_segwk)
               @ ((:+:) f_segwi g_segwj p_segwk)
               w_segwo
               ((return
                   @ m_segwq
                   $dMonad_se9q7
                   @ (f_segwi p_segwk -> (:+:) f_segwi g_segwj p_segwk, Bool)
                   (Data.Data.$fData:+:2 @ g_segwj @ f_segwi @ p_segwk))
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_segwq>_R <f_segwi p_segwk -> (:+:) f_segwi g_segwj p_segwk>_N)
                        :: (m_segwq (f_segwi p_segwk -> (:+:) f_segwi g_segwj p_segwk,
                                     Bool) :: *)
                           ~R# (Mp
                                  m_segwq (f_segwi p_segwk -> (:+:) f_segwi g_segwj p_segwk) :: *)))
               a1_ae2nv;
           R1 a1_ae2ny ->
             k_se9q6
               @ (g_segwj p_segwk)
               @ ((:+:) f_segwi g_segwj p_segwk)
               w1_segwp
               ((return
                   @ m_segwq
                   $dMonad_se9q7
                   @ (g_segwj p_segwk -> (:+:) f_segwi g_segwj p_segwk, Bool)
                   (Data.Data.$fData:+:1 @ g_segwj @ f_segwi @ p_segwk))
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_segwq>_R <g_segwj p_segwk -> (:+:) f_segwi g_segwj p_segwk>_N)
                        :: (m_segwq (g_segwj p_segwk -> (:+:) f_segwi g_segwj p_segwk,
                                     Bool) :: *)
                           ~R# (Mp
                                  m_segwq (g_segwj p_segwk -> (:+:) f_segwi g_segwj p_segwk) :: *)))
               a1_ae2ny
         })
        (\ (ds_de7oa :: ((:+:) f_segwi g_segwj p_segwk, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9Sf;
             True ->
               return
                 @ m_segwq $dMonad_se9q7 @ ((:+:) f_segwi g_segwj p_segwk) x'_ae1TD
           }
           })

-- RHS size: {terms: 18, types: 53, coercions: 0, joins: 0/0}
Data.Data.$fData:+:_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f p), Data (g p)) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> (:+:) f g p -> m ((:+:) f g p)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=8,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (f_segwi :: * -> *))
                 (@ (g_segwj :: * -> *))
                 (@ p_segwk)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w3_segwo [Occ=Once] :: Data (f_segwi p_segwk))
                 (w4_segwp [Occ=Once] :: Data (g_segwj p_segwk))
                 (@ (m_segwq :: * -> *))
                 (w5_segwr [Occ=Once] :: MonadPlus m_segwq)
                 (w6_segws [Occ=Once] :: forall d. Data d => d -> m_segwq d)
                 (w7_segwt [Occ=Once] :: (:+:) f_segwi g_segwj p_segwk) ->
                 Data.Data.$w$cgmapMp2
                   @ f_segwi
                   @ g_segwj
                   @ p_segwk
                   w3_segwo
                   w4_segwp
                   @ m_segwq
                   w5_segwr
                   w6_segws
                   w7_segwt}]
Data.Data.$fData:+:_$cgmapMp
  = \ (@ (f_segwi :: * -> *))
      (@ (g_segwj :: * -> *))
      (@ p_segwk)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w3_segwo :: Data (f_segwi p_segwk))
      (w4_segwp :: Data (g_segwj p_segwk))
      (@ (m_segwq :: * -> *))
      (w5_segwr :: MonadPlus m_segwq)
      (w6_segws :: forall d. Data d => d -> m_segwq d)
      (w7_segwt :: (:+:) f_segwi g_segwj p_segwk) ->
      Data.Data.$w$cgmapMp2
        @ f_segwi
        @ g_segwj
        @ p_segwk
        w3_segwo
        w4_segwp
        @ m_segwq
        w5_segwr
        w6_segws
        w7_segwt

-- RHS size: {terms: 47, types: 126, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapM4 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Data (f p), Data (g p)) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> (:+:) f g p -> m ((:+:) f g p)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 150 60 100] 390 0}]
Data.Data.$w$cgmapM4
  = \ (@ (f_segwA :: * -> *))
      (@ (g_segwB :: * -> *))
      (@ p_segwC)
      (w_segwG :: Data (f_segwA p_segwC))
      (w1_segwH :: Data (g_segwB p_segwC))
      (@ (m_segwI :: * -> *))
      (w2_segwJ :: Monad m_segwI)
      (w3_segwK :: forall d. Data d => d -> m_segwI d)
      (w4_segwL :: (:+:) f_segwA g_segwB p_segwC) ->
      let {
        k_se9q3 [Dmd=<C(C(C(S))),1*C1(C1(C1(U)))>]
          :: forall d b. Data d => m_segwI (d -> b) -> d -> m_segwI b
        [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
        k_se9q3
          = \ (@ d_ae2Vh)
              (@ b_ae2Vi)
              ($dData_ae2Vk [OS=OneShot] :: Data d_ae2Vh)
              (c_ae1Tm [OS=OneShot] :: m_segwI (d_ae2Vh -> b_ae2Vi))
              (x_ae1Tn [OS=OneShot] :: d_ae2Vh) ->
              let {
                lvl270_se9Sg :: m_segwI d_ae2Vh
                [LclId]
                lvl270_se9Sg = w3_segwK @ d_ae2Vh $dData_ae2Vk x_ae1Tn } in
              >>=
                @ m_segwI
                w2_segwJ
                @ (d_ae2Vh -> b_ae2Vi)
                @ b_ae2Vi
                c_ae1Tm
                (\ (c'_ae1To :: d_ae2Vh -> b_ae2Vi) ->
                   >>=
                     @ m_segwI
                     w2_segwJ
                     @ d_ae2Vh
                     @ b_ae2Vi
                     lvl270_se9Sg
                     (\ (x'_ae1Tp :: d_ae2Vh) ->
                        return @ m_segwI w2_segwJ @ b_ae2Vi (c'_ae1To x'_ae1Tp))) } in
      case w4_segwL of {
        L1 a1_ae2nv ->
          k_se9q3
            @ (f_segwA p_segwC)
            @ ((:+:) f_segwA g_segwB p_segwC)
            w_segwG
            (return
               @ m_segwI
               w2_segwJ
               @ (f_segwA p_segwC -> (:+:) f_segwA g_segwB p_segwC)
               (GHC.Generics.L1 @ * @ f_segwA @ g_segwB @ p_segwC))
            a1_ae2nv;
        R1 a1_ae2ny ->
          k_se9q3
            @ (g_segwB p_segwC)
            @ ((:+:) f_segwA g_segwB p_segwC)
            w1_segwH
            (return
               @ m_segwI
               w2_segwJ
               @ (g_segwB p_segwC -> (:+:) f_segwA g_segwB p_segwC)
               (GHC.Generics.R1 @ * @ f_segwA @ g_segwB @ p_segwC))
            a1_ae2ny
      }

-- RHS size: {terms: 18, types: 53, coercions: 0, joins: 0/0}
Data.Data.$fData:+:_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f p), Data (g p)) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> (:+:) f g p -> m ((:+:) f g p)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=8,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (f_segwA :: * -> *))
                 (@ (g_segwB :: * -> *))
                 (@ p_segwC)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w3_segwG [Occ=Once] :: Data (f_segwA p_segwC))
                 (w4_segwH [Occ=Once] :: Data (g_segwB p_segwC))
                 (@ (m_segwI :: * -> *))
                 (w5_segwJ [Occ=Once] :: Monad m_segwI)
                 (w6_segwK [Occ=Once] :: forall d. Data d => d -> m_segwI d)
                 (w7_segwL [Occ=Once] :: (:+:) f_segwA g_segwB p_segwC) ->
                 Data.Data.$w$cgmapM4
                   @ f_segwA
                   @ g_segwB
                   @ p_segwC
                   w3_segwG
                   w4_segwH
                   @ m_segwI
                   w5_segwJ
                   w6_segwK
                   w7_segwL}]
Data.Data.$fData:+:_$cgmapM
  = \ (@ (f_segwA :: * -> *))
      (@ (g_segwB :: * -> *))
      (@ p_segwC)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w3_segwG :: Data (f_segwA p_segwC))
      (w4_segwH :: Data (g_segwB p_segwC))
      (@ (m_segwI :: * -> *))
      (w5_segwJ :: Monad m_segwI)
      (w6_segwK :: forall d. Data d => d -> m_segwI d)
      (w7_segwL :: (:+:) f_segwA g_segwB p_segwC) ->
      Data.Data.$w$cgmapM4
        @ f_segwA
        @ g_segwB
        @ p_segwC
        w3_segwG
        w4_segwH
        @ m_segwI
        w5_segwJ
        w6_segwK
        w7_segwL

-- RHS size: {terms: 38, types: 67, coercions: 0, joins: 0/0}
Data.Data.$fData:+:_$cgmapQi
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f p), Data (g p)) =>
     forall u. Int -> (forall d. Data d => d -> u) -> (:+:) f g p -> u
[GblId,
 Arity=8,
 Str=<L,A><L,A><L,A><L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=8,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_Xe49j :: * -> *))
                 (@ (g_Xe49l :: * -> *))
                 (@ p_Xe49n)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 ($dData1_Xe49v [Occ=Once] :: Data (f_Xe49j p_Xe49n))
                 ($dData2_Xe49x [Occ=Once] :: Data (g_Xe49l p_Xe49n))
                 (@ u_ae3sc)
                 (ds_de7tt [Occ=Once*!] :: Int)
                 (ds1_de7tu [Occ=Once*!] :: forall d. Data d => d -> u_ae3sc)
                 (x_ae1T7 [Occ=Once!] :: (:+:) f_Xe49j g_Xe49l p_Xe49n) ->
                 case x_ae1T7 of {
                   L1 a1_ae2nv [Occ=Once] ->
                     case ds_de7tt of { I# x1_a22G [Occ=Once!] ->
                     case x1_a22G of {
                       __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3sc;
                       0# -> ds1_de7tu @ (f_Xe49j p_Xe49n) $dData1_Xe49v a1_ae2nv
                     }
                     };
                   R1 a1_ae2ny [Occ=Once] ->
                     case ds_de7tt of { I# x1_a22G [Occ=Once!] ->
                     case x1_a22G of {
                       __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3sc;
                       0# -> ds1_de7tu @ (g_Xe49l p_Xe49n) $dData2_Xe49x a1_ae2ny
                     }
                     }
                 }}]
Data.Data.$fData:+:_$cgmapQi
  = \ (@ (f_Xe49j :: * -> *))
      (@ (g_Xe49l :: * -> *))
      (@ p_Xe49n)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      ($dData1_Xe49v :: Data (f_Xe49j p_Xe49n))
      ($dData2_Xe49x :: Data (g_Xe49l p_Xe49n))
      (@ u_ae3sc)
      (ds_de7tt :: Int)
      (ds1_de7tu :: forall d. Data d => d -> u_ae3sc)
      (x_ae1T7 :: (:+:) f_Xe49j g_Xe49l p_Xe49n) ->
      case x_ae1T7 of {
        L1 a1_ae2nv ->
          case ds_de7tt of { I# x1_a22G ->
          case x1_a22G of {
            __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3sc;
            0# -> ds1_de7tu @ (f_Xe49j p_Xe49n) $dData1_Xe49v a1_ae2nv
          }
          };
        R1 a1_ae2ny ->
          case ds_de7tt of { I# x1_a22G ->
          case x1_a22G of {
            __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3sc;
            0# -> ds1_de7tu @ (g_Xe49l p_Xe49n) $dData2_Xe49x a1_ae2ny
          }
          }
      }

-- RHS size: {terms: 28, types: 64, coercions: 0, joins: 0/0}
Data.Data.$fData:+:_$cgmapQr
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f p), Data (g p)) =>
     forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> (:+:) f g p -> r
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,U><L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=9,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_Xe49h :: * -> *))
                 (@ (g_Xe49j :: * -> *))
                 (@ p_Xe49l)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 ($dData1_Xe49t [Occ=Once] :: Data (f_Xe49h p_Xe49l))
                 ($dData2_Xe49v [Occ=Once] :: Data (g_Xe49j p_Xe49l))
                 (@ r_ae3rH)
                 (@ r'_ae3rI)
                 (ds_de7tp [Occ=Once*!] :: r'_ae3rI -> r_ae3rH -> r_ae3rH)
                 (ds1_de7tq [Occ=Once*] :: r_ae3rH)
                 (ds2_de7tr [Occ=Once*!] :: forall d. Data d => d -> r'_ae3rI)
                 (x0_ae1SX [Occ=Once!] :: (:+:) f_Xe49h g_Xe49j p_Xe49l) ->
                 case x0_ae1SX of {
                   L1 a1_ae2nv [Occ=Once] ->
                     ds_de7tp
                       (ds2_de7tr @ (f_Xe49h p_Xe49l) $dData1_Xe49t a1_ae2nv) ds1_de7tq;
                   R1 a1_ae2ny [Occ=Once] ->
                     ds_de7tp
                       (ds2_de7tr @ (g_Xe49j p_Xe49l) $dData2_Xe49v a1_ae2ny) ds1_de7tq
                 }}]
Data.Data.$fData:+:_$cgmapQr
  = \ (@ (f_Xe49h :: * -> *))
      (@ (g_Xe49j :: * -> *))
      (@ p_Xe49l)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      ($dData1_Xe49t :: Data (f_Xe49h p_Xe49l))
      ($dData2_Xe49v :: Data (g_Xe49j p_Xe49l))
      (@ r_ae3rH)
      (@ r'_ae3rI)
      (ds_de7tp :: r'_ae3rI -> r_ae3rH -> r_ae3rH)
      (ds1_de7tq :: r_ae3rH)
      (ds2_de7tr :: forall d. Data d => d -> r'_ae3rI)
      (x0_ae1SX :: (:+:) f_Xe49h g_Xe49j p_Xe49l) ->
      case x0_ae1SX of {
        L1 a1_ae2nv ->
          ds_de7tp
            (ds2_de7tr @ (f_Xe49h p_Xe49l) $dData1_Xe49t a1_ae2nv) ds1_de7tq;
        R1 a1_ae2ny ->
          ds_de7tp
            (ds2_de7tr @ (g_Xe49j p_Xe49l) $dData2_Xe49v a1_ae2ny) ds1_de7tq
      }

-- RHS size: {terms: 25, types: 62, coercions: 0, joins: 0/0}
Data.Data.$fData:+:_$cgmapQ
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f p), Data (g p)) =>
     forall u. (forall d. Data d => d -> u) -> (:+:) f g p -> [u]
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,U><L,U><L,1*C1(C1(U))><S,1*U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=7,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_Xe49i :: * -> *))
                 (@ (g_Xe49k :: * -> *))
                 (@ p_Xe49m)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 ($dData1_Xe49u [Occ=Once] :: Data (f_Xe49i p_Xe49m))
                 ($dData2_Xe49w [Occ=Once] :: Data (g_Xe49k p_Xe49m))
                 (@ u_ae3rY)
                 (ds_de7ts [Occ=Once*!] :: forall d. Data d => d -> u_ae3rY)
                 (x0_ae1SX [Occ=Once!] :: (:+:) f_Xe49i g_Xe49k p_Xe49m) ->
                 case x0_ae1SX of {
                   L1 a1_ae2nv [Occ=Once] ->
                     GHC.Types.:
                       @ u_ae3rY
                       (ds_de7ts @ (f_Xe49i p_Xe49m) $dData1_Xe49u a1_ae2nv)
                       (GHC.Types.[] @ u_ae3rY);
                   R1 a1_ae2ny [Occ=Once] ->
                     GHC.Types.:
                       @ u_ae3rY
                       (ds_de7ts @ (g_Xe49k p_Xe49m) $dData2_Xe49w a1_ae2ny)
                       (GHC.Types.[] @ u_ae3rY)
                 }}]
Data.Data.$fData:+:_$cgmapQ
  = \ (@ (f_Xe49i :: * -> *))
      (@ (g_Xe49k :: * -> *))
      (@ p_Xe49m)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      ($dData1_Xe49u :: Data (f_Xe49i p_Xe49m))
      ($dData2_Xe49w :: Data (g_Xe49k p_Xe49m))
      (@ u_ae3rY)
      (ds_de7ts :: forall d. Data d => d -> u_ae3rY)
      (x0_ae1SX :: (:+:) f_Xe49i g_Xe49k p_Xe49m) ->
      case x0_ae1SX of {
        L1 a1_ae2nv ->
          GHC.Types.:
            @ u_ae3rY
            (ds_de7ts @ (f_Xe49i p_Xe49m) $dData1_Xe49u a1_ae2nv)
            (GHC.Types.[] @ u_ae3rY);
        R1 a1_ae2ny ->
          GHC.Types.:
            @ u_ae3rY
            (ds_de7ts @ (g_Xe49k p_Xe49m) $dData2_Xe49w a1_ae2ny)
            (GHC.Types.[] @ u_ae3rY)
      }

-- RHS size: {terms: 28, types: 64, coercions: 22, joins: 0/0}
Data.Data.$fData:+:3
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f p), Data (g p)) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data d => d -> r')
     -> (:+:) f g p
     -> Const r ((:+:) f g p)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,U><L,U><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=9,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_Xe49g :: * -> *))
                 (@ (g_Xe49i :: * -> *))
                 (@ p_Xe49k)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 ($dData1_Xe49s [Occ=Once] :: Data (f_Xe49g p_Xe49k))
                 ($dData2_Xe49u [Occ=Once] :: Data (g_Xe49i p_Xe49k))
                 (@ r_ae3rq)
                 (@ r'_ae3rr)
                 (ds_de7tm [Occ=Once*!] :: r_ae3rq -> r'_ae3rr -> r_ae3rq)
                 (ds1_de7tn [Occ=Once*] :: r_ae3rq)
                 (ds2_de7to [Occ=Once*!] :: forall d. Data d => d -> r'_ae3rr)
                 (eta_XNn [Occ=Once!] :: (:+:) f_Xe49g g_Xe49i p_Xe49k) ->
                 case eta_XNn of {
                   L1 a1_ae2nv [Occ=Once] ->
                     (ds_de7tm
                        ds1_de7tn (ds2_de7to @ (f_Xe49g p_Xe49k) $dData1_Xe49s a1_ae2nv))
                     `cast` (Sym (Data.Functor.Const.N:Const[0]
                                      <*>_N <r_ae3rq>_R <(:+:) f_Xe49g g_Xe49i p_Xe49k>_P)
                             :: (r_ae3rq :: *)
                                ~R# (Const r_ae3rq ((:+:) f_Xe49g g_Xe49i p_Xe49k) :: *));
                   R1 a1_ae2ny [Occ=Once] ->
                     (ds_de7tm
                        ds1_de7tn (ds2_de7to @ (g_Xe49i p_Xe49k) $dData2_Xe49u a1_ae2ny))
                     `cast` (Sym (Data.Functor.Const.N:Const[0]
                                      <*>_N <r_ae3rq>_R <(:+:) f_Xe49g g_Xe49i p_Xe49k>_P)
                             :: (r_ae3rq :: *)
                                ~R# (Const r_ae3rq ((:+:) f_Xe49g g_Xe49i p_Xe49k) :: *))
                 }}]
Data.Data.$fData:+:3
  = \ (@ (f_Xe49g :: * -> *))
      (@ (g_Xe49i :: * -> *))
      (@ p_Xe49k)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      ($dData1_Xe49s :: Data (f_Xe49g p_Xe49k))
      ($dData2_Xe49u :: Data (g_Xe49i p_Xe49k))
      (@ r_ae3rq)
      (@ r'_ae3rr)
      (ds_de7tm :: r_ae3rq -> r'_ae3rr -> r_ae3rq)
      (ds1_de7tn :: r_ae3rq)
      (ds2_de7to :: forall d. Data d => d -> r'_ae3rr)
      (eta_XNn :: (:+:) f_Xe49g g_Xe49i p_Xe49k) ->
      case eta_XNn of {
        L1 a1_ae2nv ->
          (ds_de7tm
             ds1_de7tn (ds2_de7to @ (f_Xe49g p_Xe49k) $dData1_Xe49s a1_ae2nv))
          `cast` (Sym (Data.Functor.Const.N:Const[0]
                           <*>_N <r_ae3rq>_R <(:+:) f_Xe49g g_Xe49i p_Xe49k>_P)
                  :: (r_ae3rq :: *)
                     ~R# (Const r_ae3rq ((:+:) f_Xe49g g_Xe49i p_Xe49k) :: *));
        R1 a1_ae2ny ->
          (ds_de7tm
             ds1_de7tn (ds2_de7to @ (g_Xe49i p_Xe49k) $dData2_Xe49u a1_ae2ny))
          `cast` (Sym (Data.Functor.Const.N:Const[0]
                           <*>_N <r_ae3rq>_R <(:+:) f_Xe49g g_Xe49i p_Xe49k>_P)
                  :: (r_ae3rq :: *)
                     ~R# (Const r_ae3rq ((:+:) f_Xe49g g_Xe49i p_Xe49k) :: *))
      }

-- RHS size: {terms: 22, types: 66, coercions: 16, joins: 0/0}
Data.Data.$fData:+:4
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f p), Data (g p)) =>
     (forall b. Data b => b -> b)
     -> (:+:) f g p -> Identity ((:+:) f g p)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,U><L,U><L,1*C1(C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=7,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_Xe49f :: * -> *))
                 (@ (g_Xe49h :: * -> *))
                 (@ p_Xe49j)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 ($dData1_Xe49r [Occ=Once] :: Data (f_Xe49f p_Xe49j))
                 ($dData2_Xe49t [Occ=Once] :: Data (g_Xe49h p_Xe49j))
                 (ds_de7tl [Occ=Once*!] :: forall b. Data b => b -> b)
                 (x0_Xe36U [Occ=Once!] :: (:+:) f_Xe49f g_Xe49h p_Xe49j) ->
                 case x0_Xe36U of {
                   L1 a1_ae2nv [Occ=Once] ->
                     (GHC.Generics.L1
                        @ *
                        @ f_Xe49f
                        @ g_Xe49h
                        @ p_Xe49j
                        (ds_de7tl @ (f_Xe49f p_Xe49j) $dData1_Xe49r a1_ae2nv))
                     `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                                      <(:+:) f_Xe49f g_Xe49h p_Xe49j>_R)
                             :: ((:+:) f_Xe49f g_Xe49h p_Xe49j :: *)
                                ~R# (Identity ((:+:) f_Xe49f g_Xe49h p_Xe49j) :: *));
                   R1 a1_ae2ny [Occ=Once] ->
                     (GHC.Generics.R1
                        @ *
                        @ f_Xe49f
                        @ g_Xe49h
                        @ p_Xe49j
                        (ds_de7tl @ (g_Xe49h p_Xe49j) $dData2_Xe49t a1_ae2ny))
                     `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                                      <(:+:) f_Xe49f g_Xe49h p_Xe49j>_R)
                             :: ((:+:) f_Xe49f g_Xe49h p_Xe49j :: *)
                                ~R# (Identity ((:+:) f_Xe49f g_Xe49h p_Xe49j) :: *))
                 }}]
Data.Data.$fData:+:4
  = \ (@ (f_Xe49f :: * -> *))
      (@ (g_Xe49h :: * -> *))
      (@ p_Xe49j)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      ($dData1_Xe49r :: Data (f_Xe49f p_Xe49j))
      ($dData2_Xe49t :: Data (g_Xe49h p_Xe49j))
      (ds_de7tl :: forall b. Data b => b -> b)
      (x0_Xe36U :: (:+:) f_Xe49f g_Xe49h p_Xe49j) ->
      case x0_Xe36U of {
        L1 a1_ae2nv ->
          (GHC.Generics.L1
             @ *
             @ f_Xe49f
             @ g_Xe49h
             @ p_Xe49j
             (ds_de7tl @ (f_Xe49f p_Xe49j) $dData1_Xe49r a1_ae2nv))
          `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                           <(:+:) f_Xe49f g_Xe49h p_Xe49j>_R)
                  :: ((:+:) f_Xe49f g_Xe49h p_Xe49j :: *)
                     ~R# (Identity ((:+:) f_Xe49f g_Xe49h p_Xe49j) :: *));
        R1 a1_ae2ny ->
          (GHC.Generics.R1
             @ *
             @ f_Xe49f
             @ g_Xe49h
             @ p_Xe49j
             (ds_de7tl @ (g_Xe49h p_Xe49j) $dData2_Xe49t a1_ae2ny))
          `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                           <(:+:) f_Xe49f g_Xe49h p_Xe49j>_R)
                  :: ((:+:) f_Xe49f g_Xe49h p_Xe49j :: *)
                     ~R# (Identity ((:+:) f_Xe49f g_Xe49h p_Xe49j) :: *))
      }

-- RHS size: {terms: 90, types: 229, coercions: 26, joins: 0/4}
Data.Data.$w$cgmapMo2 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Data (f p), Data (g p)) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> (:+:) f g p -> m ((:+:) f g p)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=OtherCon []]
Data.Data.$w$cgmapMo2
  = \ (@ (f_segwS :: * -> *))
      (@ (g_segwT :: * -> *))
      (@ p_segwU)
      (w_segwY :: Data (f_segwS p_segwU))
      (w1_segwZ :: Data (g_segwT p_segwU))
      (@ (m_segx0 :: * -> *))
      (w2_segx1 :: MonadPlus m_segx0)
      (w3_segx2 :: forall d. Data d => d -> m_segx0 d)
      (w4_segx3 :: (:+:) f_segwS g_segwT p_segwU) ->
      let {
        lvl270_se9So :: m_segx0 ((:+:) f_segwS g_segwT p_segwU)
        [LclId]
        lvl270_se9So
          = mzero @ m_segx0 w2_segx1 @ ((:+:) f_segwS g_segwT p_segwU) } in
      let {
        $dMonad_se9pZ [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_segx0
        [LclId]
        $dMonad_se9pZ = GHC.Base.$p2MonadPlus @ m_segx0 w2_segx1 } in
      >>=
        @ m_segx0
        $dMonad_se9pZ
        @ ((:+:) f_segwS g_segwT p_segwU, Bool)
        @ ((:+:) f_segwS g_segwT p_segwU)
        (let {
           k_se9pY [Dmd=<C(C(C(S))),1*C1(C1(C1(U)))>]
             :: forall d b.
                Data d =>
                Mp m_segx0 (d -> b) -> d -> m_segx0 (b, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_se9pY
             = \ (@ d_ae2Ya)
                 (@ b_ae2Yb)
                 ($dData_ae2Yd [OS=OneShot] :: Data d_ae2Ya)
                 (ds_de7pC [OS=OneShot] :: Mp m_segx0 (d_ae2Ya -> b_ae2Yb))
                 (y_ae1TO [OS=OneShot] :: d_ae2Ya) ->
                 let {
                   lvl271_se9Sl :: m_segx0 d_ae2Ya
                   [LclId]
                   lvl271_se9Sl = w3_segx2 @ d_ae2Ya $dData_ae2Yd y_ae1TO } in
                 >>=
                   @ m_segx0
                   $dMonad_se9pZ
                   @ (d_ae2Ya -> b_ae2Yb, Bool)
                   @ (b_ae2Yb, Bool)
                   (ds_de7pC
                    `cast` (Data.Data.N:Mp[0] <m_segx0>_R <d_ae2Ya -> b_ae2Yb>_N
                            :: (Mp m_segx0 (d_ae2Ya -> b_ae2Yb) :: *)
                               ~R# (m_segx0 (d_ae2Ya -> b_ae2Yb, Bool) :: *)))
                   (\ (ds1_de7pD :: (d_ae2Ya -> b_ae2Yb, Bool)) ->
                      case ds1_de7pD of { (h_ae1TP, b1_ae1TQ) ->
                      case b1_ae1TQ of {
                        False ->
                          mplus
                            @ m_segx0
                            w2_segx1
                            @ (b_ae2Yb, Bool)
                            (>>=
                               @ m_segx0
                               $dMonad_se9pZ
                               @ d_ae2Ya
                               @ (b_ae2Yb, Bool)
                               lvl271_se9Sl
                               (\ (y'_ae1TR :: d_ae2Ya) ->
                                  return
                                    @ m_segx0
                                    $dMonad_se9pZ
                                    @ (b_ae2Yb, Bool)
                                    (h_ae1TP y'_ae1TR, GHC.Types.True)))
                            (return
                               @ m_segx0
                               $dMonad_se9pZ
                               @ (b_ae2Yb, Bool)
                               (h_ae1TP y_ae1TO, GHC.Types.False));
                        True ->
                          return
                            @ m_segx0
                            $dMonad_se9pZ
                            @ (b_ae2Yb, Bool)
                            (h_ae1TP y_ae1TO, GHC.Types.True)
                      }
                      }) } in
         case w4_segx3 of {
           L1 a1_ae2nv ->
             k_se9pY
               @ (f_segwS p_segwU)
               @ ((:+:) f_segwS g_segwT p_segwU)
               w_segwY
               ((return
                   @ m_segx0
                   $dMonad_se9pZ
                   @ (f_segwS p_segwU -> (:+:) f_segwS g_segwT p_segwU, Bool)
                   (Data.Data.$fData:+:2 @ g_segwT @ f_segwS @ p_segwU))
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_segx0>_R <f_segwS p_segwU -> (:+:) f_segwS g_segwT p_segwU>_N)
                        :: (m_segx0 (f_segwS p_segwU -> (:+:) f_segwS g_segwT p_segwU,
                                     Bool) :: *)
                           ~R# (Mp
                                  m_segx0 (f_segwS p_segwU -> (:+:) f_segwS g_segwT p_segwU) :: *)))
               a1_ae2nv;
           R1 a1_ae2ny ->
             k_se9pY
               @ (g_segwT p_segwU)
               @ ((:+:) f_segwS g_segwT p_segwU)
               w1_segwZ
               ((return
                   @ m_segx0
                   $dMonad_se9pZ
                   @ (g_segwT p_segwU -> (:+:) f_segwS g_segwT p_segwU, Bool)
                   (Data.Data.$fData:+:1 @ g_segwT @ f_segwS @ p_segwU))
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_segx0>_R <g_segwT p_segwU -> (:+:) f_segwS g_segwT p_segwU>_N)
                        :: (m_segx0 (g_segwT p_segwU -> (:+:) f_segwS g_segwT p_segwU,
                                     Bool) :: *)
                           ~R# (Mp
                                  m_segx0 (g_segwT p_segwU -> (:+:) f_segwS g_segwT p_segwU) :: *)))
               a1_ae2ny
         })
        (\ (ds_de7pa :: ((:+:) f_segwS g_segwT p_segwU, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9So;
             True ->
               return
                 @ m_segx0 $dMonad_se9pZ @ ((:+:) f_segwS g_segwT p_segwU) x'_ae1TS
           }
           })

-- RHS size: {terms: 18, types: 53, coercions: 0, joins: 0/0}
Data.Data.$fData:+:_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f p), Data (g p)) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> (:+:) f g p -> m ((:+:) f g p)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=8,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (f_segwS :: * -> *))
                 (@ (g_segwT :: * -> *))
                 (@ p_segwU)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w3_segwY [Occ=Once] :: Data (f_segwS p_segwU))
                 (w4_segwZ [Occ=Once] :: Data (g_segwT p_segwU))
                 (@ (m_segx0 :: * -> *))
                 (w5_segx1 [Occ=Once] :: MonadPlus m_segx0)
                 (w6_segx2 [Occ=Once] :: forall d. Data d => d -> m_segx0 d)
                 (w7_segx3 [Occ=Once] :: (:+:) f_segwS g_segwT p_segwU) ->
                 Data.Data.$w$cgmapMo2
                   @ f_segwS
                   @ g_segwT
                   @ p_segwU
                   w3_segwY
                   w4_segwZ
                   @ m_segx0
                   w5_segx1
                   w6_segx2
                   w7_segx3}]
Data.Data.$fData:+:_$cgmapMo
  = \ (@ (f_segwS :: * -> *))
      (@ (g_segwT :: * -> *))
      (@ p_segwU)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w3_segwY :: Data (f_segwS p_segwU))
      (w4_segwZ :: Data (g_segwT p_segwU))
      (@ (m_segx0 :: * -> *))
      (w5_segx1 :: MonadPlus m_segx0)
      (w6_segx2 :: forall d. Data d => d -> m_segx0 d)
      (w7_segx3 :: (:+:) f_segwS g_segwT p_segwU) ->
      Data.Data.$w$cgmapMo2
        @ f_segwS
        @ g_segwT
        @ p_segwU
        w3_segwY
        w4_segwZ
        @ m_segx0
        w5_segx1
        w6_segx2
        w7_segx3

-- RHS size: {terms: 10, types: 26, coercions: 0, joins: 0/0}
lvl207_rejTM
  :: forall (g :: * -> *) p (f :: * -> *). (:+:) f g p -> Constr
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []]
lvl207_rejTM
  = \ (@ (g_Xe49e :: * -> *))
      (@ p_Xe4WT)
      (@ (f_Xe49c :: * -> *))
      (ds_de7tf :: (:+:) f_Xe49c g_Xe49e p_Xe4WT) ->
      case ds_de7tf of {
        L1 ds1_de7tg -> Data.Data.$cL1;
        R1 ds1_de7th -> Data.Data.$cR1
      }

-- RHS size: {terms: 5, types: 16, coercions: 0, joins: 0/0}
lvl208_rejTN
  :: forall (f :: * -> *) (g :: * -> *) p. (:+:) f g p -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl208_rejTN
  = \ (@ (f_Xe49c :: * -> *))
      (@ (g_Xe49e :: * -> *))
      (@ p_Xe4WT)
      _ [Occ=Dead] ->
      Data.Data.$t:+:

-- RHS size: {terms: 8, types: 38, coercions: 0, joins: 0/0}
lvl209_rejTO
  :: forall (f :: * -> *) (g :: * -> *) p (t :: * -> *) (c :: *
                                                              -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c ((:+:) f g p))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl209_rejTO
  = \ (@ (f_Xe49c :: * -> *))
      (@ (g_Xe49e :: * -> *))
      (@ p_Xe4WT)
      (@ (t_ae3qz :: * -> *))
      (@ (c_ae3qA :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae3qA ((:+:) f_Xe49c g_Xe49e p_Xe4WT))

-- RHS size: {terms: 8, types: 47, coercions: 0, joins: 0/0}
lvl210_rejTP
  :: forall (f :: * -> *) (g :: * -> *) p (t :: * -> * -> *) (c :: *
                                                                   -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e))
     -> Maybe (c ((:+:) f g p))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl210_rejTP
  = \ (@ (f_Xe49c :: * -> *))
      (@ (g_Xe49e :: * -> *))
      (@ p_Xe4WT)
      (@ (t_ae3qS :: * -> * -> *))
      (@ (c_ae3qT :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae3qT ((:+:) f_Xe49c g_Xe49e p_Xe4WT))

-- RHS size: {terms: 91, types: 141, coercions: 67, joins: 0/0}
Data.Data.$fData:+: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f p), Data (g p)) =>
     Data ((:+:) f g p)
[GblId[DFunId],
 Arity=5,
 Str=<L,U><L,U><L,1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=DFun: \ (@ (f_ae1WX :: * -> *))
             (@ (g_ae1WY :: * -> *))
             (@ p_ae1WZ)
             (v_XNF :: Typeable f_ae1WX)
             (v1_XNH :: Typeable g_ae1WY)
             (v2_XNJ :: Data p_ae1WZ)
             (v3_XNL :: Data (f_ae1WX p_ae1WZ))
             (v4_B5 :: Data (g_ae1WY p_ae1WZ)) ->
       Data.Data.C:Data TYPE: (:+:) f_ae1WX g_ae1WY p_ae1WZ
                        (Data.Data.$fData:+:5
                           @ f_ae1WX @ g_ae1WY @ p_ae1WZ v_XNF v1_XNH v2_XNJ v3_XNL v4_B5)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <(:+:)
                                                                                    f_ae1WX
                                                                                    g_ae1WY
                                                                                    p_ae1WZ>_N
                                :: (Data.Typeable.Internal.TypeRep
                                      ((:+:) f_ae1WX g_ae1WY p_ae1WZ) :: *)
                                   ~R# (Typeable ((:+:) f_ae1WX g_ae1WY p_ae1WZ) :: Constraint))
                        Data.Data.$fData:+:_$cgfoldl
                          @ f_ae1WX @ g_ae1WY @ p_ae1WZ v_XNF v1_XNH v2_XNJ v3_XNL v4_B5
                        Data.Data.$fData:+:_$cgunfold
                          @ f_ae1WX @ g_ae1WY @ p_ae1WZ v_XNF v1_XNH v2_XNJ v3_XNL v4_B5
                        \ (ds_de7tf [Occ=Once!] :: (:+:) f_ae1WX g_ae1WY p_ae1WZ) ->
                          case ds_de7tf of {
                            L1 _ [Occ=Dead] -> Data.Data.$cL1;
                            R1 _ [Occ=Dead] -> Data.Data.$cR1
                          }
                        \ _ [Occ=Dead] -> Data.Data.$t:+:
                        \ (@ (t_ae3qz :: * -> *))
                          (@ (c_ae3qA :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae3qA ((:+:) f_ae1WX g_ae1WY p_ae1WZ))
                        \ (@ (t_ae3qS :: * -> * -> *))
                          (@ (c_ae3qT :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae3qT ((:+:) f_ae1WX g_ae1WY p_ae1WZ))
                        (Data.Data.$fData:+:4
                           @ f_ae1WX @ g_ae1WY @ p_ae1WZ v_XNF v1_XNH v2_XNJ v3_XNL v4_B5)
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <(:+:) f_ae1WX g_ae1WY p_ae1WZ>_R
                                ->_R Data.Functor.Identity.N:Identity[0]
                                         <(:+:) f_ae1WX g_ae1WY p_ae1WZ>_R
                                :: ((forall b. Data b => b -> b)
                                    -> (:+:) f_ae1WX g_ae1WY p_ae1WZ
                                    -> Identity ((:+:) f_ae1WX g_ae1WY p_ae1WZ) :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> (:+:) f_ae1WX g_ae1WY p_ae1WZ
                                        -> (:+:) f_ae1WX g_ae1WY p_ae1WZ :: *))
                        (Data.Data.$fData:+:3
                           @ f_ae1WX @ g_ae1WY @ p_ae1WZ v_XNF v1_XNH v2_XNJ v3_XNL v4_B5)
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <(:+:) f_ae1WX g_ae1WY p_ae1WZ>_R
                                ->_R Data.Functor.Const.N:Const[0]
                                         <*>_N <r>_R <(:+:) f_ae1WX g_ae1WY p_ae1WZ>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> (:+:) f_ae1WX g_ae1WY p_ae1WZ
                                    -> Const r ((:+:) f_ae1WX g_ae1WY p_ae1WZ) :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d. Data d => d -> r')
                                        -> (:+:) f_ae1WX g_ae1WY p_ae1WZ
                                        -> r :: *))
                        Data.Data.$fData:+:_$cgmapQr
                          @ f_ae1WX @ g_ae1WY @ p_ae1WZ v_XNF v1_XNH v2_XNJ v3_XNL v4_B5
                        Data.Data.$fData:+:_$cgmapQ
                          @ f_ae1WX @ g_ae1WY @ p_ae1WZ v_XNF v1_XNH v2_XNJ v3_XNL v4_B5
                        Data.Data.$fData:+:_$cgmapQi
                          @ f_ae1WX @ g_ae1WY @ p_ae1WZ v_XNF v1_XNH v2_XNJ v3_XNL v4_B5
                        Data.Data.$fData:+:_$cgmapM
                          @ f_ae1WX @ g_ae1WY @ p_ae1WZ v_XNF v1_XNH v2_XNJ v3_XNL v4_B5
                        Data.Data.$fData:+:_$cgmapMp
                          @ f_ae1WX @ g_ae1WY @ p_ae1WZ v_XNF v1_XNH v2_XNJ v3_XNL v4_B5
                        Data.Data.$fData:+:_$cgmapMo
                          @ f_ae1WX @ g_ae1WY @ p_ae1WZ v_XNF v1_XNH v2_XNJ v3_XNL v4_B5]
Data.Data.$fData:+:
  = \ (@ (f_Xe49c :: * -> *))
      (@ (g_Xe49e :: * -> *))
      (@ p_Xe4WT)
      ($dTypeable_Xe4WW :: Typeable f_Xe49c)
      ($dTypeable1_Xe4WZ :: Typeable g_Xe49e)
      ($dData_Xe4X2 :: Data p_Xe4WT)
      ($dData1_Xe4X5 :: Data (f_Xe49c p_Xe4WT))
      ($dData2_Xe4X8 :: Data (g_Xe49e p_Xe4WT)) ->
      Data.Data.C:Data
        @ ((:+:) f_Xe49c g_Xe49e p_Xe4WT)
        ((Data.Data.$fData:+:5
            @ f_Xe49c
            @ g_Xe49e
            @ p_Xe4WT
            $dTypeable_Xe4WW
            $dTypeable1_Xe4WZ
            $dData_Xe4X2
            $dData1_Xe4X5
            $dData2_Xe4X8)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <(:+:)
                                                                     f_Xe49c g_Xe49e p_Xe4WT>_N
                 :: (Data.Typeable.Internal.TypeRep
                       ((:+:) f_Xe49c g_Xe49e p_Xe4WT) :: *)
                    ~R# (Typeable ((:+:) f_Xe49c g_Xe49e p_Xe4WT) :: Constraint)))
        (Data.Data.$fData:+:_$cgfoldl
           @ f_Xe49c
           @ g_Xe49e
           @ p_Xe4WT
           $dTypeable_Xe4WW
           $dTypeable1_Xe4WZ
           $dData_Xe4X2
           $dData1_Xe4X5
           $dData2_Xe4X8)
        (Data.Data.$fData:+:_$cgunfold
           @ f_Xe49c
           @ g_Xe49e
           @ p_Xe4WT
           $dTypeable_Xe4WW
           $dTypeable1_Xe4WZ
           $dData_Xe4X2
           $dData1_Xe4X5
           $dData2_Xe4X8)
        (lvl207_rejTM @ g_Xe49e @ p_Xe4WT @ f_Xe49c)
        (lvl208_rejTN @ f_Xe49c @ g_Xe49e @ p_Xe4WT)
        (lvl209_rejTO @ f_Xe49c @ g_Xe49e @ p_Xe4WT)
        (lvl210_rejTP @ f_Xe49c @ g_Xe49e @ p_Xe4WT)
        ((Data.Data.$fData:+:4
            @ f_Xe49c
            @ g_Xe49e
            @ p_Xe4WT
            $dTypeable_Xe4WW
            $dTypeable1_Xe4WZ
            $dData_Xe4X2
            $dData1_Xe4X5
            $dData2_Xe4X8)
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <(:+:) f_Xe49c g_Xe49e p_Xe4WT>_R
                 ->_R Data.Functor.Identity.N:Identity[0]
                          <(:+:) f_Xe49c g_Xe49e p_Xe4WT>_R
                 :: ((forall b. Data b => b -> b)
                     -> (:+:) f_Xe49c g_Xe49e p_Xe4WT
                     -> Identity ((:+:) f_Xe49c g_Xe49e p_Xe4WT) :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> (:+:) f_Xe49c g_Xe49e p_Xe4WT
                         -> (:+:) f_Xe49c g_Xe49e p_Xe4WT :: *)))
        ((Data.Data.$fData:+:3
            @ f_Xe49c
            @ g_Xe49e
            @ p_Xe4WT
            $dTypeable_Xe4WW
            $dTypeable1_Xe4WZ
            $dData_Xe4X2
            $dData1_Xe4X5
            $dData2_Xe4X8)
         `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                 <r -> r' -> r>_R
                 ->_R <r>_R
                 ->_R <forall d. Data d => d -> r'>_R
                 ->_R <(:+:) f_Xe49c g_Xe49e p_Xe4WT>_R
                 ->_R Data.Functor.Const.N:Const[0]
                          <*>_N <r>_R <(:+:) f_Xe49c g_Xe49e p_Xe4WT>_P
                 :: (forall r r'.
                     (r -> r' -> r)
                     -> r
                     -> (forall d. Data d => d -> r')
                     -> (:+:) f_Xe49c g_Xe49e p_Xe4WT
                     -> Const r ((:+:) f_Xe49c g_Xe49e p_Xe4WT) :: *)
                    ~R# (forall r r'.
                         (r -> r' -> r)
                         -> r
                         -> (forall d. Data d => d -> r')
                         -> (:+:) f_Xe49c g_Xe49e p_Xe4WT
                         -> r :: *)))
        (Data.Data.$fData:+:_$cgmapQr
           @ f_Xe49c
           @ g_Xe49e
           @ p_Xe4WT
           $dTypeable_Xe4WW
           $dTypeable1_Xe4WZ
           $dData_Xe4X2
           $dData1_Xe4X5
           $dData2_Xe4X8)
        (Data.Data.$fData:+:_$cgmapQ
           @ f_Xe49c
           @ g_Xe49e
           @ p_Xe4WT
           $dTypeable_Xe4WW
           $dTypeable1_Xe4WZ
           $dData_Xe4X2
           $dData1_Xe4X5
           $dData2_Xe4X8)
        (Data.Data.$fData:+:_$cgmapQi
           @ f_Xe49c
           @ g_Xe49e
           @ p_Xe4WT
           $dTypeable_Xe4WW
           $dTypeable1_Xe4WZ
           $dData_Xe4X2
           $dData1_Xe4X5
           $dData2_Xe4X8)
        (\ (@ (m_segwI :: * -> *))
           (w_segwJ :: Monad m_segwI)
           (w1_segwK :: forall d. Data d => d -> m_segwI d)
           (w2_segwL :: (:+:) f_Xe49c g_Xe49e p_Xe4WT) ->
           Data.Data.$w$cgmapM4
             @ f_Xe49c
             @ g_Xe49e
             @ p_Xe4WT
             $dData1_Xe4X5
             $dData2_Xe4X8
             @ m_segwI
             w_segwJ
             w1_segwK
             w2_segwL)
        (\ (@ (m_segwq :: * -> *))
           (w_segwr :: MonadPlus m_segwq)
           (w1_segws :: forall d. Data d => d -> m_segwq d)
           (w2_segwt :: (:+:) f_Xe49c g_Xe49e p_Xe4WT) ->
           Data.Data.$w$cgmapMp2
             @ f_Xe49c
             @ g_Xe49e
             @ p_Xe4WT
             $dData1_Xe4X5
             $dData2_Xe4X8
             @ m_segwq
             w_segwr
             w1_segws
             w2_segwt)
        (\ (@ (m_segx0 :: * -> *))
           (w_segx1 :: MonadPlus m_segx0)
           (w1_segx2 :: forall d. Data d => d -> m_segx0 d)
           (w2_segx3 :: (:+:) f_Xe49c g_Xe49e p_Xe4WT) ->
           Data.Data.$w$cgmapMo2
             @ f_Xe49c
             @ g_Xe49e
             @ p_Xe4WT
             $dData1_Xe4X5
             $dData2_Xe4X8
             @ m_segx0
             w_segx1
             w1_segx2
             w2_segx3)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData:.:7 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fData:.:7 = ":.:"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData:.:6 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fData:.:6 = unpackCString# Data.Data.$fData:.:7

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$cComp2_rejTQ :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$cComp2_rejTQ = "unComp1"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cComp3_rejTR :: [Char]
[GblId]
$cComp3_rejTR = unpackCString# $cComp2_rejTQ

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$cComp4_rejTS :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cComp4_rejTS
  = GHC.Types.: @ String $cComp3_rejTR (GHC.Types.[] @ String)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str28_rejTT :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str28_rejTT = "Comp1"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str29_rejTU :: String
[GblId]
str29_rejTU = unpackCString# str28_rejTT

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go42_rejTV :: [Constr] -> [Int] -> Int
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go42_rejTV
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str29_rejTU of {
                False -> go42_rejTV ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cComp5_rejTW :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cComp5_rejTW = Data.Data.AlgConstr $cComp6_rejTX

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fData:.:5 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData:.:5
  = GHC.Types.: @ Constr Data.Data.$cComp1 (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData:.:4 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fData:.:4 = Data.Data.AlgRep Data.Data.$fData:.:5

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$t:.: :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$t:.:
  = Data.Data.DataType Data.Data.$fData:.:6 Data.Data.$fData:.:4

-- RHS size: {terms: 6, types: 0, coercions: 0, joins: 0/0}
Data.Data.$cComp1 [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cComp1
  = Data.Data.Constr
      $cComp5_rejTW
      str29_rejTU
      $cComp4_rejTS
      Data.Data.Prefix
      Data.Data.$t:.:

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cComp6_rejTX :: Int
[GblId]
$cComp6_rejTX = go42_rejTV Data.Data.$fData:.:5 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
Data.Data.$fData:.:2
  :: forall (f :: * -> *) (g :: * -> *) p. f (g p) -> f (g p)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (f_Xe4xw :: * -> *))
                 (@ (g_Xe4xy :: * -> *))
                 (@ p_Xe4xA)
                 (v_XKf [Occ=Once] :: f_Xe4xw (g_Xe4xy p_Xe4xA)) ->
                 v_XKf}]
Data.Data.$fData:.:2
  = \ (@ (f_Xe4xw :: * -> *))
      (@ (g_Xe4xy :: * -> *))
      (@ p_Xe4xA)
      (v_XKf :: f_Xe4xw (g_Xe4xy p_Xe4xA)) ->
      v_XKf

-- RHS size: {terms: 6, types: 19, coercions: 11, joins: 0/0}
Data.Data.$fData:.:1
  :: forall (f :: * -> *) (g :: * -> *) p.
     (f (g p) -> (:.:) f g p, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData:.:1
  = \ (@ (f_Xe4xx :: * -> *)) (@ (g_Xe4xz :: * -> *)) (@ p_Xe4xB) ->
      ((Data.Data.$fData:.:2 @ f_Xe4xx @ g_Xe4xz @ p_Xe4xB)
       `cast` (<f_Xe4xx (g_Xe4xz p_Xe4xB)>_R
               ->_R Sym (GHC.Generics.N::.:[0]
                             <*>_N <*>_N <f_Xe4xx>_R <g_Xe4xz>_N <p_Xe4xB>_N)
               :: (f_Xe4xx (g_Xe4xz p_Xe4xB) -> f_Xe4xx (g_Xe4xz p_Xe4xB) :: *)
                  ~R# (f_Xe4xx (g_Xe4xz p_Xe4xB)
                       -> (:.:) f_Xe4xx g_Xe4xz p_Xe4xB :: *)),
       GHC.Types.False)

-- RHS size: {terms: 59, types: 222, coercions: 12, joins: 0/3}
Data.Data.$w$cgmapMp3 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) p.
     Data (f (g p)) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> (:.:) f g p -> m ((:.:) f g p)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 510 0}]
Data.Data.$w$cgmapMp3
  = \ (@ (f_segx7 :: * -> *))
      (@ (g_segx8 :: * -> *))
      (@ p_segx9)
      (w_segxd :: Data (f_segx7 (g_segx8 p_segx9)))
      (@ (m_segxe :: * -> *))
      (w1_segxf :: MonadPlus m_segxe)
      (w2_segxg :: forall d. Data d => d -> m_segxe d)
      (w3_segxh :: (:.:) f_segx7 g_segx8 p_segx9) ->
      let {
        lvl270_se9SH :: m_segxe ((:.:) f_segx7 g_segx8 p_segx9)
        [LclId]
        lvl270_se9SH
          = mzero @ m_segxe w1_segxf @ ((:.:) f_segx7 g_segx8 p_segx9) } in
      let {
        $dMonad_se9pV [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_segxe
        [LclId]
        $dMonad_se9pV = GHC.Base.$p2MonadPlus @ m_segxe w1_segxf } in
      >>=
        @ m_segxe
        $dMonad_se9pV
        @ ((:.:) f_segx7 g_segx8 p_segx9, Bool)
        @ ((:.:) f_segx7 g_segx8 p_segx9)
        (let {
           lvl271_se9SG :: m_segxe (f_segx7 (g_segx8 p_segx9))
           [LclId]
           lvl271_se9SG
             = w2_segxg
                 @ (f_segx7 (g_segx8 p_segx9))
                 w_segxd
                 (w3_segxh
                  `cast` (GHC.Generics.N::.:[0]
                              <*>_N <*>_N <f_segx7>_R <g_segx8>_N <p_segx9>_N
                          :: ((:.:) f_segx7 g_segx8 p_segx9 :: *)
                             ~R# (f_segx7 (g_segx8 p_segx9) :: *))) } in
         >>=
           @ m_segxe
           $dMonad_se9pV
           @ (f_segx7 (g_segx8 p_segx9) -> (:.:) f_segx7 g_segx8 p_segx9,
              Bool)
           @ ((:.:) f_segx7 g_segx8 p_segx9, Bool)
           (return
              @ m_segxe
              $dMonad_se9pV
              @ (f_segx7 (g_segx8 p_segx9) -> (:.:) f_segx7 g_segx8 p_segx9,
                 Bool)
              (Data.Data.$fData:.:1 @ f_segx7 @ g_segx8 @ p_segx9))
           (\ (ds_de7oD
                 :: (f_segx7 (g_segx8 p_segx9) -> (:.:) f_segx7 g_segx8 p_segx9,
                     Bool)) ->
              case ds_de7oD of { (h_ae1TA, b_ae1TB) ->
              mplus
                @ m_segxe
                w1_segxf
                @ ((:.:) f_segx7 g_segx8 p_segx9, Bool)
                (>>=
                   @ m_segxe
                   $dMonad_se9pV
                   @ (f_segx7 (g_segx8 p_segx9))
                   @ ((:.:) f_segx7 g_segx8 p_segx9, Bool)
                   lvl271_se9SG
                   (\ (y'_ae1TC :: f_segx7 (g_segx8 p_segx9)) ->
                      return
                        @ m_segxe
                        $dMonad_se9pV
                        @ ((:.:) f_segx7 g_segx8 p_segx9, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_segxe
                   $dMonad_se9pV
                   @ ((:.:) f_segx7 g_segx8 p_segx9, Bool)
                   (h_ae1TA
                      (w3_segxh
                       `cast` (GHC.Generics.N::.:[0]
                                   <*>_N <*>_N <f_segx7>_R <g_segx8>_N <p_segx9>_N
                               :: ((:.:) f_segx7 g_segx8 p_segx9 :: *)
                                  ~R# (f_segx7 (g_segx8 p_segx9) :: *))),
                    b_ae1TB))
              }))
        (\ (ds_de7oa :: ((:.:) f_segx7 g_segx8 p_segx9, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9SH;
             True ->
               return
                 @ m_segxe $dMonad_se9pV @ ((:.:) f_segx7 g_segx8 p_segx9) x'_ae1TD
           }
           })

-- RHS size: {terms: 16, types: 43, coercions: 0, joins: 0/0}
Data.Data.$fData:.:_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f (g p))) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> (:.:) f g p -> m ((:.:) f g p)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=7,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (f_segx7 :: * -> *))
                 (@ (g_segx8 :: * -> *))
                 (@ p_segx9)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w3_segxd [Occ=Once] :: Data (f_segx7 (g_segx8 p_segx9)))
                 (@ (m_segxe :: * -> *))
                 (w4_segxf [Occ=Once] :: MonadPlus m_segxe)
                 (w5_segxg [Occ=Once] :: forall d. Data d => d -> m_segxe d)
                 (w6_segxh [Occ=Once] :: (:.:) f_segx7 g_segx8 p_segx9) ->
                 Data.Data.$w$cgmapMp3
                   @ f_segx7
                   @ g_segx8
                   @ p_segx9
                   w3_segxd
                   @ m_segxe
                   w4_segxf
                   w5_segxg
                   w6_segxh}]
Data.Data.$fData:.:_$cgmapMp
  = \ (@ (f_segx7 :: * -> *))
      (@ (g_segx8 :: * -> *))
      (@ p_segx9)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w3_segxd :: Data (f_segx7 (g_segx8 p_segx9)))
      (@ (m_segxe :: * -> *))
      (w4_segxf :: MonadPlus m_segxe)
      (w5_segxg :: forall d. Data d => d -> m_segxe d)
      (w6_segxh :: (:.:) f_segx7 g_segx8 p_segx9) ->
      Data.Data.$w$cgmapMp3
        @ f_segx7
        @ g_segx8
        @ p_segx9
        w3_segxd
        @ m_segxe
        w4_segxf
        w5_segxg
        w6_segxh

-- RHS size: {terms: 26, types: 94, coercions: 17, joins: 0/1}
Data.Data.$w$cgmapM5 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) p.
     Data (f (g p)) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> (:.:) f g p -> m ((:.:) f g p)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120 60 0] 220 0}]
Data.Data.$w$cgmapM5
  = \ (@ (f_segxj :: * -> *))
      (@ (g_segxk :: * -> *))
      (@ p_segxl)
      (w_segxp :: Data (f_segxj (g_segxk p_segxl)))
      (@ (m_segxq :: * -> *))
      (w1_segxr :: Monad m_segxq)
      (w2_segxs :: forall d. Data d => d -> m_segxq d)
      (w3_segxt :: (:.:) f_segxj g_segxk p_segxl) ->
      let {
        lvl270_se9SJ :: m_segxq (f_segxj (g_segxk p_segxl))
        [LclId]
        lvl270_se9SJ
          = w2_segxs
              @ (f_segxj (g_segxk p_segxl))
              w_segxp
              (w3_segxt
               `cast` (GHC.Generics.N::.:[0]
                           <*>_N <*>_N <f_segxj>_R <g_segxk>_N <p_segxl>_N
                       :: ((:.:) f_segxj g_segxk p_segxl :: *)
                          ~R# (f_segxj (g_segxk p_segxl) :: *))) } in
      >>=
        @ m_segxq
        w1_segxr
        @ (f_segxj (g_segxk p_segxl) -> (:.:) f_segxj g_segxk p_segxl)
        @ ((:.:) f_segxj g_segxk p_segxl)
        (return
           @ m_segxq
           w1_segxr
           @ (f_segxj (g_segxk p_segxl) -> (:.:) f_segxj g_segxk p_segxl)
           ((Data.Data.$fData:.:2 @ f_segxj @ g_segxk @ p_segxl)
            `cast` (<f_segxj (g_segxk p_segxl)>_R
                    ->_R Sym (GHC.Generics.N::.:[0]
                                  <*>_N <*>_N <f_segxj>_R <g_segxk>_N <p_segxl>_N)
                    :: (f_segxj (g_segxk p_segxl) -> f_segxj (g_segxk p_segxl) :: *)
                       ~R# (f_segxj (g_segxk p_segxl)
                            -> (:.:) f_segxj g_segxk p_segxl :: *))))
        (\ (c'_ae1To
              :: f_segxj (g_segxk p_segxl) -> (:.:) f_segxj g_segxk p_segxl) ->
           >>=
             @ m_segxq
             w1_segxr
             @ (f_segxj (g_segxk p_segxl))
             @ ((:.:) f_segxj g_segxk p_segxl)
             lvl270_se9SJ
             (\ (x'_ae1Tp :: f_segxj (g_segxk p_segxl)) ->
                return
                  @ m_segxq
                  w1_segxr
                  @ ((:.:) f_segxj g_segxk p_segxl)
                  (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 16, types: 43, coercions: 0, joins: 0/0}
Data.Data.$fData:.:_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f (g p))) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> (:.:) f g p -> m ((:.:) f g p)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=7,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (f_segxj :: * -> *))
                 (@ (g_segxk :: * -> *))
                 (@ p_segxl)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w3_segxp [Occ=Once] :: Data (f_segxj (g_segxk p_segxl)))
                 (@ (m_segxq :: * -> *))
                 (w4_segxr [Occ=Once] :: Monad m_segxq)
                 (w5_segxs [Occ=Once] :: forall d. Data d => d -> m_segxq d)
                 (w6_segxt [Occ=Once] :: (:.:) f_segxj g_segxk p_segxl) ->
                 Data.Data.$w$cgmapM5
                   @ f_segxj
                   @ g_segxk
                   @ p_segxl
                   w3_segxp
                   @ m_segxq
                   w4_segxr
                   w5_segxs
                   w6_segxt}]
Data.Data.$fData:.:_$cgmapM
  = \ (@ (f_segxj :: * -> *))
      (@ (g_segxk :: * -> *))
      (@ p_segxl)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w3_segxp :: Data (f_segxj (g_segxk p_segxl)))
      (@ (m_segxq :: * -> *))
      (w4_segxr :: Monad m_segxq)
      (w5_segxs :: forall d. Data d => d -> m_segxq d)
      (w6_segxt :: (:.:) f_segxj g_segxk p_segxl) ->
      Data.Data.$w$cgmapM5
        @ f_segxj
        @ g_segxk
        @ p_segxl
        w3_segxp
        @ m_segxq
        w4_segxr
        w5_segxs
        w6_segxt

-- RHS size: {terms: 69, types: 239, coercions: 18, joins: 0/3}
Data.Data.$w$cgmapMo3 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) p.
     Data (f (g p)) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> (:.:) f g p -> m ((:.:) f g p)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 590 0}]
Data.Data.$w$cgmapMo3
  = \ (@ (f_segxv :: * -> *))
      (@ (g_segxw :: * -> *))
      (@ p_segxx)
      (w_segxB :: Data (f_segxv (g_segxw p_segxx)))
      (@ (m_segxC :: * -> *))
      (w1_segxD :: MonadPlus m_segxC)
      (w2_segxE :: forall d. Data d => d -> m_segxC d)
      (w3_segxF :: (:.:) f_segxv g_segxw p_segxx) ->
      let {
        lvl270_se9SO :: m_segxC ((:.:) f_segxv g_segxw p_segxx)
        [LclId]
        lvl270_se9SO
          = mzero @ m_segxC w1_segxD @ ((:.:) f_segxv g_segxw p_segxx) } in
      let {
        $dMonad_se9pT [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_segxC
        [LclId]
        $dMonad_se9pT = GHC.Base.$p2MonadPlus @ m_segxC w1_segxD } in
      >>=
        @ m_segxC
        $dMonad_se9pT
        @ ((:.:) f_segxv g_segxw p_segxx, Bool)
        @ ((:.:) f_segxv g_segxw p_segxx)
        (let {
           lvl271_se9SN :: m_segxC (f_segxv (g_segxw p_segxx))
           [LclId]
           lvl271_se9SN
             = w2_segxE
                 @ (f_segxv (g_segxw p_segxx))
                 w_segxB
                 (w3_segxF
                  `cast` (GHC.Generics.N::.:[0]
                              <*>_N <*>_N <f_segxv>_R <g_segxw>_N <p_segxx>_N
                          :: ((:.:) f_segxv g_segxw p_segxx :: *)
                             ~R# (f_segxv (g_segxw p_segxx) :: *))) } in
         >>=
           @ m_segxC
           $dMonad_se9pT
           @ (f_segxv (g_segxw p_segxx) -> (:.:) f_segxv g_segxw p_segxx,
              Bool)
           @ ((:.:) f_segxv g_segxw p_segxx, Bool)
           (return
              @ m_segxC
              $dMonad_se9pT
              @ (f_segxv (g_segxw p_segxx) -> (:.:) f_segxv g_segxw p_segxx,
                 Bool)
              (Data.Data.$fData:.:1 @ f_segxv @ g_segxw @ p_segxx))
           (\ (ds_de7pD
                 :: (f_segxv (g_segxw p_segxx) -> (:.:) f_segxv g_segxw p_segxx,
                     Bool)) ->
              case ds_de7pD of { (h_ae1TP, b_ae1TQ) ->
              case b_ae1TQ of {
                False ->
                  mplus
                    @ m_segxC
                    w1_segxD
                    @ ((:.:) f_segxv g_segxw p_segxx, Bool)
                    (>>=
                       @ m_segxC
                       $dMonad_se9pT
                       @ (f_segxv (g_segxw p_segxx))
                       @ ((:.:) f_segxv g_segxw p_segxx, Bool)
                       lvl271_se9SN
                       (\ (y'_ae1TR :: f_segxv (g_segxw p_segxx)) ->
                          return
                            @ m_segxC
                            $dMonad_se9pT
                            @ ((:.:) f_segxv g_segxw p_segxx, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_segxC
                       $dMonad_se9pT
                       @ ((:.:) f_segxv g_segxw p_segxx, Bool)
                       (h_ae1TP
                          (w3_segxF
                           `cast` (GHC.Generics.N::.:[0]
                                       <*>_N <*>_N <f_segxv>_R <g_segxw>_N <p_segxx>_N
                                   :: ((:.:) f_segxv g_segxw p_segxx :: *)
                                      ~R# (f_segxv (g_segxw p_segxx) :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_segxC
                    $dMonad_se9pT
                    @ ((:.:) f_segxv g_segxw p_segxx, Bool)
                    (h_ae1TP
                       (w3_segxF
                        `cast` (GHC.Generics.N::.:[0]
                                    <*>_N <*>_N <f_segxv>_R <g_segxw>_N <p_segxx>_N
                                :: ((:.:) f_segxv g_segxw p_segxx :: *)
                                   ~R# (f_segxv (g_segxw p_segxx) :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds_de7pa :: ((:.:) f_segxv g_segxw p_segxx, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9SO;
             True ->
               return
                 @ m_segxC $dMonad_se9pT @ ((:.:) f_segxv g_segxw p_segxx) x'_ae1TS
           }
           })

-- RHS size: {terms: 16, types: 43, coercions: 0, joins: 0/0}
Data.Data.$fData:.:_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f (g p))) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> (:.:) f g p -> m ((:.:) f g p)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=7,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (f_segxv :: * -> *))
                 (@ (g_segxw :: * -> *))
                 (@ p_segxx)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w3_segxB [Occ=Once] :: Data (f_segxv (g_segxw p_segxx)))
                 (@ (m_segxC :: * -> *))
                 (w4_segxD [Occ=Once] :: MonadPlus m_segxC)
                 (w5_segxE [Occ=Once] :: forall d. Data d => d -> m_segxC d)
                 (w6_segxF [Occ=Once] :: (:.:) f_segxv g_segxw p_segxx) ->
                 Data.Data.$w$cgmapMo3
                   @ f_segxv
                   @ g_segxw
                   @ p_segxx
                   w3_segxB
                   @ m_segxC
                   w4_segxD
                   w5_segxE
                   w6_segxF}]
Data.Data.$fData:.:_$cgmapMo
  = \ (@ (f_segxv :: * -> *))
      (@ (g_segxw :: * -> *))
      (@ p_segxx)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w3_segxB :: Data (f_segxv (g_segxw p_segxx)))
      (@ (m_segxC :: * -> *))
      (w4_segxD :: MonadPlus m_segxC)
      (w5_segxE :: forall d. Data d => d -> m_segxC d)
      (w6_segxF :: (:.:) f_segxv g_segxw p_segxx) ->
      Data.Data.$w$cgmapMo3
        @ f_segxv
        @ g_segxw
        @ p_segxx
        w3_segxB
        @ m_segxC
        w4_segxD
        w5_segxE
        w6_segxF

-- RHS size: {terms: 5, types: 12, coercions: 0, joins: 0/0}
lvl211_rejTY
  :: forall (f :: * -> *) (g :: * -> *) p. (:.:) f g p -> Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl211_rejTY
  = \ (@ (f_Xe49Z :: * -> *))
      (@ (g_Xe4a1 :: * -> *))
      (@ p_Xe4a3)
      _ [Occ=Dead] ->
      Data.Data.$cComp1

-- RHS size: {terms: 5, types: 12, coercions: 0, joins: 0/0}
lvl212_rejTZ
  :: forall (f :: * -> *) (g :: * -> *) p. (:.:) f g p -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl212_rejTZ
  = \ (@ (f_Xe49Z :: * -> *))
      (@ (g_Xe4a1 :: * -> *))
      (@ p_Xe4a3)
      _ [Occ=Dead] ->
      Data.Data.$t:.:

-- RHS size: {terms: 8, types: 34, coercions: 0, joins: 0/0}
lvl213_rejU0
  :: forall (f :: * -> *) (g :: * -> *) p (t :: * -> *) (c :: *
                                                              -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c ((:.:) f g p))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl213_rejU0
  = \ (@ (f_Xe49Z :: * -> *))
      (@ (g_Xe4a1 :: * -> *))
      (@ p_Xe4a3)
      (@ (t_ae3mQ :: * -> *))
      (@ (c_ae3mR :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae3mR ((:.:) f_Xe49Z g_Xe4a1 p_Xe4a3))

-- RHS size: {terms: 8, types: 43, coercions: 0, joins: 0/0}
lvl214_rejU1
  :: forall (f :: * -> *) (g :: * -> *) p (t :: * -> * -> *) (c :: *
                                                                   -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e))
     -> Maybe (c ((:.:) f g p))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl214_rejU1
  = \ (@ (f_Xe49Z :: * -> *))
      (@ (g_Xe4a1 :: * -> *))
      (@ p_Xe4a3)
      (@ (t_ae3n9 :: * -> * -> *))
      (@ (c_ae3na :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae3na ((:.:) f_Xe49Z g_Xe4a1 p_Xe4a3))

-- RHS size: {terms: 111, types: 302, coercions: 89, joins: 0/0}
Data.Data.$fData:.: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f (g p))) =>
     Data ((:.:) f g p)
[GblId[DFunId],
 Arity=4,
 Str=<L,U><L,U><L,1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=DFun: \ (@ (f_ae1WU :: * -> *))
             (@ (g_ae1WV :: * -> *))
             (@ p_ae1WW)
             (v_XO3 :: Typeable f_ae1WU)
             (v1_XO5 :: Typeable g_ae1WV)
             (v2_XO7 :: Data p_ae1WW)
             (v3_XO9 :: Data (f_ae1WU (g_ae1WV p_ae1WW))) ->
       Data.Data.C:Data TYPE: (:.:) f_ae1WU g_ae1WV p_ae1WW
                        (Data.Data.$fData:.:8
                           @ f_ae1WU @ g_ae1WV @ p_ae1WW v_XO3 v1_XO5 v2_XO7 v3_XO9)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <(:.:)
                                                                                    f_ae1WU
                                                                                    g_ae1WV
                                                                                    p_ae1WW>_N
                                :: (Data.Typeable.Internal.TypeRep
                                      ((:.:) f_ae1WU g_ae1WV p_ae1WW) :: *)
                                   ~R# (Typeable ((:.:) f_ae1WU g_ae1WV p_ae1WW) :: Constraint))
                        \ (@ (c_ae3me :: * -> *))
                          (k_ae2no [Occ=Once!]
                             :: forall d b. Data d => c_ae3me (d -> b) -> d -> c_ae3me b)
                          (z_ae2np [Occ=Once!] :: forall g1. g1 -> c_ae3me g1)
                          (ds_de7sP [Occ=Once] :: (:.:) f_ae1WU g_ae1WV p_ae1WW) ->
                          k_ae2no
                            @ (f_ae1WU (g_ae1WV p_ae1WW))
                            @ ((:.:) f_ae1WU g_ae1WV p_ae1WW)
                            v3_XO9
                            (z_ae2np
                               @ (f_ae1WU (g_ae1WV p_ae1WW) -> (:.:) f_ae1WU g_ae1WV p_ae1WW)
                               ((\ (v4_XKf [Occ=Once] :: f_ae1WU (g_ae1WV p_ae1WW)) -> v4_XKf)
                                `cast` (<f_ae1WU (g_ae1WV p_ae1WW)>_R
                                        ->_R Sym (GHC.Generics.N::.:[0]
                                                      <*>_N
                                                      <*>_N
                                                      <f_ae1WU>_R
                                                      <g_ae1WV>_N
                                                      <p_ae1WW>_N)
                                        :: (f_ae1WU (g_ae1WV p_ae1WW)
                                            -> f_ae1WU (g_ae1WV p_ae1WW) :: *)
                                           ~R# (f_ae1WU (g_ae1WV p_ae1WW)
                                                -> (:.:) f_ae1WU g_ae1WV p_ae1WW :: *))))
                            (ds_de7sP
                             `cast` (GHC.Generics.N::.:[0]
                                         <*>_N <*>_N <f_ae1WU>_R <g_ae1WV>_N <p_ae1WW>_N
                                     :: ((:.:) f_ae1WU g_ae1WV p_ae1WW :: *)
                                        ~R# (f_ae1WU (g_ae1WV p_ae1WW) :: *)))
                        \ (@ (c_ae3mt :: * -> *))
                          (k_ae2nr [Occ=Once!]
                             :: forall b r. Data b => c_ae3mt (b -> r) -> c_ae3mt r)
                          (z_ae2ns [Occ=Once!] :: forall r. r -> c_ae3mt r)
                          _ [Occ=Dead] ->
                          k_ae2nr
                            @ (f_ae1WU (g_ae1WV p_ae1WW))
                            @ ((:.:) f_ae1WU g_ae1WV p_ae1WW)
                            v3_XO9
                            (z_ae2ns
                               @ (f_ae1WU (g_ae1WV p_ae1WW) -> (:.:) f_ae1WU g_ae1WV p_ae1WW)
                               ((\ (v4_XKf [Occ=Once] :: f_ae1WU (g_ae1WV p_ae1WW)) -> v4_XKf)
                                `cast` (<f_ae1WU (g_ae1WV p_ae1WW)>_R
                                        ->_R Sym (GHC.Generics.N::.:[0]
                                                      <*>_N
                                                      <*>_N
                                                      <f_ae1WU>_R
                                                      <g_ae1WV>_N
                                                      <p_ae1WW>_N)
                                        :: (f_ae1WU (g_ae1WV p_ae1WW)
                                            -> f_ae1WU (g_ae1WV p_ae1WW) :: *)
                                           ~R# (f_ae1WU (g_ae1WV p_ae1WW)
                                                -> (:.:) f_ae1WU g_ae1WV p_ae1WW :: *))))
                        \ _ [Occ=Dead] -> Data.Data.$cComp1
                        \ _ [Occ=Dead] -> Data.Data.$t:.:
                        \ (@ (t_ae3mQ :: * -> *))
                          (@ (c_ae3mR :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae3mR ((:.:) f_ae1WU g_ae1WV p_ae1WW))
                        \ (@ (t_ae3n9 :: * -> * -> *))
                          (@ (c_ae3na :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae3na ((:.:) f_ae1WU g_ae1WV p_ae1WW))
                        (\ (ds_de7sW [Occ=Once!] :: forall b. Data b => b -> b)
                           (x0_Xe37i [Occ=Once] :: (:.:) f_ae1WU g_ae1WV p_ae1WW) ->
                           ds_de7sW
                             @ (f_ae1WU (g_ae1WV p_ae1WW))
                             v3_XO9
                             (x0_Xe37i
                              `cast` (GHC.Generics.N::.:[0]
                                          <*>_N <*>_N <f_ae1WU>_R <g_ae1WV>_N <p_ae1WW>_N
                                      :: ((:.:) f_ae1WU g_ae1WV p_ae1WW :: *)
                                         ~R# (f_ae1WU (g_ae1WV p_ae1WW) :: *))))
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <(:.:) f_ae1WU g_ae1WV p_ae1WW>_R
                                ->_R Sym (GHC.Generics.N::.:[0]
                                              <*>_N <*>_N <f_ae1WU>_R <g_ae1WV>_N <p_ae1WW>_N)
                                :: ((forall b. Data b => b -> b)
                                    -> (:.:) f_ae1WU g_ae1WV p_ae1WW
                                    -> f_ae1WU (g_ae1WV p_ae1WW) :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> (:.:) f_ae1WU g_ae1WV p_ae1WW
                                        -> (:.:) f_ae1WU g_ae1WV p_ae1WW :: *))
                        \ (@ r_ae3nH)
                          (@ r'_ae3nI)
                          (ds_de7sX [Occ=Once!] :: r_ae3nH -> r'_ae3nI -> r_ae3nH)
                          (ds1_de7sY [Occ=Once] :: r_ae3nH)
                          (ds2_de7sZ [Occ=Once!] :: forall d. Data d => d -> r'_ae3nI)
                          (eta_XO0 [Occ=Once] :: (:.:) f_ae1WU g_ae1WV p_ae1WW) ->
                          ds_de7sX
                            ds1_de7sY
                            (ds2_de7sZ
                               @ (f_ae1WU (g_ae1WV p_ae1WW))
                               v3_XO9
                               (eta_XO0
                                `cast` (GHC.Generics.N::.:[0]
                                            <*>_N <*>_N <f_ae1WU>_R <g_ae1WV>_N <p_ae1WW>_N
                                        :: ((:.:) f_ae1WU g_ae1WV p_ae1WW :: *)
                                           ~R# (f_ae1WU (g_ae1WV p_ae1WW) :: *))))
                        \ (@ r_ae3nY)
                          (@ r'_ae3nZ)
                          (ds_de7t0 [Occ=Once!] :: r'_ae3nZ -> r_ae3nY -> r_ae3nY)
                          (ds1_de7t1 [Occ=Once] :: r_ae3nY)
                          (ds2_de7t2 [Occ=Once!] :: forall d. Data d => d -> r'_ae3nZ)
                          (x0_ae1SX [Occ=Once] :: (:.:) f_ae1WU g_ae1WV p_ae1WW) ->
                          ds_de7t0
                            (ds2_de7t2
                               @ (f_ae1WU (g_ae1WV p_ae1WW))
                               v3_XO9
                               (x0_ae1SX
                                `cast` (GHC.Generics.N::.:[0]
                                            <*>_N <*>_N <f_ae1WU>_R <g_ae1WV>_N <p_ae1WW>_N
                                        :: ((:.:) f_ae1WU g_ae1WV p_ae1WW :: *)
                                           ~R# (f_ae1WU (g_ae1WV p_ae1WW) :: *))))
                            ds1_de7t1
                        \ (@ u_ae3of)
                          (ds_de7t3 [Occ=Once!] :: forall d. Data d => d -> u_ae3of)
                          (x0_ae1SX [Occ=Once] :: (:.:) f_ae1WU g_ae1WV p_ae1WW) ->
                          GHC.Types.:
                            @ u_ae3of
                            (ds_de7t3
                               @ (f_ae1WU (g_ae1WV p_ae1WW))
                               v3_XO9
                               (x0_ae1SX
                                `cast` (GHC.Generics.N::.:[0]
                                            <*>_N <*>_N <f_ae1WU>_R <g_ae1WV>_N <p_ae1WW>_N
                                        :: ((:.:) f_ae1WU g_ae1WV p_ae1WW :: *)
                                           ~R# (f_ae1WU (g_ae1WV p_ae1WW) :: *))))
                            (GHC.Types.[] @ u_ae3of)
                        \ (@ u_ae3ot)
                          (ds_de7t4 [Occ=Once] :: Int)
                          (ds1_de7t5 [Occ=Once!] :: forall d. Data d => d -> u_ae3ot)
                          (x_ae1T7 [Occ=Once] :: (:.:) f_ae1WU g_ae1WV p_ae1WW) ->
                          case eqInt ds_de7t4 Data.Data.$fData:.:3 of {
                            False -> Data.Maybe.fromJust1 @ u_ae3ot;
                            True ->
                              ds1_de7t5
                                @ (f_ae1WU (g_ae1WV p_ae1WW))
                                v3_XO9
                                (x_ae1T7
                                 `cast` (GHC.Generics.N::.:[0]
                                             <*>_N <*>_N <f_ae1WU>_R <g_ae1WV>_N <p_ae1WW>_N
                                         :: ((:.:) f_ae1WU g_ae1WV p_ae1WW :: *)
                                            ~R# (f_ae1WU (g_ae1WV p_ae1WW) :: *)))
                          }
                        Data.Data.$fData:.:_$cgmapM
                          @ f_ae1WU @ g_ae1WV @ p_ae1WW v_XO3 v1_XO5 v2_XO7 v3_XO9
                        Data.Data.$fData:.:_$cgmapMp
                          @ f_ae1WU @ g_ae1WV @ p_ae1WW v_XO3 v1_XO5 v2_XO7 v3_XO9
                        Data.Data.$fData:.:_$cgmapMo
                          @ f_ae1WU @ g_ae1WV @ p_ae1WW v_XO3 v1_XO5 v2_XO7 v3_XO9]
Data.Data.$fData:.:
  = \ (@ (f_Xe49Z :: * -> *))
      (@ (g_Xe4a1 :: * -> *))
      (@ p_Xe4a3)
      ($dTypeable_Xe4a5 :: Typeable f_Xe49Z)
      ($dTypeable1_Xe4a7 :: Typeable g_Xe4a1)
      ($dData_Xe4a9 :: Data p_Xe4a3)
      ($dData1_Xe4ab :: Data (f_Xe49Z (g_Xe4a1 p_Xe4a3))) ->
      Data.Data.C:Data
        @ ((:.:) f_Xe49Z g_Xe4a1 p_Xe4a3)
        ((Data.Data.$fData:.:8
            @ f_Xe49Z
            @ g_Xe4a1
            @ p_Xe4a3
            $dTypeable_Xe4a5
            $dTypeable1_Xe4a7
            $dData_Xe4a9
            $dData1_Xe4ab)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <(:.:)
                                                                     f_Xe49Z g_Xe4a1 p_Xe4a3>_N
                 :: (Data.Typeable.Internal.TypeRep
                       ((:.:) f_Xe49Z g_Xe4a1 p_Xe4a3) :: *)
                    ~R# (Typeable ((:.:) f_Xe49Z g_Xe4a1 p_Xe4a3) :: Constraint)))
        (\ (@ (c_ae3me :: * -> *))
           (k_ae2no
              :: forall d b. Data d => c_ae3me (d -> b) -> d -> c_ae3me b)
           (z_ae2np :: forall g1. g1 -> c_ae3me g1)
           (ds_de7sP :: (:.:) f_Xe49Z g_Xe4a1 p_Xe4a3) ->
           k_ae2no
             @ (f_Xe49Z (g_Xe4a1 p_Xe4a3))
             @ ((:.:) f_Xe49Z g_Xe4a1 p_Xe4a3)
             $dData1_Xe4ab
             (z_ae2np
                @ (f_Xe49Z (g_Xe4a1 p_Xe4a3) -> (:.:) f_Xe49Z g_Xe4a1 p_Xe4a3)
                ((Data.Data.$fData:.:2 @ f_Xe49Z @ g_Xe4a1 @ p_Xe4a3)
                 `cast` (<f_Xe49Z (g_Xe4a1 p_Xe4a3)>_R
                         ->_R Sym (GHC.Generics.N::.:[0]
                                       <*>_N <*>_N <f_Xe49Z>_R <g_Xe4a1>_N <p_Xe4a3>_N)
                         :: (f_Xe49Z (g_Xe4a1 p_Xe4a3) -> f_Xe49Z (g_Xe4a1 p_Xe4a3) :: *)
                            ~R# (f_Xe49Z (g_Xe4a1 p_Xe4a3)
                                 -> (:.:) f_Xe49Z g_Xe4a1 p_Xe4a3 :: *))))
             (ds_de7sP
              `cast` (GHC.Generics.N::.:[0]
                          <*>_N <*>_N <f_Xe49Z>_R <g_Xe4a1>_N <p_Xe4a3>_N
                      :: ((:.:) f_Xe49Z g_Xe4a1 p_Xe4a3 :: *)
                         ~R# (f_Xe49Z (g_Xe4a1 p_Xe4a3) :: *))))
        (\ (@ (c_ae3mt :: * -> *))
           (k_ae2nr :: forall b r. Data b => c_ae3mt (b -> r) -> c_ae3mt r)
           (z_ae2ns :: forall r. r -> c_ae3mt r)
           _ [Occ=Dead] ->
           k_ae2nr
             @ (f_Xe49Z (g_Xe4a1 p_Xe4a3))
             @ ((:.:) f_Xe49Z g_Xe4a1 p_Xe4a3)
             $dData1_Xe4ab
             (z_ae2ns
                @ (f_Xe49Z (g_Xe4a1 p_Xe4a3) -> (:.:) f_Xe49Z g_Xe4a1 p_Xe4a3)
                ((Data.Data.$fData:.:2 @ f_Xe49Z @ g_Xe4a1 @ p_Xe4a3)
                 `cast` (<f_Xe49Z (g_Xe4a1 p_Xe4a3)>_R
                         ->_R Sym (GHC.Generics.N::.:[0]
                                       <*>_N <*>_N <f_Xe49Z>_R <g_Xe4a1>_N <p_Xe4a3>_N)
                         :: (f_Xe49Z (g_Xe4a1 p_Xe4a3) -> f_Xe49Z (g_Xe4a1 p_Xe4a3) :: *)
                            ~R# (f_Xe49Z (g_Xe4a1 p_Xe4a3)
                                 -> (:.:) f_Xe49Z g_Xe4a1 p_Xe4a3 :: *)))))
        (lvl211_rejTY @ f_Xe49Z @ g_Xe4a1 @ p_Xe4a3)
        (lvl212_rejTZ @ f_Xe49Z @ g_Xe4a1 @ p_Xe4a3)
        (lvl213_rejU0 @ f_Xe49Z @ g_Xe4a1 @ p_Xe4a3)
        (lvl214_rejU1 @ f_Xe49Z @ g_Xe4a1 @ p_Xe4a3)
        ((\ (ds_de7sW :: forall b. Data b => b -> b)
            (x0_Xe37i :: (:.:) f_Xe49Z g_Xe4a1 p_Xe4a3) ->
            ds_de7sW
              @ (f_Xe49Z (g_Xe4a1 p_Xe4a3))
              $dData1_Xe4ab
              (x0_Xe37i
               `cast` (GHC.Generics.N::.:[0]
                           <*>_N <*>_N <f_Xe49Z>_R <g_Xe4a1>_N <p_Xe4a3>_N
                       :: ((:.:) f_Xe49Z g_Xe4a1 p_Xe4a3 :: *)
                          ~R# (f_Xe49Z (g_Xe4a1 p_Xe4a3) :: *))))
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <(:.:) f_Xe49Z g_Xe4a1 p_Xe4a3>_R
                 ->_R Sym (GHC.Generics.N::.:[0]
                               <*>_N <*>_N <f_Xe49Z>_R <g_Xe4a1>_N <p_Xe4a3>_N)
                 :: ((forall b. Data b => b -> b)
                     -> (:.:) f_Xe49Z g_Xe4a1 p_Xe4a3 -> f_Xe49Z (g_Xe4a1 p_Xe4a3) :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> (:.:) f_Xe49Z g_Xe4a1 p_Xe4a3
                         -> (:.:) f_Xe49Z g_Xe4a1 p_Xe4a3 :: *)))
        (\ (@ r_ae3nH)
           (@ r'_ae3nI)
           (ds_de7sX :: r_ae3nH -> r'_ae3nI -> r_ae3nH)
           (ds1_de7sY :: r_ae3nH)
           (ds2_de7sZ :: forall d. Data d => d -> r'_ae3nI)
           (eta_XO0 :: (:.:) f_Xe49Z g_Xe4a1 p_Xe4a3) ->
           ds_de7sX
             ds1_de7sY
             (ds2_de7sZ
                @ (f_Xe49Z (g_Xe4a1 p_Xe4a3))
                $dData1_Xe4ab
                (eta_XO0
                 `cast` (GHC.Generics.N::.:[0]
                             <*>_N <*>_N <f_Xe49Z>_R <g_Xe4a1>_N <p_Xe4a3>_N
                         :: ((:.:) f_Xe49Z g_Xe4a1 p_Xe4a3 :: *)
                            ~R# (f_Xe49Z (g_Xe4a1 p_Xe4a3) :: *)))))
        (\ (@ r_ae3nY)
           (@ r'_ae3nZ)
           (ds_de7t0 :: r'_ae3nZ -> r_ae3nY -> r_ae3nY)
           (ds1_de7t1 :: r_ae3nY)
           (ds2_de7t2 :: forall d. Data d => d -> r'_ae3nZ)
           (x0_ae1SX :: (:.:) f_Xe49Z g_Xe4a1 p_Xe4a3) ->
           ds_de7t0
             (ds2_de7t2
                @ (f_Xe49Z (g_Xe4a1 p_Xe4a3))
                $dData1_Xe4ab
                (x0_ae1SX
                 `cast` (GHC.Generics.N::.:[0]
                             <*>_N <*>_N <f_Xe49Z>_R <g_Xe4a1>_N <p_Xe4a3>_N
                         :: ((:.:) f_Xe49Z g_Xe4a1 p_Xe4a3 :: *)
                            ~R# (f_Xe49Z (g_Xe4a1 p_Xe4a3) :: *))))
             ds1_de7t1)
        (\ (@ u_ae3of)
           (ds_de7t3 :: forall d. Data d => d -> u_ae3of)
           (x0_ae1SX :: (:.:) f_Xe49Z g_Xe4a1 p_Xe4a3) ->
           GHC.Types.:
             @ u_ae3of
             (ds_de7t3
                @ (f_Xe49Z (g_Xe4a1 p_Xe4a3))
                $dData1_Xe4ab
                (x0_ae1SX
                 `cast` (GHC.Generics.N::.:[0]
                             <*>_N <*>_N <f_Xe49Z>_R <g_Xe4a1>_N <p_Xe4a3>_N
                         :: ((:.:) f_Xe49Z g_Xe4a1 p_Xe4a3 :: *)
                            ~R# (f_Xe49Z (g_Xe4a1 p_Xe4a3) :: *))))
             (GHC.Types.[] @ u_ae3of))
        (\ (@ u_ae3ot)
           (ds_de7t4 :: Int)
           (ds1_de7t5 :: forall d. Data d => d -> u_ae3ot)
           (x_ae1T7 :: (:.:) f_Xe49Z g_Xe4a1 p_Xe4a3) ->
           case ds_de7t4 of { I# x1_a22G ->
           case x1_a22G of {
             __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3ot;
             0# ->
               ds1_de7t5
                 @ (f_Xe49Z (g_Xe4a1 p_Xe4a3))
                 $dData1_Xe4ab
                 (x_ae1T7
                  `cast` (GHC.Generics.N::.:[0]
                              <*>_N <*>_N <f_Xe49Z>_R <g_Xe4a1>_N <p_Xe4a3>_N
                          :: ((:.:) f_Xe49Z g_Xe4a1 p_Xe4a3 :: *)
                             ~R# (f_Xe49Z (g_Xe4a1 p_Xe4a3) :: *)))
           }
           })
        (\ (@ (m_segxq :: * -> *))
           (w_segxr :: Monad m_segxq)
           (w1_segxs :: forall d. Data d => d -> m_segxq d)
           (w2_segxt :: (:.:) f_Xe49Z g_Xe4a1 p_Xe4a3) ->
           Data.Data.$w$cgmapM5
             @ f_Xe49Z
             @ g_Xe4a1
             @ p_Xe4a3
             $dData1_Xe4ab
             @ m_segxq
             w_segxr
             w1_segxs
             w2_segxt)
        (\ (@ (m_segxe :: * -> *))
           (w_segxf :: MonadPlus m_segxe)
           (w1_segxg :: forall d. Data d => d -> m_segxe d)
           (w2_segxh :: (:.:) f_Xe49Z g_Xe4a1 p_Xe4a3) ->
           Data.Data.$w$cgmapMp3
             @ f_Xe49Z
             @ g_Xe4a1
             @ p_Xe4a3
             $dData1_Xe4ab
             @ m_segxe
             w_segxf
             w1_segxg
             w2_segxh)
        (\ (@ (m_segxC :: * -> *))
           (w_segxD :: MonadPlus m_segxC)
           (w1_segxE :: forall d. Data d => d -> m_segxC d)
           (w2_segxF :: (:.:) f_Xe49Z g_Xe4a1 p_Xe4a3) ->
           Data.Data.$w$cgmapMo3
             @ f_Xe49Z
             @ g_Xe4a1
             @ p_Xe4a3
             $dData1_Xe4ab
             @ m_segxC
             w_segxD
             w1_segxE
             w2_segxF)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData:*:6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fData:*:6 = ":*:"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData:*:5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fData:*:5 = unpackCString# Data.Data.$fData:*:6

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go43_rejU2 :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go43_rejU2
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fData:*:5 of {
                False -> go43_rejU2 ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$c:*:1_rejU3 :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$c:*:1_rejU3 = Data.Data.AlgConstr $c:*:2_rejU4

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fData:*:4 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData:*:4
  = GHC.Types.: @ Constr Data.Data.$c:*: (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fData:*:3 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fData:*:3 = Data.Data.AlgRep Data.Data.$fData:*:4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$t:*: :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$t:*:
  = Data.Data.DataType Data.Data.$fData:*:5 Data.Data.$fData:*:3

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$c:*: [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$c:*:
  = Data.Data.Constr
      $c:*:1_rejU3
      Data.Data.$fData:*:5
      (GHC.Types.[] @ String)
      Data.Data.Infix
      Data.Data.$t:*:

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$c:*:2_rejU4 :: ConIndex
[GblId]
$c:*:2_rejU4 = go43_rejU2 Data.Data.$fData:*:4 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 6, types: 26, coercions: 0, joins: 0/0}
Data.Data.$fData:*:1
  :: forall (g :: * -> *) (f :: * -> *) p.
     (f p -> g p -> (:*:) f g p, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fData:*:1
  = \ (@ (g_Xe3ZP :: * -> *)) (@ (f_Xe3ZN :: * -> *)) (@ p_Xe3ZR) ->
      (GHC.Generics.:*: @ * @ f_Xe3ZN @ g_Xe3ZP @ p_Xe3ZR,
       GHC.Types.False)

-- RHS size: {terms: 76, types: 212, coercions: 28, joins: 0/4}
Data.Data.$w$cgmapMp1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Data (f p), Data (g p)) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> (:*:) f g p -> m ((:*:) f g p)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 90 60 20] 640 0}]
Data.Data.$w$cgmapMp1
  = \ (@ (f_segxO :: * -> *))
      (@ (g_segxP :: * -> *))
      (@ p_segxQ)
      (w_segxU :: Data (f_segxO p_segxQ))
      (w1_segxV :: Data (g_segxP p_segxQ))
      (@ (m_segxW :: * -> *))
      (w2_segxX :: MonadPlus m_segxW)
      (w3_segxY :: forall d. Data d => d -> m_segxW d)
      (w4_segxZ :: (:*:) f_segxO g_segxP p_segxQ) ->
      let {
        lvl270_se9T3 :: m_segxW ((:*:) f_segxO g_segxP p_segxQ)
        [LclId]
        lvl270_se9T3
          = mzero @ m_segxW w2_segxX @ ((:*:) f_segxO g_segxP p_segxQ) } in
      let {
        $dMonad_se9pR [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_segxW
        [LclId]
        $dMonad_se9pR = GHC.Base.$p2MonadPlus @ m_segxW w2_segxX } in
      >>=
        @ m_segxW
        $dMonad_se9pR
        @ ((:*:) f_segxO g_segxP p_segxQ, Bool)
        @ ((:*:) f_segxO g_segxP p_segxQ)
        (case w4_segxZ of { :*: a1_ae2nf a2_ae2ng ->
         let {
           k_se9pQ [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
             :: forall d b.
                Data d =>
                Mp m_segxW (d -> b) -> d -> m_segxW (b, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_se9pQ
             = \ (@ d_ae2Ws)
                 (@ b_ae2Wt)
                 ($dData_ae2Wv :: Data d_ae2Ws)
                 (ds_de7oC [OS=OneShot] :: Mp m_segxW (d_ae2Ws -> b_ae2Wt))
                 (y_ae1Tz [OS=OneShot] :: d_ae2Ws) ->
                 let {
                   lvl271_se9T1 :: m_segxW d_ae2Ws
                   [LclId]
                   lvl271_se9T1 = w3_segxY @ d_ae2Ws $dData_ae2Wv y_ae1Tz } in
                 >>=
                   @ m_segxW
                   $dMonad_se9pR
                   @ (d_ae2Ws -> b_ae2Wt, Bool)
                   @ (b_ae2Wt, Bool)
                   (ds_de7oC
                    `cast` (Data.Data.N:Mp[0] <m_segxW>_R <d_ae2Ws -> b_ae2Wt>_N
                            :: (Mp m_segxW (d_ae2Ws -> b_ae2Wt) :: *)
                               ~R# (m_segxW (d_ae2Ws -> b_ae2Wt, Bool) :: *)))
                   (\ (ds1_de7oD :: (d_ae2Ws -> b_ae2Wt, Bool)) ->
                      case ds1_de7oD of { (h_ae1TA, b1_ae1TB) ->
                      mplus
                        @ m_segxW
                        w2_segxX
                        @ (b_ae2Wt, Bool)
                        (>>=
                           @ m_segxW
                           $dMonad_se9pR
                           @ d_ae2Ws
                           @ (b_ae2Wt, Bool)
                           lvl271_se9T1
                           (\ (y'_ae1TC :: d_ae2Ws) ->
                              return
                                @ m_segxW
                                $dMonad_se9pR
                                @ (b_ae2Wt, Bool)
                                (h_ae1TA y'_ae1TC, GHC.Types.True)))
                        (return
                           @ m_segxW
                           $dMonad_se9pR
                           @ (b_ae2Wt, Bool)
                           (h_ae1TA y_ae1Tz, b1_ae1TB))
                      }) } in
         k_se9pQ
           @ (g_segxP p_segxQ)
           @ ((:*:) f_segxO g_segxP p_segxQ)
           w1_segxV
           ((k_se9pQ
               @ (f_segxO p_segxQ)
               @ (g_segxP p_segxQ -> (:*:) f_segxO g_segxP p_segxQ)
               w_segxU
               ((return
                   @ m_segxW
                   $dMonad_se9pR
                   @ (f_segxO p_segxQ
                      -> g_segxP p_segxQ -> (:*:) f_segxO g_segxP p_segxQ,
                      Bool)
                   (Data.Data.$fData:*:1 @ g_segxP @ f_segxO @ p_segxQ))
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_segxW>_R
                                 <f_segxO p_segxQ
                                  -> g_segxP p_segxQ -> (:*:) f_segxO g_segxP p_segxQ>_N)
                        :: (m_segxW (f_segxO p_segxQ
                                     -> g_segxP p_segxQ -> (:*:) f_segxO g_segxP p_segxQ,
                                     Bool) :: *)
                           ~R# (Mp
                                  m_segxW
                                  (f_segxO p_segxQ
                                   -> g_segxP p_segxQ -> (:*:) f_segxO g_segxP p_segxQ) :: *)))
               a1_ae2nf)
            `cast` (Sym (Data.Data.N:Mp[0]
                             <m_segxW>_R <g_segxP p_segxQ -> (:*:) f_segxO g_segxP p_segxQ>_N)
                    :: (m_segxW (g_segxP p_segxQ -> (:*:) f_segxO g_segxP p_segxQ,
                                 Bool) :: *)
                       ~R# (Mp
                              m_segxW (g_segxP p_segxQ -> (:*:) f_segxO g_segxP p_segxQ) :: *)))
           a2_ae2ng
         })
        (\ (ds_de7oa :: ((:*:) f_segxO g_segxP p_segxQ, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9T3;
             True ->
               return
                 @ m_segxW $dMonad_se9pR @ ((:*:) f_segxO g_segxP p_segxQ) x'_ae1TD
           }
           })

-- RHS size: {terms: 18, types: 53, coercions: 0, joins: 0/0}
Data.Data.$fData:*:_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f p), Data (g p)) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> (:*:) f g p -> m ((:*:) f g p)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=8,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (f_segxO :: * -> *))
                 (@ (g_segxP :: * -> *))
                 (@ p_segxQ)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w3_segxU [Occ=Once] :: Data (f_segxO p_segxQ))
                 (w4_segxV [Occ=Once] :: Data (g_segxP p_segxQ))
                 (@ (m_segxW :: * -> *))
                 (w5_segxX [Occ=Once] :: MonadPlus m_segxW)
                 (w6_segxY [Occ=Once] :: forall d. Data d => d -> m_segxW d)
                 (w7_segxZ [Occ=Once] :: (:*:) f_segxO g_segxP p_segxQ) ->
                 Data.Data.$w$cgmapMp1
                   @ f_segxO
                   @ g_segxP
                   @ p_segxQ
                   w3_segxU
                   w4_segxV
                   @ m_segxW
                   w5_segxX
                   w6_segxY
                   w7_segxZ}]
Data.Data.$fData:*:_$cgmapMp
  = \ (@ (f_segxO :: * -> *))
      (@ (g_segxP :: * -> *))
      (@ p_segxQ)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w3_segxU :: Data (f_segxO p_segxQ))
      (w4_segxV :: Data (g_segxP p_segxQ))
      (@ (m_segxW :: * -> *))
      (w5_segxX :: MonadPlus m_segxW)
      (w6_segxY :: forall d. Data d => d -> m_segxW d)
      (w7_segxZ :: (:*:) f_segxO g_segxP p_segxQ) ->
      Data.Data.$w$cgmapMp1
        @ f_segxO
        @ g_segxP
        @ p_segxQ
        w3_segxU
        w4_segxV
        @ m_segxW
        w5_segxX
        w6_segxY
        w7_segxZ

-- RHS size: {terms: 41, types: 104, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapM3 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Data (f p), Data (g p)) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> f p -> g p -> m ((:*:) f g p)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 120 60 0 0] 340 0}]
Data.Data.$w$cgmapM3
  = \ (@ (f_segy6 :: * -> *))
      (@ (g_segy7 :: * -> *))
      (@ p_segy8)
      (w_segyc :: Data (f_segy6 p_segy8))
      (w1_segyd :: Data (g_segy7 p_segy8))
      (@ (m_segye :: * -> *))
      (w2_segyf :: Monad m_segye)
      (w3_segyg :: forall d. Data d => d -> m_segye d)
      (ww_segyk :: f_segy6 p_segy8)
      (ww1_segyl :: g_segy7 p_segy8) ->
      let {
        k_se9pN [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
          :: forall d b. Data d => m_segye (d -> b) -> d -> m_segye b
        [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
        k_se9pN
          = \ (@ d_ae2Vh)
              (@ b_ae2Vi)
              ($dData_ae2Vk :: Data d_ae2Vh)
              (c_ae1Tm [OS=OneShot] :: m_segye (d_ae2Vh -> b_ae2Vi))
              (x_ae1Tn [OS=OneShot] :: d_ae2Vh) ->
              let {
                lvl270_se9T4 :: m_segye d_ae2Vh
                [LclId]
                lvl270_se9T4 = w3_segyg @ d_ae2Vh $dData_ae2Vk x_ae1Tn } in
              >>=
                @ m_segye
                w2_segyf
                @ (d_ae2Vh -> b_ae2Vi)
                @ b_ae2Vi
                c_ae1Tm
                (\ (c'_ae1To :: d_ae2Vh -> b_ae2Vi) ->
                   >>=
                     @ m_segye
                     w2_segyf
                     @ d_ae2Vh
                     @ b_ae2Vi
                     lvl270_se9T4
                     (\ (x'_ae1Tp :: d_ae2Vh) ->
                        return @ m_segye w2_segyf @ b_ae2Vi (c'_ae1To x'_ae1Tp))) } in
      k_se9pN
        @ (g_segy7 p_segy8)
        @ ((:*:) f_segy6 g_segy7 p_segy8)
        w1_segyd
        (k_se9pN
           @ (f_segy6 p_segy8)
           @ (g_segy7 p_segy8 -> (:*:) f_segy6 g_segy7 p_segy8)
           w_segyc
           (return
              @ m_segye
              w2_segyf
              @ (f_segy6 p_segy8
                 -> g_segy7 p_segy8 -> (:*:) f_segy6 g_segy7 p_segy8)
              (GHC.Generics.:*: @ * @ f_segy6 @ g_segy7 @ p_segy8))
           ww_segyk)
        ww1_segyl

-- RHS size: {terms: 22, types: 63, coercions: 0, joins: 0/0}
Data.Data.$fData:*:_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f p), Data (g p)) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> (:*:) f g p -> m ((:*:) f g p)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=8,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_segy6 :: * -> *))
                 (@ (g_segy7 :: * -> *))
                 (@ p_segy8)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w3_segyc [Occ=Once] :: Data (f_segy6 p_segy8))
                 (w4_segyd [Occ=Once] :: Data (g_segy7 p_segy8))
                 (@ (m_segye :: * -> *))
                 (w5_segyf [Occ=Once] :: Monad m_segye)
                 (w6_segyg [Occ=Once] :: forall d. Data d => d -> m_segye d)
                 (w7_segyh [Occ=Once!] :: (:*:) f_segy6 g_segy7 p_segy8) ->
                 case w7_segyh of { :*: ww1_segyk [Occ=Once] ww2_segyl [Occ=Once] ->
                 Data.Data.$w$cgmapM3
                   @ f_segy6
                   @ g_segy7
                   @ p_segy8
                   w3_segyc
                   w4_segyd
                   @ m_segye
                   w5_segyf
                   w6_segyg
                   ww1_segyk
                   ww2_segyl
                 }}]
Data.Data.$fData:*:_$cgmapM
  = \ (@ (f_segy6 :: * -> *))
      (@ (g_segy7 :: * -> *))
      (@ p_segy8)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w3_segyc :: Data (f_segy6 p_segy8))
      (w4_segyd :: Data (g_segy7 p_segy8))
      (@ (m_segye :: * -> *))
      (w5_segyf :: Monad m_segye)
      (w6_segyg :: forall d. Data d => d -> m_segye d)
      (w7_segyh :: (:*:) f_segy6 g_segy7 p_segy8) ->
      case w7_segyh of { :*: ww1_segyk ww2_segyl ->
      Data.Data.$w$cgmapM3
        @ f_segy6
        @ g_segy7
        @ p_segy8
        w3_segyc
        w4_segyd
        @ m_segye
        w5_segyf
        w6_segyg
        ww1_segyk
        ww2_segyl
      }

-- RHS size: {terms: 30, types: 63, coercions: 0, joins: 0/0}
Data.Data.$fData:*:_$cgmapQi
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f p), Data (g p)) =>
     forall u. Int -> (forall d. Data d => d -> u) -> (:*:) f g p -> u
[GblId,
 Arity=8,
 Str=<L,A><L,A><L,A><L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=8,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_Xe3ZL :: * -> *))
                 (@ (g_Xe3ZN :: * -> *))
                 (@ p_Xe3ZP)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 ($dData1_Xe3ZX [Occ=Once] :: Data (f_Xe3ZL p_Xe3ZP))
                 ($dData2_Xe3ZZ [Occ=Once] :: Data (g_Xe3ZN p_Xe3ZP))
                 (@ u_ae3hS)
                 (ds_de7sj [Occ=Once!] :: Int)
                 (ds1_de7sk [Occ=Once*!] :: forall d. Data d => d -> u_ae3hS)
                 (x_ae1T7 [Occ=Once!] :: (:*:) f_Xe3ZL g_Xe3ZN p_Xe3ZP) ->
                 case x_ae1T7 of { :*: a1_ae2nf [Occ=Once] a2_ae2ng [Occ=Once] ->
                 case ds_de7sj of { I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3hS;
                   0# -> ds1_de7sk @ (f_Xe3ZL p_Xe3ZP) $dData1_Xe3ZX a1_ae2nf;
                   1# -> ds1_de7sk @ (g_Xe3ZN p_Xe3ZP) $dData2_Xe3ZZ a2_ae2ng
                 }
                 }
                 }}]
Data.Data.$fData:*:_$cgmapQi
  = \ (@ (f_Xe3ZL :: * -> *))
      (@ (g_Xe3ZN :: * -> *))
      (@ p_Xe3ZP)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      ($dData1_Xe3ZX :: Data (f_Xe3ZL p_Xe3ZP))
      ($dData2_Xe3ZZ :: Data (g_Xe3ZN p_Xe3ZP))
      (@ u_ae3hS)
      (ds_de7sj :: Int)
      (ds1_de7sk :: forall d. Data d => d -> u_ae3hS)
      (x_ae1T7 :: (:*:) f_Xe3ZL g_Xe3ZN p_Xe3ZP) ->
      case x_ae1T7 of { :*: a1_ae2nf a2_ae2ng ->
      case ds_de7sj of { I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3hS;
        0# -> ds1_de7sk @ (f_Xe3ZL p_Xe3ZP) $dData1_Xe3ZX a1_ae2nf;
        1# -> ds1_de7sk @ (g_Xe3ZN p_Xe3ZP) $dData2_Xe3ZZ a2_ae2ng
      }
      }
      }

-- RHS size: {terms: 26, types: 64, coercions: 0, joins: 0/0}
Data.Data.$fData:*:_$cgmapQr
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f p), Data (g p)) =>
     forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> (:*:) f g p -> r
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=9,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_Xe3ZJ :: * -> *))
                 (@ (g_Xe3ZL :: * -> *))
                 (@ p_Xe3ZN)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 ($dData1_Xe3ZV [Occ=Once] :: Data (f_Xe3ZJ p_Xe3ZN))
                 ($dData2_Xe3ZX [Occ=Once] :: Data (g_Xe3ZL p_Xe3ZN))
                 (@ r_ae3hn)
                 (@ r'_ae3ho)
                 (ds_de7sf :: r'_ae3ho -> r_ae3hn -> r_ae3hn)
                 (ds1_de7sg [Occ=Once] :: r_ae3hn)
                 (ds2_de7sh :: forall d. Data d => d -> r'_ae3ho)
                 (x0_ae1SX [Occ=Once!] :: (:*:) f_Xe3ZJ g_Xe3ZL p_Xe3ZN) ->
                 case x0_ae1SX of { :*: a1_ae2nf [Occ=Once] a2_ae2ng [Occ=Once] ->
                 ds_de7sf
                   (ds2_de7sh @ (f_Xe3ZJ p_Xe3ZN) $dData1_Xe3ZV a1_ae2nf)
                   (ds_de7sf
                      (ds2_de7sh @ (g_Xe3ZL p_Xe3ZN) $dData2_Xe3ZX a2_ae2ng) ds1_de7sg)
                 }}]
Data.Data.$fData:*:_$cgmapQr
  = \ (@ (f_Xe3ZJ :: * -> *))
      (@ (g_Xe3ZL :: * -> *))
      (@ p_Xe3ZN)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      ($dData1_Xe3ZV :: Data (f_Xe3ZJ p_Xe3ZN))
      ($dData2_Xe3ZX :: Data (g_Xe3ZL p_Xe3ZN))
      (@ r_ae3hn)
      (@ r'_ae3ho)
      (ds_de7sf :: r'_ae3ho -> r_ae3hn -> r_ae3hn)
      (ds1_de7sg :: r_ae3hn)
      (ds2_de7sh :: forall d. Data d => d -> r'_ae3ho)
      (x0_ae1SX :: (:*:) f_Xe3ZJ g_Xe3ZL p_Xe3ZN) ->
      case x0_ae1SX of { :*: a1_ae2nf a2_ae2ng ->
      ds_de7sf
        (ds2_de7sh @ (f_Xe3ZJ p_Xe3ZN) $dData1_Xe3ZV a1_ae2nf)
        (ds_de7sf
           (ds2_de7sh @ (g_Xe3ZL p_Xe3ZN) $dData2_Xe3ZX a2_ae2ng) ds1_de7sg)
      }

-- RHS size: {terms: 23, types: 61, coercions: 0, joins: 0/0}
Data.Data.$fData:*:_$cgmapQ
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f p), Data (g p)) =>
     forall u. (forall d. Data d => d -> u) -> (:*:) f g p -> [u]
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,U><L,U><L,C(C1(U))><S,1*U(U,U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=7,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_Xe3ZK :: * -> *))
                 (@ (g_Xe3ZM :: * -> *))
                 (@ p_Xe3ZO)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 ($dData1_Xe3ZW [Occ=Once] :: Data (f_Xe3ZK p_Xe3ZO))
                 ($dData2_Xe3ZY [Occ=Once] :: Data (g_Xe3ZM p_Xe3ZO))
                 (@ u_ae3hE)
                 (ds_de7si :: forall d. Data d => d -> u_ae3hE)
                 (x0_ae1SX [Occ=Once!] :: (:*:) f_Xe3ZK g_Xe3ZM p_Xe3ZO) ->
                 case x0_ae1SX of { :*: a1_ae2nf [Occ=Once] a2_ae2ng [Occ=Once] ->
                 GHC.Types.:
                   @ u_ae3hE
                   (ds_de7si @ (f_Xe3ZK p_Xe3ZO) $dData1_Xe3ZW a1_ae2nf)
                   (GHC.Types.:
                      @ u_ae3hE
                      (ds_de7si @ (g_Xe3ZM p_Xe3ZO) $dData2_Xe3ZY a2_ae2ng)
                      (GHC.Types.[] @ u_ae3hE))
                 }}]
Data.Data.$fData:*:_$cgmapQ
  = \ (@ (f_Xe3ZK :: * -> *))
      (@ (g_Xe3ZM :: * -> *))
      (@ p_Xe3ZO)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      ($dData1_Xe3ZW :: Data (f_Xe3ZK p_Xe3ZO))
      ($dData2_Xe3ZY :: Data (g_Xe3ZM p_Xe3ZO))
      (@ u_ae3hE)
      (ds_de7si :: forall d. Data d => d -> u_ae3hE)
      (x0_ae1SX :: (:*:) f_Xe3ZK g_Xe3ZM p_Xe3ZO) ->
      case x0_ae1SX of { :*: a1_ae2nf a2_ae2ng ->
      GHC.Types.:
        @ u_ae3hE
        (ds_de7si @ (f_Xe3ZK p_Xe3ZO) $dData1_Xe3ZW a1_ae2nf)
        (GHC.Types.:
           @ u_ae3hE
           (ds_de7si @ (g_Xe3ZM p_Xe3ZO) $dData2_Xe3ZY a2_ae2ng)
           (GHC.Types.[] @ u_ae3hE))
      }

-- RHS size: {terms: 26, types: 64, coercions: 11, joins: 0/0}
Data.Data.$fData:*:2
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f p), Data (g p)) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data d => d -> r')
     -> (:*:) f g p
     -> Const r ((:*:) f g p)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=9,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_Xe3ZI :: * -> *))
                 (@ (g_Xe3ZK :: * -> *))
                 (@ p_Xe3ZM)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 ($dData1_Xe3ZU [Occ=Once] :: Data (f_Xe3ZI p_Xe3ZM))
                 ($dData2_Xe3ZW [Occ=Once] :: Data (g_Xe3ZK p_Xe3ZM))
                 (@ r_ae3h6)
                 (@ r'_ae3h7)
                 (ds_de7sc :: r_ae3h6 -> r'_ae3h7 -> r_ae3h6)
                 (ds1_de7sd [Occ=Once] :: r_ae3h6)
                 (ds2_de7se :: forall d. Data d => d -> r'_ae3h7)
                 (eta_XOp [Occ=Once!] :: (:*:) f_Xe3ZI g_Xe3ZK p_Xe3ZM) ->
                 case eta_XOp of { :*: a1_ae2nf [Occ=Once] a2_ae2ng [Occ=Once] ->
                 (ds_de7sc
                    (ds_de7sc
                       ds1_de7sd (ds2_de7se @ (f_Xe3ZI p_Xe3ZM) $dData1_Xe3ZU a1_ae2nf))
                    (ds2_de7se @ (g_Xe3ZK p_Xe3ZM) $dData2_Xe3ZW a2_ae2ng))
                 `cast` (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r_ae3h6>_R <(:*:) f_Xe3ZI g_Xe3ZK p_Xe3ZM>_P)
                         :: (r_ae3h6 :: *)
                            ~R# (Const r_ae3h6 ((:*:) f_Xe3ZI g_Xe3ZK p_Xe3ZM) :: *))
                 }}]
Data.Data.$fData:*:2
  = \ (@ (f_Xe3ZI :: * -> *))
      (@ (g_Xe3ZK :: * -> *))
      (@ p_Xe3ZM)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      ($dData1_Xe3ZU :: Data (f_Xe3ZI p_Xe3ZM))
      ($dData2_Xe3ZW :: Data (g_Xe3ZK p_Xe3ZM))
      (@ r_ae3h6)
      (@ r'_ae3h7)
      (ds_de7sc :: r_ae3h6 -> r'_ae3h7 -> r_ae3h6)
      (ds1_de7sd :: r_ae3h6)
      (ds2_de7se :: forall d. Data d => d -> r'_ae3h7)
      (eta_XOp :: (:*:) f_Xe3ZI g_Xe3ZK p_Xe3ZM) ->
      case eta_XOp of { :*: a1_ae2nf a2_ae2ng ->
      (ds_de7sc
         (ds_de7sc
            ds1_de7sd (ds2_de7se @ (f_Xe3ZI p_Xe3ZM) $dData1_Xe3ZU a1_ae2nf))
         (ds2_de7se @ (g_Xe3ZK p_Xe3ZM) $dData2_Xe3ZW a2_ae2ng))
      `cast` (Sym (Data.Functor.Const.N:Const[0]
                       <*>_N <r_ae3h6>_R <(:*:) f_Xe3ZI g_Xe3ZK p_Xe3ZM>_P)
              :: (r_ae3h6 :: *)
                 ~R# (Const r_ae3h6 ((:*:) f_Xe3ZI g_Xe3ZK p_Xe3ZM) :: *))
      }

-- RHS size: {terms: 86, types: 219, coercions: 28, joins: 0/4}
Data.Data.$w$cgmapMo1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Data (f p), Data (g p)) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> (:*:) f g p -> m ((:*:) f g p)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 90 60 20] 720 0}]
Data.Data.$w$cgmapMo1
  = \ (@ (f_segyt :: * -> *))
      (@ (g_segyu :: * -> *))
      (@ p_segyv)
      (w_segyz :: Data (f_segyt p_segyv))
      (w1_segyA :: Data (g_segyu p_segyv))
      (@ (m_segyB :: * -> *))
      (w2_segyC :: MonadPlus m_segyB)
      (w3_segyD :: forall d. Data d => d -> m_segyB d)
      (w4_segyE :: (:*:) f_segyt g_segyu p_segyv) ->
      let {
        lvl270_se9Ta :: m_segyB ((:*:) f_segyt g_segyu p_segyv)
        [LclId]
        lvl270_se9Ta
          = mzero @ m_segyB w2_segyC @ ((:*:) f_segyt g_segyu p_segyv) } in
      let {
        $dMonad_se9pL [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_segyB
        [LclId]
        $dMonad_se9pL = GHC.Base.$p2MonadPlus @ m_segyB w2_segyC } in
      >>=
        @ m_segyB
        $dMonad_se9pL
        @ ((:*:) f_segyt g_segyu p_segyv, Bool)
        @ ((:*:) f_segyt g_segyu p_segyv)
        (case w4_segyE of { :*: a1_ae2nf a2_ae2ng ->
         let {
           k_se9pK [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
             :: forall d b.
                Data d =>
                Mp m_segyB (d -> b) -> d -> m_segyB (b, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_se9pK
             = \ (@ d_ae2Ya)
                 (@ b_ae2Yb)
                 ($dData_ae2Yd :: Data d_ae2Ya)
                 (ds_de7pC [OS=OneShot] :: Mp m_segyB (d_ae2Ya -> b_ae2Yb))
                 (y_ae1TO [OS=OneShot] :: d_ae2Ya) ->
                 let {
                   lvl271_se9T8 :: m_segyB d_ae2Ya
                   [LclId]
                   lvl271_se9T8 = w3_segyD @ d_ae2Ya $dData_ae2Yd y_ae1TO } in
                 >>=
                   @ m_segyB
                   $dMonad_se9pL
                   @ (d_ae2Ya -> b_ae2Yb, Bool)
                   @ (b_ae2Yb, Bool)
                   (ds_de7pC
                    `cast` (Data.Data.N:Mp[0] <m_segyB>_R <d_ae2Ya -> b_ae2Yb>_N
                            :: (Mp m_segyB (d_ae2Ya -> b_ae2Yb) :: *)
                               ~R# (m_segyB (d_ae2Ya -> b_ae2Yb, Bool) :: *)))
                   (\ (ds1_de7pD :: (d_ae2Ya -> b_ae2Yb, Bool)) ->
                      case ds1_de7pD of { (h_ae1TP, b1_ae1TQ) ->
                      case b1_ae1TQ of {
                        False ->
                          mplus
                            @ m_segyB
                            w2_segyC
                            @ (b_ae2Yb, Bool)
                            (>>=
                               @ m_segyB
                               $dMonad_se9pL
                               @ d_ae2Ya
                               @ (b_ae2Yb, Bool)
                               lvl271_se9T8
                               (\ (y'_ae1TR :: d_ae2Ya) ->
                                  return
                                    @ m_segyB
                                    $dMonad_se9pL
                                    @ (b_ae2Yb, Bool)
                                    (h_ae1TP y'_ae1TR, GHC.Types.True)))
                            (return
                               @ m_segyB
                               $dMonad_se9pL
                               @ (b_ae2Yb, Bool)
                               (h_ae1TP y_ae1TO, GHC.Types.False));
                        True ->
                          return
                            @ m_segyB
                            $dMonad_se9pL
                            @ (b_ae2Yb, Bool)
                            (h_ae1TP y_ae1TO, GHC.Types.True)
                      }
                      }) } in
         k_se9pK
           @ (g_segyu p_segyv)
           @ ((:*:) f_segyt g_segyu p_segyv)
           w1_segyA
           ((k_se9pK
               @ (f_segyt p_segyv)
               @ (g_segyu p_segyv -> (:*:) f_segyt g_segyu p_segyv)
               w_segyz
               ((return
                   @ m_segyB
                   $dMonad_se9pL
                   @ (f_segyt p_segyv
                      -> g_segyu p_segyv -> (:*:) f_segyt g_segyu p_segyv,
                      Bool)
                   (Data.Data.$fData:*:1 @ g_segyu @ f_segyt @ p_segyv))
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_segyB>_R
                                 <f_segyt p_segyv
                                  -> g_segyu p_segyv -> (:*:) f_segyt g_segyu p_segyv>_N)
                        :: (m_segyB (f_segyt p_segyv
                                     -> g_segyu p_segyv -> (:*:) f_segyt g_segyu p_segyv,
                                     Bool) :: *)
                           ~R# (Mp
                                  m_segyB
                                  (f_segyt p_segyv
                                   -> g_segyu p_segyv -> (:*:) f_segyt g_segyu p_segyv) :: *)))
               a1_ae2nf)
            `cast` (Sym (Data.Data.N:Mp[0]
                             <m_segyB>_R <g_segyu p_segyv -> (:*:) f_segyt g_segyu p_segyv>_N)
                    :: (m_segyB (g_segyu p_segyv -> (:*:) f_segyt g_segyu p_segyv,
                                 Bool) :: *)
                       ~R# (Mp
                              m_segyB (g_segyu p_segyv -> (:*:) f_segyt g_segyu p_segyv) :: *)))
           a2_ae2ng
         })
        (\ (ds_de7pa :: ((:*:) f_segyt g_segyu p_segyv, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9Ta;
             True ->
               return
                 @ m_segyB $dMonad_se9pL @ ((:*:) f_segyt g_segyu p_segyv) x'_ae1TS
           }
           })

-- RHS size: {terms: 18, types: 53, coercions: 0, joins: 0/0}
Data.Data.$fData:*:_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f p), Data (g p)) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> (:*:) f g p -> m ((:*:) f g p)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=8,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (f_segyt :: * -> *))
                 (@ (g_segyu :: * -> *))
                 (@ p_segyv)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w3_segyz [Occ=Once] :: Data (f_segyt p_segyv))
                 (w4_segyA [Occ=Once] :: Data (g_segyu p_segyv))
                 (@ (m_segyB :: * -> *))
                 (w5_segyC [Occ=Once] :: MonadPlus m_segyB)
                 (w6_segyD [Occ=Once] :: forall d. Data d => d -> m_segyB d)
                 (w7_segyE [Occ=Once] :: (:*:) f_segyt g_segyu p_segyv) ->
                 Data.Data.$w$cgmapMo1
                   @ f_segyt
                   @ g_segyu
                   @ p_segyv
                   w3_segyz
                   w4_segyA
                   @ m_segyB
                   w5_segyC
                   w6_segyD
                   w7_segyE}]
Data.Data.$fData:*:_$cgmapMo
  = \ (@ (f_segyt :: * -> *))
      (@ (g_segyu :: * -> *))
      (@ p_segyv)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w3_segyz :: Data (f_segyt p_segyv))
      (w4_segyA :: Data (g_segyu p_segyv))
      (@ (m_segyB :: * -> *))
      (w5_segyC :: MonadPlus m_segyB)
      (w6_segyD :: forall d. Data d => d -> m_segyB d)
      (w7_segyE :: (:*:) f_segyt g_segyu p_segyv) ->
      Data.Data.$w$cgmapMo1
        @ f_segyt
        @ g_segyu
        @ p_segyv
        w3_segyz
        w4_segyA
        @ m_segyB
        w5_segyC
        w6_segyD
        w7_segyE

-- RHS size: {terms: 8, types: 26, coercions: 0, joins: 0/0}
lvl215_rejU5
  :: forall (g :: * -> *) p (f :: * -> *). (:*:) f g p -> Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []]
lvl215_rejU5
  = \ (@ (g_Xe3ZG :: * -> *))
      (@ p_Xe4On)
      (@ (f_Xe3ZE :: * -> *))
      (ds_de7s5 :: (:*:) f_Xe3ZE g_Xe3ZG p_Xe4On) ->
      case ds_de7s5 of { :*: ds1_de7s6 ds2_de7s7 -> Data.Data.$c:*: }

-- RHS size: {terms: 5, types: 16, coercions: 0, joins: 0/0}
lvl216_rejU6
  :: forall (f :: * -> *) (g :: * -> *) p. (:*:) f g p -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl216_rejU6
  = \ (@ (f_Xe3ZE :: * -> *))
      (@ (g_Xe3ZG :: * -> *))
      (@ p_Xe4On)
      _ [Occ=Dead] ->
      Data.Data.$t:*:

-- RHS size: {terms: 8, types: 38, coercions: 0, joins: 0/0}
lvl217_rejU7
  :: forall (f :: * -> *) (g :: * -> *) p (t :: * -> *) (c :: *
                                                              -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c ((:*:) f g p))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl217_rejU7
  = \ (@ (f_Xe3ZE :: * -> *))
      (@ (g_Xe3ZG :: * -> *))
      (@ p_Xe4On)
      (@ (t_ae3gf :: * -> *))
      (@ (c_ae3gg :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae3gg ((:*:) f_Xe3ZE g_Xe3ZG p_Xe4On))

-- RHS size: {terms: 8, types: 47, coercions: 0, joins: 0/0}
lvl218_rejU8
  :: forall (f :: * -> *) (g :: * -> *) p (t :: * -> * -> *) (c :: *
                                                                   -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e))
     -> Maybe (c ((:*:) f g p))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl218_rejU8
  = \ (@ (f_Xe3ZE :: * -> *))
      (@ (g_Xe3ZG :: * -> *))
      (@ p_Xe4On)
      (@ (t_ae3gy :: * -> * -> *))
      (@ (c_ae3gz :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae3gz ((:*:) f_Xe3ZE g_Xe3ZG p_Xe4On))

-- RHS size: {terms: 97, types: 200, coercions: 75, joins: 0/0}
Data.Data.$fData:*: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *) p.
     (Typeable f, Typeable g, Data p, Data (f p), Data (g p)) =>
     Data ((:*:) f g p)
[GblId[DFunId],
 Arity=5,
 Str=<L,U><L,U><L,1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=DFun: \ (@ (f_ae1WQ :: * -> *))
             (@ (g_ae1WR :: * -> *))
             (@ p_ae1WS)
             (v_XOH :: Typeable f_ae1WQ)
             (v1_XOJ :: Typeable g_ae1WR)
             (v2_XOL :: Data p_ae1WS)
             (v3_XON :: Data (f_ae1WQ p_ae1WS))
             (v4_B5 :: Data (g_ae1WR p_ae1WS)) ->
       Data.Data.C:Data TYPE: (:*:) f_ae1WQ g_ae1WR p_ae1WS
                        (Data.Data.$fData:*:7
                           @ f_ae1WQ @ g_ae1WR @ p_ae1WS v_XOH v1_XOJ v2_XOL v3_XON v4_B5)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <(:*:)
                                                                                    f_ae1WQ
                                                                                    g_ae1WR
                                                                                    p_ae1WS>_N
                                :: (Data.Typeable.Internal.TypeRep
                                      ((:*:) f_ae1WQ g_ae1WR p_ae1WS) :: *)
                                   ~R# (Typeable ((:*:) f_ae1WQ g_ae1WR p_ae1WS) :: Constraint))
                        Data.Data.$fData:*:_$cgfoldl
                          @ f_ae1WQ @ g_ae1WR @ p_ae1WS v_XOH v1_XOJ v2_XOL v3_XON v4_B5
                        \ (@ (c_ae3fQ :: * -> *))
                          (k_ae2nh :: forall b r. Data b => c_ae3fQ (b -> r) -> c_ae3fQ r)
                          (z_ae2ni [Occ=Once!] :: forall r. r -> c_ae3fQ r)
                          _ [Occ=Dead] ->
                          k_ae2nh
                            @ (g_ae1WR p_ae1WS)
                            @ ((:*:) f_ae1WQ g_ae1WR p_ae1WS)
                            v4_B5
                            (k_ae2nh
                               @ (f_ae1WQ p_ae1WS)
                               @ (g_ae1WR p_ae1WS -> (:*:) f_ae1WQ g_ae1WR p_ae1WS)
                               v3_XON
                               (z_ae2ni
                                  @ (f_ae1WQ p_ae1WS
                                     -> g_ae1WR p_ae1WS -> (:*:) f_ae1WQ g_ae1WR p_ae1WS)
                                  (GHC.Generics.:*: @ * @ f_ae1WQ @ g_ae1WR @ p_ae1WS)))
                        \ (ds_de7s5 [Occ=Once!] :: (:*:) f_ae1WQ g_ae1WR p_ae1WS) ->
                          case ds_de7s5 of { :*: _ [Occ=Dead] _ [Occ=Dead] ->
                          Data.Data.$c:*:
                          }
                        \ _ [Occ=Dead] -> Data.Data.$t:*:
                        \ (@ (t_ae3gf :: * -> *))
                          (@ (c_ae3gg :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae3gg ((:*:) f_ae1WQ g_ae1WR p_ae1WS))
                        \ (@ (t_ae3gy :: * -> * -> *))
                          (@ (c_ae3gz :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae3gz ((:*:) f_ae1WQ g_ae1WR p_ae1WS))
                        (\ (ds_de7sb :: forall b. Data b => b -> b)
                           (x0_Xe37W [Occ=Once!] :: (:*:) f_ae1WQ g_ae1WR p_ae1WS) ->
                           case x0_Xe37W of { :*: a1_ae2nf [Occ=Once] a2_ae2ng [Occ=Once] ->
                           (GHC.Generics.:*:
                              @ *
                              @ f_ae1WQ
                              @ g_ae1WR
                              @ p_ae1WS
                              (ds_de7sb @ (f_ae1WQ p_ae1WS) v3_XON a1_ae2nf)
                              (ds_de7sb @ (g_ae1WR p_ae1WS) v4_B5 a2_ae2ng))
                           `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                                            <(:*:) f_ae1WQ g_ae1WR p_ae1WS>_R)
                                   :: ((:*:) f_ae1WQ g_ae1WR p_ae1WS :: *)
                                      ~R# (Identity ((:*:) f_ae1WQ g_ae1WR p_ae1WS) :: *))
                           })
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <(:*:) f_ae1WQ g_ae1WR p_ae1WS>_R
                                ->_R Data.Functor.Identity.N:Identity[0]
                                         <(:*:) f_ae1WQ g_ae1WR p_ae1WS>_R
                                :: ((forall b. Data b => b -> b)
                                    -> (:*:) f_ae1WQ g_ae1WR p_ae1WS
                                    -> Identity ((:*:) f_ae1WQ g_ae1WR p_ae1WS) :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> (:*:) f_ae1WQ g_ae1WR p_ae1WS
                                        -> (:*:) f_ae1WQ g_ae1WR p_ae1WS :: *))
                        (Data.Data.$fData:*:2
                           @ f_ae1WQ @ g_ae1WR @ p_ae1WS v_XOH v1_XOJ v2_XOL v3_XON v4_B5)
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <(:*:) f_ae1WQ g_ae1WR p_ae1WS>_R
                                ->_R Data.Functor.Const.N:Const[0]
                                         <*>_N <r>_R <(:*:) f_ae1WQ g_ae1WR p_ae1WS>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> (:*:) f_ae1WQ g_ae1WR p_ae1WS
                                    -> Const r ((:*:) f_ae1WQ g_ae1WR p_ae1WS) :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d. Data d => d -> r')
                                        -> (:*:) f_ae1WQ g_ae1WR p_ae1WS
                                        -> r :: *))
                        Data.Data.$fData:*:_$cgmapQr
                          @ f_ae1WQ @ g_ae1WR @ p_ae1WS v_XOH v1_XOJ v2_XOL v3_XON v4_B5
                        Data.Data.$fData:*:_$cgmapQ
                          @ f_ae1WQ @ g_ae1WR @ p_ae1WS v_XOH v1_XOJ v2_XOL v3_XON v4_B5
                        Data.Data.$fData:*:_$cgmapQi
                          @ f_ae1WQ @ g_ae1WR @ p_ae1WS v_XOH v1_XOJ v2_XOL v3_XON v4_B5
                        Data.Data.$fData:*:_$cgmapM
                          @ f_ae1WQ @ g_ae1WR @ p_ae1WS v_XOH v1_XOJ v2_XOL v3_XON v4_B5
                        Data.Data.$fData:*:_$cgmapMp
                          @ f_ae1WQ @ g_ae1WR @ p_ae1WS v_XOH v1_XOJ v2_XOL v3_XON v4_B5
                        Data.Data.$fData:*:_$cgmapMo
                          @ f_ae1WQ @ g_ae1WR @ p_ae1WS v_XOH v1_XOJ v2_XOL v3_XON v4_B5]
Data.Data.$fData:*:
  = \ (@ (f_Xe3ZE :: * -> *))
      (@ (g_Xe3ZG :: * -> *))
      (@ p_Xe4On)
      ($dTypeable_Xe4Oq :: Typeable f_Xe3ZE)
      ($dTypeable1_Xe4Ot :: Typeable g_Xe3ZG)
      ($dData_Xe4Ow :: Data p_Xe4On)
      ($dData1_Xe4Oz :: Data (f_Xe3ZE p_Xe4On))
      ($dData2_Xe4OC :: Data (g_Xe3ZG p_Xe4On)) ->
      Data.Data.C:Data
        @ ((:*:) f_Xe3ZE g_Xe3ZG p_Xe4On)
        ((Data.Data.$fData:*:7
            @ f_Xe3ZE
            @ g_Xe3ZG
            @ p_Xe4On
            $dTypeable_Xe4Oq
            $dTypeable1_Xe4Ot
            $dData_Xe4Ow
            $dData1_Xe4Oz
            $dData2_Xe4OC)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <(:*:)
                                                                     f_Xe3ZE g_Xe3ZG p_Xe4On>_N
                 :: (Data.Typeable.Internal.TypeRep
                       ((:*:) f_Xe3ZE g_Xe3ZG p_Xe4On) :: *)
                    ~R# (Typeable ((:*:) f_Xe3ZE g_Xe3ZG p_Xe4On) :: Constraint)))
        (Data.Data.$fData:*:_$cgfoldl
           @ f_Xe3ZE
           @ g_Xe3ZG
           @ p_Xe4On
           $dTypeable_Xe4Oq
           $dTypeable1_Xe4Ot
           $dData_Xe4Ow
           $dData1_Xe4Oz
           $dData2_Xe4OC)
        (\ (@ (c_ae3fQ :: * -> *))
           (k_ae2nh :: forall b r. Data b => c_ae3fQ (b -> r) -> c_ae3fQ r)
           (z_ae2ni :: forall r. r -> c_ae3fQ r)
           _ [Occ=Dead] ->
           k_ae2nh
             @ (g_Xe3ZG p_Xe4On)
             @ ((:*:) f_Xe3ZE g_Xe3ZG p_Xe4On)
             $dData2_Xe4OC
             (k_ae2nh
                @ (f_Xe3ZE p_Xe4On)
                @ (g_Xe3ZG p_Xe4On -> (:*:) f_Xe3ZE g_Xe3ZG p_Xe4On)
                $dData1_Xe4Oz
                (z_ae2ni
                   @ (f_Xe3ZE p_Xe4On
                      -> g_Xe3ZG p_Xe4On -> (:*:) f_Xe3ZE g_Xe3ZG p_Xe4On)
                   (GHC.Generics.:*: @ * @ f_Xe3ZE @ g_Xe3ZG @ p_Xe4On))))
        (lvl215_rejU5 @ g_Xe3ZG @ p_Xe4On @ f_Xe3ZE)
        (lvl216_rejU6 @ f_Xe3ZE @ g_Xe3ZG @ p_Xe4On)
        (lvl217_rejU7 @ f_Xe3ZE @ g_Xe3ZG @ p_Xe4On)
        (lvl218_rejU8 @ f_Xe3ZE @ g_Xe3ZG @ p_Xe4On)
        ((\ (ds_de7sb :: forall b. Data b => b -> b)
            (x0_Xe37W :: (:*:) f_Xe3ZE g_Xe3ZG p_Xe4On) ->
            case x0_Xe37W of { :*: a1_ae2nf a2_ae2ng ->
            (GHC.Generics.:*:
               @ *
               @ f_Xe3ZE
               @ g_Xe3ZG
               @ p_Xe4On
               (ds_de7sb @ (f_Xe3ZE p_Xe4On) $dData1_Xe4Oz a1_ae2nf)
               (ds_de7sb @ (g_Xe3ZG p_Xe4On) $dData2_Xe4OC a2_ae2ng))
            `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                             <(:*:) f_Xe3ZE g_Xe3ZG p_Xe4On>_R)
                    :: ((:*:) f_Xe3ZE g_Xe3ZG p_Xe4On :: *)
                       ~R# (Identity ((:*:) f_Xe3ZE g_Xe3ZG p_Xe4On) :: *))
            })
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <(:*:) f_Xe3ZE g_Xe3ZG p_Xe4On>_R
                 ->_R Data.Functor.Identity.N:Identity[0]
                          <(:*:) f_Xe3ZE g_Xe3ZG p_Xe4On>_R
                 :: ((forall b. Data b => b -> b)
                     -> (:*:) f_Xe3ZE g_Xe3ZG p_Xe4On
                     -> Identity ((:*:) f_Xe3ZE g_Xe3ZG p_Xe4On) :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> (:*:) f_Xe3ZE g_Xe3ZG p_Xe4On
                         -> (:*:) f_Xe3ZE g_Xe3ZG p_Xe4On :: *)))
        ((Data.Data.$fData:*:2
            @ f_Xe3ZE
            @ g_Xe3ZG
            @ p_Xe4On
            $dTypeable_Xe4Oq
            $dTypeable1_Xe4Ot
            $dData_Xe4Ow
            $dData1_Xe4Oz
            $dData2_Xe4OC)
         `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                 <r -> r' -> r>_R
                 ->_R <r>_R
                 ->_R <forall d. Data d => d -> r'>_R
                 ->_R <(:*:) f_Xe3ZE g_Xe3ZG p_Xe4On>_R
                 ->_R Data.Functor.Const.N:Const[0]
                          <*>_N <r>_R <(:*:) f_Xe3ZE g_Xe3ZG p_Xe4On>_P
                 :: (forall r r'.
                     (r -> r' -> r)
                     -> r
                     -> (forall d. Data d => d -> r')
                     -> (:*:) f_Xe3ZE g_Xe3ZG p_Xe4On
                     -> Const r ((:*:) f_Xe3ZE g_Xe3ZG p_Xe4On) :: *)
                    ~R# (forall r r'.
                         (r -> r' -> r)
                         -> r
                         -> (forall d. Data d => d -> r')
                         -> (:*:) f_Xe3ZE g_Xe3ZG p_Xe4On
                         -> r :: *)))
        (Data.Data.$fData:*:_$cgmapQr
           @ f_Xe3ZE
           @ g_Xe3ZG
           @ p_Xe4On
           $dTypeable_Xe4Oq
           $dTypeable1_Xe4Ot
           $dData_Xe4Ow
           $dData1_Xe4Oz
           $dData2_Xe4OC)
        (Data.Data.$fData:*:_$cgmapQ
           @ f_Xe3ZE
           @ g_Xe3ZG
           @ p_Xe4On
           $dTypeable_Xe4Oq
           $dTypeable1_Xe4Ot
           $dData_Xe4Ow
           $dData1_Xe4Oz
           $dData2_Xe4OC)
        (Data.Data.$fData:*:_$cgmapQi
           @ f_Xe3ZE
           @ g_Xe3ZG
           @ p_Xe4On
           $dTypeable_Xe4Oq
           $dTypeable1_Xe4Ot
           $dData_Xe4Ow
           $dData1_Xe4Oz
           $dData2_Xe4OC)
        (Data.Data.$fData:*:_$cgmapM
           @ f_Xe3ZE
           @ g_Xe3ZG
           @ p_Xe4On
           $dTypeable_Xe4Oq
           $dTypeable1_Xe4Ot
           $dData_Xe4Ow
           $dData1_Xe4Oz
           $dData2_Xe4OC)
        (\ (@ (m_segxW :: * -> *))
           (w_segxX :: MonadPlus m_segxW)
           (w1_segxY :: forall d. Data d => d -> m_segxW d)
           (w2_segxZ :: (:*:) f_Xe3ZE g_Xe3ZG p_Xe4On) ->
           Data.Data.$w$cgmapMp1
             @ f_Xe3ZE
             @ g_Xe3ZG
             @ p_Xe4On
             $dData1_Xe4Oz
             $dData2_Xe4OC
             @ m_segxW
             w_segxX
             w1_segxY
             w2_segxZ)
        (\ (@ (m_segyB :: * -> *))
           (w_segyC :: MonadPlus m_segyB)
           (w1_segyD :: forall d. Data d => d -> m_segyB d)
           (w2_segyE :: (:*:) f_Xe3ZE g_Xe3ZG p_Xe4On) ->
           Data.Data.$w$cgmapMo1
             @ f_Xe3ZE
             @ g_Xe3ZG
             @ p_Xe4On
             $dData1_Xe4Oz
             $dData2_Xe4OC
             @ m_segyB
             w_segyC
             w1_segyD
             w2_segyE)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tFixity1_rejU9 :: [Char]
[GblId]
$tFixity1_rejU9 = unpackCString# Data.Data.$tcFixity2

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go44_rejUa :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go44_rejUa
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fShowFixity2 of {
                False -> go44_rejUa ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go45_rejUb :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go45_rejUb
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 Data.Data.$fShowFixity4 of {
                False -> go45_rejUb ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cInfix1_rejUc :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cInfix1_rejUc = Data.Data.AlgConstr $cInfix2_rejUi

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cPrefix1_rejUd :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cPrefix1_rejUd = Data.Data.AlgConstr $cPrefix2_rejUh

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cInfix [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cInfix
  = Data.Data.Constr
      $cInfix1_rejUc
      Data.Data.$fShowFixity2
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tFixity

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$tFixity2_rejUe :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tFixity2_rejUe
  = GHC.Types.: @ Constr Data.Data.$cInfix (GHC.Types.[] @ Constr)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$tFixity3_rejUf :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tFixity3_rejUf
  = GHC.Types.: @ Constr Data.Data.$cPrefix $tFixity2_rejUe

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tFixity4_rejUg :: DataRep
[GblId, Str=m1, Unf=OtherCon []]
$tFixity4_rejUg = Data.Data.AlgRep $tFixity3_rejUf

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tFixity [Occ=LoopBreaker] :: DataType
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$tFixity
  = Data.Data.DataType $tFixity1_rejU9 $tFixity4_rejUg

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cPrefix [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cPrefix
  = Data.Data.Constr
      $cPrefix1_rejUd
      Data.Data.$fShowFixity4
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tFixity

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cPrefix2_rejUh :: ConIndex
[GblId]
$cPrefix2_rejUh = go45_rejUb $tFixity3_rejUf Data.Data.mkConstr1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cInfix2_rejUi :: ConIndex
[GblId]
$cInfix2_rejUi = go44_rejUa $tFixity3_rejUf Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataFixity_$cdataTypeOf :: Generics.Fixity -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Data.$tFixity}]
Data.Data.$fDataFixity_$cdataTypeOf
  = \ _ [Occ=Dead] -> Data.Data.$tFixity

-- RHS size: {terms: 7, types: 4, coercions: 0, joins: 0/0}
Data.Data.$fDataFixity_$ctoConstr :: Generics.Fixity -> Constr
[GblId,
 Arity=1,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_de7rK [Occ=Once!] :: Generics.Fixity) ->
                 case ds_de7rK of {
                   Generics.Prefix -> Data.Data.$cPrefix;
                   Generics.Infix _ [Occ=Dead] _ [Occ=Dead] -> Data.Data.$cInfix
                 }}]
Data.Data.$fDataFixity_$ctoConstr
  = \ (ds_de7rK :: Generics.Fixity) ->
      case ds_de7rK of {
        Generics.Prefix -> Data.Data.$cPrefix;
        Generics.Infix ds1_de7rL ds2_de7rM -> Data.Data.$cInfix
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tAssociativity1_rejUj :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$tAssociativity1_rejUj = "Associativity"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tAssociativity2_rejUk :: [Char]
[GblId]
$tAssociativity2_rejUk = unpackCString# $tAssociativity1_rejUj

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str30_rejUl :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str30_rejUl = "LeftAssociative"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str31_rejUm :: String
[GblId]
str31_rejUm = unpackCString# str30_rejUl

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str32_rejUn :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str32_rejUn = "NotAssociative"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str33_rejUo :: String
[GblId]
str33_rejUo = unpackCString# str32_rejUn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str34_rejUp :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str34_rejUp = "RightAssociative"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str35_rejUq :: String
[GblId]
str35_rejUq = unpackCString# str34_rejUp

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go46_rejUr :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go46_rejUr
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str31_rejUm of {
                False -> go46_rejUr ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go47_rejUs :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go47_rejUs
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str35_rejUq of {
                False -> go47_rejUs ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go48_rejUt :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go48_rejUt
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str33_rejUo of {
                False -> go48_rejUt ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cLeftAssociative1_rejUu :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cLeftAssociative1_rejUu
  = Data.Data.AlgConstr $cLeftAssociative2_rejUD

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cRightAssociative1_rejUv :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cRightAssociative1_rejUv
  = Data.Data.AlgConstr $cRightAssociative2_rejUC

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cNotAssociative1_rejUw :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cNotAssociative1_rejUw
  = Data.Data.AlgConstr $cNotAssociative2_rejUB

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$tAssociativity3_rejUx :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tAssociativity3_rejUx
  = GHC.Types.:
      @ Constr Data.Data.$cNotAssociative (GHC.Types.[] @ Constr)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$tAssociativity4_rejUy :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tAssociativity4_rejUy
  = GHC.Types.:
      @ Constr Data.Data.$cLeftAssociative $tAssociativity6_rejUA

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tAssociativity5_rejUz :: DataRep
[GblId, Str=m1, Unf=OtherCon []]
$tAssociativity5_rejUz = Data.Data.AlgRep $tAssociativity4_rejUy

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tAssociativity [Occ=LoopBreaker] :: DataType
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$tAssociativity
  = Data.Data.DataType $tAssociativity2_rejUk $tAssociativity5_rejUz

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cRightAssociative [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cRightAssociative
  = Data.Data.Constr
      $cRightAssociative1_rejUv
      str35_rejUq
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tAssociativity

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$tAssociativity6_rejUA :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tAssociativity6_rejUA
  = GHC.Types.:
      @ Constr Data.Data.$cRightAssociative $tAssociativity3_rejUx

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cLeftAssociative [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cLeftAssociative
  = Data.Data.Constr
      $cLeftAssociative1_rejUu
      str31_rejUm
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tAssociativity

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cNotAssociative [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cNotAssociative
  = Data.Data.Constr
      $cNotAssociative1_rejUw
      str33_rejUo
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tAssociativity

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cNotAssociative2_rejUB :: ConIndex
[GblId]
$cNotAssociative2_rejUB
  = go48_rejUt $tAssociativity4_rejUy Data.Data.mkConstr1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cRightAssociative2_rejUC :: ConIndex
[GblId]
$cRightAssociative2_rejUC
  = go47_rejUs $tAssociativity4_rejUy Data.Data.mkConstr1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cLeftAssociative2_rejUD :: ConIndex
[GblId]
$cLeftAssociative2_rejUD
  = go46_rejUr $tAssociativity4_rejUy Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataAssociativity_$cdataTypeOf
  :: Associativity -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Data.$tAssociativity}]
Data.Data.$fDataAssociativity_$cdataTypeOf
  = \ _ [Occ=Dead] -> Data.Data.$tAssociativity

-- RHS size: {terms: 9, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataAssociativity_$ctoConstr :: Associativity -> Constr
[GblId,
 Arity=1,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_de7rn [Occ=Once!] :: Associativity) ->
                 case ds_de7rn of {
                   LeftAssociative -> Data.Data.$cLeftAssociative;
                   RightAssociative -> Data.Data.$cRightAssociative;
                   NotAssociative -> Data.Data.$cNotAssociative
                 }}]
Data.Data.$fDataAssociativity_$ctoConstr
  = \ (ds_de7rn :: Associativity) ->
      case ds_de7rn of {
        LeftAssociative -> Data.Data.$cLeftAssociative;
        RightAssociative -> Data.Data.$cRightAssociative;
        NotAssociative -> Data.Data.$cNotAssociative
      }

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataAssociativity_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c Associativity)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae39n :: * -> *))
                 (@ (c_ae39o :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae39o Associativity)}]
Data.Data.$fDataAssociativity_$cdataCast1
  = \ (@ (t_ae39n :: * -> *))
      (@ (c_ae39o :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae39o Associativity)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataAssociativity3 :: (Associativity, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataAssociativity3
  = (GHC.Generics.LeftAssociative, GHC.Types.False)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataAssociativity2 :: (Associativity, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataAssociativity2
  = (GHC.Generics.RightAssociative, GHC.Types.False)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataAssociativity1 :: (Associativity, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataAssociativity1
  = (GHC.Generics.NotAssociative, GHC.Types.False)

-- RHS size: {terms: 37, types: 43, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp11 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     Associativity -> m Associativity
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 100] 290 0}]
Data.Data.$w$cgmapMp11
  = \ (@ (m_segyQ :: * -> *))
      (w_segyR :: MonadPlus m_segyQ)
      (w1_segyT :: Associativity) ->
      let {
        lvl270_se9TD :: m_segyQ Associativity
        [LclId]
        lvl270_se9TD = mzero @ m_segyQ w_segyR @ Associativity } in
      let {
        $dMonad_se9pH [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_segyQ
        [LclId]
        $dMonad_se9pH = GHC.Base.$p2MonadPlus @ m_segyQ w_segyR } in
      >>=
        @ m_segyQ
        $dMonad_se9pH
        @ (Associativity, Bool)
        @ Associativity
        (case w1_segyT of {
           LeftAssociative ->
             return
               @ m_segyQ
               $dMonad_se9pH
               @ (Associativity, Bool)
               Data.Data.$fDataAssociativity3;
           RightAssociative ->
             return
               @ m_segyQ
               $dMonad_se9pH
               @ (Associativity, Bool)
               Data.Data.$fDataAssociativity2;
           NotAssociative ->
             return
               @ m_segyQ
               $dMonad_se9pH
               @ (Associativity, Bool)
               Data.Data.$fDataAssociativity1
         })
        (\ (ds_de7oa :: (Associativity, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9TD;
             True -> return @ m_segyQ $dMonad_se9pH @ Associativity x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataAssociativity_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Associativity -> m Associativity
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_segyQ :: * -> *))
                 (w_segyR [Occ=Once] :: MonadPlus m_segyQ)
                 _ [Occ=Dead]
                 (w2_segyT [Occ=Once] :: Associativity) ->
                 Data.Data.$w$cgmapMp11 @ m_segyQ w_segyR w2_segyT}]
Data.Data.$fDataAssociativity_$cgmapMp
  = \ (@ (m_segyQ :: * -> *))
      (w_segyR :: MonadPlus m_segyQ)
      _ [Occ=Dead]
      (w2_segyT :: Associativity) ->
      Data.Data.$w$cgmapMp11 @ m_segyQ w_segyR w2_segyT

-- RHS size: {terms: 17, types: 14, coercions: 0, joins: 0/0}
Data.Data.$w$cgmapM8 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     Monad m =>
     Associativity -> m Associativity
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 100] 120 0}]
Data.Data.$w$cgmapM8
  = \ (@ (m_segyV :: * -> *))
      (w_segyW :: Monad m_segyV)
      (w1_segyY :: Associativity) ->
      case w1_segyY of {
        LeftAssociative ->
          return
            @ m_segyV w_segyW @ Associativity GHC.Generics.LeftAssociative;
        RightAssociative ->
          return
            @ m_segyV w_segyW @ Associativity GHC.Generics.RightAssociative;
        NotAssociative ->
          return
            @ m_segyV w_segyW @ Associativity GHC.Generics.NotAssociative
      }

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataAssociativity_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Associativity -> m Associativity
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_segyV :: * -> *))
                 (w_segyW [Occ=Once] :: Monad m_segyV)
                 _ [Occ=Dead]
                 (w2_segyY [Occ=Once] :: Associativity) ->
                 Data.Data.$w$cgmapM8 @ m_segyV w_segyW w2_segyY}]
Data.Data.$fDataAssociativity_$cgmapM
  = \ (@ (m_segyV :: * -> *))
      (w_segyW :: Monad m_segyV)
      _ [Occ=Dead]
      (w2_segyY :: Associativity) ->
      Data.Data.$w$cgmapM8 @ m_segyV w_segyW w2_segyY

-- RHS size: {terms: 8, types: 12, coercions: 0, joins: 0/0}
Data.Data.$fDataAssociativity_$cgmapQi
  :: forall u.
     Int -> (forall d. Data d => d -> u) -> Associativity -> u
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,1*U>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae3b0)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (x_ae1T7 [Occ=Once] :: Associativity) ->
                 case x_ae1T7 of { __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3b0 }}]
Data.Data.$fDataAssociativity_$cgmapQi
  = \ (@ u_ae3b0)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (x_ae1T7 :: Associativity) ->
      case x_ae1T7 of { __DEFAULT -> Data.Maybe.fromJust1 @ u_ae3b0 }

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
Data.Data.$fDataAssociativity_$cgmapQr
  :: forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> Associativity -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_ae3av)
                 (@ r'_ae3aw)
                 _ [Occ=Dead]
                 (ds1_de7rw [Occ=Once] :: r_ae3av)
                 _ [Occ=Dead]
                 (x0_ae1SX [Occ=Once] :: Associativity) ->
                 case x0_ae1SX of { __DEFAULT -> ds1_de7rw }}]
Data.Data.$fDataAssociativity_$cgmapQr
  = \ (@ r_ae3av)
      (@ r'_ae3aw)
      _ [Occ=Dead]
      (ds1_de7rw :: r_ae3av)
      _ [Occ=Dead]
      (x0_ae1SX :: Associativity) ->
      case x0_ae1SX of { __DEFAULT -> ds1_de7rw }

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataAssociativity_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> Associativity -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae3aM)
                 _ [Occ=Dead]
                 (x0_ae1SX [Occ=Once] :: Associativity) ->
                 case x0_ae1SX of { __DEFAULT -> GHC.Types.[] @ u_ae3aM }}]
Data.Data.$fDataAssociativity_$cgmapQ
  = \ (@ u_ae3aM) _ [Occ=Dead] (x0_ae1SX :: Associativity) ->
      case x0_ae1SX of { __DEFAULT -> GHC.Types.[] @ u_ae3aM }

-- RHS size: {terms: 10, types: 16, coercions: 6, joins: 0/0}
Data.Data.$fDataAssociativity4
  :: forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data d => d -> r')
     -> Associativity
     -> Const r Associativity
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_ae3ae)
                 (@ r'_ae3af)
                 _ [Occ=Dead]
                 (ds1_de7rt [Occ=Once] :: r_ae3ae)
                 _ [Occ=Dead]
                 (eta_XP7 [Occ=Once] :: Associativity) ->
                 case eta_XP7 of { __DEFAULT ->
                 ds1_de7rt
                 `cast` (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r_ae3ae>_R <Associativity>_P)
                         :: (r_ae3ae :: *) ~R# (Const r_ae3ae Associativity :: *))
                 }}]
Data.Data.$fDataAssociativity4
  = \ (@ r_ae3ae)
      (@ r'_ae3af)
      _ [Occ=Dead]
      (ds1_de7rt :: r_ae3ae)
      _ [Occ=Dead]
      (eta_XP7 :: Associativity) ->
      case eta_XP7 of { __DEFAULT ->
      ds1_de7rt
      `cast` (Sym (Data.Functor.Const.N:Const[0]
                       <*>_N <r_ae3ae>_R <Associativity>_P)
              :: (r_ae3ae :: *) ~R# (Const r_ae3ae Associativity :: *))
      }

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fDataAssociativity5
  :: (forall b. Data b => b -> b) -> Associativity -> Associativity
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (x0_Xe38w [Occ=Once] :: Associativity) ->
                 x0_Xe38w}]
Data.Data.$fDataAssociativity5
  = \ _ [Occ=Dead] (x0_Xe38w :: Associativity) -> x0_Xe38w

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataAssociativity_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e))
     -> Maybe (c Associativity)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae39G :: * -> * -> *))
                 (@ (c_ae39H :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae39H Associativity)}]
Data.Data.$fDataAssociativity_$cdataCast2
  = \ (@ (t_ae39G :: * -> * -> *))
      (@ (c_ae39H :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae39H Associativity)

-- RHS size: {terms: 37, types: 43, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo10 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     Associativity -> m Associativity
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 100] 290 0}]
Data.Data.$w$cgmapMo10
  = \ (@ (m_segz0 :: * -> *))
      (w_segz1 :: MonadPlus m_segz0)
      (w1_segz3 :: Associativity) ->
      let {
        lvl270_se9TP :: m_segz0 Associativity
        [LclId]
        lvl270_se9TP = mzero @ m_segz0 w_segz1 @ Associativity } in
      let {
        $dMonad_se9pF [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_segz0
        [LclId]
        $dMonad_se9pF = GHC.Base.$p2MonadPlus @ m_segz0 w_segz1 } in
      >>=
        @ m_segz0
        $dMonad_se9pF
        @ (Associativity, Bool)
        @ Associativity
        (case w1_segz3 of {
           LeftAssociative ->
             return
               @ m_segz0
               $dMonad_se9pF
               @ (Associativity, Bool)
               Data.Data.$fDataAssociativity3;
           RightAssociative ->
             return
               @ m_segz0
               $dMonad_se9pF
               @ (Associativity, Bool)
               Data.Data.$fDataAssociativity2;
           NotAssociative ->
             return
               @ m_segz0
               $dMonad_se9pF
               @ (Associativity, Bool)
               Data.Data.$fDataAssociativity1
         })
        (\ (ds_de7pa :: (Associativity, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9TP;
             True -> return @ m_segz0 $dMonad_se9pF @ Associativity x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataAssociativity_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Associativity -> m Associativity
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_segz0 :: * -> *))
                 (w_segz1 [Occ=Once] :: MonadPlus m_segz0)
                 _ [Occ=Dead]
                 (w2_segz3 [Occ=Once] :: Associativity) ->
                 Data.Data.$w$cgmapMo10 @ m_segz0 w_segz1 w2_segz3}]
Data.Data.$fDataAssociativity_$cgmapMo
  = \ (@ (m_segz0 :: * -> *))
      (w_segz1 :: MonadPlus m_segz0)
      _ [Occ=Dead]
      (w2_segz3 :: Associativity) ->
      Data.Data.$w$cgmapMo10 @ m_segz0 w_segz1 w2_segz3

-- RHS size: {terms: 16, types: 1, coercions: 31, joins: 0/0}
Data.Data.$fDataAssociativity [InlPrag=NOUSERINLINE CONLIKE]
  :: Data Associativity
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: Associativity
                        Data.Data.$fDataAssociativity6
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Associativity>_N
                                :: (Data.Typeable.Internal.TypeRep Associativity :: *)
                                   ~R# (Typeable Associativity :: Constraint))
                        Data.Data.$fDataAssociativity_$cgfoldl
                        Data.Data.$fDataAssociativity_$cgunfold
                        Data.Data.$fDataAssociativity_$ctoConstr
                        Data.Data.$fDataAssociativity_$cdataTypeOf
                        Data.Data.$fDataAssociativity_$cdataCast1
                        Data.Data.$fDataAssociativity_$cdataCast2
                        Data.Data.$fDataAssociativity5
                        Data.Data.$fDataAssociativity4
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <Associativity>_R
                                ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <Associativity>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> Associativity
                                    -> Const r Associativity :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d. Data d => d -> r')
                                        -> Associativity
                                        -> r :: *))
                        Data.Data.$fDataAssociativity_$cgmapQr
                        Data.Data.$fDataAssociativity_$cgmapQ
                        Data.Data.$fDataAssociativity_$cgmapQi
                        Data.Data.$fDataAssociativity_$cgmapM
                        Data.Data.$fDataAssociativity_$cgmapMp
                        Data.Data.$fDataAssociativity_$cgmapMo]
Data.Data.$fDataAssociativity
  = Data.Data.C:Data
      @ Associativity
      (Data.Data.$fDataAssociativity6
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Associativity>_N
               :: (Data.Typeable.Internal.TypeRep Associativity :: *)
                  ~R# (Typeable Associativity :: Constraint)))
      Data.Data.$fDataAssociativity_$cgfoldl
      Data.Data.$fDataAssociativity_$cgunfold
      Data.Data.$fDataAssociativity_$ctoConstr
      Data.Data.$fDataAssociativity_$cdataTypeOf
      Data.Data.$fDataAssociativity_$cdataCast1
      Data.Data.$fDataAssociativity_$cdataCast2
      Data.Data.$fDataAssociativity5
      (Data.Data.$fDataAssociativity4
       `cast` (forall (r :: <*>_N) (r' :: <*>_N).
               <r -> r' -> r>_R
               ->_R <r>_R
               ->_R <forall d. Data d => d -> r'>_R
               ->_R <Associativity>_R
               ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <Associativity>_P
               :: (forall r r'.
                   (r -> r' -> r)
                   -> r
                   -> (forall d. Data d => d -> r')
                   -> Associativity
                   -> Const r Associativity :: *)
                  ~R# (forall r r'.
                       (r -> r' -> r)
                       -> r -> (forall d. Data d => d -> r') -> Associativity -> r :: *)))
      Data.Data.$fDataAssociativity_$cgmapQr
      Data.Data.$fDataAssociativity_$cgmapQ
      Data.Data.$fDataAssociativity_$cgmapQi
      Data.Data.$fDataAssociativity_$cgmapM
      Data.Data.$fDataAssociativity_$cgmapMp
      Data.Data.$fDataAssociativity_$cgmapMo

-- RHS size: {terms: 18, types: 34, coercions: 0, joins: 0/0}
Data.Data.$fDataFixity_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Generics.Fixity -> c Generics.Fixity
[GblId,
 Arity=3,
 Str=<L,C(C1(C1(U)))><L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [120 120 50] 140 0}]
Data.Data.$fDataFixity_$cgfoldl
  = \ (@ (c_ae3c6 :: * -> *))
      (k_ae2n4
         :: forall d b. Data d => c_ae3c6 (d -> b) -> d -> c_ae3c6 b)
      (z_ae2n5 :: forall g. g -> c_ae3c6 g)
      (ds_de7rE :: Generics.Fixity) ->
      case ds_de7rE of {
        Generics.Prefix -> z_ae2n5 @ Generics.Fixity GHC.Generics.Prefix;
        Generics.Infix a1_ae2n8 a2_ae2n9 ->
          k_ae2n4
            @ Int
            @ Generics.Fixity
            Data.Data.$fDataInt
            (k_ae2n4
               @ Associativity
               @ (Int -> Generics.Fixity)
               Data.Data.$fDataAssociativity
               (z_ae2n5
                  @ (Associativity -> Int -> Generics.Fixity) GHC.Generics.Infix)
               a1_ae2n8)
            a2_ae2n9
      }

-- RHS size: {terms: 30, types: 40, coercions: 0, joins: 0/0}
Data.Data.$w$cgunfold11 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> ConstrRep
     -> DataType
     -> c Generics.Fixity
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [120 120 60 20] 180 0}]
Data.Data.$w$cgunfold11
  = \ (@ (c_segz9 :: * -> *))
      (w_segza :: forall b r. Data b => c_segz9 (b -> r) -> c_segz9 r)
      (w1_segzb :: forall r. r -> c_segz9 r)
      (ww_segzf :: ConstrRep)
      (ww1_segzj :: DataType) ->
      case ww_segzf of {
        __DEFAULT ->
          case ww1_segzj of { DataType ww3_sefV0 ww4_sefV1 ->
          case Data.Data.$wlvl ww3_sefV0 of wild1_00 { }
          };
        AlgConstr idx_ae1Ws ->
          case idx_ae1Ws of { I# ds_de7rH ->
          case ds_de7rH of {
            __DEFAULT ->
              w_segza
                @ Int
                @ Generics.Fixity
                Data.Data.$fDataInt
                (w_segza
                   @ Associativity
                   @ (Int -> Generics.Fixity)
                   Data.Data.$fDataAssociativity
                   (w1_segzb
                      @ (Associativity -> Int -> Generics.Fixity) GHC.Generics.Infix));
            1# -> w1_segzb @ Generics.Fixity GHC.Generics.Prefix
          }
          }
      }

-- RHS size: {terms: 12, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataFixity_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c Generics.Fixity
[GblId,
 Arity=3,
 Str=<L,C(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_segz9 :: * -> *))
                 (w_segza [Occ=Once]
                    :: forall b r. Data b => c_segz9 (b -> r) -> c_segz9 r)
                 (w1_segzb [Occ=Once] :: forall r. r -> c_segz9 r)
                 (w2_segzc [Occ=Once!] :: Constr) ->
                 case w2_segzc of
                 { Constr ww1_segzf [Occ=Once] _ [Occ=Dead] _ [Occ=Dead]
                          _ [Occ=Dead] ww5_segzj [Occ=Once] ->
                 Data.Data.$w$cgunfold11
                   @ c_segz9 w_segza w1_segzb ww1_segzf ww5_segzj
                 }}]
Data.Data.$fDataFixity_$cgunfold
  = \ (@ (c_segz9 :: * -> *))
      (w_segza :: forall b r. Data b => c_segz9 (b -> r) -> c_segz9 r)
      (w1_segzb :: forall r. r -> c_segz9 r)
      (w2_segzc :: Constr) ->
      case w2_segzc of
      { Constr ww1_segzf ww2_segzg ww3_segzh ww4_segzi ww5_segzj ->
      Data.Data.$w$cgunfold11
        @ c_segz9 w_segza w1_segzb ww1_segzf ww5_segzj
      }

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataFixity_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c Generics.Fixity)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae3cI :: * -> *))
                 (@ (c_ae3cJ :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae3cJ Generics.Fixity)}]
Data.Data.$fDataFixity_$cdataCast1
  = \ (@ (t_ae3cI :: * -> *))
      (@ (c_ae3cJ :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae3cJ Generics.Fixity)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
lvl219_rejUE :: (Generics.Fixity, Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl219_rejUE = (GHC.Generics.Prefix, GHC.Types.False)

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl220_rejUF :: (Associativity -> Int -> Generics.Fixity, Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl220_rejUF = (GHC.Generics.Infix, GHC.Types.False)

-- RHS size: {terms: 90, types: 149, coercions: 0, joins: 0/4}
Data.Data.$fDataFixity_$cgmapMp
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d)
     -> Generics.Fixity -> m Generics.Fixity
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U>,
 Unf=OtherCon []]
Data.Data.$fDataFixity_$cgmapMp
  = \ (@ (m_ae3eP :: * -> *))
      ($dMonadPlus_ae3eR :: MonadPlus m_ae3eP)
      (ds_de7s1 :: forall d. Data d => d -> m_ae3eP d)
      (eta_XPo :: Generics.Fixity) ->
      let {
        lvl270_se9TV :: m_ae3eP Generics.Fixity
        [LclId]
        lvl270_se9TV
          = mzero @ m_ae3eP $dMonadPlus_ae3eR @ Generics.Fixity } in
      let {
        $dMonad_se9pz [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae3eP
        [LclId]
        $dMonad_se9pz
          = GHC.Base.$p2MonadPlus @ m_ae3eP $dMonadPlus_ae3eR } in
      >>=
        @ m_ae3eP
        $dMonad_se9pz
        @ (Generics.Fixity, Bool)
        @ Generics.Fixity
        (case eta_XPo of {
           Generics.Prefix ->
             return
               @ m_ae3eP $dMonad_se9pz @ (Generics.Fixity, Bool) lvl219_rejUE;
           Generics.Infix a1_ae2n8 a2_ae2n9 ->
             let {
               lvl271_se9TR :: m_ae3eP Int
               [LclId]
               lvl271_se9TR = ds_de7s1 @ Int Data.Data.$fDataInt a2_ae2n9 } in
             >>=
               @ m_ae3eP
               $dMonad_se9pz
               @ (Int -> Generics.Fixity, Bool)
               @ (Generics.Fixity, Bool)
               (let {
                  lvl272_se9TQ :: m_ae3eP Associativity
                  [LclId]
                  lvl272_se9TQ
                    = ds_de7s1
                        @ Associativity Data.Data.$fDataAssociativity a1_ae2n8 } in
                >>=
                  @ m_ae3eP
                  $dMonad_se9pz
                  @ (Associativity -> Int -> Generics.Fixity, Bool)
                  @ (Int -> Generics.Fixity, Bool)
                  (return
                     @ m_ae3eP
                     $dMonad_se9pz
                     @ (Associativity -> Int -> Generics.Fixity, Bool)
                     lvl220_rejUF)
                  (\ (ds1_de7oD
                        :: (Associativity -> Int -> Generics.Fixity, Bool)) ->
                     case ds1_de7oD of { (h_ae1TA, b_ae1TB) ->
                     mplus
                       @ m_ae3eP
                       $dMonadPlus_ae3eR
                       @ (Int -> Generics.Fixity, Bool)
                       (>>=
                          @ m_ae3eP
                          $dMonad_se9pz
                          @ Associativity
                          @ (Int -> Generics.Fixity, Bool)
                          lvl272_se9TQ
                          (\ (y'_ae1TC :: Associativity) ->
                             return
                               @ m_ae3eP
                               $dMonad_se9pz
                               @ (Int -> Generics.Fixity, Bool)
                               (h_ae1TA y'_ae1TC, GHC.Types.True)))
                       (return
                          @ m_ae3eP
                          $dMonad_se9pz
                          @ (Int -> Generics.Fixity, Bool)
                          (h_ae1TA a1_ae2n8, b_ae1TB))
                     }))
               (\ (ds1_de7oD :: (Int -> Generics.Fixity, Bool)) ->
                  case ds1_de7oD of { (h_ae1TA, b_ae1TB) ->
                  mplus
                    @ m_ae3eP
                    $dMonadPlus_ae3eR
                    @ (Generics.Fixity, Bool)
                    (>>=
                       @ m_ae3eP
                       $dMonad_se9pz
                       @ Int
                       @ (Generics.Fixity, Bool)
                       lvl271_se9TR
                       (\ (y'_ae1TC :: Int) ->
                          return
                            @ m_ae3eP
                            $dMonad_se9pz
                            @ (Generics.Fixity, Bool)
                            (h_ae1TA y'_ae1TC, GHC.Types.True)))
                    (return
                       @ m_ae3eP
                       $dMonad_se9pz
                       @ (Generics.Fixity, Bool)
                       (h_ae1TA a2_ae2n9, b_ae1TB))
                  })
         })
        (\ (ds1_de7oa :: (Generics.Fixity, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9TV;
             True -> return @ m_ae3eP $dMonad_se9pz @ Generics.Fixity x'_ae1TD
           }
           })

-- RHS size: {terms: 44, types: 58, coercions: 0, joins: 0/2}
Data.Data.$fDataFixity_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d)
     -> Generics.Fixity -> m Generics.Fixity
[GblId,
 Arity=3,
 Str=<S,U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [240 120 60] 460 0}]
Data.Data.$fDataFixity_$cgmapM
  = \ (@ (m_ae3ez :: * -> *))
      ($dMonad_ae3eB :: Monad m_ae3ez)
      (ds_de7s0 :: forall d. Data d => d -> m_ae3ez d)
      (eta_XPp :: Generics.Fixity) ->
      case eta_XPp of {
        Generics.Prefix ->
          return
            @ m_ae3ez $dMonad_ae3eB @ Generics.Fixity GHC.Generics.Prefix;
        Generics.Infix a1_ae2n8 a2_ae2n9 ->
          let {
            lvl270_se9TX :: m_ae3ez Int
            [LclId]
            lvl270_se9TX = ds_de7s0 @ Int Data.Data.$fDataInt a2_ae2n9 } in
          >>=
            @ m_ae3ez
            $dMonad_ae3eB
            @ (Int -> Generics.Fixity)
            @ Generics.Fixity
            (let {
               lvl271_se9TW :: m_ae3ez Associativity
               [LclId]
               lvl271_se9TW
                 = ds_de7s0
                     @ Associativity Data.Data.$fDataAssociativity a1_ae2n8 } in
             >>=
               @ m_ae3ez
               $dMonad_ae3eB
               @ (Associativity -> Int -> Generics.Fixity)
               @ (Int -> Generics.Fixity)
               (return
                  @ m_ae3ez
                  $dMonad_ae3eB
                  @ (Associativity -> Int -> Generics.Fixity)
                  GHC.Generics.Infix)
               (\ (c'_ae1To :: Associativity -> Int -> Generics.Fixity) ->
                  >>=
                    @ m_ae3ez
                    $dMonad_ae3eB
                    @ Associativity
                    @ (Int -> Generics.Fixity)
                    lvl271_se9TW
                    (\ (x'_ae1Tp :: Associativity) ->
                       return
                         @ m_ae3ez
                         $dMonad_ae3eB
                         @ (Int -> Generics.Fixity)
                         (c'_ae1To x'_ae1Tp))))
            (\ (c'_ae1To :: Int -> Generics.Fixity) ->
               >>=
                 @ m_ae3ez
                 $dMonad_ae3eB
                 @ Int
                 @ Generics.Fixity
                 lvl270_se9TX
                 (\ (x'_ae1Tp :: Int) ->
                    return
                      @ m_ae3ez $dMonad_ae3eB @ Generics.Fixity (c'_ae1To x'_ae1Tp)))
      }

-- RHS size: {terms: 21, types: 18, coercions: 0, joins: 0/0}
Data.Data.$w$cgmapQi4 [InlPrag=NOUSERINLINE[0]]
  :: forall u.
     Int# -> (forall d. Data d => d -> u) -> Generics.Fixity -> u
[GblId,
 Arity=3,
 Str=<S,1*U><C(C(S)),1*C1(C1(U))><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [70 120 30] 110 0}]
Data.Data.$w$cgmapQi4
  = \ (@ u_segzu)
      (ww_segzA :: Int#)
      (w_segzw :: forall d. Data d => d -> u_segzu)
      (w1_segzx :: Generics.Fixity) ->
      case w1_segzx of {
        Generics.Prefix -> Data.Maybe.fromJust1 @ u_segzu;
        Generics.Infix a1_ae2n8 a2_ae2n9 ->
          case ww_segzA of {
            __DEFAULT -> Data.Maybe.fromJust1 @ u_segzu;
            0# ->
              w_segzw @ Associativity Data.Data.$fDataAssociativity a1_ae2n8;
            1# -> w_segzw @ Int Data.Data.$fDataInt a2_ae2n9
          }
      }

-- RHS size: {terms: 11, types: 13, coercions: 0, joins: 0/0}
Data.Data.$fDataFixity_$cgmapQi [InlPrag=NOUSERINLINE[0]]
  :: forall u.
     Int -> (forall d. Data d => d -> u) -> Generics.Fixity -> u
[GblId,
 Arity=3,
 Str=<S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_segzu)
                 (w_segzv [Occ=Once!] :: Int)
                 (w1_segzw [Occ=Once] :: forall d. Data d => d -> u_segzu)
                 (w2_segzx [Occ=Once] :: Generics.Fixity) ->
                 case w_segzv of { I# ww1_segzA [Occ=Once] ->
                 Data.Data.$w$cgmapQi4 @ u_segzu ww1_segzA w1_segzw w2_segzx
                 }}]
Data.Data.$fDataFixity_$cgmapQi
  = \ (@ u_segzu)
      (w_segzv :: Int)
      (w1_segzw :: forall d. Data d => d -> u_segzu)
      (w2_segzx :: Generics.Fixity) ->
      case w_segzv of { I# ww1_segzA ->
      Data.Data.$w$cgmapQi4 @ u_segzu ww1_segzA w1_segzw w2_segzx
      }

-- RHS size: {terms: 20, types: 20, coercions: 0, joins: 0/0}
Data.Data.$fDataFixity_$cgmapQr
  :: forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> Generics.Fixity -> r
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,U><L,C(C1(U))><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 120 30] 140 0}]
Data.Data.$fDataFixity_$cgmapQr
  = \ (@ r_ae3dQ)
      (@ r'_ae3dR)
      (ds_de7rU :: r'_ae3dR -> r_ae3dQ -> r_ae3dQ)
      (ds1_de7rV :: r_ae3dQ)
      (ds2_de7rW :: forall d. Data d => d -> r'_ae3dR)
      (x0_ae1SX :: Generics.Fixity) ->
      case x0_ae1SX of {
        Generics.Prefix -> ds1_de7rV;
        Generics.Infix a1_ae2n8 a2_ae2n9 ->
          ds_de7rU
            (ds2_de7rW @ Associativity Data.Data.$fDataAssociativity a1_ae2n8)
            (ds_de7rU (ds2_de7rW @ Int Data.Data.$fDataInt a2_ae2n9) ds1_de7rV)
      }

-- RHS size: {terms: 17, types: 18, coercions: 0, joins: 0/0}
Data.Data.$fDataFixity_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> Generics.Fixity -> [u]
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [120 30] 100 40}]
Data.Data.$fDataFixity_$cgmapQ
  = \ (@ u_ae3e7)
      (ds_de7rX :: forall d. Data d => d -> u_ae3e7)
      (x0_ae1SX :: Generics.Fixity) ->
      case x0_ae1SX of {
        Generics.Prefix -> GHC.Types.[] @ u_ae3e7;
        Generics.Infix a1_ae2n8 a2_ae2n9 ->
          GHC.Types.:
            @ u_ae3e7
            (ds_de7rX @ Associativity Data.Data.$fDataAssociativity a1_ae2n8)
            (GHC.Types.:
               @ u_ae3e7
               (ds_de7rX @ Int Data.Data.$fDataInt a2_ae2n9)
               (GHC.Types.[] @ u_ae3e7))
      }

-- RHS size: {terms: 20, types: 20, coercions: 12, joins: 0/0}
Data.Data.$fDataFixity1
  :: forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data d => d -> r')
     -> Generics.Fixity
     -> Const r Generics.Fixity
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,U><L,C(C1(U))><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 120 30] 140 0}]
Data.Data.$fDataFixity1
  = \ (@ r_ae3dz)
      (@ r'_ae3dA)
      (ds_de7rR :: r_ae3dz -> r'_ae3dA -> r_ae3dz)
      (ds1_de7rS :: r_ae3dz)
      (ds2_de7rT :: forall d. Data d => d -> r'_ae3dA)
      (eta_XPv :: Generics.Fixity) ->
      case eta_XPv of {
        Generics.Prefix ->
          ds1_de7rS
          `cast` (Sym (Data.Functor.Const.N:Const[0]
                           <*>_N <r_ae3dz>_R <Generics.Fixity>_P)
                  :: (r_ae3dz :: *) ~R# (Const r_ae3dz Generics.Fixity :: *));
        Generics.Infix a1_ae2n8 a2_ae2n9 ->
          (ds_de7rR
             (ds_de7rR
                ds1_de7rS
                (ds2_de7rT @ Associativity Data.Data.$fDataAssociativity a1_ae2n8))
             (ds2_de7rT @ Int Data.Data.$fDataInt a2_ae2n9))
          `cast` (Sym (Data.Functor.Const.N:Const[0]
                           <*>_N <r_ae3dz>_R <Generics.Fixity>_P)
                  :: (r_ae3dz :: *) ~R# (Const r_ae3dz Generics.Fixity :: *))
      }

-- RHS size: {terms: 14, types: 12, coercions: 6, joins: 0/0}
Data.Data.$fDataFixity2
  :: (forall b. Data b => b -> b)
     -> Generics.Fixity -> Identity Generics.Fixity
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_de7rQ :: forall b. Data b => b -> b)
                 (x0_Xe38U [Occ=Once!] :: Generics.Fixity) ->
                 case x0_Xe38U of {
                   Generics.Prefix ->
                     GHC.Generics.Prefix
                     `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Generics.Fixity>_R)
                             :: (Generics.Fixity :: *) ~R# (Identity Generics.Fixity :: *));
                   Generics.Infix a1_ae2n8 [Occ=Once] a2_ae2n9 [Occ=Once] ->
                     (GHC.Generics.Infix
                        (ds_de7rQ @ Associativity Data.Data.$fDataAssociativity a1_ae2n8)
                        (ds_de7rQ @ Int Data.Data.$fDataInt a2_ae2n9))
                     `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                                      <Generics.Fixity>_R)
                             :: (Generics.Fixity :: *) ~R# (Identity Generics.Fixity :: *))
                 }}]
Data.Data.$fDataFixity2
  = \ (ds_de7rQ :: forall b. Data b => b -> b)
      (x0_Xe38U :: Generics.Fixity) ->
      case x0_Xe38U of {
        Generics.Prefix ->
          GHC.Generics.Prefix
          `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                           <Generics.Fixity>_R)
                  :: (Generics.Fixity :: *) ~R# (Identity Generics.Fixity :: *));
        Generics.Infix a1_ae2n8 a2_ae2n9 ->
          (GHC.Generics.Infix
             (ds_de7rQ @ Associativity Data.Data.$fDataAssociativity a1_ae2n8)
             (ds_de7rQ @ Int Data.Data.$fDataInt a2_ae2n9))
          `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                           <Generics.Fixity>_R)
                  :: (Generics.Fixity :: *) ~R# (Identity Generics.Fixity :: *))
      }

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataFixity_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e))
     -> Maybe (c Generics.Fixity)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae3d1 :: * -> * -> *))
                 (@ (c_ae3d2 :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae3d2 Generics.Fixity)}]
Data.Data.$fDataFixity_$cdataCast2
  = \ (@ (t_ae3d1 :: * -> * -> *))
      (@ (c_ae3d2 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae3d2 Generics.Fixity)

-- RHS size: {terms: 110, types: 165, coercions: 0, joins: 0/4}
Data.Data.$fDataFixity_$cgmapMo
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d)
     -> Generics.Fixity -> m Generics.Fixity
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U>,
 Unf=OtherCon []]
Data.Data.$fDataFixity_$cgmapMo
  = \ (@ (m_ae3f5 :: * -> *))
      ($dMonadPlus_ae3f7 :: MonadPlus m_ae3f5)
      (ds_de7s2 :: forall d. Data d => d -> m_ae3f5 d)
      (eta_XPE :: Generics.Fixity) ->
      let {
        lvl270_se9Ub :: m_ae3f5 Generics.Fixity
        [LclId]
        lvl270_se9Ub
          = mzero @ m_ae3f5 $dMonadPlus_ae3f7 @ Generics.Fixity } in
      let {
        $dMonad_se9pl [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae3f5
        [LclId]
        $dMonad_se9pl
          = GHC.Base.$p2MonadPlus @ m_ae3f5 $dMonadPlus_ae3f7 } in
      >>=
        @ m_ae3f5
        $dMonad_se9pl
        @ (Generics.Fixity, Bool)
        @ Generics.Fixity
        (case eta_XPE of {
           Generics.Prefix ->
             return
               @ m_ae3f5 $dMonad_se9pl @ (Generics.Fixity, Bool) lvl219_rejUE;
           Generics.Infix a1_ae2n8 a2_ae2n9 ->
             let {
               lvl271_se9U7 :: m_ae3f5 Int
               [LclId]
               lvl271_se9U7 = ds_de7s2 @ Int Data.Data.$fDataInt a2_ae2n9 } in
             >>=
               @ m_ae3f5
               $dMonad_se9pl
               @ (Int -> Generics.Fixity, Bool)
               @ (Generics.Fixity, Bool)
               (let {
                  lvl272_se9U6 :: m_ae3f5 Associativity
                  [LclId]
                  lvl272_se9U6
                    = ds_de7s2
                        @ Associativity Data.Data.$fDataAssociativity a1_ae2n8 } in
                >>=
                  @ m_ae3f5
                  $dMonad_se9pl
                  @ (Associativity -> Int -> Generics.Fixity, Bool)
                  @ (Int -> Generics.Fixity, Bool)
                  (return
                     @ m_ae3f5
                     $dMonad_se9pl
                     @ (Associativity -> Int -> Generics.Fixity, Bool)
                     lvl220_rejUF)
                  (\ (ds1_de7pD
                        :: (Associativity -> Int -> Generics.Fixity, Bool)) ->
                     case ds1_de7pD of { (h_ae1TP, b_ae1TQ) ->
                     case b_ae1TQ of {
                       False ->
                         mplus
                           @ m_ae3f5
                           $dMonadPlus_ae3f7
                           @ (Int -> Generics.Fixity, Bool)
                           (>>=
                              @ m_ae3f5
                              $dMonad_se9pl
                              @ Associativity
                              @ (Int -> Generics.Fixity, Bool)
                              lvl272_se9U6
                              (\ (y'_ae1TR :: Associativity) ->
                                 return
                                   @ m_ae3f5
                                   $dMonad_se9pl
                                   @ (Int -> Generics.Fixity, Bool)
                                   (h_ae1TP y'_ae1TR, GHC.Types.True)))
                           (return
                              @ m_ae3f5
                              $dMonad_se9pl
                              @ (Int -> Generics.Fixity, Bool)
                              (h_ae1TP a1_ae2n8, GHC.Types.False));
                       True ->
                         return
                           @ m_ae3f5
                           $dMonad_se9pl
                           @ (Int -> Generics.Fixity, Bool)
                           (h_ae1TP a1_ae2n8, GHC.Types.True)
                     }
                     }))
               (\ (ds1_de7pD :: (Int -> Generics.Fixity, Bool)) ->
                  case ds1_de7pD of { (h_ae1TP, b_ae1TQ) ->
                  case b_ae1TQ of {
                    False ->
                      mplus
                        @ m_ae3f5
                        $dMonadPlus_ae3f7
                        @ (Generics.Fixity, Bool)
                        (>>=
                           @ m_ae3f5
                           $dMonad_se9pl
                           @ Int
                           @ (Generics.Fixity, Bool)
                           lvl271_se9U7
                           (\ (y'_ae1TR :: Int) ->
                              return
                                @ m_ae3f5
                                $dMonad_se9pl
                                @ (Generics.Fixity, Bool)
                                (h_ae1TP y'_ae1TR, GHC.Types.True)))
                        (return
                           @ m_ae3f5
                           $dMonad_se9pl
                           @ (Generics.Fixity, Bool)
                           (h_ae1TP a2_ae2n9, GHC.Types.False));
                    True ->
                      return
                        @ m_ae3f5
                        $dMonad_se9pl
                        @ (Generics.Fixity, Bool)
                        (h_ae1TP a2_ae2n9, GHC.Types.True)
                  }
                  })
         })
        (\ (ds1_de7pa :: (Generics.Fixity, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9Ub;
             True -> return @ m_ae3f5 $dMonad_se9pl @ Generics.Fixity x'_ae1TS
           }
           })

-- RHS size: {terms: 16, types: 1, coercions: 42, joins: 0/0}
Data.Data.$fDataFixity [InlPrag=NOUSERINLINE CONLIKE]
  :: Data Generics.Fixity
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: Generics.Fixity
                        Data.Data.$fDataFixity3
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Generics.Fixity>_N
                                :: (Data.Typeable.Internal.TypeRep Generics.Fixity :: *)
                                   ~R# (Typeable Generics.Fixity :: Constraint))
                        Data.Data.$fDataFixity_$cgfoldl
                        Data.Data.$fDataFixity_$cgunfold
                        Data.Data.$fDataFixity_$ctoConstr
                        Data.Data.$fDataFixity_$cdataTypeOf
                        Data.Data.$fDataFixity_$cdataCast1
                        Data.Data.$fDataFixity_$cdataCast2
                        Data.Data.$fDataFixity2
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <Generics.Fixity>_R
                                ->_R Data.Functor.Identity.N:Identity[0] <Generics.Fixity>_R
                                :: ((forall b. Data b => b -> b)
                                    -> Generics.Fixity -> Identity Generics.Fixity :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> Generics.Fixity -> Generics.Fixity :: *))
                        Data.Data.$fDataFixity1
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <Generics.Fixity>_R
                                ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <Generics.Fixity>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> Generics.Fixity
                                    -> Const r Generics.Fixity :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d. Data d => d -> r')
                                        -> Generics.Fixity
                                        -> r :: *))
                        Data.Data.$fDataFixity_$cgmapQr
                        Data.Data.$fDataFixity_$cgmapQ
                        Data.Data.$fDataFixity_$cgmapQi
                        Data.Data.$fDataFixity_$cgmapM
                        Data.Data.$fDataFixity_$cgmapMp
                        Data.Data.$fDataFixity_$cgmapMo]
Data.Data.$fDataFixity
  = Data.Data.C:Data
      @ Generics.Fixity
      (Data.Data.$fDataFixity3
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Generics.Fixity>_N
               :: (Data.Typeable.Internal.TypeRep Generics.Fixity :: *)
                  ~R# (Typeable Generics.Fixity :: Constraint)))
      Data.Data.$fDataFixity_$cgfoldl
      Data.Data.$fDataFixity_$cgunfold
      Data.Data.$fDataFixity_$ctoConstr
      Data.Data.$fDataFixity_$cdataTypeOf
      Data.Data.$fDataFixity_$cdataCast1
      Data.Data.$fDataFixity_$cdataCast2
      (Data.Data.$fDataFixity2
       `cast` (<forall b. Data b => b -> b>_R
               ->_R <Generics.Fixity>_R
               ->_R Data.Functor.Identity.N:Identity[0] <Generics.Fixity>_R
               :: ((forall b. Data b => b -> b)
                   -> Generics.Fixity -> Identity Generics.Fixity :: *)
                  ~R# ((forall b. Data b => b -> b)
                       -> Generics.Fixity -> Generics.Fixity :: *)))
      (Data.Data.$fDataFixity1
       `cast` (forall (r :: <*>_N) (r' :: <*>_N).
               <r -> r' -> r>_R
               ->_R <r>_R
               ->_R <forall d. Data d => d -> r'>_R
               ->_R <Generics.Fixity>_R
               ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <Generics.Fixity>_P
               :: (forall r r'.
                   (r -> r' -> r)
                   -> r
                   -> (forall d. Data d => d -> r')
                   -> Generics.Fixity
                   -> Const r Generics.Fixity :: *)
                  ~R# (forall r r'.
                       (r -> r' -> r)
                       -> r
                       -> (forall d. Data d => d -> r')
                       -> Generics.Fixity
                       -> r :: *)))
      Data.Data.$fDataFixity_$cgmapQr
      Data.Data.$fDataFixity_$cgmapQ
      Data.Data.$fDataFixity_$cgmapQi
      Data.Data.$fDataFixity_$cgmapM
      Data.Data.$fDataFixity_$cgmapMp
      Data.Data.$fDataFixity_$cgmapMo

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tSourceUnpackedness1_rejUG :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$tSourceUnpackedness1_rejUG = "SourceUnpackedness"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tSourceUnpackedness2_rejUH :: [Char]
[GblId]
$tSourceUnpackedness2_rejUH
  = unpackCString# $tSourceUnpackedness1_rejUG

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str36_rejUI :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str36_rejUI = "NoSourceUnpackedness"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str37_rejUJ :: String
[GblId]
str37_rejUJ = unpackCString# str36_rejUI

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str38_rejUK :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str38_rejUK = "SourceNoUnpack"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str39_rejUL :: String
[GblId]
str39_rejUL = unpackCString# str38_rejUK

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str40_rejUM :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str40_rejUM = "SourceUnpack"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str41_rejUN :: String
[GblId]
str41_rejUN = unpackCString# str40_rejUM

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go49_rejUO :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go49_rejUO
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str37_rejUJ of {
                False -> go49_rejUO ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go50_rejUP :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go50_rejUP
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str39_rejUL of {
                False -> go50_rejUP ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go51_rejUQ :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go51_rejUQ
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str41_rejUN of {
                False -> go51_rejUQ ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cNoSourceUnpackedness1_rejUR :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cNoSourceUnpackedness1_rejUR
  = Data.Data.AlgConstr $cNoSourceUnpackedness2_rejV0

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cSourceNoUnpack1_rejUS :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cSourceNoUnpack1_rejUS
  = Data.Data.AlgConstr $cSourceNoUnpack2_rejUZ

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cSourceUnpack1_rejUT :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cSourceUnpack1_rejUT = Data.Data.AlgConstr $cSourceUnpack2_rejUY

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$tSourceUnpackedness3_rejUU :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tSourceUnpackedness3_rejUU
  = GHC.Types.:
      @ Constr Data.Data.$cSourceUnpack (GHC.Types.[] @ Constr)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$tSourceUnpackedness4_rejUV :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tSourceUnpackedness4_rejUV
  = GHC.Types.:
      @ Constr
      Data.Data.$cNoSourceUnpackedness
      $tSourceUnpackedness6_rejUX

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tSourceUnpackedness5_rejUW :: DataRep
[GblId, Str=m1, Unf=OtherCon []]
$tSourceUnpackedness5_rejUW
  = Data.Data.AlgRep $tSourceUnpackedness4_rejUV

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tSourceUnpackedness [Occ=LoopBreaker] :: DataType
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$tSourceUnpackedness
  = Data.Data.DataType
      $tSourceUnpackedness2_rejUH $tSourceUnpackedness5_rejUW

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cSourceNoUnpack [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cSourceNoUnpack
  = Data.Data.Constr
      $cSourceNoUnpack1_rejUS
      str39_rejUL
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tSourceUnpackedness

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$tSourceUnpackedness6_rejUX :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tSourceUnpackedness6_rejUX
  = GHC.Types.:
      @ Constr Data.Data.$cSourceNoUnpack $tSourceUnpackedness3_rejUU

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cNoSourceUnpackedness [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cNoSourceUnpackedness
  = Data.Data.Constr
      $cNoSourceUnpackedness1_rejUR
      str37_rejUJ
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tSourceUnpackedness

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cSourceUnpack [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cSourceUnpack
  = Data.Data.Constr
      $cSourceUnpack1_rejUT
      str41_rejUN
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tSourceUnpackedness

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cSourceUnpack2_rejUY :: ConIndex
[GblId]
$cSourceUnpack2_rejUY
  = go51_rejUQ $tSourceUnpackedness4_rejUV Data.Data.mkConstr1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cSourceNoUnpack2_rejUZ :: ConIndex
[GblId]
$cSourceNoUnpack2_rejUZ
  = go50_rejUP $tSourceUnpackedness4_rejUV Data.Data.mkConstr1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cNoSourceUnpackedness2_rejV0 :: ConIndex
[GblId]
$cNoSourceUnpackedness2_rejV0
  = go49_rejUO $tSourceUnpackedness4_rejUV Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceUnpackedness_$cdataTypeOf
  :: SourceUnpackedness -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Data.$tSourceUnpackedness}]
Data.Data.$fDataSourceUnpackedness_$cdataTypeOf
  = \ _ [Occ=Dead] -> Data.Data.$tSourceUnpackedness

-- RHS size: {terms: 9, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceUnpackedness_$ctoConstr
  :: SourceUnpackedness -> Constr
[GblId,
 Arity=1,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_de7r0 [Occ=Once!] :: SourceUnpackedness) ->
                 case ds_de7r0 of {
                   NoSourceUnpackedness -> Data.Data.$cNoSourceUnpackedness;
                   SourceNoUnpack -> Data.Data.$cSourceNoUnpack;
                   SourceUnpack -> Data.Data.$cSourceUnpack
                 }}]
Data.Data.$fDataSourceUnpackedness_$ctoConstr
  = \ (ds_de7r0 :: SourceUnpackedness) ->
      case ds_de7r0 of {
        NoSourceUnpackedness -> Data.Data.$cNoSourceUnpackedness;
        SourceNoUnpack -> Data.Data.$cSourceNoUnpack;
        SourceUnpack -> Data.Data.$cSourceUnpack
      }

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceUnpackedness_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c SourceUnpackedness)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae36e :: * -> *))
                 (@ (c_ae36f :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae36f SourceUnpackedness)}]
Data.Data.$fDataSourceUnpackedness_$cdataCast1
  = \ (@ (t_ae36e :: * -> *))
      (@ (c_ae36f :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae36f SourceUnpackedness)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceUnpackedness3 :: (SourceUnpackedness, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataSourceUnpackedness3
  = (GHC.Generics.NoSourceUnpackedness, GHC.Types.False)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceUnpackedness2 :: (SourceUnpackedness, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataSourceUnpackedness2
  = (GHC.Generics.SourceNoUnpack, GHC.Types.False)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceUnpackedness1 :: (SourceUnpackedness, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataSourceUnpackedness1
  = (GHC.Generics.SourceUnpack, GHC.Types.False)

-- RHS size: {terms: 37, types: 43, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp31 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     SourceUnpackedness -> m SourceUnpackedness
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 100] 290 0}]
Data.Data.$w$cgmapMp31
  = \ (@ (m_segA2 :: * -> *))
      (w_segA3 :: MonadPlus m_segA2)
      (w1_segA5 :: SourceUnpackedness) ->
      let {
        lvl270_se9Ur :: m_segA2 SourceUnpackedness
        [LclId]
        lvl270_se9Ur = mzero @ m_segA2 w_segA3 @ SourceUnpackedness } in
      let {
        $dMonad_se9ph [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_segA2
        [LclId]
        $dMonad_se9ph = GHC.Base.$p2MonadPlus @ m_segA2 w_segA3 } in
      >>=
        @ m_segA2
        $dMonad_se9ph
        @ (SourceUnpackedness, Bool)
        @ SourceUnpackedness
        (case w1_segA5 of {
           NoSourceUnpackedness ->
             return
               @ m_segA2
               $dMonad_se9ph
               @ (SourceUnpackedness, Bool)
               Data.Data.$fDataSourceUnpackedness3;
           SourceNoUnpack ->
             return
               @ m_segA2
               $dMonad_se9ph
               @ (SourceUnpackedness, Bool)
               Data.Data.$fDataSourceUnpackedness2;
           SourceUnpack ->
             return
               @ m_segA2
               $dMonad_se9ph
               @ (SourceUnpackedness, Bool)
               Data.Data.$fDataSourceUnpackedness1
         })
        (\ (ds_de7oa :: (SourceUnpackedness, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9Ur;
             True ->
               return @ m_segA2 $dMonad_se9ph @ SourceUnpackedness x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceUnpackedness_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d)
     -> SourceUnpackedness -> m SourceUnpackedness
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_segA2 :: * -> *))
                 (w_segA3 [Occ=Once] :: MonadPlus m_segA2)
                 _ [Occ=Dead]
                 (w2_segA5 [Occ=Once] :: SourceUnpackedness) ->
                 Data.Data.$w$cgmapMp31 @ m_segA2 w_segA3 w2_segA5}]
Data.Data.$fDataSourceUnpackedness_$cgmapMp
  = \ (@ (m_segA2 :: * -> *))
      (w_segA3 :: MonadPlus m_segA2)
      _ [Occ=Dead]
      (w2_segA5 :: SourceUnpackedness) ->
      Data.Data.$w$cgmapMp31 @ m_segA2 w_segA3 w2_segA5

-- RHS size: {terms: 17, types: 14, coercions: 0, joins: 0/0}
Data.Data.$w$cgmapM17 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     Monad m =>
     SourceUnpackedness -> m SourceUnpackedness
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 100] 120 0}]
Data.Data.$w$cgmapM17
  = \ (@ (m_segA7 :: * -> *))
      (w_segA8 :: Monad m_segA7)
      (w1_segAa :: SourceUnpackedness) ->
      case w1_segAa of {
        NoSourceUnpackedness ->
          return
            @ m_segA7
            w_segA8
            @ SourceUnpackedness
            GHC.Generics.NoSourceUnpackedness;
        SourceNoUnpack ->
          return
            @ m_segA7 w_segA8 @ SourceUnpackedness GHC.Generics.SourceNoUnpack;
        SourceUnpack ->
          return
            @ m_segA7 w_segA8 @ SourceUnpackedness GHC.Generics.SourceUnpack
      }

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceUnpackedness_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d)
     -> SourceUnpackedness -> m SourceUnpackedness
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_segA7 :: * -> *))
                 (w_segA8 [Occ=Once] :: Monad m_segA7)
                 _ [Occ=Dead]
                 (w2_segAa [Occ=Once] :: SourceUnpackedness) ->
                 Data.Data.$w$cgmapM17 @ m_segA7 w_segA8 w2_segAa}]
Data.Data.$fDataSourceUnpackedness_$cgmapM
  = \ (@ (m_segA7 :: * -> *))
      (w_segA8 :: Monad m_segA7)
      _ [Occ=Dead]
      (w2_segAa :: SourceUnpackedness) ->
      Data.Data.$w$cgmapM17 @ m_segA7 w_segA8 w2_segAa

-- RHS size: {terms: 8, types: 12, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceUnpackedness_$cgmapQi
  :: forall u.
     Int -> (forall d. Data d => d -> u) -> SourceUnpackedness -> u
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,1*U>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae37R)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (x_ae1T7 [Occ=Once] :: SourceUnpackedness) ->
                 case x_ae1T7 of { __DEFAULT -> Data.Maybe.fromJust1 @ u_ae37R }}]
Data.Data.$fDataSourceUnpackedness_$cgmapQi
  = \ (@ u_ae37R)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (x_ae1T7 :: SourceUnpackedness) ->
      case x_ae1T7 of { __DEFAULT -> Data.Maybe.fromJust1 @ u_ae37R }

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceUnpackedness_$cgmapQr
  :: forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> SourceUnpackedness -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_ae37m)
                 (@ r'_ae37n)
                 _ [Occ=Dead]
                 (ds1_de7r9 [Occ=Once] :: r_ae37m)
                 _ [Occ=Dead]
                 (x0_ae1SX [Occ=Once] :: SourceUnpackedness) ->
                 case x0_ae1SX of { __DEFAULT -> ds1_de7r9 }}]
Data.Data.$fDataSourceUnpackedness_$cgmapQr
  = \ (@ r_ae37m)
      (@ r'_ae37n)
      _ [Occ=Dead]
      (ds1_de7r9 :: r_ae37m)
      _ [Occ=Dead]
      (x0_ae1SX :: SourceUnpackedness) ->
      case x0_ae1SX of { __DEFAULT -> ds1_de7r9 }

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceUnpackedness_$cgmapQ
  :: forall u.
     (forall d. Data d => d -> u) -> SourceUnpackedness -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae37D)
                 _ [Occ=Dead]
                 (x0_ae1SX [Occ=Once] :: SourceUnpackedness) ->
                 case x0_ae1SX of { __DEFAULT -> GHC.Types.[] @ u_ae37D }}]
Data.Data.$fDataSourceUnpackedness_$cgmapQ
  = \ (@ u_ae37D) _ [Occ=Dead] (x0_ae1SX :: SourceUnpackedness) ->
      case x0_ae1SX of { __DEFAULT -> GHC.Types.[] @ u_ae37D }

-- RHS size: {terms: 10, types: 16, coercions: 6, joins: 0/0}
Data.Data.$fDataSourceUnpackedness4
  :: forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data d => d -> r')
     -> SourceUnpackedness
     -> Const r SourceUnpackedness
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_ae375)
                 (@ r'_ae376)
                 _ [Occ=Dead]
                 (ds1_de7r6 [Occ=Once] :: r_ae375)
                 _ [Occ=Dead]
                 (eta_XPX [Occ=Once] :: SourceUnpackedness) ->
                 case eta_XPX of { __DEFAULT ->
                 ds1_de7r6
                 `cast` (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r_ae375>_R <SourceUnpackedness>_P)
                         :: (r_ae375 :: *) ~R# (Const r_ae375 SourceUnpackedness :: *))
                 }}]
Data.Data.$fDataSourceUnpackedness4
  = \ (@ r_ae375)
      (@ r'_ae376)
      _ [Occ=Dead]
      (ds1_de7r6 :: r_ae375)
      _ [Occ=Dead]
      (eta_XPX :: SourceUnpackedness) ->
      case eta_XPX of { __DEFAULT ->
      ds1_de7r6
      `cast` (Sym (Data.Functor.Const.N:Const[0]
                       <*>_N <r_ae375>_R <SourceUnpackedness>_P)
              :: (r_ae375 :: *) ~R# (Const r_ae375 SourceUnpackedness :: *))
      }

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceUnpackedness5
  :: (forall b. Data b => b -> b)
     -> SourceUnpackedness -> SourceUnpackedness
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (x0_Xe39m [Occ=Once] :: SourceUnpackedness) ->
                 x0_Xe39m}]
Data.Data.$fDataSourceUnpackedness5
  = \ _ [Occ=Dead] (x0_Xe39m :: SourceUnpackedness) -> x0_Xe39m

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceUnpackedness_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e))
     -> Maybe (c SourceUnpackedness)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae36x :: * -> * -> *))
                 (@ (c_ae36y :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae36y SourceUnpackedness)}]
Data.Data.$fDataSourceUnpackedness_$cdataCast2
  = \ (@ (t_ae36x :: * -> * -> *))
      (@ (c_ae36y :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae36y SourceUnpackedness)

-- RHS size: {terms: 37, types: 43, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo30 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     SourceUnpackedness -> m SourceUnpackedness
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 100] 290 0}]
Data.Data.$w$cgmapMo30
  = \ (@ (m_segAc :: * -> *))
      (w_segAd :: MonadPlus m_segAc)
      (w1_segAf :: SourceUnpackedness) ->
      let {
        lvl270_se9UD :: m_segAc SourceUnpackedness
        [LclId]
        lvl270_se9UD = mzero @ m_segAc w_segAd @ SourceUnpackedness } in
      let {
        $dMonad_se9pf [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_segAc
        [LclId]
        $dMonad_se9pf = GHC.Base.$p2MonadPlus @ m_segAc w_segAd } in
      >>=
        @ m_segAc
        $dMonad_se9pf
        @ (SourceUnpackedness, Bool)
        @ SourceUnpackedness
        (case w1_segAf of {
           NoSourceUnpackedness ->
             return
               @ m_segAc
               $dMonad_se9pf
               @ (SourceUnpackedness, Bool)
               Data.Data.$fDataSourceUnpackedness3;
           SourceNoUnpack ->
             return
               @ m_segAc
               $dMonad_se9pf
               @ (SourceUnpackedness, Bool)
               Data.Data.$fDataSourceUnpackedness2;
           SourceUnpack ->
             return
               @ m_segAc
               $dMonad_se9pf
               @ (SourceUnpackedness, Bool)
               Data.Data.$fDataSourceUnpackedness1
         })
        (\ (ds_de7pa :: (SourceUnpackedness, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9UD;
             True ->
               return @ m_segAc $dMonad_se9pf @ SourceUnpackedness x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceUnpackedness_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d)
     -> SourceUnpackedness -> m SourceUnpackedness
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_segAc :: * -> *))
                 (w_segAd [Occ=Once] :: MonadPlus m_segAc)
                 _ [Occ=Dead]
                 (w2_segAf [Occ=Once] :: SourceUnpackedness) ->
                 Data.Data.$w$cgmapMo30 @ m_segAc w_segAd w2_segAf}]
Data.Data.$fDataSourceUnpackedness_$cgmapMo
  = \ (@ (m_segAc :: * -> *))
      (w_segAd :: MonadPlus m_segAc)
      _ [Occ=Dead]
      (w2_segAf :: SourceUnpackedness) ->
      Data.Data.$w$cgmapMo30 @ m_segAc w_segAd w2_segAf

-- RHS size: {terms: 16, types: 1, coercions: 31, joins: 0/0}
Data.Data.$fDataSourceUnpackedness [InlPrag=NOUSERINLINE CONLIKE]
  :: Data SourceUnpackedness
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: SourceUnpackedness
                        Data.Data.$fDataSourceUnpackedness6
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <SourceUnpackedness>_N
                                :: (Data.Typeable.Internal.TypeRep SourceUnpackedness :: *)
                                   ~R# (Typeable SourceUnpackedness :: Constraint))
                        Data.Data.$fDataSourceUnpackedness_$cgfoldl
                        Data.Data.$fDataSourceUnpackedness_$cgunfold
                        Data.Data.$fDataSourceUnpackedness_$ctoConstr
                        Data.Data.$fDataSourceUnpackedness_$cdataTypeOf
                        Data.Data.$fDataSourceUnpackedness_$cdataCast1
                        Data.Data.$fDataSourceUnpackedness_$cdataCast2
                        Data.Data.$fDataSourceUnpackedness5
                        Data.Data.$fDataSourceUnpackedness4
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <SourceUnpackedness>_R
                                ->_R Data.Functor.Const.N:Const[0]
                                         <*>_N <r>_R <SourceUnpackedness>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> SourceUnpackedness
                                    -> Const r SourceUnpackedness :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d. Data d => d -> r')
                                        -> SourceUnpackedness
                                        -> r :: *))
                        Data.Data.$fDataSourceUnpackedness_$cgmapQr
                        Data.Data.$fDataSourceUnpackedness_$cgmapQ
                        Data.Data.$fDataSourceUnpackedness_$cgmapQi
                        Data.Data.$fDataSourceUnpackedness_$cgmapM
                        Data.Data.$fDataSourceUnpackedness_$cgmapMp
                        Data.Data.$fDataSourceUnpackedness_$cgmapMo]
Data.Data.$fDataSourceUnpackedness
  = Data.Data.C:Data
      @ SourceUnpackedness
      (Data.Data.$fDataSourceUnpackedness6
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <SourceUnpackedness>_N
               :: (Data.Typeable.Internal.TypeRep SourceUnpackedness :: *)
                  ~R# (Typeable SourceUnpackedness :: Constraint)))
      Data.Data.$fDataSourceUnpackedness_$cgfoldl
      Data.Data.$fDataSourceUnpackedness_$cgunfold
      Data.Data.$fDataSourceUnpackedness_$ctoConstr
      Data.Data.$fDataSourceUnpackedness_$cdataTypeOf
      Data.Data.$fDataSourceUnpackedness_$cdataCast1
      Data.Data.$fDataSourceUnpackedness_$cdataCast2
      Data.Data.$fDataSourceUnpackedness5
      (Data.Data.$fDataSourceUnpackedness4
       `cast` (forall (r :: <*>_N) (r' :: <*>_N).
               <r -> r' -> r>_R
               ->_R <r>_R
               ->_R <forall d. Data d => d -> r'>_R
               ->_R <SourceUnpackedness>_R
               ->_R Data.Functor.Const.N:Const[0]
                        <*>_N <r>_R <SourceUnpackedness>_P
               :: (forall r r'.
                   (r -> r' -> r)
                   -> r
                   -> (forall d. Data d => d -> r')
                   -> SourceUnpackedness
                   -> Const r SourceUnpackedness :: *)
                  ~R# (forall r r'.
                       (r -> r' -> r)
                       -> r
                       -> (forall d. Data d => d -> r')
                       -> SourceUnpackedness
                       -> r :: *)))
      Data.Data.$fDataSourceUnpackedness_$cgmapQr
      Data.Data.$fDataSourceUnpackedness_$cgmapQ
      Data.Data.$fDataSourceUnpackedness_$cgmapQi
      Data.Data.$fDataSourceUnpackedness_$cgmapM
      Data.Data.$fDataSourceUnpackedness_$cgmapMp
      Data.Data.$fDataSourceUnpackedness_$cgmapMo

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tSourceStrictness1_rejV1 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$tSourceStrictness1_rejV1 = "SourceStrictness"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tSourceStrictness2_rejV2 :: [Char]
[GblId]
$tSourceStrictness2_rejV2
  = unpackCString# $tSourceStrictness1_rejV1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str42_rejV3 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str42_rejV3 = "NoSourceStrictness"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str43_rejV4 :: String
[GblId]
str43_rejV4 = unpackCString# str42_rejV3

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str44_rejV5 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str44_rejV5 = "SourceStrict"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str45_rejV6 :: String
[GblId]
str45_rejV6 = unpackCString# str44_rejV5

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str46_rejV7 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str46_rejV7 = "SourceLazy"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str47_rejV8 :: String
[GblId]
str47_rejV8 = unpackCString# str46_rejV7

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go52_rejV9 :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go52_rejV9
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str43_rejV4 of {
                False -> go52_rejV9 ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go53_rejVa :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go53_rejVa
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str47_rejV8 of {
                False -> go53_rejVa ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go54_rejVb :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go54_rejVb
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str45_rejV6 of {
                False -> go54_rejVb ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cNoSourceStrictness1_rejVc :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cNoSourceStrictness1_rejVc
  = Data.Data.AlgConstr $cNoSourceStrictness2_rejVl

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cSourceLazy1_rejVd :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cSourceLazy1_rejVd = Data.Data.AlgConstr $cSourceLazy2_rejVk

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cSourceStrict1_rejVe :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cSourceStrict1_rejVe = Data.Data.AlgConstr $cSourceStrict2_rejVj

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$tSourceStrictness3_rejVf :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tSourceStrictness3_rejVf
  = GHC.Types.:
      @ Constr Data.Data.$cSourceStrict (GHC.Types.[] @ Constr)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$tSourceStrictness4_rejVg :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tSourceStrictness4_rejVg
  = GHC.Types.:
      @ Constr Data.Data.$cNoSourceStrictness $tSourceStrictness6_rejVi

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tSourceStrictness5_rejVh :: DataRep
[GblId, Str=m1, Unf=OtherCon []]
$tSourceStrictness5_rejVh
  = Data.Data.AlgRep $tSourceStrictness4_rejVg

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tSourceStrictness [Occ=LoopBreaker] :: DataType
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$tSourceStrictness
  = Data.Data.DataType
      $tSourceStrictness2_rejV2 $tSourceStrictness5_rejVh

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cSourceLazy [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cSourceLazy
  = Data.Data.Constr
      $cSourceLazy1_rejVd
      str47_rejV8
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tSourceStrictness

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$tSourceStrictness6_rejVi :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tSourceStrictness6_rejVi
  = GHC.Types.:
      @ Constr Data.Data.$cSourceLazy $tSourceStrictness3_rejVf

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cNoSourceStrictness [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cNoSourceStrictness
  = Data.Data.Constr
      $cNoSourceStrictness1_rejVc
      str43_rejV4
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tSourceStrictness

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cSourceStrict [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cSourceStrict
  = Data.Data.Constr
      $cSourceStrict1_rejVe
      str45_rejV6
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tSourceStrictness

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cSourceStrict2_rejVj :: ConIndex
[GblId]
$cSourceStrict2_rejVj
  = go54_rejVb $tSourceStrictness4_rejVg Data.Data.mkConstr1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cSourceLazy2_rejVk :: ConIndex
[GblId]
$cSourceLazy2_rejVk
  = go53_rejVa $tSourceStrictness4_rejVg Data.Data.mkConstr1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cNoSourceStrictness2_rejVl :: ConIndex
[GblId]
$cNoSourceStrictness2_rejVl
  = go52_rejV9 $tSourceStrictness4_rejVg Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceStrictness_$cdataTypeOf
  :: SourceStrictness -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Data.$tSourceStrictness}]
Data.Data.$fDataSourceStrictness_$cdataTypeOf
  = \ _ [Occ=Dead] -> Data.Data.$tSourceStrictness

-- RHS size: {terms: 9, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceStrictness_$ctoConstr
  :: SourceStrictness -> Constr
[GblId,
 Arity=1,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_de7qD [Occ=Once!] :: SourceStrictness) ->
                 case ds_de7qD of {
                   NoSourceStrictness -> Data.Data.$cNoSourceStrictness;
                   SourceLazy -> Data.Data.$cSourceLazy;
                   SourceStrict -> Data.Data.$cSourceStrict
                 }}]
Data.Data.$fDataSourceStrictness_$ctoConstr
  = \ (ds_de7qD :: SourceStrictness) ->
      case ds_de7qD of {
        NoSourceStrictness -> Data.Data.$cNoSourceStrictness;
        SourceLazy -> Data.Data.$cSourceLazy;
        SourceStrict -> Data.Data.$cSourceStrict
      }

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceStrictness_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c SourceStrictness)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae335 :: * -> *))
                 (@ (c_ae336 :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae336 SourceStrictness)}]
Data.Data.$fDataSourceStrictness_$cdataCast1
  = \ (@ (t_ae335 :: * -> *))
      (@ (c_ae336 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae336 SourceStrictness)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceStrictness3 :: (SourceStrictness, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataSourceStrictness3
  = (GHC.Generics.NoSourceStrictness, GHC.Types.False)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceStrictness2 :: (SourceStrictness, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataSourceStrictness2
  = (GHC.Generics.SourceLazy, GHC.Types.False)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceStrictness1 :: (SourceStrictness, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataSourceStrictness1
  = (GHC.Generics.SourceStrict, GHC.Types.False)

-- RHS size: {terms: 37, types: 43, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp30 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     SourceStrictness -> m SourceStrictness
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 100] 290 0}]
Data.Data.$w$cgmapMp30
  = \ (@ (m_segAn :: * -> *))
      (w_segAo :: MonadPlus m_segAn)
      (w1_segAq :: SourceStrictness) ->
      let {
        lvl270_se9UT :: m_segAn SourceStrictness
        [LclId]
        lvl270_se9UT = mzero @ m_segAn w_segAo @ SourceStrictness } in
      let {
        $dMonad_se9pd [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_segAn
        [LclId]
        $dMonad_se9pd = GHC.Base.$p2MonadPlus @ m_segAn w_segAo } in
      >>=
        @ m_segAn
        $dMonad_se9pd
        @ (SourceStrictness, Bool)
        @ SourceStrictness
        (case w1_segAq of {
           NoSourceStrictness ->
             return
               @ m_segAn
               $dMonad_se9pd
               @ (SourceStrictness, Bool)
               Data.Data.$fDataSourceStrictness3;
           SourceLazy ->
             return
               @ m_segAn
               $dMonad_se9pd
               @ (SourceStrictness, Bool)
               Data.Data.$fDataSourceStrictness2;
           SourceStrict ->
             return
               @ m_segAn
               $dMonad_se9pd
               @ (SourceStrictness, Bool)
               Data.Data.$fDataSourceStrictness1
         })
        (\ (ds_de7oa :: (SourceStrictness, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9UT;
             True -> return @ m_segAn $dMonad_se9pd @ SourceStrictness x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceStrictness_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d)
     -> SourceStrictness -> m SourceStrictness
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_segAn :: * -> *))
                 (w_segAo [Occ=Once] :: MonadPlus m_segAn)
                 _ [Occ=Dead]
                 (w2_segAq [Occ=Once] :: SourceStrictness) ->
                 Data.Data.$w$cgmapMp30 @ m_segAn w_segAo w2_segAq}]
Data.Data.$fDataSourceStrictness_$cgmapMp
  = \ (@ (m_segAn :: * -> *))
      (w_segAo :: MonadPlus m_segAn)
      _ [Occ=Dead]
      (w2_segAq :: SourceStrictness) ->
      Data.Data.$w$cgmapMp30 @ m_segAn w_segAo w2_segAq

-- RHS size: {terms: 17, types: 14, coercions: 0, joins: 0/0}
Data.Data.$w$cgmapM16 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     Monad m =>
     SourceStrictness -> m SourceStrictness
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 100] 120 0}]
Data.Data.$w$cgmapM16
  = \ (@ (m_segAs :: * -> *))
      (w_segAt :: Monad m_segAs)
      (w1_segAv :: SourceStrictness) ->
      case w1_segAv of {
        NoSourceStrictness ->
          return
            @ m_segAs
            w_segAt
            @ SourceStrictness
            GHC.Generics.NoSourceStrictness;
        SourceLazy ->
          return
            @ m_segAs w_segAt @ SourceStrictness GHC.Generics.SourceLazy;
        SourceStrict ->
          return
            @ m_segAs w_segAt @ SourceStrictness GHC.Generics.SourceStrict
      }

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceStrictness_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d)
     -> SourceStrictness -> m SourceStrictness
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_segAs :: * -> *))
                 (w_segAt [Occ=Once] :: Monad m_segAs)
                 _ [Occ=Dead]
                 (w2_segAv [Occ=Once] :: SourceStrictness) ->
                 Data.Data.$w$cgmapM16 @ m_segAs w_segAt w2_segAv}]
Data.Data.$fDataSourceStrictness_$cgmapM
  = \ (@ (m_segAs :: * -> *))
      (w_segAt :: Monad m_segAs)
      _ [Occ=Dead]
      (w2_segAv :: SourceStrictness) ->
      Data.Data.$w$cgmapM16 @ m_segAs w_segAt w2_segAv

-- RHS size: {terms: 8, types: 12, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceStrictness_$cgmapQi
  :: forall u.
     Int -> (forall d. Data d => d -> u) -> SourceStrictness -> u
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,1*U>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae34I)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (x_ae1T7 [Occ=Once] :: SourceStrictness) ->
                 case x_ae1T7 of { __DEFAULT -> Data.Maybe.fromJust1 @ u_ae34I }}]
Data.Data.$fDataSourceStrictness_$cgmapQi
  = \ (@ u_ae34I)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (x_ae1T7 :: SourceStrictness) ->
      case x_ae1T7 of { __DEFAULT -> Data.Maybe.fromJust1 @ u_ae34I }

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceStrictness_$cgmapQr
  :: forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> SourceStrictness -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_ae34d)
                 (@ r'_ae34e)
                 _ [Occ=Dead]
                 (ds1_de7qM [Occ=Once] :: r_ae34d)
                 _ [Occ=Dead]
                 (x0_ae1SX [Occ=Once] :: SourceStrictness) ->
                 case x0_ae1SX of { __DEFAULT -> ds1_de7qM }}]
Data.Data.$fDataSourceStrictness_$cgmapQr
  = \ (@ r_ae34d)
      (@ r'_ae34e)
      _ [Occ=Dead]
      (ds1_de7qM :: r_ae34d)
      _ [Occ=Dead]
      (x0_ae1SX :: SourceStrictness) ->
      case x0_ae1SX of { __DEFAULT -> ds1_de7qM }

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceStrictness_$cgmapQ
  :: forall u.
     (forall d. Data d => d -> u) -> SourceStrictness -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae34u)
                 _ [Occ=Dead]
                 (x0_ae1SX [Occ=Once] :: SourceStrictness) ->
                 case x0_ae1SX of { __DEFAULT -> GHC.Types.[] @ u_ae34u }}]
Data.Data.$fDataSourceStrictness_$cgmapQ
  = \ (@ u_ae34u) _ [Occ=Dead] (x0_ae1SX :: SourceStrictness) ->
      case x0_ae1SX of { __DEFAULT -> GHC.Types.[] @ u_ae34u }

-- RHS size: {terms: 10, types: 16, coercions: 6, joins: 0/0}
Data.Data.$fDataSourceStrictness4
  :: forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data d => d -> r')
     -> SourceStrictness
     -> Const r SourceStrictness
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_ae33W)
                 (@ r'_ae33X)
                 _ [Occ=Dead]
                 (ds1_de7qJ [Occ=Once] :: r_ae33W)
                 _ [Occ=Dead]
                 (eta_XQs [Occ=Once] :: SourceStrictness) ->
                 case eta_XQs of { __DEFAULT ->
                 ds1_de7qJ
                 `cast` (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r_ae33W>_R <SourceStrictness>_P)
                         :: (r_ae33W :: *) ~R# (Const r_ae33W SourceStrictness :: *))
                 }}]
Data.Data.$fDataSourceStrictness4
  = \ (@ r_ae33W)
      (@ r'_ae33X)
      _ [Occ=Dead]
      (ds1_de7qJ :: r_ae33W)
      _ [Occ=Dead]
      (eta_XQs :: SourceStrictness) ->
      case eta_XQs of { __DEFAULT ->
      ds1_de7qJ
      `cast` (Sym (Data.Functor.Const.N:Const[0]
                       <*>_N <r_ae33W>_R <SourceStrictness>_P)
              :: (r_ae33W :: *) ~R# (Const r_ae33W SourceStrictness :: *))
      }

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceStrictness5
  :: (forall b. Data b => b -> b)
     -> SourceStrictness -> SourceStrictness
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (x0_Xe39R [Occ=Once] :: SourceStrictness) ->
                 x0_Xe39R}]
Data.Data.$fDataSourceStrictness5
  = \ _ [Occ=Dead] (x0_Xe39R :: SourceStrictness) -> x0_Xe39R

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceStrictness_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e))
     -> Maybe (c SourceStrictness)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae33o :: * -> * -> *))
                 (@ (c_ae33p :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae33p SourceStrictness)}]
Data.Data.$fDataSourceStrictness_$cdataCast2
  = \ (@ (t_ae33o :: * -> * -> *))
      (@ (c_ae33p :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae33p SourceStrictness)

-- RHS size: {terms: 37, types: 43, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo29 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     SourceStrictness -> m SourceStrictness
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 100] 290 0}]
Data.Data.$w$cgmapMo29
  = \ (@ (m_segAx :: * -> *))
      (w_segAy :: MonadPlus m_segAx)
      (w1_segAA :: SourceStrictness) ->
      let {
        lvl270_se9V5 :: m_segAx SourceStrictness
        [LclId]
        lvl270_se9V5 = mzero @ m_segAx w_segAy @ SourceStrictness } in
      let {
        $dMonad_se9pb [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_segAx
        [LclId]
        $dMonad_se9pb = GHC.Base.$p2MonadPlus @ m_segAx w_segAy } in
      >>=
        @ m_segAx
        $dMonad_se9pb
        @ (SourceStrictness, Bool)
        @ SourceStrictness
        (case w1_segAA of {
           NoSourceStrictness ->
             return
               @ m_segAx
               $dMonad_se9pb
               @ (SourceStrictness, Bool)
               Data.Data.$fDataSourceStrictness3;
           SourceLazy ->
             return
               @ m_segAx
               $dMonad_se9pb
               @ (SourceStrictness, Bool)
               Data.Data.$fDataSourceStrictness2;
           SourceStrict ->
             return
               @ m_segAx
               $dMonad_se9pb
               @ (SourceStrictness, Bool)
               Data.Data.$fDataSourceStrictness1
         })
        (\ (ds_de7pa :: (SourceStrictness, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9V5;
             True -> return @ m_segAx $dMonad_se9pb @ SourceStrictness x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataSourceStrictness_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d)
     -> SourceStrictness -> m SourceStrictness
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_segAx :: * -> *))
                 (w_segAy [Occ=Once] :: MonadPlus m_segAx)
                 _ [Occ=Dead]
                 (w2_segAA [Occ=Once] :: SourceStrictness) ->
                 Data.Data.$w$cgmapMo29 @ m_segAx w_segAy w2_segAA}]
Data.Data.$fDataSourceStrictness_$cgmapMo
  = \ (@ (m_segAx :: * -> *))
      (w_segAy :: MonadPlus m_segAx)
      _ [Occ=Dead]
      (w2_segAA :: SourceStrictness) ->
      Data.Data.$w$cgmapMo29 @ m_segAx w_segAy w2_segAA

-- RHS size: {terms: 16, types: 1, coercions: 31, joins: 0/0}
Data.Data.$fDataSourceStrictness [InlPrag=NOUSERINLINE CONLIKE]
  :: Data SourceStrictness
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: SourceStrictness
                        Data.Data.$fDataSourceStrictness6
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <SourceStrictness>_N
                                :: (Data.Typeable.Internal.TypeRep SourceStrictness :: *)
                                   ~R# (Typeable SourceStrictness :: Constraint))
                        Data.Data.$fDataSourceStrictness_$cgfoldl
                        Data.Data.$fDataSourceStrictness_$cgunfold
                        Data.Data.$fDataSourceStrictness_$ctoConstr
                        Data.Data.$fDataSourceStrictness_$cdataTypeOf
                        Data.Data.$fDataSourceStrictness_$cdataCast1
                        Data.Data.$fDataSourceStrictness_$cdataCast2
                        Data.Data.$fDataSourceStrictness5
                        Data.Data.$fDataSourceStrictness4
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <SourceStrictness>_R
                                ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <SourceStrictness>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> SourceStrictness
                                    -> Const r SourceStrictness :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d. Data d => d -> r')
                                        -> SourceStrictness
                                        -> r :: *))
                        Data.Data.$fDataSourceStrictness_$cgmapQr
                        Data.Data.$fDataSourceStrictness_$cgmapQ
                        Data.Data.$fDataSourceStrictness_$cgmapQi
                        Data.Data.$fDataSourceStrictness_$cgmapM
                        Data.Data.$fDataSourceStrictness_$cgmapMp
                        Data.Data.$fDataSourceStrictness_$cgmapMo]
Data.Data.$fDataSourceStrictness
  = Data.Data.C:Data
      @ SourceStrictness
      (Data.Data.$fDataSourceStrictness6
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <SourceStrictness>_N
               :: (Data.Typeable.Internal.TypeRep SourceStrictness :: *)
                  ~R# (Typeable SourceStrictness :: Constraint)))
      Data.Data.$fDataSourceStrictness_$cgfoldl
      Data.Data.$fDataSourceStrictness_$cgunfold
      Data.Data.$fDataSourceStrictness_$ctoConstr
      Data.Data.$fDataSourceStrictness_$cdataTypeOf
      Data.Data.$fDataSourceStrictness_$cdataCast1
      Data.Data.$fDataSourceStrictness_$cdataCast2
      Data.Data.$fDataSourceStrictness5
      (Data.Data.$fDataSourceStrictness4
       `cast` (forall (r :: <*>_N) (r' :: <*>_N).
               <r -> r' -> r>_R
               ->_R <r>_R
               ->_R <forall d. Data d => d -> r'>_R
               ->_R <SourceStrictness>_R
               ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <SourceStrictness>_P
               :: (forall r r'.
                   (r -> r' -> r)
                   -> r
                   -> (forall d. Data d => d -> r')
                   -> SourceStrictness
                   -> Const r SourceStrictness :: *)
                  ~R# (forall r r'.
                       (r -> r' -> r)
                       -> r
                       -> (forall d. Data d => d -> r')
                       -> SourceStrictness
                       -> r :: *)))
      Data.Data.$fDataSourceStrictness_$cgmapQr
      Data.Data.$fDataSourceStrictness_$cgmapQ
      Data.Data.$fDataSourceStrictness_$cgmapQi
      Data.Data.$fDataSourceStrictness_$cgmapM
      Data.Data.$fDataSourceStrictness_$cgmapMp
      Data.Data.$fDataSourceStrictness_$cgmapMo

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tDecidedStrictness1_rejVm :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
$tDecidedStrictness1_rejVm = "DecidedStrictness"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tDecidedStrictness2_rejVn :: [Char]
[GblId]
$tDecidedStrictness2_rejVn
  = unpackCString# $tDecidedStrictness1_rejVm

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str48_rejVo :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str48_rejVo = "DecidedStrict"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str49_rejVp :: String
[GblId]
str49_rejVp = unpackCString# str48_rejVo

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str50_rejVq :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str50_rejVq = "DecidedUnpack"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str51_rejVr :: String
[GblId]
str51_rejVr = unpackCString# str50_rejVq

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str52_rejVs :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str52_rejVs = "DecidedLazy"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str53_rejVt :: String
[GblId]
str53_rejVt = unpackCString# str52_rejVs

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go55_rejVu :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go55_rejVu
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str53_rejVt of {
                False -> go55_rejVu ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go56_rejVv :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go56_rejVv
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str49_rejVp of {
                False -> go56_rejVv ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go57_rejVw :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go57_rejVw
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str51_rejVr of {
                False -> go57_rejVw ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cDecidedLazy1_rejVx :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cDecidedLazy1_rejVx = Data.Data.AlgConstr $cDecidedLazy2_rejVG

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cDecidedStrict1_rejVy :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cDecidedStrict1_rejVy = Data.Data.AlgConstr $cDecidedStrict2_rejVF

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cDecidedUnpack1_rejVz :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cDecidedUnpack1_rejVz = Data.Data.AlgConstr $cDecidedUnpack2_rejVE

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$tDecidedStrictness3_rejVA :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tDecidedStrictness3_rejVA
  = GHC.Types.:
      @ Constr Data.Data.$cDecidedUnpack (GHC.Types.[] @ Constr)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$tDecidedStrictness4_rejVB :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tDecidedStrictness4_rejVB
  = GHC.Types.:
      @ Constr Data.Data.$cDecidedLazy $tDecidedStrictness6_rejVD

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tDecidedStrictness5_rejVC :: DataRep
[GblId, Str=m1, Unf=OtherCon []]
$tDecidedStrictness5_rejVC
  = Data.Data.AlgRep $tDecidedStrictness4_rejVB

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Data.$tDecidedStrictness [Occ=LoopBreaker] :: DataType
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$tDecidedStrictness
  = Data.Data.DataType
      $tDecidedStrictness2_rejVn $tDecidedStrictness5_rejVC

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cDecidedStrict [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cDecidedStrict
  = Data.Data.Constr
      $cDecidedStrict1_rejVy
      str49_rejVp
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tDecidedStrictness

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$tDecidedStrictness6_rejVD :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
$tDecidedStrictness6_rejVD
  = GHC.Types.:
      @ Constr Data.Data.$cDecidedStrict $tDecidedStrictness3_rejVA

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cDecidedLazy [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cDecidedLazy
  = Data.Data.Constr
      $cDecidedLazy1_rejVx
      str53_rejVt
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tDecidedStrictness

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Data.$cDecidedUnpack [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Data.$cDecidedUnpack
  = Data.Data.Constr
      $cDecidedUnpack1_rejVz
      str51_rejVr
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Data.$tDecidedStrictness

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cDecidedUnpack2_rejVE :: ConIndex
[GblId]
$cDecidedUnpack2_rejVE
  = go57_rejVw $tDecidedStrictness4_rejVB Data.Data.mkConstr1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cDecidedStrict2_rejVF :: ConIndex
[GblId]
$cDecidedStrict2_rejVF
  = go56_rejVv $tDecidedStrictness4_rejVB Data.Data.mkConstr1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cDecidedLazy2_rejVG :: ConIndex
[GblId]
$cDecidedLazy2_rejVG
  = go55_rejVu $tDecidedStrictness4_rejVB Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Data.$fDataDecidedStrictness_$cdataTypeOf
  :: DecidedStrictness -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Data.$tDecidedStrictness}]
Data.Data.$fDataDecidedStrictness_$cdataTypeOf
  = \ _ [Occ=Dead] -> Data.Data.$tDecidedStrictness

-- RHS size: {terms: 9, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataDecidedStrictness_$ctoConstr
  :: DecidedStrictness -> Constr
[GblId,
 Arity=1,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_de7qg [Occ=Once!] :: DecidedStrictness) ->
                 case ds_de7qg of {
                   DecidedLazy -> Data.Data.$cDecidedLazy;
                   DecidedStrict -> Data.Data.$cDecidedStrict;
                   DecidedUnpack -> Data.Data.$cDecidedUnpack
                 }}]
Data.Data.$fDataDecidedStrictness_$ctoConstr
  = \ (ds_de7qg :: DecidedStrictness) ->
      case ds_de7qg of {
        DecidedLazy -> Data.Data.$cDecidedLazy;
        DecidedStrict -> Data.Data.$cDecidedStrict;
        DecidedUnpack -> Data.Data.$cDecidedUnpack
      }

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataDecidedStrictness_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c DecidedStrictness)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae2ZW :: * -> *))
                 (@ (c_ae2ZX :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae2ZX DecidedStrictness)}]
Data.Data.$fDataDecidedStrictness_$cdataCast1
  = \ (@ (t_ae2ZW :: * -> *))
      (@ (c_ae2ZX :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae2ZX DecidedStrictness)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataDecidedStrictness3 :: (DecidedStrictness, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataDecidedStrictness3
  = (GHC.Generics.DecidedLazy, GHC.Types.False)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataDecidedStrictness2 :: (DecidedStrictness, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataDecidedStrictness2
  = (GHC.Generics.DecidedStrict, GHC.Types.False)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataDecidedStrictness1 :: (DecidedStrictness, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataDecidedStrictness1
  = (GHC.Generics.DecidedUnpack, GHC.Types.False)

-- RHS size: {terms: 37, types: 43, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMp14 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     DecidedStrictness -> m DecidedStrictness
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 100] 290 0}]
Data.Data.$w$cgmapMp14
  = \ (@ (m_segAI :: * -> *))
      (w_segAJ :: MonadPlus m_segAI)
      (w1_segAL :: DecidedStrictness) ->
      let {
        lvl270_se9Vl :: m_segAI DecidedStrictness
        [LclId]
        lvl270_se9Vl = mzero @ m_segAI w_segAJ @ DecidedStrictness } in
      let {
        $dMonad_se9p9 [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_segAI
        [LclId]
        $dMonad_se9p9 = GHC.Base.$p2MonadPlus @ m_segAI w_segAJ } in
      >>=
        @ m_segAI
        $dMonad_se9p9
        @ (DecidedStrictness, Bool)
        @ DecidedStrictness
        (case w1_segAL of {
           DecidedLazy ->
             return
               @ m_segAI
               $dMonad_se9p9
               @ (DecidedStrictness, Bool)
               Data.Data.$fDataDecidedStrictness3;
           DecidedStrict ->
             return
               @ m_segAI
               $dMonad_se9p9
               @ (DecidedStrictness, Bool)
               Data.Data.$fDataDecidedStrictness2;
           DecidedUnpack ->
             return
               @ m_segAI
               $dMonad_se9p9
               @ (DecidedStrictness, Bool)
               Data.Data.$fDataDecidedStrictness1
         })
        (\ (ds_de7oa :: (DecidedStrictness, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9Vl;
             True -> return @ m_segAI $dMonad_se9p9 @ DecidedStrictness x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataDecidedStrictness_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d)
     -> DecidedStrictness -> m DecidedStrictness
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_segAI :: * -> *))
                 (w_segAJ [Occ=Once] :: MonadPlus m_segAI)
                 _ [Occ=Dead]
                 (w2_segAL [Occ=Once] :: DecidedStrictness) ->
                 Data.Data.$w$cgmapMp14 @ m_segAI w_segAJ w2_segAL}]
Data.Data.$fDataDecidedStrictness_$cgmapMp
  = \ (@ (m_segAI :: * -> *))
      (w_segAJ :: MonadPlus m_segAI)
      _ [Occ=Dead]
      (w2_segAL :: DecidedStrictness) ->
      Data.Data.$w$cgmapMp14 @ m_segAI w_segAJ w2_segAL

-- RHS size: {terms: 17, types: 14, coercions: 0, joins: 0/0}
Data.Data.$w$cgmapM10 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     Monad m =>
     DecidedStrictness -> m DecidedStrictness
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 100] 120 0}]
Data.Data.$w$cgmapM10
  = \ (@ (m_segAN :: * -> *))
      (w_segAO :: Monad m_segAN)
      (w1_segAQ :: DecidedStrictness) ->
      case w1_segAQ of {
        DecidedLazy ->
          return
            @ m_segAN w_segAO @ DecidedStrictness GHC.Generics.DecidedLazy;
        DecidedStrict ->
          return
            @ m_segAN w_segAO @ DecidedStrictness GHC.Generics.DecidedStrict;
        DecidedUnpack ->
          return
            @ m_segAN w_segAO @ DecidedStrictness GHC.Generics.DecidedUnpack
      }

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataDecidedStrictness_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d)
     -> DecidedStrictness -> m DecidedStrictness
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_segAN :: * -> *))
                 (w_segAO [Occ=Once] :: Monad m_segAN)
                 _ [Occ=Dead]
                 (w2_segAQ [Occ=Once] :: DecidedStrictness) ->
                 Data.Data.$w$cgmapM10 @ m_segAN w_segAO w2_segAQ}]
Data.Data.$fDataDecidedStrictness_$cgmapM
  = \ (@ (m_segAN :: * -> *))
      (w_segAO :: Monad m_segAN)
      _ [Occ=Dead]
      (w2_segAQ :: DecidedStrictness) ->
      Data.Data.$w$cgmapM10 @ m_segAN w_segAO w2_segAQ

-- RHS size: {terms: 8, types: 12, coercions: 0, joins: 0/0}
Data.Data.$fDataDecidedStrictness_$cgmapQi
  :: forall u.
     Int -> (forall d. Data d => d -> u) -> DecidedStrictness -> u
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,1*U>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae31z)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (x_ae1T7 [Occ=Once] :: DecidedStrictness) ->
                 case x_ae1T7 of { __DEFAULT -> Data.Maybe.fromJust1 @ u_ae31z }}]
Data.Data.$fDataDecidedStrictness_$cgmapQi
  = \ (@ u_ae31z)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (x_ae1T7 :: DecidedStrictness) ->
      case x_ae1T7 of { __DEFAULT -> Data.Maybe.fromJust1 @ u_ae31z }

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
Data.Data.$fDataDecidedStrictness_$cgmapQr
  :: forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> DecidedStrictness -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_ae314)
                 (@ r'_ae315)
                 _ [Occ=Dead]
                 (ds1_de7qp [Occ=Once] :: r_ae314)
                 _ [Occ=Dead]
                 (x0_ae1SX [Occ=Once] :: DecidedStrictness) ->
                 case x0_ae1SX of { __DEFAULT -> ds1_de7qp }}]
Data.Data.$fDataDecidedStrictness_$cgmapQr
  = \ (@ r_ae314)
      (@ r'_ae315)
      _ [Occ=Dead]
      (ds1_de7qp :: r_ae314)
      _ [Occ=Dead]
      (x0_ae1SX :: DecidedStrictness) ->
      case x0_ae1SX of { __DEFAULT -> ds1_de7qp }

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
Data.Data.$fDataDecidedStrictness_$cgmapQ
  :: forall u.
     (forall d. Data d => d -> u) -> DecidedStrictness -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae31l)
                 _ [Occ=Dead]
                 (x0_ae1SX [Occ=Once] :: DecidedStrictness) ->
                 case x0_ae1SX of { __DEFAULT -> GHC.Types.[] @ u_ae31l }}]
Data.Data.$fDataDecidedStrictness_$cgmapQ
  = \ (@ u_ae31l) _ [Occ=Dead] (x0_ae1SX :: DecidedStrictness) ->
      case x0_ae1SX of { __DEFAULT -> GHC.Types.[] @ u_ae31l }

-- RHS size: {terms: 10, types: 16, coercions: 6, joins: 0/0}
Data.Data.$fDataDecidedStrictness4
  :: forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data d => d -> r')
     -> DecidedStrictness
     -> Const r DecidedStrictness
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_ae30N)
                 (@ r'_ae30O)
                 _ [Occ=Dead]
                 (ds1_de7qm [Occ=Once] :: r_ae30N)
                 _ [Occ=Dead]
                 (eta_XQX [Occ=Once] :: DecidedStrictness) ->
                 case eta_XQX of { __DEFAULT ->
                 ds1_de7qm
                 `cast` (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r_ae30N>_R <DecidedStrictness>_P)
                         :: (r_ae30N :: *) ~R# (Const r_ae30N DecidedStrictness :: *))
                 }}]
Data.Data.$fDataDecidedStrictness4
  = \ (@ r_ae30N)
      (@ r'_ae30O)
      _ [Occ=Dead]
      (ds1_de7qm :: r_ae30N)
      _ [Occ=Dead]
      (eta_XQX :: DecidedStrictness) ->
      case eta_XQX of { __DEFAULT ->
      ds1_de7qm
      `cast` (Sym (Data.Functor.Const.N:Const[0]
                       <*>_N <r_ae30N>_R <DecidedStrictness>_P)
              :: (r_ae30N :: *) ~R# (Const r_ae30N DecidedStrictness :: *))
      }

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Data.$fDataDecidedStrictness5
  :: (forall b. Data b => b -> b)
     -> DecidedStrictness -> DecidedStrictness
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (x0_Xe3am [Occ=Once] :: DecidedStrictness) ->
                 x0_Xe3am}]
Data.Data.$fDataDecidedStrictness5
  = \ _ [Occ=Dead] (x0_Xe3am :: DecidedStrictness) -> x0_Xe3am

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataDecidedStrictness_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e))
     -> Maybe (c DecidedStrictness)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae30f :: * -> * -> *))
                 (@ (c_ae30g :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae30g DecidedStrictness)}]
Data.Data.$fDataDecidedStrictness_$cdataCast2
  = \ (@ (t_ae30f :: * -> * -> *))
      (@ (c_ae30g :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae30g DecidedStrictness)

-- RHS size: {terms: 37, types: 43, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapMo13 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     DecidedStrictness -> m DecidedStrictness
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 100] 290 0}]
Data.Data.$w$cgmapMo13
  = \ (@ (m_segAS :: * -> *))
      (w_segAT :: MonadPlus m_segAS)
      (w1_segAV :: DecidedStrictness) ->
      let {
        lvl270_se9Vx :: m_segAS DecidedStrictness
        [LclId]
        lvl270_se9Vx = mzero @ m_segAS w_segAT @ DecidedStrictness } in
      let {
        $dMonad_se9p7 [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_segAS
        [LclId]
        $dMonad_se9p7 = GHC.Base.$p2MonadPlus @ m_segAS w_segAT } in
      >>=
        @ m_segAS
        $dMonad_se9p7
        @ (DecidedStrictness, Bool)
        @ DecidedStrictness
        (case w1_segAV of {
           DecidedLazy ->
             return
               @ m_segAS
               $dMonad_se9p7
               @ (DecidedStrictness, Bool)
               Data.Data.$fDataDecidedStrictness3;
           DecidedStrict ->
             return
               @ m_segAS
               $dMonad_se9p7
               @ (DecidedStrictness, Bool)
               Data.Data.$fDataDecidedStrictness2;
           DecidedUnpack ->
             return
               @ m_segAS
               $dMonad_se9p7
               @ (DecidedStrictness, Bool)
               Data.Data.$fDataDecidedStrictness1
         })
        (\ (ds_de7pa :: (DecidedStrictness, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9Vx;
             True -> return @ m_segAS $dMonad_se9p7 @ DecidedStrictness x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Data.$fDataDecidedStrictness_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d)
     -> DecidedStrictness -> m DecidedStrictness
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_segAS :: * -> *))
                 (w_segAT [Occ=Once] :: MonadPlus m_segAS)
                 _ [Occ=Dead]
                 (w2_segAV [Occ=Once] :: DecidedStrictness) ->
                 Data.Data.$w$cgmapMo13 @ m_segAS w_segAT w2_segAV}]
Data.Data.$fDataDecidedStrictness_$cgmapMo
  = \ (@ (m_segAS :: * -> *))
      (w_segAT :: MonadPlus m_segAS)
      _ [Occ=Dead]
      (w2_segAV :: DecidedStrictness) ->
      Data.Data.$w$cgmapMo13 @ m_segAS w_segAT w2_segAV

-- RHS size: {terms: 16, types: 1, coercions: 31, joins: 0/0}
Data.Data.$fDataDecidedStrictness [InlPrag=NOUSERINLINE CONLIKE]
  :: Data DecidedStrictness
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: DecidedStrictness
                        Data.Data.$fDataDecidedStrictness6
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <DecidedStrictness>_N
                                :: (Data.Typeable.Internal.TypeRep DecidedStrictness :: *)
                                   ~R# (Typeable DecidedStrictness :: Constraint))
                        Data.Data.$fDataDecidedStrictness_$cgfoldl
                        Data.Data.$fDataDecidedStrictness_$cgunfold
                        Data.Data.$fDataDecidedStrictness_$ctoConstr
                        Data.Data.$fDataDecidedStrictness_$cdataTypeOf
                        Data.Data.$fDataDecidedStrictness_$cdataCast1
                        Data.Data.$fDataDecidedStrictness_$cdataCast2
                        Data.Data.$fDataDecidedStrictness5
                        Data.Data.$fDataDecidedStrictness4
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <DecidedStrictness>_R
                                ->_R Data.Functor.Const.N:Const[0]
                                         <*>_N <r>_R <DecidedStrictness>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> DecidedStrictness
                                    -> Const r DecidedStrictness :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d. Data d => d -> r')
                                        -> DecidedStrictness
                                        -> r :: *))
                        Data.Data.$fDataDecidedStrictness_$cgmapQr
                        Data.Data.$fDataDecidedStrictness_$cgmapQ
                        Data.Data.$fDataDecidedStrictness_$cgmapQi
                        Data.Data.$fDataDecidedStrictness_$cgmapM
                        Data.Data.$fDataDecidedStrictness_$cgmapMp
                        Data.Data.$fDataDecidedStrictness_$cgmapMo]
Data.Data.$fDataDecidedStrictness
  = Data.Data.C:Data
      @ DecidedStrictness
      (Data.Data.$fDataDecidedStrictness6
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <DecidedStrictness>_N
               :: (Data.Typeable.Internal.TypeRep DecidedStrictness :: *)
                  ~R# (Typeable DecidedStrictness :: Constraint)))
      Data.Data.$fDataDecidedStrictness_$cgfoldl
      Data.Data.$fDataDecidedStrictness_$cgunfold
      Data.Data.$fDataDecidedStrictness_$ctoConstr
      Data.Data.$fDataDecidedStrictness_$cdataTypeOf
      Data.Data.$fDataDecidedStrictness_$cdataCast1
      Data.Data.$fDataDecidedStrictness_$cdataCast2
      Data.Data.$fDataDecidedStrictness5
      (Data.Data.$fDataDecidedStrictness4
       `cast` (forall (r :: <*>_N) (r' :: <*>_N).
               <r -> r' -> r>_R
               ->_R <r>_R
               ->_R <forall d. Data d => d -> r'>_R
               ->_R <DecidedStrictness>_R
               ->_R Data.Functor.Const.N:Const[0]
                        <*>_N <r>_R <DecidedStrictness>_P
               :: (forall r r'.
                   (r -> r' -> r)
                   -> r
                   -> (forall d. Data d => d -> r')
                   -> DecidedStrictness
                   -> Const r DecidedStrictness :: *)
                  ~R# (forall r r'.
                       (r -> r' -> r)
                       -> r
                       -> (forall d. Data d => d -> r')
                       -> DecidedStrictness
                       -> r :: *)))
      Data.Data.$fDataDecidedStrictness_$cgmapQr
      Data.Data.$fDataDecidedStrictness_$cgmapQ
      Data.Data.$fDataDecidedStrictness_$cgmapQi
      Data.Data.$fDataDecidedStrictness_$cgmapM
      Data.Data.$fDataDecidedStrictness_$cgmapMp
      Data.Data.$fDataDecidedStrictness_$cgmapMo

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataRatio6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Data.$fDataRatio6 = "GHC.Real.Ratio"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataRatio5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataRatio5 = unpackCString# Data.Data.$fDataRatio6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str54_rejVH :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str54_rejVH = ":%"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str55_rejVI :: String
[GblId]
str55_rejVI = unpackCString# str54_rejVH

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go58_rejVJ :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go58_rejVJ
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str55_rejVI of {
                False -> go58_rejVJ ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
ratioConstr1_rejVK :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
ratioConstr1_rejVK = Data.Data.AlgConstr ratioConstr2_rejVL

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataRatio4 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Data.$fDataRatio4
  = GHC.Types.: @ Constr ratioConstr (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Data.$fDataRatio3 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Data.$fDataRatio3 = Data.Data.AlgRep Data.Data.$fDataRatio4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
ratioDataType :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
ratioDataType
  = Data.Data.DataType Data.Data.$fDataRatio5 Data.Data.$fDataRatio3

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
ratioConstr [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
ratioConstr
  = Data.Data.Constr
      ratioConstr1_rejVK
      str55_rejVI
      (GHC.Types.[] @ String)
      Data.Data.Infix
      ratioDataType

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
ratioConstr2_rejVL :: ConIndex
[GblId]
ratioConstr2_rejVL
  = go58_rejVJ Data.Data.$fDataRatio4 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 77, types: 146, coercions: 17, joins: 0/4}
Data.Data.$fDataRatio_$cgmapMp
  :: forall a.
     (Data a, Integral a) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Ratio a -> m (Ratio a)
[GblId,
 Arity=5,
 Str=<L,U><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 90 60 20] 670 0}]
Data.Data.$fDataRatio_$cgmapMp
  = \ (@ a_Xe6mx)
      ($dData_Xe6mz :: Data a_Xe6mx)
      ($dIntegral_Xe6mB :: Integral a_Xe6mx)
      (@ (m_ae5CY :: * -> *))
      ($dMonadPlus_ae5D0 :: MonadPlus m_ae5CY)
      (ds_de7JK :: forall d. Data d => d -> m_ae5CY d)
      (eta_XRk :: Ratio a_Xe6mx) ->
      let {
        lvl270_se9VF :: m_ae5CY (Ratio a_Xe6mx)
        [LclId]
        lvl270_se9VF
          = mzero @ m_ae5CY $dMonadPlus_ae5D0 @ (Ratio a_Xe6mx) } in
      let {
        $dMonad_se9p5 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae5CY
        [LclId]
        $dMonad_se9p5
          = GHC.Base.$p2MonadPlus @ m_ae5CY $dMonadPlus_ae5D0 } in
      >>=
        @ m_ae5CY
        $dMonad_se9p5
        @ (Ratio a_Xe6mx, Bool)
        @ (Ratio a_Xe6mx)
        (case eta_XRk of { :% a1_ae1Us b_ae1Ut ->
         let {
           k_se9p4 [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
             :: forall d b1.
                Data d =>
                Mp m_ae5CY (d -> b1) -> d -> m_ae5CY (b1, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_se9p4
             = \ (@ d_ae2Ws)
                 (@ b1_ae2Wt)
                 ($dData1_ae2Wv :: Data d_ae2Ws)
                 (ds1_de7oC [OS=OneShot] :: Mp m_ae5CY (d_ae2Ws -> b1_ae2Wt))
                 (y_ae1Tz [OS=OneShot] :: d_ae2Ws) ->
                 let {
                   lvl271_se9VE :: m_ae5CY d_ae2Ws
                   [LclId]
                   lvl271_se9VE = ds_de7JK @ d_ae2Ws $dData1_ae2Wv y_ae1Tz } in
                 >>=
                   @ m_ae5CY
                   $dMonad_se9p5
                   @ (d_ae2Ws -> b1_ae2Wt, Bool)
                   @ (b1_ae2Wt, Bool)
                   (ds1_de7oC
                    `cast` (Data.Data.N:Mp[0] <m_ae5CY>_R <d_ae2Ws -> b1_ae2Wt>_N
                            :: (Mp m_ae5CY (d_ae2Ws -> b1_ae2Wt) :: *)
                               ~R# (m_ae5CY (d_ae2Ws -> b1_ae2Wt, Bool) :: *)))
                   (\ (ds2_de7oD :: (d_ae2Ws -> b1_ae2Wt, Bool)) ->
                      case ds2_de7oD of { (h_ae1TA, b2_ae1TB) ->
                      mplus
                        @ m_ae5CY
                        $dMonadPlus_ae5D0
                        @ (b1_ae2Wt, Bool)
                        (>>=
                           @ m_ae5CY
                           $dMonad_se9p5
                           @ d_ae2Ws
                           @ (b1_ae2Wt, Bool)
                           lvl271_se9VE
                           (\ (y'_ae1TC :: d_ae2Ws) ->
                              return
                                @ m_ae5CY
                                $dMonad_se9p5
                                @ (b1_ae2Wt, Bool)
                                (h_ae1TA y'_ae1TC, GHC.Types.True)))
                        (return
                           @ m_ae5CY
                           $dMonad_se9p5
                           @ (b1_ae2Wt, Bool)
                           (h_ae1TA y_ae1Tz, b2_ae1TB))
                      }) } in
         k_se9p4
           @ a_Xe6mx
           @ (Ratio a_Xe6mx)
           $dData_Xe6mz
           ((k_se9p4
               @ a_Xe6mx
               @ (a_Xe6mx -> Ratio a_Xe6mx)
               $dData_Xe6mz
               ((return
                   @ m_ae5CY
                   $dMonad_se9p5
                   @ (a_Xe6mx -> a_Xe6mx -> Ratio a_Xe6mx, Bool)
                   (% @ a_Xe6mx $dIntegral_Xe6mB, GHC.Types.False))
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_ae5CY>_R <a_Xe6mx -> a_Xe6mx -> Ratio a_Xe6mx>_N)
                        :: (m_ae5CY (a_Xe6mx -> a_Xe6mx -> Ratio a_Xe6mx, Bool) :: *)
                           ~R# (Mp m_ae5CY (a_Xe6mx -> a_Xe6mx -> Ratio a_Xe6mx) :: *)))
               a1_ae1Us)
            `cast` (Sym (Data.Data.N:Mp[0]
                             <m_ae5CY>_R <a_Xe6mx -> Ratio a_Xe6mx>_N)
                    :: (m_ae5CY (a_Xe6mx -> Ratio a_Xe6mx, Bool) :: *)
                       ~R# (Mp m_ae5CY (a_Xe6mx -> Ratio a_Xe6mx) :: *)))
           b_ae1Ut
         })
        (\ (ds1_de7oa :: (Ratio a_Xe6mx, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9VF;
             True -> return @ m_ae5CY $dMonad_se9p5 @ (Ratio a_Xe6mx) x'_ae1TD
           }
           })

-- RHS size: {terms: 40, types: 71, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapM14 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Data a, Integral a) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> a -> a -> m (Ratio a)
[GblId,
 Arity=6,
 Str=<L,U><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 120 60 0 0] 360 0}]
Data.Data.$w$cgmapM14
  = \ (@ a_segBg)
      (w_segBh :: Data a_segBg)
      (w1_segBi :: Integral a_segBg)
      (@ (m_segBj :: * -> *))
      (w2_segBk :: Monad m_segBj)
      (w3_segBl :: forall d. Data d => d -> m_segBj d)
      (ww_segBp
         :: a_segBg
         Unf=OtherCon [])
      (ww1_segBq
         :: a_segBg
         Unf=OtherCon []) ->
      let {
        k_se9p1 [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
          :: forall d b. Data d => m_segBj (d -> b) -> d -> m_segBj b
        [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
        k_se9p1
          = \ (@ d_ae2Vh)
              (@ b_ae2Vi)
              ($dData_ae2Vk :: Data d_ae2Vh)
              (c_ae1Tm [OS=OneShot] :: m_segBj (d_ae2Vh -> b_ae2Vi))
              (x_ae1Tn [OS=OneShot] :: d_ae2Vh) ->
              let {
                lvl270_se9VG :: m_segBj d_ae2Vh
                [LclId]
                lvl270_se9VG = w3_segBl @ d_ae2Vh $dData_ae2Vk x_ae1Tn } in
              >>=
                @ m_segBj
                w2_segBk
                @ (d_ae2Vh -> b_ae2Vi)
                @ b_ae2Vi
                c_ae1Tm
                (\ (c'_ae1To :: d_ae2Vh -> b_ae2Vi) ->
                   >>=
                     @ m_segBj
                     w2_segBk
                     @ d_ae2Vh
                     @ b_ae2Vi
                     lvl270_se9VG
                     (\ (x'_ae1Tp :: d_ae2Vh) ->
                        return @ m_segBj w2_segBk @ b_ae2Vi (c'_ae1To x'_ae1Tp))) } in
      k_se9p1
        @ a_segBg
        @ (Ratio a_segBg)
        w_segBh
        (k_se9p1
           @ a_segBg
           @ (a_segBg -> Ratio a_segBg)
           w_segBh
           (return
              @ m_segBj
              w2_segBk
              @ (a_segBg -> a_segBg -> Ratio a_segBg)
              (% @ a_segBg w1_segBi))
           ww_segBp)
        ww1_segBq

-- RHS size: {terms: 17, types: 27, coercions: 0, joins: 0/0}
Data.Data.$fDataRatio_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Data a, Integral a) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Ratio a -> m (Ratio a)
[GblId,
 Arity=5,
 Str=<L,U><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_segBg)
                 (w_segBh [Occ=Once] :: Data a_segBg)
                 (w1_segBi [Occ=Once] :: Integral a_segBg)
                 (@ (m_segBj :: * -> *))
                 (w2_segBk [Occ=Once] :: Monad m_segBj)
                 (w3_segBl [Occ=Once] :: forall d. Data d => d -> m_segBj d)
                 (w4_segBm [Occ=Once!] :: Ratio a_segBg) ->
                 case w4_segBm of { :% ww1_segBp [Occ=Once] ww2_segBq [Occ=Once] ->
                 Data.Data.$w$cgmapM14
                   @ a_segBg
                   w_segBh
                   w1_segBi
                   @ m_segBj
                   w2_segBk
                   w3_segBl
                   ww1_segBp
                   ww2_segBq
                 }}]
Data.Data.$fDataRatio_$cgmapM
  = \ (@ a_segBg)
      (w_segBh :: Data a_segBg)
      (w1_segBi :: Integral a_segBg)
      (@ (m_segBj :: * -> *))
      (w2_segBk :: Monad m_segBj)
      (w3_segBl :: forall d. Data d => d -> m_segBj d)
      (w4_segBm :: Ratio a_segBg) ->
      case w4_segBm of { :% ww1_segBp ww2_segBq ->
      Data.Data.$w$cgmapM14
        @ a_segBg
        w_segBh
        w1_segBi
        @ m_segBj
        w2_segBk
        w3_segBl
        ww1_segBp
        ww2_segBq
      }

-- RHS size: {terms: 25, types: 27, coercions: 0, joins: 0/0}
Data.Data.$fDataRatio_$cgmapQi
  :: forall a.
     (Data a, Integral a) =>
     forall u. Int -> (forall d. Data d => d -> u) -> Ratio a -> u
[GblId,
 Arity=5,
 Str=<L,U><L,A><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe6mv)
                 ($dData_Xe6mx [Occ=Once*] :: Data a_Xe6mv)
                 _ [Occ=Dead]
                 (@ u_ae5Cu)
                 (ds_de7JH [Occ=Once!] :: Int)
                 (ds1_de7JI [Occ=Once*!] :: forall d. Data d => d -> u_ae5Cu)
                 (x_ae1T7 [Occ=Once!] :: Ratio a_Xe6mv) ->
                 case x_ae1T7 of { :% a1_ae1Us [Occ=Once] b_ae1Ut [Occ=Once] ->
                 case ds_de7JH of { I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_ae5Cu;
                   0# -> ds1_de7JI @ a_Xe6mv $dData_Xe6mx a1_ae1Us;
                   1# -> ds1_de7JI @ a_Xe6mv $dData_Xe6mx b_ae1Ut
                 }
                 }
                 }}]
Data.Data.$fDataRatio_$cgmapQi
  = \ (@ a_Xe6mv)
      ($dData_Xe6mx :: Data a_Xe6mv)
      _ [Occ=Dead]
      (@ u_ae5Cu)
      (ds_de7JH :: Int)
      (ds1_de7JI :: forall d. Data d => d -> u_ae5Cu)
      (x_ae1T7 :: Ratio a_Xe6mv) ->
      case x_ae1T7 of { :% a1_ae1Us b_ae1Ut ->
      case ds_de7JH of { I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_ae5Cu;
        0# -> ds1_de7JI @ a_Xe6mv $dData_Xe6mx a1_ae1Us;
        1# -> ds1_de7JI @ a_Xe6mv $dData_Xe6mx b_ae1Ut
      }
      }
      }

-- RHS size: {terms: 21, types: 28, coercions: 0, joins: 0/0}
Data.Data.$fDataRatio_$cgmapQr
  :: forall a.
     (Data a, Integral a) =>
     forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> Ratio a -> r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,A><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe6mt)
                 ($dData_Xe6mv :: Data a_Xe6mt)
                 _ [Occ=Dead]
                 (@ r_ae5BZ)
                 (@ r'_ae5C0)
                 (ds_de7JD :: r'_ae5C0 -> r_ae5BZ -> r_ae5BZ)
                 (ds1_de7JE [Occ=Once] :: r_ae5BZ)
                 (ds2_de7JF :: forall d. Data d => d -> r'_ae5C0)
                 (x0_ae1SX [Occ=Once!] :: Ratio a_Xe6mt) ->
                 case x0_ae1SX of { :% a1_ae1Us [Occ=Once] b_ae1Ut [Occ=Once] ->
                 ds_de7JD
                   (ds2_de7JF @ a_Xe6mt $dData_Xe6mv a1_ae1Us)
                   (ds_de7JD (ds2_de7JF @ a_Xe6mt $dData_Xe6mv b_ae1Ut) ds1_de7JE)
                 }}]
Data.Data.$fDataRatio_$cgmapQr
  = \ (@ a_Xe6mt)
      ($dData_Xe6mv :: Data a_Xe6mt)
      _ [Occ=Dead]
      (@ r_ae5BZ)
      (@ r'_ae5C0)
      (ds_de7JD :: r'_ae5C0 -> r_ae5BZ -> r_ae5BZ)
      (ds1_de7JE :: r_ae5BZ)
      (ds2_de7JF :: forall d. Data d => d -> r'_ae5C0)
      (x0_ae1SX :: Ratio a_Xe6mt) ->
      case x0_ae1SX of { :% a1_ae1Us b_ae1Ut ->
      ds_de7JD
        (ds2_de7JF @ a_Xe6mt $dData_Xe6mv a1_ae1Us)
        (ds_de7JD (ds2_de7JF @ a_Xe6mt $dData_Xe6mv b_ae1Ut) ds1_de7JE)
      }

-- RHS size: {terms: 18, types: 25, coercions: 0, joins: 0/0}
Data.Data.$fDataRatio_$cgmapQ
  :: forall a.
     (Data a, Integral a) =>
     forall u. (forall d. Data d => d -> u) -> Ratio a -> [u]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,A><L,C(C1(U))><S(SS),1*U(U,U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe6mu)
                 ($dData_Xe6mw :: Data a_Xe6mu)
                 _ [Occ=Dead]
                 (@ u_ae5Cg)
                 (ds_de7JG :: forall d. Data d => d -> u_ae5Cg)
                 (x0_ae1SX [Occ=Once!] :: Ratio a_Xe6mu) ->
                 case x0_ae1SX of { :% a1_ae1Us [Occ=Once] b_ae1Ut [Occ=Once] ->
                 GHC.Types.:
                   @ u_ae5Cg
                   (ds_de7JG @ a_Xe6mu $dData_Xe6mw a1_ae1Us)
                   (GHC.Types.:
                      @ u_ae5Cg
                      (ds_de7JG @ a_Xe6mu $dData_Xe6mw b_ae1Ut)
                      (GHC.Types.[] @ u_ae5Cg))
                 }}]
Data.Data.$fDataRatio_$cgmapQ
  = \ (@ a_Xe6mu)
      ($dData_Xe6mw :: Data a_Xe6mu)
      _ [Occ=Dead]
      (@ u_ae5Cg)
      (ds_de7JG :: forall d. Data d => d -> u_ae5Cg)
      (x0_ae1SX :: Ratio a_Xe6mu) ->
      case x0_ae1SX of { :% a1_ae1Us b_ae1Ut ->
      GHC.Types.:
        @ u_ae5Cg
        (ds_de7JG @ a_Xe6mu $dData_Xe6mw a1_ae1Us)
        (GHC.Types.:
           @ u_ae5Cg
           (ds_de7JG @ a_Xe6mu $dData_Xe6mw b_ae1Ut)
           (GHC.Types.[] @ u_ae5Cg))
      }

-- RHS size: {terms: 21, types: 28, coercions: 7, joins: 0/0}
Data.Data.$fDataRatio1
  :: forall a.
     (Data a, Integral a) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data d => d -> r')
     -> Ratio a
     -> Const r (Ratio a)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,A><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S(SS),1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe6ms)
                 ($dData_Xe6mu :: Data a_Xe6ms)
                 _ [Occ=Dead]
                 (@ r_ae5BI)
                 (@ r'_ae5BJ)
                 (ds_de7JA :: r_ae5BI -> r'_ae5BJ -> r_ae5BI)
                 (ds1_de7JB [Occ=Once] :: r_ae5BI)
                 (ds2_de7JC :: forall d. Data d => d -> r'_ae5BJ)
                 (eta_XRr [Occ=Once!] :: Ratio a_Xe6ms) ->
                 case eta_XRr of { :% a1_ae1Us [Occ=Once] b_ae1Ut [Occ=Once] ->
                 (ds_de7JA
                    (ds_de7JA ds1_de7JB (ds2_de7JC @ a_Xe6ms $dData_Xe6mu a1_ae1Us))
                    (ds2_de7JC @ a_Xe6ms $dData_Xe6mu b_ae1Ut))
                 `cast` (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r_ae5BI>_R <Ratio a_Xe6ms>_P)
                         :: (r_ae5BI :: *) ~R# (Const r_ae5BI (Ratio a_Xe6ms) :: *))
                 }}]
Data.Data.$fDataRatio1
  = \ (@ a_Xe6ms)
      ($dData_Xe6mu :: Data a_Xe6ms)
      _ [Occ=Dead]
      (@ r_ae5BI)
      (@ r'_ae5BJ)
      (ds_de7JA :: r_ae5BI -> r'_ae5BJ -> r_ae5BI)
      (ds1_de7JB :: r_ae5BI)
      (ds2_de7JC :: forall d. Data d => d -> r'_ae5BJ)
      (eta_XRr :: Ratio a_Xe6ms) ->
      case eta_XRr of { :% a1_ae1Us b_ae1Ut ->
      (ds_de7JA
         (ds_de7JA ds1_de7JB (ds2_de7JC @ a_Xe6ms $dData_Xe6mu a1_ae1Us))
         (ds2_de7JC @ a_Xe6ms $dData_Xe6mu b_ae1Ut))
      `cast` (Sym (Data.Functor.Const.N:Const[0]
                       <*>_N <r_ae5BI>_R <Ratio a_Xe6ms>_P)
              :: (r_ae5BI :: *) ~R# (Const r_ae5BI (Ratio a_Xe6ms) :: *))
      }

-- RHS size: {terms: 21, types: 29, coercions: 4, joins: 0/0}
Data.Data.$fDataRatio2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Data a, Integral a) =>
     (forall b. Data b => b -> b) -> Ratio a -> Identity (Ratio a)
[GblId,
 Arity=4,
 Str=<L,U><S(S(LS(S(C(C(S))L)LLLLLLL)L)LC(C(S))LLLLLL),U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,C(C1(U))><S(SS),1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_segBt)
                 (w_segBu :: Data a_segBt)
                 (w1_segBv [Occ=Once] :: Integral a_segBt)
                 (w2_segBw :: forall b. Data b => b -> b)
                 (w3_segBx [Occ=Once!] :: Ratio a_segBt) ->
                 case w3_segBx of { :% ww1_segBA [Occ=Once] ww2_segBB [Occ=Once] ->
                 case GHC.Real.$w%
                        @ a_segBt
                        w1_segBv
                        (w2_segBw @ a_segBt w_segBu ww1_segBA)
                        (w2_segBw @ a_segBt w_segBu ww2_segBB)
                 of
                 { (# ww4_segJ5 [Occ=Once], ww5_segJ6 [Occ=Once] #) ->
                 (GHC.Real.:% @ a_segBt ww4_segJ5 ww5_segJ6)
                 `cast` (Sym (Data.Functor.Identity.N:Identity[0] <Ratio a_segBt>_R)
                         :: (Ratio a_segBt :: *) ~R# (Identity (Ratio a_segBt) :: *))
                 }
                 }}]
Data.Data.$fDataRatio2
  = \ (@ a_segBt)
      (w_segBu :: Data a_segBt)
      (w1_segBv :: Integral a_segBt)
      (w2_segBw :: forall b. Data b => b -> b)
      (w3_segBx :: Ratio a_segBt) ->
      case w3_segBx of { :% ww1_segBA ww2_segBB ->
      case GHC.Real.$w%
             @ a_segBt
             w1_segBv
             (w2_segBw @ a_segBt w_segBu ww1_segBA)
             (w2_segBw @ a_segBt w_segBu ww2_segBB)
      of
      { (# ww4_segJ5, ww5_segJ6 #) ->
      (GHC.Real.:% @ a_segBt ww4_segJ5 ww5_segJ6)
      `cast` (Sym (Data.Functor.Identity.N:Identity[0] <Ratio a_segBt>_R)
              :: (Ratio a_segBt :: *) ~R# (Identity (Ratio a_segBt) :: *))
      }
      }

-- RHS size: {terms: 87, types: 153, coercions: 17, joins: 0/4}
Data.Data.$fDataRatio_$cgmapMo
  :: forall a.
     (Data a, Integral a) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Ratio a -> m (Ratio a)
[GblId,
 Arity=5,
 Str=<L,U><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 90 60 20] 750 0}]
Data.Data.$fDataRatio_$cgmapMo
  = \ (@ a_Xe6mp)
      ($dData_Xe7e1 :: Data a_Xe6mp)
      ($dIntegral_Xe7e4 :: Integral a_Xe6mp)
      (@ (m_ae5De :: * -> *))
      ($dMonadPlus_ae5Dg :: MonadPlus m_ae5De)
      (ds_de7JL :: forall d. Data d => d -> m_ae5De d)
      (eta_XRG :: Ratio a_Xe6mp) ->
      let {
        lvl270_se9VL :: m_ae5De (Ratio a_Xe6mp)
        [LclId]
        lvl270_se9VL
          = mzero @ m_ae5De $dMonadPlus_ae5Dg @ (Ratio a_Xe6mp) } in
      let {
        $dMonad_se9oZ [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae5De
        [LclId]
        $dMonad_se9oZ
          = GHC.Base.$p2MonadPlus @ m_ae5De $dMonadPlus_ae5Dg } in
      >>=
        @ m_ae5De
        $dMonad_se9oZ
        @ (Ratio a_Xe6mp, Bool)
        @ (Ratio a_Xe6mp)
        (case eta_XRG of { :% a1_ae1Us b_ae1Ut ->
         let {
           k_se9oY [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
             :: forall d b1.
                Data d =>
                Mp m_ae5De (d -> b1) -> d -> m_ae5De (b1, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_se9oY
             = \ (@ d_ae2Ya)
                 (@ b1_ae2Yb)
                 ($dData1_ae2Yd :: Data d_ae2Ya)
                 (ds1_de7pC [OS=OneShot] :: Mp m_ae5De (d_ae2Ya -> b1_ae2Yb))
                 (y_ae1TO [OS=OneShot] :: d_ae2Ya) ->
                 let {
                   lvl271_se9VK :: m_ae5De d_ae2Ya
                   [LclId]
                   lvl271_se9VK = ds_de7JL @ d_ae2Ya $dData1_ae2Yd y_ae1TO } in
                 >>=
                   @ m_ae5De
                   $dMonad_se9oZ
                   @ (d_ae2Ya -> b1_ae2Yb, Bool)
                   @ (b1_ae2Yb, Bool)
                   (ds1_de7pC
                    `cast` (Data.Data.N:Mp[0] <m_ae5De>_R <d_ae2Ya -> b1_ae2Yb>_N
                            :: (Mp m_ae5De (d_ae2Ya -> b1_ae2Yb) :: *)
                               ~R# (m_ae5De (d_ae2Ya -> b1_ae2Yb, Bool) :: *)))
                   (\ (ds2_de7pD :: (d_ae2Ya -> b1_ae2Yb, Bool)) ->
                      case ds2_de7pD of { (h_ae1TP, b2_ae1TQ) ->
                      case b2_ae1TQ of {
                        False ->
                          mplus
                            @ m_ae5De
                            $dMonadPlus_ae5Dg
                            @ (b1_ae2Yb, Bool)
                            (>>=
                               @ m_ae5De
                               $dMonad_se9oZ
                               @ d_ae2Ya
                               @ (b1_ae2Yb, Bool)
                               lvl271_se9VK
                               (\ (y'_ae1TR :: d_ae2Ya) ->
                                  return
                                    @ m_ae5De
                                    $dMonad_se9oZ
                                    @ (b1_ae2Yb, Bool)
                                    (h_ae1TP y'_ae1TR, GHC.Types.True)))
                            (return
                               @ m_ae5De
                               $dMonad_se9oZ
                               @ (b1_ae2Yb, Bool)
                               (h_ae1TP y_ae1TO, GHC.Types.False));
                        True ->
                          return
                            @ m_ae5De
                            $dMonad_se9oZ
                            @ (b1_ae2Yb, Bool)
                            (h_ae1TP y_ae1TO, GHC.Types.True)
                      }
                      }) } in
         k_se9oY
           @ a_Xe6mp
           @ (Ratio a_Xe6mp)
           $dData_Xe7e1
           ((k_se9oY
               @ a_Xe6mp
               @ (a_Xe6mp -> Ratio a_Xe6mp)
               $dData_Xe7e1
               ((return
                   @ m_ae5De
                   $dMonad_se9oZ
                   @ (a_Xe6mp -> a_Xe6mp -> Ratio a_Xe6mp, Bool)
                   (% @ a_Xe6mp $dIntegral_Xe7e4, GHC.Types.False))
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_ae5De>_R <a_Xe6mp -> a_Xe6mp -> Ratio a_Xe6mp>_N)
                        :: (m_ae5De (a_Xe6mp -> a_Xe6mp -> Ratio a_Xe6mp, Bool) :: *)
                           ~R# (Mp m_ae5De (a_Xe6mp -> a_Xe6mp -> Ratio a_Xe6mp) :: *)))
               a1_ae1Us)
            `cast` (Sym (Data.Data.N:Mp[0]
                             <m_ae5De>_R <a_Xe6mp -> Ratio a_Xe6mp>_N)
                    :: (m_ae5De (a_Xe6mp -> Ratio a_Xe6mp, Bool) :: *)
                       ~R# (Mp m_ae5De (a_Xe6mp -> Ratio a_Xe6mp) :: *)))
           b_ae1Ut
         })
        (\ (ds1_de7pa :: (Ratio a_Xe6mp, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9VL;
             True -> return @ m_ae5De $dMonad_se9oZ @ (Ratio a_Xe6mp) x'_ae1TS
           }
           })

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl221_rejVM :: forall a. Ratio a -> Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl221_rejVM = \ (@ a_Xe6mo) _ [Occ=Dead] -> ratioConstr

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl222_rejVN :: forall a. Ratio a -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl222_rejVN = \ (@ a_Xe6mo) _ [Occ=Dead] -> ratioDataType

-- RHS size: {terms: 6, types: 26, coercions: 0, joins: 0/0}
lvl223_rejVO
  :: forall a (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Ratio a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl223_rejVO
  = \ (@ a_Xe6mo)
      (@ (t_ae5AR :: * -> *))
      (@ (c_ae5AS :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5AS (Ratio a_Xe6mo))

-- RHS size: {terms: 6, types: 35, coercions: 0, joins: 0/0}
lvl224_rejVP
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c (Ratio a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl224_rejVP
  = \ (@ a_Xe6mo)
      (@ (t_ae5Ba :: * -> * -> *))
      (@ (c_ae5Bb :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5Bb (Ratio a_Xe6mo))

-- RHS size: {terms: 41, types: 23, coercions: 47, joins: 0/0}
Data.Data.$fDataRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. (Data a, Integral a) => Data (Ratio a)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=DFun: \ (@ a_ae1Up)
             (v_XRC :: Data a_ae1Up)
             (v1_XRE :: Integral a_ae1Up) ->
       Data.Data.C:Data TYPE: Ratio a_ae1Up
                        (Data.Data.$fDataRatio8 @ a_ae1Up v_XRC v1_XRE)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Ratio
                                                                                    a_ae1Up>_N
                                :: (Data.Typeable.Internal.TypeRep (Ratio a_ae1Up) :: *)
                                   ~R# (Typeable (Ratio a_ae1Up) :: Constraint))
                        Data.Data.$fDataRatio_$cgfoldl @ a_ae1Up v_XRC v1_XRE
                        Data.Data.$fDataRatio_$cgunfold @ a_ae1Up v_XRC v1_XRE
                        \ _ [Occ=Dead] -> ratioConstr
                        \ _ [Occ=Dead] -> ratioDataType
                        \ (@ (t_ae5AR :: * -> *))
                          (@ (c_ae5AS :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae5AS (Ratio a_ae1Up))
                        \ (@ (t_ae5Ba :: * -> * -> *))
                          (@ (c_ae5Bb :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae5Bb (Ratio a_ae1Up))
                        (Data.Data.$fDataRatio2 @ a_ae1Up v_XRC v1_XRE)
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <Ratio a_ae1Up>_R
                                ->_R Data.Functor.Identity.N:Identity[0] <Ratio a_ae1Up>_R
                                :: ((forall b. Data b => b -> b)
                                    -> Ratio a_ae1Up -> Identity (Ratio a_ae1Up) :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> Ratio a_ae1Up -> Ratio a_ae1Up :: *))
                        (Data.Data.$fDataRatio1 @ a_ae1Up v_XRC v1_XRE)
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <Ratio a_ae1Up>_R
                                ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <Ratio a_ae1Up>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> Ratio a_ae1Up
                                    -> Const r (Ratio a_ae1Up) :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d. Data d => d -> r')
                                        -> Ratio a_ae1Up
                                        -> r :: *))
                        Data.Data.$fDataRatio_$cgmapQr @ a_ae1Up v_XRC v1_XRE
                        Data.Data.$fDataRatio_$cgmapQ @ a_ae1Up v_XRC v1_XRE
                        Data.Data.$fDataRatio_$cgmapQi @ a_ae1Up v_XRC v1_XRE
                        Data.Data.$fDataRatio_$cgmapM @ a_ae1Up v_XRC v1_XRE
                        Data.Data.$fDataRatio_$cgmapMp @ a_ae1Up v_XRC v1_XRE
                        Data.Data.$fDataRatio_$cgmapMo @ a_ae1Up v_XRC v1_XRE]
Data.Data.$fDataRatio
  = \ (@ a_Xe6mo)
      ($dData_Xe6mq :: Data a_Xe6mo)
      ($dIntegral_Xe7e4 :: Integral a_Xe6mo) ->
      Data.Data.C:Data
        @ (Ratio a_Xe6mo)
        ((Data.Data.$fDataRatio8 @ a_Xe6mo $dData_Xe6mq $dIntegral_Xe7e4)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Ratio
                                                                     a_Xe6mo>_N
                 :: (Data.Typeable.Internal.TypeRep (Ratio a_Xe6mo) :: *)
                    ~R# (Typeable (Ratio a_Xe6mo) :: Constraint)))
        (Data.Data.$fDataRatio_$cgfoldl
           @ a_Xe6mo $dData_Xe6mq $dIntegral_Xe7e4)
        (Data.Data.$fDataRatio_$cgunfold
           @ a_Xe6mo $dData_Xe6mq $dIntegral_Xe7e4)
        (lvl221_rejVM @ a_Xe6mo)
        (lvl222_rejVN @ a_Xe6mo)
        (lvl223_rejVO @ a_Xe6mo)
        (lvl224_rejVP @ a_Xe6mo)
        ((Data.Data.$fDataRatio2 @ a_Xe6mo $dData_Xe6mq $dIntegral_Xe7e4)
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <Ratio a_Xe6mo>_R
                 ->_R Data.Functor.Identity.N:Identity[0] <Ratio a_Xe6mo>_R
                 :: ((forall b. Data b => b -> b)
                     -> Ratio a_Xe6mo -> Identity (Ratio a_Xe6mo) :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> Ratio a_Xe6mo -> Ratio a_Xe6mo :: *)))
        ((Data.Data.$fDataRatio1 @ a_Xe6mo $dData_Xe6mq $dIntegral_Xe7e4)
         `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                 <r -> r' -> r>_R
                 ->_R <r>_R
                 ->_R <forall d. Data d => d -> r'>_R
                 ->_R <Ratio a_Xe6mo>_R
                 ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <Ratio a_Xe6mo>_P
                 :: (forall r r'.
                     (r -> r' -> r)
                     -> r
                     -> (forall d. Data d => d -> r')
                     -> Ratio a_Xe6mo
                     -> Const r (Ratio a_Xe6mo) :: *)
                    ~R# (forall r r'.
                         (r -> r' -> r)
                         -> r -> (forall d. Data d => d -> r') -> Ratio a_Xe6mo -> r :: *)))
        (Data.Data.$fDataRatio_$cgmapQr
           @ a_Xe6mo $dData_Xe6mq $dIntegral_Xe7e4)
        (Data.Data.$fDataRatio_$cgmapQ
           @ a_Xe6mo $dData_Xe6mq $dIntegral_Xe7e4)
        (Data.Data.$fDataRatio_$cgmapQi
           @ a_Xe6mo $dData_Xe6mq $dIntegral_Xe7e4)
        (Data.Data.$fDataRatio_$cgmapM
           @ a_Xe6mo $dData_Xe6mq $dIntegral_Xe7e4)
        (Data.Data.$fDataRatio_$cgmapMp
           @ a_Xe6mo $dData_Xe6mq $dIntegral_Xe7e4)
        (Data.Data.$fDataRatio_$cgmapMo
           @ a_Xe6mo $dData_Xe6mq $dIntegral_Xe7e4)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
listDataType1_rejVQ :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
listDataType1_rejVQ = "Prelude.[]"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
listDataType2_rejVR :: [Char]
[GblId]
listDataType2_rejVR = unpackCString# listDataType1_rejVQ

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str56_rejVS :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str56_rejVS = "[]"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str57_rejVT :: String
[GblId]
str57_rejVT = unpackCString# str56_rejVS

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
str58_rejVU :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
str58_rejVU = "(:)"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
str59_rejVV :: String
[GblId]
str59_rejVV = unpackCString# str58_rejVU

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go59_rejVW :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go59_rejVW
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str59_rejVV of {
                False -> go59_rejVW ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go60_rejVX :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go60_rejVX
  = \ (ds_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Constr ds1_de7m3 ds2_de7m4 ds3_de7m5 ds4_de7m6 ds5_de7m7 ->
              case eqString ds2_de7m4 str57_rejVT of {
                False -> go60_rejVX ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
consConstr1_rejVY :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
consConstr1_rejVY = Data.Data.AlgConstr consConstr2_rejW4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
nilConstr1_rejVZ :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
nilConstr1_rejVZ = Data.Data.AlgConstr nilConstr2_rejW3

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
consConstr [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
consConstr
  = Data.Data.Constr
      consConstr1_rejVY
      str59_rejVV
      (GHC.Types.[] @ String)
      Data.Data.Infix
      listDataType

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
listDataType3_rejW0 :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
listDataType3_rejW0
  = GHC.Types.: @ Constr consConstr (GHC.Types.[] @ Constr)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
listDataType4_rejW1 :: [Constr]
[GblId, Str=m2, Unf=OtherCon []]
listDataType4_rejW1
  = GHC.Types.: @ Constr nilConstr listDataType3_rejW0

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
listDataType5_rejW2 :: DataRep
[GblId, Str=m1, Unf=OtherCon []]
listDataType5_rejW2 = Data.Data.AlgRep listDataType4_rejW1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
listDataType [Occ=LoopBreaker] :: DataType
[GblId, Str=m, Unf=OtherCon []]
listDataType
  = Data.Data.DataType listDataType2_rejVR listDataType5_rejW2

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
nilConstr [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
nilConstr
  = Data.Data.Constr
      nilConstr1_rejVZ
      str57_rejVT
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      listDataType

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
nilConstr2_rejW3 :: ConIndex
[GblId]
nilConstr2_rejW3
  = go60_rejVX listDataType4_rejW1 Data.Data.mkConstr1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
consConstr2_rejW4 :: ConIndex
[GblId]
consConstr2_rejW4
  = go59_rejVW listDataType4_rejW1 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl225_rejW5 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl225_rejW5 = "Data.Data.gunfold(List)"#

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
lvl226_rejW6 :: forall (c :: * -> *) a. c [a]
[GblId, Str=x]
lvl226_rejW6
  = \ (@ (c_ae5wJ :: * -> *)) (@ a_Xe6j4) ->
      errorWithoutStackTrace
        @ 'LiftedRep @ (c_ae5wJ [a_Xe6j4]) (unpackCString# lvl225_rejW5)

-- RHS size: {terms: 6, types: 35, coercions: 0, joins: 0/0}
lvl227_rejW7
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c [a])
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl227_rejW7
  = \ (@ a_Xe6j2)
      (@ (t_ae5xB :: * -> * -> *))
      (@ (c_ae5xC :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5xC [a_Xe6j2])

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl228_rejW8 :: forall a. [a] -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl228_rejW8 = \ (@ a_Xe6j2) _ [Occ=Dead] -> listDataType

-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
lvl229_rejW9 :: forall a. [a] -> Constr
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []]
lvl229_rejW9
  = \ (@ a_Xe6j2) (ds_de7HK :: [a_Xe6j2]) ->
      case ds_de7HK of {
        [] -> nilConstr;
        : ds1_de7HT ds2_de7HU -> consConstr
      }

-- RHS size: {terms: 5, types: 33, coercions: 0, joins: 0/0}
lvl230_rejWa
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c [Char])
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl230_rejWa
  = \ (@ (t_ae5xB :: * -> * -> *))
      (@ (c_ae5xC :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5xC [Char])

-- RHS size: {terms: 16, types: 40, coercions: 12, joins: 0/1}
lvl231_rejWb
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c [Char])
[GblId, Arity=1, Str=<L,1*U>, Unf=OtherCon []]
lvl231_rejWb
  = \ (@ (t_ae5xj :: * -> *))
      (@ (c_ae5xk :: * -> *))
      ($dTypeable_ae5xm :: Typeable t_ae5xj) ->
      let {
        lvl270_se9yn :: Bool
        [LclId]
        lvl270_se9yn
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_ae5xj
              @ []
              ($dTypeable_ae5xm
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_ae5xj>_N
                       :: (Typeable t_ae5xj :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_ae5xj :: *)))
              Data.Data.$fData[]2 } in
      \ (f_ae1Ud :: forall d. Data d => c_ae5xk (t_ae5xj d)) ->
        case lvl270_se9yn of {
          False -> GHC.Base.Nothing @ (c_ae5xk [Char]);
          True ->
            GHC.Base.Just
              @ (c_ae5xk [Char])
              ((f_ae1Ud @ Char Data.Data.$fDataChar)
               `cast` (<c_ae5xk>_R (UnsafeCo nominal t_ae5xj [] <Char>_N)
                       :: (c_ae5xk (t_ae5xj Char) :: *) ~R# (c_ae5xk [Char] :: *)))
        }

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
lvl232_rejWc :: [Char] -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl232_rejWc = \ _ [Occ=Dead] -> listDataType

-- RHS size: {terms: 7, types: 7, coercions: 0, joins: 0/0}
lvl233_rejWd :: [Char] -> Constr
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []]
lvl233_rejWd
  = \ (ds_de7HK :: [Char]) ->
      case ds_de7HK of {
        [] -> nilConstr;
        : ds1_de7HT ds2_de7HU -> consConstr
      }

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
lvl234_rejWe :: Data.Typeable.Internal.TypeRep [Char]
[GblId]
lvl234_rejWe
  = Data.Typeable.Internal.mkTrApp
      @ * @ * @ [] @ Char Data.Data.$fData[]2 Data.Data.$fDataChar7

-- RHS size: {terms: 5, types: 33, coercions: 0, joins: 0/0}
lvl235_rejWf
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c [Int])
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl235_rejWf
  = \ (@ (t_ae5xB :: * -> * -> *))
      (@ (c_ae5xC :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5xC [Int])

-- RHS size: {terms: 16, types: 40, coercions: 12, joins: 0/1}
lvl236_rejWg
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c [Int])
[GblId, Arity=1, Str=<L,1*U>, Unf=OtherCon []]
lvl236_rejWg
  = \ (@ (t_ae5xj :: * -> *))
      (@ (c_ae5xk :: * -> *))
      ($dTypeable_ae5xm :: Typeable t_ae5xj) ->
      let {
        lvl270_se9yn :: Bool
        [LclId]
        lvl270_se9yn
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_ae5xj
              @ []
              ($dTypeable_ae5xm
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_ae5xj>_N
                       :: (Typeable t_ae5xj :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_ae5xj :: *)))
              Data.Data.$fData[]2 } in
      \ (f_ae1Ud :: forall d. Data d => c_ae5xk (t_ae5xj d)) ->
        case lvl270_se9yn of {
          False -> GHC.Base.Nothing @ (c_ae5xk [Int]);
          True ->
            GHC.Base.Just
              @ (c_ae5xk [Int])
              ((f_ae1Ud @ Int Data.Data.$fDataInt)
               `cast` (<c_ae5xk>_R (UnsafeCo nominal t_ae5xj [] <Int>_N)
                       :: (c_ae5xk (t_ae5xj Int) :: *) ~R# (c_ae5xk [Int] :: *)))
        }

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
lvl237_rejWh :: [Int] -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl237_rejWh = \ _ [Occ=Dead] -> listDataType

-- RHS size: {terms: 7, types: 7, coercions: 0, joins: 0/0}
lvl238_rejWi :: [Int] -> Constr
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []]
lvl238_rejWi
  = \ (ds_de7HK :: [Int]) ->
      case ds_de7HK of {
        [] -> nilConstr;
        : ds1_de7HT ds2_de7HU -> consConstr
      }

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
lvl239_rejWj :: Data.Typeable.Internal.TypeRep [Int]
[GblId]
lvl239_rejWj
  = Data.Typeable.Internal.mkTrApp
      @ * @ * @ [] @ Int Data.Data.$fData[]2 Data.Data.$fDataInt4

-- RHS size: {terms: 4, types: 8, coercions: 0, joins: 0/0}
lvl240_rejWk :: forall (c :: * -> *). c [Char]
[GblId, Str=x]
lvl240_rejWk
  = \ (@ (c_ae5wJ :: * -> *)) ->
      errorWithoutStackTrace
        @ 'LiftedRep @ (c_ae5wJ [Char]) (unpackCString# lvl225_rejW5)

-- RHS size: {terms: 4, types: 8, coercions: 0, joins: 0/0}
lvl241_rejWl :: forall (c :: * -> *). c [Int]
[GblId, Str=x]
lvl241_rejWl
  = \ (@ (c_ae5wJ :: * -> *)) ->
      errorWithoutStackTrace
        @ 'LiftedRep @ (c_ae5wJ [Int]) (unpackCString# lvl225_rejW5)

Rec {
-- RHS size: {terms: 12, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fData[]_$s$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c [Char]
[GblId,
 Arity=3,
 Str=<L,C(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_segC9 :: * -> *))
                 (w_segCa [Occ=Once]
                    :: forall b r. Data b => c_segC9 (b -> r) -> c_segC9 r)
                 (w1_segCb [Occ=Once] :: forall r. r -> c_segC9 r)
                 (w2_segCc [Occ=Once!] :: Constr) ->
                 case w2_segCc of
                 { Constr ww1_segCf [Occ=Once] _ [Occ=Dead] _ [Occ=Dead]
                          _ [Occ=Dead] ww5_segCj [Occ=Once] ->
                 Data.Data.$w$s$cgunfold
                   @ c_segC9 w_segCa w1_segCb ww1_segCf ww5_segCj
                 }}]
Data.Data.$fData[]_$s$cgunfold
  = \ (@ (c_segC9 :: * -> *))
      (w_segCa :: forall b r. Data b => c_segC9 (b -> r) -> c_segC9 r)
      (w1_segCb :: forall r. r -> c_segC9 r)
      (w2_segCc :: Constr) ->
      case w2_segCc of
      { Constr ww1_segCf ww2_segCg ww3_segCh ww4_segCi ww5_segCj ->
      Data.Data.$w$s$cgunfold
        @ c_segC9 w_segCa w1_segCb ww1_segCf ww5_segCj
      }

-- RHS size: {terms: 16, types: 2, coercions: 6, joins: 0/0}
Data.Data.$fData[]_$s$fData[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Data [Char]
[GblId,
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: [Char]
                        (Data.Typeable.Internal.mkTrApp
                           @ * @ * @ [] @ Char Data.Data.$fData[]2 Data.Data.$fDataChar7)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <[Char]>_N
                                :: (Data.Typeable.Internal.TypeRep [Char] :: *)
                                   ~R# (Typeable [Char] :: Constraint))
                        Data.Data.$fData[]_$s$cgfoldl
                        Data.Data.$fData[]_$s$cgunfold
                        \ (ds_de7HK [Occ=Once!] :: [Char]) ->
                          case ds_de7HK of {
                            [] -> nilConstr;
                            : _ [Occ=Dead] _ [Occ=Dead] -> consConstr
                          }
                        \ _ [Occ=Dead] -> listDataType
                        Data.Data.$fData[]_$s$cdataCast1
                        \ (@ (t_ae5xB :: * -> * -> *))
                          (@ (c_ae5xC :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae5xC [Char])
                        Data.Data.$fData[]_$s$cgmapT
                        Data.Data.$fData[]1
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <[Char]>_R
                                ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <[Char]>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> [Char]
                                    -> Const r [Char] :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r -> (forall d. Data d => d -> r') -> [Char] -> r :: *))
                        Data.Data.$fData[]_$s$cgmapQr
                        Data.Data.$fData[]_$s$cgmapQ
                        Data.Data.$fData[]_$s$cgmapQi
                        Data.Data.$fData[]_$s$cgmapM
                        Data.Data.$fData[]_$s$cgmapMp
                        Data.Data.$fData[]_$s$cgmapMo]
Data.Data.$fData[]_$s$fData[]
  = Data.Data.C:Data
      @ [Char]
      (lvl234_rejWe
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <[Char]>_N
               :: (Data.Typeable.Internal.TypeRep [Char] :: *)
                  ~R# (Typeable [Char] :: Constraint)))
      lvl246_rejWq
      lvl250_rejWu
      lvl233_rejWd
      lvl232_rejWc
      lvl231_rejWb
      lvl230_rejWa
      lvl248_rejWs
      Data.Data.$fData[]4
      lvl244_rejWo
      lvl247_rejWr
      lvl243_rejWn
      lvl249_rejWt
      lvl242_rejWm
      lvl245_rejWp

-- RHS size: {terms: 32, types: 49, coercions: 0, joins: 0/2}
Data.Data.$fData[]_$s$cgmapM [Occ=LoopBreaker]
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> [Char] -> m [Char]
[GblId, Arity=1, Str=<L,U(A,C(C1(U)),A,C(U),A)>, Unf=OtherCon []]
Data.Data.$fData[]_$s$cgmapM
  = \ (@ (m_ae5z3 :: * -> *)) ($dMonad_ae5z5 :: Monad m_ae5z3) ->
      let {
        lvl270_se9Wd :: m_ae5z3 [Char]
        [LclId]
        lvl270_se9Wd
          = return
              @ m_ae5z3 $dMonad_ae5z5 @ [Char] (GHC.Types.[] @ Char) } in
      \ (ds_de7Iw :: forall d. Data d => d -> m_ae5z3 d)
        (ds1_de7Ix :: [Char]) ->
        case ds1_de7Ix of {
          [] -> lvl270_se9Wd;
          : x_ae1Ul xs_ae1Um ->
            let {
              lvl271_se9We :: m_ae5z3 [Char]
              [LclId]
              lvl271_se9We
                = ds_de7Iw @ [Char] Data.Data.$fData[]_$s$fData[] xs_ae1Um } in
            >>=
              @ m_ae5z3
              $dMonad_ae5z5
              @ Char
              @ [Char]
              (ds_de7Iw @ Char Data.Data.$fDataChar x_ae1Ul)
              (\ (x'_ae1Un :: Char) ->
                 >>=
                   @ m_ae5z3
                   $dMonad_ae5z5
                   @ [Char]
                   @ [Char]
                   lvl271_se9We
                   (\ (xs'_ae1Uo :: [Char]) ->
                      return
                        @ m_ae5z3
                        $dMonad_ae5z5
                        @ [Char]
                        (GHC.Types.: @ Char x'_ae1Un xs'_ae1Uo)))
        }

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
Data.Data.$fData[]_$s$cgmapT [Occ=LoopBreaker]
  :: (forall b. Data b => b -> b) -> [Char] -> [Char]
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []]
Data.Data.$fData[]_$s$cgmapT
  = \ (ds_de7I2 :: forall b. Data b => b -> b)
      (ds1_de7I3 :: [Char]) ->
      case ds1_de7I3 of {
        [] -> GHC.Types.[] @ Char;
        : x_ae1Uf xs_ae1Ug ->
          GHC.Types.:
            @ Char
            (ds_de7I2 @ Char Data.Data.$fDataChar x_ae1Uf)
            (ds_de7I2 @ [Char] Data.Data.$fData[]_$s$fData[] xs_ae1Ug)
      }

-- RHS size: {terms: 22, types: 36, coercions: 47, joins: 0/0}
Data.Data.$fData[]_$s$cgmapQr [Occ=LoopBreaker]
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> [Char] -> r
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,U><L,C(C1(U))><S,1*U>,
 Unf=OtherCon []]
Data.Data.$fData[]_$s$cgmapQr
  = \ (@ r_ae5yo)
      (@ r'_ae5yp)
      (ds_de7Ie :: r'_ae5yp -> r_ae5yo -> r_ae5yo)
      (ds1_de7If :: r_ae5yo)
      (ds2_de7Ig :: forall d. Data d => d -> r'_ae5yp)
      (x0_ae1SX :: [Char]) ->
      ((Data.Data.$fData[]_$s$cgfoldl
          @ (Qr r_ae5yo)
          ((\ (@ d_ae2Sl)
              (@ b_ae2Sm)
              ($dData_ae2So :: Data d_ae2Sl)
              (ds3_de7nc [OS=OneShot] :: Qr r_ae5yo (d_ae2Sl -> b_ae2Sm))
              (x_ae1T2 [OS=OneShot] :: d_ae2Sl)
              (r1_ae1T3 :: r_ae5yo) ->
              (ds3_de7nc
               `cast` (Data.Data.N:Qr[0] <*>_N <r_ae5yo>_R <d_ae2Sl -> b_ae2Sm>_P
                       :: (Qr r_ae5yo (d_ae2Sl -> b_ae2Sm) :: *)
                          ~R# (r_ae5yo -> r_ae5yo :: *)))
                (ds_de7Ie (ds2_de7Ig @ d_ae2Sl $dData_ae2So x_ae1T2) r1_ae1T3))
           `cast` (forall (d :: <*>_N) (b :: <*>_N).
                   <Data d>_R
                   ->_R <Qr r_ae5yo (d -> b)>_R
                   ->_R <d>_R
                   ->_R Sym (Data.Data.N:Qr[0] <*>_N <r_ae5yo>_R <b>_P)
                   :: (forall d b.
                       Data d =>
                       Qr r_ae5yo (d -> b) -> d -> r_ae5yo -> r_ae5yo :: *)
                      ~R# (forall d b.
                           Data d =>
                           Qr r_ae5yo (d -> b) -> d -> Qr r_ae5yo b :: *)))
          ((lvl13_rejMm @ r_ae5yo)
           `cast` (forall (g :: <*>_N).
                   <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r_ae5yo>_R <g>_P)
                   :: (forall g. g -> r_ae5yo -> r_ae5yo :: *)
                      ~R# (forall g. g -> Qr r_ae5yo g :: *)))
          x0_ae1SX)
       `cast` (Data.Data.N:Qr[0] <*>_N <r_ae5yo>_R <[Char]>_P
               :: (Qr r_ae5yo [Char] :: *) ~R# (r_ae5yo -> r_ae5yo :: *)))
        ds1_de7If

-- RHS size: {terms: 17, types: 22, coercions: 0, joins: 0/0}
Data.Data.$fData[]_$s$cgmapQ [Occ=LoopBreaker]
  :: forall u. (forall d. Data d => d -> u) -> [Char] -> [u]
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []]
Data.Data.$fData[]_$s$cgmapQ
  = \ (@ u_ae5yF)
      (ds_de7Ih :: forall d. Data d => d -> u_ae5yF)
      (ds1_de7Ii :: [Char]) ->
      case ds1_de7Ii of {
        [] -> GHC.Types.[] @ u_ae5yF;
        : x_ae1Ui xs_ae1Uj ->
          GHC.Types.:
            @ u_ae5yF
            (ds_de7Ih @ Char Data.Data.$fDataChar x_ae1Ui)
            (GHC.Types.:
               @ u_ae5yF
               (ds_de7Ih @ [Char] Data.Data.$fData[]_$s$fData[] xs_ae1Uj)
               (GHC.Types.[] @ u_ae5yF))
      }

-- RHS size: {terms: 21, types: 37, coercions: 41, joins: 0/0}
Data.Data.$fData[]1 [Occ=LoopBreaker]
  :: forall r r'.
     (r -> r' -> r)
     -> r -> (forall d. Data d => d -> r') -> [Char] -> Const r [Char]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,1*U><L,C(C1(U))><S,1*U>,
 Unf=OtherCon []]
Data.Data.$fData[]1
  = \ (@ r_ae5y7)
      (@ r'_ae5y8)
      (ds_de7Ib :: r_ae5y7 -> r'_ae5y8 -> r_ae5y7)
      (ds1_de7Ic :: r_ae5y7)
      (ds2_de7Id :: forall d. Data d => d -> r'_ae5y8)
      (eta_B1 :: [Char]) ->
      Data.Data.$fData[]_$s$cgfoldl
        @ (Const r_ae5y7)
        ((\ (@ d_ae2R3)
            (@ b_ae2R4)
            ($dData_ae2R6 :: Data d_ae2R3)
            (c_ae1SS [OS=OneShot] :: Const r_ae5y7 (d_ae2R3 -> b_ae2R4))
            (x_ae1ST [OS=OneShot] :: d_ae2R3) ->
            ds_de7Ib
              (c_ae1SS
               `cast` (Data.Functor.Const.N:Const[0]
                           <*>_N <r_ae5y7>_R <d_ae2R3 -> b_ae2R4>_P
                       :: (Const r_ae5y7 (d_ae2R3 -> b_ae2R4) :: *) ~R# (r_ae5y7 :: *)))
              (ds2_de7Id @ d_ae2R3 $dData_ae2R6 x_ae1ST))
         `cast` (forall (d :: <*>_N) (b :: <*>_N).
                 <Data d>_R
                 ->_R <Const r_ae5y7 (d -> b)>_R
                 ->_R <d>_R
                 ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r_ae5y7>_R <b>_P)
                 :: (forall d b.
                     Data d =>
                     Const r_ae5y7 (d -> b) -> d -> r_ae5y7 :: *)
                    ~R# (forall d b.
                         Data d =>
                         Const r_ae5y7 (d -> b) -> d -> Const r_ae5y7 b :: *)))
        ((\ (@ g_ae2RK) _ [Occ=Dead, OS=OneShot] -> ds1_de7Ic)
         `cast` (forall (g :: <*>_N).
                 <g>_R
                 ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r_ae5y7>_R <g>_P)
                 :: (forall g. g -> r_ae5y7 :: *)
                    ~R# (forall g. g -> Const r_ae5y7 g :: *)))
        eta_B1

-- RHS size: {terms: 18, types: 46, coercions: 0, joins: 0/0}
Data.Data.$fData[]_$s$cgfoldl [Occ=LoopBreaker]
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> [Char] -> c [Char]
[GblId,
 Arity=3,
 Str=<L,C(C1(C1(U)))><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []]
Data.Data.$fData[]_$s$cgfoldl
  = \ (@ (c_ae5wt :: * -> *))
      (ds_de7Hr
         :: forall d b. Data d => c_ae5wt (d -> b) -> d -> c_ae5wt b)
      (z_ae1U5 :: forall g. g -> c_ae5wt g)
      (ds1_de7Hs :: [Char]) ->
      case ds1_de7Hs of {
        [] -> z_ae1U5 @ [Char] (GHC.Types.[] @ Char);
        : x_ae1U8 xs_ae1U9 ->
          ds_de7Hr
            @ [Char]
            @ [Char]
            Data.Data.$fData[]_$s$fData[]
            (ds_de7Hr
               @ Char
               @ ([Char] -> [Char])
               Data.Data.$fDataChar
               (z_ae1U5 @ (Char -> [Char] -> [Char]) (GHC.Types.: @ Char))
               x_ae1U8)
            xs_ae1U9
      }

-- RHS size: {terms: 44, types: 61, coercions: 0, joins: 0/0}
Data.Data.$fData[]_$s$cgmapQi [Occ=LoopBreaker]
  :: forall u. Int -> (forall d. Data d => d -> u) -> [Char] -> u
[GblId, Arity=3, Str=<L,U(U)><L,C(C1(U))><S,1*U>, Unf=OtherCon []]
Data.Data.$fData[]_$s$cgmapQi
  = \ (@ u_ae5yP)
      (ds_de7Iu :: Int)
      (ds1_de7Iv :: forall d. Data d => d -> u_ae5yP)
      (x_ae1T7 :: [Char]) ->
      case Data.Data.$fData[]_$s$cgfoldl
             @ (Qi u_ae5yP)
             (\ (@ d_ae2U4)
                (@ b_ae2U5)
                ($dData_ae2U7 :: Data d_ae2U4)
                (ds2_de7nG [OS=OneShot] :: Qi u_ae5yP (d_ae2U4 -> b_ae2U5))
                (a_ae1Tg [OS=OneShot] :: d_ae2U4) ->
                case ds2_de7nG of { Qi i'_ae1Te q_ae1Tf ->
                Data.Data.Qi
                  @ *
                  @ u_ae5yP
                  @ b_ae2U5
                  (case i'_ae1Te of { I# x1_i7MX1 -> GHC.Types.I# (+# x1_i7MX1 1#) })
                  (case ds_de7Iu of { I# x1_a22G ->
                   case i'_ae1Te of { I# y_a22K ->
                   case ==# x1_a22G y_a22K of {
                     __DEFAULT -> q_ae1Tf;
                     1# ->
                       GHC.Base.Just @ u_ae5yP (ds1_de7Iv @ d_ae2U4 $dData_ae2U7 a_ae1Tg)
                   }
                   }
                   })
                })
             (lvl54_rejNF @ u_ae5yP)
             x_ae1T7
      of
      { Qi ds2_de7nD q_ae1Th ->
      fromJust @ u_ae5yP q_ae1Th
      }

-- RHS size: {terms: 32, types: 50, coercions: 0, joins: 0/0}
Data.Data.$w$s$cgunfold [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> ConstrRep -> DataType -> c [Char]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
 Unf=OtherCon []]
Data.Data.$w$s$cgunfold
  = \ (@ (c_segC9 :: * -> *))
      (w_segCa :: forall b r. Data b => c_segC9 (b -> r) -> c_segC9 r)
      (w1_segCb :: forall r. r -> c_segC9 r)
      (ww_segCf :: ConstrRep)
      (ww1_segCj :: DataType) ->
      case ww_segCf of {
        __DEFAULT ->
          case ww1_segCj of { DataType ww3_sefV0 ww4_sefV1 ->
          case Data.Data.$wlvl ww3_sefV0 of wild1_00 { }
          };
        AlgConstr idx_ae1Ws ->
          case idx_ae1Ws of { I# ds_de7HF ->
          case ds_de7HF of {
            __DEFAULT -> lvl240_rejWk @ c_segC9;
            1# -> w1_segCb @ [Char] (GHC.Types.[] @ Char);
            2# ->
              w_segCa
                @ [Char]
                @ [Char]
                Data.Data.$fData[]_$s$fData[]
                (w_segCa
                   @ Char
                   @ ([Char] -> [Char])
                   Data.Data.$fDataChar
                   (w1_segCb @ (Char -> [Char] -> [Char]) (GHC.Types.: @ Char)))
          }
          }
      }

-- RHS size: {terms: 67, types: 112, coercions: 37, joins: 0/3}
Data.Data.$fData[]_$s$cgmapMp [Occ=LoopBreaker]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> [Char] -> m [Char]
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U>,
 Unf=OtherCon []]
Data.Data.$fData[]_$s$cgmapMp
  = \ (@ (m_ae5zu :: * -> *))
      ($dMonadPlus_ae5zw :: MonadPlus m_ae5zu)
      (ds_de7IP :: forall d. Data d => d -> m_ae5zu d)
      (eta_XRX :: [Char]) ->
      let {
        lvl270_se9W6 :: m_ae5zu [Char]
        [LclId]
        lvl270_se9W6 = mzero @ m_ae5zu $dMonadPlus_ae5zw @ [Char] } in
      let {
        $dMonad_se9nH [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae5zu
        [LclId]
        $dMonad_se9nH
          = GHC.Base.$p2MonadPlus @ m_ae5zu $dMonadPlus_ae5zw } in
      >>=
        @ m_ae5zu
        $dMonad_se9nH
        @ ([Char], Bool)
        @ [Char]
        ((Data.Data.$fData[]_$s$cgfoldl
            @ (Mp m_ae5zu)
            ((\ (@ d_ae2Ws)
                (@ b_ae2Wt)
                ($dData_ae2Wv :: Data d_ae2Ws)
                (ds1_de7oC [OS=OneShot] :: Mp m_ae5zu (d_ae2Ws -> b_ae2Wt))
                (y_ae1Tz [OS=OneShot] :: d_ae2Ws) ->
                let {
                  lvl271_se9W5 :: m_ae5zu d_ae2Ws
                  [LclId]
                  lvl271_se9W5 = ds_de7IP @ d_ae2Ws $dData_ae2Wv y_ae1Tz } in
                >>=
                  @ m_ae5zu
                  $dMonad_se9nH
                  @ (d_ae2Ws -> b_ae2Wt, Bool)
                  @ (b_ae2Wt, Bool)
                  (ds1_de7oC
                   `cast` (Data.Data.N:Mp[0] <m_ae5zu>_R <d_ae2Ws -> b_ae2Wt>_N
                           :: (Mp m_ae5zu (d_ae2Ws -> b_ae2Wt) :: *)
                              ~R# (m_ae5zu (d_ae2Ws -> b_ae2Wt, Bool) :: *)))
                  (\ (ds2_de7oD :: (d_ae2Ws -> b_ae2Wt, Bool)) ->
                     case ds2_de7oD of { (h_ae1TA, b1_ae1TB) ->
                     mplus
                       @ m_ae5zu
                       $dMonadPlus_ae5zw
                       @ (b_ae2Wt, Bool)
                       (>>=
                          @ m_ae5zu
                          $dMonad_se9nH
                          @ d_ae2Ws
                          @ (b_ae2Wt, Bool)
                          lvl271_se9W5
                          (\ (y'_ae1TC :: d_ae2Ws) ->
                             return
                               @ m_ae5zu
                               $dMonad_se9nH
                               @ (b_ae2Wt, Bool)
                               (h_ae1TA y'_ae1TC, GHC.Types.True)))
                       (return
                          @ m_ae5zu
                          $dMonad_se9nH
                          @ (b_ae2Wt, Bool)
                          (h_ae1TA y_ae1Tz, b1_ae1TB))
                     }))
             `cast` (forall (d :: <*>_N) (b :: <*>_N).
                     <Data d>_R
                     ->_R <Mp m_ae5zu (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Mp[0] <m_ae5zu>_R <b>_N)
                     :: (forall d b.
                         Data d =>
                         Mp m_ae5zu (d -> b) -> d -> m_ae5zu (b, Bool) :: *)
                        ~R# (forall d b.
                             Data d =>
                             Mp m_ae5zu (d -> b) -> d -> Mp m_ae5zu b :: *)))
            ((\ (@ g_ae2Xq) (g1_ae1Tx [OS=OneShot] :: g_ae2Xq) ->
                return
                  @ m_ae5zu
                  $dMonad_se9nH
                  @ (g_ae2Xq, Bool)
                  (g1_ae1Tx, GHC.Types.False))
             `cast` (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Mp[0] <m_ae5zu>_R <g>_N)
                     :: (forall g. g -> m_ae5zu (g, Bool) :: *)
                        ~R# (forall g. g -> Mp m_ae5zu g :: *)))
            eta_XRX)
         `cast` (Data.Data.N:Mp[0] <m_ae5zu>_R <[Char]>_N
                 :: (Mp m_ae5zu [Char] :: *) ~R# (m_ae5zu ([Char], Bool) :: *)))
        (\ (ds1_de7oa :: ([Char], Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9W6;
             True -> return @ m_ae5zu $dMonad_se9nH @ [Char] x'_ae1TD
           }
           })

-- RHS size: {terms: 77, types: 119, coercions: 37, joins: 0/3}
Data.Data.$fData[]_$s$cgmapMo [Occ=LoopBreaker]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> [Char] -> m [Char]
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U>,
 Unf=OtherCon []]
Data.Data.$fData[]_$s$cgmapMo
  = \ (@ (m_ae5zK :: * -> *))
      ($dMonadPlus_ae5zM :: MonadPlus m_ae5zK)
      (ds_de7IQ :: forall d. Data d => d -> m_ae5zK d)
      (eta_XRY :: [Char]) ->
      let {
        lvl270_se9W2 :: m_ae5zK [Char]
        [LclId]
        lvl270_se9W2 = mzero @ m_ae5zK $dMonadPlus_ae5zM @ [Char] } in
      let {
        $dMonad_se9nz [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae5zK
        [LclId]
        $dMonad_se9nz
          = GHC.Base.$p2MonadPlus @ m_ae5zK $dMonadPlus_ae5zM } in
      >>=
        @ m_ae5zK
        $dMonad_se9nz
        @ ([Char], Bool)
        @ [Char]
        ((Data.Data.$fData[]_$s$cgfoldl
            @ (Mp m_ae5zK)
            ((\ (@ d_ae2Ya)
                (@ b_ae2Yb)
                ($dData_ae2Yd :: Data d_ae2Ya)
                (ds1_de7pC [OS=OneShot] :: Mp m_ae5zK (d_ae2Ya -> b_ae2Yb))
                (y_ae1TO [OS=OneShot] :: d_ae2Ya) ->
                let {
                  lvl271_se9W1 :: m_ae5zK d_ae2Ya
                  [LclId]
                  lvl271_se9W1 = ds_de7IQ @ d_ae2Ya $dData_ae2Yd y_ae1TO } in
                >>=
                  @ m_ae5zK
                  $dMonad_se9nz
                  @ (d_ae2Ya -> b_ae2Yb, Bool)
                  @ (b_ae2Yb, Bool)
                  (ds1_de7pC
                   `cast` (Data.Data.N:Mp[0] <m_ae5zK>_R <d_ae2Ya -> b_ae2Yb>_N
                           :: (Mp m_ae5zK (d_ae2Ya -> b_ae2Yb) :: *)
                              ~R# (m_ae5zK (d_ae2Ya -> b_ae2Yb, Bool) :: *)))
                  (\ (ds2_de7pD :: (d_ae2Ya -> b_ae2Yb, Bool)) ->
                     case ds2_de7pD of { (h_ae1TP, b1_ae1TQ) ->
                     case b1_ae1TQ of {
                       False ->
                         mplus
                           @ m_ae5zK
                           $dMonadPlus_ae5zM
                           @ (b_ae2Yb, Bool)
                           (>>=
                              @ m_ae5zK
                              $dMonad_se9nz
                              @ d_ae2Ya
                              @ (b_ae2Yb, Bool)
                              lvl271_se9W1
                              (\ (y'_ae1TR :: d_ae2Ya) ->
                                 return
                                   @ m_ae5zK
                                   $dMonad_se9nz
                                   @ (b_ae2Yb, Bool)
                                   (h_ae1TP y'_ae1TR, GHC.Types.True)))
                           (return
                              @ m_ae5zK
                              $dMonad_se9nz
                              @ (b_ae2Yb, Bool)
                              (h_ae1TP y_ae1TO, GHC.Types.False));
                       True ->
                         return
                           @ m_ae5zK
                           $dMonad_se9nz
                           @ (b_ae2Yb, Bool)
                           (h_ae1TP y_ae1TO, GHC.Types.True)
                     }
                     }))
             `cast` (forall (d :: <*>_N) (b :: <*>_N).
                     <Data d>_R
                     ->_R <Mp m_ae5zK (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Mp[0] <m_ae5zK>_R <b>_N)
                     :: (forall d b.
                         Data d =>
                         Mp m_ae5zK (d -> b) -> d -> m_ae5zK (b, Bool) :: *)
                        ~R# (forall d b.
                             Data d =>
                             Mp m_ae5zK (d -> b) -> d -> Mp m_ae5zK b :: *)))
            ((\ (@ g_ae2Zd) (g1_ae1TM [OS=OneShot] :: g_ae2Zd) ->
                return
                  @ m_ae5zK
                  $dMonad_se9nz
                  @ (g_ae2Zd, Bool)
                  (g1_ae1TM, GHC.Types.False))
             `cast` (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Mp[0] <m_ae5zK>_R <g>_N)
                     :: (forall g. g -> m_ae5zK (g, Bool) :: *)
                        ~R# (forall g. g -> Mp m_ae5zK g :: *)))
            eta_XRY)
         `cast` (Data.Data.N:Mp[0] <m_ae5zK>_R <[Char]>_N
                 :: (Mp m_ae5zK [Char] :: *) ~R# (m_ae5zK ([Char], Bool) :: *)))
        (\ (ds1_de7pa :: ([Char], Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9W2;
             True -> return @ m_ae5zK $dMonad_se9nz @ [Char] x'_ae1TS
           }
           })

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl242_rejWm
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> [Char] -> m [Char]
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U>,
 Unf=OtherCon []]
lvl242_rejWm = Data.Data.$fData[]_$s$cgmapMp

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl243_rejWn
  :: forall u. Int -> (forall d. Data d => d -> u) -> [Char] -> u
[GblId, Arity=3, Str=<L,U(U)><L,C(C1(U))><S,1*U>, Unf=OtherCon []]
lvl243_rejWn = Data.Data.$fData[]_$s$cgmapQi

-- RHS size: {terms: 1, types: 0, coercions: 28, joins: 0/0}
Data.Data.$fData[]4 [Occ=LoopBreaker!]
  :: forall r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> [Char] -> r
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,1*U><L,C(C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Data.$fData[]1
               `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                       <r -> r' -> r>_R
                       ->_R <r>_R
                       ->_R <forall d. Data d => d -> r'>_R
                       ->_R <[Char]>_R
                       ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <[Char]>_P
                       :: (forall r r'.
                           (r -> r' -> r)
                           -> r
                           -> (forall d. Data d => d -> r')
                           -> [Char]
                           -> Const r [Char] :: *)
                          ~R# (forall r r'.
                               (r -> r' -> r)
                               -> r -> (forall d. Data d => d -> r') -> [Char] -> r :: *))}]
Data.Data.$fData[]4
  = Data.Data.$fData[]1
    `cast` (forall (r :: <*>_N) (r' :: <*>_N).
            <r -> r' -> r>_R
            ->_R <r>_R
            ->_R <forall d. Data d => d -> r'>_R
            ->_R <[Char]>_R
            ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <[Char]>_P
            :: (forall r r'.
                (r -> r' -> r)
                -> r
                -> (forall d. Data d => d -> r')
                -> [Char]
                -> Const r [Char] :: *)
               ~R# (forall r r'.
                    (r -> r' -> r)
                    -> r -> (forall d. Data d => d -> r') -> [Char] -> r :: *))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl244_rejWo
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> [Char] -> r
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,U><L,C(C1(U))><S,1*U>,
 Unf=OtherCon []]
lvl244_rejWo = Data.Data.$fData[]_$s$cgmapQr

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl245_rejWp
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> [Char] -> m [Char]
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U>,
 Unf=OtherCon []]
lvl245_rejWp = Data.Data.$fData[]_$s$cgmapMo

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl246_rejWq
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> [Char] -> c [Char]
[GblId,
 Arity=3,
 Str=<L,C(C1(C1(U)))><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []]
lvl246_rejWq = Data.Data.$fData[]_$s$cgfoldl

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl247_rejWr
  :: forall u. (forall d. Data d => d -> u) -> [Char] -> [u]
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []]
lvl247_rejWr = Data.Data.$fData[]_$s$cgmapQ

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl248_rejWs :: (forall b. Data b => b -> b) -> [Char] -> [Char]
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []]
lvl248_rejWs = Data.Data.$fData[]_$s$cgmapT

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl249_rejWt
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> [Char] -> m [Char]
[GblId, Arity=1, Str=<L,U(A,C(C1(U)),A,C(U),A)>, Unf=OtherCon []]
lvl249_rejWt = Data.Data.$fData[]_$s$cgmapM

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl250_rejWu
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c [Char]
[GblId,
 Arity=3,
 Str=<L,C(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=OtherCon []]
lvl250_rejWu = Data.Data.$fData[]_$s$cgunfold
end Rec }

Rec {
-- RHS size: {terms: 12, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fData[]_$s$cgunfold1 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c [Int]
[GblId,
 Arity=3,
 Str=<L,C(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_segDe :: * -> *))
                 (w_segDf [Occ=Once]
                    :: forall b r. Data b => c_segDe (b -> r) -> c_segDe r)
                 (w1_segDg [Occ=Once] :: forall r. r -> c_segDe r)
                 (w2_segDh [Occ=Once!] :: Constr) ->
                 case w2_segDh of
                 { Constr ww1_segDk [Occ=Once] _ [Occ=Dead] _ [Occ=Dead]
                          _ [Occ=Dead] ww5_segDo [Occ=Once] ->
                 Data.Data.$w$s$cgunfold1
                   @ c_segDe w_segDf w1_segDg ww1_segDk ww5_segDo
                 }}]
Data.Data.$fData[]_$s$cgunfold1
  = \ (@ (c_segDe :: * -> *))
      (w_segDf :: forall b r. Data b => c_segDe (b -> r) -> c_segDe r)
      (w1_segDg :: forall r. r -> c_segDe r)
      (w2_segDh :: Constr) ->
      case w2_segDh of
      { Constr ww1_segDk ww2_segDl ww3_segDm ww4_segDn ww5_segDo ->
      Data.Data.$w$s$cgunfold1
        @ c_segDe w_segDf w1_segDg ww1_segDk ww5_segDo
      }

-- RHS size: {terms: 16, types: 2, coercions: 6, joins: 0/0}
Data.Data.$fData[]_$s$fData[]1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data [Int]
[GblId,
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: [Int]
                        (Data.Typeable.Internal.mkTrApp
                           @ * @ * @ [] @ Int Data.Data.$fData[]2 Data.Data.$fDataInt4)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <[Int]>_N
                                :: (Data.Typeable.Internal.TypeRep [Int] :: *)
                                   ~R# (Typeable [Int] :: Constraint))
                        Data.Data.$fData[]_$s$cgfoldl1
                        Data.Data.$fData[]_$s$cgunfold1
                        \ (ds_de7HK [Occ=Once!] :: [Int]) ->
                          case ds_de7HK of {
                            [] -> nilConstr;
                            : _ [Occ=Dead] _ [Occ=Dead] -> consConstr
                          }
                        \ _ [Occ=Dead] -> listDataType
                        Data.Data.$fData[]_$s$cdataCast2
                        \ (@ (t_ae5xB :: * -> * -> *))
                          (@ (c_ae5xC :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae5xC [Int])
                        Data.Data.$fData[]_$s$cgmapT1
                        Data.Data.$fData[]3
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <[Int]>_R
                                ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <[Int]>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> [Int]
                                    -> Const r [Int] :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r -> (forall d. Data d => d -> r') -> [Int] -> r :: *))
                        Data.Data.$fData[]_$s$cgmapQr1
                        Data.Data.$fData[]_$s$cgmapQ1
                        Data.Data.$fData[]_$s$cgmapQi1
                        Data.Data.$fData[]_$s$cgmapM1
                        Data.Data.$fData[]_$s$cgmapMp1
                        Data.Data.$fData[]_$s$cgmapMo1]
Data.Data.$fData[]_$s$fData[]1
  = Data.Data.C:Data
      @ [Int]
      (lvl239_rejWj
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <[Int]>_N
               :: (Data.Typeable.Internal.TypeRep [Int] :: *)
                  ~R# (Typeable [Int] :: Constraint)))
      lvl255_rejWz
      lvl259_rejWD
      lvl238_rejWi
      lvl237_rejWh
      lvl236_rejWg
      lvl235_rejWf
      lvl257_rejWB
      Data.Data.$fData[]5
      lvl252_rejWw
      lvl256_rejWA
      lvl253_rejWx
      lvl258_rejWC
      lvl251_rejWv
      lvl254_rejWy

-- RHS size: {terms: 32, types: 49, coercions: 0, joins: 0/2}
Data.Data.$fData[]_$s$cgmapM1 [Occ=LoopBreaker]
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> [Int] -> m [Int]
[GblId, Arity=1, Str=<L,U(A,C(C1(U)),A,C(U),A)>, Unf=OtherCon []]
Data.Data.$fData[]_$s$cgmapM1
  = \ (@ (m_ae5z3 :: * -> *)) ($dMonad_ae5z5 :: Monad m_ae5z3) ->
      let {
        lvl270_se9W9 :: m_ae5z3 [Int]
        [LclId]
        lvl270_se9W9
          = return @ m_ae5z3 $dMonad_ae5z5 @ [Int] (GHC.Types.[] @ Int) } in
      \ (ds_de7Iw :: forall d. Data d => d -> m_ae5z3 d)
        (ds1_de7Ix :: [Int]) ->
        case ds1_de7Ix of {
          [] -> lvl270_se9W9;
          : x_ae1Ul xs_ae1Um ->
            let {
              lvl271_se9Wa :: m_ae5z3 [Int]
              [LclId]
              lvl271_se9Wa
                = ds_de7Iw @ [Int] Data.Data.$fData[]_$s$fData[]1 xs_ae1Um } in
            >>=
              @ m_ae5z3
              $dMonad_ae5z5
              @ Int
              @ [Int]
              (ds_de7Iw @ Int Data.Data.$fDataInt x_ae1Ul)
              (\ (x'_ae1Un :: Int) ->
                 >>=
                   @ m_ae5z3
                   $dMonad_ae5z5
                   @ [Int]
                   @ [Int]
                   lvl271_se9Wa
                   (\ (xs'_ae1Uo :: [Int]) ->
                      return
                        @ m_ae5z3
                        $dMonad_ae5z5
                        @ [Int]
                        (GHC.Types.: @ Int x'_ae1Un xs'_ae1Uo)))
        }

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
Data.Data.$fData[]_$s$cgmapT1 [Occ=LoopBreaker]
  :: (forall b. Data b => b -> b) -> [Int] -> [Int]
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []]
Data.Data.$fData[]_$s$cgmapT1
  = \ (ds_de7I2 :: forall b. Data b => b -> b)
      (ds1_de7I3 :: [Int]) ->
      case ds1_de7I3 of {
        [] -> GHC.Types.[] @ Int;
        : x_ae1Uf xs_ae1Ug ->
          GHC.Types.:
            @ Int
            (ds_de7I2 @ Int Data.Data.$fDataInt x_ae1Uf)
            (ds_de7I2 @ [Int] Data.Data.$fData[]_$s$fData[]1 xs_ae1Ug)
      }

-- RHS size: {terms: 44, types: 61, coercions: 0, joins: 0/0}
Data.Data.$fData[]_$s$cgmapQi1 [Occ=LoopBreaker]
  :: forall u. Int -> (forall d. Data d => d -> u) -> [Int] -> u
[GblId, Arity=3, Str=<L,U(U)><L,C(C1(U))><S,1*U>, Unf=OtherCon []]
Data.Data.$fData[]_$s$cgmapQi1
  = \ (@ u_ae5yP)
      (ds_de7Iu :: Int)
      (ds1_de7Iv :: forall d. Data d => d -> u_ae5yP)
      (x_ae1T7 :: [Int]) ->
      case Data.Data.$fData[]_$s$cgfoldl1
             @ (Qi u_ae5yP)
             (\ (@ d_ae2U4)
                (@ b_ae2U5)
                ($dData_ae2U7 :: Data d_ae2U4)
                (ds2_de7nG [OS=OneShot] :: Qi u_ae5yP (d_ae2U4 -> b_ae2U5))
                (a_ae1Tg [OS=OneShot] :: d_ae2U4) ->
                case ds2_de7nG of { Qi i'_ae1Te q_ae1Tf ->
                Data.Data.Qi
                  @ *
                  @ u_ae5yP
                  @ b_ae2U5
                  (case i'_ae1Te of { I# x1_i7MX1 -> GHC.Types.I# (+# x1_i7MX1 1#) })
                  (case ds_de7Iu of { I# x1_a22G ->
                   case i'_ae1Te of { I# y_a22K ->
                   case ==# x1_a22G y_a22K of {
                     __DEFAULT -> q_ae1Tf;
                     1# ->
                       GHC.Base.Just @ u_ae5yP (ds1_de7Iv @ d_ae2U4 $dData_ae2U7 a_ae1Tg)
                   }
                   }
                   })
                })
             (lvl54_rejNF @ u_ae5yP)
             x_ae1T7
      of
      { Qi ds2_de7nD q_ae1Th ->
      fromJust @ u_ae5yP q_ae1Th
      }

-- RHS size: {terms: 22, types: 36, coercions: 47, joins: 0/0}
Data.Data.$fData[]_$s$cgmapQr1 [Occ=LoopBreaker]
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> [Int] -> r
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,U><L,C(C1(U))><S,1*U>,
 Unf=OtherCon []]
Data.Data.$fData[]_$s$cgmapQr1
  = \ (@ r_ae5yo)
      (@ r'_ae5yp)
      (ds_de7Ie :: r'_ae5yp -> r_ae5yo -> r_ae5yo)
      (ds1_de7If :: r_ae5yo)
      (ds2_de7Ig :: forall d. Data d => d -> r'_ae5yp)
      (x0_ae1SX :: [Int]) ->
      ((Data.Data.$fData[]_$s$cgfoldl1
          @ (Qr r_ae5yo)
          ((\ (@ d_ae2Sl)
              (@ b_ae2Sm)
              ($dData_ae2So :: Data d_ae2Sl)
              (ds3_de7nc [OS=OneShot] :: Qr r_ae5yo (d_ae2Sl -> b_ae2Sm))
              (x_ae1T2 [OS=OneShot] :: d_ae2Sl)
              (r1_ae1T3 :: r_ae5yo) ->
              (ds3_de7nc
               `cast` (Data.Data.N:Qr[0] <*>_N <r_ae5yo>_R <d_ae2Sl -> b_ae2Sm>_P
                       :: (Qr r_ae5yo (d_ae2Sl -> b_ae2Sm) :: *)
                          ~R# (r_ae5yo -> r_ae5yo :: *)))
                (ds_de7Ie (ds2_de7Ig @ d_ae2Sl $dData_ae2So x_ae1T2) r1_ae1T3))
           `cast` (forall (d :: <*>_N) (b :: <*>_N).
                   <Data d>_R
                   ->_R <Qr r_ae5yo (d -> b)>_R
                   ->_R <d>_R
                   ->_R Sym (Data.Data.N:Qr[0] <*>_N <r_ae5yo>_R <b>_P)
                   :: (forall d b.
                       Data d =>
                       Qr r_ae5yo (d -> b) -> d -> r_ae5yo -> r_ae5yo :: *)
                      ~R# (forall d b.
                           Data d =>
                           Qr r_ae5yo (d -> b) -> d -> Qr r_ae5yo b :: *)))
          ((lvl13_rejMm @ r_ae5yo)
           `cast` (forall (g :: <*>_N).
                   <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r_ae5yo>_R <g>_P)
                   :: (forall g. g -> r_ae5yo -> r_ae5yo :: *)
                      ~R# (forall g. g -> Qr r_ae5yo g :: *)))
          x0_ae1SX)
       `cast` (Data.Data.N:Qr[0] <*>_N <r_ae5yo>_R <[Int]>_P
               :: (Qr r_ae5yo [Int] :: *) ~R# (r_ae5yo -> r_ae5yo :: *)))
        ds1_de7If

-- RHS size: {terms: 17, types: 22, coercions: 0, joins: 0/0}
Data.Data.$fData[]_$s$cgmapQ1 [Occ=LoopBreaker]
  :: forall u. (forall d. Data d => d -> u) -> [Int] -> [u]
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []]
Data.Data.$fData[]_$s$cgmapQ1
  = \ (@ u_ae5yF)
      (ds_de7Ih :: forall d. Data d => d -> u_ae5yF)
      (ds1_de7Ii :: [Int]) ->
      case ds1_de7Ii of {
        [] -> GHC.Types.[] @ u_ae5yF;
        : x_ae1Ui xs_ae1Uj ->
          GHC.Types.:
            @ u_ae5yF
            (ds_de7Ih @ Int Data.Data.$fDataInt x_ae1Ui)
            (GHC.Types.:
               @ u_ae5yF
               (ds_de7Ih @ [Int] Data.Data.$fData[]_$s$fData[]1 xs_ae1Uj)
               (GHC.Types.[] @ u_ae5yF))
      }

-- RHS size: {terms: 18, types: 46, coercions: 0, joins: 0/0}
Data.Data.$fData[]_$s$cgfoldl1 [Occ=LoopBreaker]
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> [Int] -> c [Int]
[GblId,
 Arity=3,
 Str=<L,C(C1(C1(U)))><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []]
Data.Data.$fData[]_$s$cgfoldl1
  = \ (@ (c_ae5wt :: * -> *))
      (ds_de7Hr
         :: forall d b. Data d => c_ae5wt (d -> b) -> d -> c_ae5wt b)
      (z_ae1U5 :: forall g. g -> c_ae5wt g)
      (ds1_de7Hs :: [Int]) ->
      case ds1_de7Hs of {
        [] -> z_ae1U5 @ [Int] (GHC.Types.[] @ Int);
        : x_ae1U8 xs_ae1U9 ->
          ds_de7Hr
            @ [Int]
            @ [Int]
            Data.Data.$fData[]_$s$fData[]1
            (ds_de7Hr
               @ Int
               @ ([Int] -> [Int])
               Data.Data.$fDataInt
               (z_ae1U5 @ (Int -> [Int] -> [Int]) (GHC.Types.: @ Int))
               x_ae1U8)
            xs_ae1U9
      }

-- RHS size: {terms: 21, types: 37, coercions: 41, joins: 0/0}
Data.Data.$fData[]3 [Occ=LoopBreaker]
  :: forall r r'.
     (r -> r' -> r)
     -> r -> (forall d. Data d => d -> r') -> [Int] -> Const r [Int]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,1*U><L,C(C1(U))><S,1*U>,
 Unf=OtherCon []]
Data.Data.$fData[]3
  = \ (@ r_Xe6AT)
      (@ r'_Xe6AV)
      (ds_Xe8KZ :: r_Xe6AT -> r'_Xe6AV -> r_Xe6AT)
      (ds1_Xe8L1 :: r_Xe6AT)
      (ds2_Xe8L3 :: forall d. Data d => d -> r'_Xe6AV)
      (eta_X12S :: [Int]) ->
      Data.Data.$fData[]_$s$cgfoldl1
        @ (Const r_Xe6AT)
        ((\ (@ d_ae2R3)
            (@ b_ae2R4)
            ($dData_ae2R6 :: Data d_ae2R3)
            (c_ae1SS [OS=OneShot] :: Const r_Xe6AT (d_ae2R3 -> b_ae2R4))
            (x_ae1ST [OS=OneShot] :: d_ae2R3) ->
            ds_Xe8KZ
              (c_ae1SS
               `cast` (Data.Functor.Const.N:Const[0]
                           <*>_N <r_Xe6AT>_R <d_ae2R3 -> b_ae2R4>_P
                       :: (Const r_Xe6AT (d_ae2R3 -> b_ae2R4) :: *) ~R# (r_Xe6AT :: *)))
              (ds2_Xe8L3 @ d_ae2R3 $dData_ae2R6 x_ae1ST))
         `cast` (forall (d :: <*>_N) (b :: <*>_N).
                 <Data d>_R
                 ->_R <Const r_Xe6AT (d -> b)>_R
                 ->_R <d>_R
                 ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r_Xe6AT>_R <b>_P)
                 :: (forall d b.
                     Data d =>
                     Const r_Xe6AT (d -> b) -> d -> r_Xe6AT :: *)
                    ~R# (forall d b.
                         Data d =>
                         Const r_Xe6AT (d -> b) -> d -> Const r_Xe6AT b :: *)))
        ((\ (@ g_ae2RK) _ [Occ=Dead, OS=OneShot] -> ds1_Xe8L1)
         `cast` (forall (g :: <*>_N).
                 <g>_R
                 ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r_Xe6AT>_R <g>_P)
                 :: (forall g. g -> r_Xe6AT :: *)
                    ~R# (forall g. g -> Const r_Xe6AT g :: *)))
        eta_X12S

-- RHS size: {terms: 32, types: 50, coercions: 0, joins: 0/0}
Data.Data.$w$s$cgunfold1 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> ConstrRep -> DataType -> c [Int]
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,1*C1(U)><S,1*U><L,1*U(1*U,A)>,
 Unf=OtherCon []]
Data.Data.$w$s$cgunfold1
  = \ (@ (c_segDe :: * -> *))
      (w_segDf :: forall b r. Data b => c_segDe (b -> r) -> c_segDe r)
      (w1_segDg :: forall r. r -> c_segDe r)
      (ww_segDk :: ConstrRep)
      (ww1_segDo :: DataType) ->
      case ww_segDk of {
        __DEFAULT ->
          case ww1_segDo of { DataType ww3_sefV0 ww4_sefV1 ->
          case Data.Data.$wlvl ww3_sefV0 of wild1_00 { }
          };
        AlgConstr idx_ae1Ws ->
          case idx_ae1Ws of { I# ds_de7HF ->
          case ds_de7HF of {
            __DEFAULT -> lvl241_rejWl @ c_segDe;
            1# -> w1_segDg @ [Int] (GHC.Types.[] @ Int);
            2# ->
              w_segDf
                @ [Int]
                @ [Int]
                Data.Data.$fData[]_$s$fData[]1
                (w_segDf
                   @ Int
                   @ ([Int] -> [Int])
                   Data.Data.$fDataInt
                   (w1_segDg @ (Int -> [Int] -> [Int]) (GHC.Types.: @ Int)))
          }
          }
      }

-- RHS size: {terms: 67, types: 112, coercions: 37, joins: 0/3}
Data.Data.$fData[]_$s$cgmapMp1 [Occ=LoopBreaker]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> [Int] -> m [Int]
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U>,
 Unf=OtherCon []]
Data.Data.$fData[]_$s$cgmapMp1
  = \ (@ (m_ae5zu :: * -> *))
      ($dMonadPlus_ae5zw :: MonadPlus m_ae5zu)
      (ds_de7IP :: forall d. Data d => d -> m_ae5zu d)
      (eta_XRX :: [Int]) ->
      let {
        lvl270_se9W4 :: m_ae5zu [Int]
        [LclId]
        lvl270_se9W4 = mzero @ m_ae5zu $dMonadPlus_ae5zw @ [Int] } in
      let {
        $dMonad_se9nL [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae5zu
        [LclId]
        $dMonad_se9nL
          = GHC.Base.$p2MonadPlus @ m_ae5zu $dMonadPlus_ae5zw } in
      >>=
        @ m_ae5zu
        $dMonad_se9nL
        @ ([Int], Bool)
        @ [Int]
        ((Data.Data.$fData[]_$s$cgfoldl1
            @ (Mp m_ae5zu)
            ((\ (@ d_ae2Ws)
                (@ b_ae2Wt)
                ($dData_ae2Wv :: Data d_ae2Ws)
                (ds1_de7oC [OS=OneShot] :: Mp m_ae5zu (d_ae2Ws -> b_ae2Wt))
                (y_ae1Tz [OS=OneShot] :: d_ae2Ws) ->
                let {
                  lvl271_se9W3 :: m_ae5zu d_ae2Ws
                  [LclId]
                  lvl271_se9W3 = ds_de7IP @ d_ae2Ws $dData_ae2Wv y_ae1Tz } in
                >>=
                  @ m_ae5zu
                  $dMonad_se9nL
                  @ (d_ae2Ws -> b_ae2Wt, Bool)
                  @ (b_ae2Wt, Bool)
                  (ds1_de7oC
                   `cast` (Data.Data.N:Mp[0] <m_ae5zu>_R <d_ae2Ws -> b_ae2Wt>_N
                           :: (Mp m_ae5zu (d_ae2Ws -> b_ae2Wt) :: *)
                              ~R# (m_ae5zu (d_ae2Ws -> b_ae2Wt, Bool) :: *)))
                  (\ (ds2_de7oD :: (d_ae2Ws -> b_ae2Wt, Bool)) ->
                     case ds2_de7oD of { (h_ae1TA, b1_ae1TB) ->
                     mplus
                       @ m_ae5zu
                       $dMonadPlus_ae5zw
                       @ (b_ae2Wt, Bool)
                       (>>=
                          @ m_ae5zu
                          $dMonad_se9nL
                          @ d_ae2Ws
                          @ (b_ae2Wt, Bool)
                          lvl271_se9W3
                          (\ (y'_ae1TC :: d_ae2Ws) ->
                             return
                               @ m_ae5zu
                               $dMonad_se9nL
                               @ (b_ae2Wt, Bool)
                               (h_ae1TA y'_ae1TC, GHC.Types.True)))
                       (return
                          @ m_ae5zu
                          $dMonad_se9nL
                          @ (b_ae2Wt, Bool)
                          (h_ae1TA y_ae1Tz, b1_ae1TB))
                     }))
             `cast` (forall (d :: <*>_N) (b :: <*>_N).
                     <Data d>_R
                     ->_R <Mp m_ae5zu (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Mp[0] <m_ae5zu>_R <b>_N)
                     :: (forall d b.
                         Data d =>
                         Mp m_ae5zu (d -> b) -> d -> m_ae5zu (b, Bool) :: *)
                        ~R# (forall d b.
                             Data d =>
                             Mp m_ae5zu (d -> b) -> d -> Mp m_ae5zu b :: *)))
            ((\ (@ g_ae2Xq) (g1_ae1Tx [OS=OneShot] :: g_ae2Xq) ->
                return
                  @ m_ae5zu
                  $dMonad_se9nL
                  @ (g_ae2Xq, Bool)
                  (g1_ae1Tx, GHC.Types.False))
             `cast` (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Mp[0] <m_ae5zu>_R <g>_N)
                     :: (forall g. g -> m_ae5zu (g, Bool) :: *)
                        ~R# (forall g. g -> Mp m_ae5zu g :: *)))
            eta_XRX)
         `cast` (Data.Data.N:Mp[0] <m_ae5zu>_R <[Int]>_N
                 :: (Mp m_ae5zu [Int] :: *) ~R# (m_ae5zu ([Int], Bool) :: *)))
        (\ (ds1_de7oa :: ([Int], Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9W4;
             True -> return @ m_ae5zu $dMonad_se9nL @ [Int] x'_ae1TD
           }
           })

-- RHS size: {terms: 77, types: 119, coercions: 37, joins: 0/3}
Data.Data.$fData[]_$s$cgmapMo1 [Occ=LoopBreaker]
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> [Int] -> m [Int]
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U>,
 Unf=OtherCon []]
Data.Data.$fData[]_$s$cgmapMo1
  = \ (@ (m_ae5zK :: * -> *))
      ($dMonadPlus_ae5zM :: MonadPlus m_ae5zK)
      (ds_de7IQ :: forall d. Data d => d -> m_ae5zK d)
      (eta_XRY :: [Int]) ->
      let {
        lvl270_se9W0 :: m_ae5zK [Int]
        [LclId]
        lvl270_se9W0 = mzero @ m_ae5zK $dMonadPlus_ae5zM @ [Int] } in
      let {
        $dMonad_se9nD [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae5zK
        [LclId]
        $dMonad_se9nD
          = GHC.Base.$p2MonadPlus @ m_ae5zK $dMonadPlus_ae5zM } in
      >>=
        @ m_ae5zK
        $dMonad_se9nD
        @ ([Int], Bool)
        @ [Int]
        ((Data.Data.$fData[]_$s$cgfoldl1
            @ (Mp m_ae5zK)
            ((\ (@ d_ae2Ya)
                (@ b_ae2Yb)
                ($dData_ae2Yd :: Data d_ae2Ya)
                (ds1_de7pC [OS=OneShot] :: Mp m_ae5zK (d_ae2Ya -> b_ae2Yb))
                (y_ae1TO [OS=OneShot] :: d_ae2Ya) ->
                let {
                  lvl271_se9VZ :: m_ae5zK d_ae2Ya
                  [LclId]
                  lvl271_se9VZ = ds_de7IQ @ d_ae2Ya $dData_ae2Yd y_ae1TO } in
                >>=
                  @ m_ae5zK
                  $dMonad_se9nD
                  @ (d_ae2Ya -> b_ae2Yb, Bool)
                  @ (b_ae2Yb, Bool)
                  (ds1_de7pC
                   `cast` (Data.Data.N:Mp[0] <m_ae5zK>_R <d_ae2Ya -> b_ae2Yb>_N
                           :: (Mp m_ae5zK (d_ae2Ya -> b_ae2Yb) :: *)
                              ~R# (m_ae5zK (d_ae2Ya -> b_ae2Yb, Bool) :: *)))
                  (\ (ds2_de7pD :: (d_ae2Ya -> b_ae2Yb, Bool)) ->
                     case ds2_de7pD of { (h_ae1TP, b1_ae1TQ) ->
                     case b1_ae1TQ of {
                       False ->
                         mplus
                           @ m_ae5zK
                           $dMonadPlus_ae5zM
                           @ (b_ae2Yb, Bool)
                           (>>=
                              @ m_ae5zK
                              $dMonad_se9nD
                              @ d_ae2Ya
                              @ (b_ae2Yb, Bool)
                              lvl271_se9VZ
                              (\ (y'_ae1TR :: d_ae2Ya) ->
                                 return
                                   @ m_ae5zK
                                   $dMonad_se9nD
                                   @ (b_ae2Yb, Bool)
                                   (h_ae1TP y'_ae1TR, GHC.Types.True)))
                           (return
                              @ m_ae5zK
                              $dMonad_se9nD
                              @ (b_ae2Yb, Bool)
                              (h_ae1TP y_ae1TO, GHC.Types.False));
                       True ->
                         return
                           @ m_ae5zK
                           $dMonad_se9nD
                           @ (b_ae2Yb, Bool)
                           (h_ae1TP y_ae1TO, GHC.Types.True)
                     }
                     }))
             `cast` (forall (d :: <*>_N) (b :: <*>_N).
                     <Data d>_R
                     ->_R <Mp m_ae5zK (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Mp[0] <m_ae5zK>_R <b>_N)
                     :: (forall d b.
                         Data d =>
                         Mp m_ae5zK (d -> b) -> d -> m_ae5zK (b, Bool) :: *)
                        ~R# (forall d b.
                             Data d =>
                             Mp m_ae5zK (d -> b) -> d -> Mp m_ae5zK b :: *)))
            ((\ (@ g_ae2Zd) (g1_ae1TM [OS=OneShot] :: g_ae2Zd) ->
                return
                  @ m_ae5zK
                  $dMonad_se9nD
                  @ (g_ae2Zd, Bool)
                  (g1_ae1TM, GHC.Types.False))
             `cast` (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Mp[0] <m_ae5zK>_R <g>_N)
                     :: (forall g. g -> m_ae5zK (g, Bool) :: *)
                        ~R# (forall g. g -> Mp m_ae5zK g :: *)))
            eta_XRY)
         `cast` (Data.Data.N:Mp[0] <m_ae5zK>_R <[Int]>_N
                 :: (Mp m_ae5zK [Int] :: *) ~R# (m_ae5zK ([Int], Bool) :: *)))
        (\ (ds1_de7pa :: ([Int], Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9W0;
             True -> return @ m_ae5zK $dMonad_se9nD @ [Int] x'_ae1TS
           }
           })

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl251_rejWv
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> [Int] -> m [Int]
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U>,
 Unf=OtherCon []]
lvl251_rejWv = Data.Data.$fData[]_$s$cgmapMp1

-- RHS size: {terms: 1, types: 0, coercions: 28, joins: 0/0}
Data.Data.$fData[]5 [Occ=LoopBreaker!]
  :: forall r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> [Int] -> r
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,1*U><L,C(C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Data.$fData[]3
               `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                       <r -> r' -> r>_R
                       ->_R <r>_R
                       ->_R <forall d. Data d => d -> r'>_R
                       ->_R <[Int]>_R
                       ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <[Int]>_P
                       :: (forall r r'.
                           (r -> r' -> r)
                           -> r
                           -> (forall d. Data d => d -> r')
                           -> [Int]
                           -> Const r [Int] :: *)
                          ~R# (forall r r'.
                               (r -> r' -> r)
                               -> r -> (forall d. Data d => d -> r') -> [Int] -> r :: *))}]
Data.Data.$fData[]5
  = Data.Data.$fData[]3
    `cast` (forall (r :: <*>_N) (r' :: <*>_N).
            <r -> r' -> r>_R
            ->_R <r>_R
            ->_R <forall d. Data d => d -> r'>_R
            ->_R <[Int]>_R
            ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <[Int]>_P
            :: (forall r r'.
                (r -> r' -> r)
                -> r
                -> (forall d. Data d => d -> r')
                -> [Int]
                -> Const r [Int] :: *)
               ~R# (forall r r'.
                    (r -> r' -> r)
                    -> r -> (forall d. Data d => d -> r') -> [Int] -> r :: *))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl252_rejWw
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> [Int] -> r
[GblId,
 Arity=4,
 Str=<L,C(C1(U))><L,U><L,C(C1(U))><S,1*U>,
 Unf=OtherCon []]
lvl252_rejWw = Data.Data.$fData[]_$s$cgmapQr1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl253_rejWx
  :: forall u. Int -> (forall d. Data d => d -> u) -> [Int] -> u
[GblId, Arity=3, Str=<L,U(U)><L,C(C1(U))><S,1*U>, Unf=OtherCon []]
lvl253_rejWx = Data.Data.$fData[]_$s$cgmapQi1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl254_rejWy
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> [Int] -> m [Int]
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U>,
 Unf=OtherCon []]
lvl254_rejWy = Data.Data.$fData[]_$s$cgmapMo1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl255_rejWz
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> [Int] -> c [Int]
[GblId,
 Arity=3,
 Str=<L,C(C1(C1(U)))><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []]
lvl255_rejWz = Data.Data.$fData[]_$s$cgfoldl1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl256_rejWA
  :: forall u. (forall d. Data d => d -> u) -> [Int] -> [u]
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []]
lvl256_rejWA = Data.Data.$fData[]_$s$cgmapQ1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl257_rejWB :: (forall b. Data b => b -> b) -> [Int] -> [Int]
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []]
lvl257_rejWB = Data.Data.$fData[]_$s$cgmapT1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl258_rejWC
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> [Int] -> m [Int]
[GblId, Arity=1, Str=<L,U(A,C(C1(U)),A,C(U),A)>, Unf=OtherCon []]
lvl258_rejWC = Data.Data.$fData[]_$s$cgmapM1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl259_rejWD
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c [Int]
[GblId,
 Arity=3,
 Str=<L,C(C1(U))><L,1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=OtherCon []]
lvl259_rejWD = Data.Data.$fData[]_$s$cgunfold1
end Rec }

Rec {
-- RHS size: {terms: 30, types: 21, coercions: 6, joins: 0/0}
Data.Data.$fData[] [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data a => Data [a]
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_ae1U4) (v_XRK :: Data a_ae1U4) ->
       Data.Data.C:Data TYPE: [a_ae1U4]
                        (Data.Data.$fData[]6 @ a_ae1U4 v_XRK)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <[a_ae1U4]>_N
                                :: (Data.Typeable.Internal.TypeRep [a_ae1U4] :: *)
                                   ~R# (Typeable [a_ae1U4] :: Constraint))
                        Data.Data.$fData[]_$cgfoldl @ a_ae1U4 v_XRK
                        Data.Data.$fData[]_$cgunfold @ a_ae1U4 v_XRK
                        \ (ds_de7HK [Occ=Once!] :: [a_ae1U4]) ->
                          case ds_de7HK of {
                            [] -> nilConstr;
                            : _ [Occ=Dead] _ [Occ=Dead] -> consConstr
                          }
                        \ _ [Occ=Dead] -> listDataType
                        Data.Data.$fData[]_$cdataCast1 @ a_ae1U4 v_XRK
                        \ (@ (t_ae5xB :: * -> * -> *))
                          (@ (c_ae5xC :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae5xC [a_ae1U4])
                        Data.Data.$fData[]_$cgmapT @ a_ae1U4 v_XRK
                        Data.Data.$fData[]_$cgmapQl @ a_ae1U4 v_XRK
                        Data.Data.$fData[]_$cgmapQr @ a_ae1U4 v_XRK
                        Data.Data.$fData[]_$cgmapQ @ a_ae1U4 v_XRK
                        Data.Data.$fData[]_$cgmapQi @ a_ae1U4 v_XRK
                        Data.Data.$fData[]_$cgmapM @ a_ae1U4 v_XRK
                        Data.Data.$fData[]_$cgmapMp @ a_ae1U4 v_XRK
                        Data.Data.$fData[]_$cgmapMo @ a_ae1U4 v_XRK]
Data.Data.$fData[]
  = \ (@ a_Xe6j2) ($dData_Xe6j4 :: Data a_Xe6j2) ->
      Data.Data.C:Data
        @ [a_Xe6j2]
        ((Data.Data.$fData[]6 @ a_Xe6j2 $dData_Xe6j4)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <[a_Xe6j2]>_N
                 :: (Data.Typeable.Internal.TypeRep [a_Xe6j2] :: *)
                    ~R# (Typeable [a_Xe6j2] :: Constraint)))
        (Data.Data.$fData[]_$cgfoldl @ a_Xe6j2 $dData_Xe6j4)
        (Data.Data.$fData[]_$cgunfold @ a_Xe6j2 $dData_Xe6j4)
        (lvl229_rejW9 @ a_Xe6j2)
        (lvl228_rejW8 @ a_Xe6j2)
        (Data.Data.$fData[]_$cdataCast1 @ a_Xe6j2 $dData_Xe6j4)
        (lvl227_rejW7 @ a_Xe6j2)
        (Data.Data.$fData[]_$cgmapT @ a_Xe6j2 $dData_Xe6j4)
        (Data.Data.$fData[]_$cgmapQl @ a_Xe6j2 $dData_Xe6j4)
        (Data.Data.$fData[]_$cgmapQr @ a_Xe6j2 $dData_Xe6j4)
        (Data.Data.$fData[]_$cgmapQ @ a_Xe6j2 $dData_Xe6j4)
        (Data.Data.$fData[]_$cgmapQi @ a_Xe6j2 $dData_Xe6j4)
        (Data.Data.$fData[]_$cgmapM @ a_Xe6j2 $dData_Xe6j4)
        (Data.Data.$fData[]_$cgmapMp @ a_Xe6j2 $dData_Xe6j4)
        (Data.Data.$fData[]_$cgmapMo @ a_Xe6j2 $dData_Xe6j4)

-- RHS size: {terms: 37, types: 57, coercions: 0, joins: 0/3}
Data.Data.$fData[]_$cgmapM [Occ=LoopBreaker]
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> [a] -> m [a]
[GblId,
 Arity=2,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,C(U),A)>,
 Unf=OtherCon []]
Data.Data.$fData[]_$cgmapM
  = \ (@ a_Xe6jb)
      ($dData_Xe6jd :: Data a_Xe6jb)
      (@ (m_ae5z3 :: * -> *))
      ($dMonad_ae5z5 :: Monad m_ae5z3) ->
      let {
        lvl270_se9Xn :: m_ae5z3 [a_Xe6jb]
        [LclId]
        lvl270_se9Xn
          = return
              @ m_ae5z3 $dMonad_ae5z5 @ [a_Xe6jb] (GHC.Types.[] @ a_Xe6jb) } in
      let {
        $dData1_se9nl :: Data [a_Xe6jb]
        [LclId]
        $dData1_se9nl = Data.Data.$fData[] @ a_Xe6jb $dData_Xe6jd } in
      \ (ds_de7Iw :: forall d. Data d => d -> m_ae5z3 d)
        (ds1_de7Ix :: [a_Xe6jb]) ->
        case ds1_de7Ix of {
          [] -> lvl270_se9Xn;
          : x_ae1Ul xs_ae1Um ->
            let {
              lvl271_se9Xo :: m_ae5z3 [a_Xe6jb]
              [LclId]
              lvl271_se9Xo = ds_de7Iw @ [a_Xe6jb] $dData1_se9nl xs_ae1Um } in
            >>=
              @ m_ae5z3
              $dMonad_ae5z5
              @ a_Xe6jb
              @ [a_Xe6jb]
              (ds_de7Iw @ a_Xe6jb $dData_Xe6jd x_ae1Ul)
              (\ (x'_ae1Un :: a_Xe6jb) ->
                 >>=
                   @ m_ae5z3
                   $dMonad_ae5z5
                   @ [a_Xe6jb]
                   @ [a_Xe6jb]
                   lvl271_se9Xo
                   (\ (xs'_ae1Uo :: [a_Xe6jb]) ->
                      return
                        @ m_ae5z3
                        $dMonad_ae5z5
                        @ [a_Xe6jb]
                        (GHC.Types.: @ a_Xe6jb x'_ae1Un xs'_ae1Uo)))
        }

-- RHS size: {terms: 19, types: 26, coercions: 0, joins: 0/1}
Data.Data.$fData[]_$cgmapT [Occ=LoopBreaker]
  :: forall a. Data a => (forall b. Data b => b -> b) -> [a] -> [a]
[GblId,
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=OtherCon []]
Data.Data.$fData[]_$cgmapT
  = \ (@ a_Xe6j6) ($dData_Xe6j8 :: Data a_Xe6j6) ->
      let {
        $dData1_se9nj :: Data [a_Xe6j6]
        [LclId]
        $dData1_se9nj = Data.Data.$fData[] @ a_Xe6j6 $dData_Xe6j8 } in
      \ (ds_de7I2 :: forall b. Data b => b -> b)
        (ds1_de7I3 :: [a_Xe6j6]) ->
        case ds1_de7I3 of {
          [] -> GHC.Types.[] @ a_Xe6j6;
          : x_ae1Uf xs_ae1Ug ->
            GHC.Types.:
              @ a_Xe6j6
              (ds_de7I2 @ a_Xe6j6 $dData_Xe6j8 x_ae1Uf)
              (ds_de7I2 @ [a_Xe6j6] $dData1_se9nj xs_ae1Ug)
        }

-- RHS size: {terms: 26, types: 50, coercions: 50, joins: 0/1}
Data.Data.$fData[]_$cgmapQl [Occ=LoopBreaker]
  :: forall a.
     Data a =>
     forall r r'.
     (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> [a] -> r
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
 Unf=OtherCon []]
Data.Data.$fData[]_$cgmapQl
  = \ (@ a_Xe6j7)
      ($dData_Xe6j9 :: Data a_Xe6j7)
      (@ r_Xe6BC)
      (@ r'_Xe6BE)
      (ds_Xe8LI :: r_Xe6BC -> r'_Xe6BE -> r_Xe6BC)
      (ds1_Xe8LK :: r_Xe6BC)
      (ds2_Xe8LM :: forall d. Data d => d -> r'_Xe6BE) ->
      let {
        g_se9nh [Dmd=<L,C(U)>] :: [a_Xe6j7] -> Const r_Xe6BC [a_Xe6j7]
        [LclId]
        g_se9nh
          = Data.Data.$fData[]_$cgfoldl
              @ a_Xe6j7
              $dData_Xe6j9
              @ (Const r_Xe6BC)
              ((\ (@ d_ae2R3)
                  (@ b_ae2R4)
                  ($dData1_ae2R6 :: Data d_ae2R3)
                  (c_ae1SS :: Const r_Xe6BC (d_ae2R3 -> b_ae2R4))
                  (x_ae1ST :: d_ae2R3) ->
                  ds_Xe8LI
                    (c_ae1SS
                     `cast` (Data.Functor.Const.N:Const[0]
                                 <*>_N <r_Xe6BC>_R <d_ae2R3 -> b_ae2R4>_P
                             :: (Const r_Xe6BC (d_ae2R3 -> b_ae2R4) :: *) ~R# (r_Xe6BC :: *)))
                    (ds2_Xe8LM @ d_ae2R3 $dData1_ae2R6 x_ae1ST))
               `cast` (forall (d :: <*>_N) (b :: <*>_N).
                       <Data d>_R
                       ->_R <Const r_Xe6BC (d -> b)>_R
                       ->_R <d>_R
                       ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r_Xe6BC>_R <b>_P)
                       :: (forall d b.
                           Data d =>
                           Const r_Xe6BC (d -> b) -> d -> r_Xe6BC :: *)
                          ~R# (forall d b.
                               Data d =>
                               Const r_Xe6BC (d -> b) -> d -> Const r_Xe6BC b :: *)))
              ((\ (@ g1_ae2RK) _ [Occ=Dead] -> ds1_Xe8LK)
               `cast` (forall (g1 :: <*>_N).
                       <g1>_R
                       ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <r_Xe6BC>_R <g1>_P)
                       :: (forall g1. g1 -> r_Xe6BC :: *)
                          ~R# (forall g1. g1 -> Const r_Xe6BC g1 :: *))) } in
      (\ (x_i7Rxi :: [a_Xe6j7]) -> g_se9nh x_i7Rxi)
      `cast` (<[a_Xe6j7]>_R
              ->_R Data.Functor.Const.N:Const[0] <*>_N <r_Xe6BC>_R <[a_Xe6j7]>_P
              :: ([a_Xe6j7] -> Const r_Xe6BC [a_Xe6j7] :: *)
                 ~R# ([a_Xe6j7] -> r_Xe6BC :: *))

-- RHS size: {terms: 25, types: 41, coercions: 47, joins: 0/0}
Data.Data.$fData[]_$cgmapQr [Occ=LoopBreaker]
  :: forall a.
     Data a =>
     forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> [a] -> r
[GblId,
 Arity=5,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))><L,U>,
 Unf=OtherCon []]
Data.Data.$fData[]_$cgmapQr
  = \ (@ a_Xe6j8)
      ($dData_Xe6ja :: Data a_Xe6j8)
      (@ r_ae5yo)
      (@ r'_ae5yp)
      (ds_de7Ie :: r'_ae5yp -> r_ae5yo -> r_ae5yo)
      (ds1_de7If :: r_ae5yo)
      (ds2_de7Ig :: forall d. Data d => d -> r'_ae5yp)
      (x0_ae1SX :: [a_Xe6j8]) ->
      ((Data.Data.$fData[]_$cgfoldl
          @ a_Xe6j8
          $dData_Xe6ja
          @ (Qr r_ae5yo)
          ((\ (@ d_ae2Sl)
              (@ b_ae2Sm)
              ($dData1_ae2So :: Data d_ae2Sl)
              (ds3_de7nc :: Qr r_ae5yo (d_ae2Sl -> b_ae2Sm))
              (x_ae1T2 :: d_ae2Sl)
              (r1_ae1T3 :: r_ae5yo) ->
              (ds3_de7nc
               `cast` (Data.Data.N:Qr[0] <*>_N <r_ae5yo>_R <d_ae2Sl -> b_ae2Sm>_P
                       :: (Qr r_ae5yo (d_ae2Sl -> b_ae2Sm) :: *)
                          ~R# (r_ae5yo -> r_ae5yo :: *)))
                (ds_de7Ie (ds2_de7Ig @ d_ae2Sl $dData1_ae2So x_ae1T2) r1_ae1T3))
           `cast` (forall (d :: <*>_N) (b :: <*>_N).
                   <Data d>_R
                   ->_R <Qr r_ae5yo (d -> b)>_R
                   ->_R <d>_R
                   ->_R Sym (Data.Data.N:Qr[0] <*>_N <r_ae5yo>_R <b>_P)
                   :: (forall d b.
                       Data d =>
                       Qr r_ae5yo (d -> b) -> d -> r_ae5yo -> r_ae5yo :: *)
                      ~R# (forall d b.
                           Data d =>
                           Qr r_ae5yo (d -> b) -> d -> Qr r_ae5yo b :: *)))
          ((lvl13_rejMm @ r_ae5yo)
           `cast` (forall (g :: <*>_N).
                   <g>_R ->_R Sym (Data.Data.N:Qr[0] <*>_N <r_ae5yo>_R <g>_P)
                   :: (forall g. g -> r_ae5yo -> r_ae5yo :: *)
                      ~R# (forall g. g -> Qr r_ae5yo g :: *)))
          x0_ae1SX)
       `cast` (Data.Data.N:Qr[0] <*>_N <r_ae5yo>_R <[a_Xe6j8]>_P
               :: (Qr r_ae5yo [a_Xe6j8] :: *) ~R# (r_ae5yo -> r_ae5yo :: *)))
        ds1_de7If

-- RHS size: {terms: 22, types: 30, coercions: 0, joins: 0/1}
Data.Data.$fData[]_$cgmapQ [Occ=LoopBreaker]
  :: forall a.
     Data a =>
     forall u. (forall d. Data d => d -> u) -> [a] -> [u]
[GblId,
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=OtherCon []]
Data.Data.$fData[]_$cgmapQ
  = \ (@ a_Xe6j9) ($dData_Xe6jb :: Data a_Xe6j9) (@ u_ae5yF) ->
      let {
        $dData1_se9nd :: Data [a_Xe6j9]
        [LclId]
        $dData1_se9nd = Data.Data.$fData[] @ a_Xe6j9 $dData_Xe6jb } in
      \ (ds_de7Ih :: forall d. Data d => d -> u_ae5yF)
        (ds1_de7Ii :: [a_Xe6j9]) ->
        case ds1_de7Ii of {
          [] -> GHC.Types.[] @ u_ae5yF;
          : x_ae1Ui xs_ae1Uj ->
            GHC.Types.:
              @ u_ae5yF
              (ds_de7Ih @ a_Xe6j9 $dData_Xe6jb x_ae1Ui)
              (GHC.Types.:
                 @ u_ae5yF
                 (ds_de7Ih @ [a_Xe6j9] $dData1_se9nd xs_ae1Uj)
                 (GHC.Types.[] @ u_ae5yF))
        }

-- RHS size: {terms: 23, types: 54, coercions: 0, joins: 0/1}
Data.Data.$fData[]_$cgfoldl [Occ=LoopBreaker]
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> [a] -> c [a]
[GblId,
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=OtherCon []]
Data.Data.$fData[]_$cgfoldl
  = \ (@ a_Xe6jd)
      ($dData_Xe6jf :: Data a_Xe6jd)
      (@ (c_ae5wt :: * -> *)) ->
      let {
        $dData1_se9nf :: Data [a_Xe6jd]
        [LclId]
        $dData1_se9nf = Data.Data.$fData[] @ a_Xe6jd $dData_Xe6jf } in
      \ (ds_de7Hr
           :: forall d b. Data d => c_ae5wt (d -> b) -> d -> c_ae5wt b)
        (z_ae1U5 :: forall g. g -> c_ae5wt g)
        (ds1_de7Hs :: [a_Xe6jd]) ->
        case ds1_de7Hs of {
          [] -> z_ae1U5 @ [a_Xe6jd] (GHC.Types.[] @ a_Xe6jd);
          : x_ae1U8 xs_ae1U9 ->
            ds_de7Hr
              @ [a_Xe6jd]
              @ [a_Xe6jd]
              $dData1_se9nf
              (ds_de7Hr
                 @ a_Xe6jd
                 @ ([a_Xe6jd] -> [a_Xe6jd])
                 $dData_Xe6jf
                 (z_ae1U5
                    @ (a_Xe6jd -> [a_Xe6jd] -> [a_Xe6jd]) (GHC.Types.: @ a_Xe6jd))
                 x_ae1U8)
              xs_ae1U9
        }

-- RHS size: {terms: 47, types: 66, coercions: 0, joins: 0/0}
Data.Data.$fData[]_$cgmapQi [Occ=LoopBreaker]
  :: forall a.
     Data a =>
     forall u. Int -> (forall d. Data d => d -> u) -> [a] -> u
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U)><L,C(C1(U))><L,U>,
 Unf=OtherCon []]
Data.Data.$fData[]_$cgmapQi
  = \ (@ a_Xe6ja)
      ($dData_Xe6jc :: Data a_Xe6ja)
      (@ u_ae5yP)
      (ds_de7Iu :: Int)
      (ds1_de7Iv :: forall d. Data d => d -> u_ae5yP)
      (x_ae1T7 :: [a_Xe6ja]) ->
      case Data.Data.$fData[]_$cgfoldl
             @ a_Xe6ja
             $dData_Xe6jc
             @ (Qi u_ae5yP)
             (\ (@ d_ae2U4)
                (@ b_ae2U5)
                ($dData1_ae2U7 :: Data d_ae2U4)
                (ds2_de7nG :: Qi u_ae5yP (d_ae2U4 -> b_ae2U5))
                (a1_ae1Tg :: d_ae2U4) ->
                case ds2_de7nG of { Qi i'_ae1Te q_ae1Tf ->
                Data.Data.Qi
                  @ *
                  @ u_ae5yP
                  @ b_ae2U5
                  (case i'_ae1Te of { I# x1_i7MX1 -> GHC.Types.I# (+# x1_i7MX1 1#) })
                  (case ds_de7Iu of { I# x1_a22G ->
                   case i'_ae1Te of { I# y_a22K ->
                   case ==# x1_a22G y_a22K of {
                     __DEFAULT -> q_ae1Tf;
                     1# ->
                       GHC.Base.Just
                         @ u_ae5yP (ds1_de7Iv @ d_ae2U4 $dData1_ae2U7 a1_ae1Tg)
                   }
                   }
                   })
                })
             (lvl54_rejNF @ u_ae5yP)
             x_ae1T7
      of
      { Qi ds2_de7nD q_ae1Th ->
      fromJust @ u_ae5yP q_ae1Th
      }

-- RHS size: {terms: 39, types: 65, coercions: 0, joins: 0/1}
Data.Data.$fData[]_$cgunfold [Occ=LoopBreaker]
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c [a]
[GblId,
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=OtherCon []]
Data.Data.$fData[]_$cgunfold
  = \ (@ a_Xe6j4)
      ($dData_Xe6j6 :: Data a_Xe6j4)
      (@ (c_ae5wJ :: * -> *)) ->
      let {
        $dData1_se9nb :: Data [a_Xe6j4]
        [LclId]
        $dData1_se9nb = Data.Data.$fData[] @ a_Xe6j4 $dData_Xe6j6 } in
      \ (k_ae1Ua :: forall b r. Data b => c_ae5wJ (b -> r) -> c_ae5wJ r)
        (z_ae1Ub :: forall r. r -> c_ae5wJ r)
        (c1_ae1Uc :: Constr) ->
        case c1_ae1Uc of
        { Constr ds_de7lX ds1_de7lY ds2_de7lZ ds3_de7m0 ds4_de7m1 ->
        case ds_de7lX of {
          __DEFAULT ->
            case ds4_de7m1 of { DataType ww1_sefV0 ww2_sefV1 ->
            case Data.Data.$wlvl ww1_sefV0 of wild2_00 { }
            };
          AlgConstr idx_ae1Ws ->
            case idx_ae1Ws of { I# ds5_de7HF ->
            case ds5_de7HF of {
              __DEFAULT -> lvl226_rejW6 @ c_ae5wJ @ a_Xe6j4;
              1# -> z_ae1Ub @ [a_Xe6j4] (GHC.Types.[] @ a_Xe6j4);
              2# ->
                k_ae1Ua
                  @ [a_Xe6j4]
                  @ [a_Xe6j4]
                  $dData1_se9nb
                  (k_ae1Ua
                     @ a_Xe6j4
                     @ ([a_Xe6j4] -> [a_Xe6j4])
                     $dData_Xe6j6
                     (z_ae1Ub
                        @ (a_Xe6j4 -> [a_Xe6j4] -> [a_Xe6j4]) (GHC.Types.: @ a_Xe6j4)))
            }
            }
        }
        }

-- RHS size: {terms: 70, types: 117, coercions: 37, joins: 0/3}
Data.Data.$fData[]_$cgmapMp [Occ=LoopBreaker]
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> [a] -> m [a]
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
 Unf=OtherCon []]
Data.Data.$fData[]_$cgmapMp
  = \ (@ a_Xe6jc)
      ($dData_Xe6je :: Data a_Xe6jc)
      (@ (m_ae5zu :: * -> *))
      ($dMonadPlus_ae5zw :: MonadPlus m_ae5zu)
      (ds_de7IP :: forall d. Data d => d -> m_ae5zu d)
      (eta_XRX :: [a_Xe6jc]) ->
      let {
        lvl270_se9Xq :: m_ae5zu [a_Xe6jc]
        [LclId]
        lvl270_se9Xq = mzero @ m_ae5zu $dMonadPlus_ae5zw @ [a_Xe6jc] } in
      let {
        $dMonad_se9nn [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae5zu
        [LclId]
        $dMonad_se9nn
          = GHC.Base.$p2MonadPlus @ m_ae5zu $dMonadPlus_ae5zw } in
      >>=
        @ m_ae5zu
        $dMonad_se9nn
        @ ([a_Xe6jc], Bool)
        @ [a_Xe6jc]
        ((Data.Data.$fData[]_$cgfoldl
            @ a_Xe6jc
            $dData_Xe6je
            @ (Mp m_ae5zu)
            ((\ (@ d_ae2Ws)
                (@ b_ae2Wt)
                ($dData1_ae2Wv :: Data d_ae2Ws)
                (ds1_de7oC :: Mp m_ae5zu (d_ae2Ws -> b_ae2Wt))
                (y_ae1Tz :: d_ae2Ws) ->
                let {
                  lvl271_se9Xp :: m_ae5zu d_ae2Ws
                  [LclId]
                  lvl271_se9Xp = ds_de7IP @ d_ae2Ws $dData1_ae2Wv y_ae1Tz } in
                >>=
                  @ m_ae5zu
                  $dMonad_se9nn
                  @ (d_ae2Ws -> b_ae2Wt, Bool)
                  @ (b_ae2Wt, Bool)
                  (ds1_de7oC
                   `cast` (Data.Data.N:Mp[0] <m_ae5zu>_R <d_ae2Ws -> b_ae2Wt>_N
                           :: (Mp m_ae5zu (d_ae2Ws -> b_ae2Wt) :: *)
                              ~R# (m_ae5zu (d_ae2Ws -> b_ae2Wt, Bool) :: *)))
                  (\ (ds2_de7oD :: (d_ae2Ws -> b_ae2Wt, Bool)) ->
                     case ds2_de7oD of { (h_ae1TA, b1_ae1TB) ->
                     mplus
                       @ m_ae5zu
                       $dMonadPlus_ae5zw
                       @ (b_ae2Wt, Bool)
                       (>>=
                          @ m_ae5zu
                          $dMonad_se9nn
                          @ d_ae2Ws
                          @ (b_ae2Wt, Bool)
                          lvl271_se9Xp
                          (\ (y'_ae1TC :: d_ae2Ws) ->
                             return
                               @ m_ae5zu
                               $dMonad_se9nn
                               @ (b_ae2Wt, Bool)
                               (h_ae1TA y'_ae1TC, GHC.Types.True)))
                       (return
                          @ m_ae5zu
                          $dMonad_se9nn
                          @ (b_ae2Wt, Bool)
                          (h_ae1TA y_ae1Tz, b1_ae1TB))
                     }))
             `cast` (forall (d :: <*>_N) (b :: <*>_N).
                     <Data d>_R
                     ->_R <Mp m_ae5zu (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Mp[0] <m_ae5zu>_R <b>_N)
                     :: (forall d b.
                         Data d =>
                         Mp m_ae5zu (d -> b) -> d -> m_ae5zu (b, Bool) :: *)
                        ~R# (forall d b.
                             Data d =>
                             Mp m_ae5zu (d -> b) -> d -> Mp m_ae5zu b :: *)))
            ((\ (@ g_ae2Xq) (g1_ae1Tx :: g_ae2Xq) ->
                return
                  @ m_ae5zu
                  $dMonad_se9nn
                  @ (g_ae2Xq, Bool)
                  (g1_ae1Tx, GHC.Types.False))
             `cast` (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Mp[0] <m_ae5zu>_R <g>_N)
                     :: (forall g. g -> m_ae5zu (g, Bool) :: *)
                        ~R# (forall g. g -> Mp m_ae5zu g :: *)))
            eta_XRX)
         `cast` (Data.Data.N:Mp[0] <m_ae5zu>_R <[a_Xe6jc]>_N
                 :: (Mp m_ae5zu [a_Xe6jc] :: *)
                    ~R# (m_ae5zu ([a_Xe6jc], Bool) :: *)))
        (\ (ds1_de7oa :: ([a_Xe6jc], Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9Xq;
             True -> return @ m_ae5zu $dMonad_se9nn @ [a_Xe6jc] x'_ae1TD
           }
           })

-- RHS size: {terms: 80, types: 124, coercions: 37, joins: 0/3}
Data.Data.$fData[]_$cgmapMo [Occ=LoopBreaker]
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> [a] -> m [a]
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,U>,
 Unf=OtherCon []]
Data.Data.$fData[]_$cgmapMo
  = \ (@ a_Xe6j3)
      ($dData_Xe6j5 :: Data a_Xe6j3)
      (@ (m_ae5zK :: * -> *))
      ($dMonadPlus_ae5zM :: MonadPlus m_ae5zK)
      (ds_de7IQ :: forall d. Data d => d -> m_ae5zK d)
      (eta_XRY :: [a_Xe6j3]) ->
      let {
        lvl270_se9Xs :: m_ae5zK [a_Xe6j3]
        [LclId]
        lvl270_se9Xs = mzero @ m_ae5zK $dMonadPlus_ae5zM @ [a_Xe6j3] } in
      let {
        $dMonad_se9np [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae5zK
        [LclId]
        $dMonad_se9np
          = GHC.Base.$p2MonadPlus @ m_ae5zK $dMonadPlus_ae5zM } in
      >>=
        @ m_ae5zK
        $dMonad_se9np
        @ ([a_Xe6j3], Bool)
        @ [a_Xe6j3]
        ((Data.Data.$fData[]_$cgfoldl
            @ a_Xe6j3
            $dData_Xe6j5
            @ (Mp m_ae5zK)
            ((\ (@ d_ae2Ya)
                (@ b_ae2Yb)
                ($dData1_ae2Yd :: Data d_ae2Ya)
                (ds1_de7pC :: Mp m_ae5zK (d_ae2Ya -> b_ae2Yb))
                (y_ae1TO :: d_ae2Ya) ->
                let {
                  lvl271_se9Xr :: m_ae5zK d_ae2Ya
                  [LclId]
                  lvl271_se9Xr = ds_de7IQ @ d_ae2Ya $dData1_ae2Yd y_ae1TO } in
                >>=
                  @ m_ae5zK
                  $dMonad_se9np
                  @ (d_ae2Ya -> b_ae2Yb, Bool)
                  @ (b_ae2Yb, Bool)
                  (ds1_de7pC
                   `cast` (Data.Data.N:Mp[0] <m_ae5zK>_R <d_ae2Ya -> b_ae2Yb>_N
                           :: (Mp m_ae5zK (d_ae2Ya -> b_ae2Yb) :: *)
                              ~R# (m_ae5zK (d_ae2Ya -> b_ae2Yb, Bool) :: *)))
                  (\ (ds2_de7pD :: (d_ae2Ya -> b_ae2Yb, Bool)) ->
                     case ds2_de7pD of { (h_ae1TP, b1_ae1TQ) ->
                     case b1_ae1TQ of {
                       False ->
                         mplus
                           @ m_ae5zK
                           $dMonadPlus_ae5zM
                           @ (b_ae2Yb, Bool)
                           (>>=
                              @ m_ae5zK
                              $dMonad_se9np
                              @ d_ae2Ya
                              @ (b_ae2Yb, Bool)
                              lvl271_se9Xr
                              (\ (y'_ae1TR :: d_ae2Ya) ->
                                 return
                                   @ m_ae5zK
                                   $dMonad_se9np
                                   @ (b_ae2Yb, Bool)
                                   (h_ae1TP y'_ae1TR, GHC.Types.True)))
                           (return
                              @ m_ae5zK
                              $dMonad_se9np
                              @ (b_ae2Yb, Bool)
                              (h_ae1TP y_ae1TO, GHC.Types.False));
                       True ->
                         return
                           @ m_ae5zK
                           $dMonad_se9np
                           @ (b_ae2Yb, Bool)
                           (h_ae1TP y_ae1TO, GHC.Types.True)
                     }
                     }))
             `cast` (forall (d :: <*>_N) (b :: <*>_N).
                     <Data d>_R
                     ->_R <Mp m_ae5zK (d -> b)>_R
                     ->_R <d>_R
                     ->_R Sym (Data.Data.N:Mp[0] <m_ae5zK>_R <b>_N)
                     :: (forall d b.
                         Data d =>
                         Mp m_ae5zK (d -> b) -> d -> m_ae5zK (b, Bool) :: *)
                        ~R# (forall d b.
                             Data d =>
                             Mp m_ae5zK (d -> b) -> d -> Mp m_ae5zK b :: *)))
            ((\ (@ g_ae2Zd) (g1_ae1TM :: g_ae2Zd) ->
                return
                  @ m_ae5zK
                  $dMonad_se9np
                  @ (g_ae2Zd, Bool)
                  (g1_ae1TM, GHC.Types.False))
             `cast` (forall (g :: <*>_N).
                     <g>_R ->_R Sym (Data.Data.N:Mp[0] <m_ae5zK>_R <g>_N)
                     :: (forall g. g -> m_ae5zK (g, Bool) :: *)
                        ~R# (forall g. g -> Mp m_ae5zK g :: *)))
            eta_XRY)
         `cast` (Data.Data.N:Mp[0] <m_ae5zK>_R <[a_Xe6j3]>_N
                 :: (Mp m_ae5zK [a_Xe6j3] :: *)
                    ~R# (m_ae5zK ([a_Xe6j3], Bool) :: *)))
        (\ (ds1_de7pa :: ([a_Xe6j3], Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9Xs;
             True -> return @ m_ae5zK $dMonad_se9np @ [a_Xe6j3] x'_ae1TS
           }
           })
end Rec }

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
Data.Data.$fDataVersion1 :: Data [String]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Data.$fDataVersion1
  = Data.Data.$fData[] @ [Char] Data.Data.$fData[]_$s$fData[]

-- RHS size: {terms: 13, types: 38, coercions: 0, joins: 0/0}
Data.Data.$w$cgfoldl3 [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> [Int] -> [String] -> c Version
[GblId,
 Arity=4,
 Str=<C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [120 60 0 0] 100 0}]
Data.Data.$w$cgfoldl3
  = \ (@ (c_segEk :: * -> *))
      (w_segEl
         :: forall d b. Data d => c_segEk (d -> b) -> d -> c_segEk b)
      (w1_segEm :: forall g. g -> c_segEk g)
      (ww_segEq :: [Int])
      (ww1_segEr :: [String]) ->
      w_segEl
        @ [String]
        @ Version
        Data.Data.$fDataVersion1
        (w_segEl
           @ [Int]
           @ ([String] -> Version)
           Data.Data.$fData[]_$s$fData[]1
           (w1_segEm @ ([Int] -> [String] -> Version) Data.Version.Version)
           ww_segEq)
        ww1_segEr

-- RHS size: {terms: 12, types: 28, coercions: 0, joins: 0/0}
Data.Data.$fDataVersion_$cgfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Version -> c Version
[GblId,
 Arity=3,
 Str=<C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_segEk :: * -> *))
                 (w_segEl [Occ=Once]
                    :: forall d b. Data d => c_segEk (d -> b) -> d -> c_segEk b)
                 (w1_segEm [Occ=Once] :: forall g. g -> c_segEk g)
                 (w2_segEn [Occ=Once!] :: Version) ->
                 case w2_segEn of
                 { Version ww1_segEq [Occ=Once] ww2_segEr [Occ=Once] ->
                 Data.Data.$w$cgfoldl3
                   @ c_segEk w_segEl w1_segEm ww1_segEq ww2_segEr
                 }}]
Data.Data.$fDataVersion_$cgfoldl
  = \ (@ (c_segEk :: * -> *))
      (w_segEl
         :: forall d b. Data d => c_segEk (d -> b) -> d -> c_segEk b)
      (w1_segEm :: forall g. g -> c_segEk g)
      (w2_segEn :: Version) ->
      case w2_segEn of { Version ww1_segEq ww2_segEr ->
      Data.Data.$w$cgfoldl3
        @ c_segEk w_segEl w1_segEm ww1_segEq ww2_segEr
      }

-- RHS size: {terms: 10, types: 34, coercions: 0, joins: 0/0}
Data.Data.$fDataVersion_$cgunfold
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c Version
[GblId,
 Arity=3,
 Str=<C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_ae4a4 :: * -> *))
                 (k_Xe3bW :: forall b r. Data b => c_ae4a4 (b -> r) -> c_ae4a4 r)
                 (z_Xe3bY [Occ=Once!] :: forall r. r -> c_ae4a4 r)
                 _ [Occ=Dead] ->
                 k_Xe3bW
                   @ [String]
                   @ Version
                   Data.Data.$fDataVersion1
                   (k_Xe3bW
                      @ [Int]
                      @ ([String] -> Version)
                      Data.Data.$fData[]_$s$fData[]1
                      (z_Xe3bY @ ([Int] -> [String] -> Version) Data.Version.Version))}]
Data.Data.$fDataVersion_$cgunfold
  = \ (@ (c_ae4a4 :: * -> *))
      (k_Xe3bW :: forall b r. Data b => c_ae4a4 (b -> r) -> c_ae4a4 r)
      (z_Xe3bY :: forall r. r -> c_ae4a4 r)
      _ [Occ=Dead] ->
      k_Xe3bW
        @ [String]
        @ Version
        Data.Data.$fDataVersion1
        (k_Xe3bW
           @ [Int]
           @ ([String] -> Version)
           Data.Data.$fData[]_$s$fData[]1
           (z_Xe3bY @ ([Int] -> [String] -> Version) Data.Version.Version))

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Data.$fDataVersion_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c Version)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae4ap :: * -> *))
                 (@ (c_ae4aq :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae4aq Version)}]
Data.Data.$fDataVersion_$cdataCast1
  = \ (@ (t_ae4ap :: * -> *))
      (@ (c_ae4aq :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae4aq Version)

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
lvl260_rejWE :: ([Int] -> [String] -> Version, Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl260_rejWE = (Data.Version.Version, GHC.Types.False)

-- RHS size: {terms: 86, types: 176, coercions: 0, joins: 0/4}
Data.Data.$fDataVersion_$cgmapMp
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Version -> m Version
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []]
Data.Data.$fDataVersion_$cgmapMp
  = \ (@ (m_ae4cw :: * -> *))
      ($dMonadPlus_ae4cy :: MonadPlus m_ae4cw)
      (ds_de7y9 :: forall d. Data d => d -> m_ae4cw d)
      (eta_XS6 :: Version) ->
      let {
        lvl270_se9Xx :: m_ae4cw Version
        [LclId]
        lvl270_se9Xx = mzero @ m_ae4cw $dMonadPlus_ae4cy @ Version } in
      let {
        $dMonad_se9n5 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae4cw
        [LclId]
        $dMonad_se9n5
          = GHC.Base.$p2MonadPlus @ m_ae4cw $dMonadPlus_ae4cy } in
      >>=
        @ m_ae4cw
        $dMonad_se9n5
        @ (Version, Bool)
        @ Version
        (case eta_XS6 of { Version a1_ae2oM a2_ae2oN ->
         let {
           lvl271_se9Xu :: m_ae4cw [String]
           [LclId]
           lvl271_se9Xu
             = ds_de7y9 @ [String] Data.Data.$fDataVersion1 a2_ae2oN } in
         >>=
           @ m_ae4cw
           $dMonad_se9n5
           @ ([String] -> Version, Bool)
           @ (Version, Bool)
           (let {
              lvl272_se9Xt :: m_ae4cw [Int]
              [LclId]
              lvl272_se9Xt
                = ds_de7y9 @ [Int] Data.Data.$fData[]_$s$fData[]1 a1_ae2oM } in
            >>=
              @ m_ae4cw
              $dMonad_se9n5
              @ ([Int] -> [String] -> Version, Bool)
              @ ([String] -> Version, Bool)
              (return
                 @ m_ae4cw
                 $dMonad_se9n5
                 @ ([Int] -> [String] -> Version, Bool)
                 lvl260_rejWE)
              (\ (ds1_de7oD :: ([Int] -> [String] -> Version, Bool)) ->
                 case ds1_de7oD of { (h_ae1TA, b_ae1TB) ->
                 mplus
                   @ m_ae4cw
                   $dMonadPlus_ae4cy
                   @ ([String] -> Version, Bool)
                   (>>=
                      @ m_ae4cw
                      $dMonad_se9n5
                      @ [Int]
                      @ ([String] -> Version, Bool)
                      lvl272_se9Xt
                      (\ (y'_ae1TC :: [Int]) ->
                         return
                           @ m_ae4cw
                           $dMonad_se9n5
                           @ ([String] -> Version, Bool)
                           (h_ae1TA y'_ae1TC, GHC.Types.True)))
                   (return
                      @ m_ae4cw
                      $dMonad_se9n5
                      @ ([String] -> Version, Bool)
                      (h_ae1TA a1_ae2oM, b_ae1TB))
                 }))
           (\ (ds1_de7oD :: ([String] -> Version, Bool)) ->
              case ds1_de7oD of { (h_ae1TA, b_ae1TB) ->
              mplus
                @ m_ae4cw
                $dMonadPlus_ae4cy
                @ (Version, Bool)
                (>>=
                   @ m_ae4cw
                   $dMonad_se9n5
                   @ [String]
                   @ (Version, Bool)
                   lvl271_se9Xu
                   (\ (y'_ae1TC :: [String]) ->
                      return
                        @ m_ae4cw
                        $dMonad_se9n5
                        @ (Version, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_ae4cw
                   $dMonad_se9n5
                   @ (Version, Bool)
                   (h_ae1TA a2_ae2oN, b_ae1TB))
              })
         })
        (\ (ds1_de7oa :: (Version, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9Xx;
             True -> return @ m_ae4cw $dMonad_se9n5 @ Version x'_ae1TD
           }
           })

-- RHS size: {terms: 38, types: 75, coercions: 0, joins: 0/2}
Data.Data.$w$cgmapM18 [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> [Int] -> [String] -> m Version
[GblId,
 Arity=4,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [210 120 0 0] 410 0}]
Data.Data.$w$cgmapM18
  = \ (@ (m_segEy :: * -> *))
      (w_segEz :: Monad m_segEy)
      (w1_segEA :: forall d. Data d => d -> m_segEy d)
      (ww_segEE :: [Int])
      (ww1_segEF :: [String]) ->
      let {
        lvl270_se9Xz :: m_segEy [String]
        [LclId]
        lvl270_se9Xz
          = w1_segEA @ [String] Data.Data.$fDataVersion1 ww1_segEF } in
      >>=
        @ m_segEy
        w_segEz
        @ ([String] -> Version)
        @ Version
        (let {
           lvl271_se9Xy :: m_segEy [Int]
           [LclId]
           lvl271_se9Xy
             = w1_segEA @ [Int] Data.Data.$fData[]_$s$fData[]1 ww_segEE } in
         >>=
           @ m_segEy
           w_segEz
           @ ([Int] -> [String] -> Version)
           @ ([String] -> Version)
           (return
              @ m_segEy
              w_segEz
              @ ([Int] -> [String] -> Version)
              Data.Version.Version)
           (\ (c'_ae1To :: [Int] -> [String] -> Version) ->
              >>=
                @ m_segEy
                w_segEz
                @ [Int]
                @ ([String] -> Version)
                lvl271_se9Xy
                (\ (x'_ae1Tp :: [Int]) ->
                   return
                     @ m_segEy w_segEz @ ([String] -> Version) (c'_ae1To x'_ae1Tp))))
        (\ (c'_ae1To :: [String] -> Version) ->
           >>=
             @ m_segEy
             w_segEz
             @ [String]
             @ Version
             lvl270_se9Xz
             (\ (x'_ae1Tp :: [String]) ->
                return @ m_segEy w_segEz @ Version (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 12, types: 20, coercions: 0, joins: 0/0}
Data.Data.$fDataVersion_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Version -> m Version
[GblId,
 Arity=3,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (m_segEy :: * -> *))
                 (w_segEz [Occ=Once] :: Monad m_segEy)
                 (w1_segEA [Occ=Once] :: forall d. Data d => d -> m_segEy d)
                 (w2_segEB [Occ=Once!] :: Version) ->
                 case w2_segEB of
                 { Version ww1_segEE [Occ=Once] ww2_segEF [Occ=Once] ->
                 Data.Data.$w$cgmapM18
                   @ m_segEy w_segEz w1_segEA ww1_segEE ww2_segEF
                 }}]
Data.Data.$fDataVersion_$cgmapM
  = \ (@ (m_segEy :: * -> *))
      (w_segEz :: Monad m_segEy)
      (w1_segEA :: forall d. Data d => d -> m_segEy d)
      (w2_segEB :: Version) ->
      case w2_segEB of { Version ww1_segEE ww2_segEF ->
      Data.Data.$w$cgmapM18
        @ m_segEy w_segEz w1_segEA ww1_segEE ww2_segEF
      }

-- RHS size: {terms: 17, types: 19, coercions: 0, joins: 0/0}
Data.Data.$w$cgmapQi6 [InlPrag=NOUSERINLINE[0]]
  :: forall u.
     Int# -> (forall d. Data d => d -> u) -> [Int] -> [String] -> u
[GblId,
 Arity=4,
 Str=<S,1*U><C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [70 120 0 0] 90 0}]
Data.Data.$w$cgmapQi6
  = \ (@ u_segEI)
      (ww_segEO :: Int#)
      (w_segEK :: forall d. Data d => d -> u_segEI)
      (ww1_segES :: [Int])
      (ww2_segET :: [String]) ->
      case ww_segEO of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_segEI;
        0# -> w_segEK @ [Int] Data.Data.$fData[]_$s$fData[]1 ww1_segES;
        1# -> w_segEK @ [String] Data.Data.$fDataVersion1 ww2_segET
      }

-- RHS size: {terms: 15, types: 18, coercions: 0, joins: 0/0}
Data.Data.$fDataVersion_$cgmapQi [InlPrag=NOUSERINLINE[0]]
  :: forall u. Int -> (forall d. Data d => d -> u) -> Version -> u
[GblId,
 Arity=3,
 Str=<S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_segEI)
                 (w_segEJ [Occ=Once!] :: Int)
                 (w1_segEK [Occ=Once] :: forall d. Data d => d -> u_segEI)
                 (w2_segEL [Occ=Once!] :: Version) ->
                 case w_segEJ of { I# ww1_segEO [Occ=Once] ->
                 case w2_segEL of
                 { Version ww3_segES [Occ=Once] ww4_segET [Occ=Once] ->
                 Data.Data.$w$cgmapQi6
                   @ u_segEI ww1_segEO w1_segEK ww3_segES ww4_segET
                 }
                 }}]
Data.Data.$fDataVersion_$cgmapQi
  = \ (@ u_segEI)
      (w_segEJ :: Int)
      (w1_segEK :: forall d. Data d => d -> u_segEI)
      (w2_segEL :: Version) ->
      case w_segEJ of { I# ww1_segEO ->
      case w2_segEL of { Version ww3_segES ww4_segET ->
      Data.Data.$w$cgmapQi6
        @ u_segEI ww1_segEO w1_segEK ww3_segES ww4_segET
      }
      }

-- RHS size: {terms: 16, types: 22, coercions: 0, joins: 0/0}
Data.Data.$w$cgmapQr2 [InlPrag=NOUSERINLINE[0]]
  :: forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> [Int] -> [String] -> r
[GblId,
 Arity=5,
 Str=<C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 120 0 0] 120 0}]
Data.Data.$w$cgmapQr2
  = \ (@ r_segEW)
      (@ r'_segEX)
      (w_segEY :: r'_segEX -> r_segEW -> r_segEW)
      (w1_segEZ :: r_segEW)
      (w2_segF0 :: forall d. Data d => d -> r'_segEX)
      (ww_segF4 :: [Int])
      (ww1_segF5 :: [String]) ->
      w_segEY
        (w2_segF0 @ [Int] Data.Data.$fData[]_$s$fData[]1 ww_segF4)
        (w_segEY
           (w2_segF0 @ [String] Data.Data.$fDataVersion1 ww1_segF5) w1_segEZ)

-- RHS size: {terms: 15, types: 22, coercions: 0, joins: 0/0}
Data.Data.$fDataVersion_$cgmapQr [InlPrag=NOUSERINLINE[0]]
  :: forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> Version -> r
[GblId,
 Arity=4,
 Str=<C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_segEW)
                 (@ r'_segEX)
                 (w_segEY [Occ=Once] :: r'_segEX -> r_segEW -> r_segEW)
                 (w1_segEZ [Occ=Once] :: r_segEW)
                 (w2_segF0 [Occ=Once] :: forall d. Data d => d -> r'_segEX)
                 (w3_segF1 [Occ=Once!] :: Version) ->
                 case w3_segF1 of
                 { Version ww1_segF4 [Occ=Once] ww2_segF5 [Occ=Once] ->
                 Data.Data.$w$cgmapQr2
                   @ r_segEW @ r'_segEX w_segEY w1_segEZ w2_segF0 ww1_segF4 ww2_segF5
                 }}]
Data.Data.$fDataVersion_$cgmapQr
  = \ (@ r_segEW)
      (@ r'_segEX)
      (w_segEY :: r'_segEX -> r_segEW -> r_segEW)
      (w1_segEZ :: r_segEW)
      (w2_segF0 :: forall d. Data d => d -> r'_segEX)
      (w3_segF1 :: Version) ->
      case w3_segF1 of { Version ww1_segF4 ww2_segF5 ->
      Data.Data.$w$cgmapQr2
        @ r_segEW @ r'_segEX w_segEY w1_segEZ w2_segF0 ww1_segF4 ww2_segF5
      }

-- RHS size: {terms: 15, types: 21, coercions: 0, joins: 0/0}
Data.Data.$fDataVersion_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> Version -> [u]
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><S,1*U(U,U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_ae4bO)
                 (ds_de7y5 :: forall d. Data d => d -> u_ae4bO)
                 (x0_ae1SX [Occ=Once!] :: Version) ->
                 case x0_ae1SX of
                 { Version a1_ae2oM [Occ=Once] a2_ae2oN [Occ=Once] ->
                 GHC.Types.:
                   @ u_ae4bO
                   (ds_de7y5 @ [Int] Data.Data.$fData[]_$s$fData[]1 a1_ae2oM)
                   (GHC.Types.:
                      @ u_ae4bO
                      (ds_de7y5 @ [String] Data.Data.$fDataVersion1 a2_ae2oN)
                      (GHC.Types.[] @ u_ae4bO))
                 }}]
Data.Data.$fDataVersion_$cgmapQ
  = \ (@ u_ae4bO)
      (ds_de7y5 :: forall d. Data d => d -> u_ae4bO)
      (x0_ae1SX :: Version) ->
      case x0_ae1SX of { Version a1_ae2oM a2_ae2oN ->
      GHC.Types.:
        @ u_ae4bO
        (ds_de7y5 @ [Int] Data.Data.$fData[]_$s$fData[]1 a1_ae2oM)
        (GHC.Types.:
           @ u_ae4bO
           (ds_de7y5 @ [String] Data.Data.$fDataVersion1 a2_ae2oN)
           (GHC.Types.[] @ u_ae4bO))
      }

-- RHS size: {terms: 16, types: 22, coercions: 0, joins: 0/0}
Data.Data.$w$cgmapQl1
  :: forall r r'.
     (r -> r' -> r)
     -> r -> (forall d. Data d => d -> r') -> [Int] -> [String] -> r
[GblId,
 Arity=5,
 Str=<C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 120 0 0] 120 0}]
Data.Data.$w$cgmapQl1
  = \ (@ r_segF8)
      (@ r'_segF9)
      (w_segFa :: r_segF8 -> r'_segF9 -> r_segF8)
      (w1_segFb :: r_segF8)
      (w2_segFc :: forall d. Data d => d -> r'_segF9)
      (ww_segFg :: [Int])
      (ww1_segFh :: [String]) ->
      w_segFa
        (w_segFa
           w1_segFb
           (w2_segFc @ [Int] Data.Data.$fData[]_$s$fData[]1 ww_segFg))
        (w2_segFc @ [String] Data.Data.$fDataVersion1 ww1_segFh)

-- RHS size: {terms: 15, types: 22, coercions: 6, joins: 0/0}
Data.Data.$fDataVersion2 [InlPrag=NOUSERINLINE[0]]
  :: forall r r'.
     (r -> r' -> r)
     -> r -> (forall d. Data d => d -> r') -> Version -> Const r Version
[GblId,
 Arity=4,
 Str=<C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_XehYi)
                 (@ r'_XehYk)
                 (w_XehYm [Occ=Once] :: r_XehYi -> r'_XehYk -> r_XehYi)
                 (w1_XehYo [Occ=Once] :: r_XehYi)
                 (w2_XehYq [Occ=Once] :: forall d. Data d => d -> r'_XehYk)
                 (w3_segFd [Occ=Once!] :: Version) ->
                 case w3_segFd of
                 { Version ww1_XehYy [Occ=Once] ww2_XehYA [Occ=Once] ->
                 (Data.Data.$w$cgmapQl1
                    @ r_XehYi @ r'_XehYk w_XehYm w1_XehYo w2_XehYq ww1_XehYy ww2_XehYA)
                 `cast` (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r_XehYi>_R <Version>_P)
                         :: (r_XehYi :: *) ~R# (Const r_XehYi Version :: *))
                 }}]
Data.Data.$fDataVersion2
  = \ (@ r_XehYi)
      (@ r'_XehYk)
      (w_XehYm :: r_XehYi -> r'_XehYk -> r_XehYi)
      (w1_XehYo :: r_XehYi)
      (w2_XehYq :: forall d. Data d => d -> r'_XehYk)
      (w3_segFd :: Version) ->
      case w3_segFd of { Version ww1_XehYy ww2_XehYA ->
      (Data.Data.$w$cgmapQl1
         @ r_XehYi @ r'_XehYk w_XehYm w1_XehYo w2_XehYq ww1_XehYy ww2_XehYA)
      `cast` (Sym (Data.Functor.Const.N:Const[0]
                       <*>_N <r_XehYi>_R <Version>_P)
              :: (r_XehYi :: *) ~R# (Const r_XehYi Version :: *))
      }

-- RHS size: {terms: 12, types: 16, coercions: 3, joins: 0/0}
Data.Data.$fDataVersion3
  :: (forall b. Data b => b -> b) -> Version -> Identity Version
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_de7xY :: forall b. Data b => b -> b)
                 (x0_Xe3bC [Occ=Once!] :: Version) ->
                 case x0_Xe3bC of
                 { Version a1_ae2oM [Occ=Once] a2_ae2oN [Occ=Once] ->
                 (Data.Version.Version
                    (ds_de7xY @ [Int] Data.Data.$fData[]_$s$fData[]1 a1_ae2oM)
                    (ds_de7xY @ [String] Data.Data.$fDataVersion1 a2_ae2oN))
                 `cast` (Sym (Data.Functor.Identity.N:Identity[0] <Version>_R)
                         :: (Version :: *) ~R# (Identity Version :: *))
                 }}]
Data.Data.$fDataVersion3
  = \ (ds_de7xY :: forall b. Data b => b -> b)
      (x0_Xe3bC :: Version) ->
      case x0_Xe3bC of { Version a1_ae2oM a2_ae2oN ->
      (Data.Version.Version
         (ds_de7xY @ [Int] Data.Data.$fData[]_$s$fData[]1 a1_ae2oM)
         (ds_de7xY @ [String] Data.Data.$fDataVersion1 a2_ae2oN))
      `cast` (Sym (Data.Functor.Identity.N:Identity[0] <Version>_R)
              :: (Version :: *) ~R# (Identity Version :: *))
      }

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataVersion_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c Version)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_ae4aI :: * -> * -> *))
                 (@ (c_ae4aJ :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_ae4aJ Version)}]
Data.Data.$fDataVersion_$cdataCast2
  = \ (@ (t_ae4aI :: * -> * -> *))
      (@ (c_ae4aJ :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae4aJ Version)

-- RHS size: {terms: 106, types: 194, coercions: 0, joins: 0/4}
Data.Data.$fDataVersion_$cgmapMo
  :: forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Version -> m Version
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []]
Data.Data.$fDataVersion_$cgmapMo
  = \ (@ (m_ae4cM :: * -> *))
      ($dMonadPlus_ae4cO :: MonadPlus m_ae4cM)
      (ds_de7ya :: forall d. Data d => d -> m_ae4cM d)
      (eta_XSm :: Version) ->
      let {
        lvl270_se9XI :: m_ae4cM Version
        [LclId]
        lvl270_se9XI = mzero @ m_ae4cM $dMonadPlus_ae4cO @ Version } in
      let {
        $dMonad_se9mR [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae4cM
        [LclId]
        $dMonad_se9mR
          = GHC.Base.$p2MonadPlus @ m_ae4cM $dMonadPlus_ae4cO } in
      >>=
        @ m_ae4cM
        $dMonad_se9mR
        @ (Version, Bool)
        @ Version
        (case eta_XSm of { Version a1_ae2oM a2_ae2oN ->
         let {
           lvl271_se9XF :: m_ae4cM [String]
           [LclId]
           lvl271_se9XF
             = ds_de7ya @ [String] Data.Data.$fDataVersion1 a2_ae2oN } in
         >>=
           @ m_ae4cM
           $dMonad_se9mR
           @ ([String] -> Version, Bool)
           @ (Version, Bool)
           (let {
              lvl272_se9XE :: m_ae4cM [Int]
              [LclId]
              lvl272_se9XE
                = ds_de7ya @ [Int] Data.Data.$fData[]_$s$fData[]1 a1_ae2oM } in
            >>=
              @ m_ae4cM
              $dMonad_se9mR
              @ ([Int] -> [String] -> Version, Bool)
              @ ([String] -> Version, Bool)
              (return
                 @ m_ae4cM
                 $dMonad_se9mR
                 @ ([Int] -> [String] -> Version, Bool)
                 lvl260_rejWE)
              (\ (ds1_de7pD :: ([Int] -> [String] -> Version, Bool)) ->
                 case ds1_de7pD of { (h_ae1TP, b_ae1TQ) ->
                 case b_ae1TQ of {
                   False ->
                     mplus
                       @ m_ae4cM
                       $dMonadPlus_ae4cO
                       @ ([String] -> Version, Bool)
                       (>>=
                          @ m_ae4cM
                          $dMonad_se9mR
                          @ [Int]
                          @ ([String] -> Version, Bool)
                          lvl272_se9XE
                          (\ (y'_ae1TR :: [Int]) ->
                             return
                               @ m_ae4cM
                               $dMonad_se9mR
                               @ ([String] -> Version, Bool)
                               (h_ae1TP y'_ae1TR, GHC.Types.True)))
                       (return
                          @ m_ae4cM
                          $dMonad_se9mR
                          @ ([String] -> Version, Bool)
                          (h_ae1TP a1_ae2oM, GHC.Types.False));
                   True ->
                     return
                       @ m_ae4cM
                       $dMonad_se9mR
                       @ ([String] -> Version, Bool)
                       (h_ae1TP a1_ae2oM, GHC.Types.True)
                 }
                 }))
           (\ (ds1_de7pD :: ([String] -> Version, Bool)) ->
              case ds1_de7pD of { (h_ae1TP, b_ae1TQ) ->
              case b_ae1TQ of {
                False ->
                  mplus
                    @ m_ae4cM
                    $dMonadPlus_ae4cO
                    @ (Version, Bool)
                    (>>=
                       @ m_ae4cM
                       $dMonad_se9mR
                       @ [String]
                       @ (Version, Bool)
                       lvl271_se9XF
                       (\ (y'_ae1TR :: [String]) ->
                          return
                            @ m_ae4cM
                            $dMonad_se9mR
                            @ (Version, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_ae4cM
                       $dMonad_se9mR
                       @ (Version, Bool)
                       (h_ae1TP a2_ae2oN, GHC.Types.False));
                True ->
                  return
                    @ m_ae4cM
                    $dMonad_se9mR
                    @ (Version, Bool)
                    (h_ae1TP a2_ae2oN, GHC.Types.True)
              }
              })
         })
        (\ (ds1_de7pa :: (Version, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9XI;
             True -> return @ m_ae4cM $dMonad_se9mR @ Version x'_ae1TS
           }
           })

-- RHS size: {terms: 16, types: 1, coercions: 42, joins: 0/0}
Data.Data.$fDataVersion [InlPrag=NOUSERINLINE CONLIKE]
  :: Data Version
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: Version
                        Data.Data.$fDataVersion8
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Version>_N
                                :: (Data.Typeable.Internal.TypeRep Version :: *)
                                   ~R# (Typeable Version :: Constraint))
                        Data.Data.$fDataVersion_$cgfoldl
                        Data.Data.$fDataVersion_$cgunfold
                        Data.Data.$fDataVersion_$ctoConstr
                        Data.Data.$fDataVersion_$cdataTypeOf
                        Data.Data.$fDataVersion_$cdataCast1
                        Data.Data.$fDataVersion_$cdataCast2
                        Data.Data.$fDataVersion3
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <Version>_R
                                ->_R Data.Functor.Identity.N:Identity[0] <Version>_R
                                :: ((forall b. Data b => b -> b)
                                    -> Version -> Identity Version :: *)
                                   ~R# ((forall b. Data b => b -> b) -> Version -> Version :: *))
                        Data.Data.$fDataVersion2
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <Version>_R
                                ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <Version>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> Version
                                    -> Const r Version :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r -> (forall d. Data d => d -> r') -> Version -> r :: *))
                        Data.Data.$fDataVersion_$cgmapQr
                        Data.Data.$fDataVersion_$cgmapQ
                        Data.Data.$fDataVersion_$cgmapQi
                        Data.Data.$fDataVersion_$cgmapM
                        Data.Data.$fDataVersion_$cgmapMp
                        Data.Data.$fDataVersion_$cgmapMo]
Data.Data.$fDataVersion
  = Data.Data.C:Data
      @ Version
      (Data.Data.$fDataVersion8
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Version>_N
               :: (Data.Typeable.Internal.TypeRep Version :: *)
                  ~R# (Typeable Version :: Constraint)))
      Data.Data.$fDataVersion_$cgfoldl
      Data.Data.$fDataVersion_$cgunfold
      Data.Data.$fDataVersion_$ctoConstr
      Data.Data.$fDataVersion_$cdataTypeOf
      Data.Data.$fDataVersion_$cdataCast1
      Data.Data.$fDataVersion_$cdataCast2
      (Data.Data.$fDataVersion3
       `cast` (<forall b. Data b => b -> b>_R
               ->_R <Version>_R
               ->_R Data.Functor.Identity.N:Identity[0] <Version>_R
               :: ((forall b. Data b => b -> b)
                   -> Version -> Identity Version :: *)
                  ~R# ((forall b. Data b => b -> b) -> Version -> Version :: *)))
      (Data.Data.$fDataVersion2
       `cast` (forall (r :: <*>_N) (r' :: <*>_N).
               <r -> r' -> r>_R
               ->_R <r>_R
               ->_R <forall d. Data d => d -> r'>_R
               ->_R <Version>_R
               ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <Version>_P
               :: (forall r r'.
                   (r -> r' -> r)
                   -> r
                   -> (forall d. Data d => d -> r')
                   -> Version
                   -> Const r Version :: *)
                  ~R# (forall r r'.
                       (r -> r' -> r)
                       -> r -> (forall d. Data d => d -> r') -> Version -> r :: *)))
      Data.Data.$fDataVersion_$cgmapQr
      Data.Data.$fDataVersion_$cgmapQ
      Data.Data.$fDataVersion_$cgmapQi
      Data.Data.$fDataVersion_$cgmapM
      Data.Data.$fDataVersion_$cgmapMp
      Data.Data.$fDataVersion_$cgmapMo

-- RHS size: {terms: 20, types: 51, coercions: 0, joins: 0/1}
Data.Data.$fDataNonEmpty_$cgfoldl
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> NonEmpty a -> c (NonEmpty a)
[GblId,
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 170 60}]
Data.Data.$fDataNonEmpty_$cgfoldl
  = \ (@ a_Xe60t)
      ($dData_Xe60v :: Data a_Xe60t)
      (@ (c_ae5dn :: * -> *)) ->
      let {
        $dData1_se9mN :: Data [a_Xe60t]
        [LclId]
        $dData1_se9mN = Data.Data.$fData[] @ a_Xe60t $dData_Xe60v } in
      \ (k_ae2qN
           :: forall d b. Data d => c_ae5dn (d -> b) -> d -> c_ae5dn b)
        (z_ae2qO :: forall g. g -> c_ae5dn g)
        (ds_de7EG :: NonEmpty a_Xe60t) ->
        case ds_de7EG of { :| a1_ae2qP a2_ae2qQ ->
        k_ae2qN
          @ [a_Xe60t]
          @ (NonEmpty a_Xe60t)
          $dData1_se9mN
          (k_ae2qN
             @ a_Xe60t
             @ ([a_Xe60t] -> NonEmpty a_Xe60t)
             $dData_Xe60v
             (z_ae2qO
                @ (a_Xe60t -> [a_Xe60t] -> NonEmpty a_Xe60t)
                (GHC.Base.:| @ a_Xe60t))
             a1_ae2qP)
          a2_ae2qQ
        }

-- RHS size: {terms: 15, types: 44, coercions: 0, joins: 0/1}
Data.Data.$fDataNonEmpty_$cgunfold
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c (NonEmpty a)
[GblId,
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 140 60}]
Data.Data.$fDataNonEmpty_$cgunfold
  = \ (@ a_Xe60u)
      ($dData_Xe60w :: Data a_Xe60u)
      (@ (c_ae5dB :: * -> *)) ->
      let {
        $dData1_se9mL :: Data [a_Xe60u]
        [LclId]
        $dData1_se9mL = Data.Data.$fData[] @ a_Xe60u $dData_Xe60w } in
      \ (k_ae2qR :: forall b r. Data b => c_ae5dB (b -> r) -> c_ae5dB r)
        (z_ae2qS :: forall r. r -> c_ae5dB r)
        _ [Occ=Dead] ->
        k_ae2qR
          @ [a_Xe60u]
          @ (NonEmpty a_Xe60u)
          $dData1_se9mL
          (k_ae2qR
             @ a_Xe60u
             @ ([a_Xe60u] -> NonEmpty a_Xe60u)
             $dData_Xe60w
             (z_ae2qS
                @ (a_Xe60u -> [a_Xe60u] -> NonEmpty a_Xe60u)
                (GHC.Base.:| @ a_Xe60u)))

-- RHS size: {terms: 4, types: 9, coercions: 0, joins: 0/0}
lvl261_rejWF :: forall a. (a -> [a] -> NonEmpty a, Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl261_rejWF
  = \ (@ a_Xe60D) -> (GHC.Base.:| @ a_Xe60D, GHC.Types.False)

-- RHS size: {terms: 89, types: 205, coercions: 0, joins: 0/4}
Data.Data.$fDataNonEmpty_$cgmapMp
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> NonEmpty a -> m (NonEmpty a)
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []]
Data.Data.$fDataNonEmpty_$cgmapMp
  = \ (@ a_Xe60D)
      ($dData_Xe60F :: Data a_Xe60D)
      (@ (m_ae5g3 :: * -> *))
      ($dMonadPlus_ae5g5 :: MonadPlus m_ae5g3)
      (ds_de7EY :: forall d. Data d => d -> m_ae5g3 d)
      (eta_XSt :: NonEmpty a_Xe60D) ->
      let {
        lvl270_se9XM :: m_ae5g3 (NonEmpty a_Xe60D)
        [LclId]
        lvl270_se9XM
          = mzero @ m_ae5g3 $dMonadPlus_ae5g5 @ (NonEmpty a_Xe60D) } in
      let {
        $dMonad_se9mH [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae5g3
        [LclId]
        $dMonad_se9mH
          = GHC.Base.$p2MonadPlus @ m_ae5g3 $dMonadPlus_ae5g5 } in
      >>=
        @ m_ae5g3
        $dMonad_se9mH
        @ (NonEmpty a_Xe60D, Bool)
        @ (NonEmpty a_Xe60D)
        (case eta_XSt of { :| a1_ae2qP a2_ae2qQ ->
         let {
           lvl271_se9XJ :: m_ae5g3 [a_Xe60D]
           [LclId]
           lvl271_se9XJ
             = ds_de7EY
                 @ [a_Xe60D]
                 (Data.Data.$fData[] @ a_Xe60D $dData_Xe60F)
                 a2_ae2qQ } in
         >>=
           @ m_ae5g3
           $dMonad_se9mH
           @ ([a_Xe60D] -> NonEmpty a_Xe60D, Bool)
           @ (NonEmpty a_Xe60D, Bool)
           (let {
              lvl272_se9XK :: m_ae5g3 a_Xe60D
              [LclId]
              lvl272_se9XK = ds_de7EY @ a_Xe60D $dData_Xe60F a1_ae2qP } in
            >>=
              @ m_ae5g3
              $dMonad_se9mH
              @ (a_Xe60D -> [a_Xe60D] -> NonEmpty a_Xe60D, Bool)
              @ ([a_Xe60D] -> NonEmpty a_Xe60D, Bool)
              (return
                 @ m_ae5g3
                 $dMonad_se9mH
                 @ (a_Xe60D -> [a_Xe60D] -> NonEmpty a_Xe60D, Bool)
                 (lvl261_rejWF @ a_Xe60D))
              (\ (ds1_de7oD
                    :: (a_Xe60D -> [a_Xe60D] -> NonEmpty a_Xe60D, Bool)) ->
                 case ds1_de7oD of { (h_ae1TA, b_ae1TB) ->
                 mplus
                   @ m_ae5g3
                   $dMonadPlus_ae5g5
                   @ ([a_Xe60D] -> NonEmpty a_Xe60D, Bool)
                   (>>=
                      @ m_ae5g3
                      $dMonad_se9mH
                      @ a_Xe60D
                      @ ([a_Xe60D] -> NonEmpty a_Xe60D, Bool)
                      lvl272_se9XK
                      (\ (y'_ae1TC :: a_Xe60D) ->
                         return
                           @ m_ae5g3
                           $dMonad_se9mH
                           @ ([a_Xe60D] -> NonEmpty a_Xe60D, Bool)
                           (h_ae1TA y'_ae1TC, GHC.Types.True)))
                   (return
                      @ m_ae5g3
                      $dMonad_se9mH
                      @ ([a_Xe60D] -> NonEmpty a_Xe60D, Bool)
                      (h_ae1TA a1_ae2qP, b_ae1TB))
                 }))
           (\ (ds1_de7oD :: ([a_Xe60D] -> NonEmpty a_Xe60D, Bool)) ->
              case ds1_de7oD of { (h_ae1TA, b_ae1TB) ->
              mplus
                @ m_ae5g3
                $dMonadPlus_ae5g5
                @ (NonEmpty a_Xe60D, Bool)
                (>>=
                   @ m_ae5g3
                   $dMonad_se9mH
                   @ [a_Xe60D]
                   @ (NonEmpty a_Xe60D, Bool)
                   lvl271_se9XJ
                   (\ (y'_ae1TC :: [a_Xe60D]) ->
                      return
                        @ m_ae5g3
                        $dMonad_se9mH
                        @ (NonEmpty a_Xe60D, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_ae5g3
                   $dMonad_se9mH
                   @ (NonEmpty a_Xe60D, Bool)
                   (h_ae1TA a2_ae2qQ, b_ae1TB))
              })
         })
        (\ (ds1_de7oa :: (NonEmpty a_Xe60D, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl270_se9XM;
             True ->
               return @ m_ae5g3 $dMonad_se9mH @ (NonEmpty a_Xe60D) x'_ae1TD
           }
           })

-- RHS size: {terms: 47, types: 97, coercions: 0, joins: 0/4}
Data.Data.$fDataNonEmpty_$cgmapM
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> NonEmpty a -> m (NonEmpty a)
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 210 120] 470 60}]
Data.Data.$fDataNonEmpty_$cgmapM
  = \ (@ a_Xe60C)
      ($dData_Xe60E :: Data a_Xe60C)
      (@ (m_ae5fN :: * -> *))
      ($dMonad_ae5fP :: Monad m_ae5fN)
      (ds_de7EX :: forall d. Data d => d -> m_ae5fN d) ->
      let {
        $dData1_se9mB :: Data [a_Xe60C]
        [LclId]
        $dData1_se9mB = Data.Data.$fData[] @ a_Xe60C $dData_Xe60E } in
      let {
        lvl270_se9XP :: m_ae5fN (a_Xe60C -> [a_Xe60C] -> NonEmpty a_Xe60C)
        [LclId]
        lvl270_se9XP
          = return
              @ m_ae5fN
              $dMonad_ae5fP
              @ (a_Xe60C -> [a_Xe60C] -> NonEmpty a_Xe60C)
              (GHC.Base.:| @ a_Xe60C) } in
      \ (ds1_de7EG :: NonEmpty a_Xe60C) ->
        case ds1_de7EG of { :| a1_ae2qP a2_ae2qQ ->
        let {
          lvl271_se9XN :: m_ae5fN [a_Xe60C]
          [LclId]
          lvl271_se9XN = ds_de7EX @ [a_Xe60C] $dData1_se9mB a2_ae2qQ } in
        >>=
          @ m_ae5fN
          $dMonad_ae5fP
          @ ([a_Xe60C] -> NonEmpty a_Xe60C)
          @ (NonEmpty a_Xe60C)
          (let {
             lvl272_se9XO :: m_ae5fN a_Xe60C
             [LclId]
             lvl272_se9XO = ds_de7EX @ a_Xe60C $dData_Xe60E a1_ae2qP } in
           >>=
             @ m_ae5fN
             $dMonad_ae5fP
             @ (a_Xe60C -> [a_Xe60C] -> NonEmpty a_Xe60C)
             @ ([a_Xe60C] -> NonEmpty a_Xe60C)
             lvl270_se9XP
             (\ (c'_ae1To :: a_Xe60C -> [a_Xe60C] -> NonEmpty a_Xe60C) ->
                >>=
                  @ m_ae5fN
                  $dMonad_ae5fP
                  @ a_Xe60C
                  @ ([a_Xe60C] -> NonEmpty a_Xe60C)
                  lvl272_se9XO
                  (\ (x'_ae1Tp :: a_Xe60C) ->
                     return
                       @ m_ae5fN
                       $dMonad_ae5fP
                       @ ([a_Xe60C] -> NonEmpty a_Xe60C)
                       (c'_ae1To x'_ae1Tp))))
          (\ (c'_ae1To :: [a_Xe60C] -> NonEmpty a_Xe60C) ->
             >>=
               @ m_ae5fN
               $dMonad_ae5fP
               @ [a_Xe60C]
               @ (NonEmpty a_Xe60C)
               lvl271_se9XN
               (\ (x'_ae1Tp :: [a_Xe60C]) ->
                  return
                    @ m_ae5fN $dMonad_ae5fP @ (NonEmpty a_Xe60C) (c'_ae1To x'_ae1Tp)))
        }

-- RHS size: {terms: 20, types: 22, coercions: 0, joins: 0/0}
Data.Data.$w$cgmapQi5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data a =>
     forall u. Int# -> (forall d. Data d => d -> u) -> a -> [a] -> u
[GblId,
 Arity=5,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S,1*U><C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 70 120 0 0] 110 0}]
Data.Data.$w$cgmapQi5
  = \ (@ a_segFD)
      (w_segFE :: Data a_segFD)
      (@ u_segFF)
      (ww_segFL :: Int#)
      (w1_segFH :: forall d. Data d => d -> u_segFF)
      (ww1_segFP :: a_segFD)
      (ww2_segFQ :: [a_segFD]) ->
      case ww_segFL of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_segFF;
        0# -> w1_segFH @ a_segFD w_segFE ww1_segFP;
        1# ->
          w1_segFH
            @ [a_segFD] (Data.Data.$fData[] @ a_segFD w_segFE) ww2_segFQ
      }

-- RHS size: {terms: 18, types: 24, coercions: 0, joins: 0/0}
Data.Data.$fDataNonEmpty_$cgmapQi [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data a =>
     forall u. Int -> (forall d. Data d => d -> u) -> NonEmpty a -> u
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_segFD)
                 (w_segFE [Occ=Once] :: Data a_segFD)
                 (@ u_segFF)
                 (w1_segFG [Occ=Once!] :: Int)
                 (w2_segFH [Occ=Once] :: forall d. Data d => d -> u_segFF)
                 (w3_segFI [Occ=Once!] :: NonEmpty a_segFD) ->
                 case w1_segFG of { I# ww1_segFL [Occ=Once] ->
                 case w3_segFI of { :| ww3_segFP [Occ=Once] ww4_segFQ [Occ=Once] ->
                 Data.Data.$w$cgmapQi5
                   @ a_segFD w_segFE @ u_segFF ww1_segFL w2_segFH ww3_segFP ww4_segFQ
                 }
                 }}]
Data.Data.$fDataNonEmpty_$cgmapQi
  = \ (@ a_segFD)
      (w_segFE :: Data a_segFD)
      (@ u_segFF)
      (w1_segFG :: Int)
      (w2_segFH :: forall d. Data d => d -> u_segFF)
      (w3_segFI :: NonEmpty a_segFD) ->
      case w1_segFG of { I# ww1_segFL ->
      case w3_segFI of { :| ww3_segFP ww4_segFQ ->
      Data.Data.$w$cgmapQi5
        @ a_segFD w_segFE @ u_segFF ww1_segFL w2_segFH ww3_segFP ww4_segFQ
      }
      }

-- RHS size: {terms: 19, types: 25, coercions: 0, joins: 0/0}
Data.Data.$w$cgmapQr1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data a =>
     forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> a -> [a] -> r
[GblId,
 Arity=6,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 60 0 120 0 0] 140 0}]
Data.Data.$w$cgmapQr1
  = \ (@ a_segFT)
      (w_segFU :: Data a_segFT)
      (@ r_segFV)
      (@ r'_segFW)
      (w1_segFX :: r'_segFW -> r_segFV -> r_segFV)
      (w2_segFY :: r_segFV)
      (w3_segFZ :: forall d. Data d => d -> r'_segFW)
      (ww_segG3 :: a_segFT)
      (ww1_segG4 :: [a_segFT]) ->
      w1_segFX
        (w3_segFZ @ a_segFT w_segFU ww_segG3)
        (w1_segFX
           (w3_segFZ
              @ [a_segFT] (Data.Data.$fData[] @ a_segFT w_segFU) ww1_segG4)
           w2_segFY)

-- RHS size: {terms: 18, types: 28, coercions: 0, joins: 0/0}
Data.Data.$fDataNonEmpty_$cgmapQr [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data a =>
     forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> NonEmpty a -> r
[GblId,
 Arity=5,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_segFT)
                 (w_segFU [Occ=Once] :: Data a_segFT)
                 (@ r_segFV)
                 (@ r'_segFW)
                 (w1_segFX [Occ=Once] :: r'_segFW -> r_segFV -> r_segFV)
                 (w2_segFY [Occ=Once] :: r_segFV)
                 (w3_segFZ [Occ=Once] :: forall d. Data d => d -> r'_segFW)
                 (w4_segG0 [Occ=Once!] :: NonEmpty a_segFT) ->
                 case w4_segG0 of { :| ww1_segG3 [Occ=Once] ww2_segG4 [Occ=Once] ->
                 Data.Data.$w$cgmapQr1
                   @ a_segFT
                   w_segFU
                   @ r_segFV
                   @ r'_segFW
                   w1_segFX
                   w2_segFY
                   w3_segFZ
                   ww1_segG3
                   ww2_segG4
                 }}]
Data.Data.$fDataNonEmpty_$cgmapQr
  = \ (@ a_segFT)
      (w_segFU :: Data a_segFT)
      (@ r_segFV)
      (@ r'_segFW)
      (w1_segFX :: r'_segFW -> r_segFV -> r_segFV)
      (w2_segFY :: r_segFV)
      (w3_segFZ :: forall d. Data d => d -> r'_segFW)
      (w4_segG0 :: NonEmpty a_segFT) ->
      case w4_segG0 of { :| ww1_segG3 ww2_segG4 ->
      Data.Data.$w$cgmapQr1
        @ a_segFT
        w_segFU
        @ r_segFV
        @ r'_segFW
        w1_segFX
        w2_segFY
        w3_segFZ
        ww1_segG3
        ww2_segG4
      }

-- RHS size: {terms: 18, types: 26, coercions: 0, joins: 0/0}
Data.Data.$fDataNonEmpty_$cgmapQ [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data a =>
     forall u. (forall d. Data d => d -> u) -> NonEmpty a -> [u]
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><S,1*U(U,U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_segG7)
                 (w_segG8 :: Data a_segG7)
                 (@ u_segG9)
                 (w1_segGa :: forall d. Data d => d -> u_segG9)
                 (w2_segGb [Occ=Once!] :: NonEmpty a_segG7) ->
                 case w2_segGb of { :| ww1_segGe [Occ=Once] ww2_segGf [Occ=Once] ->
                 GHC.Types.:
                   @ u_segG9
                   (w1_segGa @ a_segG7 w_segG8 ww1_segGe)
                   (GHC.Types.:
                      @ u_segG9
                      (w1_segGa
                         @ [a_segG7] (Data.Data.$fData[] @ a_segG7 w_segG8) ww2_segGf)
                      (GHC.Types.[] @ u_segG9))
                 }}]
Data.Data.$fDataNonEmpty_$cgmapQ
  = \ (@ a_segG7)
      (w_segG8 :: Data a_segG7)
      (@ u_segG9)
      (w1_segGa :: forall d. Data d => d -> u_segG9)
      (w2_segGb :: NonEmpty a_segG7) ->
      case w2_segGb of { :| ww1_segGe ww2_segGf ->
      GHC.Types.:
        @ u_segG9
        (w1_segGa @ a_segG7 w_segG8 ww1_segGe)
        (GHC.Types.:
           @ u_segG9
           (w1_segGa
              @ [a_segG7] (Data.Data.$fData[] @ a_segG7 w_segG8) ww2_segGf)
           (GHC.Types.[] @ u_segG9))
      }

-- RHS size: {terms: 23, types: 32, coercions: 16, joins: 0/1}
Data.Data.$fDataNonEmpty_$cgmapQl
  :: forall a.
     Data a =>
     forall r r'.
     (r -> r' -> r)
     -> r -> (forall d. Data d => d -> r') -> NonEmpty a -> r
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 60 0 120] 170 60}]
Data.Data.$fDataNonEmpty_$cgmapQl
  = \ (@ a_Xe60y)
      ($dData_Xe60A :: Data a_Xe60y)
      (@ r_ae5eN)
      (@ r'_ae5eO)
      (ds_de7EO :: r_ae5eN -> r'_ae5eO -> r_ae5eN)
      (ds1_de7EP :: r_ae5eN)
      (ds2_de7EQ :: forall d. Data d => d -> r'_ae5eO) ->
      let {
        $dData1_se9mv :: Data [a_Xe60y]
        [LclId]
        $dData1_se9mv = Data.Data.$fData[] @ a_Xe60y $dData_Xe60A } in
      (\ (ds3_de7EG :: NonEmpty a_Xe60y) ->
         case ds3_de7EG of { :| a1_ae2qP a2_ae2qQ ->
         (ds_de7EO
            (ds_de7EO ds1_de7EP (ds2_de7EQ @ a_Xe60y $dData_Xe60A a1_ae2qP))
            (ds2_de7EQ @ [a_Xe60y] $dData1_se9mv a2_ae2qQ))
         `cast` (Sym (Data.Functor.Const.N:Const[0]
                          <*>_N <r_ae5eN>_R <NonEmpty a_Xe60y>_P)
                 :: (r_ae5eN :: *) ~R# (Const r_ae5eN (NonEmpty a_Xe60y) :: *))
         })
      `cast` (<NonEmpty a_Xe60y>_R
              ->_R Data.Functor.Const.N:Const[0]
                       <*>_N <r_ae5eN>_R <NonEmpty a_Xe60y>_P
              :: (NonEmpty a_Xe60y -> Const r_ae5eN (NonEmpty a_Xe60y) :: *)
                 ~R# (NonEmpty a_Xe60y -> r_ae5eN :: *))

-- RHS size: {terms: 15, types: 22, coercions: 4, joins: 0/0}
Data.Data.$fDataNonEmpty1
  :: forall a.
     Data a =>
     (forall b. Data b => b -> b) -> NonEmpty a -> Identity (NonEmpty a)
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe60x)
                 ($dData_Xe60z :: Data a_Xe60x)
                 (ds_de7EN :: forall b. Data b => b -> b)
                 (x0_Xe3bS [Occ=Once!] :: NonEmpty a_Xe60x) ->
                 case x0_Xe3bS of { :| a1_ae2qP [Occ=Once] a2_ae2qQ [Occ=Once] ->
                 (GHC.Base.:|
                    @ a_Xe60x
                    (ds_de7EN @ a_Xe60x $dData_Xe60z a1_ae2qP)
                    (ds_de7EN
                       @ [a_Xe60x] (Data.Data.$fData[] @ a_Xe60x $dData_Xe60z) a2_ae2qQ))
                 `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                                  <NonEmpty a_Xe60x>_R)
                         :: (NonEmpty a_Xe60x :: *) ~R# (Identity (NonEmpty a_Xe60x) :: *))
                 }}]
Data.Data.$fDataNonEmpty1
  = \ (@ a_Xe60x)
      ($dData_Xe60z :: Data a_Xe60x)
      (ds_de7EN :: forall b. Data b => b -> b)
      (x0_Xe3bS :: NonEmpty a_Xe60x) ->
      case x0_Xe3bS of { :| a1_ae2qP a2_ae2qQ ->
      (GHC.Base.:|
         @ a_Xe60x
         (ds_de7EN @ a_Xe60x $dData_Xe60z a1_ae2qP)
         (ds_de7EN
            @ [a_Xe60x] (Data.Data.$fData[] @ a_Xe60x $dData_Xe60z) a2_ae2qQ))
      `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                       <NonEmpty a_Xe60x>_R)
              :: (NonEmpty a_Xe60x :: *) ~R# (Identity (NonEmpty a_Xe60x) :: *))
      }

-- RHS size: {terms: 109, types: 227, coercions: 0, joins: 0/4}
Data.Data.$fDataNonEmpty_$cgmapMo
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> NonEmpty a -> m (NonEmpty a)
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=OtherCon []]
Data.Data.$fDataNonEmpty_$cgmapMo
  = \ (@ a_Xe60w)
      ($dData_Xe60y :: Data a_Xe60w)
      (@ (m_ae5gj :: * -> *))
      ($dMonadPlus_ae5gl :: MonadPlus m_ae5gj)
      (ds_de7EZ :: forall d. Data d => d -> m_ae5gj d)
      (eta_XSD :: NonEmpty a_Xe60w) ->
      let {
        lvl270_se9XW :: m_ae5gj (NonEmpty a_Xe60w)
        [LclId]
        lvl270_se9XW
          = mzero @ m_ae5gj $dMonadPlus_ae5gl @ (NonEmpty a_Xe60w) } in
      let {
        $dMonad_se9mr [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_ae5gj
        [LclId]
        $dMonad_se9mr
          = GHC.Base.$p2MonadPlus @ m_ae5gj $dMonadPlus_ae5gl } in
      >>=
        @ m_ae5gj
        $dMonad_se9mr
        @ (NonEmpty a_Xe60w, Bool)
        @ (NonEmpty a_Xe60w)
        (case eta_XSD of { :| a1_ae2qP a2_ae2qQ ->
         let {
           lvl271_se9XT :: m_ae5gj [a_Xe60w]
           [LclId]
           lvl271_se9XT
             = ds_de7EZ
                 @ [a_Xe60w]
                 (Data.Data.$fData[] @ a_Xe60w $dData_Xe60y)
                 a2_ae2qQ } in
         >>=
           @ m_ae5gj
           $dMonad_se9mr
           @ ([a_Xe60w] -> NonEmpty a_Xe60w, Bool)
           @ (NonEmpty a_Xe60w, Bool)
           (let {
              lvl272_se9XU :: m_ae5gj a_Xe60w
              [LclId]
              lvl272_se9XU = ds_de7EZ @ a_Xe60w $dData_Xe60y a1_ae2qP } in
            >>=
              @ m_ae5gj
              $dMonad_se9mr
              @ (a_Xe60w -> [a_Xe60w] -> NonEmpty a_Xe60w, Bool)
              @ ([a_Xe60w] -> NonEmpty a_Xe60w, Bool)
              (return
                 @ m_ae5gj
                 $dMonad_se9mr
                 @ (a_Xe60w -> [a_Xe60w] -> NonEmpty a_Xe60w, Bool)
                 (lvl261_rejWF @ a_Xe60w))
              (\ (ds1_de7pD
                    :: (a_Xe60w -> [a_Xe60w] -> NonEmpty a_Xe60w, Bool)) ->
                 case ds1_de7pD of { (h_ae1TP, b_ae1TQ) ->
                 case b_ae1TQ of {
                   False ->
                     mplus
                       @ m_ae5gj
                       $dMonadPlus_ae5gl
                       @ ([a_Xe60w] -> NonEmpty a_Xe60w, Bool)
                       (>>=
                          @ m_ae5gj
                          $dMonad_se9mr
                          @ a_Xe60w
                          @ ([a_Xe60w] -> NonEmpty a_Xe60w, Bool)
                          lvl272_se9XU
                          (\ (y'_ae1TR :: a_Xe60w) ->
                             return
                               @ m_ae5gj
                               $dMonad_se9mr
                               @ ([a_Xe60w] -> NonEmpty a_Xe60w, Bool)
                               (h_ae1TP y'_ae1TR, GHC.Types.True)))
                       (return
                          @ m_ae5gj
                          $dMonad_se9mr
                          @ ([a_Xe60w] -> NonEmpty a_Xe60w, Bool)
                          (h_ae1TP a1_ae2qP, GHC.Types.False));
                   True ->
                     return
                       @ m_ae5gj
                       $dMonad_se9mr
                       @ ([a_Xe60w] -> NonEmpty a_Xe60w, Bool)
                       (h_ae1TP a1_ae2qP, GHC.Types.True)
                 }
                 }))
           (\ (ds1_de7pD :: ([a_Xe60w] -> NonEmpty a_Xe60w, Bool)) ->
              case ds1_de7pD of { (h_ae1TP, b_ae1TQ) ->
              case b_ae1TQ of {
                False ->
                  mplus
                    @ m_ae5gj
                    $dMonadPlus_ae5gl
                    @ (NonEmpty a_Xe60w, Bool)
                    (>>=
                       @ m_ae5gj
                       $dMonad_se9mr
                       @ [a_Xe60w]
                       @ (NonEmpty a_Xe60w, Bool)
                       lvl271_se9XT
                       (\ (y'_ae1TR :: [a_Xe60w]) ->
                          return
                            @ m_ae5gj
                            $dMonad_se9mr
                            @ (NonEmpty a_Xe60w, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_ae5gj
                       $dMonad_se9mr
                       @ (NonEmpty a_Xe60w, Bool)
                       (h_ae1TP a2_ae2qQ, GHC.Types.False));
                True ->
                  return
                    @ m_ae5gj
                    $dMonad_se9mr
                    @ (NonEmpty a_Xe60w, Bool)
                    (h_ae1TP a2_ae2qQ, GHC.Types.True)
              }
              })
         })
        (\ (ds1_de7pa :: (NonEmpty a_Xe60w, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl270_se9XW;
             True ->
               return @ m_ae5gj $dMonad_se9mr @ (NonEmpty a_Xe60w) x'_ae1TS
           }
           })

-- RHS size: {terms: 6, types: 9, coercions: 0, joins: 0/0}
lvl262_rejWG :: forall a. NonEmpty a -> Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []]
lvl262_rejWG
  = \ (@ a_Xe60v) (ds_de7EI :: NonEmpty a_Xe60v) ->
      case ds_de7EI of { :| ds1_de7EJ ds2_de7EK -> Data.Data.$c:| }

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl263_rejWH :: forall a. NonEmpty a -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl263_rejWH = \ (@ a_Xe60v) _ [Occ=Dead] -> Data.Data.$tNonEmpty

-- RHS size: {terms: 6, types: 35, coercions: 0, joins: 0/0}
lvl264_rejWI
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e))
     -> Maybe (c (NonEmpty a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl264_rejWI
  = \ (@ a_Xe60v)
      (@ (t_ae5ef :: * -> * -> *))
      (@ (c_ae5eg :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5eg (NonEmpty a_Xe60v))

-- RHS size: {terms: 30, types: 21, coercions: 19, joins: 0/0}
Data.Data.$fDataNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data a => Data (NonEmpty a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_ae1XZ) (v_XSA :: Data a_ae1XZ) ->
       Data.Data.C:Data TYPE: NonEmpty a_ae1XZ
                        (Data.Data.$fDataNonEmpty7 @ a_ae1XZ v_XSA)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <NonEmpty
                                                                                    a_ae1XZ>_N
                                :: (Data.Typeable.Internal.TypeRep (NonEmpty a_ae1XZ) :: *)
                                   ~R# (Typeable (NonEmpty a_ae1XZ) :: Constraint))
                        Data.Data.$fDataNonEmpty_$cgfoldl @ a_ae1XZ v_XSA
                        Data.Data.$fDataNonEmpty_$cgunfold @ a_ae1XZ v_XSA
                        \ (ds_de7EI [Occ=Once!] :: NonEmpty a_ae1XZ) ->
                          case ds_de7EI of { :| _ [Occ=Dead] _ [Occ=Dead] -> Data.Data.$c:| }
                        \ _ [Occ=Dead] -> Data.Data.$tNonEmpty
                        Data.Data.$fDataNonEmpty_$cdataCast1 @ a_ae1XZ v_XSA
                        \ (@ (t_ae5ef :: * -> * -> *))
                          (@ (c_ae5eg :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae5eg (NonEmpty a_ae1XZ))
                        (Data.Data.$fDataNonEmpty1 @ a_ae1XZ v_XSA)
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <NonEmpty a_ae1XZ>_R
                                ->_R Data.Functor.Identity.N:Identity[0] <NonEmpty a_ae1XZ>_R
                                :: ((forall b. Data b => b -> b)
                                    -> NonEmpty a_ae1XZ -> Identity (NonEmpty a_ae1XZ) :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> NonEmpty a_ae1XZ -> NonEmpty a_ae1XZ :: *))
                        Data.Data.$fDataNonEmpty_$cgmapQl @ a_ae1XZ v_XSA
                        Data.Data.$fDataNonEmpty_$cgmapQr @ a_ae1XZ v_XSA
                        Data.Data.$fDataNonEmpty_$cgmapQ @ a_ae1XZ v_XSA
                        Data.Data.$fDataNonEmpty_$cgmapQi @ a_ae1XZ v_XSA
                        Data.Data.$fDataNonEmpty_$cgmapM @ a_ae1XZ v_XSA
                        Data.Data.$fDataNonEmpty_$cgmapMp @ a_ae1XZ v_XSA
                        Data.Data.$fDataNonEmpty_$cgmapMo @ a_ae1XZ v_XSA]
Data.Data.$fDataNonEmpty
  = \ (@ a_Xe60v) ($dData_Xe6T6 :: Data a_Xe60v) ->
      Data.Data.C:Data
        @ (NonEmpty a_Xe60v)
        ((Data.Data.$fDataNonEmpty7 @ a_Xe60v $dData_Xe6T6)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <NonEmpty
                                                                     a_Xe60v>_N
                 :: (Data.Typeable.Internal.TypeRep (NonEmpty a_Xe60v) :: *)
                    ~R# (Typeable (NonEmpty a_Xe60v) :: Constraint)))
        (Data.Data.$fDataNonEmpty_$cgfoldl @ a_Xe60v $dData_Xe6T6)
        (Data.Data.$fDataNonEmpty_$cgunfold @ a_Xe60v $dData_Xe6T6)
        (lvl262_rejWG @ a_Xe60v)
        (lvl263_rejWH @ a_Xe60v)
        (Data.Data.$fDataNonEmpty_$cdataCast1 @ a_Xe60v $dData_Xe6T6)
        (lvl264_rejWI @ a_Xe60v)
        ((Data.Data.$fDataNonEmpty1 @ a_Xe60v $dData_Xe6T6)
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <NonEmpty a_Xe60v>_R
                 ->_R Data.Functor.Identity.N:Identity[0] <NonEmpty a_Xe60v>_R
                 :: ((forall b. Data b => b -> b)
                     -> NonEmpty a_Xe60v -> Identity (NonEmpty a_Xe60v) :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> NonEmpty a_Xe60v -> NonEmpty a_Xe60v :: *)))
        (Data.Data.$fDataNonEmpty_$cgmapQl @ a_Xe60v $dData_Xe6T6)
        (Data.Data.$fDataNonEmpty_$cgmapQr @ a_Xe60v $dData_Xe6T6)
        (Data.Data.$fDataNonEmpty_$cgmapQ @ a_Xe60v $dData_Xe6T6)
        (Data.Data.$fDataNonEmpty_$cgmapQi @ a_Xe60v $dData_Xe6T6)
        (Data.Data.$fDataNonEmpty_$cgmapM @ a_Xe60v $dData_Xe6T6)
        (Data.Data.$fDataNonEmpty_$cgmapMp @ a_Xe60v $dData_Xe6T6)
        (Data.Data.$fDataNonEmpty_$cgmapMo @ a_Xe60v $dData_Xe6T6)

-- RHS size: {terms: 20, types: 52, coercions: 0, joins: 0/1}
Data.Data.$w$cgfoldl2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data b, Ix a) =>
     forall (c :: * -> *).
     (forall d b1. Data d => c (d -> b1) -> d -> c b1)
     -> (forall g. g -> c g) -> Array a b -> c (Array a b)
[GblId,
 Arity=2,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,A,A,A,A,C(U(U)),A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 190 60}]
Data.Data.$w$cgfoldl2
  = \ (@ a_segGy)
      (@ b_segGz)
      (w_segGB :: Data b_segGz)
      (w1_segGC :: Ix a_segGy)
      (@ (c_ae5mx :: * -> *)) ->
      let {
        $dData_se9mn :: Data [b_segGz]
        [LclId]
        $dData_se9mn = Data.Data.$fData[] @ b_segGz w_segGB } in
      \ (f_ae1TW
           :: forall d b1. Data d => c_ae5mx (d -> b1) -> d -> c_ae5mx b1)
        (z_ae1TX :: forall g. g -> c_ae5mx g)
        (a1_ae1TY :: Array a_segGy b_segGz) ->
        f_ae1TW
          @ [b_segGz]
          @ (Array a_segGy b_segGz)
          $dData_se9mn
          (z_ae1TX
             @ ([b_segGz] -> Array a_segGy b_segGz)
             (listArray
                @ a_segGy
                @ b_segGz
                w1_segGC
                (bounds @ a_segGy @ b_segGz a1_ae1TY)))
          (elems @ a_segGy @ b_segGz a1_ae1TY)

-- RHS size: {terms: 8, types: 12, coercions: 0, joins: 0/0}
Data.Data.$fDataArray_$cgfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data a, Data b, Ix a) =>
     forall (c :: * -> *).
     (forall d b1. Data d => c (d -> b1) -> d -> c b1)
     -> (forall g. g -> c g) -> Array a b -> c (Array a b)
[GblId,
 Arity=3,
 Str=<L,A><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,A,A,A,A,C(U(U)),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_segGy)
                 (@ b_segGz)
                 _ [Occ=Dead]
                 (w1_segGB [Occ=Once] :: Data b_segGz)
                 (w2_segGC [Occ=Once] :: Ix a_segGy) ->
                 Data.Data.$w$cgfoldl2 @ a_segGy @ b_segGz w1_segGB w2_segGC}]
Data.Data.$fDataArray_$cgfoldl
  = \ (@ a_segGy)
      (@ b_segGz)
      _ [Occ=Dead]
      (w1_segGB :: Data b_segGz)
      (w2_segGC :: Ix a_segGy) ->
      Data.Data.$w$cgfoldl2 @ a_segGy @ b_segGz w1_segGB w2_segGC

-- RHS size: {terms: 102, types: 181, coercions: 0, joins: 0/6}
Data.Data.$w$cgmapMp8 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data b, Ix a) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Array a b -> m (Array a b)
[GblId,
 Arity=5,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,A,A,A,A,C(U(U)),A)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U(U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 90 60 20] 725 0}]
Data.Data.$w$cgmapMp8
  = \ (@ a_segGF)
      (@ b_segGG)
      (w_segGI :: Data b_segGG)
      (w1_segGJ :: Ix a_segGF)
      (@ (m_segGK :: * -> *))
      (w2_segGL :: MonadPlus m_segGK)
      (w3_segGM :: forall d. Data d => d -> m_segGK d)
      (w4_segGN :: Array a_segGF b_segGG) ->
      let {
        lvl270_se9Y1 :: m_segGK (Array a_segGF b_segGG)
        [LclId]
        lvl270_se9Y1
          = mzero @ m_segGK w2_segGL @ (Array a_segGF b_segGG) } in
      let {
        $dMonad_se9ml [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_segGK
        [LclId]
        $dMonad_se9ml = GHC.Base.$p2MonadPlus @ m_segGK w2_segGL } in
      >>=
        @ m_segGK
        $dMonad_se9ml
        @ (Array a_segGF b_segGG, Bool)
        @ (Array a_segGF b_segGG)
        (let {
           y_se9mj :: [b_segGG]
           [LclId]
           y_se9mj
             = case w4_segGN of { Array ds_ibW8P ds1_ibW8Q dt_ibW8R ds2_ibW8S ->
               let {
                 y1_i819M [Dmd=<S,U>] :: Int#
                 [LclId]
                 y1_i819M = -# dt_ibW8R 1# } in
               case ># 0# y1_i819M of {
                 __DEFAULT ->
                   letrec {
                     go_i819O [Occ=LoopBreaker] :: Int# -> [b_segGG]
                     [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
                     go_i819O
                       = \ (x_i819P :: Int#) ->
                           GHC.Types.:
                             @ b_segGG
                             (case indexArray# @ b_segGG ds2_ibW8S x_i819P of
                              { (# ipv_ibW90 #) ->
                              ipv_ibW90
                              })
                             (case ==# x_i819P y1_i819M of {
                                __DEFAULT -> go_i819O (+# x_i819P 1#);
                                1# -> GHC.Types.[] @ b_segGG
                              }); } in
                   go_i819O 0#;
                 1# -> GHC.Types.[] @ b_segGG
               }
               } } in
         let {
           lvl271_se9Y0 :: m_segGK [b_segGG]
           [LclId]
           lvl271_se9Y0
             = w3_segGM
                 @ [b_segGG] (Data.Data.$fData[] @ b_segGG w_segGI) y_se9mj } in
         >>=
           @ m_segGK
           $dMonad_se9ml
           @ ([b_segGG] -> Array a_segGF b_segGG, Bool)
           @ (Array a_segGF b_segGG, Bool)
           (return
              @ m_segGK
              $dMonad_se9ml
              @ ([b_segGG] -> Array a_segGF b_segGG, Bool)
              (listArray
                 @ a_segGF @ b_segGG w1_segGJ (bounds @ a_segGF @ b_segGG w4_segGN),
               GHC.Types.False))
           (\ (ds_de7oD :: ([b_segGG] -> Array a_segGF b_segGG, Bool)) ->
              case ds_de7oD of { (h_ae1TA, b1_ae1TB) ->
              mplus
                @ m_segGK
                w2_segGL
                @ (Array a_segGF b_segGG, Bool)
                (>>=
                   @ m_segGK
                   $dMonad_se9ml
                   @ [b_segGG]
                   @ (Array a_segGF b_segGG, Bool)
                   lvl271_se9Y0
                   (\ (y'_ae1TC :: [b_segGG]) ->
                      return
                        @ m_segGK
                        $dMonad_se9ml
                        @ (Array a_segGF b_segGG, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_segGK
                   $dMonad_se9ml
                   @ (Array a_segGF b_segGG, Bool)
                   (h_ae1TA y_se9mj, b1_ae1TB))
              }))
        (\ (ds_de7oa :: (Array a_segGF b_segGG, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b1_ae1TE) ->
           case b1_ae1TE of {
             False -> lvl270_se9Y1;
             True ->
               return @ m_segGK $dMonad_se9ml @ (Array a_segGF b_segGG) x'_ae1TD
           }
           })

-- RHS size: {terms: 15, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataArray_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data a, Data b, Ix a) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Array a b -> m (Array a b)
[GblId,
 Arity=6,
 Str=<L,A><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,A,A,A,A,C(U(U)),A)><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U(U,U,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_segGF)
                 (@ b_segGG)
                 _ [Occ=Dead]
                 (w1_segGI [Occ=Once] :: Data b_segGG)
                 (w2_segGJ [Occ=Once] :: Ix a_segGF)
                 (@ (m_segGK :: * -> *))
                 (w3_segGL [Occ=Once] :: MonadPlus m_segGK)
                 (w4_segGM [Occ=Once] :: forall d. Data d => d -> m_segGK d)
                 (w5_segGN [Occ=Once] :: Array a_segGF b_segGG) ->
                 Data.Data.$w$cgmapMp8
                   @ a_segGF
                   @ b_segGG
                   w1_segGI
                   w2_segGJ
                   @ m_segGK
                   w3_segGL
                   w4_segGM
                   w5_segGN}]
Data.Data.$fDataArray_$cgmapMp
  = \ (@ a_segGF)
      (@ b_segGG)
      _ [Occ=Dead]
      (w1_segGI :: Data b_segGG)
      (w2_segGJ :: Ix a_segGF)
      (@ (m_segGK :: * -> *))
      (w3_segGL :: MonadPlus m_segGK)
      (w4_segGM :: forall d. Data d => d -> m_segGK d)
      (w5_segGN :: Array a_segGF b_segGG) ->
      Data.Data.$w$cgmapMp8
        @ a_segGF
        @ b_segGG
        w1_segGI
        w2_segGJ
        @ m_segGK
        w3_segGL
        w4_segGM
        w5_segGN

-- RHS size: {terms: 67, types: 92, coercions: 0, joins: 0/4}
Data.Data.$w$cgmapM7 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data b, Ix a) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Array a b -> m (Array a b)
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,A,A,A,A,C(U(U)),A)><L,U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 120 60] 435 60}]
Data.Data.$w$cgmapM7
  = \ (@ a_segGQ)
      (@ b_segGR)
      (w_segGT :: Data b_segGR)
      (w1_segGU :: Ix a_segGQ)
      (@ (m_segGV :: * -> *))
      (w2_segGW :: Monad m_segGV)
      (w3_segGX :: forall d. Data d => d -> m_segGV d) ->
      let {
        $dData_se9mf :: Data [b_segGR]
        [LclId]
        $dData_se9mf = Data.Data.$fData[] @ b_segGR w_segGT } in
      \ (a1_ae1TY :: Array a_segGQ b_segGR) ->
        let {
          lvl270_se9Y2 :: m_segGV [b_segGR]
          [LclId]
          lvl270_se9Y2
            = w3_segGX
                @ [b_segGR]
                $dData_se9mf
                (case a1_ae1TY of { Array ds_ibW8P ds1_ibW8Q dt_ibW8R ds2_ibW8S ->
                 let {
                   y_i819M [Dmd=<S,U>] :: Int#
                   [LclId]
                   y_i819M = -# dt_ibW8R 1# } in
                 case ># 0# y_i819M of {
                   __DEFAULT ->
                     letrec {
                       go_i819O [Occ=LoopBreaker] :: Int# -> [b_segGR]
                       [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
                       go_i819O
                         = \ (x_i819P :: Int#) ->
                             GHC.Types.:
                               @ b_segGR
                               (case indexArray# @ b_segGR ds2_ibW8S x_i819P of
                                { (# ipv_ibW90 #) ->
                                ipv_ibW90
                                })
                               (case ==# x_i819P y_i819M of {
                                  __DEFAULT -> go_i819O (+# x_i819P 1#);
                                  1# -> GHC.Types.[] @ b_segGR
                                }); } in
                     go_i819O 0#;
                   1# -> GHC.Types.[] @ b_segGR
                 }
                 }) } in
        >>=
          @ m_segGV
          w2_segGW
          @ ([b_segGR] -> Array a_segGQ b_segGR)
          @ (Array a_segGQ b_segGR)
          (return
             @ m_segGV
             w2_segGW
             @ ([b_segGR] -> Array a_segGQ b_segGR)
             (listArray
                @ a_segGQ
                @ b_segGR
                w1_segGU
                (bounds @ a_segGQ @ b_segGR a1_ae1TY)))
          (\ (c'_ae1To :: [b_segGR] -> Array a_segGQ b_segGR) ->
             >>=
               @ m_segGV
               w2_segGW
               @ [b_segGR]
               @ (Array a_segGQ b_segGR)
               lvl270_se9Y2
               (\ (x'_ae1Tp :: [b_segGR]) ->
                  return
                    @ m_segGV w2_segGW @ (Array a_segGQ b_segGR) (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 13, types: 26, coercions: 0, joins: 0/0}
Data.Data.$fDataArray_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data a, Data b, Ix a) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Array a b -> m (Array a b)
[GblId,
 Arity=5,
 Str=<L,A><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,A,A,A,A,C(U(U)),A)><L,U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_segGQ)
                 (@ b_segGR)
                 _ [Occ=Dead]
                 (w1_segGT [Occ=Once] :: Data b_segGR)
                 (w2_segGU [Occ=Once] :: Ix a_segGQ)
                 (@ (m_segGV :: * -> *))
                 (w3_segGW [Occ=Once] :: Monad m_segGV)
                 (w4_segGX [Occ=Once] :: forall d. Data d => d -> m_segGV d) ->
                 Data.Data.$w$cgmapM7
                   @ a_segGQ @ b_segGR w1_segGT w2_segGU @ m_segGV w3_segGW w4_segGX}]
Data.Data.$fDataArray_$cgmapM
  = \ (@ a_segGQ)
      (@ b_segGR)
      _ [Occ=Dead]
      (w1_segGT :: Data b_segGR)
      (w2_segGU :: Ix a_segGQ)
      (@ (m_segGV :: * -> *))
      (w3_segGW :: Monad m_segGV)
      (w4_segGX :: forall d. Data d => d -> m_segGV d) ->
      Data.Data.$w$cgmapM7
        @ a_segGQ @ b_segGR w1_segGT w2_segGU @ m_segGV w3_segGW w4_segGX

-- RHS size: {terms: 22, types: 31, coercions: 0, joins: 0/0}
Data.Data.$fDataArray_$cgmapQi
  :: forall a b.
     (Data a, Data b, Ix a) =>
     forall u. Int -> (forall d. Data d => d -> u) -> Array a b -> u
[GblId,
 Arity=6,
 Str=<L,A><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,A><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,1*U(A,A,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe69T)
                 (@ b_Xe69V)
                 _ [Occ=Dead]
                 ($dData1_Xe69Z [Occ=Once] :: Data b_Xe69V)
                 _ [Occ=Dead]
                 (@ u_ae5oH)
                 (ds_de7Gk [Occ=Once!] :: Int)
                 (ds1_de7Gl [Occ=Once!] :: forall d. Data d => d -> u_ae5oH)
                 (x_ae1T7 [Occ=Once] :: Array a_Xe69T b_Xe69V) ->
                 case ds_de7Gk of { I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_ae5oH;
                   0# ->
                     ds1_de7Gl
                       @ [b_Xe69V]
                       (Data.Data.$fData[] @ b_Xe69V $dData1_Xe69Z)
                       (elems @ a_Xe69T @ b_Xe69V x_ae1T7)
                 }
                 }}]
Data.Data.$fDataArray_$cgmapQi
  = \ (@ a_Xe69T)
      (@ b_Xe69V)
      _ [Occ=Dead]
      ($dData1_Xe69Z :: Data b_Xe69V)
      _ [Occ=Dead]
      (@ u_ae5oH)
      (ds_de7Gk :: Int)
      (ds1_de7Gl :: forall d. Data d => d -> u_ae5oH)
      (x_ae1T7 :: Array a_Xe69T b_Xe69V) ->
      case ds_de7Gk of { I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_ae5oH;
        0# ->
          ds1_de7Gl
            @ [b_Xe69V]
            (Data.Data.$fData[] @ b_Xe69V $dData1_Xe69Z)
            (elems @ a_Xe69T @ b_Xe69V x_ae1T7)
      }
      }

-- RHS size: {terms: 18, types: 32, coercions: 0, joins: 0/0}
Data.Data.$fDataArray_$cgmapQr
  :: forall a b.
     (Data a, Data b, Ix a) =>
     forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> Array a b -> r
[GblId,
 Arity=7,
 Str=<L,A><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,A><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,1*U(A,A,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=7,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe69R)
                 (@ b_Xe69T)
                 _ [Occ=Dead]
                 ($dData1_Xe69X [Occ=Once] :: Data b_Xe69T)
                 _ [Occ=Dead]
                 (@ r_ae5oc)
                 (@ r'_ae5od)
                 (ds_de7Gg [Occ=Once!] :: r'_ae5od -> r_ae5oc -> r_ae5oc)
                 (ds1_de7Gh [Occ=Once] :: r_ae5oc)
                 (ds2_de7Gi [Occ=Once!] :: forall d. Data d => d -> r'_ae5od)
                 (x0_ae1SX [Occ=Once] :: Array a_Xe69R b_Xe69T) ->
                 ds_de7Gg
                   (ds2_de7Gi
                      @ [b_Xe69T]
                      (Data.Data.$fData[] @ b_Xe69T $dData1_Xe69X)
                      (elems @ a_Xe69R @ b_Xe69T x0_ae1SX))
                   ds1_de7Gh}]
Data.Data.$fDataArray_$cgmapQr
  = \ (@ a_Xe69R)
      (@ b_Xe69T)
      _ [Occ=Dead]
      ($dData1_Xe69X :: Data b_Xe69T)
      _ [Occ=Dead]
      (@ r_ae5oc)
      (@ r'_ae5od)
      (ds_de7Gg :: r'_ae5od -> r_ae5oc -> r_ae5oc)
      (ds1_de7Gh :: r_ae5oc)
      (ds2_de7Gi :: forall d. Data d => d -> r'_ae5od)
      (x0_ae1SX :: Array a_Xe69R b_Xe69T) ->
      ds_de7Gg
        (ds2_de7Gi
           @ [b_Xe69T]
           (Data.Data.$fData[] @ b_Xe69T $dData1_Xe69X)
           (elems @ a_Xe69R @ b_Xe69T x0_ae1SX))
        ds1_de7Gh

-- RHS size: {terms: 15, types: 28, coercions: 0, joins: 0/0}
Data.Data.$fDataArray_$cgmapQ
  :: forall a b.
     (Data a, Data b, Ix a) =>
     forall u. (forall d. Data d => d -> u) -> Array a b -> [u]
[GblId,
 Arity=5,
 Str=<L,A><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,A><L,1*C1(C1(U))><L,1*U(A,A,U,U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe69S)
                 (@ b_Xe69U)
                 _ [Occ=Dead]
                 ($dData1_Xe69Y [Occ=Once] :: Data b_Xe69U)
                 _ [Occ=Dead]
                 (@ u_ae5ot)
                 (ds_de7Gj [Occ=Once!] :: forall d. Data d => d -> u_ae5ot)
                 (x0_ae1SX [Occ=Once] :: Array a_Xe69S b_Xe69U) ->
                 GHC.Types.:
                   @ u_ae5ot
                   (ds_de7Gj
                      @ [b_Xe69U]
                      (Data.Data.$fData[] @ b_Xe69U $dData1_Xe69Y)
                      (elems @ a_Xe69S @ b_Xe69U x0_ae1SX))
                   (GHC.Types.[] @ u_ae5ot)}]
Data.Data.$fDataArray_$cgmapQ
  = \ (@ a_Xe69S)
      (@ b_Xe69U)
      _ [Occ=Dead]
      ($dData1_Xe69Y :: Data b_Xe69U)
      _ [Occ=Dead]
      (@ u_ae5ot)
      (ds_de7Gj :: forall d. Data d => d -> u_ae5ot)
      (x0_ae1SX :: Array a_Xe69S b_Xe69U) ->
      GHC.Types.:
        @ u_ae5ot
        (ds_de7Gj
           @ [b_Xe69U]
           (Data.Data.$fData[] @ b_Xe69U $dData1_Xe69Y)
           (elems @ a_Xe69S @ b_Xe69U x0_ae1SX))
        (GHC.Types.[] @ u_ae5ot)

-- RHS size: {terms: 20, types: 35, coercions: 0, joins: 0/1}
Data.Data.$fDataArray_$cgmapQl
  :: forall a b.
     (Data a, Data b, Ix a) =>
     forall r r'.
     (r -> r' -> r)
     -> r -> (forall d. Data d => d -> r') -> Array a b -> r
[GblId,
 Arity=6,
 Str=<L,A><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,A><L,C(C1(U))><L,U><L,C(C1(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xe69Q)
                 (@ b_Xe69S)
                 _ [Occ=Dead]
                 ($dData1_Xe69W [Occ=OnceL] :: Data b_Xe69S)
                 _ [Occ=Dead]
                 (@ r_ae5nV)
                 (@ r'_ae5nW)
                 (ds_de7Gd [Occ=OnceL!] :: r_ae5nV -> r'_ae5nW -> r_ae5nV)
                 (ds1_de7Ge [Occ=OnceL] :: r_ae5nV)
                 (ds2_de7Gf [Occ=OnceL!] :: forall d. Data d => d -> r'_ae5nW) ->
                 let {
                   $dData2_se9m9 [Occ=OnceL] :: Data [b_Xe69S]
                   [LclId]
                   $dData2_se9m9 = Data.Data.$fData[] @ b_Xe69S $dData1_Xe69W } in
                 \ (x_i7Rxi [Occ=Once] :: Array a_Xe69Q b_Xe69S) ->
                   ds_de7Gd
                     ds1_de7Ge
                     (ds2_de7Gf
                        @ [b_Xe69S] $dData2_se9m9 (elems @ a_Xe69Q @ b_Xe69S x_i7Rxi))}]
Data.Data.$fDataArray_$cgmapQl
  = \ (@ a_Xe69Q)
      (@ b_Xe69S)
      _ [Occ=Dead]
      ($dData1_Xe69W :: Data b_Xe69S)
      _ [Occ=Dead]
      (@ r_ae5nV)
      (@ r'_ae5nW)
      (ds_de7Gd :: r_ae5nV -> r'_ae5nW -> r_ae5nV)
      (ds1_de7Ge :: r_ae5nV)
      (ds2_de7Gf :: forall d. Data d => d -> r'_ae5nW) ->
      let {
        $dData2_se9m9 :: Data [b_Xe69S]
        [LclId]
        $dData2_se9m9 = Data.Data.$fData[] @ b_Xe69S $dData1_Xe69W } in
      \ (x_i7Rxi :: Array a_Xe69Q b_Xe69S) ->
        ds_de7Gd
          ds1_de7Ge
          (ds2_de7Gf
             @ [b_Xe69S] $dData2_se9m9 (elems @ a_Xe69Q @ b_Xe69S x_i7Rxi))

-- RHS size: {terms: 137, types: 197, coercions: 0, joins: 2/4}
Data.Data.$w$cgmapT [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data b, Ix a) =>
     (forall b1. Data b1 => b1 -> b1)
     -> a -> a -> Int# -> Array# b -> Array a b
[GblId,
 Arity=7,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LLLLLC(S(S))L),1*U(A,A,A,A,A,1*C1(U(U)),A)><L,1*C1(C1(U))><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 30 60 0 0 0 0] 383 0}]
Data.Data.$w$cgmapT
  = \ (@ a_segH4)
      (@ b_segH5)
      (w_segH7 :: Data b_segH5)
      (w1_segH8 :: Ix a_segH4)
      (w2_segH9 :: forall b1. Data b1 => b1 -> b1)
      (ww_segHd
         :: a_segH4
         Unf=OtherCon [])
      (ww1_segHe
         :: a_segH4
         Unf=OtherCon [])
      (ww2_segHf :: Int#)
      (ww3_segHg :: Array# b_segH5) ->
      case runRW#
             @ ('TupleRep '['TupleRep '[], 'LiftedRep])
             @ (# State# RealWorld, Array a_segH4 b_segH5 #)
             (\ (s1#_iawUe [OS=OneShot] :: State# RealWorld) ->
                case rangeSize @ a_segH4 w1_segH8 (ww_segHd, ww1_segHe) of
                { I# x_alN9 ->
                case <# x_alN9 0# of {
                  __DEFAULT ->
                    case newArray#
                           @ b_segH5 @ RealWorld x_alN9 (arrEleBottom @ b_segH5) s1#_iawUe
                    of
                    { (# ipv_iawUt, ipv1_iawUu #) ->
                    case x_alN9 of wild1_X17k {
                      __DEFAULT ->
                        join {
                          $j_seeTt [Dmd=<C(S),C(U)>]
                            :: State# RealWorld
                               -> (# State# RealWorld, Array a_segH4 b_segH5 #)
                          [LclId[JoinId(1)], Arity=1, Str=<S,U>]
                          $j_seeTt (wild4_iawUH [OS=OneShot]
                                      :: State# RealWorld
                                      Unf=OtherCon [])
                            = case unsafeFreezeArray#
                                     @ RealWorld @ b_segH5 ipv1_iawUu wild4_iawUH
                              of
                              { (# ipv2_iawUK, ipv3_iawUL #) ->
                              (# ipv2_iawUK,
                                 GHC.Arr.Array
                                   @ a_segH4 @ b_segH5 ww_segHd ww1_segHe wild1_X17k ipv3_iawUL #)
                              } } in
                        joinrec {
                          go_i7Jcj [Occ=LoopBreaker]
                            :: [b_segH5]
                               -> Int#
                               -> State# RealWorld
                               -> (# State# RealWorld, Array a_segH4 b_segH5 #)
                          [LclId[JoinId(3)], Arity=3, Str=<S,1*U><L,U><S,U>, Unf=OtherCon []]
                          go_i7Jcj (ds_i7Jck :: [b_segH5])
                                   (eta_B2 :: Int#)
                                   (eta1_B1 :: State# RealWorld)
                            = case ds_i7Jck of {
                                [] -> jump $j_seeTt eta1_B1;
                                : y_i7Jcp ys_i7Jcq ->
                                  case writeArray#
                                         @ RealWorld @ b_segH5 ipv1_iawUu eta_B2 y_i7Jcp eta1_B1
                                  of s4#_iawUD
                                  { __DEFAULT ->
                                  case ==# eta_B2 (-# wild1_X17k 1#) of {
                                    __DEFAULT -> jump go_i7Jcj ys_i7Jcq (+# eta_B2 1#) s4#_iawUD;
                                    1# -> jump $j_seeTt s4#_iawUD
                                  }
                                  }
                              }; } in
                        jump go_i7Jcj
                          (w2_segH9
                             @ [b_segH5]
                             (Data.Data.$fData[] @ b_segH5 w_segH7)
                             (let {
                                y_i819M [Dmd=<S,U>] :: Int#
                                [LclId]
                                y_i819M = -# ww2_segHf 1# } in
                              case ># 0# y_i819M of {
                                __DEFAULT ->
                                  letrec {
                                    go61_i819O [Occ=LoopBreaker] :: Int# -> [b_segH5]
                                    [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
                                    go61_i819O
                                      = \ (x1_i819P :: Int#) ->
                                          GHC.Types.:
                                            @ b_segH5
                                            (case indexArray# @ b_segH5 ww3_segHg x1_i819P of
                                             { (# ipv2_ibW90 #) ->
                                             ipv2_ibW90
                                             })
                                            (case ==# x1_i819P y_i819M of {
                                               __DEFAULT -> go61_i819O (+# x1_i819P 1#);
                                               1# -> GHC.Types.[] @ b_segH5
                                             }); } in
                                  go61_i819O 0#;
                                1# -> GHC.Types.[] @ b_segH5
                              }))
                          0#
                          ipv_iawUt;
                      0# ->
                        case unsafeFreezeArray# @ RealWorld @ b_segH5 ipv1_iawUu ipv_iawUt
                        of
                        { (# ipv2_iawUR, ipv3_iawUS #) ->
                        (# ipv2_iawUR,
                           GHC.Arr.Array
                             @ a_segH4 @ b_segH5 ww_segHd ww1_segHe 0# ipv3_iawUS #)
                        }
                    }
                    };
                  1# -> case negRange of wild1_00 { }
                }
                })
      of
      { (# ipv_iawUX, ipv1_iawUY #) ->
      ipv1_iawUY
      }

-- RHS size: {terms: 18, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataArray1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data a, Data b, Ix a) =>
     (forall b1. Data b1 => b1 -> b1) -> Array a b -> Array a b
[GblId,
 Arity=5,
 Str=<L,A><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LLLLLC(S(S))L),1*U(A,A,A,A,A,1*C1(U(U)),A)><L,1*C1(C1(U))><S(SSSS),1*U(U,U,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_segH4)
                 (@ b_segH5)
                 _ [Occ=Dead]
                 (w1_segH7 [Occ=Once] :: Data b_segH5)
                 (w2_segH8 [Occ=Once] :: Ix a_segH4)
                 (w3_segH9 [Occ=Once] :: forall b1. Data b1 => b1 -> b1)
                 (w4_segHa [Occ=Once!] :: Array a_segH4 b_segH5) ->
                 case w4_segHa of
                 { Array ww1_segHd [Occ=Once] ww2_segHe [Occ=Once]
                         ww3_segHf [Occ=Once] ww4_segHg [Occ=Once] ->
                 Data.Data.$w$cgmapT
                   @ a_segH4
                   @ b_segH5
                   w1_segH7
                   w2_segH8
                   w3_segH9
                   ww1_segHd
                   ww2_segHe
                   ww3_segHf
                   ww4_segHg
                 }}]
Data.Data.$fDataArray1
  = \ (@ a_segH4)
      (@ b_segH5)
      _ [Occ=Dead]
      (w1_segH7 :: Data b_segH5)
      (w2_segH8 :: Ix a_segH4)
      (w3_segH9 :: forall b1. Data b1 => b1 -> b1)
      (w4_segHa :: Array a_segH4 b_segH5) ->
      case w4_segHa of { Array ww1_segHd ww2_segHe ww3_segHf ww4_segHg ->
      Data.Data.$w$cgmapT
        @ a_segH4
        @ b_segH5
        w1_segH7
        w2_segH8
        w3_segH9
        ww1_segHd
        ww2_segHe
        ww3_segHf
        ww4_segHg
      }

-- RHS size: {terms: 112, types: 192, coercions: 0, joins: 0/6}
Data.Data.$w$cgmapMo7 [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data b, Ix a) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Array a b -> m (Array a b)
[GblId,
 Arity=5,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,A,A,A,A,C(U(U)),A)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U(U,U,U,U)>,
 Unf=OtherCon []]
Data.Data.$w$cgmapMo7
  = \ (@ a_segHk)
      (@ b_segHl)
      (w_segHn :: Data b_segHl)
      (w1_segHo :: Ix a_segHk)
      (@ (m_segHp :: * -> *))
      (w2_segHq :: MonadPlus m_segHp)
      (w3_segHr :: forall d. Data d => d -> m_segHp d)
      (w4_segHs :: Array a_segHk b_segHl) ->
      let {
        lvl270_se9Y8 :: m_segHp (Array a_segHk b_segHl)
        [LclId]
        lvl270_se9Y8
          = mzero @ m_segHp w2_segHq @ (Array a_segHk b_segHl) } in
      let {
        $dMonad_se9m5 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_segHp
        [LclId]
        $dMonad_se9m5 = GHC.Base.$p2MonadPlus @ m_segHp w2_segHq } in
      >>=
        @ m_segHp
        $dMonad_se9m5
        @ (Array a_segHk b_segHl, Bool)
        @ (Array a_segHk b_segHl)
        (let {
           y_se9m3 :: [b_segHl]
           [LclId]
           y_se9m3
             = case w4_segHs of { Array ds_ibW8P ds1_ibW8Q dt_ibW8R ds2_ibW8S ->
               let {
                 y1_i819M [Dmd=<S,U>] :: Int#
                 [LclId]
                 y1_i819M = -# dt_ibW8R 1# } in
               case ># 0# y1_i819M of {
                 __DEFAULT ->
                   letrec {
                     go_i819O [Occ=LoopBreaker] :: Int# -> [b_segHl]
                     [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []]
                     go_i819O
                       = \ (x_i819P :: Int#) ->
                           GHC.Types.:
                             @ b_segHl
                             (case indexArray# @ b_segHl ds2_ibW8S x_i819P of
                              { (# ipv_ibW90 #) ->
                              ipv_ibW90
                              })
                             (case ==# x_i819P y1_i819M of {
                                __DEFAULT -> go_i819O (+# x_i819P 1#);
                                1# -> GHC.Types.[] @ b_segHl
                              }); } in
                   go_i819O 0#;
                 1# -> GHC.Types.[] @ b_segHl
               }
               } } in
         let {
           lvl271_se9Y7 :: m_segHp [b_segHl]
           [LclId]
           lvl271_se9Y7
             = w3_segHr
                 @ [b_segHl] (Data.Data.$fData[] @ b_segHl w_segHn) y_se9m3 } in
         >>=
           @ m_segHp
           $dMonad_se9m5
           @ ([b_segHl] -> Array a_segHk b_segHl, Bool)
           @ (Array a_segHk b_segHl, Bool)
           (return
              @ m_segHp
              $dMonad_se9m5
              @ ([b_segHl] -> Array a_segHk b_segHl, Bool)
              (listArray
                 @ a_segHk @ b_segHl w1_segHo (bounds @ a_segHk @ b_segHl w4_segHs),
               GHC.Types.False))
           (\ (ds_de7pD :: ([b_segHl] -> Array a_segHk b_segHl, Bool)) ->
              case ds_de7pD of { (h_ae1TP, b1_ae1TQ) ->
              case b1_ae1TQ of {
                False ->
                  mplus
                    @ m_segHp
                    w2_segHq
                    @ (Array a_segHk b_segHl, Bool)
                    (>>=
                       @ m_segHp
                       $dMonad_se9m5
                       @ [b_segHl]
                       @ (Array a_segHk b_segHl, Bool)
                       lvl271_se9Y7
                       (\ (y'_ae1TR :: [b_segHl]) ->
                          return
                            @ m_segHp
                            $dMonad_se9m5
                            @ (Array a_segHk b_segHl, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_segHp
                       $dMonad_se9m5
                       @ (Array a_segHk b_segHl, Bool)
                       (h_ae1TP y_se9m3, GHC.Types.False));
                True ->
                  return
                    @ m_segHp
                    $dMonad_se9m5
                    @ (Array a_segHk b_segHl, Bool)
                    (h_ae1TP y_se9m3, GHC.Types.True)
              }
              }))
        (\ (ds_de7pa :: (Array a_segHk b_segHl, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b1_ae1TT) ->
           case b1_ae1TT of {
             False -> lvl270_se9Y8;
             True ->
               return @ m_segHp $dMonad_se9m5 @ (Array a_segHk b_segHl) x'_ae1TS
           }
           })

-- RHS size: {terms: 15, types: 29, coercions: 0, joins: 0/0}
Data.Data.$fDataArray_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data a, Data b, Ix a) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Array a b -> m (Array a b)
[GblId,
 Arity=6,
 Str=<L,A><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,A,A,A,A,C(U(U)),A)><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U(U,U,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_segHk)
                 (@ b_segHl)
                 _ [Occ=Dead]
                 (w1_segHn [Occ=Once] :: Data b_segHl)
                 (w2_segHo [Occ=Once] :: Ix a_segHk)
                 (@ (m_segHp :: * -> *))
                 (w3_segHq [Occ=Once] :: MonadPlus m_segHp)
                 (w4_segHr [Occ=Once] :: forall d. Data d => d -> m_segHp d)
                 (w5_segHs [Occ=Once] :: Array a_segHk b_segHl) ->
                 Data.Data.$w$cgmapMo7
                   @ a_segHk
                   @ b_segHl
                   w1_segHn
                   w2_segHo
                   @ m_segHp
                   w3_segHq
                   w4_segHr
                   w5_segHs}]
Data.Data.$fDataArray_$cgmapMo
  = \ (@ a_segHk)
      (@ b_segHl)
      _ [Occ=Dead]
      (w1_segHn :: Data b_segHl)
      (w2_segHo :: Ix a_segHk)
      (@ (m_segHp :: * -> *))
      (w3_segHq :: MonadPlus m_segHp)
      (w4_segHr :: forall d. Data d => d -> m_segHp d)
      (w5_segHs :: Array a_segHk b_segHl) ->
      Data.Data.$w$cgmapMo7
        @ a_segHk
        @ b_segHl
        w1_segHn
        w2_segHo
        @ m_segHp
        w3_segHq
        w4_segHr
        w5_segHs

-- RHS size: {terms: 7, types: 29, coercions: 0, joins: 0/0}
lvl265_rejWJ
  :: forall a b (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Array a b))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl265_rejWJ
  = \ (@ a_Xe69N)
      (@ b_Xe72F)
      (@ (t_ae5n5 :: * -> *))
      (@ (c_ae5n6 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_ae5n6 (Array a_Xe69N b_Xe72F))

-- RHS size: {terms: 7, types: 30, coercions: 0, joins: 0/0}
lvl266_rejWK
  :: forall a b (c :: * -> *).
     (forall b1 r. Data b1 => c (b1 -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c (Array a b)
[GblId, Arity=2, Str=<B,A><B,A>x, Unf=OtherCon []]
lvl266_rejWK
  = \ (@ a_Xe69N)
      (@ b_Xe72F)
      (@ (c_ae5mO :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      errorWithoutStackTrace
        @ 'LiftedRep
        @ (Constr -> c_ae5mO (Array a_Xe69N b_Xe72F))
        Data.Data.$fDataArray8

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
lvl267_rejWL :: forall a b. Array a b -> Constr
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []]
lvl267_rejWL
  = \ (@ a_Xe69N) (@ b_Xe72F) _ [Occ=Dead] ->
      errorWithoutStackTrace @ 'LiftedRep @ Constr Data.Data.$fDataArray6

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
lvl268_rejWM :: forall a b. Array a b -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl268_rejWM
  = \ (@ a_Xe69N) (@ b_Xe72F) _ [Occ=Dead] -> Data.Data.$fDataArray3

-- RHS size: {terms: 69, types: 91, coercions: 7, joins: 0/0}
Data.Data.$fDataArray [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. (Data a, Data b, Ix a) => Data (Array a b)
[GblId[DFunId],
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,A,A,A,A,C(U(U)),A)>,
 Unf=DFun: \ (@ a_ae1TU)
             (@ b_ae1TV)
             (v_XSS :: Data a_ae1TU)
             (v1_XSU :: Data b_ae1TV)
             (v2_XSW :: Ix a_ae1TU) ->
       Data.Data.C:Data TYPE: Array a_ae1TU b_ae1TV
                        (Data.Data.$fDataArray10 @ a_ae1TU @ b_ae1TV v_XSS v1_XSU v2_XSW)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Array
                                                                                    a_ae1TU
                                                                                    b_ae1TV>_N
                                :: (Data.Typeable.Internal.TypeRep (Array a_ae1TU b_ae1TV) :: *)
                                   ~R# (Typeable (Array a_ae1TU b_ae1TV) :: Constraint))
                        Data.Data.$fDataArray_$cgfoldl
                          @ a_ae1TU @ b_ae1TV v_XSS v1_XSU v2_XSW
                        \ (@ (c_ae5mO :: * -> *)) _ [Occ=Dead] _ [Occ=Dead] ->
                          errorWithoutStackTrace
                            @ 'LiftedRep
                            @ (Constr -> c_ae5mO (Array a_ae1TU b_ae1TV))
                            Data.Data.$fDataArray8
                        \ _ [Occ=Dead] ->
                          errorWithoutStackTrace @ 'LiftedRep @ Constr Data.Data.$fDataArray6
                        \ _ [Occ=Dead] -> Data.Data.$fDataArray3
                        \ (@ (t_ae5n5 :: * -> *))
                          (@ (c_ae5n6 :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_ae5n6 (Array a_ae1TU b_ae1TV))
                        Data.Data.$fDataArray_$cdataCast2
                          @ a_ae1TU @ b_ae1TV v_XSS v1_XSU v2_XSW
                        Data.Data.$fDataArray1 @ a_ae1TU @ b_ae1TV v_XSS v1_XSU v2_XSW
                        Data.Data.$fDataArray_$cgmapQl
                          @ a_ae1TU @ b_ae1TV v_XSS v1_XSU v2_XSW
                        Data.Data.$fDataArray_$cgmapQr
                          @ a_ae1TU @ b_ae1TV v_XSS v1_XSU v2_XSW
                        Data.Data.$fDataArray_$cgmapQ
                          @ a_ae1TU @ b_ae1TV v_XSS v1_XSU v2_XSW
                        Data.Data.$fDataArray_$cgmapQi
                          @ a_ae1TU @ b_ae1TV v_XSS v1_XSU v2_XSW
                        Data.Data.$fDataArray_$cgmapM
                          @ a_ae1TU @ b_ae1TV v_XSS v1_XSU v2_XSW
                        Data.Data.$fDataArray_$cgmapMp
                          @ a_ae1TU @ b_ae1TV v_XSS v1_XSU v2_XSW
                        Data.Data.$fDataArray_$cgmapMo
                          @ a_ae1TU @ b_ae1TV v_XSS v1_XSU v2_XSW]
Data.Data.$fDataArray
  = \ (@ a_Xe69N)
      (@ b_Xe72F)
      ($dData_Xe72I :: Data a_Xe69N)
      ($dData1_Xe72L :: Data b_Xe72F)
      ($dIx_Xe72O :: Ix a_Xe69N) ->
      Data.Data.C:Data
        @ (Array a_Xe69N b_Xe72F)
        ((Data.Data.$fDataArray10
            @ a_Xe69N @ b_Xe72F $dData_Xe72I $dData1_Xe72L $dIx_Xe72O)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Array
                                                                     a_Xe69N b_Xe72F>_N
                 :: (Data.Typeable.Internal.TypeRep (Array a_Xe69N b_Xe72F) :: *)
                    ~R# (Typeable (Array a_Xe69N b_Xe72F) :: Constraint)))
        (Data.Data.$w$cgfoldl2
           @ a_Xe69N @ b_Xe72F $dData1_Xe72L $dIx_Xe72O)
        (lvl266_rejWK @ a_Xe69N @ b_Xe72F)
        (lvl267_rejWL @ a_Xe69N @ b_Xe72F)
        (lvl268_rejWM @ a_Xe69N @ b_Xe72F)
        (lvl265_rejWJ @ a_Xe69N @ b_Xe72F)
        (Data.Data.$fDataArray_$cdataCast2
           @ a_Xe69N @ b_Xe72F $dData_Xe72I $dData1_Xe72L $dIx_Xe72O)
        (Data.Data.$fDataArray1
           @ a_Xe69N @ b_Xe72F $dData_Xe72I $dData1_Xe72L $dIx_Xe72O)
        (Data.Data.$fDataArray_$cgmapQl
           @ a_Xe69N @ b_Xe72F $dData_Xe72I $dData1_Xe72L $dIx_Xe72O)
        (Data.Data.$fDataArray_$cgmapQr
           @ a_Xe69N @ b_Xe72F $dData_Xe72I $dData1_Xe72L $dIx_Xe72O)
        (Data.Data.$fDataArray_$cgmapQ
           @ a_Xe69N @ b_Xe72F $dData_Xe72I $dData1_Xe72L $dIx_Xe72O)
        (Data.Data.$fDataArray_$cgmapQi
           @ a_Xe69N @ b_Xe72F $dData_Xe72I $dData1_Xe72L $dIx_Xe72O)
        (\ (@ (m_segGV :: * -> *))
           (w_segGW :: Monad m_segGV)
           (w1_segGX :: forall d. Data d => d -> m_segGV d) ->
           Data.Data.$w$cgmapM7
             @ a_Xe69N
             @ b_Xe72F
             $dData1_Xe72L
             $dIx_Xe72O
             @ m_segGV
             w_segGW
             w1_segGX)
        (\ (@ (m_segGK :: * -> *))
           (w_segGL :: MonadPlus m_segGK)
           (w1_segGM :: forall d. Data d => d -> m_segGK d)
           (w2_segGN :: Array a_Xe69N b_Xe72F) ->
           Data.Data.$w$cgmapMp8
             @ a_Xe69N
             @ b_Xe72F
             $dData1_Xe72L
             $dIx_Xe72O
             @ m_segGK
             w_segGL
             w1_segGM
             w2_segGN)
        (\ (@ (m_segHp :: * -> *))
           (w_segHq :: MonadPlus m_segHp)
           (w1_segHr :: forall d. Data d => d -> m_segHp d)
           (w2_segHs :: Array a_Xe69N b_Xe72F) ->
           Data.Data.$w$cgmapMo7
             @ a_Xe69N
             @ b_Xe72F
             $dData1_Xe72L
             $dIx_Xe72O
             @ m_segHp
             w_segHq
             w1_segHr
             w2_segHs)

-- RHS size: {terms: 10, types: 4, coercions: 0, joins: 0/0}
lvl269_rejWN :: Char -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)>,
 Unf=OtherCon []]
lvl269_rejWN
  = \ (x_i7Rxi :: Char) ->
      case x_i7Rxi of { C# y_a5il ->
      case y_a5il of {
        __DEFAULT -> GHC.Types.True;
        '.'# -> GHC.Types.False
      }
      }

Rec {
-- RHS size: {terms: 20, types: 15, coercions: 0, joins: 0/1}
tyconUQname [Occ=LoopBreaker] :: String -> String
[GblId, Arity=1, Str=<S,U>, Unf=OtherCon []]
tyconUQname
  = \ (x_ae1WI :: String) ->
      let {
        x'_se9lX [Dmd=<S,U>] :: [Char]
        [LclId]
        x'_se9lX = dropWhile @ Char lvl269_rejWN x_ae1WI } in
      case eqString x'_se9lX (GHC.Types.[] @ Char) of {
        False ->
          case x'_se9lX of {
            [] -> case GHC.List.scanl2 of wild2_00 { };
            : ds1_ibGtk xs_ibGtl -> tyconUQname xs_ibGtl
          };
        True -> x_ae1WI
      }
end Rec }


------ Local rules for imported ids --------
"SPEC $cdataCast1 @ Int"
    forall ($dData_se9x9 :: Data Int).
      Data.Data.$fData[]_$cdataCast1 @ Int $dData_se9x9
      = Data.Data.$fData[]_$s$cdataCast2
"SPEC $cdataCast1 @ Char"
    forall ($dData_se9x5 :: Data Char).
      Data.Data.$fData[]_$cdataCast1 @ Char $dData_se9x5
      = Data.Data.$fData[]_$s$cdataCast1
"SPEC $fData[] @ Int"
    forall ($dData_se9ns :: Data Int).
      Data.Data.$fData[] @ Int $dData_se9ns
      = Data.Data.$fData[]_$s$fData[]1
"SPEC $fData[] @ Char"
    forall ($dData_se9nq :: Data Char).
      Data.Data.$fData[] @ Char $dData_se9nq
      = Data.Data.$fData[]_$s$fData[]
"SPEC $cgmapM @ Int"
    forall ($dData_se9nQ :: Data Int).
      Data.Data.$fData[]_$cgmapM @ Int $dData_se9nQ
      = Data.Data.$fData[]_$s$cgmapM1
"SPEC $cgmapM @ Char"
    forall ($dData_se9nM :: Data Char).
      Data.Data.$fData[]_$cgmapM @ Char $dData_se9nM
      = Data.Data.$fData[]_$s$cgmapM
"SPEC $cgmapT @ Int"
    forall ($dData_se9nY :: Data Int).
      Data.Data.$fData[]_$cgmapT @ Int $dData_se9nY
      = Data.Data.$fData[]_$s$cgmapT1
"SPEC $cgmapT @ Char"
    forall ($dData_se9nU :: Data Char).
      Data.Data.$fData[]_$cgmapT @ Char $dData_se9nU
      = Data.Data.$fData[]_$s$cgmapT
"SPEC $cgmapQl @ Int"
    forall ($dData_se9o6 :: Data Int).
      Data.Data.$fData[]_$cgmapQl @ Int $dData_se9o6
      = Data.Data.$fData[]5
"SPEC $cgmapQl @ Char"
    forall ($dData_se9o2 :: Data Char).
      Data.Data.$fData[]_$cgmapQl @ Char $dData_se9o2
      = Data.Data.$fData[]4
"SPEC $cgmapQr @ Int"
    forall ($dData_se9oq :: Data Int).
      Data.Data.$fData[]_$cgmapQr @ Int $dData_se9oq
      = Data.Data.$fData[]_$s$cgmapQr1
"SPEC $cgmapQr @ Char"
    forall ($dData_se9oo :: Data Char).
      Data.Data.$fData[]_$cgmapQr @ Char $dData_se9oo
      = Data.Data.$fData[]_$s$cgmapQr
"SPEC $cgmapQ @ Int"
    forall ($dData_se9ow :: Data Int).
      Data.Data.$fData[]_$cgmapQ @ Int $dData_se9ow
      = Data.Data.$fData[]_$s$cgmapQ1
"SPEC $cgmapQ @ Char"
    forall ($dData_se9os :: Data Char).
      Data.Data.$fData[]_$cgmapQ @ Char $dData_se9os
      = Data.Data.$fData[]_$s$cgmapQ
"SPEC $cgfoldl @ Int"
    forall ($dData_se9oe :: Data Int).
      Data.Data.$fData[]_$cgfoldl @ Int $dData_se9oe
      = Data.Data.$fData[]_$s$cgfoldl1
"SPEC $cgfoldl @ Char"
    forall ($dData_se9oa :: Data Char).
      Data.Data.$fData[]_$cgfoldl @ Char $dData_se9oa
      = Data.Data.$fData[]_$s$cgfoldl
"SPEC $cgmapQi @ Int"
    forall ($dData_se9oC :: Data Int).
      Data.Data.$fData[]_$cgmapQi @ Int $dData_se9oC
      = Data.Data.$fData[]_$s$cgmapQi1
"SPEC $cgmapQi @ Char"
    forall ($dData_se9oA :: Data Char).
      Data.Data.$fData[]_$cgmapQi @ Char $dData_se9oA
      = Data.Data.$fData[]_$s$cgmapQi
"SPEC $cgunfold @ Int"
    forall ($dData_se9oI :: Data Int).
      Data.Data.$fData[]_$cgunfold @ Int $dData_se9oI
      = Data.Data.$fData[]_$s$cgunfold1
"SPEC $cgunfold @ Char"
    forall ($dData_se9oE :: Data Char).
      Data.Data.$fData[]_$cgunfold @ Char $dData_se9oE
      = Data.Data.$fData[]_$s$cgunfold
"SPEC $cgmapMp @ Int"
    forall ($dData_se9nI :: Data Int).
      Data.Data.$fData[]_$cgmapMp @ Int $dData_se9nI
      = Data.Data.$fData[]_$s$cgmapMp1
"SPEC $cgmapMp @ Char"
    forall ($dData_se9nE :: Data Char).
      Data.Data.$fData[]_$cgmapMp @ Char $dData_se9nE
      = Data.Data.$fData[]_$s$cgmapMp
"SPEC $cgmapMo @ Int"
    forall ($dData_se9nA :: Data Int).
      Data.Data.$fData[]_$cgmapMo @ Int $dData_se9nA
      = Data.Data.$fData[]_$s$cgmapMo1
"SPEC $cgmapMo @ Char"
    forall ($dData_se9nw :: Data Char).
      Data.Data.$fData[]_$cgmapMo @ Char $dData_se9nw
      = Data.Data.$fData[]_$s$cgmapMo

