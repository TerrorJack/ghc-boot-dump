
==================== Output Cmm ====================
2018-03-16 16:06:57.934540305 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:57.935572484 UTC

[section ""data" . Data.Version.$fGenericVersion_$cto_closure" {
     Data.Version.$fGenericVersion_$cto_closure:
         const Data.Version.$fGenericVersion_$cto_info;
 },
 Data.Version.$fGenericVersion_$cto_entry() //  [R2]
         { info_tbl: [(cc440,
                       label: Data.Version.$fGenericVersion_$cto_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc440: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc444; else goto cc445;
       cc444: // global
           R2 = R2;
           R1 = Data.Version.$fGenericVersion_$cto_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc445: // global
           I64[Sp - 8] = block_cc43Y_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc43Y() //  [R1]
         { info_tbl: [(cc43Y,
                       label: block_cc43Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc43Y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc448; else goto cc447;
       cc448: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc447: // global
           _sc3YF::P64 = P64[R1 + 7];
           _sc3YG::P64 = P64[R1 + 15];
           I64[Hp - 16] = Data.Version.Version_con_info;
           P64[Hp - 8] = _sc3YF::P64;
           P64[Hp] = _sc3YG::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.936949288 UTC

[section ""data" . Data.Version.$fGenericVersion1_closure" {
     Data.Version.$fGenericVersion1_closure:
         const Data.Version.$fGenericVersion1_info;
 },
 Data.Version.$fGenericVersion1_entry() //  [R2]
         { info_tbl: [(cc44g,
                       label: Data.Version.$fGenericVersion1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc44g: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc44k; else goto cc44l;
       cc44k: // global
           R2 = R2;
           R1 = Data.Version.$fGenericVersion1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc44l: // global
           I64[Sp - 8] = block_cc44d_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc44p; else goto cc44e;
       uc44p: // global
           call _cc44d(R1) args: 0, res: 0, upd: 0;
       cc44e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc44d() //  [R1]
         { info_tbl: [(cc44d,
                       label: block_cc44d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc44d: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc44o; else goto cc44n;
       cc44o: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc44n: // global
           _sc3YJ::P64 = P64[R1 + 7];
           _sc3YK::P64 = P64[R1 + 15];
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = _sc3YJ::P64;
           P64[Hp] = _sc3YK::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.938025113 UTC

[section ""data" . Data.Version.$fGenericVersion_closure" {
     Data.Version.$fGenericVersion_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Version.$fGenericVersion1_closure+1;
         const Data.Version.$fGenericVersion_$cto_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.938816738 UTC

[section ""data" . Data.Version.versionTags_closure" {
     Data.Version.versionTags_closure:
         const Data.Version.versionTags_info;
 },
 Data.Version.versionTags_entry() //  [R2]
         { info_tbl: [(cc44x,
                       label: Data.Version.versionTags_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc44x: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc44y; else goto cc44z;
       cc44y: // global
           R2 = R2;
           R1 = Data.Version.versionTags_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc44z: // global
           I64[Sp - 8] = block_cc44u_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc44D; else goto cc44v;
       uc44D: // global
           call _cc44u(R1) args: 0, res: 0, upd: 0;
       cc44v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc44u() //  [R1]
         { info_tbl: [(cc44u,
                       label: block_cc44u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc44u: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.939949351 UTC

[section ""data" . Data.Version.versionBranch_closure" {
     Data.Version.versionBranch_closure:
         const Data.Version.versionBranch_info;
 },
 Data.Version.versionBranch_entry() //  [R2]
         { info_tbl: [(cc44L,
                       label: Data.Version.versionBranch_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc44L: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc44M; else goto cc44N;
       cc44M: // global
           R2 = R2;
           R1 = Data.Version.versionBranch_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc44N: // global
           I64[Sp - 8] = block_cc44I_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc44R; else goto cc44J;
       uc44R: // global
           call _cc44I(R1) args: 0, res: 0, upd: 0;
       cc44J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc44I() //  [R1]
         { info_tbl: [(cc44I,
                       label: block_cc44I_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc44I: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.941175269 UTC

[section ""data" . Data.Version.$fOrdVersion_$ccompare_closure" {
     Data.Version.$fOrdVersion_$ccompare_closure:
         const Data.Version.$fOrdVersion_$ccompare_info;
 },
 Data.Version.$fOrdVersion_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(cc44Z,
                       label: Data.Version.$fOrdVersion_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc44Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc453; else goto cc454;
       cc453: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc454: // global
           I64[Sp - 16] = block_cc44W_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc45c; else goto cc44X;
       uc45c: // global
           call _cc44W(R1) args: 0, res: 0, upd: 0;
       cc44X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc44W() //  [R1]
         { info_tbl: [(cc44W,
                       label: block_cc44W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc44W: // global
           I64[Sp] = block_cc452_info;
           _sc3YW::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sc3YW::P64;
           if (R1 & 7 != 0) goto uc45b; else goto cc456;
       uc45b: // global
           call _cc452(R1) args: 0, res: 0, upd: 0;
       cc456: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc452() //  [R1]
         { info_tbl: [(cc452,
                       label: block_cc452_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc452: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.942703814 UTC

[section ""data" . Data.Version.$w$c==_closure" {
     Data.Version.$w$c==_closure:
         const Data.Version.$w$c==_info;
 },
 Data.Version.$w$c==_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc45n,
                       label: Data.Version.$w$c==_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc45n: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc45o; else goto cc45p;
       cc45o: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$w$c==_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc45p: // global
           I64[Sp - 24] = block_cc45h_info;
           _sc3Z2::P64 = R3;
           R3 = R4;
           R2 = R2;
           P64[Sp - 16] = _sc3Z2::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call GHC.Classes.$fEq[]_$s$c==_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc45h() //  [R1]
         { info_tbl: [(cc45h,
                       label: block_cc45h_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc45h: // global
           if (R1 & 7 == 1) goto cc45k; else goto cc45l;
       cc45k: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc45l: // global
           I64[Sp] = block_cc45v_info;
           R3 = P64[Sp + 16];
           R2 = GHC.Classes.$fOrd[]_$s$ccompare1_closure+2;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc45v() //  [R1]
         { info_tbl: [(cc45v,
                       label: block_cc45v_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc45v: // global
           _sc3Z2::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc45z_info;
           R3 = _sc3Z2::P64;
           R2 = GHC.Classes.$fOrd[]_$s$ccompare1_closure+2;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc45z() //  [R1]
         { info_tbl: [(cc45z,
                       label: block_cc45z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc45z: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Classes.$fEq[]_$s$c==1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.944385186 UTC

[section ""data" . Data.Version.$fEqVersion_$c==_closure" {
     Data.Version.$fEqVersion_$c==_closure:
         const Data.Version.$fEqVersion_$c==_info;
 },
 Data.Version.$fEqVersion_$c==_entry() //  [R2, R3]
         { info_tbl: [(cc45N,
                       label: Data.Version.$fEqVersion_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc45N: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc45R; else goto cc45S;
       cc45R: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fEqVersion_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc45S: // global
           I64[Sp - 16] = block_cc45K_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc460; else goto cc45L;
       uc460: // global
           call _cc45K(R1) args: 0, res: 0, upd: 0;
       cc45L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc45K() //  [R1]
         { info_tbl: [(cc45K,
                       label: block_cc45K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc45K: // global
           I64[Sp - 8] = block_cc45Q_info;
           _sc3Zb::P64 = P64[R1 + 7];
           _sc3Zc::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sc3Zc::P64;
           P64[Sp + 8] = _sc3Zb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc45Z; else goto cc45U;
       uc45Z: // global
           call _cc45Q(R1) args: 0, res: 0, upd: 0;
       cc45U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc45Q() //  [R1]
         { info_tbl: [(cc45Q,
                       label: block_cc45Q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc45Q: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Version.$w$c==_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.946032366 UTC

[section ""data" . Data.Version.$fEqVersion_$c/=_closure" {
     Data.Version.$fEqVersion_$c/=_closure:
         const Data.Version.$fEqVersion_$c/=_info;
 },
 Data.Version.$fEqVersion_$c/=_entry() //  [R2, R3]
         { info_tbl: [(cc468,
                       label: Data.Version.$fEqVersion_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc468: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc46c; else goto cc46d;
       cc46c: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fEqVersion_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc46d: // global
           I64[Sp - 16] = block_cc465_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc46x; else goto cc466;
       uc46x: // global
           call _cc465(R1) args: 0, res: 0, upd: 0;
       cc466: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc465() //  [R1]
         { info_tbl: [(cc465,
                       label: block_cc465_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc465: // global
           I64[Sp - 8] = block_cc46b_info;
           _sc3Zj::P64 = P64[R1 + 7];
           _sc3Zk::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sc3Zk::P64;
           P64[Sp + 8] = _sc3Zj::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc46w; else goto cc46f;
       uc46w: // global
           call _cc46b(R1) args: 0, res: 0, upd: 0;
       cc46f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc46b() //  [R1]
         { info_tbl: [(cc46b,
                       label: block_cc46b_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc46b: // global
           _sc3Zj::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cc46j_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _sc3Zj::P64;
           Sp = Sp + 16;
           call Data.Version.$w$c==_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc46j() //  [R1]
         { info_tbl: [(cc46j,
                       label: block_cc46j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc46j: // global
           if (R1 & 7 == 1) goto cc46q; else goto cc46u;
       cc46q: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc46u: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.94749822 UTC

[section ""data" . Data.Version.$fEqVersion_closure" {
     Data.Version.$fEqVersion_closure:
         const GHC.Classes.C:Eq_con_info;
         const Data.Version.$fEqVersion_$c==_closure+2;
         const Data.Version.$fEqVersion_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.948415782 UTC

[section ""data" . Data.Version.$fOrdVersion_$c<_closure" {
     Data.Version.$fOrdVersion_$c<_closure:
         const Data.Version.$fOrdVersion_$c<_info;
 },
 Data.Version.$fOrdVersion_$c<_entry() //  [R2, R3]
         { info_tbl: [(cc46F,
                       label: Data.Version.$fOrdVersion_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc46F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc46J; else goto cc46K;
       cc46J: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc46K: // global
           I64[Sp - 16] = block_cc46C_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc474; else goto cc46D;
       uc474: // global
           call _cc46C(R1) args: 0, res: 0, upd: 0;
       cc46D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc46C() //  [R1]
         { info_tbl: [(cc46C,
                       label: block_cc46C_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc46C: // global
           I64[Sp] = block_cc46I_info;
           _sc3Zs::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sc3Zs::P64;
           if (R1 & 7 != 0) goto uc473; else goto cc46M;
       uc473: // global
           call _cc46I(R1) args: 0, res: 0, upd: 0;
       cc46M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc46I() //  [R1]
         { info_tbl: [(cc46I,
                       label: block_cc46I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc46I: // global
           _sc3Zs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc46Q_info;
           R3 = P64[R1 + 7];
           R2 = _sc3Zs::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc46Q() //  [R1]
         { info_tbl: [(cc46Q,
                       label: block_cc46Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc46Q: // global
           if (R1 & 7 == 1) goto cc471; else goto cc46X;
       cc471: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc46X: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.950304231 UTC

[section ""data" . Data.Version.$fOrdVersion_$c>=_closure" {
     Data.Version.$fOrdVersion_$c>=_closure:
         const Data.Version.$fOrdVersion_$c>=_info;
 },
 Data.Version.$fOrdVersion_$c>=_entry() //  [R2, R3]
         { info_tbl: [(cc47c,
                       label: Data.Version.$fOrdVersion_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc47c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc47g; else goto cc47h;
       cc47g: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc47h: // global
           I64[Sp - 16] = block_cc479_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc47B; else goto cc47a;
       uc47B: // global
           call _cc479(R1) args: 0, res: 0, upd: 0;
       cc47a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc479() //  [R1]
         { info_tbl: [(cc479,
                       label: block_cc479_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc479: // global
           I64[Sp] = block_cc47f_info;
           _sc3ZB::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sc3ZB::P64;
           if (R1 & 7 != 0) goto uc47A; else goto cc47j;
       uc47A: // global
           call _cc47f(R1) args: 0, res: 0, upd: 0;
       cc47j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc47f() //  [R1]
         { info_tbl: [(cc47f,
                       label: block_cc47f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc47f: // global
           _sc3ZB::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc47n_info;
           R3 = P64[R1 + 7];
           R2 = _sc3ZB::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc47n() //  [R1]
         { info_tbl: [(cc47n,
                       label: block_cc47n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc47n: // global
           if (R1 & 7 == 1) goto cc47y; else goto cc47u;
       cc47y: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc47u: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.952004401 UTC

[section ""data" . Data.Version.$fOrdVersion_$c>_closure" {
     Data.Version.$fOrdVersion_$c>_closure:
         const Data.Version.$fOrdVersion_$c>_info;
 },
 Data.Version.$fOrdVersion_$c>_entry() //  [R2, R3]
         { info_tbl: [(cc47J,
                       label: Data.Version.$fOrdVersion_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc47J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc47N; else goto cc47O;
       cc47N: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc47O: // global
           I64[Sp - 16] = block_cc47G_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc488; else goto cc47H;
       uc488: // global
           call _cc47G(R1) args: 0, res: 0, upd: 0;
       cc47H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc47G() //  [R1]
         { info_tbl: [(cc47G,
                       label: block_cc47G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc47G: // global
           I64[Sp] = block_cc47M_info;
           _sc3ZK::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sc3ZK::P64;
           if (R1 & 7 != 0) goto uc487; else goto cc47Q;
       uc487: // global
           call _cc47M(R1) args: 0, res: 0, upd: 0;
       cc47Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc47M() //  [R1]
         { info_tbl: [(cc47M,
                       label: block_cc47M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc47M: // global
           _sc3ZK::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc47U_info;
           R3 = P64[R1 + 7];
           R2 = _sc3ZK::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc47U() //  [R1]
         { info_tbl: [(cc47U,
                       label: block_cc47U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc47U: // global
           if (R1 & 7 == 3) goto cc485; else goto cc481;
       cc485: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc481: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.953755453 UTC

[section ""data" . Data.Version.$fOrdVersion_$c<=_closure" {
     Data.Version.$fOrdVersion_$c<=_closure:
         const Data.Version.$fOrdVersion_$c<=_info;
 },
 Data.Version.$fOrdVersion_$c<=_entry() //  [R2, R3]
         { info_tbl: [(cc48g,
                       label: Data.Version.$fOrdVersion_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc48g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc48k; else goto cc48l;
       cc48k: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc48l: // global
           I64[Sp - 16] = block_cc48d_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc48F; else goto cc48e;
       uc48F: // global
           call _cc48d(R1) args: 0, res: 0, upd: 0;
       cc48e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc48d() //  [R1]
         { info_tbl: [(cc48d,
                       label: block_cc48d_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc48d: // global
           I64[Sp] = block_cc48j_info;
           _sc3ZT::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sc3ZT::P64;
           if (R1 & 7 != 0) goto uc48E; else goto cc48n;
       uc48E: // global
           call _cc48j(R1) args: 0, res: 0, upd: 0;
       cc48n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc48j() //  [R1]
         { info_tbl: [(cc48j,
                       label: block_cc48j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc48j: // global
           _sc3ZT::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc48r_info;
           R3 = P64[R1 + 7];
           R2 = _sc3ZT::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc48r() //  [R1]
         { info_tbl: [(cc48r,
                       label: block_cc48r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc48r: // global
           if (R1 & 7 == 3) goto cc48C; else goto cc48y;
       cc48C: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc48y: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.955549928 UTC

[section ""data" . Data.Version.$fOrdVersion_$cmax_closure" {
     Data.Version.$fOrdVersion_$cmax_closure:
         const Data.Version.$fOrdVersion_$cmax_info;
 },
 Data.Version.$fOrdVersion_$cmax_entry() //  [R2, R3]
         { info_tbl: [(cc48N,
                       label: Data.Version.$fOrdVersion_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc48N: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc48R; else goto cc48S;
       cc48R: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc48S: // global
           I64[Sp - 16] = block_cc48K_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc49c; else goto cc48L;
       uc49c: // global
           call _cc48K(R1) args: 0, res: 0, upd: 0;
       cc48L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc48K() //  [R1]
         { info_tbl: [(cc48K,
                       label: block_cc48K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc48K: // global
           I64[Sp - 8] = block_cc48Q_info;
           _sc401::P64 = R1;
           _sc402::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp] = _sc402::P64;
           P64[Sp + 8] = _sc401::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc49b; else goto cc48U;
       uc49b: // global
           call _cc48Q(R1) args: 0, res: 0, upd: 0;
       cc48U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc48Q() //  [R1]
         { info_tbl: [(cc48Q,
                       label: block_cc48Q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc48Q: // global
           I64[Sp] = block_cc48Y_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc48Y() //  [R1]
         { info_tbl: [(cc48Y,
                       label: block_cc48Y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc48Y: // global
           if (R1 & 7 == 3) goto cc499; else goto cc495;
       cc499: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc495: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.95733133 UTC

[section ""data" . Data.Version.$fOrdVersion_$cmin_closure" {
     Data.Version.$fOrdVersion_$cmin_closure:
         const Data.Version.$fOrdVersion_$cmin_info;
 },
 Data.Version.$fOrdVersion_$cmin_entry() //  [R2, R3]
         { info_tbl: [(cc49k,
                       label: Data.Version.$fOrdVersion_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc49k: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc49o; else goto cc49p;
       cc49o: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc49p: // global
           I64[Sp - 16] = block_cc49h_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc49J; else goto cc49i;
       uc49J: // global
           call _cc49h(R1) args: 0, res: 0, upd: 0;
       cc49i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc49h() //  [R1]
         { info_tbl: [(cc49h,
                       label: block_cc49h_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc49h: // global
           I64[Sp - 8] = block_cc49n_info;
           _sc40a::P64 = R1;
           _sc40b::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp] = _sc40b::P64;
           P64[Sp + 8] = _sc40a::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc49I; else goto cc49r;
       uc49I: // global
           call _cc49n(R1) args: 0, res: 0, upd: 0;
       cc49r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc49n() //  [R1]
         { info_tbl: [(cc49n,
                       label: block_cc49n_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc49n: // global
           I64[Sp] = block_cc49v_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc49v() //  [R1]
         { info_tbl: [(cc49v,
                       label: block_cc49v_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc49v: // global
           if (R1 & 7 == 3) goto cc49G; else goto cc49C;
       cc49G: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc49C: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.958736162 UTC

[section ""data" . Data.Version.$fOrdVersion_closure" {
     Data.Version.$fOrdVersion_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Version.$fEqVersion_closure+1;
         const Data.Version.$fOrdVersion_$ccompare_closure+2;
         const Data.Version.$fOrdVersion_$c<_closure+2;
         const Data.Version.$fOrdVersion_$c<=_closure+2;
         const Data.Version.$fOrdVersion_$c>_closure+2;
         const Data.Version.$fOrdVersion_$c>=_closure+2;
         const Data.Version.$fOrdVersion_$cmax_closure+2;
         const Data.Version.$fOrdVersion_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.959545144 UTC

[section ""data" . Data.Version.makeVersion_closure" {
     Data.Version.makeVersion_closure:
         const Data.Version.makeVersion_info;
 },
 Data.Version.makeVersion_entry() //  [R2]
         { info_tbl: [(cc49P,
                       label: Data.Version.makeVersion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc49P: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc49T; else goto cc49S;
       cc49T: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Version.makeVersion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc49S: // global
           I64[Hp - 16] = Data.Version.Version_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.9603467 UTC

[section ""cstring" . Data.Version.$trModule4_bytes" {
     Data.Version.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.960886282 UTC

[section ""data" . Data.Version.$trModule3_closure" {
     Data.Version.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Version.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.961676947 UTC

[section ""cstring" . Data.Version.$trModule2_bytes" {
     Data.Version.$trModule2_bytes:
         I8[] [68,97,116,97,46,86,101,114,115,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.962218196 UTC

[section ""data" . Data.Version.$trModule1_closure" {
     Data.Version.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Version.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.962760269 UTC

[section ""data" . Data.Version.$trModule_closure" {
     Data.Version.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Version.$trModule3_closure+1;
         const Data.Version.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.963365886 UTC

[section ""data" . $krep_rc3Yn_closure" {
     $krep_rc3Yn_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcChar_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.963936786 UTC

[section ""data" . $krep1_rc3Yo_closure" {
     $krep1_rc3Yo_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.96450464 UTC

[section ""data" . $krep2_rc3Yp_closure" {
     $krep2_rc3Yp_closure:
         const :_con_info;
         const $krep_rc3Yn_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.965050906 UTC

[section ""data" . $krep3_rc3Yq_closure" {
     $krep3_rc3Yq_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep2_rc3Yp_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.965654759 UTC

[section ""data" . $krep4_rc3Yr_closure" {
     $krep4_rc3Yr_closure:
         const :_con_info;
         const $krep1_rc3Yo_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.966197445 UTC

[section ""data" . $krep5_rc3Ys_closure" {
     $krep5_rc3Ys_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep4_rc3Yr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.966737621 UTC

[section ""data" . $krep6_rc3Yt_closure" {
     $krep6_rc3Yt_closure:
         const :_con_info;
         const $krep3_rc3Yq_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.967328422 UTC

[section ""data" . $krep7_rc3Yu_closure" {
     $krep7_rc3Yu_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep6_rc3Yt_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.967905418 UTC

[section ""cstring" . Data.Version.$fReadVersion19_bytes" {
     Data.Version.$fReadVersion19_bytes:
         I8[] [86,101,114,115,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.968408816 UTC

[section ""data" . Data.Version.$tcVersion1_closure" {
     Data.Version.$tcVersion1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Version.$fReadVersion19_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.968961596 UTC

[section ""data" . Data.Version.$tcVersion_closure" {
     Data.Version.$tcVersion_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Version.$trModule_closure+1;
         const Data.Version.$tcVersion1_closure+1;
         const GHC.Types.krep$*_closure;
         const 18148779789861942324;
         const 12675349638857785520;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.96956143 UTC

[section ""data" . $krep8_rc3Yv_closure" {
     $krep8_rc3Yv_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Version.$tcVersion_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.970156792 UTC

[section ""data" . $krep9_rc3Yw_closure" {
     $krep9_rc3Yw_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rc3Yu_closure+1;
         const $krep8_rc3Yv_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.970739012 UTC

[section ""data" . Data.Version.$tc'Version1_closure" {
     Data.Version.$tc'Version1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_rc3Ys_closure+1;
         const $krep9_rc3Yw_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.971339373 UTC

[section ""cstring" . Data.Version.$tc'Version3_bytes" {
     Data.Version.$tc'Version3_bytes:
         I8[] [39,86,101,114,115,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.971893674 UTC

[section ""data" . Data.Version.$tc'Version2_closure" {
     Data.Version.$tc'Version2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Version.$tc'Version3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.974146332 UTC

[section ""data" . Data.Version.$tc'Version_closure" {
     Data.Version.$tc'Version_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Version.$trModule_closure+1;
         const Data.Version.$tc'Version2_closure+1;
         const Data.Version.$tc'Version1_closure+4;
         const 3698077959655346891;
         const 8062481246695158651;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.974772658 UTC

[section ""cstring" . f_rc3Yx_bytes" {
     f_rc3Yx_bytes:
         I8[] [86,101,114,115,105,111,110,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.975625987 UTC

[section ""data" . f1_rc3Yy_closure" {
     f1_rc3Yy_closure:
         const f1_rc3Yy_info;
         const 0;
         const 0;
         const 0;
 },
 f1_rc3Yy_entry() //  [R1]
         { info_tbl: [(cc4a0,
                       label: f1_rc3Yy_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4a0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4a1; else goto cc4a2;
       cc4a1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4a2: // global
           (_cc49X::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc49X::I64 == 0) goto cc49Z; else goto cc49Y;
       cc49Z: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc49Y: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc49X::I64;
           R2 = f_rc3Yx_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.976550575 UTC

[section ""cstring" . lvl_rc3Yz_bytes" {
     lvl_rc3Yz_bytes:
         I8[] [118,101,114,115,105,111,110,66,114,97,110,99,104,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.977066366 UTC

[section ""cstring" . lvl1_rc3YA_bytes" {
     lvl1_rc3YA_bytes:
         I8[] [118,101,114,115,105,111,110,84,97,103,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.978613478 UTC

[section ""cstring" . Data.Version.$fReadVersion5_bytes" {
     Data.Version.$fReadVersion5_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.98361713 UTC

[section ""data" . Data.Version.$w$cshowsPrec_closure" {
     Data.Version.$w$cshowsPrec_closure:
         const Data.Version.$w$cshowsPrec_info;
         const 0;
 },
 Data.Version.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4a4: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Data.Version.$w$cshowsPrec_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 8, res: 0, upd: 8;
     }
 },
 s1_sc40p_entry() //  [R1]
         { info_tbl: [(cc4ax,
                       label: s1_sc40p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ax: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4ay; else goto cc4az;
       cc4ay: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4az: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Version.$fReadVersion5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc40B_entry() //  [R1]
         { info_tbl: [(cc4b6,
                       label: sat_sc40B_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4b6: // global
           _sc40B::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc4b7; else goto cc4b8;
       cc4b8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc4ba; else goto cc4b9;
       cc4ba: // global
           HpAlloc = 56;
           goto cc4b7;
       cc4b7: // global
           R1 = _sc40B::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4b9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc40B::P64;
           _sc40u::P64 = P64[_sc40B::P64 + 16];
           _sc40x::P64 = P64[_sc40B::P64 + 24];
           _sc40y::P64 = P64[_sc40B::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sc40u::P64;
           P64[Hp - 24] = _sc40y::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sc40x::P64;
           Sp = Sp - 16;
           call GHC.Show.showLitString_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 showl_sc40u_entry() //  [R1, R2]
         { info_tbl: [(cc4bf,
                       label: showl_sc40u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4bf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc4bg; else goto cc4bh;
       cc4bg: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4bh: // global
           I64[Sp - 24] = block_cc4aU_info;
           _sc40u::P64 = R1;
           _sc40t::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sc40t::P64;
           P64[Sp - 8] = _sc40u::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc4bp; else goto cc4aV;
       uc4bp: // global
           call _cc4aU(R1) args: 0, res: 0, upd: 0;
       cc4aV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4aU() //  [R1]
         { info_tbl: [(cc4aU,
                       label: block_cc4aU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4aU: // global
           if (R1 & 7 == 1) goto cc4bc; else goto cc4bd;
       cc4bc: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4bd: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cc4bo; else goto cc4bn;
       cc4bo: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4bn: // global
           _sc40x::P64 = P64[R1 + 6];
           _sc40y::P64 = P64[R1 + 14];
           I64[Hp - 80] = sat_sc40B_info;
           P64[Hp - 64] = P64[Sp + 16];
           P64[Hp - 56] = _sc40x::P64;
           P64[Hp - 48] = _sc40y::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = GHC.Show.$fShow(,)3_closure;
           P64[Hp - 24] = Hp - 80;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.showList__1_closure;
           P64[Hp] = Hp - 38;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc40D_entry() //  [R1]
         { info_tbl: [(cc4bq,
                       label: sat_sc40D_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4bq: // global
           _sc40D::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc4br; else goto cc4bs;
       cc4bs: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc4bu; else goto cc4bt;
       cc4bu: // global
           HpAlloc = 40;
           goto cc4br;
       cc4br: // global
           R1 = _sc40D::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4bt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc40D::P64;
           _sc40p::P64 = P64[_sc40D::P64 + 16];
           _sc40s::P64 = P64[_sc40D::P64 + 24];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.Show.showList__2_closure;
           P64[Hp - 16] = _sc40p::P64;
           I64[Hp - 8] = showl_sc40u_info;
           P64[Hp] = Hp - 30;
           R2 = _sc40s::P64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call showl_sc40u_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc40F_entry() //  [R1]
         { info_tbl: [(cc4bw,
                       label: sat_sc40F_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4bw: // global
           _sc40F::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc4bx; else goto cc4by;
       cc4by: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc4bA; else goto cc4bz;
       cc4bA: // global
           HpAlloc = 56;
           goto cc4bx;
       cc4bx: // global
           R1 = _sc40F::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4bz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc40F::P64;
           _sc40p::P64 = P64[_sc40F::P64 + 16];
           _sc40r::P64 = P64[_sc40F::P64 + 24];
           _sc40s::P64 = P64[_sc40F::P64 + 32];
           I64[Hp - 48] = sat_sc40D_info;
           P64[Hp - 32] = _sc40p::P64;
           P64[Hp - 24] = _sc40s::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sc40r::P64;
           Sp = Sp - 16;
           call GHC.Show.showLitString_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc40H_entry() //  [R1]
         { info_tbl: [(cc4bF,
                       label: sat_sc40H_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4bF: // global
           _sc40H::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc4bG; else goto cc4bH;
       cc4bH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4bJ; else goto cc4bI;
       cc4bJ: // global
           HpAlloc = 24;
           goto cc4bG;
       cc4bG: // global
           R1 = _sc40H::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4bI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc40H::P64;
           _sc40k::P64 = P64[_sc40H::P64 + 16];
           _sc40n::P64 = P64[_sc40H::P64 + 24];
           I64[Hp - 16] = s1_sc40p_info;
           P64[Hp] = _sc40n::P64;
           I64[Sp - 32] = block_cc4aA_info;
           R1 = _sc40k::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uc4bR; else goto cc4aB;
       uc4bR: // global
           call _cc4aA(R1) args: 0, res: 0, upd: 0;
       cc4aB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc4aA() //  [R1]
         { info_tbl: [(cc4aA,
                       label: block_cc4aA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4aA: // global
           _cc4at::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc4bC; else goto cc4bD;
       cc4bC: // global
           R3 = _cc4at::P64;
           R2 = GHC.Show.showList__4_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
       cc4bD: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cc4bQ; else goto cc4bP;
       cc4bQ: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cc4bP: // global
           _sc40r::P64 = P64[R1 + 6];
           _sc40s::P64 = P64[R1 + 14];
           I64[Hp - 80] = sat_sc40F_info;
           P64[Hp - 64] = _cc4at::P64;
           P64[Hp - 56] = _sc40r::P64;
           P64[Hp - 48] = _sc40s::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = GHC.Show.$fShow(,)3_closure;
           P64[Hp - 24] = Hp - 80;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.showList__3_closure;
           P64[Hp] = Hp - 38;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc40I_entry() //  [R1]
         { info_tbl: [(cc4bS,
                       label: sat_sc40I_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4bS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc4bW; else goto cc4bV;
       cc4bW: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4bV: // global
           _sc40k::P64 = P64[R1 + 16];
           _sc40n::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_sc40H_info;
           P64[Hp - 8] = _sc40k::P64;
           P64[Hp] = _sc40n::P64;
           R3 = Hp - 24;
           R2 = lvl1_rc3YA_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 s_sc40o_entry() //  [R1]
         { info_tbl: [(cc4bX,
                       label: s_sc40o_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4bX: // global
           _sc40o::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc4bY; else goto cc4bZ;
       cc4bZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc4c1; else goto cc4c0;
       cc4c1: // global
           HpAlloc = 32;
           goto cc4bY;
       cc4bY: // global
           R1 = _sc40o::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4c0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc40o::P64;
           _sc40k::P64 = P64[_sc40o::P64 + 16];
           _sc40n::P64 = P64[_sc40o::P64 + 24];
           I64[Hp - 24] = sat_sc40I_info;
           P64[Hp - 8] = _sc40k::P64;
           P64[Hp] = _sc40n::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc410_entry() //  [R1]
         { info_tbl: [(cc4cE,
                       label: sat_sc410_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4cE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc4cL; else goto cc4cM;
       cc4cL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4cM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cc4cB_info;
           _sc40P::P64 = P64[R1 + 16];
           _sc40T::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sc40P::P64;
           P64[Sp - 24] = _sc40T::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc4cT; else goto cc4cC;
       uc4cT: // global
           call _cc4cB(R1) args: 0, res: 0, upd: 0;
       cc4cC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc4cB() //  [R1]
         { info_tbl: [(cc4cB,
                       label: block_cc4cB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4cB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc4cP; else goto cc4cO;
       cc4cP: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cc4cO: // global
           _sc40V::I64 = I64[R1 + 7];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cc4cI_info;
           R4 = Hp - 24;
           R3 = _sc40V::I64;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc4cI() //  [R1, R2]
         { info_tbl: [(cc4cI,
                       label: block_cc4cI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4cI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4cS; else goto cc4cR;
       cc4cS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cc4cR: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 showl_sc40P_entry() //  [R1, R2]
         { info_tbl: [(cc4cY,
                       label: showl_sc40P_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4cY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc4cZ; else goto cc4d0;
       cc4cZ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4d0: // global
           I64[Sp - 24] = block_cc4cr_info;
           _sc40P::P64 = R1;
           _sc40O::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sc40O::P64;
           P64[Sp - 8] = _sc40P::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc4d7; else goto cc4cs;
       uc4d7: // global
           call _cc4cr(R1) args: 0, res: 0, upd: 0;
       cc4cs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4cr() //  [R1]
         { info_tbl: [(cc4cr,
                       label: block_cc4cr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4cr: // global
           if (R1 & 7 == 1) goto cc4cV; else goto cc4cW;
       cc4cV: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4cW: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc4d6; else goto cc4d5;
       cc4d6: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4d5: // global
           _sc40S::P64 = P64[R1 + 6];
           _sc40T::P64 = P64[R1 + 14];
           I64[Hp - 56] = sat_sc410_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = _sc40S::P64;
           P64[Hp - 24] = _sc40T::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.showList__1_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc411_entry() //  [R1]
         { info_tbl: [(cc4d8,
                       label: sat_sc411_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4d8: // global
           _sc411::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc4d9; else goto cc4da;
       cc4da: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc4dc; else goto cc4db;
       cc4dc: // global
           HpAlloc = 40;
           goto cc4d9;
       cc4d9: // global
           R1 = _sc411::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4db: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc411::P64;
           _sc40o::P64 = P64[_sc411::P64 + 16];
           _sc40L::P64 = P64[_sc411::P64 + 24];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.Show.showList__2_closure;
           P64[Hp - 16] = _sc40o::P64;
           I64[Hp - 8] = showl_sc40P_info;
           P64[Hp] = Hp - 30;
           R2 = _sc40L::P64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call showl_sc40P_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc415_entry() //  [R1]
         { info_tbl: [(cc4dd,
                       label: sat_sc415_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4dd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc4dh; else goto cc4di;
       cc4dh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4di: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cc4cc_info;
           _sc40o::P64 = P64[R1 + 16];
           _sc40L::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sc40o::P64;
           P64[Sp - 24] = _sc40L::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc4dp; else goto cc4cd;
       uc4dp: // global
           call _cc4cc(R1) args: 0, res: 0, upd: 0;
       cc4cd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc4cc() //  [R1]
         { info_tbl: [(cc4cc,
                       label: block_cc4cc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4cc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc4dl; else goto cc4dk;
       cc4dl: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cc4dk: // global
           _sc40N::I64 = I64[R1 + 7];
           I64[Hp - 24] = sat_sc411_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cc4de_info;
           R4 = Hp - 24;
           R3 = _sc40N::I64;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc4de() //  [R1, R2]
         { info_tbl: [(cc4de,
                       label: block_cc4de_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4de: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4do; else goto cc4dn;
       cc4do: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cc4dn: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc416_entry() //  [R1]
         { info_tbl: [(cc4du,
                       label: sat_sc416_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4du: // global
           _sc416::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc4dv; else goto cc4dw;
       cc4dw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc4dy; else goto cc4dx;
       cc4dy: // global
           HpAlloc = 32;
           goto cc4dv;
       cc4dv: // global
           R1 = _sc416::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4dx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc416::P64;
           _sc40j::P64 = P64[_sc416::P64 + 16];
           _sc40k::P64 = P64[_sc416::P64 + 24];
           _sc40n::P64 = P64[_sc416::P64 + 32];
           I64[Hp - 24] = s_sc40o_info;
           P64[Hp - 8] = _sc40k::P64;
           P64[Hp] = _sc40n::P64;
           I64[Sp - 32] = block_cc4c2_info;
           R1 = _sc40j::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uc4dF; else goto cc4c3;
       uc4dF: // global
           call _cc4c2(R1) args: 0, res: 0, upd: 0;
       cc4c3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc4c2() //  [R1]
         { info_tbl: [(cc4c2,
                       label: block_cc4c2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4c2: // global
           _cc4ah::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc4dr; else goto cc4ds;
       cc4dr: // global
           R3 = _cc4ah::P64;
           R2 = GHC.Show.showList__4_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
       cc4ds: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc4dE; else goto cc4dD;
       cc4dE: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cc4dD: // global
           _sc40K::P64 = P64[R1 + 6];
           _sc40L::P64 = P64[R1 + 14];
           I64[Hp - 56] = sat_sc415_info;
           P64[Hp - 40] = _cc4ah::P64;
           P64[Hp - 32] = _sc40K::P64;
           P64[Hp - 24] = _sc40L::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.showList__3_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 g_sc40m_entry() //  [R1, R2]
         { info_tbl: [(cc4dG,
                       label: g_sc40m_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4dG: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc4dK; else goto cc4dJ;
       cc4dK: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4dJ: // global
           _sc40j::P64 = P64[R1 + 7];
           _sc40k::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_sc416_info;
           P64[Hp - 16] = _sc40j::P64;
           P64[Hp - 8] = _sc40k::P64;
           P64[Hp] = R2;
           R3 = Hp - 32;
           R2 = lvl_rc3Yz_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc418_entry() //  [R1]
         { info_tbl: [(cc4dS,
                       label: sat_sc418_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4dS: // global
           R2 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           call g_sc40m_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc41a_entry() //  [R1]
         { info_tbl: [(cc4e5,
                       label: sat_sc41a_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4e5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4e9; else goto cc4e8;
       cc4e9: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4e8: // global
           _sc40l::P64 = P64[R1 + 16];
           _sc40m::P64 = P64[R1 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sc40l::P64;
           R2 = Hp - 14;
           R1 = _sc40m::P64;
           call g_sc40m_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc41b_entry() //  [R1]
         { info_tbl: [(cc4ea,
                       label: sat_sc41b_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ea: // global
           _sc41b::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc4eb; else goto cc4ec;
       cc4ec: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc4ee; else goto cc4ed;
       cc4ee: // global
           HpAlloc = 32;
           goto cc4eb;
       cc4eb: // global
           R1 = _sc41b::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4ed: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc41b::P64;
           _sc40l::P64 = P64[_sc41b::P64 + 16];
           _sc40m::P64 = P64[_sc41b::P64 + 24];
           I64[Hp - 24] = sat_sc41a_info;
           P64[Hp - 8] = _sc40l::P64;
           P64[Hp] = _sc40m::P64;
           R3 = Hp - 24;
           R2 = f1_rc3Yy_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Version.$w$cshowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc4ei,
                       label: Data.Version.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ei: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc4em; else goto cc4el;
       cc4em: // global
           HpAlloc = 80;
           R1 = Data.Version.$w$cshowsPrec_closure;
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cc4el: // global
           I64[Hp - 72] = g_sc40m_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           _cc4a8::P64 = Hp - 71;
           if (%MO_S_Lt_W64(R2, 11)) goto cc4eg; else goto cc4eh;
       cc4eg: // global
           I64[Hp - 48] = sat_sc418_info;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = _cc4a8::P64;
           _cc4dO::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _cc4dO::P64;
           R2 = f1_rc3Yy_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       cc4eh: // global
           I64[Hp - 48] = sat_sc41b_info;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = _cc4a8::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.994288279 UTC

[section ""data" . Data.Version.$fShowVersion_$cshowsPrec_closure" {
     Data.Version.$fShowVersion_$cshowsPrec_closure:
         const Data.Version.$fShowVersion_$cshowsPrec_info;
         const 0;
 },
 Data.Version.$fShowVersion_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cc4ew,
                       label: Data.Version.$fShowVersion_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ew: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc4eA; else goto cc4eB;
       cc4eA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fShowVersion_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4eB: // global
           I64[Sp - 24] = block_cc4et_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc4eJ; else goto cc4eu;
       uc4eJ: // global
           call _cc4et(R1) args: 0, res: 0, upd: 0;
       cc4eu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4et() //  [R1]
         { info_tbl: [(cc4et,
                       label: block_cc4et_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4et: // global
           I64[Sp] = block_cc4ez_info;
           _sc41g::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sc41g::I64;
           if (R1 & 7 != 0) goto uc4eI; else goto cc4eD;
       uc4eI: // global
           call _cc4ez(R1) args: 0, res: 0, upd: 0;
       cc4eD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4ez() //  [R1]
         { info_tbl: [(cc4ez,
                       label: block_cc4ez_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ez: // global
           R5 = P64[Sp + 16];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call Data.Version.$w$cshowsPrec_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.995635579 UTC

[section ""data" . Data.Version.$fShowVersion2_closure" {
     Data.Version.$fShowVersion2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.996422162 UTC

[section ""data" . Data.Version.$fShowVersion_$cshow_closure" {
     Data.Version.$fShowVersion_$cshow_closure:
         const Data.Version.$fShowVersion_$cshow_info;
         const 0;
 },
 Data.Version.$fShowVersion_$cshow_entry() //  [R2]
         { info_tbl: [(cc4eR,
                       label: Data.Version.$fShowVersion_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4eR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc4eS; else goto cc4eT;
       cc4eS: // global
           R2 = R2;
           R1 = Data.Version.$fShowVersion_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4eT: // global
           I64[Sp - 8] = block_cc4eO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4eX; else goto cc4eP;
       uc4eX: // global
           call _cc4eO(R1) args: 0, res: 0, upd: 0;
       cc4eP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4eO() //  [R1]
         { info_tbl: [(cc4eO,
                       label: block_cc4eO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4eO: // global
           R5 = GHC.Types.[]_closure+1;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call Data.Version.$w$cshowsPrec_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.997698552 UTC

[section ""data" . Data.Version.$fShowVersion1_closure" {
     Data.Version.$fShowVersion1_closure:
         const Data.Version.$fShowVersion1_info;
         const 0;
 },
 Data.Version.$fShowVersion1_entry() //  [R2, R3]
         { info_tbl: [(cc4f5,
                       label: Data.Version.$fShowVersion1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4f5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4f6; else goto cc4f7;
       cc4f6: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fShowVersion1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4f7: // global
           I64[Sp - 16] = block_cc4f2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4fb; else goto cc4f3;
       uc4fb: // global
           call _cc4f2(R1) args: 0, res: 0, upd: 0;
       cc4f3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4f2() //  [R1]
         { info_tbl: [(cc4f2,
                       label: block_cc4f2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4f2: // global
           R5 = P64[Sp + 8];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 16;
           call Data.Version.$w$cshowsPrec_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.998801408 UTC

[section ""data" . Data.Version.$fShowVersion_$cshowList_closure" {
     Data.Version.$fShowVersion_$cshowList_closure:
         const Data.Version.$fShowVersion_$cshowList_info;
         const 0;
 },
 Data.Version.$fShowVersion_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cc4fg,
                       label: Data.Version.$fShowVersion_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4fg: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Version.$fShowVersion1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.999465569 UTC

[section ""data" . Data.Version.$fShowVersion_closure" {
     Data.Version.$fShowVersion_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Version.$fShowVersion_$cshowsPrec_closure+3;
         const Data.Version.$fShowVersion_$cshow_closure+1;
         const Data.Version.$fShowVersion_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.000027845 UTC

[section ""data" . f2_rc3YB_closure" {
     f2_rc3YB_closure:
         const GHC.Types.C#_con_info;
         const 45;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.000485701 UTC

[section ""cstring" . Data.Version.showVersion2_bytes" {
     Data.Version.showVersion2_bytes:
         I8[] [46]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.001179731 UTC

[section ""data" . Data.Version.showVersion1_closure" {
     Data.Version.showVersion1_closure:
         const Data.Version.showVersion1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.showVersion1_entry() //  [R1]
         { info_tbl: [(cc4fp,
                       label: Data.Version.showVersion1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4fp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4fq; else goto cc4fr;
       cc4fq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4fr: // global
           (_cc4fm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4fm::I64 == 0) goto cc4fo; else goto cc4fn;
       cc4fo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4fn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4fm::I64;
           R2 = Data.Version.showVersion2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.002555025 UTC

[section ""data" . Data.Version.showVersion_go_closure" {
     Data.Version.showVersion_go_closure:
         const Data.Version.showVersion_go_info;
 },
 sat_sc41A_entry() //  [R1]
         { info_tbl: [(cc4fG,
                       label: sat_sc41A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4fG: // global
           R2 = P64[R1 + 16];
           call Data.Version.showVersion_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.showVersion_go_entry() //  [R2]
         { info_tbl: [(cc4fN,
                       label: Data.Version.showVersion_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4fN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc4fO; else goto cc4fP;
       cc4fO: // global
           R2 = R2;
           R1 = Data.Version.showVersion_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4fP: // global
           I64[Sp - 8] = block_cc4fw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4fW; else goto cc4fx;
       uc4fW: // global
           call _cc4fw(R1) args: 0, res: 0, upd: 0;
       cc4fx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4fw() //  [R1]
         { info_tbl: [(cc4fw,
                       label: block_cc4fw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4fw: // global
           if (R1 & 7 == 1) goto cc4fK; else goto cc4fL;
       cc4fK: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4fL: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc4fV; else goto cc4fU;
       cc4fV: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4fU: // global
           _sc41x::P64 = P64[R1 + 6];
           _sc41y::P64 = P64[R1 + 14];
           I64[Hp - 40] = sat_sc41A_info;
           P64[Hp - 24] = _sc41y::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = f2_rc3YB_closure+1;
           P64[Hp] = _sc41x::P64;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.004889886 UTC

[section ""data" . Data.Version.$wshowVersion_closure" {
     Data.Version.$wshowVersion_closure:
         const Data.Version.$wshowVersion_info;
         const 0;
 },
 arg_sc41D_entry() //  [R1]
         { info_tbl: [(cc4g5,
                       label: arg_sc41D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4g5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4g6; else goto cc4g7;
       cc4g6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4g7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Version.showVersion_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc41M_entry() //  [R1]
         { info_tbl: [(cc4gs,
                       label: sat_sc41M_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4gs: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_sc41H_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sc41H_entry() //  [R1, R2]
         { info_tbl: [(cc4gz,
                       label: go_sc41H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4gz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc4gA; else goto cc4gB;
       cc4gA: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4gB: // global
           I64[Sp - 24] = block_cc4gi_info;
           _sc41H::P64 = R1;
           _sc41D::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sc41D::P64;
           P64[Sp - 8] = _sc41H::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc4gH; else goto cc4gj;
       uc4gH: // global
           call _cc4gi(R1) args: 0, res: 0, upd: 0;
       cc4gj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4gi() //  [R1]
         { info_tbl: [(cc4gi,
                       label: block_cc4gi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4gi: // global
           if (R1 & 7 == 1) goto cc4gw; else goto cc4gx;
       cc4gw: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc4gx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc4gG; else goto cc4gF;
       cc4gG: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4gF: // global
           _sc41K::P64 = P64[R1 + 6];
           _sc41L::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_sc41M_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sc41L::P64;
           R3 = Hp - 24;
           R2 = _sc41K::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc41N_entry() //  [R1]
         { info_tbl: [(cc4gM,
                       label: sat_sc41N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4gM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4gN; else goto cc4gO;
       cc4gN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4gO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Version.showVersion1_closure;
           Sp = Sp - 16;
           call Data.OldList.prependToAll_entry(R3,
                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Version.$wshowVersion_entry() //  [R2, R3]
         { info_tbl: [(cc4gT,
                       label: Data.Version.$wshowVersion_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4gT: // global
           _sc41C::P64 = R3;
           _sc41B::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cc4gU; else goto cc4gV;
       cc4gV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4gX; else goto cc4gW;
       cc4gX: // global
           HpAlloc = 24;
           goto cc4gU;
       cc4gU: // global
           R3 = _sc41C::P64;
           R2 = _sc41B::P64;
           R1 = Data.Version.$wshowVersion_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4gW: // global
           I64[Hp - 16] = arg_sc41D_info;
           P64[Hp] = _sc41C::P64;
           I64[Sp - 16] = block_cc4g8_info;
           R3 = _sc41B::P64;
           R2 = GHC.Show.$fShowInt_$cshow_closure+1;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4g8() //  [R1]
         { info_tbl: [(cc4g8,
                       label: block_cc4g8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4g8: // global
           _cc4g1::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc4gQ; else goto cc4gR;
       cc4gQ: // global
           R1 = _cc4g1::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc4gR: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc4h3; else goto cc4h2;
       cc4h3: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4h2: // global
           _sc41F::P64 = P64[R1 + 6];
           _sc41G::P64 = P64[R1 + 14];
           I64[Hp - 56] = go_sc41H_info;
           P64[Hp - 48] = _cc4g1::P64;
           I64[Hp - 40] = sat_sc41N_info;
           P64[Hp - 24] = _sc41G::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sc41F::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 14;
           R1 = Hp - 55;
           Sp = Sp + 16;
           call go_sc41H_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.007693079 UTC

[section ""data" . Data.Version.showVersion_closure" {
     Data.Version.showVersion_closure:
         const Data.Version.showVersion_info;
         const 0;
 },
 Data.Version.showVersion_entry() //  [R2]
         { info_tbl: [(cc4hb,
                       label: Data.Version.showVersion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4hb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc4hc; else goto cc4hd;
       cc4hc: // global
           R2 = R2;
           R1 = Data.Version.showVersion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4hd: // global
           I64[Sp - 8] = block_cc4h8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4hh; else goto cc4h9;
       uc4hh: // global
           call _cc4h8(R1) args: 0, res: 0, upd: 0;
       cc4h9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4h8() //  [R1]
         { info_tbl: [(cc4h8,
                       label: block_cc4h8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4h8: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Version.$wshowVersion_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.008871165 UTC

[section ""data" . Data.Version.$fReadVersion18_closure" {
     Data.Version.$fReadVersion18_closure:
         const Data.Version.$fReadVersion18_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion18_entry() //  [R1]
         { info_tbl: [(cc4ho,
                       label: Data.Version.$fReadVersion18_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ho: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4hp; else goto cc4hq;
       cc4hp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4hq: // global
           (_cc4hl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4hl::I64 == 0) goto cc4hn; else goto cc4hm;
       cc4hn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4hm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4hl::I64;
           R2 = Data.Version.$fReadVersion19_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.009752288 UTC

[section ""data" . Data.Version.$fReadVersion_lexeme1_closure" {
     Data.Version.$fReadVersion_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Version.$fReadVersion18_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.010296014 UTC

[section ""cstring" . Data.Version.$fReadVersion17_bytes" {
     Data.Version.$fReadVersion17_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.010963962 UTC

[section ""data" . Data.Version.$fReadVersion16_closure" {
     Data.Version.$fReadVersion16_closure:
         const Data.Version.$fReadVersion16_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion16_entry() //  [R1]
         { info_tbl: [(cc4hx,
                       label: Data.Version.$fReadVersion16_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4hx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4hy; else goto cc4hz;
       cc4hy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4hz: // global
           (_cc4hu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4hu::I64 == 0) goto cc4hw; else goto cc4hv;
       cc4hw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4hv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4hu::I64;
           R2 = Data.Version.$fReadVersion17_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.011809811 UTC

[section ""data" . Data.Version.$fReadVersion_lexeme_closure" {
     Data.Version.$fReadVersion_lexeme_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Version.$fReadVersion16_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.012345621 UTC

[section ""cstring" . Data.Version.$fReadVersion15_bytes" {
     Data.Version.$fReadVersion15_bytes:
         I8[] [118,101,114,115,105,111,110,66,114,97,110,99,104]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.013006228 UTC

[section ""data" . Data.Version.$fReadVersion14_closure" {
     Data.Version.$fReadVersion14_closure:
         const Data.Version.$fReadVersion14_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion14_entry() //  [R1]
         { info_tbl: [(cc4hG,
                       label: Data.Version.$fReadVersion14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4hG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4hH; else goto cc4hI;
       cc4hH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4hI: // global
           (_cc4hD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4hD::I64 == 0) goto cc4hF; else goto cc4hE;
       cc4hF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4hE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4hD::I64;
           R2 = Data.Version.$fReadVersion15_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.014097414 UTC

[section ""data" . Data.Version.$fReadVersion13_closure" {
     Data.Version.$fReadVersion13_closure:
         const Data.Version.$fReadVersion13_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion13_entry() //  [R1]
         { info_tbl: [(cc4hP,
                       label: Data.Version.$fReadVersion13_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4hP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4hQ; else goto cc4hR;
       cc4hQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4hR: // global
           (_cc4hM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4hM::I64 == 0) goto cc4hO; else goto cc4hN;
       cc4hO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4hN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4hM::I64;
           R2 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R1 = GHC.Read.$fReadInt_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.015110038 UTC

[section ""data" . Data.Version.$fReadVersion12_closure" {
     Data.Version.$fReadVersion12_closure:
         const Data.Version.$fReadVersion12_info;
         const 0;
 },
 Data.Version.$fReadVersion12_entry() //  []
         { info_tbl: [(cc4hW,
                       label: Data.Version.$fReadVersion12_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4hW: // global
           R1 = Data.Version.$fReadVersion13_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.015845777 UTC

[section ""data" . Data.Version.$fReadVersion_n_closure" {
     Data.Version.$fReadVersion_n_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.016391715 UTC

[section ""cstring" . Data.Version.$fReadVersion11_bytes" {
     Data.Version.$fReadVersion11_bytes:
         I8[] [44]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.017084475 UTC

[section ""data" . Data.Version.$fReadVersion10_closure" {
     Data.Version.$fReadVersion10_closure:
         const Data.Version.$fReadVersion10_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion10_entry() //  [R1]
         { info_tbl: [(cc4i5,
                       label: Data.Version.$fReadVersion10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4i5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4i6; else goto cc4i7;
       cc4i6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4i7: // global
           (_cc4i2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4i2::I64 == 0) goto cc4i4; else goto cc4i3;
       cc4i4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4i3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4i2::I64;
           R2 = Data.Version.$fReadVersion11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.018182107 UTC

[section ""data" . Data.Version.$fReadVersion9_closure" {
     Data.Version.$fReadVersion9_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Version.$fReadVersion10_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.018722569 UTC

[section ""cstring" . Data.Version.$fReadVersion8_bytes" {
     Data.Version.$fReadVersion8_bytes:
         I8[] [118,101,114,115,105,111,110,84,97,103,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.019411064 UTC

[section ""data" . Data.Version.$fReadVersion7_closure" {
     Data.Version.$fReadVersion7_closure:
         const Data.Version.$fReadVersion7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion7_entry() //  [R1]
         { info_tbl: [(cc4ie,
                       label: Data.Version.$fReadVersion7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ie: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4if; else goto cc4ig;
       cc4if: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4ig: // global
           (_cc4ib::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4ib::I64 == 0) goto cc4id; else goto cc4ic;
       cc4id: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4ic: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4ib::I64;
           R2 = Data.Version.$fReadVersion8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.020391421 UTC

[section ""data" . Data.Version.$fReadVersion6_closure" {
     Data.Version.$fReadVersion6_closure:
         const Data.Version.$fReadVersion6_info;
         const 0;
 },
 Data.Version.$fReadVersion6_entry() //  []
         { info_tbl: [(cc4il,
                       label: Data.Version.$fReadVersion6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4il: // global
           R2 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R1 = GHC.Read.$fRead[]_$s$creadListPrec1_closure;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.021303021 UTC

[section ""data" . Data.Version.$fReadVersion4_closure" {
     Data.Version.$fReadVersion4_closure:
         const Data.Version.$fReadVersion4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion4_entry() //  [R1]
         { info_tbl: [(cc4iu,
                       label: Data.Version.$fReadVersion4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4iu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4iv; else goto cc4iw;
       cc4iv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4iw: // global
           (_cc4ir::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4ir::I64 == 0) goto cc4it; else goto cc4is;
       cc4it: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4is: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4ir::I64;
           R2 = Data.Version.$fReadVersion5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.022213934 UTC

[section ""data" . Data.Version.$fReadVersion3_closure" {
     Data.Version.$fReadVersion3_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Version.$fReadVersion4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.024449811 UTC

[section ""data" . Data.Version.$w$creadPrec_closure" {
     Data.Version.$w$creadPrec_closure:
         const Data.Version.$w$creadPrec_info;
         const 0;
 },
 sat_sc425_entry() //  [R1, R2]
         { info_tbl: [(cc4ja,
                       label: sat_sc425_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ja: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4je; else goto cc4jd;
       cc4je: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4jd: // global
           _sc41W::P64 = P64[R1 + 7];
           _sc420::P64 = P64[R1 + 15];
           _sc422::P64 = P64[R1 + 23];
           I64[Hp - 16] = Data.Version.Version_con_info;
           P64[Hp - 8] = _sc420::P64;
           P64[Hp] = _sc422::P64;
           R2 = Hp - 15;
           R1 = _sc41W::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc428_entry() //  [R1, R2]
         { info_tbl: [(cc4ji,
                       label: sat_sc428_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ji: // global
           _sc422::P64 = R2;
           _sc428::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cc4jj; else goto cc4jk;
       cc4jk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc4jm; else goto cc4jl;
       cc4jm: // global
           HpAlloc = 32;
           goto cc4jj;
       cc4jj: // global
           R2 = _sc422::P64;
           R1 = _sc428::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4jl: // global
           _sc41W::P64 = P64[_sc428::P64 + 7];
           _sc420::P64 = P64[_sc428::P64 + 15];
           I64[Hp - 24] = sat_sc425_info;
           P64[Hp - 16] = _sc41W::P64;
           P64[Hp - 8] = _sc420::P64;
           P64[Hp] = _sc422::P64;
           I64[Sp - 8] = block_cc4jf_info;
           R3 = Hp - 23;
           R2 = Data.Version.$fReadVersion3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4jf() //  [R1]
         { info_tbl: [(cc4jf,
                       label: block_cc4jf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4jf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4jp; else goto cc4jo;
       cc4jp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4jo: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc429_entry() //  [R1, R2]
         { info_tbl: [(cc4jq,
                       label: sat_sc429_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4jq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4ju; else goto cc4jt;
       cc4ju: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4jt: // global
           _sc41W::P64 = P64[R1 + 7];
           _sc420::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sc428_info;
           P64[Hp - 8] = _sc41W::P64;
           P64[Hp] = _sc420::P64;
           R5 = Hp - 15;
           R4 = Data.Version.$fReadVersion_n_closure+1;
           R3 = Data.Version.$fReadVersion6_closure+1;
           R2 = Data.Version.$fReadVersion7_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc42c_entry() //  [R1, R2]
         { info_tbl: [(cc4jy,
                       label: sat_sc42c_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4jy: // global
           _sc420::P64 = R2;
           _sc42c::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cc4jz; else goto cc4jA;
       cc4jA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4jC; else goto cc4jB;
       cc4jC: // global
           HpAlloc = 24;
           goto cc4jz;
       cc4jz: // global
           R2 = _sc420::P64;
           R1 = _sc42c::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4jB: // global
           _sc41W::P64 = P64[_sc42c::P64 + 7];
           I64[Hp - 16] = sat_sc429_info;
           P64[Hp - 8] = _sc41W::P64;
           P64[Hp] = _sc420::P64;
           I64[Sp - 8] = block_cc4jv_info;
           R3 = Hp - 15;
           R2 = Data.Version.$fReadVersion9_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4jv() //  [R1]
         { info_tbl: [(cc4jv,
                       label: block_cc4jv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4jv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4jF; else goto cc4jE;
       cc4jF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4jE: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc42d_entry() //  [R1, R2]
         { info_tbl: [(cc4jG,
                       label: sat_sc42d_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4jG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4jK; else goto cc4jJ;
       cc4jK: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4jJ: // global
           _sc41W::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_sc42c_info;
           P64[Hp] = _sc41W::P64;
           R5 = Hp - 7;
           R4 = Data.Version.$fReadVersion_n_closure+1;
           R3 = Data.Version.$fReadVersion12_closure+1;
           R2 = Data.Version.$fReadVersion14_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc42g_entry() //  [R1, R2]
         { info_tbl: [(cc4jO,
                       label: sat_sc42g_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4jO: // global
           _sc41Y::P64 = R2;
           _sc42g::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cc4jP; else goto cc4jQ;
       cc4jQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4jS; else goto cc4jR;
       cc4jS: // global
           HpAlloc = 16;
           goto cc4jP;
       cc4jP: // global
           R2 = _sc41Y::P64;
           R1 = _sc42g::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4jR: // global
           _sc41W::P64 = P64[_sc42g::P64 + 7];
           I64[Hp - 8] = sat_sc42d_info;
           P64[Hp] = _sc41W::P64;
           I64[Sp - 8] = block_cc4jL_info;
           R3 = Hp - 7;
           R2 = Data.Version.$fReadVersion_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4jL() //  [R1]
         { info_tbl: [(cc4jL,
                       label: block_cc4jL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4jL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4jV; else goto cc4jU;
       cc4jV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4jU: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.$w$creadPrec_entry() //  [R2, R3]
         { info_tbl: [(cc4jZ,
                       label: Data.Version.$w$creadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4jZ: // global
           _sc41W::P64 = R3;
           _sc41V::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cc4k0; else goto cc4k1;
       cc4k1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4k3; else goto cc4k2;
       cc4k3: // global
           HpAlloc = 16;
           goto cc4k0;
       cc4k0: // global
           R3 = _sc41W::P64;
           R2 = _sc41V::I64;
           R1 = Data.Version.$w$creadPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4k2: // global
           if (%MO_S_Gt_W64(_sc41V::I64, 11)) goto cc4jX; else goto cc4jY;
       cc4jX: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4jY: // global
           I64[Hp - 8] = sat_sc42g_info;
           P64[Hp] = _sc41W::P64;
           I64[Sp - 8] = block_cc4k4_info;
           R3 = Hp - 7;
           R2 = Data.Version.$fReadVersion_lexeme1_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4k4() //  [R1]
         { info_tbl: [(cc4k4,
                       label: block_cc4k4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4k4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4k9; else goto cc4k8;
       cc4k9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4k8: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.028602791 UTC

[section ""data" . Data.Version.$fReadVersion2_closure" {
     Data.Version.$fReadVersion2_closure:
         const Data.Version.$fReadVersion2_info;
         const 0;
 },
 Data.Version.$fReadVersion2_entry() //  [R2, R3]
         { info_tbl: [(cc4kh,
                       label: Data.Version.$fReadVersion2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4kh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4ki; else goto cc4kj;
       cc4ki: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fReadVersion2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4kj: // global
           I64[Sp - 16] = block_cc4ke_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4kn; else goto cc4kf;
       uc4kn: // global
           call _cc4ke(R1) args: 0, res: 0, upd: 0;
       cc4kf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4ke() //  [R1]
         { info_tbl: [(cc4ke,
                       label: block_cc4ke_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ke: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Data.Version.$w$creadPrec_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.030047131 UTC

[section ""data" . Data.Version.$fReadVersion1_closure" {
     Data.Version.$fReadVersion1_closure:
         const Data.Version.$fReadVersion1_info;
         const 0;
 },
 Data.Version.$fReadVersion1_entry() //  [R2, R3]
         { info_tbl: [(cc4ks,
                       label: Data.Version.$fReadVersion1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ks: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Version.$fReadVersion2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.03108753 UTC

[section ""data" . Data.Version.$fReadVersion_$creadsPrec_closure" {
     Data.Version.$fReadVersion_$creadsPrec_closure:
         const Data.Version.$fReadVersion_$creadsPrec_info;
         const 0;
 },
 sat_sc42o_entry() //  [R1]
         { info_tbl: [(cc4kD,
                       label: sat_sc42o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4kD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4kE; else goto cc4kF;
       cc4kE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4kF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = Data.Version.$fReadVersion2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Version.$fReadVersion_$creadsPrec_entry() //  [R2]
         { info_tbl: [(cc4kG,
                       label: Data.Version.$fReadVersion_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4kG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4kK; else goto cc4kJ;
       cc4kK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Version.$fReadVersion_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4kJ: // global
           I64[Hp - 16] = sat_sc42o_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.032382006 UTC

[section ""data" . Data.Version.$fReadVersion_$creadListPrec_closure" {
     Data.Version.$fReadVersion_$creadListPrec_closure:
         const Data.Version.$fReadVersion_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion_$creadListPrec_entry() //  [R1]
         { info_tbl: [(cc4kR,
                       label: Data.Version.$fReadVersion_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4kR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4kS; else goto cc4kT;
       cc4kS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4kT: // global
           (_cc4kO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4kO::I64 == 0) goto cc4kQ; else goto cc4kP;
       cc4kQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4kP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4kO::I64;
           R2 = Data.Version.$fReadVersion1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.035444178 UTC

[section ""data" . Data.Version.$fReadVersion20_closure" {
     Data.Version.$fReadVersion20_closure:
         const Data.Version.$fReadVersion20_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion20_entry() //  [R1]
         { info_tbl: [(cc4l0,
                       label: Data.Version.$fReadVersion20_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4l0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4l1; else goto cc4l2;
       cc4l1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4l2: // global
           (_cc4kX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4kX::I64 == 0) goto cc4kZ; else goto cc4kY;
       cc4kZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4kY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4kX::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = Data.Version.$fReadVersion_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.036489304 UTC

[section ""data" . Data.Version.$fReadVersion_$creadList_closure" {
     Data.Version.$fReadVersion_$creadList_closure:
         const Data.Version.$fReadVersion_$creadList_info;
         const 0;
 },
 Data.Version.$fReadVersion_$creadList_entry() //  [R2]
         { info_tbl: [(cc4l7,
                       label: Data.Version.$fReadVersion_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4l7: // global
           R3 = R2;
           R2 = Data.Version.$fReadVersion20_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.037215352 UTC

[section ""data" . Data.Version.$fReadVersion_closure" {
     Data.Version.$fReadVersion_closure:
         const GHC.Read.C:Read_con_info;
         const Data.Version.$fReadVersion_$creadsPrec_closure+1;
         const Data.Version.$fReadVersion_$creadList_closure+1;
         const Data.Version.$fReadVersion1_closure+2;
         const Data.Version.$fReadVersion_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.038059268 UTC

[section ""data" . Data.Version.parseVersion5_closure" {
     Data.Version.parseVersion5_closure:
         const Data.Version.parseVersion5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.parseVersion5_entry() //  [R1]
         { info_tbl: [(cc4lg,
                       label: Data.Version.parseVersion5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4lg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4lh; else goto cc4li;
       cc4lh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4li: // global
           (_cc4ld::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4ld::I64 == 0) goto cc4lf; else goto cc4le;
       cc4lf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4le: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4ld::I64;
           R2 = Text.Read.readEither5_closure;
           Sp = Sp - 16;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.039049626 UTC

[section ""data" . Data.Version.parseVersion4_closure" {
     Data.Version.parseVersion4_closure:
         const Data.Version.parseVersion4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.parseVersion4_entry() //  [R1]
         { info_tbl: [(cc4lp,
                       label: Data.Version.parseVersion4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4lp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4lq; else goto cc4lr;
       cc4lq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4lr: // global
           (_cc4lm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4lm::I64 == 0) goto cc4lo; else goto cc4ln;
       cc4lo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4ln: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4lm::I64;
           R2 = Text.Read.readEither2_closure;
           Sp = Sp - 16;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.040099018 UTC

[section ""data" . Data.Version.parseVersion6_closure" {
     Data.Version.parseVersion6_closure:
         const Data.Version.parseVersion6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.parseVersion6_entry() //  [R1]
         { info_tbl: [(cc4ly,
                       label: Data.Version.parseVersion6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ly: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4lz; else goto cc4lA;
       cc4lz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4lA: // global
           (_cc4lv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4lv::I64 == 0) goto cc4lx; else goto cc4lw;
       cc4lx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4lw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4lv::I64;
           R4 = Text.Read.readEither7_closure+1;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = GHC.Read.$fReadInt2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.042401565 UTC

[section ""data" . Data.Version.$wp_closure" {
     Data.Version.$wp_closure:
         const Data.Version.$wp_info;
         const 0;
 },
 sat_sc42G_entry() //  [R1]
         { info_tbl: [(cc4me,
                       label: sat_sc42G_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4me: // global
           _sc42G::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc4mf; else goto cc4mg;
       cc4mg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4mi; else goto cc4mh;
       cc4mi: // global
           HpAlloc = 24;
           goto cc4mf;
       cc4mf: // global
           R1 = _sc42G::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4mh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc42G::P64;
           _sc42r::P64 = P64[_sc42G::P64 + 16];
           _sc42x::P64 = P64[_sc42G::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sc42r::P64;
           P64[Hp] = _sc42x::P64;
           I64[Sp - 24] = block_cc4mc_info;
           R3 = Hp - 14;
           R2 = Data.Version.parseVersion6_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc4mc() //  [R1]
         { info_tbl: [(cc4mc,
                       label: block_cc4mc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4mc: // global
           I64[Sp] = block_cc4ml_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc4ml() //  [R1]
         { info_tbl: [(cc4ml,
                       label: block_cc4ml_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ml: // global
           if (R1 & 7 == 1) goto cc4ms; else goto cc4mx;
       cc4ms: // global
           R1 = Data.Version.parseVersion5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cc4mx: // global
           I64[Sp - 8] = block_cc4mv_info;
           _sc42B::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sc42B::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4mL; else goto cc4my;
       uc4mL: // global
           call _cc4mv(R1) args: 0, res: 0, upd: 0;
       cc4my: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc4mv() //  [R1]
         { info_tbl: [(cc4mv,
                       label: block_cc4mv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4mv: // global
           if (R1 & 7 == 1) goto cc4mE; else goto cc4mI;
       cc4mE: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cc4mI: // global
           R1 = Data.Version.parseVersion4_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc42H_entry() //  [R1, R2]
         { info_tbl: [(cc4mM,
                       label: sat_sc42H_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4mM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc4mQ; else goto cc4mP;
       cc4mQ: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4mP: // global
           _sc42p::P64 = P64[R1 + 7];
           _sc42r::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sc42G_info;
           P64[Hp - 8] = _sc42r::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _sc42p::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc42K_entry() //  [R1, R2]
         { info_tbl: [(cc4mR,
                       label: sat_sc42K_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4mR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4mS; else goto cc4mT;
       cc4mS: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4mT: // global
           I64[Sp - 16] = block_cc4lK_info;
           _sc42p::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sc42p::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4n6; else goto cc4lL;
       uc4n6: // global
           call _cc4lK(R1) args: 0, res: 0, upd: 0;
       cc4lL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4lK() //  [R1]
         { info_tbl: [(cc4lK,
                       label: block_cc4lK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4lK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4mW; else goto cc4mV;
       cc4mW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4mV: // global
           if (I64[R1 + 7] - 48 > 9) goto cc4mY; else goto cc4n2;
       cc4mY: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4n2: // global
           I64[Hp - 16] = sat_sc42H_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cc4mZ_info;
           R3 = Hp - 15;
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.$wmunch_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4mZ() //  [R1]
         { info_tbl: [(cc4mZ,
                       label: block_cc4mZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4mZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4n5; else goto cc4n4;
       cc4n5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4n4: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.$wp_entry() //  [R2]
         { info_tbl: [(cc4n7,
                       label: Data.Version.$wp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4n7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4nb; else goto cc4na;
       cc4nb: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Version.$wp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4na: // global
           I64[Hp - 8] = sat_sc42K_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.045475631 UTC

[section ""data" . Data.Version.parseVersion3_closure" {
     Data.Version.parseVersion3_closure:
         const Data.Version.parseVersion3_info;
         const 0;
 },
 Data.Version.parseVersion3_entry() //  [R2]
         { info_tbl: [(cc4nj,
                       label: Data.Version.parseVersion3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4nj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc4nk; else goto cc4nl;
       cc4nk: // global
           R2 = R2;
           R1 = Data.Version.parseVersion3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4nl: // global
           I64[Sp - 8] = block_cc4ng_info;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Version.$wp_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4ng() //  [R1]
         { info_tbl: [(cc4ng,
                       label: block_cc4ng_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ng: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4no; else goto cc4nn;
       cc4no: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4nn: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.047085402 UTC

[section ""data" . Data.Version.parseVersion_m2_closure" {
     Data.Version.parseVersion_m2_closure:
         const Data.Version.parseVersion_m2_info;
         const 0;
 },
 lvl4_sc42P_entry() //  [R1]
         { info_tbl: [(cc4nA,
                       label: lvl4_sc42P_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4nA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc4nB; else goto cc4nC;
       cc4nB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4nC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cc4nx_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Data.Version.$wp_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc4nx() //  [R1]
         { info_tbl: [(cc4nx,
                       label: block_cc4nx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4nx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4nF; else goto cc4nE;
       cc4nF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cc4nE: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc42W_entry() //  [R1, R2]
         { info_tbl: [(cc4nO,
                       label: sat_sc42W_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4nO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4nP; else goto cc4nQ;
       cc4nP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4nQ: // global
           I64[Sp - 16] = block_cc4nL_info;
           _sc42P::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sc42P::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4nY; else goto cc4nM;
       uc4nY: // global
           call _cc4nL(R1) args: 0, res: 0, upd: 0;
       cc4nM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4nL() //  [R1]
         { info_tbl: [(cc4nL,
                       label: block_cc4nL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4nL: // global
           if (I64[R1 + 7] == 46) goto cc4nX; else goto cc4nW;
       cc4nX: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc4nW: // global
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.parseVersion_m2_entry() //  [R2]
         { info_tbl: [(cc4o0,
                       label: Data.Version.parseVersion_m2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4o0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc4o4; else goto cc4o3;
       cc4o4: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Version.parseVersion_m2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4o3: // global
           I64[Hp - 48] = lvl4_sc42P_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = sat_sc42W_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.05001752 UTC

[section ""data" . Data.Version.$wlvl_closure" {
     Data.Version.$wlvl_closure:
         const Data.Version.$wlvl_info;
 },
 sat_sc439_entry() //  [R1, R2]
         { info_tbl: [(cc4os,
                       label: sat_sc439_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4os: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4ow; else goto cc4ov;
       cc4ow: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4ov: // global
           _sc42X::P64 = P64[R1 + 7];
           _sc436::P64 = P64[R1 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sc436::P64;
           P64[Hp] = R2;
           R2 = Hp - 14;
           R1 = _sc42X::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $www1_sc42Y_entry() //  [R1, R2]
         { info_tbl: [(cc4ox,
                       label: $www1_sc42Y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ox: // global
           _sc42Z::I64 = R2;
           _sc42Y::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cc4oy; else goto cc4oz;
       cc4oz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc4oB; else goto cc4oA;
       cc4oB: // global
           HpAlloc = 40;
           goto cc4oy;
       cc4oy: // global
           R2 = _sc42Z::I64;
           R1 = _sc42Y::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4oA: // global
           _sc42X::P64 = P64[_sc42Y::P64 + 7];
           (_sc434::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] u_iswalnum(_sc42Z::I64);
           if (_sc434::I64 == 0) goto cc4oK; else goto cc4oG;
       cc4oK: // global
           Hp = Hp - 40;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4oG: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _sc42Z::I64;
           I64[Hp - 16] = sat_sc439_info;
           P64[Hp - 8] = _sc42X::P64;
           P64[Hp] = Hp - 31;
           I64[Sp - 8] = block_cc4oC_info;
           R3 = Hp - 15;
           R2 = GHC.Unicode.isAlphaNum_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wmunch_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4oC() //  [R1]
         { info_tbl: [(cc4oC,
                       label: block_cc4oC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4oC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4oJ; else goto cc4oI;
       cc4oJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4oI: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 ww1_sc43c_entry() //  [R1, R2]
         { info_tbl: [(cc4oT,
                       label: ww1_sc43c_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4oT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4oU; else goto cc4oV;
       cc4oU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4oV: // global
           I64[Sp - 16] = block_cc4oQ_info;
           _sc42Y::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sc42Y::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4oZ; else goto cc4oR;
       uc4oZ: // global
           call _cc4oQ(R1) args: 0, res: 0, upd: 0;
       cc4oR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4oQ() //  [R1]
         { info_tbl: [(cc4oQ,
                       label: block_cc4oQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4oQ: // global
           R2 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $www1_sc42Y_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc43l_entry() //  [R1, R2]
         { info_tbl: [(cc4p9,
                       label: sat_sc43l_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4p9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4pa; else goto cc4pb;
       cc4pa: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4pb: // global
           I64[Sp - 16] = block_cc4p6_info;
           _sc43g::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sc43g::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4pj; else goto cc4p7;
       uc4pj: // global
           call _cc4p6(R1) args: 0, res: 0, upd: 0;
       cc4p7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4p6() //  [R1]
         { info_tbl: [(cc4p6,
                       label: block_cc4p6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4p6: // global
           if (I64[R1 + 7] == 45) goto cc4pi; else goto cc4ph;
       cc4pi: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4ph: // global
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.$wlvl_entry() //  [R2]
         { info_tbl: [(cc4pk,
                       label: Data.Version.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4pk: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc4po; else goto cc4pn;
       cc4po: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Data.Version.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4pn: // global
           I64[Hp - 56] = $www1_sc42Y_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = ww1_sc43c_info;
           P64[Hp - 32] = Hp - 55;
           I64[Hp - 24] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp - 16] = Hp - 39;
           I64[Hp - 8] = sat_sc43l_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.05289918 UTC

[section ""data" . Data.Version.parseVersion2_closure" {
     Data.Version.parseVersion2_closure:
         const Data.Version.parseVersion2_info;
 },
 Data.Version.parseVersion2_entry() //  [R2]
         { info_tbl: [(cc4pw,
                       label: Data.Version.parseVersion2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4pw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc4px; else goto cc4py;
       cc4px: // global
           R2 = R2;
           R1 = Data.Version.parseVersion2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4py: // global
           I64[Sp - 8] = block_cc4pt_info;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Version.$wlvl_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4pt() //  [R1]
         { info_tbl: [(cc4pt,
                       label: block_cc4pt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4pt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4pB; else goto cc4pA;
       cc4pB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4pA: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.055627193 UTC

[section ""data" . Data.Version.$wparseVersion_closure" {
     Data.Version.$wparseVersion_closure:
         const Data.Version.$wparseVersion_info;
         const 0;
 },
 a2_sc43y_entry() //  [R1]
         { info_tbl: [(cc4qf,
                       label: a2_sc43y_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4qf: // global
           _sc43y::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc4qg; else goto cc4qh;
       cc4qh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4qj; else goto cc4qi;
       cc4qj: // global
           HpAlloc = 24;
           goto cc4qg;
       cc4qg: // global
           R1 = _sc43y::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4qi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc43y::P64;
           _sc43r::P64 = P64[_sc43y::P64 + 16];
           _sc43x::P64 = P64[_sc43y::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sc43r::P64;
           P64[Hp] = _sc43x::P64;
           I64[Sp - 24] = block_cc4qd_info;
           R3 = Hp - 14;
           R2 = Data.Version.parseVersion6_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc4qd() //  [R1]
         { info_tbl: [(cc4qd,
                       label: block_cc4qd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4qd: // global
           I64[Sp] = block_cc4qm_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc4qm() //  [R1]
         { info_tbl: [(cc4qm,
                       label: block_cc4qm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4qm: // global
           if (R1 & 7 == 1) goto cc4qt; else goto cc4qy;
       cc4qt: // global
           R1 = Data.Version.parseVersion5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cc4qy: // global
           I64[Sp - 8] = block_cc4qw_info;
           _sc43C::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sc43C::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4qM; else goto cc4qz;
       uc4qM: // global
           call _cc4qw(R1) args: 0, res: 0, upd: 0;
       cc4qz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc4qw() //  [R1]
         { info_tbl: [(cc4qw,
                       label: block_cc4qw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4qw: // global
           if (R1 & 7 == 1) goto cc4qF; else goto cc4qJ;
       cc4qF: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cc4qJ: // global
           R1 = Data.Version.parseVersion4_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc43L_entry() //  [R1, R2]
         { info_tbl: [(cc4qZ,
                       label: sat_sc43L_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4qZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4r3; else goto cc4r2;
       cc4r3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4r2: // global
           _sc43p::P64 = P64[R1 + 7];
           _sc43I::P64 = P64[R1 + 15];
           I64[Hp - 16] = Data.Version.Version_con_info;
           P64[Hp - 8] = _sc43I::P64;
           P64[Hp] = R2;
           R2 = Hp - 15;
           R1 = _sc43p::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc43M_entry() //  [R1, R2]
         { info_tbl: [(cc4r4,
                       label: sat_sc43M_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4r4: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc4r8; else goto cc4r7;
       cc4r8: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4r7: // global
           _sc43p::P64 = P64[R1 + 7];
           _sc43y::P64 = P64[R1 + 15];
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = _sc43y::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sc43L_info;
           P64[Hp - 8] = _sc43p::P64;
           P64[Hp] = Hp - 38;
           R3 = Hp - 15;
           R2 = Data.Version.parseVersion2_closure+1;
           call Text.ParserCombinators.ReadP.endBy3_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc43N_entry() //  [R1, R2]
         { info_tbl: [(cc4r9,
                       label: sat_sc43N_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4r9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc4rd; else goto cc4rc;
       cc4rd: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4rc: // global
           _sc43p::P64 = P64[R1 + 7];
           _sc43r::P64 = P64[R1 + 15];
           I64[Hp - 48] = a2_sc43y_info;
           P64[Hp - 32] = _sc43r::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sc43M_info;
           P64[Hp - 8] = _sc43p::P64;
           P64[Hp] = Hp - 48;
           R3 = Hp - 15;
           R2 = Data.Version.parseVersion_m2_closure+1;
           call Text.ParserCombinators.ReadP.endBy3_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc43Q_entry() //  [R1, R2]
         { info_tbl: [(cc4re,
                       label: sat_sc43Q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4re: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4rf; else goto cc4rg;
       cc4rf: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4rg: // global
           I64[Sp - 16] = block_cc4pL_info;
           _sc43p::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sc43p::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4rt; else goto cc4pM;
       uc4rt: // global
           call _cc4pL(R1) args: 0, res: 0, upd: 0;
       cc4pM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4pL() //  [R1]
         { info_tbl: [(cc4pL,
                       label: block_cc4pL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4pL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4rj; else goto cc4ri;
       cc4rj: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4ri: // global
           if (I64[R1 + 7] - 48 > 9) goto cc4rl; else goto cc4rp;
       cc4rl: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4rp: // global
           I64[Hp - 16] = sat_sc43N_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cc4rm_info;
           R3 = Hp - 15;
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.$wmunch_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4rm() //  [R1]
         { info_tbl: [(cc4rm,
                       label: block_cc4rm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4rm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4rs; else goto cc4rr;
       cc4rs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4rr: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.$wparseVersion_entry() //  [R2]
         { info_tbl: [(cc4ru,
                       label: Data.Version.$wparseVersion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ru: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4ry; else goto cc4rx;
       cc4ry: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Version.$wparseVersion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4rx: // global
           I64[Hp - 8] = sat_sc43Q_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.059336371 UTC

[section ""data" . Data.Version.parseVersion1_closure" {
     Data.Version.parseVersion1_closure:
         const Data.Version.parseVersion1_info;
         const 0;
 },
 Data.Version.parseVersion1_entry() //  [R2]
         { info_tbl: [(cc4rG,
                       label: Data.Version.parseVersion1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4rG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc4rH; else goto cc4rI;
       cc4rH: // global
           R2 = R2;
           R1 = Data.Version.parseVersion1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4rI: // global
           I64[Sp - 8] = block_cc4rD_info;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Version.$wparseVersion_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4rD() //  [R1]
         { info_tbl: [(cc4rD,
                       label: block_cc4rD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4rD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4rL; else goto cc4rK;
       cc4rL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4rK: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.060426754 UTC

[section ""data" . Data.Version.parseVersion_closure" {
     Data.Version.parseVersion_closure:
         const Data.Version.parseVersion_info;
         const 0;
 },
 Data.Version.parseVersion_entry() //  [R2]
         { info_tbl: [(cc4rQ,
                       label: Data.Version.parseVersion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4rQ: // global
           R2 = R2;
           call Data.Version.parseVersion1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.061313896 UTC

[section ""data" . Data.Version.Version_closure" {
     Data.Version.Version_closure:
         const Data.Version.Version_info;
 },
 Data.Version.Version_entry() //  [R2, R3]
         { info_tbl: [(cc4rY,
                       label: Data.Version.Version_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4rY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4s2; else goto cc4s1;
       cc4s2: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.Version_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4s1: // global
           I64[Hp - 16] = Data.Version.Version_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.06216891 UTC

[Data.Version.Version_con_entry() //  [R1]
         { info_tbl: [(cc4s3,
                       label: Data.Version.Version_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,86,101,114,115,105,111,110,46,86,101,114,115,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4s3: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.062855965 UTC

[section ""relreadonly" . Sc4eo_srt" {
     Sc4eo_srt:
         const GHC.Show.showLitString_closure;
         const GHC.Show.showCommaSpace1_closure;
         const f1_rc3Yy_closure;
         const Data.Version.$w$cshowsPrec_closure;
         const Data.Version.$fShowVersion_$cshowsPrec_closure;
         const Data.Version.$fShowVersion_$cshow_closure;
         const Data.Version.$fShowVersion1_closure;
         const Data.Version.showVersion1_closure;
         const Data.Version.$wshowVersion_closure;
         const Data.Version.showVersion_closure;
         const GHC.Read.$fReadInt_$creadListPrec_closure;
         const Data.Version.$fReadVersion13_closure;
         const GHC.Read.$fRead[]_$s$creadListPrec1_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Version.$fReadVersion3_closure;
         const GHC.Read.readField_closure;
         const Data.Version.$fReadVersion6_closure;
         const Data.Version.$fReadVersion7_closure;
         const Data.Version.$fReadVersion9_closure;
         const Data.Version.$fReadVersion12_closure;
         const Data.Version.$fReadVersion14_closure;
         const Data.Version.$fReadVersion_lexeme_closure;
         const Data.Version.$w$creadPrec_closure;
         const Data.Version.$fReadVersion_lexeme1_closure;
         const Data.Version.$fReadVersion2_closure;
         const GHC.Read.list3_closure;
         const Data.Version.$fReadVersion_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Version.$fReadVersion1_closure;
         const Data.Version.$fReadVersion_$creadListPrec_closure;
         const Data.Version.$fReadVersion20_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Text.Read.readEither5_closure;
         const Text.Read.readEither2_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const Data.Version.parseVersion4_closure;
         const Data.Version.parseVersion5_closure;
         const Data.Version.parseVersion6_closure;
         const Data.Version.$wp_closure;
         const Data.Version.parseVersion3_closure;
         const Data.Version.parseVersion_m2_closure;
         const Text.ParserCombinators.ReadP.endBy3_closure;
         const Data.Version.$wparseVersion_closure;
         const Data.Version.parseVersion1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.063643257 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:58.064442705 UTC

[section ""data" . Data.Version.$fGenericVersion_$cto_closure" {
     Data.Version.$fGenericVersion_$cto_closure:
         const Data.Version.$fGenericVersion_$cto_info;
 },
 Data.Version.$fGenericVersion_$cto_entry() //  [R2]
         { info_tbl: [(cc4sa,
                       label: Data.Version.$fGenericVersion_$cto_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4sa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc4se; else goto cc4sf;
       cc4se: // global
           R2 = R2;
           R1 = Data.Version.$fGenericVersion_$cto_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4sf: // global
           I64[Sp - 8] = block_cc4s8_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4s8() //  [R1]
         { info_tbl: [(cc4s8,
                       label: block_cc4s8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4s8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4si; else goto cc4sh;
       cc4si: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4sh: // global
           _sc3YF::P64 = P64[R1 + 7];
           _sc3YG::P64 = P64[R1 + 15];
           I64[Hp - 16] = Data.Version.Version_con_info;
           P64[Hp - 8] = _sc3YF::P64;
           P64[Hp] = _sc3YG::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.065733708 UTC

[section ""data" . Data.Version.$fGenericVersion1_closure" {
     Data.Version.$fGenericVersion1_closure:
         const Data.Version.$fGenericVersion1_info;
 },
 Data.Version.$fGenericVersion1_entry() //  [R2]
         { info_tbl: [(cc4sq,
                       label: Data.Version.$fGenericVersion1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4sq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc4su; else goto cc4sv;
       cc4su: // global
           R2 = R2;
           R1 = Data.Version.$fGenericVersion1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4sv: // global
           I64[Sp - 8] = block_cc4sn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4sz; else goto cc4so;
       uc4sz: // global
           call _cc4sn(R1) args: 0, res: 0, upd: 0;
       cc4so: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4sn() //  [R1]
         { info_tbl: [(cc4sn,
                       label: block_cc4sn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4sn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4sy; else goto cc4sx;
       cc4sy: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4sx: // global
           _sc3YJ::P64 = P64[R1 + 7];
           _sc3YK::P64 = P64[R1 + 15];
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = _sc3YJ::P64;
           P64[Hp] = _sc3YK::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.066776153 UTC

[section ""data" . Data.Version.$fGenericVersion_closure" {
     Data.Version.$fGenericVersion_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Version.$fGenericVersion1_closure+1;
         const Data.Version.$fGenericVersion_$cto_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.067552089 UTC

[section ""data" . Data.Version.versionTags_closure" {
     Data.Version.versionTags_closure:
         const Data.Version.versionTags_info;
 },
 Data.Version.versionTags_entry() //  [R2]
         { info_tbl: [(cc4sH,
                       label: Data.Version.versionTags_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4sH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc4sI; else goto cc4sJ;
       cc4sI: // global
           R2 = R2;
           R1 = Data.Version.versionTags_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4sJ: // global
           I64[Sp - 8] = block_cc4sE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4sN; else goto cc4sF;
       uc4sN: // global
           call _cc4sE(R1) args: 0, res: 0, upd: 0;
       cc4sF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4sE() //  [R1]
         { info_tbl: [(cc4sE,
                       label: block_cc4sE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4sE: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.06868164 UTC

[section ""data" . Data.Version.versionBranch_closure" {
     Data.Version.versionBranch_closure:
         const Data.Version.versionBranch_info;
 },
 Data.Version.versionBranch_entry() //  [R2]
         { info_tbl: [(cc4sV,
                       label: Data.Version.versionBranch_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4sV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc4sW; else goto cc4sX;
       cc4sW: // global
           R2 = R2;
           R1 = Data.Version.versionBranch_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4sX: // global
           I64[Sp - 8] = block_cc4sS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4t1; else goto cc4sT;
       uc4t1: // global
           call _cc4sS(R1) args: 0, res: 0, upd: 0;
       cc4sT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4sS() //  [R1]
         { info_tbl: [(cc4sS,
                       label: block_cc4sS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4sS: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.069892922 UTC

[section ""data" . Data.Version.$fOrdVersion_$ccompare_closure" {
     Data.Version.$fOrdVersion_$ccompare_closure:
         const Data.Version.$fOrdVersion_$ccompare_info;
 },
 Data.Version.$fOrdVersion_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(cc4t9,
                       label: Data.Version.$fOrdVersion_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4t9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4td; else goto cc4te;
       cc4td: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4te: // global
           I64[Sp - 16] = block_cc4t6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4tm; else goto cc4t7;
       uc4tm: // global
           call _cc4t6(R1) args: 0, res: 0, upd: 0;
       cc4t7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4t6() //  [R1]
         { info_tbl: [(cc4t6,
                       label: block_cc4t6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4t6: // global
           I64[Sp] = block_cc4tc_info;
           _sc3YW::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sc3YW::P64;
           if (R1 & 7 != 0) goto uc4tl; else goto cc4tg;
       uc4tl: // global
           call _cc4tc(R1) args: 0, res: 0, upd: 0;
       cc4tg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4tc() //  [R1]
         { info_tbl: [(cc4tc,
                       label: block_cc4tc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4tc: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.071441508 UTC

[section ""data" . Data.Version.$w$c==_closure" {
     Data.Version.$w$c==_closure:
         const Data.Version.$w$c==_info;
 },
 Data.Version.$w$c==_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc4tx,
                       label: Data.Version.$w$c==_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4tx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc4ty; else goto cc4tz;
       cc4ty: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$w$c==_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4tz: // global
           I64[Sp - 24] = block_cc4tr_info;
           _sc3Z2::P64 = R3;
           R3 = R4;
           R2 = R2;
           P64[Sp - 16] = _sc3Z2::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call GHC.Classes.$fEq[]_$s$c==_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4tr() //  [R1]
         { info_tbl: [(cc4tr,
                       label: block_cc4tr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4tr: // global
           if (R1 & 7 == 1) goto cc4tu; else goto cc4tv;
       cc4tu: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4tv: // global
           I64[Sp] = block_cc4tF_info;
           R3 = P64[Sp + 16];
           R2 = GHC.Classes.$fOrd[]_$s$ccompare1_closure+2;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4tF() //  [R1]
         { info_tbl: [(cc4tF,
                       label: block_cc4tF_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4tF: // global
           _sc3Z2::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc4tJ_info;
           R3 = _sc3Z2::P64;
           R2 = GHC.Classes.$fOrd[]_$s$ccompare1_closure+2;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4tJ() //  [R1]
         { info_tbl: [(cc4tJ,
                       label: block_cc4tJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4tJ: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Classes.$fEq[]_$s$c==1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.073049541 UTC

[section ""data" . Data.Version.$fEqVersion_$c==_closure" {
     Data.Version.$fEqVersion_$c==_closure:
         const Data.Version.$fEqVersion_$c==_info;
 },
 Data.Version.$fEqVersion_$c==_entry() //  [R2, R3]
         { info_tbl: [(cc4tX,
                       label: Data.Version.$fEqVersion_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4tX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc4u1; else goto cc4u2;
       cc4u1: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fEqVersion_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4u2: // global
           I64[Sp - 16] = block_cc4tU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4ua; else goto cc4tV;
       uc4ua: // global
           call _cc4tU(R1) args: 0, res: 0, upd: 0;
       cc4tV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4tU() //  [R1]
         { info_tbl: [(cc4tU,
                       label: block_cc4tU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4tU: // global
           I64[Sp - 8] = block_cc4u0_info;
           _sc3Zb::P64 = P64[R1 + 7];
           _sc3Zc::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sc3Zc::P64;
           P64[Sp + 8] = _sc3Zb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4u9; else goto cc4u4;
       uc4u9: // global
           call _cc4u0(R1) args: 0, res: 0, upd: 0;
       cc4u4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4u0() //  [R1]
         { info_tbl: [(cc4u0,
                       label: block_cc4u0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4u0: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Version.$w$c==_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.074801891 UTC

[section ""data" . Data.Version.$fEqVersion_$c/=_closure" {
     Data.Version.$fEqVersion_$c/=_closure:
         const Data.Version.$fEqVersion_$c/=_info;
 },
 Data.Version.$fEqVersion_$c/=_entry() //  [R2, R3]
         { info_tbl: [(cc4ui,
                       label: Data.Version.$fEqVersion_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ui: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc4um; else goto cc4un;
       cc4um: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fEqVersion_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4un: // global
           I64[Sp - 16] = block_cc4uf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4uH; else goto cc4ug;
       uc4uH: // global
           call _cc4uf(R1) args: 0, res: 0, upd: 0;
       cc4ug: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4uf() //  [R1]
         { info_tbl: [(cc4uf,
                       label: block_cc4uf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4uf: // global
           I64[Sp - 8] = block_cc4ul_info;
           _sc3Zj::P64 = P64[R1 + 7];
           _sc3Zk::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sc3Zk::P64;
           P64[Sp + 8] = _sc3Zj::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4uG; else goto cc4up;
       uc4uG: // global
           call _cc4ul(R1) args: 0, res: 0, upd: 0;
       cc4up: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4ul() //  [R1]
         { info_tbl: [(cc4ul,
                       label: block_cc4ul_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ul: // global
           _sc3Zj::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cc4ut_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _sc3Zj::P64;
           Sp = Sp + 16;
           call Data.Version.$w$c==_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4ut() //  [R1]
         { info_tbl: [(cc4ut,
                       label: block_cc4ut_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ut: // global
           if (R1 & 7 == 1) goto cc4uA; else goto cc4uE;
       cc4uA: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4uE: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.076237103 UTC

[section ""data" . Data.Version.$fEqVersion_closure" {
     Data.Version.$fEqVersion_closure:
         const GHC.Classes.C:Eq_con_info;
         const Data.Version.$fEqVersion_$c==_closure+2;
         const Data.Version.$fEqVersion_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.077141037 UTC

[section ""data" . Data.Version.$fOrdVersion_$c<_closure" {
     Data.Version.$fOrdVersion_$c<_closure:
         const Data.Version.$fOrdVersion_$c<_info;
 },
 Data.Version.$fOrdVersion_$c<_entry() //  [R2, R3]
         { info_tbl: [(cc4uP,
                       label: Data.Version.$fOrdVersion_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4uP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4uT; else goto cc4uU;
       cc4uT: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4uU: // global
           I64[Sp - 16] = block_cc4uM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4ve; else goto cc4uN;
       uc4ve: // global
           call _cc4uM(R1) args: 0, res: 0, upd: 0;
       cc4uN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4uM() //  [R1]
         { info_tbl: [(cc4uM,
                       label: block_cc4uM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4uM: // global
           I64[Sp] = block_cc4uS_info;
           _sc3Zs::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sc3Zs::P64;
           if (R1 & 7 != 0) goto uc4vd; else goto cc4uW;
       uc4vd: // global
           call _cc4uS(R1) args: 0, res: 0, upd: 0;
       cc4uW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4uS() //  [R1]
         { info_tbl: [(cc4uS,
                       label: block_cc4uS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4uS: // global
           _sc3Zs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc4v0_info;
           R3 = P64[R1 + 7];
           R2 = _sc3Zs::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4v0() //  [R1]
         { info_tbl: [(cc4v0,
                       label: block_cc4v0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4v0: // global
           if (R1 & 7 == 1) goto cc4vb; else goto cc4v7;
       cc4vb: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4v7: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.07891309 UTC

[section ""data" . Data.Version.$fOrdVersion_$c>=_closure" {
     Data.Version.$fOrdVersion_$c>=_closure:
         const Data.Version.$fOrdVersion_$c>=_info;
 },
 Data.Version.$fOrdVersion_$c>=_entry() //  [R2, R3]
         { info_tbl: [(cc4vm,
                       label: Data.Version.$fOrdVersion_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4vm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4vq; else goto cc4vr;
       cc4vq: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4vr: // global
           I64[Sp - 16] = block_cc4vj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4vL; else goto cc4vk;
       uc4vL: // global
           call _cc4vj(R1) args: 0, res: 0, upd: 0;
       cc4vk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4vj() //  [R1]
         { info_tbl: [(cc4vj,
                       label: block_cc4vj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4vj: // global
           I64[Sp] = block_cc4vp_info;
           _sc3ZB::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sc3ZB::P64;
           if (R1 & 7 != 0) goto uc4vK; else goto cc4vt;
       uc4vK: // global
           call _cc4vp(R1) args: 0, res: 0, upd: 0;
       cc4vt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4vp() //  [R1]
         { info_tbl: [(cc4vp,
                       label: block_cc4vp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4vp: // global
           _sc3ZB::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc4vx_info;
           R3 = P64[R1 + 7];
           R2 = _sc3ZB::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4vx() //  [R1]
         { info_tbl: [(cc4vx,
                       label: block_cc4vx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4vx: // global
           if (R1 & 7 == 1) goto cc4vI; else goto cc4vE;
       cc4vI: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4vE: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.080645403 UTC

[section ""data" . Data.Version.$fOrdVersion_$c>_closure" {
     Data.Version.$fOrdVersion_$c>_closure:
         const Data.Version.$fOrdVersion_$c>_info;
 },
 Data.Version.$fOrdVersion_$c>_entry() //  [R2, R3]
         { info_tbl: [(cc4vT,
                       label: Data.Version.$fOrdVersion_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4vT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4vX; else goto cc4vY;
       cc4vX: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4vY: // global
           I64[Sp - 16] = block_cc4vQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4wi; else goto cc4vR;
       uc4wi: // global
           call _cc4vQ(R1) args: 0, res: 0, upd: 0;
       cc4vR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4vQ() //  [R1]
         { info_tbl: [(cc4vQ,
                       label: block_cc4vQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4vQ: // global
           I64[Sp] = block_cc4vW_info;
           _sc3ZK::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sc3ZK::P64;
           if (R1 & 7 != 0) goto uc4wh; else goto cc4w0;
       uc4wh: // global
           call _cc4vW(R1) args: 0, res: 0, upd: 0;
       cc4w0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4vW() //  [R1]
         { info_tbl: [(cc4vW,
                       label: block_cc4vW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4vW: // global
           _sc3ZK::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc4w4_info;
           R3 = P64[R1 + 7];
           R2 = _sc3ZK::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4w4() //  [R1]
         { info_tbl: [(cc4w4,
                       label: block_cc4w4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4w4: // global
           if (R1 & 7 == 3) goto cc4wf; else goto cc4wb;
       cc4wf: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4wb: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.082408008 UTC

[section ""data" . Data.Version.$fOrdVersion_$c<=_closure" {
     Data.Version.$fOrdVersion_$c<=_closure:
         const Data.Version.$fOrdVersion_$c<=_info;
 },
 Data.Version.$fOrdVersion_$c<=_entry() //  [R2, R3]
         { info_tbl: [(cc4wq,
                       label: Data.Version.$fOrdVersion_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4wq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4wu; else goto cc4wv;
       cc4wu: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4wv: // global
           I64[Sp - 16] = block_cc4wn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4wP; else goto cc4wo;
       uc4wP: // global
           call _cc4wn(R1) args: 0, res: 0, upd: 0;
       cc4wo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4wn() //  [R1]
         { info_tbl: [(cc4wn,
                       label: block_cc4wn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4wn: // global
           I64[Sp] = block_cc4wt_info;
           _sc3ZT::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sc3ZT::P64;
           if (R1 & 7 != 0) goto uc4wO; else goto cc4wx;
       uc4wO: // global
           call _cc4wt(R1) args: 0, res: 0, upd: 0;
       cc4wx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4wt() //  [R1]
         { info_tbl: [(cc4wt,
                       label: block_cc4wt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4wt: // global
           _sc3ZT::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc4wB_info;
           R3 = P64[R1 + 7];
           R2 = _sc3ZT::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4wB() //  [R1]
         { info_tbl: [(cc4wB,
                       label: block_cc4wB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4wB: // global
           if (R1 & 7 == 3) goto cc4wM; else goto cc4wI;
       cc4wM: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4wI: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.084206536 UTC

[section ""data" . Data.Version.$fOrdVersion_$cmax_closure" {
     Data.Version.$fOrdVersion_$cmax_closure:
         const Data.Version.$fOrdVersion_$cmax_info;
 },
 Data.Version.$fOrdVersion_$cmax_entry() //  [R2, R3]
         { info_tbl: [(cc4wX,
                       label: Data.Version.$fOrdVersion_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4wX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc4x1; else goto cc4x2;
       cc4x1: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4x2: // global
           I64[Sp - 16] = block_cc4wU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4xm; else goto cc4wV;
       uc4xm: // global
           call _cc4wU(R1) args: 0, res: 0, upd: 0;
       cc4wV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4wU() //  [R1]
         { info_tbl: [(cc4wU,
                       label: block_cc4wU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4wU: // global
           I64[Sp - 8] = block_cc4x0_info;
           _sc401::P64 = R1;
           _sc402::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp] = _sc402::P64;
           P64[Sp + 8] = _sc401::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4xl; else goto cc4x4;
       uc4xl: // global
           call _cc4x0(R1) args: 0, res: 0, upd: 0;
       cc4x4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4x0() //  [R1]
         { info_tbl: [(cc4x0,
                       label: block_cc4x0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4x0: // global
           I64[Sp] = block_cc4x8_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4x8() //  [R1]
         { info_tbl: [(cc4x8,
                       label: block_cc4x8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4x8: // global
           if (R1 & 7 == 3) goto cc4xj; else goto cc4xf;
       cc4xj: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc4xf: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.086070133 UTC

[section ""data" . Data.Version.$fOrdVersion_$cmin_closure" {
     Data.Version.$fOrdVersion_$cmin_closure:
         const Data.Version.$fOrdVersion_$cmin_info;
 },
 Data.Version.$fOrdVersion_$cmin_entry() //  [R2, R3]
         { info_tbl: [(cc4xu,
                       label: Data.Version.$fOrdVersion_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4xu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc4xy; else goto cc4xz;
       cc4xy: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4xz: // global
           I64[Sp - 16] = block_cc4xr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4xT; else goto cc4xs;
       uc4xT: // global
           call _cc4xr(R1) args: 0, res: 0, upd: 0;
       cc4xs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4xr() //  [R1]
         { info_tbl: [(cc4xr,
                       label: block_cc4xr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4xr: // global
           I64[Sp - 8] = block_cc4xx_info;
           _sc40a::P64 = R1;
           _sc40b::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp] = _sc40b::P64;
           P64[Sp + 8] = _sc40a::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4xS; else goto cc4xB;
       uc4xS: // global
           call _cc4xx(R1) args: 0, res: 0, upd: 0;
       cc4xB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4xx() //  [R1]
         { info_tbl: [(cc4xx,
                       label: block_cc4xx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4xx: // global
           I64[Sp] = block_cc4xF_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4xF() //  [R1]
         { info_tbl: [(cc4xF,
                       label: block_cc4xF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4xF: // global
           if (R1 & 7 == 3) goto cc4xQ; else goto cc4xM;
       cc4xQ: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc4xM: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.087508875 UTC

[section ""data" . Data.Version.$fOrdVersion_closure" {
     Data.Version.$fOrdVersion_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Version.$fEqVersion_closure+1;
         const Data.Version.$fOrdVersion_$ccompare_closure+2;
         const Data.Version.$fOrdVersion_$c<_closure+2;
         const Data.Version.$fOrdVersion_$c<=_closure+2;
         const Data.Version.$fOrdVersion_$c>_closure+2;
         const Data.Version.$fOrdVersion_$c>=_closure+2;
         const Data.Version.$fOrdVersion_$cmax_closure+2;
         const Data.Version.$fOrdVersion_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.088270233 UTC

[section ""data" . Data.Version.makeVersion_closure" {
     Data.Version.makeVersion_closure:
         const Data.Version.makeVersion_info;
 },
 Data.Version.makeVersion_entry() //  [R2]
         { info_tbl: [(cc4xZ,
                       label: Data.Version.makeVersion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4xZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4y3; else goto cc4y2;
       cc4y3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Version.makeVersion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4y2: // global
           I64[Hp - 16] = Data.Version.Version_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.089082168 UTC

[section ""cstring" . Data.Version.$trModule4_bytes" {
     Data.Version.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.08966855 UTC

[section ""data" . Data.Version.$trModule3_closure" {
     Data.Version.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Version.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.090161004 UTC

[section ""cstring" . Data.Version.$trModule2_bytes" {
     Data.Version.$trModule2_bytes:
         I8[] [68,97,116,97,46,86,101,114,115,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.090685281 UTC

[section ""data" . Data.Version.$trModule1_closure" {
     Data.Version.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Version.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.091230351 UTC

[section ""data" . Data.Version.$trModule_closure" {
     Data.Version.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Version.$trModule3_closure+1;
         const Data.Version.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.091829695 UTC

[section ""data" . $krep_rc3Yn_closure" {
     $krep_rc3Yn_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcChar_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.092371566 UTC

[section ""data" . $krep1_rc3Yo_closure" {
     $krep1_rc3Yo_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.094906789 UTC

[section ""data" . $krep2_rc3Yp_closure" {
     $krep2_rc3Yp_closure:
         const :_con_info;
         const $krep_rc3Yn_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.09552382 UTC

[section ""data" . $krep3_rc3Yq_closure" {
     $krep3_rc3Yq_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep2_rc3Yp_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.096055387 UTC

[section ""data" . $krep4_rc3Yr_closure" {
     $krep4_rc3Yr_closure:
         const :_con_info;
         const $krep1_rc3Yo_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.096606659 UTC

[section ""data" . $krep5_rc3Ys_closure" {
     $krep5_rc3Ys_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep4_rc3Yr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.097175348 UTC

[section ""data" . $krep6_rc3Yt_closure" {
     $krep6_rc3Yt_closure:
         const :_con_info;
         const $krep3_rc3Yq_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.098162224 UTC

[section ""data" . $krep7_rc3Yu_closure" {
     $krep7_rc3Yu_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep6_rc3Yt_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.098713239 UTC

[section ""cstring" . Data.Version.$fReadVersion19_bytes" {
     Data.Version.$fReadVersion19_bytes:
         I8[] [86,101,114,115,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.099253969 UTC

[section ""data" . Data.Version.$tcVersion1_closure" {
     Data.Version.$tcVersion1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Version.$fReadVersion19_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.099810047 UTC

[section ""data" . Data.Version.$tcVersion_closure" {
     Data.Version.$tcVersion_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Version.$trModule_closure+1;
         const Data.Version.$tcVersion1_closure+1;
         const GHC.Types.krep$*_closure;
         const 18148779789861942324;
         const 12675349638857785520;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.100365392 UTC

[section ""data" . $krep8_rc3Yv_closure" {
     $krep8_rc3Yv_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Version.$tcVersion_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.100906921 UTC

[section ""data" . $krep9_rc3Yw_closure" {
     $krep9_rc3Yw_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rc3Yu_closure+1;
         const $krep8_rc3Yv_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.101508101 UTC

[section ""data" . Data.Version.$tc'Version1_closure" {
     Data.Version.$tc'Version1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_rc3Ys_closure+1;
         const $krep9_rc3Yw_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.10204843 UTC

[section ""cstring" . Data.Version.$tc'Version3_bytes" {
     Data.Version.$tc'Version3_bytes:
         I8[] [39,86,101,114,115,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.102588019 UTC

[section ""data" . Data.Version.$tc'Version2_closure" {
     Data.Version.$tc'Version2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Version.$tc'Version3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.103193264 UTC

[section ""data" . Data.Version.$tc'Version_closure" {
     Data.Version.$tc'Version_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Version.$trModule_closure+1;
         const Data.Version.$tc'Version2_closure+1;
         const Data.Version.$tc'Version1_closure+4;
         const 3698077959655346891;
         const 8062481246695158651;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.10377102 UTC

[section ""cstring" . f_rc3Yx_bytes" {
     f_rc3Yx_bytes:
         I8[] [86,101,114,115,105,111,110,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.104584183 UTC

[section ""data" . f1_rc3Yy_closure" {
     f1_rc3Yy_closure:
         const f1_rc3Yy_info;
         const 0;
         const 0;
         const 0;
 },
 f1_rc3Yy_entry() //  [R1]
         { info_tbl: [(cc4ya,
                       label: f1_rc3Yy_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ya: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4yb; else goto cc4yc;
       cc4yb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4yc: // global
           (_cc4y7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4y7::I64 == 0) goto cc4y9; else goto cc4y8;
       cc4y9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4y8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4y7::I64;
           R2 = f_rc3Yx_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.105539589 UTC

[section ""cstring" . lvl_rc3Yz_bytes" {
     lvl_rc3Yz_bytes:
         I8[] [118,101,114,115,105,111,110,66,114,97,110,99,104,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.106087365 UTC

[section ""cstring" . lvl1_rc3YA_bytes" {
     lvl1_rc3YA_bytes:
         I8[] [118,101,114,115,105,111,110,84,97,103,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.106626236 UTC

[section ""cstring" . Data.Version.$fReadVersion5_bytes" {
     Data.Version.$fReadVersion5_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.1118591 UTC

[section ""data" . Data.Version.$w$cshowsPrec_closure" {
     Data.Version.$w$cshowsPrec_closure:
         const Data.Version.$w$cshowsPrec_info;
         const 0;
 },
 Data.Version.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ye: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Data.Version.$w$cshowsPrec_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 8, res: 0, upd: 8;
     }
 },
 s1_sc40p_entry() //  [R1]
         { info_tbl: [(cc4yH,
                       label: s1_sc40p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4yH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4yI; else goto cc4yJ;
       cc4yI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4yJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Version.$fReadVersion5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc40B_entry() //  [R1]
         { info_tbl: [(cc4zg,
                       label: sat_sc40B_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4zg: // global
           _sc40B::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc4zh; else goto cc4zi;
       cc4zi: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc4zk; else goto cc4zj;
       cc4zk: // global
           HpAlloc = 56;
           goto cc4zh;
       cc4zh: // global
           R1 = _sc40B::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4zj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc40B::P64;
           _sc40u::P64 = P64[_sc40B::P64 + 16];
           _sc40x::P64 = P64[_sc40B::P64 + 24];
           _sc40y::P64 = P64[_sc40B::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sc40u::P64;
           P64[Hp - 24] = _sc40y::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sc40x::P64;
           Sp = Sp - 16;
           call GHC.Show.showLitString_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 showl_sc40u_entry() //  [R1, R2]
         { info_tbl: [(cc4zp,
                       label: showl_sc40u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4zp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc4zq; else goto cc4zr;
       cc4zq: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4zr: // global
           I64[Sp - 24] = block_cc4z4_info;
           _sc40u::P64 = R1;
           _sc40t::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sc40t::P64;
           P64[Sp - 8] = _sc40u::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc4zz; else goto cc4z5;
       uc4zz: // global
           call _cc4z4(R1) args: 0, res: 0, upd: 0;
       cc4z5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4z4() //  [R1]
         { info_tbl: [(cc4z4,
                       label: block_cc4z4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4z4: // global
           if (R1 & 7 == 1) goto cc4zm; else goto cc4zn;
       cc4zm: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4zn: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cc4zy; else goto cc4zx;
       cc4zy: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4zx: // global
           _sc40x::P64 = P64[R1 + 6];
           _sc40y::P64 = P64[R1 + 14];
           I64[Hp - 80] = sat_sc40B_info;
           P64[Hp - 64] = P64[Sp + 16];
           P64[Hp - 56] = _sc40x::P64;
           P64[Hp - 48] = _sc40y::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = GHC.Show.$fShow(,)3_closure;
           P64[Hp - 24] = Hp - 80;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.showList__1_closure;
           P64[Hp] = Hp - 38;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc40D_entry() //  [R1]
         { info_tbl: [(cc4zA,
                       label: sat_sc40D_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4zA: // global
           _sc40D::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc4zB; else goto cc4zC;
       cc4zC: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc4zE; else goto cc4zD;
       cc4zE: // global
           HpAlloc = 40;
           goto cc4zB;
       cc4zB: // global
           R1 = _sc40D::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4zD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc40D::P64;
           _sc40p::P64 = P64[_sc40D::P64 + 16];
           _sc40s::P64 = P64[_sc40D::P64 + 24];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.Show.showList__2_closure;
           P64[Hp - 16] = _sc40p::P64;
           I64[Hp - 8] = showl_sc40u_info;
           P64[Hp] = Hp - 30;
           R2 = _sc40s::P64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call showl_sc40u_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc40F_entry() //  [R1]
         { info_tbl: [(cc4zG,
                       label: sat_sc40F_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4zG: // global
           _sc40F::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc4zH; else goto cc4zI;
       cc4zI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc4zK; else goto cc4zJ;
       cc4zK: // global
           HpAlloc = 56;
           goto cc4zH;
       cc4zH: // global
           R1 = _sc40F::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4zJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc40F::P64;
           _sc40p::P64 = P64[_sc40F::P64 + 16];
           _sc40r::P64 = P64[_sc40F::P64 + 24];
           _sc40s::P64 = P64[_sc40F::P64 + 32];
           I64[Hp - 48] = sat_sc40D_info;
           P64[Hp - 32] = _sc40p::P64;
           P64[Hp - 24] = _sc40s::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sc40r::P64;
           Sp = Sp - 16;
           call GHC.Show.showLitString_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc40H_entry() //  [R1]
         { info_tbl: [(cc4zP,
                       label: sat_sc40H_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4zP: // global
           _sc40H::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc4zQ; else goto cc4zR;
       cc4zR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4zT; else goto cc4zS;
       cc4zT: // global
           HpAlloc = 24;
           goto cc4zQ;
       cc4zQ: // global
           R1 = _sc40H::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4zS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc40H::P64;
           _sc40k::P64 = P64[_sc40H::P64 + 16];
           _sc40n::P64 = P64[_sc40H::P64 + 24];
           I64[Hp - 16] = s1_sc40p_info;
           P64[Hp] = _sc40n::P64;
           I64[Sp - 32] = block_cc4yK_info;
           R1 = _sc40k::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uc4A1; else goto cc4yL;
       uc4A1: // global
           call _cc4yK(R1) args: 0, res: 0, upd: 0;
       cc4yL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc4yK() //  [R1]
         { info_tbl: [(cc4yK,
                       label: block_cc4yK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4yK: // global
           _cc4yD::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc4zM; else goto cc4zN;
       cc4zM: // global
           R3 = _cc4yD::P64;
           R2 = GHC.Show.showList__4_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
       cc4zN: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cc4A0; else goto cc4zZ;
       cc4A0: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cc4zZ: // global
           _sc40r::P64 = P64[R1 + 6];
           _sc40s::P64 = P64[R1 + 14];
           I64[Hp - 80] = sat_sc40F_info;
           P64[Hp - 64] = _cc4yD::P64;
           P64[Hp - 56] = _sc40r::P64;
           P64[Hp - 48] = _sc40s::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = GHC.Show.$fShow(,)3_closure;
           P64[Hp - 24] = Hp - 80;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.showList__3_closure;
           P64[Hp] = Hp - 38;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc40I_entry() //  [R1]
         { info_tbl: [(cc4A2,
                       label: sat_sc40I_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4A2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc4A6; else goto cc4A5;
       cc4A6: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4A5: // global
           _sc40k::P64 = P64[R1 + 16];
           _sc40n::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_sc40H_info;
           P64[Hp - 8] = _sc40k::P64;
           P64[Hp] = _sc40n::P64;
           R3 = Hp - 24;
           R2 = lvl1_rc3YA_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 s_sc40o_entry() //  [R1]
         { info_tbl: [(cc4A7,
                       label: s_sc40o_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4A7: // global
           _sc40o::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc4A8; else goto cc4A9;
       cc4A9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc4Ab; else goto cc4Aa;
       cc4Ab: // global
           HpAlloc = 32;
           goto cc4A8;
       cc4A8: // global
           R1 = _sc40o::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4Aa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc40o::P64;
           _sc40k::P64 = P64[_sc40o::P64 + 16];
           _sc40n::P64 = P64[_sc40o::P64 + 24];
           I64[Hp - 24] = sat_sc40I_info;
           P64[Hp - 8] = _sc40k::P64;
           P64[Hp] = _sc40n::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc410_entry() //  [R1]
         { info_tbl: [(cc4AO,
                       label: sat_sc410_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4AO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc4AV; else goto cc4AW;
       cc4AV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4AW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cc4AL_info;
           _sc40P::P64 = P64[R1 + 16];
           _sc40T::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sc40P::P64;
           P64[Sp - 24] = _sc40T::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc4B3; else goto cc4AM;
       uc4B3: // global
           call _cc4AL(R1) args: 0, res: 0, upd: 0;
       cc4AM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc4AL() //  [R1]
         { info_tbl: [(cc4AL,
                       label: block_cc4AL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4AL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc4AZ; else goto cc4AY;
       cc4AZ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cc4AY: // global
           _sc40V::I64 = I64[R1 + 7];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cc4AS_info;
           R4 = Hp - 24;
           R3 = _sc40V::I64;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc4AS() //  [R1, R2]
         { info_tbl: [(cc4AS,
                       label: block_cc4AS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4AS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4B2; else goto cc4B1;
       cc4B2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cc4B1: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 showl_sc40P_entry() //  [R1, R2]
         { info_tbl: [(cc4B8,
                       label: showl_sc40P_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4B8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc4B9; else goto cc4Ba;
       cc4B9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4Ba: // global
           I64[Sp - 24] = block_cc4AB_info;
           _sc40P::P64 = R1;
           _sc40O::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sc40O::P64;
           P64[Sp - 8] = _sc40P::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc4Bh; else goto cc4AC;
       uc4Bh: // global
           call _cc4AB(R1) args: 0, res: 0, upd: 0;
       cc4AC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4AB() //  [R1]
         { info_tbl: [(cc4AB,
                       label: block_cc4AB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4AB: // global
           if (R1 & 7 == 1) goto cc4B5; else goto cc4B6;
       cc4B5: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4B6: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc4Bg; else goto cc4Bf;
       cc4Bg: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4Bf: // global
           _sc40S::P64 = P64[R1 + 6];
           _sc40T::P64 = P64[R1 + 14];
           I64[Hp - 56] = sat_sc410_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = _sc40S::P64;
           P64[Hp - 24] = _sc40T::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.showList__1_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc411_entry() //  [R1]
         { info_tbl: [(cc4Bi,
                       label: sat_sc411_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Bi: // global
           _sc411::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc4Bj; else goto cc4Bk;
       cc4Bk: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc4Bm; else goto cc4Bl;
       cc4Bm: // global
           HpAlloc = 40;
           goto cc4Bj;
       cc4Bj: // global
           R1 = _sc411::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4Bl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc411::P64;
           _sc40o::P64 = P64[_sc411::P64 + 16];
           _sc40L::P64 = P64[_sc411::P64 + 24];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.Show.showList__2_closure;
           P64[Hp - 16] = _sc40o::P64;
           I64[Hp - 8] = showl_sc40P_info;
           P64[Hp] = Hp - 30;
           R2 = _sc40L::P64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call showl_sc40P_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc415_entry() //  [R1]
         { info_tbl: [(cc4Bn,
                       label: sat_sc415_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Bn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc4Br; else goto cc4Bs;
       cc4Br: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4Bs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cc4Am_info;
           _sc40o::P64 = P64[R1 + 16];
           _sc40L::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sc40o::P64;
           P64[Sp - 24] = _sc40L::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc4Bz; else goto cc4An;
       uc4Bz: // global
           call _cc4Am(R1) args: 0, res: 0, upd: 0;
       cc4An: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc4Am() //  [R1]
         { info_tbl: [(cc4Am,
                       label: block_cc4Am_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Am: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc4Bv; else goto cc4Bu;
       cc4Bv: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cc4Bu: // global
           _sc40N::I64 = I64[R1 + 7];
           I64[Hp - 24] = sat_sc411_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cc4Bo_info;
           R4 = Hp - 24;
           R3 = _sc40N::I64;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc4Bo() //  [R1, R2]
         { info_tbl: [(cc4Bo,
                       label: block_cc4Bo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Bo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4By; else goto cc4Bx;
       cc4By: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cc4Bx: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc416_entry() //  [R1]
         { info_tbl: [(cc4BE,
                       label: sat_sc416_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4BE: // global
           _sc416::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc4BF; else goto cc4BG;
       cc4BG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc4BI; else goto cc4BH;
       cc4BI: // global
           HpAlloc = 32;
           goto cc4BF;
       cc4BF: // global
           R1 = _sc416::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4BH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc416::P64;
           _sc40j::P64 = P64[_sc416::P64 + 16];
           _sc40k::P64 = P64[_sc416::P64 + 24];
           _sc40n::P64 = P64[_sc416::P64 + 32];
           I64[Hp - 24] = s_sc40o_info;
           P64[Hp - 8] = _sc40k::P64;
           P64[Hp] = _sc40n::P64;
           I64[Sp - 32] = block_cc4Ac_info;
           R1 = _sc40j::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uc4BP; else goto cc4Ad;
       uc4BP: // global
           call _cc4Ac(R1) args: 0, res: 0, upd: 0;
       cc4Ad: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc4Ac() //  [R1]
         { info_tbl: [(cc4Ac,
                       label: block_cc4Ac_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Ac: // global
           _cc4yr::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc4BB; else goto cc4BC;
       cc4BB: // global
           R3 = _cc4yr::P64;
           R2 = GHC.Show.showList__4_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
       cc4BC: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc4BO; else goto cc4BN;
       cc4BO: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cc4BN: // global
           _sc40K::P64 = P64[R1 + 6];
           _sc40L::P64 = P64[R1 + 14];
           I64[Hp - 56] = sat_sc415_info;
           P64[Hp - 40] = _cc4yr::P64;
           P64[Hp - 32] = _sc40K::P64;
           P64[Hp - 24] = _sc40L::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.showList__3_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 g_sc40m_entry() //  [R1, R2]
         { info_tbl: [(cc4BQ,
                       label: g_sc40m_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4BQ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc4BU; else goto cc4BT;
       cc4BU: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4BT: // global
           _sc40j::P64 = P64[R1 + 7];
           _sc40k::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_sc416_info;
           P64[Hp - 16] = _sc40j::P64;
           P64[Hp - 8] = _sc40k::P64;
           P64[Hp] = R2;
           R3 = Hp - 32;
           R2 = lvl_rc3Yz_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc418_entry() //  [R1]
         { info_tbl: [(cc4C2,
                       label: sat_sc418_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4C2: // global
           R2 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           call g_sc40m_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc41a_entry() //  [R1]
         { info_tbl: [(cc4Cf,
                       label: sat_sc41a_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Cf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4Cj; else goto cc4Ci;
       cc4Cj: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4Ci: // global
           _sc40l::P64 = P64[R1 + 16];
           _sc40m::P64 = P64[R1 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sc40l::P64;
           R2 = Hp - 14;
           R1 = _sc40m::P64;
           call g_sc40m_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc41b_entry() //  [R1]
         { info_tbl: [(cc4Ck,
                       label: sat_sc41b_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Ck: // global
           _sc41b::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc4Cl; else goto cc4Cm;
       cc4Cm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc4Co; else goto cc4Cn;
       cc4Co: // global
           HpAlloc = 32;
           goto cc4Cl;
       cc4Cl: // global
           R1 = _sc41b::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4Cn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc41b::P64;
           _sc40l::P64 = P64[_sc41b::P64 + 16];
           _sc40m::P64 = P64[_sc41b::P64 + 24];
           I64[Hp - 24] = sat_sc41a_info;
           P64[Hp - 8] = _sc40l::P64;
           P64[Hp] = _sc40m::P64;
           R3 = Hp - 24;
           R2 = f1_rc3Yy_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Version.$w$cshowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc4Cs,
                       label: Data.Version.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Cs: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc4Cw; else goto cc4Cv;
       cc4Cw: // global
           HpAlloc = 80;
           R1 = Data.Version.$w$cshowsPrec_closure;
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cc4Cv: // global
           I64[Hp - 72] = g_sc40m_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           _cc4yi::P64 = Hp - 71;
           if (%MO_S_Lt_W64(R2, 11)) goto cc4Cq; else goto cc4Cr;
       cc4Cq: // global
           I64[Hp - 48] = sat_sc418_info;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = _cc4yi::P64;
           _cc4BY::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _cc4BY::P64;
           R2 = f1_rc3Yy_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       cc4Cr: // global
           I64[Hp - 48] = sat_sc41b_info;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = _cc4yi::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.121826204 UTC

[section ""data" . Data.Version.$fShowVersion_$cshowsPrec_closure" {
     Data.Version.$fShowVersion_$cshowsPrec_closure:
         const Data.Version.$fShowVersion_$cshowsPrec_info;
         const 0;
 },
 Data.Version.$fShowVersion_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cc4CF,
                       label: Data.Version.$fShowVersion_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4CF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc4CJ; else goto cc4CK;
       cc4CJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fShowVersion_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4CK: // global
           I64[Sp - 24] = block_cc4CC_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc4CS; else goto cc4CD;
       uc4CS: // global
           call _cc4CC(R1) args: 0, res: 0, upd: 0;
       cc4CD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4CC() //  [R1]
         { info_tbl: [(cc4CC,
                       label: block_cc4CC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4CC: // global
           I64[Sp] = block_cc4CI_info;
           _sc41g::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sc41g::I64;
           if (R1 & 7 != 0) goto uc4CR; else goto cc4CM;
       uc4CR: // global
           call _cc4CI(R1) args: 0, res: 0, upd: 0;
       cc4CM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4CI() //  [R1]
         { info_tbl: [(cc4CI,
                       label: block_cc4CI_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4CI: // global
           R5 = P64[Sp + 16];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call Data.Version.$w$cshowsPrec_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.123082236 UTC

[section ""data" . Data.Version.$fShowVersion2_closure" {
     Data.Version.$fShowVersion2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.123827971 UTC

[section ""data" . Data.Version.$fShowVersion_$cshow_closure" {
     Data.Version.$fShowVersion_$cshow_closure:
         const Data.Version.$fShowVersion_$cshow_info;
         const 0;
 },
 Data.Version.$fShowVersion_$cshow_entry() //  [R2]
         { info_tbl: [(cc4D0,
                       label: Data.Version.$fShowVersion_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4D0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc4D1; else goto cc4D2;
       cc4D1: // global
           R2 = R2;
           R1 = Data.Version.$fShowVersion_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4D2: // global
           I64[Sp - 8] = block_cc4CX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4D6; else goto cc4CY;
       uc4D6: // global
           call _cc4CX(R1) args: 0, res: 0, upd: 0;
       cc4CY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4CX() //  [R1]
         { info_tbl: [(cc4CX,
                       label: block_cc4CX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4CX: // global
           R5 = GHC.Types.[]_closure+1;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call Data.Version.$w$cshowsPrec_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.125135999 UTC

[section ""data" . Data.Version.$fShowVersion1_closure" {
     Data.Version.$fShowVersion1_closure:
         const Data.Version.$fShowVersion1_info;
         const 0;
 },
 Data.Version.$fShowVersion1_entry() //  [R2, R3]
         { info_tbl: [(cc4De,
                       label: Data.Version.$fShowVersion1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4De: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4Df; else goto cc4Dg;
       cc4Df: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fShowVersion1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4Dg: // global
           I64[Sp - 16] = block_cc4Db_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4Dk; else goto cc4Dc;
       uc4Dk: // global
           call _cc4Db(R1) args: 0, res: 0, upd: 0;
       cc4Dc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Db() //  [R1]
         { info_tbl: [(cc4Db,
                       label: block_cc4Db_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Db: // global
           R5 = P64[Sp + 8];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 16;
           call Data.Version.$w$cshowsPrec_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.126305774 UTC

[section ""data" . Data.Version.$fShowVersion_$cshowList_closure" {
     Data.Version.$fShowVersion_$cshowList_closure:
         const Data.Version.$fShowVersion_$cshowList_info;
         const 0;
 },
 Data.Version.$fShowVersion_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cc4Dp,
                       label: Data.Version.$fShowVersion_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Dp: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Version.$fShowVersion1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.127017061 UTC

[section ""data" . Data.Version.$fShowVersion_closure" {
     Data.Version.$fShowVersion_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Version.$fShowVersion_$cshowsPrec_closure+3;
         const Data.Version.$fShowVersion_$cshow_closure+1;
         const Data.Version.$fShowVersion_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.12756801 UTC

[section ""data" . f2_rc3YB_closure" {
     f2_rc3YB_closure:
         const GHC.Types.C#_con_info;
         const 45;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.128107149 UTC

[section ""cstring" . Data.Version.showVersion2_bytes" {
     Data.Version.showVersion2_bytes:
         I8[] [46]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.128844381 UTC

[section ""data" . Data.Version.showVersion1_closure" {
     Data.Version.showVersion1_closure:
         const Data.Version.showVersion1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.showVersion1_entry() //  [R1]
         { info_tbl: [(cc4Dy,
                       label: Data.Version.showVersion1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Dy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4Dz; else goto cc4DA;
       cc4Dz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4DA: // global
           (_cc4Dv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4Dv::I64 == 0) goto cc4Dx; else goto cc4Dw;
       cc4Dx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4Dw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4Dv::I64;
           R2 = Data.Version.showVersion2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.130192014 UTC

[section ""data" . Data.Version.showVersion_go_closure" {
     Data.Version.showVersion_go_closure:
         const Data.Version.showVersion_go_info;
 },
 sat_sc41A_entry() //  [R1]
         { info_tbl: [(cc4DP,
                       label: sat_sc41A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4DP: // global
           R2 = P64[R1 + 16];
           call Data.Version.showVersion_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.showVersion_go_entry() //  [R2]
         { info_tbl: [(cc4DW,
                       label: Data.Version.showVersion_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4DW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc4DX; else goto cc4DY;
       cc4DX: // global
           R2 = R2;
           R1 = Data.Version.showVersion_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4DY: // global
           I64[Sp - 8] = block_cc4DF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4E5; else goto cc4DG;
       uc4E5: // global
           call _cc4DF(R1) args: 0, res: 0, upd: 0;
       cc4DG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4DF() //  [R1]
         { info_tbl: [(cc4DF,
                       label: block_cc4DF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4DF: // global
           if (R1 & 7 == 1) goto cc4DT; else goto cc4DU;
       cc4DT: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4DU: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc4E4; else goto cc4E3;
       cc4E4: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4E3: // global
           _sc41x::P64 = P64[R1 + 6];
           _sc41y::P64 = P64[R1 + 14];
           I64[Hp - 40] = sat_sc41A_info;
           P64[Hp - 24] = _sc41y::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = f2_rc3YB_closure+1;
           P64[Hp] = _sc41x::P64;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.132561483 UTC

[section ""data" . Data.Version.$wshowVersion_closure" {
     Data.Version.$wshowVersion_closure:
         const Data.Version.$wshowVersion_info;
         const 0;
 },
 arg_sc41D_entry() //  [R1]
         { info_tbl: [(cc4Ee,
                       label: arg_sc41D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Ee: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4Ef; else goto cc4Eg;
       cc4Ef: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4Eg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Version.showVersion_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc41M_entry() //  [R1]
         { info_tbl: [(cc4EB,
                       label: sat_sc41M_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4EB: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_sc41H_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sc41H_entry() //  [R1, R2]
         { info_tbl: [(cc4EI,
                       label: go_sc41H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4EI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc4EJ; else goto cc4EK;
       cc4EJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4EK: // global
           I64[Sp - 24] = block_cc4Er_info;
           _sc41H::P64 = R1;
           _sc41D::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sc41D::P64;
           P64[Sp - 8] = _sc41H::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc4EQ; else goto cc4Es;
       uc4EQ: // global
           call _cc4Er(R1) args: 0, res: 0, upd: 0;
       cc4Es: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Er() //  [R1]
         { info_tbl: [(cc4Er,
                       label: block_cc4Er_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Er: // global
           if (R1 & 7 == 1) goto cc4EF; else goto cc4EG;
       cc4EF: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc4EG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc4EP; else goto cc4EO;
       cc4EP: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4EO: // global
           _sc41K::P64 = P64[R1 + 6];
           _sc41L::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_sc41M_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sc41L::P64;
           R3 = Hp - 24;
           R2 = _sc41K::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc41N_entry() //  [R1]
         { info_tbl: [(cc4EV,
                       label: sat_sc41N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4EV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4EW; else goto cc4EX;
       cc4EW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4EX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Version.showVersion1_closure;
           Sp = Sp - 16;
           call Data.OldList.prependToAll_entry(R3,
                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Version.$wshowVersion_entry() //  [R2, R3]
         { info_tbl: [(cc4F2,
                       label: Data.Version.$wshowVersion_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4F2: // global
           _sc41C::P64 = R3;
           _sc41B::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cc4F3; else goto cc4F4;
       cc4F4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4F6; else goto cc4F5;
       cc4F6: // global
           HpAlloc = 24;
           goto cc4F3;
       cc4F3: // global
           R3 = _sc41C::P64;
           R2 = _sc41B::P64;
           R1 = Data.Version.$wshowVersion_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4F5: // global
           I64[Hp - 16] = arg_sc41D_info;
           P64[Hp] = _sc41C::P64;
           I64[Sp - 16] = block_cc4Eh_info;
           R3 = _sc41B::P64;
           R2 = GHC.Show.$fShowInt_$cshow_closure+1;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Eh() //  [R1]
         { info_tbl: [(cc4Eh,
                       label: block_cc4Eh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Eh: // global
           _cc4Ea::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc4EZ; else goto cc4F0;
       cc4EZ: // global
           R1 = _cc4Ea::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc4F0: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc4Fc; else goto cc4Fb;
       cc4Fc: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4Fb: // global
           _sc41F::P64 = P64[R1 + 6];
           _sc41G::P64 = P64[R1 + 14];
           I64[Hp - 56] = go_sc41H_info;
           P64[Hp - 48] = _cc4Ea::P64;
           I64[Hp - 40] = sat_sc41N_info;
           P64[Hp - 24] = _sc41G::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sc41F::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 14;
           R1 = Hp - 55;
           Sp = Sp + 16;
           call go_sc41H_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.135368743 UTC

[section ""data" . Data.Version.showVersion_closure" {
     Data.Version.showVersion_closure:
         const Data.Version.showVersion_info;
         const 0;
 },
 Data.Version.showVersion_entry() //  [R2]
         { info_tbl: [(cc4Fk,
                       label: Data.Version.showVersion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Fk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc4Fl; else goto cc4Fm;
       cc4Fl: // global
           R2 = R2;
           R1 = Data.Version.showVersion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4Fm: // global
           I64[Sp - 8] = block_cc4Fh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4Fq; else goto cc4Fi;
       uc4Fq: // global
           call _cc4Fh(R1) args: 0, res: 0, upd: 0;
       cc4Fi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Fh() //  [R1]
         { info_tbl: [(cc4Fh,
                       label: block_cc4Fh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Fh: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Version.$wshowVersion_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.136525775 UTC

[section ""data" . Data.Version.$fReadVersion18_closure" {
     Data.Version.$fReadVersion18_closure:
         const Data.Version.$fReadVersion18_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion18_entry() //  [R1]
         { info_tbl: [(cc4Fx,
                       label: Data.Version.$fReadVersion18_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Fx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4Fy; else goto cc4Fz;
       cc4Fy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4Fz: // global
           (_cc4Fu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4Fu::I64 == 0) goto cc4Fw; else goto cc4Fv;
       cc4Fw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4Fv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4Fu::I64;
           R2 = Data.Version.$fReadVersion19_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.137377912 UTC

[section ""data" . Data.Version.$fReadVersion_lexeme1_closure" {
     Data.Version.$fReadVersion_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Version.$fReadVersion18_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.137950439 UTC

[section ""cstring" . Data.Version.$fReadVersion17_bytes" {
     Data.Version.$fReadVersion17_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.138590418 UTC

[section ""data" . Data.Version.$fReadVersion16_closure" {
     Data.Version.$fReadVersion16_closure:
         const Data.Version.$fReadVersion16_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion16_entry() //  [R1]
         { info_tbl: [(cc4FG,
                       label: Data.Version.$fReadVersion16_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4FG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4FH; else goto cc4FI;
       cc4FH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4FI: // global
           (_cc4FD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4FD::I64 == 0) goto cc4FF; else goto cc4FE;
       cc4FF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4FE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4FD::I64;
           R2 = Data.Version.$fReadVersion17_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.139473676 UTC

[section ""data" . Data.Version.$fReadVersion_lexeme_closure" {
     Data.Version.$fReadVersion_lexeme_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Version.$fReadVersion16_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.140009761 UTC

[section ""cstring" . Data.Version.$fReadVersion15_bytes" {
     Data.Version.$fReadVersion15_bytes:
         I8[] [118,101,114,115,105,111,110,66,114,97,110,99,104]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.140707134 UTC

[section ""data" . Data.Version.$fReadVersion14_closure" {
     Data.Version.$fReadVersion14_closure:
         const Data.Version.$fReadVersion14_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion14_entry() //  [R1]
         { info_tbl: [(cc4FP,
                       label: Data.Version.$fReadVersion14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4FP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4FQ; else goto cc4FR;
       cc4FQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4FR: // global
           (_cc4FM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4FM::I64 == 0) goto cc4FO; else goto cc4FN;
       cc4FO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4FN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4FM::I64;
           R2 = Data.Version.$fReadVersion15_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.141773133 UTC

[section ""data" . Data.Version.$fReadVersion13_closure" {
     Data.Version.$fReadVersion13_closure:
         const Data.Version.$fReadVersion13_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion13_entry() //  [R1]
         { info_tbl: [(cc4FY,
                       label: Data.Version.$fReadVersion13_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4FY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4FZ; else goto cc4G0;
       cc4FZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4G0: // global
           (_cc4FV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4FV::I64 == 0) goto cc4FX; else goto cc4FW;
       cc4FX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4FW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4FV::I64;
           R2 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R1 = GHC.Read.$fReadInt_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.142770666 UTC

[section ""data" . Data.Version.$fReadVersion12_closure" {
     Data.Version.$fReadVersion12_closure:
         const Data.Version.$fReadVersion12_info;
         const 0;
 },
 Data.Version.$fReadVersion12_entry() //  []
         { info_tbl: [(cc4G5,
                       label: Data.Version.$fReadVersion12_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4G5: // global
           R1 = Data.Version.$fReadVersion13_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.143464231 UTC

[section ""data" . Data.Version.$fReadVersion_n_closure" {
     Data.Version.$fReadVersion_n_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.145662391 UTC

[section ""cstring" . Data.Version.$fReadVersion11_bytes" {
     Data.Version.$fReadVersion11_bytes:
         I8[] [44]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.14641233 UTC

[section ""data" . Data.Version.$fReadVersion10_closure" {
     Data.Version.$fReadVersion10_closure:
         const Data.Version.$fReadVersion10_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion10_entry() //  [R1]
         { info_tbl: [(cc4Ge,
                       label: Data.Version.$fReadVersion10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Ge: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4Gf; else goto cc4Gg;
       cc4Gf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4Gg: // global
           (_cc4Gb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4Gb::I64 == 0) goto cc4Gd; else goto cc4Gc;
       cc4Gd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4Gc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4Gb::I64;
           R2 = Data.Version.$fReadVersion11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.147300848 UTC

[section ""data" . Data.Version.$fReadVersion9_closure" {
     Data.Version.$fReadVersion9_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Version.$fReadVersion10_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.147859941 UTC

[section ""cstring" . Data.Version.$fReadVersion8_bytes" {
     Data.Version.$fReadVersion8_bytes:
         I8[] [118,101,114,115,105,111,110,84,97,103,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.148527945 UTC

[section ""data" . Data.Version.$fReadVersion7_closure" {
     Data.Version.$fReadVersion7_closure:
         const Data.Version.$fReadVersion7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion7_entry() //  [R1]
         { info_tbl: [(cc4Gn,
                       label: Data.Version.$fReadVersion7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Gn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4Go; else goto cc4Gp;
       cc4Go: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4Gp: // global
           (_cc4Gk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4Gk::I64 == 0) goto cc4Gm; else goto cc4Gl;
       cc4Gm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4Gl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4Gk::I64;
           R2 = Data.Version.$fReadVersion8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.149523944 UTC

[section ""data" . Data.Version.$fReadVersion6_closure" {
     Data.Version.$fReadVersion6_closure:
         const Data.Version.$fReadVersion6_info;
         const 0;
 },
 Data.Version.$fReadVersion6_entry() //  []
         { info_tbl: [(cc4Gu,
                       label: Data.Version.$fReadVersion6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Gu: // global
           R2 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R1 = GHC.Read.$fRead[]_$s$creadListPrec1_closure;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.15036837 UTC

[section ""data" . Data.Version.$fReadVersion4_closure" {
     Data.Version.$fReadVersion4_closure:
         const Data.Version.$fReadVersion4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion4_entry() //  [R1]
         { info_tbl: [(cc4GD,
                       label: Data.Version.$fReadVersion4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4GD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4GE; else goto cc4GF;
       cc4GE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4GF: // global
           (_cc4GA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4GA::I64 == 0) goto cc4GC; else goto cc4GB;
       cc4GC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4GB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4GA::I64;
           R2 = Data.Version.$fReadVersion5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.151216216 UTC

[section ""data" . Data.Version.$fReadVersion3_closure" {
     Data.Version.$fReadVersion3_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Version.$fReadVersion4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.15338864 UTC

[section ""data" . Data.Version.$w$creadPrec_closure" {
     Data.Version.$w$creadPrec_closure:
         const Data.Version.$w$creadPrec_info;
         const 0;
 },
 sat_sc425_entry() //  [R1, R2]
         { info_tbl: [(cc4Hj,
                       label: sat_sc425_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Hj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4Hn; else goto cc4Hm;
       cc4Hn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4Hm: // global
           _sc41W::P64 = P64[R1 + 7];
           _sc420::P64 = P64[R1 + 15];
           _sc422::P64 = P64[R1 + 23];
           I64[Hp - 16] = Data.Version.Version_con_info;
           P64[Hp - 8] = _sc420::P64;
           P64[Hp] = _sc422::P64;
           R2 = Hp - 15;
           R1 = _sc41W::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc428_entry() //  [R1, R2]
         { info_tbl: [(cc4Hr,
                       label: sat_sc428_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Hr: // global
           _sc422::P64 = R2;
           _sc428::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cc4Hs; else goto cc4Ht;
       cc4Ht: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc4Hv; else goto cc4Hu;
       cc4Hv: // global
           HpAlloc = 32;
           goto cc4Hs;
       cc4Hs: // global
           R2 = _sc422::P64;
           R1 = _sc428::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4Hu: // global
           _sc41W::P64 = P64[_sc428::P64 + 7];
           _sc420::P64 = P64[_sc428::P64 + 15];
           I64[Hp - 24] = sat_sc425_info;
           P64[Hp - 16] = _sc41W::P64;
           P64[Hp - 8] = _sc420::P64;
           P64[Hp] = _sc422::P64;
           I64[Sp - 8] = block_cc4Ho_info;
           R3 = Hp - 23;
           R2 = Data.Version.$fReadVersion3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Ho() //  [R1]
         { info_tbl: [(cc4Ho,
                       label: block_cc4Ho_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Ho: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4Hy; else goto cc4Hx;
       cc4Hy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4Hx: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc429_entry() //  [R1, R2]
         { info_tbl: [(cc4Hz,
                       label: sat_sc429_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Hz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4HD; else goto cc4HC;
       cc4HD: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4HC: // global
           _sc41W::P64 = P64[R1 + 7];
           _sc420::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sc428_info;
           P64[Hp - 8] = _sc41W::P64;
           P64[Hp] = _sc420::P64;
           R5 = Hp - 15;
           R4 = Data.Version.$fReadVersion_n_closure+1;
           R3 = Data.Version.$fReadVersion6_closure+1;
           R2 = Data.Version.$fReadVersion7_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc42c_entry() //  [R1, R2]
         { info_tbl: [(cc4HH,
                       label: sat_sc42c_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4HH: // global
           _sc420::P64 = R2;
           _sc42c::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cc4HI; else goto cc4HJ;
       cc4HJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4HL; else goto cc4HK;
       cc4HL: // global
           HpAlloc = 24;
           goto cc4HI;
       cc4HI: // global
           R2 = _sc420::P64;
           R1 = _sc42c::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4HK: // global
           _sc41W::P64 = P64[_sc42c::P64 + 7];
           I64[Hp - 16] = sat_sc429_info;
           P64[Hp - 8] = _sc41W::P64;
           P64[Hp] = _sc420::P64;
           I64[Sp - 8] = block_cc4HE_info;
           R3 = Hp - 15;
           R2 = Data.Version.$fReadVersion9_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4HE() //  [R1]
         { info_tbl: [(cc4HE,
                       label: block_cc4HE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4HE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4HO; else goto cc4HN;
       cc4HO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4HN: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc42d_entry() //  [R1, R2]
         { info_tbl: [(cc4HP,
                       label: sat_sc42d_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4HP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4HT; else goto cc4HS;
       cc4HT: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4HS: // global
           _sc41W::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_sc42c_info;
           P64[Hp] = _sc41W::P64;
           R5 = Hp - 7;
           R4 = Data.Version.$fReadVersion_n_closure+1;
           R3 = Data.Version.$fReadVersion12_closure+1;
           R2 = Data.Version.$fReadVersion14_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc42g_entry() //  [R1, R2]
         { info_tbl: [(cc4HX,
                       label: sat_sc42g_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4HX: // global
           _sc41Y::P64 = R2;
           _sc42g::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cc4HY; else goto cc4HZ;
       cc4HZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4I1; else goto cc4I0;
       cc4I1: // global
           HpAlloc = 16;
           goto cc4HY;
       cc4HY: // global
           R2 = _sc41Y::P64;
           R1 = _sc42g::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4I0: // global
           _sc41W::P64 = P64[_sc42g::P64 + 7];
           I64[Hp - 8] = sat_sc42d_info;
           P64[Hp] = _sc41W::P64;
           I64[Sp - 8] = block_cc4HU_info;
           R3 = Hp - 7;
           R2 = Data.Version.$fReadVersion_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4HU() //  [R1]
         { info_tbl: [(cc4HU,
                       label: block_cc4HU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4HU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4I4; else goto cc4I3;
       cc4I4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4I3: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.$w$creadPrec_entry() //  [R2, R3]
         { info_tbl: [(cc4I8,
                       label: Data.Version.$w$creadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4I8: // global
           _sc41W::P64 = R3;
           _sc41V::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cc4I9; else goto cc4Ia;
       cc4Ia: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4Ic; else goto cc4Ib;
       cc4Ic: // global
           HpAlloc = 16;
           goto cc4I9;
       cc4I9: // global
           R3 = _sc41W::P64;
           R2 = _sc41V::I64;
           R1 = Data.Version.$w$creadPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4Ib: // global
           if (%MO_S_Gt_W64(_sc41V::I64, 11)) goto cc4I6; else goto cc4I7;
       cc4I6: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4I7: // global
           I64[Hp - 8] = sat_sc42g_info;
           P64[Hp] = _sc41W::P64;
           I64[Sp - 8] = block_cc4Id_info;
           R3 = Hp - 7;
           R2 = Data.Version.$fReadVersion_lexeme1_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Id() //  [R1]
         { info_tbl: [(cc4Id,
                       label: block_cc4Id_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Id: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4Ii; else goto cc4Ih;
       cc4Ii: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4Ih: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.157377054 UTC

[section ""data" . Data.Version.$fReadVersion2_closure" {
     Data.Version.$fReadVersion2_closure:
         const Data.Version.$fReadVersion2_info;
         const 0;
 },
 Data.Version.$fReadVersion2_entry() //  [R2, R3]
         { info_tbl: [(cc4Iq,
                       label: Data.Version.$fReadVersion2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Iq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4Ir; else goto cc4Is;
       cc4Ir: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fReadVersion2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4Is: // global
           I64[Sp - 16] = block_cc4In_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4Iw; else goto cc4Io;
       uc4Iw: // global
           call _cc4In(R1) args: 0, res: 0, upd: 0;
       cc4Io: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4In() //  [R1]
         { info_tbl: [(cc4In,
                       label: block_cc4In_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4In: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Data.Version.$w$creadPrec_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.158469292 UTC

[section ""data" . Data.Version.$fReadVersion1_closure" {
     Data.Version.$fReadVersion1_closure:
         const Data.Version.$fReadVersion1_info;
         const 0;
 },
 Data.Version.$fReadVersion1_entry() //  [R2, R3]
         { info_tbl: [(cc4IB,
                       label: Data.Version.$fReadVersion1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4IB: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Version.$fReadVersion2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.159485604 UTC

[section ""data" . Data.Version.$fReadVersion_$creadsPrec_closure" {
     Data.Version.$fReadVersion_$creadsPrec_closure:
         const Data.Version.$fReadVersion_$creadsPrec_info;
         const 0;
 },
 sat_sc42o_entry() //  [R1]
         { info_tbl: [(cc4IM,
                       label: sat_sc42o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4IM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4IN; else goto cc4IO;
       cc4IN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4IO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = Data.Version.$fReadVersion2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Version.$fReadVersion_$creadsPrec_entry() //  [R2]
         { info_tbl: [(cc4IP,
                       label: Data.Version.$fReadVersion_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4IP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4IT; else goto cc4IS;
       cc4IT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Version.$fReadVersion_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4IS: // global
           I64[Hp - 16] = sat_sc42o_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.160696167 UTC

[section ""data" . Data.Version.$fReadVersion_$creadListPrec_closure" {
     Data.Version.$fReadVersion_$creadListPrec_closure:
         const Data.Version.$fReadVersion_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion_$creadListPrec_entry() //  [R1]
         { info_tbl: [(cc4J0,
                       label: Data.Version.$fReadVersion_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4J0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4J1; else goto cc4J2;
       cc4J1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4J2: // global
           (_cc4IX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4IX::I64 == 0) goto cc4IZ; else goto cc4IY;
       cc4IZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4IY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4IX::I64;
           R2 = Data.Version.$fReadVersion1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.161984185 UTC

[section ""data" . Data.Version.$fReadVersion20_closure" {
     Data.Version.$fReadVersion20_closure:
         const Data.Version.$fReadVersion20_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion20_entry() //  [R1]
         { info_tbl: [(cc4J9,
                       label: Data.Version.$fReadVersion20_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4J9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4Ja; else goto cc4Jb;
       cc4Ja: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4Jb: // global
           (_cc4J6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4J6::I64 == 0) goto cc4J8; else goto cc4J7;
       cc4J8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4J7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4J6::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = Data.Version.$fReadVersion_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.162973105 UTC

[section ""data" . Data.Version.$fReadVersion_$creadList_closure" {
     Data.Version.$fReadVersion_$creadList_closure:
         const Data.Version.$fReadVersion_$creadList_info;
         const 0;
 },
 Data.Version.$fReadVersion_$creadList_entry() //  [R2]
         { info_tbl: [(cc4Jg,
                       label: Data.Version.$fReadVersion_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Jg: // global
           R3 = R2;
           R2 = Data.Version.$fReadVersion20_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.163668381 UTC

[section ""data" . Data.Version.$fReadVersion_closure" {
     Data.Version.$fReadVersion_closure:
         const GHC.Read.C:Read_con_info;
         const Data.Version.$fReadVersion_$creadsPrec_closure+1;
         const Data.Version.$fReadVersion_$creadList_closure+1;
         const Data.Version.$fReadVersion1_closure+2;
         const Data.Version.$fReadVersion_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.164417358 UTC

[section ""data" . Data.Version.parseVersion5_closure" {
     Data.Version.parseVersion5_closure:
         const Data.Version.parseVersion5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.parseVersion5_entry() //  [R1]
         { info_tbl: [(cc4Jp,
                       label: Data.Version.parseVersion5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Jp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4Jq; else goto cc4Jr;
       cc4Jq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4Jr: // global
           (_cc4Jm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4Jm::I64 == 0) goto cc4Jo; else goto cc4Jn;
       cc4Jo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4Jn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4Jm::I64;
           R2 = Text.Read.readEither5_closure;
           Sp = Sp - 16;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.165457767 UTC

[section ""data" . Data.Version.parseVersion4_closure" {
     Data.Version.parseVersion4_closure:
         const Data.Version.parseVersion4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.parseVersion4_entry() //  [R1]
         { info_tbl: [(cc4Jy,
                       label: Data.Version.parseVersion4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Jy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4Jz; else goto cc4JA;
       cc4Jz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4JA: // global
           (_cc4Jv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4Jv::I64 == 0) goto cc4Jx; else goto cc4Jw;
       cc4Jx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4Jw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4Jv::I64;
           R2 = Text.Read.readEither2_closure;
           Sp = Sp - 16;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.166482159 UTC

[section ""data" . Data.Version.parseVersion6_closure" {
     Data.Version.parseVersion6_closure:
         const Data.Version.parseVersion6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.parseVersion6_entry() //  [R1]
         { info_tbl: [(cc4JH,
                       label: Data.Version.parseVersion6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4JH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4JI; else goto cc4JJ;
       cc4JI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4JJ: // global
           (_cc4JE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc4JE::I64 == 0) goto cc4JG; else goto cc4JF;
       cc4JG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc4JF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc4JE::I64;
           R4 = Text.Read.readEither7_closure+1;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = GHC.Read.$fReadInt2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.168674568 UTC

[section ""data" . Data.Version.$wp_closure" {
     Data.Version.$wp_closure:
         const Data.Version.$wp_info;
         const 0;
 },
 sat_sc42G_entry() //  [R1]
         { info_tbl: [(cc4Kn,
                       label: sat_sc42G_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Kn: // global
           _sc42G::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc4Ko; else goto cc4Kp;
       cc4Kp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4Kr; else goto cc4Kq;
       cc4Kr: // global
           HpAlloc = 24;
           goto cc4Ko;
       cc4Ko: // global
           R1 = _sc42G::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4Kq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc42G::P64;
           _sc42r::P64 = P64[_sc42G::P64 + 16];
           _sc42x::P64 = P64[_sc42G::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sc42r::P64;
           P64[Hp] = _sc42x::P64;
           I64[Sp - 24] = block_cc4Kl_info;
           R3 = Hp - 14;
           R2 = Data.Version.parseVersion6_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc4Kl() //  [R1]
         { info_tbl: [(cc4Kl,
                       label: block_cc4Kl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Kl: // global
           I64[Sp] = block_cc4Ku_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc4Ku() //  [R1]
         { info_tbl: [(cc4Ku,
                       label: block_cc4Ku_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Ku: // global
           if (R1 & 7 == 1) goto cc4KB; else goto cc4KG;
       cc4KB: // global
           R1 = Data.Version.parseVersion5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cc4KG: // global
           I64[Sp - 8] = block_cc4KE_info;
           _sc42B::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sc42B::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4KU; else goto cc4KH;
       uc4KU: // global
           call _cc4KE(R1) args: 0, res: 0, upd: 0;
       cc4KH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc4KE() //  [R1]
         { info_tbl: [(cc4KE,
                       label: block_cc4KE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4KE: // global
           if (R1 & 7 == 1) goto cc4KN; else goto cc4KR;
       cc4KN: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cc4KR: // global
           R1 = Data.Version.parseVersion4_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc42H_entry() //  [R1, R2]
         { info_tbl: [(cc4KV,
                       label: sat_sc42H_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4KV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc4KZ; else goto cc4KY;
       cc4KZ: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4KY: // global
           _sc42p::P64 = P64[R1 + 7];
           _sc42r::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sc42G_info;
           P64[Hp - 8] = _sc42r::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _sc42p::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc42K_entry() //  [R1, R2]
         { info_tbl: [(cc4L0,
                       label: sat_sc42K_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4L0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4L1; else goto cc4L2;
       cc4L1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4L2: // global
           I64[Sp - 16] = block_cc4JT_info;
           _sc42p::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sc42p::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4Lf; else goto cc4JU;
       uc4Lf: // global
           call _cc4JT(R1) args: 0, res: 0, upd: 0;
       cc4JU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4JT() //  [R1]
         { info_tbl: [(cc4JT,
                       label: block_cc4JT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4JT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4L5; else goto cc4L4;
       cc4L5: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4L4: // global
           if (I64[R1 + 7] - 48 > 9) goto cc4L7; else goto cc4Lb;
       cc4L7: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4Lb: // global
           I64[Hp - 16] = sat_sc42H_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cc4L8_info;
           R3 = Hp - 15;
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.$wmunch_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4L8() //  [R1]
         { info_tbl: [(cc4L8,
                       label: block_cc4L8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4L8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4Le; else goto cc4Ld;
       cc4Le: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4Ld: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.$wp_entry() //  [R2]
         { info_tbl: [(cc4Lg,
                       label: Data.Version.$wp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Lg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4Lk; else goto cc4Lj;
       cc4Lk: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Version.$wp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4Lj: // global
           I64[Hp - 8] = sat_sc42K_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.172073129 UTC

[section ""data" . Data.Version.parseVersion3_closure" {
     Data.Version.parseVersion3_closure:
         const Data.Version.parseVersion3_info;
         const 0;
 },
 Data.Version.parseVersion3_entry() //  [R2]
         { info_tbl: [(cc4Ls,
                       label: Data.Version.parseVersion3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Ls: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc4Lt; else goto cc4Lu;
       cc4Lt: // global
           R2 = R2;
           R1 = Data.Version.parseVersion3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4Lu: // global
           I64[Sp - 8] = block_cc4Lp_info;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Version.$wp_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Lp() //  [R1]
         { info_tbl: [(cc4Lp,
                       label: block_cc4Lp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Lp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4Lx; else goto cc4Lw;
       cc4Lx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4Lw: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.173731521 UTC

[section ""data" . Data.Version.parseVersion_m2_closure" {
     Data.Version.parseVersion_m2_closure:
         const Data.Version.parseVersion_m2_info;
         const 0;
 },
 lvl4_sc42P_entry() //  [R1]
         { info_tbl: [(cc4LJ,
                       label: lvl4_sc42P_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4LJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc4LK; else goto cc4LL;
       cc4LK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4LL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cc4LG_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Data.Version.$wp_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc4LG() //  [R1]
         { info_tbl: [(cc4LG,
                       label: block_cc4LG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4LG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4LO; else goto cc4LN;
       cc4LO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cc4LN: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc42W_entry() //  [R1, R2]
         { info_tbl: [(cc4LX,
                       label: sat_sc42W_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4LX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4LY; else goto cc4LZ;
       cc4LY: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4LZ: // global
           I64[Sp - 16] = block_cc4LU_info;
           _sc42P::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sc42P::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4M7; else goto cc4LV;
       uc4M7: // global
           call _cc4LU(R1) args: 0, res: 0, upd: 0;
       cc4LV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4LU() //  [R1]
         { info_tbl: [(cc4LU,
                       label: block_cc4LU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4LU: // global
           if (I64[R1 + 7] == 46) goto cc4M6; else goto cc4M5;
       cc4M6: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc4M5: // global
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.parseVersion_m2_entry() //  [R2]
         { info_tbl: [(cc4M9,
                       label: Data.Version.parseVersion_m2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4M9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc4Md; else goto cc4Mc;
       cc4Md: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Version.parseVersion_m2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4Mc: // global
           I64[Hp - 48] = lvl4_sc42P_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = sat_sc42W_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.176662732 UTC

[section ""data" . Data.Version.$wlvl_closure" {
     Data.Version.$wlvl_closure:
         const Data.Version.$wlvl_info;
 },
 sat_sc439_entry() //  [R1, R2]
         { info_tbl: [(cc4MB,
                       label: sat_sc439_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4MB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4MF; else goto cc4ME;
       cc4MF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4ME: // global
           _sc42X::P64 = P64[R1 + 7];
           _sc436::P64 = P64[R1 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sc436::P64;
           P64[Hp] = R2;
           R2 = Hp - 14;
           R1 = _sc42X::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $www1_sc42Y_entry() //  [R1, R2]
         { info_tbl: [(cc4MG,
                       label: $www1_sc42Y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4MG: // global
           _sc42Z::I64 = R2;
           _sc42Y::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cc4MH; else goto cc4MI;
       cc4MI: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc4MK; else goto cc4MJ;
       cc4MK: // global
           HpAlloc = 40;
           goto cc4MH;
       cc4MH: // global
           R2 = _sc42Z::I64;
           R1 = _sc42Y::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4MJ: // global
           _sc42X::P64 = P64[_sc42Y::P64 + 7];
           (_sc434::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] u_iswalnum(_sc42Z::I64);
           if (_sc434::I64 == 0) goto cc4MT; else goto cc4MP;
       cc4MT: // global
           Hp = Hp - 40;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4MP: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _sc42Z::I64;
           I64[Hp - 16] = sat_sc439_info;
           P64[Hp - 8] = _sc42X::P64;
           P64[Hp] = Hp - 31;
           I64[Sp - 8] = block_cc4ML_info;
           R3 = Hp - 15;
           R2 = GHC.Unicode.isAlphaNum_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wmunch_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4ML() //  [R1]
         { info_tbl: [(cc4ML,
                       label: block_cc4ML_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ML: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4MS; else goto cc4MR;
       cc4MS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4MR: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 ww1_sc43c_entry() //  [R1, R2]
         { info_tbl: [(cc4N2,
                       label: ww1_sc43c_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4N2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4N3; else goto cc4N4;
       cc4N3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4N4: // global
           I64[Sp - 16] = block_cc4MZ_info;
           _sc42Y::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sc42Y::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4N8; else goto cc4N0;
       uc4N8: // global
           call _cc4MZ(R1) args: 0, res: 0, upd: 0;
       cc4N0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4MZ() //  [R1]
         { info_tbl: [(cc4MZ,
                       label: block_cc4MZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4MZ: // global
           R2 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $www1_sc42Y_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc43l_entry() //  [R1, R2]
         { info_tbl: [(cc4Ni,
                       label: sat_sc43l_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Ni: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4Nj; else goto cc4Nk;
       cc4Nj: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4Nk: // global
           I64[Sp - 16] = block_cc4Nf_info;
           _sc43g::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sc43g::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4Ns; else goto cc4Ng;
       uc4Ns: // global
           call _cc4Nf(R1) args: 0, res: 0, upd: 0;
       cc4Ng: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Nf() //  [R1]
         { info_tbl: [(cc4Nf,
                       label: block_cc4Nf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Nf: // global
           if (I64[R1 + 7] == 45) goto cc4Nr; else goto cc4Nq;
       cc4Nr: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4Nq: // global
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.$wlvl_entry() //  [R2]
         { info_tbl: [(cc4Nt,
                       label: Data.Version.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Nt: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc4Nx; else goto cc4Nw;
       cc4Nx: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Data.Version.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4Nw: // global
           I64[Hp - 56] = $www1_sc42Y_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = ww1_sc43c_info;
           P64[Hp - 32] = Hp - 55;
           I64[Hp - 24] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp - 16] = Hp - 39;
           I64[Hp - 8] = sat_sc43l_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.179618503 UTC

[section ""data" . Data.Version.parseVersion2_closure" {
     Data.Version.parseVersion2_closure:
         const Data.Version.parseVersion2_info;
 },
 Data.Version.parseVersion2_entry() //  [R2]
         { info_tbl: [(cc4NF,
                       label: Data.Version.parseVersion2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4NF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc4NG; else goto cc4NH;
       cc4NG: // global
           R2 = R2;
           R1 = Data.Version.parseVersion2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4NH: // global
           I64[Sp - 8] = block_cc4NC_info;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Version.$wlvl_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4NC() //  [R1]
         { info_tbl: [(cc4NC,
                       label: block_cc4NC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4NC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4NK; else goto cc4NJ;
       cc4NK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4NJ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.182195476 UTC

[section ""data" . Data.Version.$wparseVersion_closure" {
     Data.Version.$wparseVersion_closure:
         const Data.Version.$wparseVersion_info;
         const 0;
 },
 a2_sc43y_entry() //  [R1]
         { info_tbl: [(cc4Oo,
                       label: a2_sc43y_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Oo: // global
           _sc43y::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc4Op; else goto cc4Oq;
       cc4Oq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4Os; else goto cc4Or;
       cc4Os: // global
           HpAlloc = 24;
           goto cc4Op;
       cc4Op: // global
           R1 = _sc43y::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc4Or: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc43y::P64;
           _sc43r::P64 = P64[_sc43y::P64 + 16];
           _sc43x::P64 = P64[_sc43y::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sc43r::P64;
           P64[Hp] = _sc43x::P64;
           I64[Sp - 24] = block_cc4Om_info;
           R3 = Hp - 14;
           R2 = Data.Version.parseVersion6_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc4Om() //  [R1]
         { info_tbl: [(cc4Om,
                       label: block_cc4Om_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Om: // global
           I64[Sp] = block_cc4Ov_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc4Ov() //  [R1]
         { info_tbl: [(cc4Ov,
                       label: block_cc4Ov_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Ov: // global
           if (R1 & 7 == 1) goto cc4OC; else goto cc4OH;
       cc4OC: // global
           R1 = Data.Version.parseVersion5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cc4OH: // global
           I64[Sp - 8] = block_cc4OF_info;
           _sc43C::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sc43C::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4OV; else goto cc4OI;
       uc4OV: // global
           call _cc4OF(R1) args: 0, res: 0, upd: 0;
       cc4OI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc4OF() //  [R1]
         { info_tbl: [(cc4OF,
                       label: block_cc4OF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4OF: // global
           if (R1 & 7 == 1) goto cc4OO; else goto cc4OS;
       cc4OO: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cc4OS: // global
           R1 = Data.Version.parseVersion4_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc43L_entry() //  [R1, R2]
         { info_tbl: [(cc4P8,
                       label: sat_sc43L_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4P8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4Pc; else goto cc4Pb;
       cc4Pc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4Pb: // global
           _sc43p::P64 = P64[R1 + 7];
           _sc43I::P64 = P64[R1 + 15];
           I64[Hp - 16] = Data.Version.Version_con_info;
           P64[Hp - 8] = _sc43I::P64;
           P64[Hp] = R2;
           R2 = Hp - 15;
           R1 = _sc43p::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc43M_entry() //  [R1, R2]
         { info_tbl: [(cc4Pd,
                       label: sat_sc43M_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Pd: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc4Ph; else goto cc4Pg;
       cc4Ph: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4Pg: // global
           _sc43p::P64 = P64[R1 + 7];
           _sc43y::P64 = P64[R1 + 15];
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = _sc43y::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sc43L_info;
           P64[Hp - 8] = _sc43p::P64;
           P64[Hp] = Hp - 38;
           R3 = Hp - 15;
           R2 = Data.Version.parseVersion2_closure+1;
           call Text.ParserCombinators.ReadP.endBy3_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc43N_entry() //  [R1, R2]
         { info_tbl: [(cc4Pi,
                       label: sat_sc43N_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Pi: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc4Pm; else goto cc4Pl;
       cc4Pm: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4Pl: // global
           _sc43p::P64 = P64[R1 + 7];
           _sc43r::P64 = P64[R1 + 15];
           I64[Hp - 48] = a2_sc43y_info;
           P64[Hp - 32] = _sc43r::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sc43M_info;
           P64[Hp - 8] = _sc43p::P64;
           P64[Hp] = Hp - 48;
           R3 = Hp - 15;
           R2 = Data.Version.parseVersion_m2_closure+1;
           call Text.ParserCombinators.ReadP.endBy3_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc43Q_entry() //  [R1, R2]
         { info_tbl: [(cc4Pn,
                       label: sat_sc43Q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Pn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4Po; else goto cc4Pp;
       cc4Po: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4Pp: // global
           I64[Sp - 16] = block_cc4NU_info;
           _sc43p::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sc43p::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4PC; else goto cc4NV;
       uc4PC: // global
           call _cc4NU(R1) args: 0, res: 0, upd: 0;
       cc4NV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4NU() //  [R1]
         { info_tbl: [(cc4NU,
                       label: block_cc4NU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4NU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4Ps; else goto cc4Pr;
       cc4Ps: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4Pr: // global
           if (I64[R1 + 7] - 48 > 9) goto cc4Pu; else goto cc4Py;
       cc4Pu: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4Py: // global
           I64[Hp - 16] = sat_sc43N_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cc4Pv_info;
           R3 = Hp - 15;
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.$wmunch_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Pv() //  [R1]
         { info_tbl: [(cc4Pv,
                       label: block_cc4Pv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Pv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4PB; else goto cc4PA;
       cc4PB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4PA: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.$wparseVersion_entry() //  [R2]
         { info_tbl: [(cc4PD,
                       label: Data.Version.$wparseVersion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4PD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4PH; else goto cc4PG;
       cc4PH: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Version.$wparseVersion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4PG: // global
           I64[Hp - 8] = sat_sc43Q_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.186102794 UTC

[section ""data" . Data.Version.parseVersion1_closure" {
     Data.Version.parseVersion1_closure:
         const Data.Version.parseVersion1_info;
         const 0;
 },
 Data.Version.parseVersion1_entry() //  [R2]
         { info_tbl: [(cc4PP,
                       label: Data.Version.parseVersion1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4PP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc4PQ; else goto cc4PR;
       cc4PQ: // global
           R2 = R2;
           R1 = Data.Version.parseVersion1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4PR: // global
           I64[Sp - 8] = block_cc4PM_info;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Version.$wparseVersion_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4PM() //  [R1]
         { info_tbl: [(cc4PM,
                       label: block_cc4PM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4PM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc4PU; else goto cc4PT;
       cc4PU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4PT: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.187206035 UTC

[section ""data" . Data.Version.parseVersion_closure" {
     Data.Version.parseVersion_closure:
         const Data.Version.parseVersion_info;
         const 0;
 },
 Data.Version.parseVersion_entry() //  [R2]
         { info_tbl: [(cc4PZ,
                       label: Data.Version.parseVersion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4PZ: // global
           R2 = R2;
           call Data.Version.parseVersion1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.188045225 UTC

[section ""data" . Data.Version.Version_closure" {
     Data.Version.Version_closure:
         const Data.Version.Version_info;
 },
 Data.Version.Version_entry() //  [R2, R3]
         { info_tbl: [(cc4Q7,
                       label: Data.Version.Version_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Q7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4Qb; else goto cc4Qa;
       cc4Qb: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.Version_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4Qa: // global
           I64[Hp - 16] = Data.Version.Version_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.188875871 UTC

[Data.Version.Version_con_entry() //  [R1]
         { info_tbl: [(cc4Qc,
                       label: Data.Version.Version_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,86,101,114,115,105,111,110,46,86,101,114,115,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Qc: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.189550358 UTC

[section ""relreadonly" . Sc4eo_srt" {
     Sc4eo_srt:
         const GHC.Show.showLitString_closure;
         const GHC.Show.showCommaSpace1_closure;
         const f1_rc3Yy_closure;
         const Data.Version.$w$cshowsPrec_closure;
         const Data.Version.$fShowVersion_$cshowsPrec_closure;
         const Data.Version.$fShowVersion_$cshow_closure;
         const Data.Version.$fShowVersion1_closure;
         const Data.Version.showVersion1_closure;
         const Data.Version.$wshowVersion_closure;
         const Data.Version.showVersion_closure;
         const GHC.Read.$fReadInt_$creadListPrec_closure;
         const Data.Version.$fReadVersion13_closure;
         const GHC.Read.$fRead[]_$s$creadListPrec1_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Version.$fReadVersion3_closure;
         const GHC.Read.readField_closure;
         const Data.Version.$fReadVersion6_closure;
         const Data.Version.$fReadVersion7_closure;
         const Data.Version.$fReadVersion9_closure;
         const Data.Version.$fReadVersion12_closure;
         const Data.Version.$fReadVersion14_closure;
         const Data.Version.$fReadVersion_lexeme_closure;
         const Data.Version.$w$creadPrec_closure;
         const Data.Version.$fReadVersion_lexeme1_closure;
         const Data.Version.$fReadVersion2_closure;
         const GHC.Read.list3_closure;
         const Data.Version.$fReadVersion_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Version.$fReadVersion1_closure;
         const Data.Version.$fReadVersion_$creadListPrec_closure;
         const Data.Version.$fReadVersion20_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Text.Read.readEither5_closure;
         const Text.Read.readEither2_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const Data.Version.parseVersion4_closure;
         const Data.Version.parseVersion5_closure;
         const Data.Version.parseVersion6_closure;
         const Data.Version.$wp_closure;
         const Data.Version.parseVersion3_closure;
         const Data.Version.parseVersion_m2_closure;
         const Text.ParserCombinators.ReadP.endBy3_closure;
         const Data.Version.$wparseVersion_closure;
         const Data.Version.parseVersion1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.190566462 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:58.191938729 UTC

[section ""data" . Data.Version.$fGenericVersion_$cto_closure" {
     Data.Version.$fGenericVersion_$cto_closure:
         const Data.Version.$fGenericVersion_$cto_info;
 },
 Data.Version.$fGenericVersion_$cto_entry() //  [R2]
         { info_tbl: [(cc4Qk,
                       label: Data.Version.$fGenericVersion_$cto_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Qk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc4Qo; else goto cc4Qp;
       cc4Qo: // global
           R2 = R2;
           R1 = Data.Version.$fGenericVersion_$cto_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4Qp: // global
           I64[Sp - 8] = block_cc4Qi_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Qi() //  [R1]
         { info_tbl: [(cc4Qi,
                       label: block_cc4Qi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Qi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4Qs; else goto cc4Qr;
       cc4Qs: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4Qr: // global
           _sc3YF::P64 = P64[R1 + 7];
           _sc3YG::P64 = P64[R1 + 15];
           I64[Hp - 16] = Data.Version.Version_con_info;
           P64[Hp - 8] = _sc3YF::P64;
           P64[Hp] = _sc3YG::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.197672164 UTC

[section ""data" . Data.Version.$fGenericVersion1_closure" {
     Data.Version.$fGenericVersion1_closure:
         const Data.Version.$fGenericVersion1_info;
 },
 Data.Version.$fGenericVersion1_entry() //  [R2]
         { info_tbl: [(cc4QJ,
                       label: Data.Version.$fGenericVersion1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4QJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc4QN; else goto cc4QO;
       cc4QN: // global
           R2 = R2;
           R1 = Data.Version.$fGenericVersion1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4QO: // global
           I64[Sp - 8] = block_cc4QG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4QS; else goto cc4QH;
       uc4QS: // global
           call _cc4QG(R1) args: 0, res: 0, upd: 0;
       cc4QH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4QG() //  [R1]
         { info_tbl: [(cc4QG,
                       label: block_cc4QG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4QG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4QR; else goto cc4QQ;
       cc4QR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc4QQ: // global
           _sc3YJ::P64 = P64[R1 + 7];
           _sc3YK::P64 = P64[R1 + 15];
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = _sc3YJ::P64;
           P64[Hp] = _sc3YK::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.204691648 UTC

[section ""data" . Data.Version.$fGenericVersion_closure" {
     Data.Version.$fGenericVersion_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Version.$fGenericVersion1_closure+1;
         const Data.Version.$fGenericVersion_$cto_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.206644719 UTC

[section ""data" . Data.Version.versionTags_closure" {
     Data.Version.versionTags_closure:
         const Data.Version.versionTags_info;
 },
 Data.Version.versionTags_entry() //  [R2]
         { info_tbl: [(cc4Rb,
                       label: Data.Version.versionTags_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Rb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc4Rc; else goto cc4Rd;
       cc4Rc: // global
           R2 = R2;
           R1 = Data.Version.versionTags_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4Rd: // global
           I64[Sp - 8] = block_cc4R8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4Rh; else goto cc4R9;
       uc4Rh: // global
           call _cc4R8(R1) args: 0, res: 0, upd: 0;
       cc4R9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4R8() //  [R1]
         { info_tbl: [(cc4R8,
                       label: block_cc4R8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4R8: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.212080712 UTC

[section ""data" . Data.Version.versionBranch_closure" {
     Data.Version.versionBranch_closure:
         const Data.Version.versionBranch_info;
 },
 Data.Version.versionBranch_entry() //  [R2]
         { info_tbl: [(cc4RA,
                       label: Data.Version.versionBranch_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4RA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc4RB; else goto cc4RC;
       cc4RB: // global
           R2 = R2;
           R1 = Data.Version.versionBranch_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4RC: // global
           I64[Sp - 8] = block_cc4Rx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4RG; else goto cc4Ry;
       uc4RG: // global
           call _cc4Rx(R1) args: 0, res: 0, upd: 0;
       cc4Ry: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Rx() //  [R1]
         { info_tbl: [(cc4Rx,
                       label: block_cc4Rx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Rx: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.217378156 UTC

[section ""data" . Data.Version.$fOrdVersion_$ccompare_closure" {
     Data.Version.$fOrdVersion_$ccompare_closure:
         const Data.Version.$fOrdVersion_$ccompare_info;
 },
 Data.Version.$fOrdVersion_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(cc4RZ,
                       label: Data.Version.$fOrdVersion_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4RZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4S3; else goto cc4S4;
       cc4S3: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4S4: // global
           I64[Sp - 16] = block_cc4RW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4Sc; else goto cc4RX;
       uc4Sc: // global
           call _cc4RW(R1) args: 0, res: 0, upd: 0;
       cc4RX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4RW() //  [R1]
         { info_tbl: [(cc4RW,
                       label: block_cc4RW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4RW: // global
           I64[Sp] = block_cc4S2_info;
           _sc3YW::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sc3YW::P64;
           if (R1 & 7 != 0) goto uc4Sb; else goto cc4S6;
       uc4Sb: // global
           call _cc4S2(R1) args: 0, res: 0, upd: 0;
       cc4S6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4S2() //  [R1]
         { info_tbl: [(cc4S2,
                       label: block_cc4S2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4S2: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.224340901 UTC

[section ""data" . Data.Version.$w$c==_closure" {
     Data.Version.$w$c==_closure:
         const Data.Version.$w$c==_info;
 },
 Data.Version.$w$c==_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc4SA,
                       label: Data.Version.$w$c==_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4SA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc4SB; else goto cc4SC;
       cc4SB: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$w$c==_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4SC: // global
           I64[Sp - 24] = block_cc4Su_info;
           _sc3Z2::P64 = R3;
           R3 = R4;
           R2 = R2;
           P64[Sp - 16] = _sc3Z2::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call GHC.Classes.$fEq[]_$s$c==_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Su() //  [R1]
         { info_tbl: [(cc4Su,
                       label: block_cc4Su_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Su: // global
           if (R1 & 7 == 1) goto cc4Sx; else goto cc4Sy;
       cc4Sx: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4Sy: // global
           I64[Sp] = block_cc4SI_info;
           R3 = P64[Sp + 16];
           R2 = GHC.Classes.$fOrd[]_$s$ccompare1_closure+2;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4SI() //  [R1]
         { info_tbl: [(cc4SI,
                       label: block_cc4SI_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4SI: // global
           _sc3Z2::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc4SM_info;
           R3 = _sc3Z2::P64;
           R2 = GHC.Classes.$fOrd[]_$s$ccompare1_closure+2;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4SM() //  [R1]
         { info_tbl: [(cc4SM,
                       label: block_cc4SM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4SM: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Classes.$fEq[]_$s$c==1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.233020619 UTC

[section ""data" . Data.Version.$fEqVersion_$c==_closure" {
     Data.Version.$fEqVersion_$c==_closure:
         const Data.Version.$fEqVersion_$c==_info;
 },
 Data.Version.$fEqVersion_$c==_entry() //  [R2, R3]
         { info_tbl: [(cc4Th,
                       label: Data.Version.$fEqVersion_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Th: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc4Tl; else goto cc4Tm;
       cc4Tl: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fEqVersion_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4Tm: // global
           I64[Sp - 16] = block_cc4Te_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4Tu; else goto cc4Tf;
       uc4Tu: // global
           call _cc4Te(R1) args: 0, res: 0, upd: 0;
       cc4Tf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Te() //  [R1]
         { info_tbl: [(cc4Te,
                       label: block_cc4Te_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Te: // global
           I64[Sp - 8] = block_cc4Tk_info;
           _sc3Zb::P64 = P64[R1 + 7];
           _sc3Zc::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sc3Zc::P64;
           P64[Sp + 8] = _sc3Zb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4Tt; else goto cc4To;
       uc4Tt: // global
           call _cc4Tk(R1) args: 0, res: 0, upd: 0;
       cc4To: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Tk() //  [R1]
         { info_tbl: [(cc4Tk,
                       label: block_cc4Tk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Tk: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Version.$w$c==_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.241726545 UTC

[section ""data" . Data.Version.$fEqVersion_$c/=_closure" {
     Data.Version.$fEqVersion_$c/=_closure:
         const Data.Version.$fEqVersion_$c/=_info;
 },
 Data.Version.$fEqVersion_$c/=_entry() //  [R2, R3]
         { info_tbl: [(cc4TP,
                       label: Data.Version.$fEqVersion_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4TP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc4TT; else goto cc4TU;
       cc4TT: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fEqVersion_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4TU: // global
           I64[Sp - 16] = block_cc4TM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4Ue; else goto cc4TN;
       uc4Ue: // global
           call _cc4TM(R1) args: 0, res: 0, upd: 0;
       cc4TN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4TM() //  [R1]
         { info_tbl: [(cc4TM,
                       label: block_cc4TM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4TM: // global
           I64[Sp - 8] = block_cc4TS_info;
           _sc3Zj::P64 = P64[R1 + 7];
           _sc3Zk::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sc3Zk::P64;
           P64[Sp + 8] = _sc3Zj::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4Ud; else goto cc4TW;
       uc4Ud: // global
           call _cc4TS(R1) args: 0, res: 0, upd: 0;
       cc4TW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4TS() //  [R1]
         { info_tbl: [(cc4TS,
                       label: block_cc4TS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4TS: // global
           _sc3Zj::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cc4U0_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _sc3Zj::P64;
           Sp = Sp + 16;
           call Data.Version.$w$c==_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4U0() //  [R1]
         { info_tbl: [(cc4U0,
                       label: block_cc4U0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4U0: // global
           if (R1 & 7 == 1) goto cc4U7; else goto cc4Ub;
       cc4U7: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4Ub: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.250178221 UTC

[section ""data" . Data.Version.$fEqVersion_closure" {
     Data.Version.$fEqVersion_closure:
         const GHC.Classes.C:Eq_con_info;
         const Data.Version.$fEqVersion_$c==_closure+2;
         const Data.Version.$fEqVersion_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.252217324 UTC

[section ""data" . Data.Version.$fOrdVersion_$c<_closure" {
     Data.Version.$fOrdVersion_$c<_closure:
         const Data.Version.$fOrdVersion_$c<_info;
 },
 Data.Version.$fOrdVersion_$c<_entry() //  [R2, R3]
         { info_tbl: [(cc4UH,
                       label: Data.Version.$fOrdVersion_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4UH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4UL; else goto cc4UM;
       cc4UL: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4UM: // global
           I64[Sp - 16] = block_cc4UE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4V6; else goto cc4UF;
       uc4V6: // global
           call _cc4UE(R1) args: 0, res: 0, upd: 0;
       cc4UF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4UE() //  [R1]
         { info_tbl: [(cc4UE,
                       label: block_cc4UE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4UE: // global
           I64[Sp] = block_cc4UK_info;
           _sc3Zs::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sc3Zs::P64;
           if (R1 & 7 != 0) goto uc4V5; else goto cc4UO;
       uc4V5: // global
           call _cc4UK(R1) args: 0, res: 0, upd: 0;
       cc4UO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4UK() //  [R1]
         { info_tbl: [(cc4UK,
                       label: block_cc4UK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4UK: // global
           _sc3Zs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc4US_info;
           R3 = P64[R1 + 7];
           R2 = _sc3Zs::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4US() //  [R1]
         { info_tbl: [(cc4US,
                       label: block_cc4US_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4US: // global
           if (R1 & 7 == 1) goto cc4V3; else goto cc4UZ;
       cc4V3: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4UZ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.261376615 UTC

[section ""data" . Data.Version.$fOrdVersion_$c>=_closure" {
     Data.Version.$fOrdVersion_$c>=_closure:
         const Data.Version.$fOrdVersion_$c>=_info;
 },
 Data.Version.$fOrdVersion_$c>=_entry() //  [R2, R3]
         { info_tbl: [(cc4Vy,
                       label: Data.Version.$fOrdVersion_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Vy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4VC; else goto cc4VD;
       cc4VC: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4VD: // global
           I64[Sp - 16] = block_cc4Vv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4VX; else goto cc4Vw;
       uc4VX: // global
           call _cc4Vv(R1) args: 0, res: 0, upd: 0;
       cc4Vw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Vv() //  [R1]
         { info_tbl: [(cc4Vv,
                       label: block_cc4Vv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Vv: // global
           I64[Sp] = block_cc4VB_info;
           _sc3ZB::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sc3ZB::P64;
           if (R1 & 7 != 0) goto uc4VW; else goto cc4VF;
       uc4VW: // global
           call _cc4VB(R1) args: 0, res: 0, upd: 0;
       cc4VF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4VB() //  [R1]
         { info_tbl: [(cc4VB,
                       label: block_cc4VB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4VB: // global
           _sc3ZB::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc4VJ_info;
           R3 = P64[R1 + 7];
           R2 = _sc3ZB::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4VJ() //  [R1]
         { info_tbl: [(cc4VJ,
                       label: block_cc4VJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4VJ: // global
           if (R1 & 7 == 1) goto cc4VU; else goto cc4VQ;
       cc4VU: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4VQ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.271166231 UTC

[section ""data" . Data.Version.$fOrdVersion_$c>_closure" {
     Data.Version.$fOrdVersion_$c>_closure:
         const Data.Version.$fOrdVersion_$c>_info;
 },
 Data.Version.$fOrdVersion_$c>_entry() //  [R2, R3]
         { info_tbl: [(cc4Wp,
                       label: Data.Version.$fOrdVersion_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Wp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4Wt; else goto cc4Wu;
       cc4Wt: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4Wu: // global
           I64[Sp - 16] = block_cc4Wm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4WO; else goto cc4Wn;
       uc4WO: // global
           call _cc4Wm(R1) args: 0, res: 0, upd: 0;
       cc4Wn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Wm() //  [R1]
         { info_tbl: [(cc4Wm,
                       label: block_cc4Wm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Wm: // global
           I64[Sp] = block_cc4Ws_info;
           _sc3ZK::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sc3ZK::P64;
           if (R1 & 7 != 0) goto uc4WN; else goto cc4Ww;
       uc4WN: // global
           call _cc4Ws(R1) args: 0, res: 0, upd: 0;
       cc4Ww: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Ws() //  [R1]
         { info_tbl: [(cc4Ws,
                       label: block_cc4Ws_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Ws: // global
           _sc3ZK::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc4WA_info;
           R3 = P64[R1 + 7];
           R2 = _sc3ZK::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4WA() //  [R1]
         { info_tbl: [(cc4WA,
                       label: block_cc4WA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4WA: // global
           if (R1 & 7 == 3) goto cc4WL; else goto cc4WH;
       cc4WL: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4WH: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.280078608 UTC

[section ""data" . Data.Version.$fOrdVersion_$c<=_closure" {
     Data.Version.$fOrdVersion_$c<=_closure:
         const Data.Version.$fOrdVersion_$c<=_info;
 },
 Data.Version.$fOrdVersion_$c<=_entry() //  [R2, R3]
         { info_tbl: [(cc4Xg,
                       label: Data.Version.$fOrdVersion_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Xg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc4Xk; else goto cc4Xl;
       cc4Xk: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4Xl: // global
           I64[Sp - 16] = block_cc4Xd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4XF; else goto cc4Xe;
       uc4XF: // global
           call _cc4Xd(R1) args: 0, res: 0, upd: 0;
       cc4Xe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Xd() //  [R1]
         { info_tbl: [(cc4Xd,
                       label: block_cc4Xd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Xd: // global
           I64[Sp] = block_cc4Xj_info;
           _sc3ZT::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sc3ZT::P64;
           if (R1 & 7 != 0) goto uc4XE; else goto cc4Xn;
       uc4XE: // global
           call _cc4Xj(R1) args: 0, res: 0, upd: 0;
       cc4Xn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Xj() //  [R1]
         { info_tbl: [(cc4Xj,
                       label: block_cc4Xj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Xj: // global
           _sc3ZT::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc4Xr_info;
           R3 = P64[R1 + 7];
           R2 = _sc3ZT::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Xr() //  [R1]
         { info_tbl: [(cc4Xr,
                       label: block_cc4Xr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Xr: // global
           if (R1 & 7 == 3) goto cc4XC; else goto cc4Xy;
       cc4XC: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc4Xy: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.288924675 UTC

[section ""data" . Data.Version.$fOrdVersion_$cmax_closure" {
     Data.Version.$fOrdVersion_$cmax_closure:
         const Data.Version.$fOrdVersion_$cmax_info;
 },
 Data.Version.$fOrdVersion_$cmax_entry() //  [R2, R3]
         { info_tbl: [(cc4Y7,
                       label: Data.Version.$fOrdVersion_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Y7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc4Yb; else goto cc4Yc;
       cc4Yb: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4Yc: // global
           I64[Sp - 16] = block_cc4Y4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4Yw; else goto cc4Y5;
       uc4Yw: // global
           call _cc4Y4(R1) args: 0, res: 0, upd: 0;
       cc4Y5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Y4() //  [R1]
         { info_tbl: [(cc4Y4,
                       label: block_cc4Y4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Y4: // global
           I64[Sp - 8] = block_cc4Ya_info;
           _sc401::P64 = R1;
           _sc402::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp] = _sc402::P64;
           P64[Sp + 8] = _sc401::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4Yv; else goto cc4Ye;
       uc4Yv: // global
           call _cc4Ya(R1) args: 0, res: 0, upd: 0;
       cc4Ye: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Ya() //  [R1]
         { info_tbl: [(cc4Ya,
                       label: block_cc4Ya_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Ya: // global
           I64[Sp] = block_cc4Yi_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Yi() //  [R1]
         { info_tbl: [(cc4Yi,
                       label: block_cc4Yi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Yi: // global
           if (R1 & 7 == 3) goto cc4Yt; else goto cc4Yp;
       cc4Yt: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc4Yp: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.298280385 UTC

[section ""data" . Data.Version.$fOrdVersion_$cmin_closure" {
     Data.Version.$fOrdVersion_$cmin_closure:
         const Data.Version.$fOrdVersion_$cmin_info;
 },
 Data.Version.$fOrdVersion_$cmin_entry() //  [R2, R3]
         { info_tbl: [(cc4Z0,
                       label: Data.Version.$fOrdVersion_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Z0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc4Z4; else goto cc4Z5;
       cc4Z4: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc4Z5: // global
           I64[Sp - 16] = block_cc4YX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc4Zp; else goto cc4YY;
       uc4Zp: // global
           call _cc4YX(R1) args: 0, res: 0, upd: 0;
       cc4YY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4YX() //  [R1]
         { info_tbl: [(cc4YX,
                       label: block_cc4YX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4YX: // global
           I64[Sp - 8] = block_cc4Z3_info;
           _sc40a::P64 = R1;
           _sc40b::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp] = _sc40b::P64;
           P64[Sp + 8] = _sc40a::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc4Zo; else goto cc4Z7;
       uc4Zo: // global
           call _cc4Z3(R1) args: 0, res: 0, upd: 0;
       cc4Z7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Z3() //  [R1]
         { info_tbl: [(cc4Z3,
                       label: block_cc4Z3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Z3: // global
           I64[Sp] = block_cc4Zb_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc4Zb() //  [R1]
         { info_tbl: [(cc4Zb,
                       label: block_cc4Zb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4Zb: // global
           if (R1 & 7 == 3) goto cc4Zm; else goto cc4Zi;
       cc4Zm: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc4Zi: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.307424189 UTC

[section ""data" . Data.Version.$fOrdVersion_closure" {
     Data.Version.$fOrdVersion_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Version.$fEqVersion_closure+1;
         const Data.Version.$fOrdVersion_$ccompare_closure+2;
         const Data.Version.$fOrdVersion_$c<_closure+2;
         const Data.Version.$fOrdVersion_$c<=_closure+2;
         const Data.Version.$fOrdVersion_$c>_closure+2;
         const Data.Version.$fOrdVersion_$c>=_closure+2;
         const Data.Version.$fOrdVersion_$cmax_closure+2;
         const Data.Version.$fOrdVersion_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.309487589 UTC

[section ""data" . Data.Version.makeVersion_closure" {
     Data.Version.makeVersion_closure:
         const Data.Version.makeVersion_info;
 },
 Data.Version.makeVersion_entry() //  [R2]
         { info_tbl: [(cc4ZS,
                       label: Data.Version.makeVersion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc4ZS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc4ZW; else goto cc4ZV;
       cc4ZW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Version.makeVersion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc4ZV: // global
           I64[Hp - 16] = Data.Version.Version_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.31295682 UTC

[section ""cstring" . Data.Version.$trModule4_bytes" {
     Data.Version.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.314814087 UTC

[section ""data" . Data.Version.$trModule3_closure" {
     Data.Version.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Version.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.316461042 UTC

[section ""cstring" . Data.Version.$trModule2_bytes" {
     Data.Version.$trModule2_bytes:
         I8[] [68,97,116,97,46,86,101,114,115,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.318105131 UTC

[section ""data" . Data.Version.$trModule1_closure" {
     Data.Version.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Version.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.319721466 UTC

[section ""data" . Data.Version.$trModule_closure" {
     Data.Version.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Version.$trModule3_closure+1;
         const Data.Version.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.321398886 UTC

[section ""data" . $krep_rc3Yn_closure" {
     $krep_rc3Yn_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcChar_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.323078458 UTC

[section ""data" . $krep1_rc3Yo_closure" {
     $krep1_rc3Yo_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.324713393 UTC

[section ""data" . $krep2_rc3Yp_closure" {
     $krep2_rc3Yp_closure:
         const :_con_info;
         const $krep_rc3Yn_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.326445237 UTC

[section ""data" . $krep3_rc3Yq_closure" {
     $krep3_rc3Yq_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep2_rc3Yp_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.328103949 UTC

[section ""data" . $krep4_rc3Yr_closure" {
     $krep4_rc3Yr_closure:
         const :_con_info;
         const $krep1_rc3Yo_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.329786278 UTC

[section ""data" . $krep5_rc3Ys_closure" {
     $krep5_rc3Ys_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep4_rc3Yr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.331826447 UTC

[section ""data" . $krep6_rc3Yt_closure" {
     $krep6_rc3Yt_closure:
         const :_con_info;
         const $krep3_rc3Yq_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.333728767 UTC

[section ""data" . $krep7_rc3Yu_closure" {
     $krep7_rc3Yu_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep6_rc3Yt_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.335379361 UTC

[section ""cstring" . Data.Version.$fReadVersion19_bytes" {
     Data.Version.$fReadVersion19_bytes:
         I8[] [86,101,114,115,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.336965529 UTC

[section ""data" . Data.Version.$tcVersion1_closure" {
     Data.Version.$tcVersion1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Version.$fReadVersion19_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.338586555 UTC

[section ""data" . Data.Version.$tcVersion_closure" {
     Data.Version.$tcVersion_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Version.$trModule_closure+1;
         const Data.Version.$tcVersion1_closure+1;
         const GHC.Types.krep$*_closure;
         const 18148779789861942324;
         const 12675349638857785520;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.340344331 UTC

[section ""data" . $krep8_rc3Yv_closure" {
     $krep8_rc3Yv_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Version.$tcVersion_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.341982108 UTC

[section ""data" . $krep9_rc3Yw_closure" {
     $krep9_rc3Yw_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rc3Yu_closure+1;
         const $krep8_rc3Yv_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.343606095 UTC

[section ""data" . Data.Version.$tc'Version1_closure" {
     Data.Version.$tc'Version1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_rc3Ys_closure+1;
         const $krep9_rc3Yw_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.345227628 UTC

[section ""cstring" . Data.Version.$tc'Version3_bytes" {
     Data.Version.$tc'Version3_bytes:
         I8[] [39,86,101,114,115,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.346893748 UTC

[section ""data" . Data.Version.$tc'Version2_closure" {
     Data.Version.$tc'Version2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Version.$tc'Version3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.348568767 UTC

[section ""data" . Data.Version.$tc'Version_closure" {
     Data.Version.$tc'Version_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Version.$trModule_closure+1;
         const Data.Version.$tc'Version2_closure+1;
         const Data.Version.$tc'Version1_closure+4;
         const 3698077959655346891;
         const 8062481246695158651;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.350364341 UTC

[section ""cstring" . f_rc3Yx_bytes" {
     f_rc3Yx_bytes:
         I8[] [86,101,114,115,105,111,110,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.352283713 UTC

[section ""data" . f1_rc3Yy_closure" {
     f1_rc3Yy_closure:
         const f1_rc3Yy_info;
         const 0;
         const 0;
         const 0;
 },
 f1_rc3Yy_entry() //  [R1]
         { info_tbl: [(cc50v,
                       label: f1_rc3Yy_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc50v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc50w; else goto cc50x;
       cc50w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc50x: // global
           (_cc50s::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc50s::I64 == 0) goto cc50u; else goto cc50t;
       cc50u: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc50t: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc50s::I64;
           R2 = f_rc3Yx_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.357028487 UTC

[section ""cstring" . lvl_rc3Yz_bytes" {
     lvl_rc3Yz_bytes:
         I8[] [118,101,114,115,105,111,110,66,114,97,110,99,104,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.359137535 UTC

[section ""cstring" . lvl1_rc3YA_bytes" {
     lvl1_rc3YA_bytes:
         I8[] [118,101,114,115,105,111,110,84,97,103,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.360704219 UTC

[section ""cstring" . Data.Version.$fReadVersion5_bytes" {
     Data.Version.$fReadVersion5_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.366768261 UTC

[section ""data" . Data.Version.$w$cshowsPrec_closure" {
     Data.Version.$w$cshowsPrec_closure:
         const Data.Version.$w$cshowsPrec_info;
         const 0;
 },
 Data.Version.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc50J: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Data.Version.$w$cshowsPrec_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 8, res: 0, upd: 8;
     }
 },
 s1_sc40p_entry() //  [R1]
         { info_tbl: [(cc51c,
                       label: s1_sc40p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc51c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc51d; else goto cc51e;
       cc51d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc51e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Version.$fReadVersion5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc40B_entry() //  [R1]
         { info_tbl: [(cc51L,
                       label: sat_sc40B_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc51L: // global
           _sc40B::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc51M; else goto cc51N;
       cc51N: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc51P; else goto cc51O;
       cc51P: // global
           HpAlloc = 56;
           goto cc51M;
       cc51M: // global
           R1 = _sc40B::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc51O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc40B::P64;
           _sc40u::P64 = P64[_sc40B::P64 + 16];
           _sc40x::P64 = P64[_sc40B::P64 + 24];
           _sc40y::P64 = P64[_sc40B::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sc40u::P64;
           P64[Hp - 24] = _sc40y::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sc40x::P64;
           Sp = Sp - 16;
           call GHC.Show.showLitString_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 showl_sc40u_entry() //  [R1, R2]
         { info_tbl: [(cc51U,
                       label: showl_sc40u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc51U: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc51V; else goto cc51W;
       cc51V: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc51W: // global
           I64[Sp - 24] = block_cc51z_info;
           _sc40u::P64 = R1;
           _sc40t::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sc40t::P64;
           P64[Sp - 8] = _sc40u::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc524; else goto cc51A;
       uc524: // global
           call _cc51z(R1) args: 0, res: 0, upd: 0;
       cc51A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc51z() //  [R1]
         { info_tbl: [(cc51z,
                       label: block_cc51z_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc51z: // global
           if (R1 & 7 == 1) goto cc51R; else goto cc51S;
       cc51R: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc51S: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cc523; else goto cc522;
       cc523: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc522: // global
           _sc40x::P64 = P64[R1 + 6];
           _sc40y::P64 = P64[R1 + 14];
           I64[Hp - 80] = sat_sc40B_info;
           P64[Hp - 64] = P64[Sp + 16];
           P64[Hp - 56] = _sc40x::P64;
           P64[Hp - 48] = _sc40y::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = GHC.Show.$fShow(,)3_closure;
           P64[Hp - 24] = Hp - 80;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.showList__1_closure;
           P64[Hp] = Hp - 38;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc40D_entry() //  [R1]
         { info_tbl: [(cc525,
                       label: sat_sc40D_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc525: // global
           _sc40D::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc526; else goto cc527;
       cc527: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc529; else goto cc528;
       cc529: // global
           HpAlloc = 40;
           goto cc526;
       cc526: // global
           R1 = _sc40D::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc528: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc40D::P64;
           _sc40p::P64 = P64[_sc40D::P64 + 16];
           _sc40s::P64 = P64[_sc40D::P64 + 24];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.Show.showList__2_closure;
           P64[Hp - 16] = _sc40p::P64;
           I64[Hp - 8] = showl_sc40u_info;
           P64[Hp] = Hp - 30;
           R2 = _sc40s::P64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call showl_sc40u_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc40F_entry() //  [R1]
         { info_tbl: [(cc52b,
                       label: sat_sc40F_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc52b: // global
           _sc40F::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc52c; else goto cc52d;
       cc52d: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc52f; else goto cc52e;
       cc52f: // global
           HpAlloc = 56;
           goto cc52c;
       cc52c: // global
           R1 = _sc40F::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc52e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc40F::P64;
           _sc40p::P64 = P64[_sc40F::P64 + 16];
           _sc40r::P64 = P64[_sc40F::P64 + 24];
           _sc40s::P64 = P64[_sc40F::P64 + 32];
           I64[Hp - 48] = sat_sc40D_info;
           P64[Hp - 32] = _sc40p::P64;
           P64[Hp - 24] = _sc40s::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sc40r::P64;
           Sp = Sp - 16;
           call GHC.Show.showLitString_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc40H_entry() //  [R1]
         { info_tbl: [(cc52k,
                       label: sat_sc40H_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc52k: // global
           _sc40H::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc52l; else goto cc52m;
       cc52m: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc52o; else goto cc52n;
       cc52o: // global
           HpAlloc = 24;
           goto cc52l;
       cc52l: // global
           R1 = _sc40H::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc52n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc40H::P64;
           _sc40k::P64 = P64[_sc40H::P64 + 16];
           _sc40n::P64 = P64[_sc40H::P64 + 24];
           I64[Hp - 16] = s1_sc40p_info;
           P64[Hp] = _sc40n::P64;
           I64[Sp - 32] = block_cc51f_info;
           R1 = _sc40k::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uc52w; else goto cc51g;
       uc52w: // global
           call _cc51f(R1) args: 0, res: 0, upd: 0;
       cc51g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc51f() //  [R1]
         { info_tbl: [(cc51f,
                       label: block_cc51f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc51f: // global
           _cc518::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc52h; else goto cc52i;
       cc52h: // global
           R3 = _cc518::P64;
           R2 = GHC.Show.showList__4_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
       cc52i: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cc52v; else goto cc52u;
       cc52v: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cc52u: // global
           _sc40r::P64 = P64[R1 + 6];
           _sc40s::P64 = P64[R1 + 14];
           I64[Hp - 80] = sat_sc40F_info;
           P64[Hp - 64] = _cc518::P64;
           P64[Hp - 56] = _sc40r::P64;
           P64[Hp - 48] = _sc40s::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = GHC.Show.$fShow(,)3_closure;
           P64[Hp - 24] = Hp - 80;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.showList__3_closure;
           P64[Hp] = Hp - 38;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc40I_entry() //  [R1]
         { info_tbl: [(cc52x,
                       label: sat_sc40I_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc52x: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc52B; else goto cc52A;
       cc52B: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc52A: // global
           _sc40k::P64 = P64[R1 + 16];
           _sc40n::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_sc40H_info;
           P64[Hp - 8] = _sc40k::P64;
           P64[Hp] = _sc40n::P64;
           R3 = Hp - 24;
           R2 = lvl1_rc3YA_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 s_sc40o_entry() //  [R1]
         { info_tbl: [(cc52C,
                       label: s_sc40o_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc52C: // global
           _sc40o::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc52D; else goto cc52E;
       cc52E: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc52G; else goto cc52F;
       cc52G: // global
           HpAlloc = 32;
           goto cc52D;
       cc52D: // global
           R1 = _sc40o::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc52F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc40o::P64;
           _sc40k::P64 = P64[_sc40o::P64 + 16];
           _sc40n::P64 = P64[_sc40o::P64 + 24];
           I64[Hp - 24] = sat_sc40I_info;
           P64[Hp - 8] = _sc40k::P64;
           P64[Hp] = _sc40n::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc410_entry() //  [R1]
         { info_tbl: [(cc53j,
                       label: sat_sc410_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc53j: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc53q; else goto cc53r;
       cc53q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc53r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cc53g_info;
           _sc40P::P64 = P64[R1 + 16];
           _sc40T::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sc40P::P64;
           P64[Sp - 24] = _sc40T::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc53y; else goto cc53h;
       uc53y: // global
           call _cc53g(R1) args: 0, res: 0, upd: 0;
       cc53h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc53g() //  [R1]
         { info_tbl: [(cc53g,
                       label: block_cc53g_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc53g: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc53u; else goto cc53t;
       cc53u: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cc53t: // global
           _sc40V::I64 = I64[R1 + 7];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cc53n_info;
           R4 = Hp - 24;
           R3 = _sc40V::I64;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc53n() //  [R1, R2]
         { info_tbl: [(cc53n,
                       label: block_cc53n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc53n: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc53x; else goto cc53w;
       cc53x: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cc53w: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 showl_sc40P_entry() //  [R1, R2]
         { info_tbl: [(cc53D,
                       label: showl_sc40P_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc53D: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc53E; else goto cc53F;
       cc53E: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc53F: // global
           I64[Sp - 24] = block_cc536_info;
           _sc40P::P64 = R1;
           _sc40O::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sc40O::P64;
           P64[Sp - 8] = _sc40P::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc53M; else goto cc537;
       uc53M: // global
           call _cc536(R1) args: 0, res: 0, upd: 0;
       cc537: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc536() //  [R1]
         { info_tbl: [(cc536,
                       label: block_cc536_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc536: // global
           if (R1 & 7 == 1) goto cc53A; else goto cc53B;
       cc53A: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc53B: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc53L; else goto cc53K;
       cc53L: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc53K: // global
           _sc40S::P64 = P64[R1 + 6];
           _sc40T::P64 = P64[R1 + 14];
           I64[Hp - 56] = sat_sc410_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = _sc40S::P64;
           P64[Hp - 24] = _sc40T::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.showList__1_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc411_entry() //  [R1]
         { info_tbl: [(cc53N,
                       label: sat_sc411_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc53N: // global
           _sc411::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc53O; else goto cc53P;
       cc53P: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc53R; else goto cc53Q;
       cc53R: // global
           HpAlloc = 40;
           goto cc53O;
       cc53O: // global
           R1 = _sc411::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc53Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc411::P64;
           _sc40o::P64 = P64[_sc411::P64 + 16];
           _sc40L::P64 = P64[_sc411::P64 + 24];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.Show.showList__2_closure;
           P64[Hp - 16] = _sc40o::P64;
           I64[Hp - 8] = showl_sc40P_info;
           P64[Hp] = Hp - 30;
           R2 = _sc40L::P64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call showl_sc40P_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc415_entry() //  [R1]
         { info_tbl: [(cc53S,
                       label: sat_sc415_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc53S: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc53W; else goto cc53X;
       cc53W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc53X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cc52R_info;
           _sc40o::P64 = P64[R1 + 16];
           _sc40L::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sc40o::P64;
           P64[Sp - 24] = _sc40L::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc544; else goto cc52S;
       uc544: // global
           call _cc52R(R1) args: 0, res: 0, upd: 0;
       cc52S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc52R() //  [R1]
         { info_tbl: [(cc52R,
                       label: block_cc52R_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc52R: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc540; else goto cc53Z;
       cc540: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cc53Z: // global
           _sc40N::I64 = I64[R1 + 7];
           I64[Hp - 24] = sat_sc411_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cc53T_info;
           R4 = Hp - 24;
           R3 = _sc40N::I64;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc53T() //  [R1, R2]
         { info_tbl: [(cc53T,
                       label: block_cc53T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc53T: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc543; else goto cc542;
       cc543: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cc542: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc416_entry() //  [R1]
         { info_tbl: [(cc549,
                       label: sat_sc416_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc549: // global
           _sc416::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc54a; else goto cc54b;
       cc54b: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc54d; else goto cc54c;
       cc54d: // global
           HpAlloc = 32;
           goto cc54a;
       cc54a: // global
           R1 = _sc416::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc54c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc416::P64;
           _sc40j::P64 = P64[_sc416::P64 + 16];
           _sc40k::P64 = P64[_sc416::P64 + 24];
           _sc40n::P64 = P64[_sc416::P64 + 32];
           I64[Hp - 24] = s_sc40o_info;
           P64[Hp - 8] = _sc40k::P64;
           P64[Hp] = _sc40n::P64;
           I64[Sp - 32] = block_cc52H_info;
           R1 = _sc40j::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uc54k; else goto cc52I;
       uc54k: // global
           call _cc52H(R1) args: 0, res: 0, upd: 0;
       cc52I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc52H() //  [R1]
         { info_tbl: [(cc52H,
                       label: block_cc52H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc52H: // global
           _cc50W::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc546; else goto cc547;
       cc546: // global
           R3 = _cc50W::P64;
           R2 = GHC.Show.showList__4_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
       cc547: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc54j; else goto cc54i;
       cc54j: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cc54i: // global
           _sc40K::P64 = P64[R1 + 6];
           _sc40L::P64 = P64[R1 + 14];
           I64[Hp - 56] = sat_sc415_info;
           P64[Hp - 40] = _cc50W::P64;
           P64[Hp - 32] = _sc40K::P64;
           P64[Hp - 24] = _sc40L::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.showList__3_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 g_sc40m_entry() //  [R1, R2]
         { info_tbl: [(cc54l,
                       label: g_sc40m_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc54l: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc54p; else goto cc54o;
       cc54p: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc54o: // global
           _sc40j::P64 = P64[R1 + 7];
           _sc40k::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_sc416_info;
           P64[Hp - 16] = _sc40j::P64;
           P64[Hp - 8] = _sc40k::P64;
           P64[Hp] = R2;
           R3 = Hp - 32;
           R2 = lvl_rc3Yz_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc418_entry() //  [R1]
         { info_tbl: [(cc54x,
                       label: sat_sc418_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc54x: // global
           R2 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           call g_sc40m_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc41a_entry() //  [R1]
         { info_tbl: [(cc54K,
                       label: sat_sc41a_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc54K: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc54O; else goto cc54N;
       cc54O: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc54N: // global
           _sc40l::P64 = P64[R1 + 16];
           _sc40m::P64 = P64[R1 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sc40l::P64;
           R2 = Hp - 14;
           R1 = _sc40m::P64;
           call g_sc40m_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc41b_entry() //  [R1]
         { info_tbl: [(cc54P,
                       label: sat_sc41b_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc54P: // global
           _sc41b::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc54Q; else goto cc54R;
       cc54R: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc54T; else goto cc54S;
       cc54T: // global
           HpAlloc = 32;
           goto cc54Q;
       cc54Q: // global
           R1 = _sc41b::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc54S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc41b::P64;
           _sc40l::P64 = P64[_sc41b::P64 + 16];
           _sc40m::P64 = P64[_sc41b::P64 + 24];
           I64[Hp - 24] = sat_sc41a_info;
           P64[Hp - 8] = _sc40l::P64;
           P64[Hp] = _sc40m::P64;
           R3 = Hp - 24;
           R2 = f1_rc3Yy_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Version.$w$cshowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc54X,
                       label: Data.Version.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc54X: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc551; else goto cc550;
       cc551: // global
           HpAlloc = 80;
           R1 = Data.Version.$w$cshowsPrec_closure;
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cc550: // global
           I64[Hp - 72] = g_sc40m_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           _cc50N::P64 = Hp - 71;
           if (%MO_S_Lt_W64(R2, 11)) goto cc54V; else goto cc54W;
       cc54V: // global
           I64[Hp - 48] = sat_sc418_info;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = _cc50N::P64;
           _cc54t::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _cc54t::P64;
           R2 = f1_rc3Yy_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       cc54W: // global
           I64[Hp - 48] = sat_sc41b_info;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = _cc50N::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.425122018 UTC

[section ""data" . Data.Version.$fShowVersion_$cshowsPrec_closure" {
     Data.Version.$fShowVersion_$cshowsPrec_closure:
         const Data.Version.$fShowVersion_$cshowsPrec_info;
         const 0;
 },
 Data.Version.$fShowVersion_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cc57m,
                       label: Data.Version.$fShowVersion_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc57m: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc57q; else goto cc57r;
       cc57q: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fShowVersion_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc57r: // global
           I64[Sp - 24] = block_cc57j_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc57z; else goto cc57k;
       uc57z: // global
           call _cc57j(R1) args: 0, res: 0, upd: 0;
       cc57k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc57j() //  [R1]
         { info_tbl: [(cc57j,
                       label: block_cc57j_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc57j: // global
           I64[Sp] = block_cc57p_info;
           _sc41g::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sc41g::I64;
           if (R1 & 7 != 0) goto uc57y; else goto cc57t;
       uc57y: // global
           call _cc57p(R1) args: 0, res: 0, upd: 0;
       cc57t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc57p() //  [R1]
         { info_tbl: [(cc57p,
                       label: block_cc57p_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc57p: // global
           R5 = P64[Sp + 16];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call Data.Version.$w$cshowsPrec_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.432289424 UTC

[section ""data" . Data.Version.$fShowVersion2_closure" {
     Data.Version.$fShowVersion2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.434145812 UTC

[section ""data" . Data.Version.$fShowVersion_$cshow_closure" {
     Data.Version.$fShowVersion_$cshow_closure:
         const Data.Version.$fShowVersion_$cshow_info;
         const 0;
 },
 Data.Version.$fShowVersion_$cshow_entry() //  [R2]
         { info_tbl: [(cc57V,
                       label: Data.Version.$fShowVersion_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc57V: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc57W; else goto cc57X;
       cc57W: // global
           R2 = R2;
           R1 = Data.Version.$fShowVersion_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc57X: // global
           I64[Sp - 8] = block_cc57S_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc581; else goto cc57T;
       uc581: // global
           call _cc57S(R1) args: 0, res: 0, upd: 0;
       cc57T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc57S() //  [R1]
         { info_tbl: [(cc57S,
                       label: block_cc57S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc57S: // global
           R5 = GHC.Types.[]_closure+1;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call Data.Version.$w$cshowsPrec_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.439409459 UTC

[section ""data" . Data.Version.$fShowVersion1_closure" {
     Data.Version.$fShowVersion1_closure:
         const Data.Version.$fShowVersion1_info;
         const 0;
 },
 Data.Version.$fShowVersion1_entry() //  [R2, R3]
         { info_tbl: [(cc58i,
                       label: Data.Version.$fShowVersion1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc58i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc58j; else goto cc58k;
       cc58j: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fShowVersion1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc58k: // global
           I64[Sp - 16] = block_cc58f_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc58o; else goto cc58g;
       uc58o: // global
           call _cc58f(R1) args: 0, res: 0, upd: 0;
       cc58g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc58f() //  [R1]
         { info_tbl: [(cc58f,
                       label: block_cc58f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc58f: // global
           R5 = P64[Sp + 8];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 16;
           call Data.Version.$w$cshowsPrec_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.445583459 UTC

[section ""data" . Data.Version.$fShowVersion_$cshowList_closure" {
     Data.Version.$fShowVersion_$cshowList_closure:
         const Data.Version.$fShowVersion_$cshowList_info;
         const 0;
 },
 Data.Version.$fShowVersion_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cc58C,
                       label: Data.Version.$fShowVersion_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc58C: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Version.$fShowVersion1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.448724916 UTC

[section ""data" . Data.Version.$fShowVersion_closure" {
     Data.Version.$fShowVersion_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Version.$fShowVersion_$cshowsPrec_closure+3;
         const Data.Version.$fShowVersion_$cshow_closure+1;
         const Data.Version.$fShowVersion_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.450407089 UTC

[section ""data" . f2_rc3YB_closure" {
     f2_rc3YB_closure:
         const GHC.Types.C#_con_info;
         const 45;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.45204588 UTC

[section ""cstring" . Data.Version.showVersion2_bytes" {
     Data.Version.showVersion2_bytes:
         I8[] [46]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.453855256 UTC

[section ""data" . Data.Version.showVersion1_closure" {
     Data.Version.showVersion1_closure:
         const Data.Version.showVersion1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.showVersion1_entry() //  [R1]
         { info_tbl: [(cc58S,
                       label: Data.Version.showVersion1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc58S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc58T; else goto cc58U;
       cc58T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc58U: // global
           (_cc58P::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc58P::I64 == 0) goto cc58R; else goto cc58Q;
       cc58R: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc58Q: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc58P::I64;
           R2 = Data.Version.showVersion2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.458443294 UTC

[section ""data" . Data.Version.showVersion_go_closure" {
     Data.Version.showVersion_go_closure:
         const Data.Version.showVersion_go_info;
 },
 sat_sc41A_entry() //  [R1]
         { info_tbl: [(cc59g,
                       label: sat_sc41A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc59g: // global
           R2 = P64[R1 + 16];
           call Data.Version.showVersion_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.showVersion_go_entry() //  [R2]
         { info_tbl: [(cc59n,
                       label: Data.Version.showVersion_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc59n: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc59o; else goto cc59p;
       cc59o: // global
           R2 = R2;
           R1 = Data.Version.showVersion_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc59p: // global
           I64[Sp - 8] = block_cc596_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc59w; else goto cc597;
       uc59w: // global
           call _cc596(R1) args: 0, res: 0, upd: 0;
       cc597: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc596() //  [R1]
         { info_tbl: [(cc596,
                       label: block_cc596_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc596: // global
           if (R1 & 7 == 1) goto cc59k; else goto cc59l;
       cc59k: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc59l: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc59v; else goto cc59u;
       cc59v: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc59u: // global
           _sc41x::P64 = P64[R1 + 6];
           _sc41y::P64 = P64[R1 + 14];
           I64[Hp - 40] = sat_sc41A_info;
           P64[Hp - 24] = _sc41y::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = f2_rc3YB_closure+1;
           P64[Hp] = _sc41x::P64;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.466552528 UTC

[section ""data" . Data.Version.$wshowVersion_closure" {
     Data.Version.$wshowVersion_closure:
         const Data.Version.$wshowVersion_info;
         const 0;
 },
 arg_sc41D_entry() //  [R1]
         { info_tbl: [(cc59U,
                       label: arg_sc41D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc59U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc59V; else goto cc59W;
       cc59V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc59W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Version.showVersion_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc41M_entry() //  [R1]
         { info_tbl: [(cc5ah,
                       label: sat_sc41M_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5ah: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_sc41H_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sc41H_entry() //  [R1, R2]
         { info_tbl: [(cc5ao,
                       label: go_sc41H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5ao: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc5ap; else goto cc5aq;
       cc5ap: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5aq: // global
           I64[Sp - 24] = block_cc5a7_info;
           _sc41H::P64 = R1;
           _sc41D::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sc41D::P64;
           P64[Sp - 8] = _sc41H::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc5aw; else goto cc5a8;
       uc5aw: // global
           call _cc5a7(R1) args: 0, res: 0, upd: 0;
       cc5a8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5a7() //  [R1]
         { info_tbl: [(cc5a7,
                       label: block_cc5a7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5a7: // global
           if (R1 & 7 == 1) goto cc5al; else goto cc5am;
       cc5al: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc5am: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc5av; else goto cc5au;
       cc5av: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5au: // global
           _sc41K::P64 = P64[R1 + 6];
           _sc41L::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_sc41M_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sc41L::P64;
           R3 = Hp - 24;
           R2 = _sc41K::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc41N_entry() //  [R1]
         { info_tbl: [(cc5aB,
                       label: sat_sc41N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5aB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5aC; else goto cc5aD;
       cc5aC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5aD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Version.showVersion1_closure;
           Sp = Sp - 16;
           call Data.OldList.prependToAll_entry(R3,
                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Version.$wshowVersion_entry() //  [R2, R3]
         { info_tbl: [(cc5aI,
                       label: Data.Version.$wshowVersion_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5aI: // global
           _sc41C::P64 = R3;
           _sc41B::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cc5aJ; else goto cc5aK;
       cc5aK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5aM; else goto cc5aL;
       cc5aM: // global
           HpAlloc = 24;
           goto cc5aJ;
       cc5aJ: // global
           R3 = _sc41C::P64;
           R2 = _sc41B::P64;
           R1 = Data.Version.$wshowVersion_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc5aL: // global
           I64[Hp - 16] = arg_sc41D_info;
           P64[Hp] = _sc41C::P64;
           I64[Sp - 16] = block_cc59X_info;
           R3 = _sc41B::P64;
           R2 = GHC.Show.$fShowInt_$cshow_closure+1;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc59X() //  [R1]
         { info_tbl: [(cc59X,
                       label: block_cc59X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc59X: // global
           _cc59Q::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc5aF; else goto cc5aG;
       cc5aF: // global
           R1 = _cc59Q::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc5aG: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc5aS; else goto cc5aR;
       cc5aS: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5aR: // global
           _sc41F::P64 = P64[R1 + 6];
           _sc41G::P64 = P64[R1 + 14];
           I64[Hp - 56] = go_sc41H_info;
           P64[Hp - 48] = _cc59Q::P64;
           I64[Hp - 40] = sat_sc41N_info;
           P64[Hp - 24] = _sc41G::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sc41F::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 14;
           R1 = Hp - 55;
           Sp = Sp + 16;
           call go_sc41H_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.48286606 UTC

[section ""data" . Data.Version.showVersion_closure" {
     Data.Version.showVersion_closure:
         const Data.Version.showVersion_info;
         const 0;
 },
 Data.Version.showVersion_entry() //  [R2]
         { info_tbl: [(cc5bC,
                       label: Data.Version.showVersion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5bC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc5bD; else goto cc5bE;
       cc5bD: // global
           R2 = R2;
           R1 = Data.Version.showVersion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5bE: // global
           I64[Sp - 8] = block_cc5bz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc5bI; else goto cc5bA;
       uc5bI: // global
           call _cc5bz(R1) args: 0, res: 0, upd: 0;
       cc5bA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5bz() //  [R1]
         { info_tbl: [(cc5bz,
                       label: block_cc5bz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5bz: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Version.$wshowVersion_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.488019458 UTC

[section ""data" . Data.Version.$fReadVersion18_closure" {
     Data.Version.$fReadVersion18_closure:
         const Data.Version.$fReadVersion18_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion18_entry() //  [R1]
         { info_tbl: [(cc5bY,
                       label: Data.Version.$fReadVersion18_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5bY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5bZ; else goto cc5c0;
       cc5bZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5c0: // global
           (_cc5bV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc5bV::I64 == 0) goto cc5bX; else goto cc5bW;
       cc5bX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc5bW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc5bV::I64;
           R2 = Data.Version.$fReadVersion19_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.491942418 UTC

[section ""data" . Data.Version.$fReadVersion_lexeme1_closure" {
     Data.Version.$fReadVersion_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Version.$fReadVersion18_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.493632557 UTC

[section ""cstring" . Data.Version.$fReadVersion17_bytes" {
     Data.Version.$fReadVersion17_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.495445047 UTC

[section ""data" . Data.Version.$fReadVersion16_closure" {
     Data.Version.$fReadVersion16_closure:
         const Data.Version.$fReadVersion16_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion16_entry() //  [R1]
         { info_tbl: [(cc5cg,
                       label: Data.Version.$fReadVersion16_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5cg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5ch; else goto cc5ci;
       cc5ch: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5ci: // global
           (_cc5cd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc5cd::I64 == 0) goto cc5cf; else goto cc5ce;
       cc5cf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc5ce: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc5cd::I64;
           R2 = Data.Version.$fReadVersion17_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.499718455 UTC

[section ""data" . Data.Version.$fReadVersion_lexeme_closure" {
     Data.Version.$fReadVersion_lexeme_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Version.$fReadVersion16_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.501308037 UTC

[section ""cstring" . Data.Version.$fReadVersion15_bytes" {
     Data.Version.$fReadVersion15_bytes:
         I8[] [118,101,114,115,105,111,110,66,114,97,110,99,104]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.503106917 UTC

[section ""data" . Data.Version.$fReadVersion14_closure" {
     Data.Version.$fReadVersion14_closure:
         const Data.Version.$fReadVersion14_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion14_entry() //  [R1]
         { info_tbl: [(cc5cy,
                       label: Data.Version.$fReadVersion14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5cy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5cz; else goto cc5cA;
       cc5cz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5cA: // global
           (_cc5cv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc5cv::I64 == 0) goto cc5cx; else goto cc5cw;
       cc5cx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc5cw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc5cv::I64;
           R2 = Data.Version.$fReadVersion15_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.507012996 UTC

[section ""data" . Data.Version.$fReadVersion13_closure" {
     Data.Version.$fReadVersion13_closure:
         const Data.Version.$fReadVersion13_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion13_entry() //  [R1]
         { info_tbl: [(cc5cO,
                       label: Data.Version.$fReadVersion13_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5cO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5cP; else goto cc5cQ;
       cc5cP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5cQ: // global
           (_cc5cL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc5cL::I64 == 0) goto cc5cN; else goto cc5cM;
       cc5cN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc5cM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc5cL::I64;
           R2 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R1 = GHC.Read.$fReadInt_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.51164912 UTC

[section ""data" . Data.Version.$fReadVersion12_closure" {
     Data.Version.$fReadVersion12_closure:
         const Data.Version.$fReadVersion12_info;
         const 0;
 },
 Data.Version.$fReadVersion12_entry() //  []
         { info_tbl: [(cc5d2,
                       label: Data.Version.$fReadVersion12_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5d2: // global
           R1 = Data.Version.$fReadVersion13_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.514689649 UTC

[section ""data" . Data.Version.$fReadVersion_n_closure" {
     Data.Version.$fReadVersion_n_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.516328508 UTC

[section ""cstring" . Data.Version.$fReadVersion11_bytes" {
     Data.Version.$fReadVersion11_bytes:
         I8[] [44]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.518144704 UTC

[section ""data" . Data.Version.$fReadVersion10_closure" {
     Data.Version.$fReadVersion10_closure:
         const Data.Version.$fReadVersion10_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion10_entry() //  [R1]
         { info_tbl: [(cc5dh,
                       label: Data.Version.$fReadVersion10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5dh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5di; else goto cc5dj;
       cc5di: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5dj: // global
           (_cc5de::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc5de::I64 == 0) goto cc5dg; else goto cc5df;
       cc5dg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc5df: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc5de::I64;
           R2 = Data.Version.$fReadVersion11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.521886961 UTC

[section ""data" . Data.Version.$fReadVersion9_closure" {
     Data.Version.$fReadVersion9_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Version.$fReadVersion10_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.523555057 UTC

[section ""cstring" . Data.Version.$fReadVersion8_bytes" {
     Data.Version.$fReadVersion8_bytes:
         I8[] [118,101,114,115,105,111,110,84,97,103,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.525668274 UTC

[section ""data" . Data.Version.$fReadVersion7_closure" {
     Data.Version.$fReadVersion7_closure:
         const Data.Version.$fReadVersion7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion7_entry() //  [R1]
         { info_tbl: [(cc5dz,
                       label: Data.Version.$fReadVersion7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5dz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5dA; else goto cc5dB;
       cc5dA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5dB: // global
           (_cc5dw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc5dw::I64 == 0) goto cc5dy; else goto cc5dx;
       cc5dy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc5dx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc5dw::I64;
           R2 = Data.Version.$fReadVersion8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.529545967 UTC

[section ""data" . Data.Version.$fReadVersion6_closure" {
     Data.Version.$fReadVersion6_closure:
         const Data.Version.$fReadVersion6_info;
         const 0;
 },
 Data.Version.$fReadVersion6_entry() //  []
         { info_tbl: [(cc5dN,
                       label: Data.Version.$fReadVersion6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5dN: // global
           R2 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R1 = GHC.Read.$fRead[]_$s$creadListPrec1_closure;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.532905133 UTC

[section ""data" . Data.Version.$fReadVersion4_closure" {
     Data.Version.$fReadVersion4_closure:
         const Data.Version.$fReadVersion4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion4_entry() //  [R1]
         { info_tbl: [(cc5e0,
                       label: Data.Version.$fReadVersion4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5e0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5e1; else goto cc5e2;
       cc5e1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5e2: // global
           (_cc5dX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc5dX::I64 == 0) goto cc5dZ; else goto cc5dY;
       cc5dZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc5dY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc5dX::I64;
           R2 = Data.Version.$fReadVersion5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.536636539 UTC

[section ""data" . Data.Version.$fReadVersion3_closure" {
     Data.Version.$fReadVersion3_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Version.$fReadVersion4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.540442553 UTC

[section ""data" . Data.Version.$w$creadPrec_closure" {
     Data.Version.$w$creadPrec_closure:
         const Data.Version.$w$creadPrec_info;
         const 0;
 },
 sat_sc425_entry() //  [R1, R2]
         { info_tbl: [(cc5eO,
                       label: sat_sc425_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5eO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5eS; else goto cc5eR;
       cc5eS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5eR: // global
           _sc41W::P64 = P64[R1 + 7];
           _sc420::P64 = P64[R1 + 15];
           _sc422::P64 = P64[R1 + 23];
           I64[Hp - 16] = Data.Version.Version_con_info;
           P64[Hp - 8] = _sc420::P64;
           P64[Hp] = _sc422::P64;
           R2 = Hp - 15;
           R1 = _sc41W::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc428_entry() //  [R1, R2]
         { info_tbl: [(cc5eW,
                       label: sat_sc428_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5eW: // global
           _sc422::P64 = R2;
           _sc428::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cc5eX; else goto cc5eY;
       cc5eY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc5f0; else goto cc5eZ;
       cc5f0: // global
           HpAlloc = 32;
           goto cc5eX;
       cc5eX: // global
           R2 = _sc422::P64;
           R1 = _sc428::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5eZ: // global
           _sc41W::P64 = P64[_sc428::P64 + 7];
           _sc420::P64 = P64[_sc428::P64 + 15];
           I64[Hp - 24] = sat_sc425_info;
           P64[Hp - 16] = _sc41W::P64;
           P64[Hp - 8] = _sc420::P64;
           P64[Hp] = _sc422::P64;
           I64[Sp - 8] = block_cc5eT_info;
           R3 = Hp - 23;
           R2 = Data.Version.$fReadVersion3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5eT() //  [R1]
         { info_tbl: [(cc5eT,
                       label: block_cc5eT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5eT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5f3; else goto cc5f2;
       cc5f3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5f2: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc429_entry() //  [R1, R2]
         { info_tbl: [(cc5f4,
                       label: sat_sc429_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5f4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5f8; else goto cc5f7;
       cc5f8: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5f7: // global
           _sc41W::P64 = P64[R1 + 7];
           _sc420::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sc428_info;
           P64[Hp - 8] = _sc41W::P64;
           P64[Hp] = _sc420::P64;
           R5 = Hp - 15;
           R4 = Data.Version.$fReadVersion_n_closure+1;
           R3 = Data.Version.$fReadVersion6_closure+1;
           R2 = Data.Version.$fReadVersion7_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc42c_entry() //  [R1, R2]
         { info_tbl: [(cc5fc,
                       label: sat_sc42c_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5fc: // global
           _sc420::P64 = R2;
           _sc42c::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cc5fd; else goto cc5fe;
       cc5fe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5fg; else goto cc5ff;
       cc5fg: // global
           HpAlloc = 24;
           goto cc5fd;
       cc5fd: // global
           R2 = _sc420::P64;
           R1 = _sc42c::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5ff: // global
           _sc41W::P64 = P64[_sc42c::P64 + 7];
           I64[Hp - 16] = sat_sc429_info;
           P64[Hp - 8] = _sc41W::P64;
           P64[Hp] = _sc420::P64;
           I64[Sp - 8] = block_cc5f9_info;
           R3 = Hp - 15;
           R2 = Data.Version.$fReadVersion9_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5f9() //  [R1]
         { info_tbl: [(cc5f9,
                       label: block_cc5f9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5f9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5fj; else goto cc5fi;
       cc5fj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5fi: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc42d_entry() //  [R1, R2]
         { info_tbl: [(cc5fk,
                       label: sat_sc42d_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5fk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5fo; else goto cc5fn;
       cc5fo: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5fn: // global
           _sc41W::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_sc42c_info;
           P64[Hp] = _sc41W::P64;
           R5 = Hp - 7;
           R4 = Data.Version.$fReadVersion_n_closure+1;
           R3 = Data.Version.$fReadVersion12_closure+1;
           R2 = Data.Version.$fReadVersion14_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc42g_entry() //  [R1, R2]
         { info_tbl: [(cc5fs,
                       label: sat_sc42g_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5fs: // global
           _sc41Y::P64 = R2;
           _sc42g::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cc5ft; else goto cc5fu;
       cc5fu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5fw; else goto cc5fv;
       cc5fw: // global
           HpAlloc = 16;
           goto cc5ft;
       cc5ft: // global
           R2 = _sc41Y::P64;
           R1 = _sc42g::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5fv: // global
           _sc41W::P64 = P64[_sc42g::P64 + 7];
           I64[Hp - 8] = sat_sc42d_info;
           P64[Hp] = _sc41W::P64;
           I64[Sp - 8] = block_cc5fp_info;
           R3 = Hp - 7;
           R2 = Data.Version.$fReadVersion_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5fp() //  [R1]
         { info_tbl: [(cc5fp,
                       label: block_cc5fp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5fp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5fz; else goto cc5fy;
       cc5fz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5fy: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.$w$creadPrec_entry() //  [R2, R3]
         { info_tbl: [(cc5fD,
                       label: Data.Version.$w$creadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5fD: // global
           _sc41W::P64 = R3;
           _sc41V::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cc5fE; else goto cc5fF;
       cc5fF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5fH; else goto cc5fG;
       cc5fH: // global
           HpAlloc = 16;
           goto cc5fE;
       cc5fE: // global
           R3 = _sc41W::P64;
           R2 = _sc41V::I64;
           R1 = Data.Version.$w$creadPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc5fG: // global
           if (%MO_S_Gt_W64(_sc41V::I64, 11)) goto cc5fB; else goto cc5fC;
       cc5fB: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc5fC: // global
           I64[Hp - 8] = sat_sc42g_info;
           P64[Hp] = _sc41W::P64;
           I64[Sp - 8] = block_cc5fI_info;
           R3 = Hp - 7;
           R2 = Data.Version.$fReadVersion_lexeme1_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5fI() //  [R1]
         { info_tbl: [(cc5fI,
                       label: block_cc5fI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5fI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5fN; else goto cc5fM;
       cc5fN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5fM: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.564943475 UTC

[section ""data" . Data.Version.$fReadVersion2_closure" {
     Data.Version.$fReadVersion2_closure:
         const Data.Version.$fReadVersion2_info;
         const 0;
 },
 Data.Version.$fReadVersion2_entry() //  [R2, R3]
         { info_tbl: [(cc5gC,
                       label: Data.Version.$fReadVersion2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5gC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5gD; else goto cc5gE;
       cc5gD: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fReadVersion2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc5gE: // global
           I64[Sp - 16] = block_cc5gz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc5gI; else goto cc5gA;
       uc5gI: // global
           call _cc5gz(R1) args: 0, res: 0, upd: 0;
       cc5gA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5gz() //  [R1]
         { info_tbl: [(cc5gz,
                       label: block_cc5gz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5gz: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Data.Version.$w$creadPrec_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.570393191 UTC

[section ""data" . Data.Version.$fReadVersion1_closure" {
     Data.Version.$fReadVersion1_closure:
         const Data.Version.$fReadVersion1_info;
         const 0;
 },
 Data.Version.$fReadVersion1_entry() //  [R2, R3]
         { info_tbl: [(cc5gW,
                       label: Data.Version.$fReadVersion1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5gW: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Version.$fReadVersion2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.573826327 UTC

[section ""data" . Data.Version.$fReadVersion_$creadsPrec_closure" {
     Data.Version.$fReadVersion_$creadsPrec_closure:
         const Data.Version.$fReadVersion_$creadsPrec_info;
         const 0;
 },
 sat_sc42o_entry() //  [R1]
         { info_tbl: [(cc5hb,
                       label: sat_sc42o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5hb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5hc; else goto cc5hd;
       cc5hc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5hd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = Data.Version.$fReadVersion2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Version.$fReadVersion_$creadsPrec_entry() //  [R2]
         { info_tbl: [(cc5he,
                       label: Data.Version.$fReadVersion_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5he: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5hi; else goto cc5hh;
       cc5hi: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Version.$fReadVersion_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5hh: // global
           I64[Hp - 16] = sat_sc42o_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.580358532 UTC

[section ""data" . Data.Version.$fReadVersion_$creadListPrec_closure" {
     Data.Version.$fReadVersion_$creadListPrec_closure:
         const Data.Version.$fReadVersion_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion_$creadListPrec_entry() //  [R1]
         { info_tbl: [(cc5hx,
                       label: Data.Version.$fReadVersion_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5hx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5hy; else goto cc5hz;
       cc5hy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5hz: // global
           (_cc5hu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc5hu::I64 == 0) goto cc5hw; else goto cc5hv;
       cc5hw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc5hv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc5hu::I64;
           R2 = Data.Version.$fReadVersion1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.584278526 UTC

[section ""data" . Data.Version.$fReadVersion20_closure" {
     Data.Version.$fReadVersion20_closure:
         const Data.Version.$fReadVersion20_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion20_entry() //  [R1]
         { info_tbl: [(cc5hN,
                       label: Data.Version.$fReadVersion20_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5hN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5hO; else goto cc5hP;
       cc5hO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5hP: // global
           (_cc5hK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc5hK::I64 == 0) goto cc5hM; else goto cc5hL;
       cc5hM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc5hL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc5hK::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = Data.Version.$fReadVersion_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.588218765 UTC

[section ""data" . Data.Version.$fReadVersion_$creadList_closure" {
     Data.Version.$fReadVersion_$creadList_closure:
         const Data.Version.$fReadVersion_$creadList_info;
         const 0;
 },
 Data.Version.$fReadVersion_$creadList_entry() //  [R2]
         { info_tbl: [(cc5i1,
                       label: Data.Version.$fReadVersion_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5i1: // global
           R3 = R2;
           R2 = Data.Version.$fReadVersion20_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.591593593 UTC

[section ""data" . Data.Version.$fReadVersion_closure" {
     Data.Version.$fReadVersion_closure:
         const GHC.Read.C:Read_con_info;
         const Data.Version.$fReadVersion_$creadsPrec_closure+1;
         const Data.Version.$fReadVersion_$creadList_closure+1;
         const Data.Version.$fReadVersion1_closure+2;
         const Data.Version.$fReadVersion_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.593528233 UTC

[section ""data" . Data.Version.parseVersion5_closure" {
     Data.Version.parseVersion5_closure:
         const Data.Version.parseVersion5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.parseVersion5_entry() //  [R1]
         { info_tbl: [(cc5if,
                       label: Data.Version.parseVersion5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5if: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5ig; else goto cc5ih;
       cc5ig: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5ih: // global
           (_cc5ic::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc5ic::I64 == 0) goto cc5ie; else goto cc5id;
       cc5ie: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc5id: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc5ic::I64;
           R2 = Text.Read.readEither5_closure;
           Sp = Sp - 16;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.597497665 UTC

[section ""data" . Data.Version.parseVersion4_closure" {
     Data.Version.parseVersion4_closure:
         const Data.Version.parseVersion4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.parseVersion4_entry() //  [R1]
         { info_tbl: [(cc5iv,
                       label: Data.Version.parseVersion4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5iv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5iw; else goto cc5ix;
       cc5iw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5ix: // global
           (_cc5is::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc5is::I64 == 0) goto cc5iu; else goto cc5it;
       cc5iu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc5it: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc5is::I64;
           R2 = Text.Read.readEither2_closure;
           Sp = Sp - 16;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.601412895 UTC

[section ""data" . Data.Version.parseVersion6_closure" {
     Data.Version.parseVersion6_closure:
         const Data.Version.parseVersion6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.parseVersion6_entry() //  [R1]
         { info_tbl: [(cc5iL,
                       label: Data.Version.parseVersion6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5iL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5iM; else goto cc5iN;
       cc5iM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5iN: // global
           (_cc5iI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc5iI::I64 == 0) goto cc5iK; else goto cc5iJ;
       cc5iK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc5iJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc5iI::I64;
           R4 = Text.Read.readEither7_closure+1;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = GHC.Read.$fReadInt2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.606891889 UTC

[section ""data" . Data.Version.$wp_closure" {
     Data.Version.$wp_closure:
         const Data.Version.$wp_info;
         const 0;
 },
 sat_sc42G_entry() //  [R1]
         { info_tbl: [(cc5jy,
                       label: sat_sc42G_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5jy: // global
           _sc42G::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc5jz; else goto cc5jA;
       cc5jA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5jC; else goto cc5jB;
       cc5jC: // global
           HpAlloc = 24;
           goto cc5jz;
       cc5jz: // global
           R1 = _sc42G::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5jB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc42G::P64;
           _sc42r::P64 = P64[_sc42G::P64 + 16];
           _sc42x::P64 = P64[_sc42G::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sc42r::P64;
           P64[Hp] = _sc42x::P64;
           I64[Sp - 24] = block_cc5jw_info;
           R3 = Hp - 14;
           R2 = Data.Version.parseVersion6_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc5jw() //  [R1]
         { info_tbl: [(cc5jw,
                       label: block_cc5jw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5jw: // global
           I64[Sp] = block_cc5jF_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc5jF() //  [R1]
         { info_tbl: [(cc5jF,
                       label: block_cc5jF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5jF: // global
           if (R1 & 7 == 1) goto cc5jM; else goto cc5jR;
       cc5jM: // global
           R1 = Data.Version.parseVersion5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cc5jR: // global
           I64[Sp - 8] = block_cc5jP_info;
           _sc42B::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sc42B::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc5k5; else goto cc5jS;
       uc5k5: // global
           call _cc5jP(R1) args: 0, res: 0, upd: 0;
       cc5jS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc5jP() //  [R1]
         { info_tbl: [(cc5jP,
                       label: block_cc5jP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5jP: // global
           if (R1 & 7 == 1) goto cc5jY; else goto cc5k2;
       cc5jY: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cc5k2: // global
           R1 = Data.Version.parseVersion4_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc42H_entry() //  [R1, R2]
         { info_tbl: [(cc5k6,
                       label: sat_sc42H_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5k6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc5ka; else goto cc5k9;
       cc5ka: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5k9: // global
           _sc42p::P64 = P64[R1 + 7];
           _sc42r::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sc42G_info;
           P64[Hp - 8] = _sc42r::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _sc42p::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc42K_entry() //  [R1, R2]
         { info_tbl: [(cc5kb,
                       label: sat_sc42K_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5kb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5kc; else goto cc5kd;
       cc5kc: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5kd: // global
           I64[Sp - 16] = block_cc5j4_info;
           _sc42p::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sc42p::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc5kq; else goto cc5j5;
       uc5kq: // global
           call _cc5j4(R1) args: 0, res: 0, upd: 0;
       cc5j5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5j4() //  [R1]
         { info_tbl: [(cc5j4,
                       label: block_cc5j4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5j4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5kg; else goto cc5kf;
       cc5kg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5kf: // global
           if (I64[R1 + 7] - 48 > 9) goto cc5ki; else goto cc5km;
       cc5ki: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc5km: // global
           I64[Hp - 16] = sat_sc42H_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cc5kj_info;
           R3 = Hp - 15;
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.$wmunch_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5kj() //  [R1]
         { info_tbl: [(cc5kj,
                       label: block_cc5kj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5kj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5kp; else goto cc5ko;
       cc5kp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5ko: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.$wp_entry() //  [R2]
         { info_tbl: [(cc5kr,
                       label: Data.Version.$wp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5kr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5kv; else goto cc5ku;
       cc5kv: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Version.$wp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5ku: // global
           I64[Hp - 8] = sat_sc42K_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.62668739 UTC

[section ""data" . Data.Version.parseVersion3_closure" {
     Data.Version.parseVersion3_closure:
         const Data.Version.parseVersion3_info;
         const 0;
 },
 Data.Version.parseVersion3_entry() //  [R2]
         { info_tbl: [(cc5ln,
                       label: Data.Version.parseVersion3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5ln: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc5lo; else goto cc5lp;
       cc5lo: // global
           R2 = R2;
           R1 = Data.Version.parseVersion3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5lp: // global
           I64[Sp - 8] = block_cc5lk_info;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Version.$wp_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5lk() //  [R1]
         { info_tbl: [(cc5lk,
                       label: block_cc5lk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5lk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5ls; else goto cc5lr;
       cc5ls: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5lr: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.632541557 UTC

[section ""data" . Data.Version.parseVersion_m2_closure" {
     Data.Version.parseVersion_m2_closure:
         const Data.Version.parseVersion_m2_info;
         const 0;
 },
 lvl4_sc42P_entry() //  [R1]
         { info_tbl: [(cc5lN,
                       label: lvl4_sc42P_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5lN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc5lO; else goto cc5lP;
       cc5lO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5lP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cc5lK_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Data.Version.$wp_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc5lK() //  [R1]
         { info_tbl: [(cc5lK,
                       label: block_cc5lK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5lK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5lS; else goto cc5lR;
       cc5lS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cc5lR: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc42W_entry() //  [R1, R2]
         { info_tbl: [(cc5m1,
                       label: sat_sc42W_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5m1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5m2; else goto cc5m3;
       cc5m2: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5m3: // global
           I64[Sp - 16] = block_cc5lY_info;
           _sc42P::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sc42P::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc5mb; else goto cc5lZ;
       uc5mb: // global
           call _cc5lY(R1) args: 0, res: 0, upd: 0;
       cc5lZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5lY() //  [R1]
         { info_tbl: [(cc5lY,
                       label: block_cc5lY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5lY: // global
           if (I64[R1 + 7] == 46) goto cc5ma; else goto cc5m9;
       cc5ma: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc5m9: // global
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.parseVersion_m2_entry() //  [R2]
         { info_tbl: [(cc5md,
                       label: Data.Version.parseVersion_m2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5md: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc5mh; else goto cc5mg;
       cc5mh: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Version.parseVersion_m2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5mg: // global
           I64[Hp - 48] = lvl4_sc42P_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = sat_sc42W_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.644552125 UTC

[section ""data" . Data.Version.$wlvl_closure" {
     Data.Version.$wlvl_closure:
         const Data.Version.$wlvl_info;
 },
 sat_sc439_entry() //  [R1, R2]
         { info_tbl: [(cc5n5,
                       label: sat_sc439_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5n5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5n9; else goto cc5n8;
       cc5n9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5n8: // global
           _sc42X::P64 = P64[R1 + 7];
           _sc436::P64 = P64[R1 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sc436::P64;
           P64[Hp] = R2;
           R2 = Hp - 14;
           R1 = _sc42X::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $www1_sc42Y_entry() //  [R1, R2]
         { info_tbl: [(cc5na,
                       label: $www1_sc42Y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5na: // global
           _sc42Z::I64 = R2;
           _sc42Y::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cc5nb; else goto cc5nc;
       cc5nc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc5ne; else goto cc5nd;
       cc5ne: // global
           HpAlloc = 40;
           goto cc5nb;
       cc5nb: // global
           R2 = _sc42Z::I64;
           R1 = _sc42Y::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5nd: // global
           _sc42X::P64 = P64[_sc42Y::P64 + 7];
           (_sc434::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] u_iswalnum(_sc42Z::I64);
           if (_sc434::I64 == 0) goto cc5nn; else goto cc5nj;
       cc5nn: // global
           Hp = Hp - 40;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc5nj: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _sc42Z::I64;
           I64[Hp - 16] = sat_sc439_info;
           P64[Hp - 8] = _sc42X::P64;
           P64[Hp] = Hp - 31;
           I64[Sp - 8] = block_cc5nf_info;
           R3 = Hp - 15;
           R2 = GHC.Unicode.isAlphaNum_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wmunch_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5nf() //  [R1]
         { info_tbl: [(cc5nf,
                       label: block_cc5nf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5nf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5nm; else goto cc5nl;
       cc5nm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5nl: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 ww1_sc43c_entry() //  [R1, R2]
         { info_tbl: [(cc5nw,
                       label: ww1_sc43c_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5nw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5nx; else goto cc5ny;
       cc5nx: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5ny: // global
           I64[Sp - 16] = block_cc5nt_info;
           _sc42Y::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sc42Y::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc5nC; else goto cc5nu;
       uc5nC: // global
           call _cc5nt(R1) args: 0, res: 0, upd: 0;
       cc5nu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5nt() //  [R1]
         { info_tbl: [(cc5nt,
                       label: block_cc5nt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5nt: // global
           R2 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $www1_sc42Y_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc43l_entry() //  [R1, R2]
         { info_tbl: [(cc5nM,
                       label: sat_sc43l_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5nM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5nN; else goto cc5nO;
       cc5nN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5nO: // global
           I64[Sp - 16] = block_cc5nJ_info;
           _sc43g::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sc43g::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc5nW; else goto cc5nK;
       uc5nW: // global
           call _cc5nJ(R1) args: 0, res: 0, upd: 0;
       cc5nK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5nJ() //  [R1]
         { info_tbl: [(cc5nJ,
                       label: block_cc5nJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5nJ: // global
           if (I64[R1 + 7] == 45) goto cc5nV; else goto cc5nU;
       cc5nV: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc5nU: // global
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.$wlvl_entry() //  [R2]
         { info_tbl: [(cc5nX,
                       label: Data.Version.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5nX: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc5o1; else goto cc5o0;
       cc5o1: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Data.Version.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5o0: // global
           I64[Hp - 56] = $www1_sc42Y_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = ww1_sc43c_info;
           P64[Hp - 32] = Hp - 55;
           I64[Hp - 24] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp - 16] = Hp - 39;
           I64[Hp - 8] = sat_sc43l_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.662503248 UTC

[section ""data" . Data.Version.parseVersion2_closure" {
     Data.Version.parseVersion2_closure:
         const Data.Version.parseVersion2_info;
 },
 Data.Version.parseVersion2_entry() //  [R2]
         { info_tbl: [(cc5oM,
                       label: Data.Version.parseVersion2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5oM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc5oN; else goto cc5oO;
       cc5oN: // global
           R2 = R2;
           R1 = Data.Version.parseVersion2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5oO: // global
           I64[Sp - 8] = block_cc5oJ_info;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Version.$wlvl_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5oJ() //  [R1]
         { info_tbl: [(cc5oJ,
                       label: block_cc5oJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5oJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5oR; else goto cc5oQ;
       cc5oR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5oQ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.669113365 UTC

[section ""data" . Data.Version.$wparseVersion_closure" {
     Data.Version.$wparseVersion_closure:
         const Data.Version.$wparseVersion_info;
         const 0;
 },
 a2_sc43y_entry() //  [R1]
         { info_tbl: [(cc5pE,
                       label: a2_sc43y_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5pE: // global
           _sc43y::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc5pF; else goto cc5pG;
       cc5pG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5pI; else goto cc5pH;
       cc5pI: // global
           HpAlloc = 24;
           goto cc5pF;
       cc5pF: // global
           R1 = _sc43y::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5pH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc43y::P64;
           _sc43r::P64 = P64[_sc43y::P64 + 16];
           _sc43x::P64 = P64[_sc43y::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sc43r::P64;
           P64[Hp] = _sc43x::P64;
           I64[Sp - 24] = block_cc5pC_info;
           R3 = Hp - 14;
           R2 = Data.Version.parseVersion6_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc5pC() //  [R1]
         { info_tbl: [(cc5pC,
                       label: block_cc5pC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5pC: // global
           I64[Sp] = block_cc5pL_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc5pL() //  [R1]
         { info_tbl: [(cc5pL,
                       label: block_cc5pL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5pL: // global
           if (R1 & 7 == 1) goto cc5pS; else goto cc5pX;
       cc5pS: // global
           R1 = Data.Version.parseVersion5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cc5pX: // global
           I64[Sp - 8] = block_cc5pV_info;
           _sc43C::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sc43C::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc5qb; else goto cc5pY;
       uc5qb: // global
           call _cc5pV(R1) args: 0, res: 0, upd: 0;
       cc5pY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc5pV() //  [R1]
         { info_tbl: [(cc5pV,
                       label: block_cc5pV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5pV: // global
           if (R1 & 7 == 1) goto cc5q4; else goto cc5q8;
       cc5q4: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cc5q8: // global
           R1 = Data.Version.parseVersion4_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc43L_entry() //  [R1, R2]
         { info_tbl: [(cc5qo,
                       label: sat_sc43L_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5qo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5qs; else goto cc5qr;
       cc5qs: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5qr: // global
           _sc43p::P64 = P64[R1 + 7];
           _sc43I::P64 = P64[R1 + 15];
           I64[Hp - 16] = Data.Version.Version_con_info;
           P64[Hp - 8] = _sc43I::P64;
           P64[Hp] = R2;
           R2 = Hp - 15;
           R1 = _sc43p::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc43M_entry() //  [R1, R2]
         { info_tbl: [(cc5qt,
                       label: sat_sc43M_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5qt: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc5qx; else goto cc5qw;
       cc5qx: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5qw: // global
           _sc43p::P64 = P64[R1 + 7];
           _sc43y::P64 = P64[R1 + 15];
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = _sc43y::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sc43L_info;
           P64[Hp - 8] = _sc43p::P64;
           P64[Hp] = Hp - 38;
           R3 = Hp - 15;
           R2 = Data.Version.parseVersion2_closure+1;
           call Text.ParserCombinators.ReadP.endBy3_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc43N_entry() //  [R1, R2]
         { info_tbl: [(cc5qy,
                       label: sat_sc43N_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5qy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc5qC; else goto cc5qB;
       cc5qC: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5qB: // global
           _sc43p::P64 = P64[R1 + 7];
           _sc43r::P64 = P64[R1 + 15];
           I64[Hp - 48] = a2_sc43y_info;
           P64[Hp - 32] = _sc43r::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sc43M_info;
           P64[Hp - 8] = _sc43p::P64;
           P64[Hp] = Hp - 48;
           R3 = Hp - 15;
           R2 = Data.Version.parseVersion_m2_closure+1;
           call Text.ParserCombinators.ReadP.endBy3_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc43Q_entry() //  [R1, R2]
         { info_tbl: [(cc5qD,
                       label: sat_sc43Q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5qD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5qE; else goto cc5qF;
       cc5qE: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5qF: // global
           I64[Sp - 16] = block_cc5pa_info;
           _sc43p::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sc43p::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc5qS; else goto cc5pb;
       uc5qS: // global
           call _cc5pa(R1) args: 0, res: 0, upd: 0;
       cc5pb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5pa() //  [R1]
         { info_tbl: [(cc5pa,
                       label: block_cc5pa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5pa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5qI; else goto cc5qH;
       cc5qI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5qH: // global
           if (I64[R1 + 7] - 48 > 9) goto cc5qK; else goto cc5qO;
       cc5qK: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc5qO: // global
           I64[Hp - 16] = sat_sc43N_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cc5qL_info;
           R3 = Hp - 15;
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.$wmunch_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5qL() //  [R1]
         { info_tbl: [(cc5qL,
                       label: block_cc5qL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5qL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5qR; else goto cc5qQ;
       cc5qR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5qQ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.$wparseVersion_entry() //  [R2]
         { info_tbl: [(cc5qT,
                       label: Data.Version.$wparseVersion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5qT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5qX; else goto cc5qW;
       cc5qX: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Version.$wparseVersion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5qW: // global
           I64[Hp - 8] = sat_sc43Q_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.692568058 UTC

[section ""data" . Data.Version.parseVersion1_closure" {
     Data.Version.parseVersion1_closure:
         const Data.Version.parseVersion1_info;
         const 0;
 },
 Data.Version.parseVersion1_entry() //  [R2]
         { info_tbl: [(cc5rX,
                       label: Data.Version.parseVersion1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5rX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc5rY; else goto cc5rZ;
       cc5rY: // global
           R2 = R2;
           R1 = Data.Version.parseVersion1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5rZ: // global
           I64[Sp - 8] = block_cc5rU_info;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Version.$wparseVersion_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5rU() //  [R1]
         { info_tbl: [(cc5rU,
                       label: block_cc5rU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5rU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5s2; else goto cc5s1;
       cc5s2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5s1: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.698453904 UTC

[section ""data" . Data.Version.parseVersion_closure" {
     Data.Version.parseVersion_closure:
         const Data.Version.parseVersion_info;
         const 0;
 },
 Data.Version.parseVersion_entry() //  [R2]
         { info_tbl: [(cc5sg,
                       label: Data.Version.parseVersion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5sg: // global
           R2 = R2;
           call Data.Version.parseVersion1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.701636068 UTC

[section ""data" . Data.Version.Version_closure" {
     Data.Version.Version_closure:
         const Data.Version.Version_info;
 },
 Data.Version.Version_entry() //  [R2, R3]
         { info_tbl: [(cc5ss,
                       label: Data.Version.Version_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5ss: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5sw; else goto cc5sv;
       cc5sw: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.Version_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc5sv: // global
           I64[Hp - 16] = Data.Version.Version_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.705228474 UTC

[Data.Version.Version_con_entry() //  [R1]
         { info_tbl: [(cc5sC,
                       label: Data.Version.Version_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,86,101,114,115,105,111,110,46,86,101,114,115,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5sC: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:58.708226356 UTC

[section ""relreadonly" . Sc4eo_srt" {
     Sc4eo_srt:
         const GHC.Show.showLitString_closure;
         const GHC.Show.showCommaSpace1_closure;
         const f1_rc3Yy_closure;
         const Data.Version.$w$cshowsPrec_closure;
         const Data.Version.$fShowVersion_$cshowsPrec_closure;
         const Data.Version.$fShowVersion_$cshow_closure;
         const Data.Version.$fShowVersion1_closure;
         const Data.Version.showVersion1_closure;
         const Data.Version.$wshowVersion_closure;
         const Data.Version.showVersion_closure;
         const GHC.Read.$fReadInt_$creadListPrec_closure;
         const Data.Version.$fReadVersion13_closure;
         const GHC.Read.$fRead[]_$s$creadListPrec1_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Version.$fReadVersion3_closure;
         const GHC.Read.readField_closure;
         const Data.Version.$fReadVersion6_closure;
         const Data.Version.$fReadVersion7_closure;
         const Data.Version.$fReadVersion9_closure;
         const Data.Version.$fReadVersion12_closure;
         const Data.Version.$fReadVersion14_closure;
         const Data.Version.$fReadVersion_lexeme_closure;
         const Data.Version.$w$creadPrec_closure;
         const Data.Version.$fReadVersion_lexeme1_closure;
         const Data.Version.$fReadVersion2_closure;
         const GHC.Read.list3_closure;
         const Data.Version.$fReadVersion_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Version.$fReadVersion1_closure;
         const Data.Version.$fReadVersion_$creadListPrec_closure;
         const Data.Version.$fReadVersion20_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Text.Read.readEither5_closure;
         const Text.Read.readEither2_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const Data.Version.parseVersion4_closure;
         const Data.Version.parseVersion5_closure;
         const Data.Version.parseVersion6_closure;
         const Data.Version.$wp_closure;
         const Data.Version.parseVersion3_closure;
         const Data.Version.parseVersion_m2_closure;
         const Text.ParserCombinators.ReadP.endBy3_closure;
         const Data.Version.$wparseVersion_closure;
         const Data.Version.parseVersion1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.826249077 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:59.827789372 UTC

[section ""data" . Data.Version.$fGenericVersion_$cto_closure" {
     Data.Version.$fGenericVersion_$cto_closure:
         const Data.Version.$fGenericVersion_$cto_info;
 },
 Data.Version.$fGenericVersion_$cto_entry() //  [R2]
         { info_tbl: [(cc5y6,
                       label: Data.Version.$fGenericVersion_$cto_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5y6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc5ya; else goto cc5yb;
       cc5ya: // global
           R2 = R2;
           R1 = Data.Version.$fGenericVersion_$cto_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5yb: // global
           I64[Sp - 8] = block_cc5y4_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5y4() //  [R1]
         { info_tbl: [(cc5y4,
                       label: block_cc5y4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5y4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5ye; else goto cc5yd;
       cc5ye: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5yd: // global
           _sc5sL::P64 = P64[R1 + 7];
           _sc5sM::P64 = P64[R1 + 15];
           I64[Hp - 16] = Data.Version.Version_con_info;
           P64[Hp - 8] = _sc5sL::P64;
           P64[Hp] = _sc5sM::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.833897661 UTC

[section ""data" . Data.Version.$fGenericVersion1_closure" {
     Data.Version.$fGenericVersion1_closure:
         const Data.Version.$fGenericVersion1_info;
 },
 Data.Version.$fGenericVersion1_entry() //  [R2]
         { info_tbl: [(cc5yx,
                       label: Data.Version.$fGenericVersion1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5yx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc5yB; else goto cc5yC;
       cc5yB: // global
           R2 = R2;
           R1 = Data.Version.$fGenericVersion1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5yC: // global
           I64[Sp - 8] = block_cc5yu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc5yG; else goto cc5yv;
       uc5yG: // global
           call _cc5yu(R1) args: 0, res: 0, upd: 0;
       cc5yv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5yu() //  [R1]
         { info_tbl: [(cc5yu,
                       label: block_cc5yu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5yu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5yF; else goto cc5yE;
       cc5yF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5yE: // global
           _sc5sP::P64 = P64[R1 + 7];
           _sc5sQ::P64 = P64[R1 + 15];
           I64[Hp - 16] = GHC.Generics.:*:_con_info;
           P64[Hp - 8] = _sc5sP::P64;
           P64[Hp] = _sc5sQ::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.840216412 UTC

[section ""data" . Data.Version.$fGenericVersion_closure" {
     Data.Version.$fGenericVersion_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Version.$fGenericVersion1_closure+1;
         const Data.Version.$fGenericVersion_$cto_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.842149288 UTC

[section ""data" . Data.Version.versionTags_closure" {
     Data.Version.versionTags_closure:
         const Data.Version.versionTags_info;
 },
 Data.Version.versionTags_entry() //  [R2]
         { info_tbl: [(cc5z1,
                       label: Data.Version.versionTags_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5z1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc5z2; else goto cc5z3;
       cc5z2: // global
           R2 = R2;
           R1 = Data.Version.versionTags_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5z3: // global
           I64[Sp - 8] = block_cc5yY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc5z7; else goto cc5yZ;
       uc5z7: // global
           call _cc5yY(R1) args: 0, res: 0, upd: 0;
       cc5yZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5yY() //  [R1]
         { info_tbl: [(cc5yY,
                       label: block_cc5yY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5yY: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.847494304 UTC

[section ""data" . Data.Version.versionBranch_closure" {
     Data.Version.versionBranch_closure:
         const Data.Version.versionBranch_info;
 },
 Data.Version.versionBranch_entry() //  [R2]
         { info_tbl: [(cc5zr,
                       label: Data.Version.versionBranch_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5zr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc5zs; else goto cc5zt;
       cc5zs: // global
           R2 = R2;
           R1 = Data.Version.versionBranch_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5zt: // global
           I64[Sp - 8] = block_cc5zo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc5zx; else goto cc5zp;
       uc5zx: // global
           call _cc5zo(R1) args: 0, res: 0, upd: 0;
       cc5zp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5zo() //  [R1]
         { info_tbl: [(cc5zo,
                       label: block_cc5zo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5zo: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.852674375 UTC

[section ""data" . Data.Version.$fOrdVersion_$ccompare_closure" {
     Data.Version.$fOrdVersion_$ccompare_closure:
         const Data.Version.$fOrdVersion_$ccompare_info;
 },
 Data.Version.$fOrdVersion_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(cc5zR,
                       label: Data.Version.$fOrdVersion_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5zR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5zV; else goto cc5zW;
       cc5zV: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc5zW: // global
           I64[Sp - 16] = block_cc5zO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc5A4; else goto cc5zP;
       uc5A4: // global
           call _cc5zO(R1) args: 0, res: 0, upd: 0;
       cc5zP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5zO() //  [R1]
         { info_tbl: [(cc5zO,
                       label: block_cc5zO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5zO: // global
           I64[Sp] = block_cc5zU_info;
           _sc5t2::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sc5t2::P64;
           if (R1 & 7 != 0) goto uc5A3; else goto cc5zY;
       uc5A3: // global
           call _cc5zU(R1) args: 0, res: 0, upd: 0;
       cc5zY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5zU() //  [R1]
         { info_tbl: [(cc5zU,
                       label: block_cc5zU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5zU: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.859801045 UTC

[section ""data" . Data.Version.$w$c==_closure" {
     Data.Version.$w$c==_closure:
         const Data.Version.$w$c==_info;
 },
 Data.Version.$w$c==_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc5Au,
                       label: Data.Version.$w$c==_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Au: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc5Av; else goto cc5Aw;
       cc5Av: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$w$c==_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc5Aw: // global
           I64[Sp - 24] = block_cc5Ao_info;
           _sc5t8::P64 = R3;
           R3 = R4;
           R2 = R2;
           P64[Sp - 16] = _sc5t8::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call GHC.Classes.$fEq[]_$s$c==_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5Ao() //  [R1]
         { info_tbl: [(cc5Ao,
                       label: block_cc5Ao_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Ao: // global
           if (R1 & 7 == 1) goto cc5Ar; else goto cc5As;
       cc5Ar: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc5As: // global
           I64[Sp] = block_cc5AC_info;
           R3 = P64[Sp + 16];
           R2 = GHC.Classes.$fOrd[]_$s$ccompare1_closure+2;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5AC() //  [R1]
         { info_tbl: [(cc5AC,
                       label: block_cc5AC_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5AC: // global
           _sc5t8::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc5AG_info;
           R3 = _sc5t8::P64;
           R2 = GHC.Classes.$fOrd[]_$s$ccompare1_closure+2;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5AG() //  [R1]
         { info_tbl: [(cc5AG,
                       label: block_cc5AG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5AG: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Classes.$fEq[]_$s$c==1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.869734162 UTC

[section ""data" . Data.Version.$fEqVersion_$c==_closure" {
     Data.Version.$fEqVersion_$c==_closure:
         const Data.Version.$fEqVersion_$c==_info;
 },
 Data.Version.$fEqVersion_$c==_entry() //  [R2, R3]
         { info_tbl: [(cc5Bh,
                       label: Data.Version.$fEqVersion_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Bh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc5Bl; else goto cc5Bm;
       cc5Bl: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fEqVersion_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc5Bm: // global
           I64[Sp - 16] = block_cc5Be_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc5Bu; else goto cc5Bf;
       uc5Bu: // global
           call _cc5Be(R1) args: 0, res: 0, upd: 0;
       cc5Bf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5Be() //  [R1]
         { info_tbl: [(cc5Be,
                       label: block_cc5Be_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Be: // global
           I64[Sp - 8] = block_cc5Bk_info;
           _sc5th::P64 = P64[R1 + 7];
           _sc5ti::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sc5ti::P64;
           P64[Sp + 8] = _sc5th::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc5Bt; else goto cc5Bo;
       uc5Bt: // global
           call _cc5Bk(R1) args: 0, res: 0, upd: 0;
       cc5Bo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5Bk() //  [R1]
         { info_tbl: [(cc5Bk,
                       label: block_cc5Bk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Bk: // global
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.Version.$w$c==_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.877349705 UTC

[section ""data" . Data.Version.$fEqVersion_$c/=_closure" {
     Data.Version.$fEqVersion_$c/=_closure:
         const Data.Version.$fEqVersion_$c/=_info;
 },
 Data.Version.$fEqVersion_$c/=_entry() //  [R2, R3]
         { info_tbl: [(cc5BR,
                       label: Data.Version.$fEqVersion_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5BR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc5BV; else goto cc5BW;
       cc5BV: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fEqVersion_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc5BW: // global
           I64[Sp - 16] = block_cc5BO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc5Cg; else goto cc5BP;
       uc5Cg: // global
           call _cc5BO(R1) args: 0, res: 0, upd: 0;
       cc5BP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5BO() //  [R1]
         { info_tbl: [(cc5BO,
                       label: block_cc5BO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5BO: // global
           I64[Sp - 8] = block_cc5BU_info;
           _sc5tp::P64 = P64[R1 + 7];
           _sc5tq::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sc5tq::P64;
           P64[Sp + 8] = _sc5tp::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc5Cf; else goto cc5BY;
       uc5Cf: // global
           call _cc5BU(R1) args: 0, res: 0, upd: 0;
       cc5BY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5BU() //  [R1]
         { info_tbl: [(cc5BU,
                       label: block_cc5BU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5BU: // global
           _sc5tp::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cc5C2_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = _sc5tp::P64;
           Sp = Sp + 16;
           call Data.Version.$w$c==_entry(R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5C2() //  [R1]
         { info_tbl: [(cc5C2,
                       label: block_cc5C2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5C2: // global
           if (R1 & 7 == 1) goto cc5C9; else goto cc5Cd;
       cc5C9: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc5Cd: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.885935543 UTC

[section ""data" . Data.Version.$fEqVersion_closure" {
     Data.Version.$fEqVersion_closure:
         const GHC.Classes.C:Eq_con_info;
         const Data.Version.$fEqVersion_$c==_closure+2;
         const Data.Version.$fEqVersion_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.888060536 UTC

[section ""data" . Data.Version.$fOrdVersion_$c<_closure" {
     Data.Version.$fOrdVersion_$c<_closure:
         const Data.Version.$fOrdVersion_$c<_info;
 },
 Data.Version.$fOrdVersion_$c<_entry() //  [R2, R3]
         { info_tbl: [(cc5CO,
                       label: Data.Version.$fOrdVersion_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5CO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5CS; else goto cc5CT;
       cc5CS: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc5CT: // global
           I64[Sp - 16] = block_cc5CL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc5Dd; else goto cc5CM;
       uc5Dd: // global
           call _cc5CL(R1) args: 0, res: 0, upd: 0;
       cc5CM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5CL() //  [R1]
         { info_tbl: [(cc5CL,
                       label: block_cc5CL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5CL: // global
           I64[Sp] = block_cc5CR_info;
           _sc5ty::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sc5ty::P64;
           if (R1 & 7 != 0) goto uc5Dc; else goto cc5CV;
       uc5Dc: // global
           call _cc5CR(R1) args: 0, res: 0, upd: 0;
       cc5CV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5CR() //  [R1]
         { info_tbl: [(cc5CR,
                       label: block_cc5CR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5CR: // global
           _sc5ty::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc5CZ_info;
           R3 = P64[R1 + 7];
           R2 = _sc5ty::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5CZ() //  [R1]
         { info_tbl: [(cc5CZ,
                       label: block_cc5CZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5CZ: // global
           if (R1 & 7 == 1) goto cc5Da; else goto cc5D6;
       cc5Da: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc5D6: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.897046359 UTC

[section ""data" . Data.Version.$fOrdVersion_$c>=_closure" {
     Data.Version.$fOrdVersion_$c>=_closure:
         const Data.Version.$fOrdVersion_$c>=_info;
 },
 Data.Version.$fOrdVersion_$c>=_entry() //  [R2, R3]
         { info_tbl: [(cc5DK,
                       label: Data.Version.$fOrdVersion_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5DK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5DO; else goto cc5DP;
       cc5DO: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc5DP: // global
           I64[Sp - 16] = block_cc5DH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc5E9; else goto cc5DI;
       uc5E9: // global
           call _cc5DH(R1) args: 0, res: 0, upd: 0;
       cc5DI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5DH() //  [R1]
         { info_tbl: [(cc5DH,
                       label: block_cc5DH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5DH: // global
           I64[Sp] = block_cc5DN_info;
           _sc5tH::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sc5tH::P64;
           if (R1 & 7 != 0) goto uc5E8; else goto cc5DR;
       uc5E8: // global
           call _cc5DN(R1) args: 0, res: 0, upd: 0;
       cc5DR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5DN() //  [R1]
         { info_tbl: [(cc5DN,
                       label: block_cc5DN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5DN: // global
           _sc5tH::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc5DV_info;
           R3 = P64[R1 + 7];
           R2 = _sc5tH::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5DV() //  [R1]
         { info_tbl: [(cc5DV,
                       label: block_cc5DV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5DV: // global
           if (R1 & 7 == 1) goto cc5E6; else goto cc5E2;
       cc5E6: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc5E2: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.906883609 UTC

[section ""data" . Data.Version.$fOrdVersion_$c>_closure" {
     Data.Version.$fOrdVersion_$c>_closure:
         const Data.Version.$fOrdVersion_$c>_info;
 },
 Data.Version.$fOrdVersion_$c>_entry() //  [R2, R3]
         { info_tbl: [(cc5EG,
                       label: Data.Version.$fOrdVersion_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5EG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5EK; else goto cc5EL;
       cc5EK: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc5EL: // global
           I64[Sp - 16] = block_cc5ED_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc5F5; else goto cc5EE;
       uc5F5: // global
           call _cc5ED(R1) args: 0, res: 0, upd: 0;
       cc5EE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5ED() //  [R1]
         { info_tbl: [(cc5ED,
                       label: block_cc5ED_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5ED: // global
           I64[Sp] = block_cc5EJ_info;
           _sc5tQ::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sc5tQ::P64;
           if (R1 & 7 != 0) goto uc5F4; else goto cc5EN;
       uc5F4: // global
           call _cc5EJ(R1) args: 0, res: 0, upd: 0;
       cc5EN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5EJ() //  [R1]
         { info_tbl: [(cc5EJ,
                       label: block_cc5EJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5EJ: // global
           _sc5tQ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc5ER_info;
           R3 = P64[R1 + 7];
           R2 = _sc5tQ::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5ER() //  [R1]
         { info_tbl: [(cc5ER,
                       label: block_cc5ER_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5ER: // global
           if (R1 & 7 == 3) goto cc5F2; else goto cc5EY;
       cc5F2: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc5EY: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.916389432 UTC

[section ""data" . Data.Version.$fOrdVersion_$c<=_closure" {
     Data.Version.$fOrdVersion_$c<=_closure:
         const Data.Version.$fOrdVersion_$c<=_info;
 },
 Data.Version.$fOrdVersion_$c<=_entry() //  [R2, R3]
         { info_tbl: [(cc5FC,
                       label: Data.Version.$fOrdVersion_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5FC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5FG; else goto cc5FH;
       cc5FG: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc5FH: // global
           I64[Sp - 16] = block_cc5Fz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc5G1; else goto cc5FA;
       uc5G1: // global
           call _cc5Fz(R1) args: 0, res: 0, upd: 0;
       cc5FA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5Fz() //  [R1]
         { info_tbl: [(cc5Fz,
                       label: block_cc5Fz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Fz: // global
           I64[Sp] = block_cc5FF_info;
           _sc5tZ::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sc5tZ::P64;
           if (R1 & 7 != 0) goto uc5G0; else goto cc5FJ;
       uc5G0: // global
           call _cc5FF(R1) args: 0, res: 0, upd: 0;
       cc5FJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5FF() //  [R1]
         { info_tbl: [(cc5FF,
                       label: block_cc5FF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5FF: // global
           _sc5tZ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc5FN_info;
           R3 = P64[R1 + 7];
           R2 = _sc5tZ::P64;
           Sp = Sp + 8;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5FN() //  [R1]
         { info_tbl: [(cc5FN,
                       label: block_cc5FN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5FN: // global
           if (R1 & 7 == 3) goto cc5FY; else goto cc5FU;
       cc5FY: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc5FU: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.925335083 UTC

[section ""data" . Data.Version.$fOrdVersion_$cmax_closure" {
     Data.Version.$fOrdVersion_$cmax_closure:
         const Data.Version.$fOrdVersion_$cmax_info;
 },
 Data.Version.$fOrdVersion_$cmax_entry() //  [R2, R3]
         { info_tbl: [(cc5Gy,
                       label: Data.Version.$fOrdVersion_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Gy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc5GC; else goto cc5GD;
       cc5GC: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc5GD: // global
           I64[Sp - 16] = block_cc5Gv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc5GX; else goto cc5Gw;
       uc5GX: // global
           call _cc5Gv(R1) args: 0, res: 0, upd: 0;
       cc5Gw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5Gv() //  [R1]
         { info_tbl: [(cc5Gv,
                       label: block_cc5Gv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Gv: // global
           I64[Sp - 8] = block_cc5GB_info;
           _sc5u7::P64 = R1;
           _sc5u8::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp] = _sc5u8::P64;
           P64[Sp + 8] = _sc5u7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc5GW; else goto cc5GF;
       uc5GW: // global
           call _cc5GB(R1) args: 0, res: 0, upd: 0;
       cc5GF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5GB() //  [R1]
         { info_tbl: [(cc5GB,
                       label: block_cc5GB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5GB: // global
           I64[Sp] = block_cc5GJ_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5GJ() //  [R1]
         { info_tbl: [(cc5GJ,
                       label: block_cc5GJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5GJ: // global
           if (R1 & 7 == 3) goto cc5GU; else goto cc5GQ;
       cc5GU: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc5GQ: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.934654902 UTC

[section ""data" . Data.Version.$fOrdVersion_$cmin_closure" {
     Data.Version.$fOrdVersion_$cmin_closure:
         const Data.Version.$fOrdVersion_$cmin_info;
 },
 Data.Version.$fOrdVersion_$cmin_entry() //  [R2, R3]
         { info_tbl: [(cc5Hu,
                       label: Data.Version.$fOrdVersion_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Hu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc5Hy; else goto cc5Hz;
       cc5Hy: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fOrdVersion_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc5Hz: // global
           I64[Sp - 16] = block_cc5Hr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc5HT; else goto cc5Hs;
       uc5HT: // global
           call _cc5Hr(R1) args: 0, res: 0, upd: 0;
       cc5Hs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5Hr() //  [R1]
         { info_tbl: [(cc5Hr,
                       label: block_cc5Hr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Hr: // global
           I64[Sp - 8] = block_cc5Hx_info;
           _sc5ug::P64 = R1;
           _sc5uh::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp] = _sc5uh::P64;
           P64[Sp + 8] = _sc5ug::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc5HS; else goto cc5HB;
       uc5HS: // global
           call _cc5Hx(R1) args: 0, res: 0, upd: 0;
       cc5HB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5Hx() //  [R1]
         { info_tbl: [(cc5Hx,
                       label: block_cc5Hx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Hx: // global
           I64[Sp] = block_cc5HF_info;
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Classes.$fOrd[]_$s$ccompare_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5HF() //  [R1]
         { info_tbl: [(cc5HF,
                       label: block_cc5HF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5HF: // global
           if (R1 & 7 == 3) goto cc5HQ; else goto cc5HM;
       cc5HQ: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc5HM: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.943993274 UTC

[section ""data" . Data.Version.$fOrdVersion_closure" {
     Data.Version.$fOrdVersion_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Version.$fEqVersion_closure+1;
         const Data.Version.$fOrdVersion_$ccompare_closure+2;
         const Data.Version.$fOrdVersion_$c<_closure+2;
         const Data.Version.$fOrdVersion_$c<=_closure+2;
         const Data.Version.$fOrdVersion_$c>_closure+2;
         const Data.Version.$fOrdVersion_$c>=_closure+2;
         const Data.Version.$fOrdVersion_$cmax_closure+2;
         const Data.Version.$fOrdVersion_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.946357243 UTC

[section ""data" . Data.Version.makeVersion_closure" {
     Data.Version.makeVersion_closure:
         const Data.Version.makeVersion_info;
 },
 Data.Version.makeVersion_entry() //  [R2]
         { info_tbl: [(cc5Ip,
                       label: Data.Version.makeVersion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Ip: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5It; else goto cc5Is;
       cc5It: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Version.makeVersion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5Is: // global
           I64[Hp - 16] = Data.Version.Version_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.94979345 UTC

[section ""cstring" . Data.Version.$trModule4_bytes" {
     Data.Version.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.95130765 UTC

[section ""data" . Data.Version.$trModule3_closure" {
     Data.Version.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Version.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.952870808 UTC

[section ""cstring" . Data.Version.$trModule2_bytes" {
     Data.Version.$trModule2_bytes:
         I8[] [68,97,116,97,46,86,101,114,115,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.954454064 UTC

[section ""data" . Data.Version.$trModule1_closure" {
     Data.Version.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Version.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.956032862 UTC

[section ""data" . Data.Version.$trModule_closure" {
     Data.Version.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Version.$trModule3_closure+1;
         const Data.Version.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.957710843 UTC

[section ""data" . $krep_rc3Yn_closure" {
     $krep_rc3Yn_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcChar_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.959379741 UTC

[section ""data" . $krep1_rc3Yo_closure" {
     $krep1_rc3Yo_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.961051951 UTC

[section ""data" . $krep2_rc3Yp_closure" {
     $krep2_rc3Yp_closure:
         const :_con_info;
         const $krep_rc3Yn_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.963176671 UTC

[section ""data" . $krep3_rc3Yq_closure" {
     $krep3_rc3Yq_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep2_rc3Yp_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.96485162 UTC

[section ""data" . $krep4_rc3Yr_closure" {
     $krep4_rc3Yr_closure:
         const :_con_info;
         const $krep1_rc3Yo_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.966532341 UTC

[section ""data" . $krep5_rc3Ys_closure" {
     $krep5_rc3Ys_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep4_rc3Yr_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.968665472 UTC

[section ""data" . $krep6_rc3Yt_closure" {
     $krep6_rc3Yt_closure:
         const :_con_info;
         const $krep3_rc3Yq_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.970291875 UTC

[section ""data" . $krep7_rc3Yu_closure" {
     $krep7_rc3Yu_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep6_rc3Yt_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.971811522 UTC

[section ""cstring" . Data.Version.$fReadVersion19_bytes" {
     Data.Version.$fReadVersion19_bytes:
         I8[] [86,101,114,115,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.973896501 UTC

[section ""data" . Data.Version.$tcVersion1_closure" {
     Data.Version.$tcVersion1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Version.$fReadVersion19_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.975498151 UTC

[section ""data" . Data.Version.$tcVersion_closure" {
     Data.Version.$tcVersion_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Version.$trModule_closure+1;
         const Data.Version.$tcVersion1_closure+1;
         const GHC.Types.krep$*_closure;
         const 18148779789861942324;
         const 12675349638857785520;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.97730919 UTC

[section ""data" . $krep8_rc3Yv_closure" {
     $krep8_rc3Yv_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Version.$tcVersion_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.978867572 UTC

[section ""data" . $krep9_rc3Yw_closure" {
     $krep9_rc3Yw_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_rc3Yu_closure+1;
         const $krep8_rc3Yv_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.980474845 UTC

[section ""data" . Data.Version.$tc'Version1_closure" {
     Data.Version.$tc'Version1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_rc3Ys_closure+1;
         const $krep9_rc3Yw_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.982116993 UTC

[section ""cstring" . Data.Version.$tc'Version3_bytes" {
     Data.Version.$tc'Version3_bytes:
         I8[] [39,86,101,114,115,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.983659183 UTC

[section ""data" . Data.Version.$tc'Version2_closure" {
     Data.Version.$tc'Version2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Version.$tc'Version3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.985269151 UTC

[section ""data" . Data.Version.$tc'Version_closure" {
     Data.Version.$tc'Version_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Version.$trModule_closure+1;
         const Data.Version.$tc'Version2_closure+1;
         const Data.Version.$tc'Version1_closure+4;
         const 3698077959655346891;
         const 8062481246695158651;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.987016084 UTC

[section ""cstring" . f_rc3Yx_bytes" {
     f_rc3Yx_bytes:
         I8[] [86,101,114,115,105,111,110,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.988776922 UTC

[section ""data" . f1_rc3Yy_closure" {
     f1_rc3Yy_closure:
         const f1_rc3Yy_info;
         const 0;
         const 0;
         const 0;
 },
 f1_rc3Yy_entry() //  [R1]
         { info_tbl: [(cc5J5,
                       label: f1_rc3Yy_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5J5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5J6; else goto cc5J7;
       cc5J6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5J7: // global
           (_cc5J2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc5J2::I64 == 0) goto cc5J4; else goto cc5J3;
       cc5J4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc5J3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc5J2::I64;
           R2 = f_rc3Yx_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.993525053 UTC

[section ""cstring" . lvl_rc3Yz_bytes" {
     lvl_rc3Yz_bytes:
         I8[] [118,101,114,115,105,111,110,66,114,97,110,99,104,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.995038407 UTC

[section ""cstring" . lvl1_rc3YA_bytes" {
     lvl1_rc3YA_bytes:
         I8[] [118,101,114,115,105,111,110,84,97,103,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:59.996545523 UTC

[section ""cstring" . Data.Version.$fReadVersion5_bytes" {
     Data.Version.$fReadVersion5_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.002487705 UTC

[section ""data" . Data.Version.$w$cshowsPrec_closure" {
     Data.Version.$w$cshowsPrec_closure:
         const Data.Version.$w$cshowsPrec_info;
         const 0;
 },
 Data.Version.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Jk: // global
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Data.Version.$w$cshowsPrec_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2,
                                                 R1) args: 8, res: 0, upd: 8;
     }
 },
 s1_sc5uv_entry() //  [R1]
         { info_tbl: [(cc5JN,
                       label: s1_sc5uv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5JN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5JO; else goto cc5JP;
       cc5JO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5JP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Version.$fReadVersion5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc5uH_entry() //  [R1]
         { info_tbl: [(cc5Km,
                       label: sat_sc5uH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Km: // global
           _sc5uH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc5Kn; else goto cc5Ko;
       cc5Ko: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc5Kq; else goto cc5Kp;
       cc5Kq: // global
           HpAlloc = 56;
           goto cc5Kn;
       cc5Kn: // global
           R1 = _sc5uH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5Kp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc5uH::P64;
           _sc5uA::P64 = P64[_sc5uH::P64 + 16];
           _sc5uD::P64 = P64[_sc5uH::P64 + 24];
           _sc5uE::P64 = P64[_sc5uH::P64 + 32];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sc5uA::P64;
           P64[Hp - 24] = _sc5uE::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sc5uD::P64;
           Sp = Sp - 16;
           call GHC.Show.showLitString_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 showl_sc5uA_entry() //  [R1, R2]
         { info_tbl: [(cc5Kv,
                       label: showl_sc5uA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Kv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc5Kw; else goto cc5Kx;
       cc5Kw: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5Kx: // global
           I64[Sp - 24] = block_cc5Ka_info;
           _sc5uA::P64 = R1;
           _sc5uz::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sc5uz::P64;
           P64[Sp - 8] = _sc5uA::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc5KF; else goto cc5Kb;
       uc5KF: // global
           call _cc5Ka(R1) args: 0, res: 0, upd: 0;
       cc5Kb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5Ka() //  [R1]
         { info_tbl: [(cc5Ka,
                       label: block_cc5Ka_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Ka: // global
           if (R1 & 7 == 1) goto cc5Ks; else goto cc5Kt;
       cc5Ks: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc5Kt: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cc5KE; else goto cc5KD;
       cc5KE: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5KD: // global
           _sc5uD::P64 = P64[R1 + 6];
           _sc5uE::P64 = P64[R1 + 14];
           I64[Hp - 80] = sat_sc5uH_info;
           P64[Hp - 64] = P64[Sp + 16];
           P64[Hp - 56] = _sc5uD::P64;
           P64[Hp - 48] = _sc5uE::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = GHC.Show.$fShow(,)3_closure;
           P64[Hp - 24] = Hp - 80;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.showList__1_closure;
           P64[Hp] = Hp - 38;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc5uJ_entry() //  [R1]
         { info_tbl: [(cc5KG,
                       label: sat_sc5uJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5KG: // global
           _sc5uJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc5KH; else goto cc5KI;
       cc5KI: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc5KK; else goto cc5KJ;
       cc5KK: // global
           HpAlloc = 40;
           goto cc5KH;
       cc5KH: // global
           R1 = _sc5uJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5KJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc5uJ::P64;
           _sc5uv::P64 = P64[_sc5uJ::P64 + 16];
           _sc5uy::P64 = P64[_sc5uJ::P64 + 24];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.Show.showList__2_closure;
           P64[Hp - 16] = _sc5uv::P64;
           I64[Hp - 8] = showl_sc5uA_info;
           P64[Hp] = Hp - 30;
           R2 = _sc5uy::P64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call showl_sc5uA_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc5uL_entry() //  [R1]
         { info_tbl: [(cc5KM,
                       label: sat_sc5uL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5KM: // global
           _sc5uL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc5KN; else goto cc5KO;
       cc5KO: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc5KQ; else goto cc5KP;
       cc5KQ: // global
           HpAlloc = 56;
           goto cc5KN;
       cc5KN: // global
           R1 = _sc5uL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5KP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc5uL::P64;
           _sc5uv::P64 = P64[_sc5uL::P64 + 16];
           _sc5ux::P64 = P64[_sc5uL::P64 + 24];
           _sc5uy::P64 = P64[_sc5uL::P64 + 32];
           I64[Hp - 48] = sat_sc5uJ_info;
           P64[Hp - 32] = _sc5uv::P64;
           P64[Hp - 24] = _sc5uy::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)3_closure;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sc5ux::P64;
           Sp = Sp - 16;
           call GHC.Show.showLitString_entry(R3,
                                             R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc5uN_entry() //  [R1]
         { info_tbl: [(cc5KV,
                       label: sat_sc5uN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5KV: // global
           _sc5uN::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc5KW; else goto cc5KX;
       cc5KX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5KZ; else goto cc5KY;
       cc5KZ: // global
           HpAlloc = 24;
           goto cc5KW;
       cc5KW: // global
           R1 = _sc5uN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5KY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc5uN::P64;
           _sc5uq::P64 = P64[_sc5uN::P64 + 16];
           _sc5ut::P64 = P64[_sc5uN::P64 + 24];
           I64[Hp - 16] = s1_sc5uv_info;
           P64[Hp] = _sc5ut::P64;
           I64[Sp - 32] = block_cc5JQ_info;
           R1 = _sc5uq::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uc5L7; else goto cc5JR;
       uc5L7: // global
           call _cc5JQ(R1) args: 0, res: 0, upd: 0;
       cc5JR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc5JQ() //  [R1]
         { info_tbl: [(cc5JQ,
                       label: block_cc5JQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5JQ: // global
           _cc5JJ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc5KS; else goto cc5KT;
       cc5KS: // global
           R3 = _cc5JJ::P64;
           R2 = GHC.Show.showList__4_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
       cc5KT: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cc5L6; else goto cc5L5;
       cc5L6: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cc5L5: // global
           _sc5ux::P64 = P64[R1 + 6];
           _sc5uy::P64 = P64[R1 + 14];
           I64[Hp - 80] = sat_sc5uL_info;
           P64[Hp - 64] = _cc5JJ::P64;
           P64[Hp - 56] = _sc5ux::P64;
           P64[Hp - 48] = _sc5uy::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = GHC.Show.$fShow(,)3_closure;
           P64[Hp - 24] = Hp - 80;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.showList__3_closure;
           P64[Hp] = Hp - 38;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc5uO_entry() //  [R1]
         { info_tbl: [(cc5L8,
                       label: sat_sc5uO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5L8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc5Lc; else goto cc5Lb;
       cc5Lc: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5Lb: // global
           _sc5uq::P64 = P64[R1 + 16];
           _sc5ut::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_sc5uN_info;
           P64[Hp - 8] = _sc5uq::P64;
           P64[Hp] = _sc5ut::P64;
           R3 = Hp - 24;
           R2 = lvl1_rc3YA_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 s_sc5uu_entry() //  [R1]
         { info_tbl: [(cc5Ld,
                       label: s_sc5uu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Ld: // global
           _sc5uu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc5Le; else goto cc5Lf;
       cc5Lf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc5Lh; else goto cc5Lg;
       cc5Lh: // global
           HpAlloc = 32;
           goto cc5Le;
       cc5Le: // global
           R1 = _sc5uu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5Lg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc5uu::P64;
           _sc5uq::P64 = P64[_sc5uu::P64 + 16];
           _sc5ut::P64 = P64[_sc5uu::P64 + 24];
           I64[Hp - 24] = sat_sc5uO_info;
           P64[Hp - 8] = _sc5uq::P64;
           P64[Hp] = _sc5ut::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc5v6_entry() //  [R1]
         { info_tbl: [(cc5LU,
                       label: sat_sc5v6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5LU: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc5M1; else goto cc5M2;
       cc5M1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5M2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cc5LR_info;
           _sc5uV::P64 = P64[R1 + 16];
           _sc5uZ::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sc5uV::P64;
           P64[Sp - 24] = _sc5uZ::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc5M9; else goto cc5LS;
       uc5M9: // global
           call _cc5LR(R1) args: 0, res: 0, upd: 0;
       cc5LS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc5LR() //  [R1]
         { info_tbl: [(cc5LR,
                       label: block_cc5LR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5LR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc5M5; else goto cc5M4;
       cc5M5: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cc5M4: // global
           _sc5v1::I64 = I64[R1 + 7];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cc5LY_info;
           R4 = Hp - 24;
           R3 = _sc5v1::I64;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc5LY() //  [R1, R2]
         { info_tbl: [(cc5LY,
                       label: block_cc5LY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5LY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5M8; else goto cc5M7;
       cc5M8: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cc5M7: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 showl_sc5uV_entry() //  [R1, R2]
         { info_tbl: [(cc5Me,
                       label: showl_sc5uV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Me: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc5Mf; else goto cc5Mg;
       cc5Mf: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5Mg: // global
           I64[Sp - 24] = block_cc5LH_info;
           _sc5uV::P64 = R1;
           _sc5uU::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sc5uU::P64;
           P64[Sp - 8] = _sc5uV::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc5Mn; else goto cc5LI;
       uc5Mn: // global
           call _cc5LH(R1) args: 0, res: 0, upd: 0;
       cc5LI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5LH() //  [R1]
         { info_tbl: [(cc5LH,
                       label: block_cc5LH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5LH: // global
           if (R1 & 7 == 1) goto cc5Mb; else goto cc5Mc;
       cc5Mb: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc5Mc: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc5Mm; else goto cc5Ml;
       cc5Mm: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5Ml: // global
           _sc5uY::P64 = P64[R1 + 6];
           _sc5uZ::P64 = P64[R1 + 14];
           I64[Hp - 56] = sat_sc5v6_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = _sc5uY::P64;
           P64[Hp - 24] = _sc5uZ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.showList__1_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc5v7_entry() //  [R1]
         { info_tbl: [(cc5Mo,
                       label: sat_sc5v7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Mo: // global
           _sc5v7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc5Mp; else goto cc5Mq;
       cc5Mq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc5Ms; else goto cc5Mr;
       cc5Ms: // global
           HpAlloc = 40;
           goto cc5Mp;
       cc5Mp: // global
           R1 = _sc5v7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5Mr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc5v7::P64;
           _sc5uu::P64 = P64[_sc5v7::P64 + 16];
           _sc5uR::P64 = P64[_sc5v7::P64 + 24];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.Show.showList__2_closure;
           P64[Hp - 16] = _sc5uu::P64;
           I64[Hp - 8] = showl_sc5uV_info;
           P64[Hp] = Hp - 30;
           R2 = _sc5uR::P64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call showl_sc5uV_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc5vb_entry() //  [R1]
         { info_tbl: [(cc5Mt,
                       label: sat_sc5vb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Mt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cc5Mx; else goto cc5My;
       cc5Mx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5My: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cc5Ls_info;
           _sc5uu::P64 = P64[R1 + 16];
           _sc5uR::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sc5uu::P64;
           P64[Sp - 24] = _sc5uR::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uc5MF; else goto cc5Lt;
       uc5MF: // global
           call _cc5Ls(R1) args: 0, res: 0, upd: 0;
       cc5Lt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc5Ls() //  [R1]
         { info_tbl: [(cc5Ls,
                       label: block_cc5Ls_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Ls: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc5MB; else goto cc5MA;
       cc5MB: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cc5MA: // global
           _sc5uT::I64 = I64[R1 + 7];
           I64[Hp - 24] = sat_sc5v7_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_cc5Mu_info;
           R4 = Hp - 24;
           R3 = _sc5uT::I64;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc5Mu() //  [R1, R2]
         { info_tbl: [(cc5Mu,
                       label: block_cc5Mu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Mu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5ME; else goto cc5MD;
       cc5ME: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cc5MD: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc5vc_entry() //  [R1]
         { info_tbl: [(cc5MK,
                       label: sat_sc5vc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5MK: // global
           _sc5vc::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc5ML; else goto cc5MM;
       cc5MM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc5MO; else goto cc5MN;
       cc5MO: // global
           HpAlloc = 32;
           goto cc5ML;
       cc5ML: // global
           R1 = _sc5vc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5MN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc5vc::P64;
           _sc5up::P64 = P64[_sc5vc::P64 + 16];
           _sc5uq::P64 = P64[_sc5vc::P64 + 24];
           _sc5ut::P64 = P64[_sc5vc::P64 + 32];
           I64[Hp - 24] = s_sc5uu_info;
           P64[Hp - 8] = _sc5uq::P64;
           P64[Hp] = _sc5ut::P64;
           I64[Sp - 32] = block_cc5Li_info;
           R1 = _sc5up::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uc5MV; else goto cc5Lj;
       uc5MV: // global
           call _cc5Li(R1) args: 0, res: 0, upd: 0;
       cc5Lj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc5Li() //  [R1]
         { info_tbl: [(cc5Li,
                       label: block_cc5Li_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Li: // global
           _cc5Jx::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc5MH; else goto cc5MI;
       cc5MH: // global
           R3 = _cc5Jx::P64;
           R2 = GHC.Show.showList__4_bytes;
           Sp = Sp + 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
       cc5MI: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc5MU; else goto cc5MT;
       cc5MU: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cc5MT: // global
           _sc5uQ::P64 = P64[R1 + 6];
           _sc5uR::P64 = P64[R1 + 14];
           I64[Hp - 56] = sat_sc5vb_info;
           P64[Hp - 40] = _cc5Jx::P64;
           P64[Hp - 32] = _sc5uQ::P64;
           P64[Hp - 24] = _sc5uR::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.showList__3_closure;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 g_sc5us_entry() //  [R1, R2]
         { info_tbl: [(cc5MW,
                       label: g_sc5us_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5MW: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc5N0; else goto cc5MZ;
       cc5N0: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5MZ: // global
           _sc5up::P64 = P64[R1 + 7];
           _sc5uq::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_sc5vc_info;
           P64[Hp - 16] = _sc5up::P64;
           P64[Hp - 8] = _sc5uq::P64;
           P64[Hp] = R2;
           R3 = Hp - 32;
           R2 = lvl_rc3Yz_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc5ve_entry() //  [R1]
         { info_tbl: [(cc5N8,
                       label: sat_sc5ve_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5N8: // global
           R2 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           call g_sc5us_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc5vg_entry() //  [R1]
         { info_tbl: [(cc5Nl,
                       label: sat_sc5vg_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Nl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5Np; else goto cc5No;
       cc5Np: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5No: // global
           _sc5ur::P64 = P64[R1 + 16];
           _sc5us::P64 = P64[R1 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _sc5ur::P64;
           R2 = Hp - 14;
           R1 = _sc5us::P64;
           call g_sc5us_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc5vh_entry() //  [R1]
         { info_tbl: [(cc5Nq,
                       label: sat_sc5vh_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Nq: // global
           _sc5vh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cc5Nr; else goto cc5Ns;
       cc5Ns: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc5Nu; else goto cc5Nt;
       cc5Nu: // global
           HpAlloc = 32;
           goto cc5Nr;
       cc5Nr: // global
           R1 = _sc5vh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5Nt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc5vh::P64;
           _sc5ur::P64 = P64[_sc5vh::P64 + 16];
           _sc5us::P64 = P64[_sc5vh::P64 + 24];
           I64[Hp - 24] = sat_sc5vg_info;
           P64[Hp - 8] = _sc5ur::P64;
           P64[Hp] = _sc5us::P64;
           R3 = Hp - 24;
           R2 = f1_rc3Yy_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Version.$w$cshowsPrec_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cc5Ny,
                       label: Data.Version.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 4 fun_type: ArgGen [True, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Ny: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cc5NC; else goto cc5NB;
       cc5NC: // global
           HpAlloc = 80;
           R1 = Data.Version.$w$cshowsPrec_closure;
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cc5NB: // global
           I64[Hp - 72] = g_sc5us_info;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           _cc5Jo::P64 = Hp - 71;
           if (%MO_S_Lt_W64(R2, 11)) goto cc5Nw; else goto cc5Nx;
       cc5Nw: // global
           I64[Hp - 48] = sat_sc5ve_info;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = _cc5Jo::P64;
           _cc5N4::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _cc5N4::P64;
           R2 = f1_rc3Yy_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       cc5Nx: // global
           I64[Hp - 48] = sat_sc5vh_info;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = _cc5Jo::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.062891922 UTC

[section ""data" . Data.Version.$fShowVersion_$cshowsPrec_closure" {
     Data.Version.$fShowVersion_$cshowsPrec_closure:
         const Data.Version.$fShowVersion_$cshowsPrec_info;
         const 0;
 },
 Data.Version.$fShowVersion_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cc5R0,
                       label: Data.Version.$fShowVersion_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5R0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc5R4; else goto cc5R5;
       cc5R4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fShowVersion_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc5R5: // global
           I64[Sp - 24] = block_cc5QX_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc5Rd; else goto cc5QY;
       uc5Rd: // global
           call _cc5QX(R1) args: 0, res: 0, upd: 0;
       cc5QY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5QX() //  [R1]
         { info_tbl: [(cc5QX,
                       label: block_cc5QX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5QX: // global
           I64[Sp] = block_cc5R3_info;
           _sc5vm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sc5vm::I64;
           if (R1 & 7 != 0) goto uc5Rc; else goto cc5R7;
       uc5Rc: // global
           call _cc5R3(R1) args: 0, res: 0, upd: 0;
       cc5R7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5R3() //  [R1]
         { info_tbl: [(cc5R3,
                       label: block_cc5R3_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5R3: // global
           R5 = P64[Sp + 16];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call Data.Version.$w$cshowsPrec_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.070491185 UTC

[section ""data" . Data.Version.$fShowVersion2_closure" {
     Data.Version.$fShowVersion2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.07239247 UTC

[section ""data" . Data.Version.$fShowVersion_$cshow_closure" {
     Data.Version.$fShowVersion_$cshow_closure:
         const Data.Version.$fShowVersion_$cshow_info;
         const 0;
 },
 Data.Version.$fShowVersion_$cshow_entry() //  [R2]
         { info_tbl: [(cc5RB,
                       label: Data.Version.$fShowVersion_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5RB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc5RC; else goto cc5RD;
       cc5RC: // global
           R2 = R2;
           R1 = Data.Version.$fShowVersion_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5RD: // global
           I64[Sp - 8] = block_cc5Ry_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc5RH; else goto cc5Rz;
       uc5RH: // global
           call _cc5Ry(R1) args: 0, res: 0, upd: 0;
       cc5Rz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5Ry() //  [R1]
         { info_tbl: [(cc5Ry,
                       label: block_cc5Ry_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Ry: // global
           R5 = GHC.Types.[]_closure+1;
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call Data.Version.$w$cshowsPrec_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.078494325 UTC

[section ""data" . Data.Version.$fShowVersion1_closure" {
     Data.Version.$fShowVersion1_closure:
         const Data.Version.$fShowVersion1_info;
         const 0;
 },
 Data.Version.$fShowVersion1_entry() //  [R2, R3]
         { info_tbl: [(cc5S0,
                       label: Data.Version.$fShowVersion1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5S0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5S1; else goto cc5S2;
       cc5S1: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fShowVersion1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc5S2: // global
           I64[Sp - 16] = block_cc5RX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc5S6; else goto cc5RY;
       uc5S6: // global
           call _cc5RX(R1) args: 0, res: 0, upd: 0;
       cc5RY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5RX() //  [R1]
         { info_tbl: [(cc5RX,
                       label: block_cc5RX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5RX: // global
           R5 = P64[Sp + 8];
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = 0;
           Sp = Sp + 16;
           call Data.Version.$w$cshowsPrec_entry(R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.083824086 UTC

[section ""data" . Data.Version.$fShowVersion_$cshowList_closure" {
     Data.Version.$fShowVersion_$cshowList_closure:
         const Data.Version.$fShowVersion_$cshowList_info;
         const 0;
 },
 Data.Version.$fShowVersion_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cc5Sl,
                       label: Data.Version.$fShowVersion_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Sl: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Version.$fShowVersion1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.087077662 UTC

[section ""data" . Data.Version.$fShowVersion_closure" {
     Data.Version.$fShowVersion_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Version.$fShowVersion_$cshowsPrec_closure+3;
         const Data.Version.$fShowVersion_$cshow_closure+1;
         const Data.Version.$fShowVersion_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.088714497 UTC

[section ""data" . f2_rc3YB_closure" {
     f2_rc3YB_closure:
         const GHC.Types.C#_con_info;
         const 45;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.09041302 UTC

[section ""cstring" . Data.Version.showVersion2_bytes" {
     Data.Version.showVersion2_bytes:
         I8[] [46]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.092219195 UTC

[section ""data" . Data.Version.showVersion1_closure" {
     Data.Version.showVersion1_closure:
         const Data.Version.showVersion1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.showVersion1_entry() //  [R1]
         { info_tbl: [(cc5SB,
                       label: Data.Version.showVersion1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5SB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5SC; else goto cc5SD;
       cc5SC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5SD: // global
           (_cc5Sy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc5Sy::I64 == 0) goto cc5SA; else goto cc5Sz;
       cc5SA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc5Sz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc5Sy::I64;
           R2 = Data.Version.showVersion2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.097135227 UTC

[section ""data" . Data.Version.showVersion_go_closure" {
     Data.Version.showVersion_go_closure:
         const Data.Version.showVersion_go_info;
 },
 sat_sc5vG_entry() //  [R1]
         { info_tbl: [(cc5T0,
                       label: sat_sc5vG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5T0: // global
           R2 = P64[R1 + 16];
           call Data.Version.showVersion_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.showVersion_go_entry() //  [R2]
         { info_tbl: [(cc5T7,
                       label: Data.Version.showVersion_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5T7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc5T8; else goto cc5T9;
       cc5T8: // global
           R2 = R2;
           R1 = Data.Version.showVersion_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5T9: // global
           I64[Sp - 8] = block_cc5SQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc5Tg; else goto cc5SR;
       uc5Tg: // global
           call _cc5SQ(R1) args: 0, res: 0, upd: 0;
       cc5SR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5SQ() //  [R1]
         { info_tbl: [(cc5SQ,
                       label: block_cc5SQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5SQ: // global
           if (R1 & 7 == 1) goto cc5T4; else goto cc5T5;
       cc5T4: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc5T5: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc5Tf; else goto cc5Te;
       cc5Tf: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5Te: // global
           _sc5vD::P64 = P64[R1 + 6];
           _sc5vE::P64 = P64[R1 + 14];
           I64[Hp - 40] = sat_sc5vG_info;
           P64[Hp - 24] = _sc5vE::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = f2_rc3YB_closure+1;
           P64[Hp] = _sc5vD::P64;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.106518252 UTC

[section ""data" . Data.Version.$wshowVersion_closure" {
     Data.Version.$wshowVersion_closure:
         const Data.Version.$wshowVersion_info;
         const 0;
 },
 arg_sc5vJ_entry() //  [R1]
         { info_tbl: [(cc5TJ,
                       label: arg_sc5vJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5TJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5TK; else goto cc5TL;
       cc5TK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5TL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Version.showVersion_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc5vS_entry() //  [R1]
         { info_tbl: [(cc5U6,
                       label: sat_sc5vS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5U6: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_sc5vN_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go_sc5vN_entry() //  [R1, R2]
         { info_tbl: [(cc5Ud,
                       label: go_sc5vN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Ud: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc5Ue; else goto cc5Uf;
       cc5Ue: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5Uf: // global
           I64[Sp - 24] = block_cc5TW_info;
           _sc5vN::P64 = R1;
           _sc5vJ::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sc5vJ::P64;
           P64[Sp - 8] = _sc5vN::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uc5Ul; else goto cc5TX;
       uc5Ul: // global
           call _cc5TW(R1) args: 0, res: 0, upd: 0;
       cc5TX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5TW() //  [R1]
         { info_tbl: [(cc5TW,
                       label: block_cc5TW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5TW: // global
           if (R1 & 7 == 1) goto cc5Ua; else goto cc5Ub;
       cc5Ua: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc5Ub: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc5Uk; else goto cc5Uj;
       cc5Uk: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5Uj: // global
           _sc5vQ::P64 = P64[R1 + 6];
           _sc5vR::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_sc5vS_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sc5vR::P64;
           R3 = Hp - 24;
           R2 = _sc5vQ::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc5vT_entry() //  [R1]
         { info_tbl: [(cc5Uq,
                       label: sat_sc5vT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Uq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5Ur; else goto cc5Us;
       cc5Ur: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5Us: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Version.showVersion1_closure;
           Sp = Sp - 16;
           call Data.OldList.prependToAll_entry(R3,
                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Version.$wshowVersion_entry() //  [R2, R3]
         { info_tbl: [(cc5Ux,
                       label: Data.Version.$wshowVersion_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Ux: // global
           _sc5vI::P64 = R3;
           _sc5vH::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cc5Uy; else goto cc5Uz;
       cc5Uz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5UB; else goto cc5UA;
       cc5UB: // global
           HpAlloc = 24;
           goto cc5Uy;
       cc5Uy: // global
           R3 = _sc5vI::P64;
           R2 = _sc5vH::P64;
           R1 = Data.Version.$wshowVersion_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc5UA: // global
           I64[Hp - 16] = arg_sc5vJ_info;
           P64[Hp] = _sc5vI::P64;
           I64[Sp - 16] = block_cc5TM_info;
           R3 = _sc5vH::P64;
           R2 = GHC.Show.$fShowInt_$cshow_closure+1;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5TM() //  [R1]
         { info_tbl: [(cc5TM,
                       label: block_cc5TM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5TM: // global
           _cc5TF::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cc5Uu; else goto cc5Uv;
       cc5Uu: // global
           R1 = _cc5TF::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc5Uv: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc5UH; else goto cc5UG;
       cc5UH: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5UG: // global
           _sc5vL::P64 = P64[R1 + 6];
           _sc5vM::P64 = P64[R1 + 14];
           I64[Hp - 56] = go_sc5vN_info;
           P64[Hp - 48] = _cc5TF::P64;
           I64[Hp - 40] = sat_sc5vT_info;
           P64[Hp - 24] = _sc5vM::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sc5vL::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 14;
           R1 = Hp - 55;
           Sp = Sp + 16;
           call go_sc5vN_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.12262824 UTC

[section ""data" . Data.Version.showVersion_closure" {
     Data.Version.showVersion_closure:
         const Data.Version.showVersion_info;
         const 0;
 },
 Data.Version.showVersion_entry() //  [R2]
         { info_tbl: [(cc5VB,
                       label: Data.Version.showVersion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5VB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc5VC; else goto cc5VD;
       cc5VC: // global
           R2 = R2;
           R1 = Data.Version.showVersion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5VD: // global
           I64[Sp - 8] = block_cc5Vy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc5VH; else goto cc5Vz;
       uc5VH: // global
           call _cc5Vy(R1) args: 0, res: 0, upd: 0;
       cc5Vz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc5Vy() //  [R1]
         { info_tbl: [(cc5Vy,
                       label: block_cc5Vy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Vy: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Version.$wshowVersion_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.128009975 UTC

[section ""data" . Data.Version.$fReadVersion18_closure" {
     Data.Version.$fReadVersion18_closure:
         const Data.Version.$fReadVersion18_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion18_entry() //  [R1]
         { info_tbl: [(cc5VY,
                       label: Data.Version.$fReadVersion18_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5VY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5VZ; else goto cc5W0;
       cc5VZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5W0: // global
           (_cc5VV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc5VV::I64 == 0) goto cc5VX; else goto cc5VW;
       cc5VX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc5VW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc5VV::I64;
           R2 = Data.Version.$fReadVersion19_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.132002118 UTC

[section ""data" . Data.Version.$fReadVersion_lexeme1_closure" {
     Data.Version.$fReadVersion_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Version.$fReadVersion18_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.134158781 UTC

[section ""cstring" . Data.Version.$fReadVersion17_bytes" {
     Data.Version.$fReadVersion17_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.136632501 UTC

[section ""data" . Data.Version.$fReadVersion16_closure" {
     Data.Version.$fReadVersion16_closure:
         const Data.Version.$fReadVersion16_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion16_entry() //  [R1]
         { info_tbl: [(cc5Wh,
                       label: Data.Version.$fReadVersion16_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Wh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5Wi; else goto cc5Wj;
       cc5Wi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5Wj: // global
           (_cc5We::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc5We::I64 == 0) goto cc5Wg; else goto cc5Wf;
       cc5Wg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc5Wf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc5We::I64;
           R2 = Data.Version.$fReadVersion17_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.140560581 UTC

[section ""data" . Data.Version.$fReadVersion_lexeme_closure" {
     Data.Version.$fReadVersion_lexeme_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Version.$fReadVersion16_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.142272356 UTC

[section ""cstring" . Data.Version.$fReadVersion15_bytes" {
     Data.Version.$fReadVersion15_bytes:
         I8[] [118,101,114,115,105,111,110,66,114,97,110,99,104]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.144049862 UTC

[section ""data" . Data.Version.$fReadVersion14_closure" {
     Data.Version.$fReadVersion14_closure:
         const Data.Version.$fReadVersion14_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion14_entry() //  [R1]
         { info_tbl: [(cc5WA,
                       label: Data.Version.$fReadVersion14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5WA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5WB; else goto cc5WC;
       cc5WB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5WC: // global
           (_cc5Wx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc5Wx::I64 == 0) goto cc5Wz; else goto cc5Wy;
       cc5Wz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc5Wy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc5Wx::I64;
           R2 = Data.Version.$fReadVersion15_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.14840515 UTC

[section ""data" . Data.Version.$fReadVersion13_closure" {
     Data.Version.$fReadVersion13_closure:
         const Data.Version.$fReadVersion13_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion13_entry() //  [R1]
         { info_tbl: [(cc5WR,
                       label: Data.Version.$fReadVersion13_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5WR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5WS; else goto cc5WT;
       cc5WS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5WT: // global
           (_cc5WO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc5WO::I64 == 0) goto cc5WQ; else goto cc5WP;
       cc5WQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc5WP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc5WO::I64;
           R2 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R1 = GHC.Read.$fReadInt_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.152466211 UTC

[section ""data" . Data.Version.$fReadVersion12_closure" {
     Data.Version.$fReadVersion12_closure:
         const Data.Version.$fReadVersion12_info;
         const 0;
 },
 Data.Version.$fReadVersion12_entry() //  []
         { info_tbl: [(cc5X6,
                       label: Data.Version.$fReadVersion12_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5X6: // global
           R1 = Data.Version.$fReadVersion13_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.155942747 UTC

[section ""data" . Data.Version.$fReadVersion_n_closure" {
     Data.Version.$fReadVersion_n_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.157732007 UTC

[section ""cstring" . Data.Version.$fReadVersion11_bytes" {
     Data.Version.$fReadVersion11_bytes:
         I8[] [44]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.159609279 UTC

[section ""data" . Data.Version.$fReadVersion10_closure" {
     Data.Version.$fReadVersion10_closure:
         const Data.Version.$fReadVersion10_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion10_entry() //  [R1]
         { info_tbl: [(cc5Xl,
                       label: Data.Version.$fReadVersion10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Xl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5Xm; else goto cc5Xn;
       cc5Xm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5Xn: // global
           (_cc5Xi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc5Xi::I64 == 0) goto cc5Xk; else goto cc5Xj;
       cc5Xk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc5Xj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc5Xi::I64;
           R2 = Data.Version.$fReadVersion11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.163484918 UTC

[section ""data" . Data.Version.$fReadVersion9_closure" {
     Data.Version.$fReadVersion9_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Version.$fReadVersion10_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.165146279 UTC

[section ""cstring" . Data.Version.$fReadVersion8_bytes" {
     Data.Version.$fReadVersion8_bytes:
         I8[] [118,101,114,115,105,111,110,84,97,103,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.167688788 UTC

[section ""data" . Data.Version.$fReadVersion7_closure" {
     Data.Version.$fReadVersion7_closure:
         const Data.Version.$fReadVersion7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion7_entry() //  [R1]
         { info_tbl: [(cc5XE,
                       label: Data.Version.$fReadVersion7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5XE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5XF; else goto cc5XG;
       cc5XF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5XG: // global
           (_cc5XB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc5XB::I64 == 0) goto cc5XD; else goto cc5XC;
       cc5XD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc5XC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc5XB::I64;
           R2 = Data.Version.$fReadVersion8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.1716013 UTC

[section ""data" . Data.Version.$fReadVersion6_closure" {
     Data.Version.$fReadVersion6_closure:
         const Data.Version.$fReadVersion6_info;
         const 0;
 },
 Data.Version.$fReadVersion6_entry() //  []
         { info_tbl: [(cc5XT,
                       label: Data.Version.$fReadVersion6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5XT: // global
           R2 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R1 = GHC.Read.$fRead[]_$s$creadListPrec1_closure;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.175051594 UTC

[section ""data" . Data.Version.$fReadVersion4_closure" {
     Data.Version.$fReadVersion4_closure:
         const Data.Version.$fReadVersion4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion4_entry() //  [R1]
         { info_tbl: [(cc5Y6,
                       label: Data.Version.$fReadVersion4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Y6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc5Y7; else goto cc5Y8;
       cc5Y7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc5Y8: // global
           (_cc5Y3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc5Y3::I64 == 0) goto cc5Y5; else goto cc5Y4;
       cc5Y5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc5Y4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc5Y3::I64;
           R2 = Data.Version.$fReadVersion5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.179211726 UTC

[section ""data" . Data.Version.$fReadVersion3_closure" {
     Data.Version.$fReadVersion3_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Version.$fReadVersion4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.18258775 UTC

[section ""data" . Data.Version.$w$creadPrec_closure" {
     Data.Version.$w$creadPrec_closure:
         const Data.Version.$w$creadPrec_info;
         const 0;
 },
 sat_sc5wb_entry() //  [R1, R2]
         { info_tbl: [(cc5YV,
                       label: sat_sc5wb_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5YV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5YZ; else goto cc5YY;
       cc5YZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5YY: // global
           _sc5w2::P64 = P64[R1 + 7];
           _sc5w6::P64 = P64[R1 + 15];
           _sc5w8::P64 = P64[R1 + 23];
           I64[Hp - 16] = Data.Version.Version_con_info;
           P64[Hp - 8] = _sc5w6::P64;
           P64[Hp] = _sc5w8::P64;
           R2 = Hp - 15;
           R1 = _sc5w2::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc5we_entry() //  [R1, R2]
         { info_tbl: [(cc5Z3,
                       label: sat_sc5we_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Z3: // global
           _sc5w8::P64 = R2;
           _sc5we::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cc5Z4; else goto cc5Z5;
       cc5Z5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc5Z7; else goto cc5Z6;
       cc5Z7: // global
           HpAlloc = 32;
           goto cc5Z4;
       cc5Z4: // global
           R2 = _sc5w8::P64;
           R1 = _sc5we::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5Z6: // global
           _sc5w2::P64 = P64[_sc5we::P64 + 7];
           _sc5w6::P64 = P64[_sc5we::P64 + 15];
           I64[Hp - 24] = sat_sc5wb_info;
           P64[Hp - 16] = _sc5w2::P64;
           P64[Hp - 8] = _sc5w6::P64;
           P64[Hp] = _sc5w8::P64;
           I64[Sp - 8] = block_cc5Z0_info;
           R3 = Hp - 23;
           R2 = Data.Version.$fReadVersion3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5Z0() //  [R1]
         { info_tbl: [(cc5Z0,
                       label: block_cc5Z0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Z0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5Za; else goto cc5Z9;
       cc5Za: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5Z9: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc5wf_entry() //  [R1, R2]
         { info_tbl: [(cc5Zb,
                       label: sat_sc5wf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Zb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5Zf; else goto cc5Ze;
       cc5Zf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5Ze: // global
           _sc5w2::P64 = P64[R1 + 7];
           _sc5w6::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_sc5we_info;
           P64[Hp - 8] = _sc5w2::P64;
           P64[Hp] = _sc5w6::P64;
           R5 = Hp - 15;
           R4 = Data.Version.$fReadVersion_n_closure+1;
           R3 = Data.Version.$fReadVersion6_closure+1;
           R2 = Data.Version.$fReadVersion7_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc5wi_entry() //  [R1, R2]
         { info_tbl: [(cc5Zj,
                       label: sat_sc5wi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Zj: // global
           _sc5w6::P64 = R2;
           _sc5wi::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cc5Zk; else goto cc5Zl;
       cc5Zl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc5Zn; else goto cc5Zm;
       cc5Zn: // global
           HpAlloc = 24;
           goto cc5Zk;
       cc5Zk: // global
           R2 = _sc5w6::P64;
           R1 = _sc5wi::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5Zm: // global
           _sc5w2::P64 = P64[_sc5wi::P64 + 7];
           I64[Hp - 16] = sat_sc5wf_info;
           P64[Hp - 8] = _sc5w2::P64;
           P64[Hp] = _sc5w6::P64;
           I64[Sp - 8] = block_cc5Zg_info;
           R3 = Hp - 15;
           R2 = Data.Version.$fReadVersion9_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5Zg() //  [R1]
         { info_tbl: [(cc5Zg,
                       label: block_cc5Zg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Zg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5Zq; else goto cc5Zp;
       cc5Zq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5Zp: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc5wj_entry() //  [R1, R2]
         { info_tbl: [(cc5Zr,
                       label: sat_sc5wj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Zr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5Zv; else goto cc5Zu;
       cc5Zv: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5Zu: // global
           _sc5w2::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_sc5wi_info;
           P64[Hp] = _sc5w2::P64;
           R5 = Hp - 7;
           R4 = Data.Version.$fReadVersion_n_closure+1;
           R3 = Data.Version.$fReadVersion12_closure+1;
           R2 = Data.Version.$fReadVersion14_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc5wm_entry() //  [R1, R2]
         { info_tbl: [(cc5Zz,
                       label: sat_sc5wm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Zz: // global
           _sc5w4::P64 = R2;
           _sc5wm::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cc5ZA; else goto cc5ZB;
       cc5ZB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5ZD; else goto cc5ZC;
       cc5ZD: // global
           HpAlloc = 16;
           goto cc5ZA;
       cc5ZA: // global
           R2 = _sc5w4::P64;
           R1 = _sc5wm::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc5ZC: // global
           _sc5w2::P64 = P64[_sc5wm::P64 + 7];
           I64[Hp - 8] = sat_sc5wj_info;
           P64[Hp] = _sc5w2::P64;
           I64[Sp - 8] = block_cc5Zw_info;
           R3 = Hp - 7;
           R2 = Data.Version.$fReadVersion_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5Zw() //  [R1]
         { info_tbl: [(cc5Zw,
                       label: block_cc5Zw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5Zw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5ZG; else goto cc5ZF;
       cc5ZG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5ZF: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.$w$creadPrec_entry() //  [R2, R3]
         { info_tbl: [(cc5ZK,
                       label: Data.Version.$w$creadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5ZK: // global
           _sc5w2::P64 = R3;
           _sc5w1::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cc5ZL; else goto cc5ZM;
       cc5ZM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5ZO; else goto cc5ZN;
       cc5ZO: // global
           HpAlloc = 16;
           goto cc5ZL;
       cc5ZL: // global
           R3 = _sc5w2::P64;
           R2 = _sc5w1::I64;
           R1 = Data.Version.$w$creadPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc5ZN: // global
           if (%MO_S_Gt_W64(_sc5w1::I64, 11)) goto cc5ZI; else goto cc5ZJ;
       cc5ZI: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc5ZJ: // global
           I64[Hp - 8] = sat_sc5wm_info;
           P64[Hp] = _sc5w2::P64;
           I64[Sp - 8] = block_cc5ZP_info;
           R3 = Hp - 7;
           R2 = Data.Version.$fReadVersion_lexeme1_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc5ZP() //  [R1]
         { info_tbl: [(cc5ZP,
                       label: block_cc5ZP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc5ZP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc5ZU; else goto cc5ZT;
       cc5ZU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc5ZT: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.208066971 UTC

[section ""data" . Data.Version.$fReadVersion2_closure" {
     Data.Version.$fReadVersion2_closure:
         const Data.Version.$fReadVersion2_info;
         const 0;
 },
 Data.Version.$fReadVersion2_entry() //  [R2, R3]
         { info_tbl: [(cc60Z,
                       label: Data.Version.$fReadVersion2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc60Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc610; else goto cc611;
       cc610: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.$fReadVersion2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc611: // global
           I64[Sp - 16] = block_cc60W_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc615; else goto cc60X;
       uc615: // global
           call _cc60W(R1) args: 0, res: 0, upd: 0;
       cc60X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc60W() //  [R1]
         { info_tbl: [(cc60W,
                       label: block_cc60W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc60W: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Data.Version.$w$creadPrec_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.213421848 UTC

[section ""data" . Data.Version.$fReadVersion1_closure" {
     Data.Version.$fReadVersion1_closure:
         const Data.Version.$fReadVersion1_info;
         const 0;
 },
 Data.Version.$fReadVersion1_entry() //  [R2, R3]
         { info_tbl: [(cc61k,
                       label: Data.Version.$fReadVersion1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc61k: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Version.$fReadVersion2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.217054644 UTC

[section ""data" . Data.Version.$fReadVersion_$creadsPrec_closure" {
     Data.Version.$fReadVersion_$creadsPrec_closure:
         const Data.Version.$fReadVersion_$creadsPrec_info;
         const 0;
 },
 sat_sc5wu_entry() //  [R1]
         { info_tbl: [(cc61z,
                       label: sat_sc5wu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc61z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc61A; else goto cc61B;
       cc61A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc61B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = Data.Version.$fReadVersion2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Version.$fReadVersion_$creadsPrec_entry() //  [R2]
         { info_tbl: [(cc61C,
                       label: Data.Version.$fReadVersion_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc61C: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc61G; else goto cc61F;
       cc61G: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Version.$fReadVersion_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc61F: // global
           I64[Hp - 16] = sat_sc5wu_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.223218027 UTC

[section ""data" . Data.Version.$fReadVersion_$creadListPrec_closure" {
     Data.Version.$fReadVersion_$creadListPrec_closure:
         const Data.Version.$fReadVersion_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion_$creadListPrec_entry() //  [R1]
         { info_tbl: [(cc61Z,
                       label: Data.Version.$fReadVersion_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc61Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc620; else goto cc621;
       cc620: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc621: // global
           (_cc61W::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc61W::I64 == 0) goto cc61Y; else goto cc61X;
       cc61Y: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc61X: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc61W::I64;
           R2 = Data.Version.$fReadVersion1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.22735276 UTC

[section ""data" . Data.Version.$fReadVersion20_closure" {
     Data.Version.$fReadVersion20_closure:
         const Data.Version.$fReadVersion20_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.$fReadVersion20_entry() //  [R1]
         { info_tbl: [(cc62g,
                       label: Data.Version.$fReadVersion20_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc62g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc62h; else goto cc62i;
       cc62h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc62i: // global
           (_cc62d::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc62d::I64 == 0) goto cc62f; else goto cc62e;
       cc62f: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc62e: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc62d::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = Data.Version.$fReadVersion_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.231738191 UTC

[section ""data" . Data.Version.$fReadVersion_$creadList_closure" {
     Data.Version.$fReadVersion_$creadList_closure:
         const Data.Version.$fReadVersion_$creadList_info;
         const 0;
 },
 Data.Version.$fReadVersion_$creadList_entry() //  [R2]
         { info_tbl: [(cc62w,
                       label: Data.Version.$fReadVersion_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc62w: // global
           R3 = R2;
           R2 = Data.Version.$fReadVersion20_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.235093604 UTC

[section ""data" . Data.Version.$fReadVersion_closure" {
     Data.Version.$fReadVersion_closure:
         const GHC.Read.C:Read_con_info;
         const Data.Version.$fReadVersion_$creadsPrec_closure+1;
         const Data.Version.$fReadVersion_$creadList_closure+1;
         const Data.Version.$fReadVersion1_closure+2;
         const Data.Version.$fReadVersion_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.237039672 UTC

[section ""data" . Data.Version.parseVersion5_closure" {
     Data.Version.parseVersion5_closure:
         const Data.Version.parseVersion5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.parseVersion5_entry() //  [R1]
         { info_tbl: [(cc62K,
                       label: Data.Version.parseVersion5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc62K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc62L; else goto cc62M;
       cc62L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc62M: // global
           (_cc62H::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc62H::I64 == 0) goto cc62J; else goto cc62I;
       cc62J: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc62I: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc62H::I64;
           R2 = Text.Read.readEither5_closure;
           Sp = Sp - 16;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.242079519 UTC

[section ""data" . Data.Version.parseVersion4_closure" {
     Data.Version.parseVersion4_closure:
         const Data.Version.parseVersion4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.parseVersion4_entry() //  [R1]
         { info_tbl: [(cc631,
                       label: Data.Version.parseVersion4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc631: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc632; else goto cc633;
       cc632: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc633: // global
           (_cc62Y::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc62Y::I64 == 0) goto cc630; else goto cc62Z;
       cc630: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc62Z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc62Y::I64;
           R2 = Text.Read.readEither2_closure;
           Sp = Sp - 16;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.246032469 UTC

[section ""data" . Data.Version.parseVersion6_closure" {
     Data.Version.parseVersion6_closure:
         const Data.Version.parseVersion6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Version.parseVersion6_entry() //  [R1]
         { info_tbl: [(cc63i,
                       label: Data.Version.parseVersion6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc63i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc63j; else goto cc63k;
       cc63j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc63k: // global
           (_cc63f::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc63f::I64 == 0) goto cc63h; else goto cc63g;
       cc63h: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc63g: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc63f::I64;
           R4 = Text.Read.readEither7_closure+1;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = GHC.Read.$fReadInt2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.$fReadInt_$sreadNumber_entry(R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.251219169 UTC

[section ""data" . Data.Version.$wp_closure" {
     Data.Version.$wp_closure:
         const Data.Version.$wp_info;
         const 0;
 },
 sat_sc5wM_entry() //  [R1]
         { info_tbl: [(cc648,
                       label: sat_sc5wM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc648: // global
           _sc5wM::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc649; else goto cc64a;
       cc64a: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc64c; else goto cc64b;
       cc64c: // global
           HpAlloc = 24;
           goto cc649;
       cc649: // global
           R1 = _sc5wM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc64b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc5wM::P64;
           _sc5wx::P64 = P64[_sc5wM::P64 + 16];
           _sc5wD::P64 = P64[_sc5wM::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sc5wx::P64;
           P64[Hp] = _sc5wD::P64;
           I64[Sp - 24] = block_cc646_info;
           R3 = Hp - 14;
           R2 = Data.Version.parseVersion6_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc646() //  [R1]
         { info_tbl: [(cc646,
                       label: block_cc646_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc646: // global
           I64[Sp] = block_cc64f_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc64f() //  [R1]
         { info_tbl: [(cc64f,
                       label: block_cc64f_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc64f: // global
           if (R1 & 7 == 1) goto cc64m; else goto cc64r;
       cc64m: // global
           R1 = Data.Version.parseVersion5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cc64r: // global
           I64[Sp - 8] = block_cc64p_info;
           _sc5wH::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sc5wH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc64F; else goto cc64s;
       uc64F: // global
           call _cc64p(R1) args: 0, res: 0, upd: 0;
       cc64s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc64p() //  [R1]
         { info_tbl: [(cc64p,
                       label: block_cc64p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc64p: // global
           if (R1 & 7 == 1) goto cc64y; else goto cc64C;
       cc64y: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cc64C: // global
           R1 = Data.Version.parseVersion4_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc5wN_entry() //  [R1, R2]
         { info_tbl: [(cc64G,
                       label: sat_sc5wN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc64G: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc64K; else goto cc64J;
       cc64K: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc64J: // global
           _sc5wv::P64 = P64[R1 + 7];
           _sc5wx::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sc5wM_info;
           P64[Hp - 8] = _sc5wx::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _sc5wv::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc5wQ_entry() //  [R1, R2]
         { info_tbl: [(cc64L,
                       label: sat_sc5wQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc64L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc64M; else goto cc64N;
       cc64M: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc64N: // global
           I64[Sp - 16] = block_cc63E_info;
           _sc5wv::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sc5wv::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc650; else goto cc63F;
       uc650: // global
           call _cc63E(R1) args: 0, res: 0, upd: 0;
       cc63F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc63E() //  [R1]
         { info_tbl: [(cc63E,
                       label: block_cc63E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc63E: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc64Q; else goto cc64P;
       cc64Q: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc64P: // global
           if (I64[R1 + 7] - 48 > 9) goto cc64S; else goto cc64W;
       cc64S: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc64W: // global
           I64[Hp - 16] = sat_sc5wN_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cc64T_info;
           R3 = Hp - 15;
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.$wmunch_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc64T() //  [R1]
         { info_tbl: [(cc64T,
                       label: block_cc64T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc64T: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc64Z; else goto cc64Y;
       cc64Z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc64Y: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.$wp_entry() //  [R2]
         { info_tbl: [(cc651,
                       label: Data.Version.$wp_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc651: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc655; else goto cc654;
       cc655: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Version.$wp_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc654: // global
           I64[Hp - 8] = sat_sc5wQ_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.271426603 UTC

[section ""data" . Data.Version.parseVersion3_closure" {
     Data.Version.parseVersion3_closure:
         const Data.Version.parseVersion3_info;
         const 0;
 },
 Data.Version.parseVersion3_entry() //  [R2]
         { info_tbl: [(cc66a,
                       label: Data.Version.parseVersion3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc66a: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc66b; else goto cc66c;
       cc66b: // global
           R2 = R2;
           R1 = Data.Version.parseVersion3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc66c: // global
           I64[Sp - 8] = block_cc667_info;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Version.$wp_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc667() //  [R1]
         { info_tbl: [(cc667,
                       label: block_cc667_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc667: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc66f; else goto cc66e;
       cc66f: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc66e: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.279772089 UTC

[section ""data" . Data.Version.parseVersion_m2_closure" {
     Data.Version.parseVersion_m2_closure:
         const Data.Version.parseVersion_m2_info;
         const 0;
 },
 lvl4_sc5wV_entry() //  [R1]
         { info_tbl: [(cc66C,
                       label: lvl4_sc5wV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc66C: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc66D; else goto cc66E;
       cc66D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc66E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cc66z_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Data.Version.$wp_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc66z() //  [R1]
         { info_tbl: [(cc66z,
                       label: block_cc66z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc66z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc66H; else goto cc66G;
       cc66H: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cc66G: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc5x2_entry() //  [R1, R2]
         { info_tbl: [(cc66Q,
                       label: sat_sc5x2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc66Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc66R; else goto cc66S;
       cc66R: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc66S: // global
           I64[Sp - 16] = block_cc66N_info;
           _sc5wV::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sc5wV::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc670; else goto cc66O;
       uc670: // global
           call _cc66N(R1) args: 0, res: 0, upd: 0;
       cc66O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc66N() //  [R1]
         { info_tbl: [(cc66N,
                       label: block_cc66N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc66N: // global
           if (I64[R1 + 7] == 46) goto cc66Z; else goto cc66Y;
       cc66Z: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cc66Y: // global
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.parseVersion_m2_entry() //  [R2]
         { info_tbl: [(cc672,
                       label: Data.Version.parseVersion_m2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc672: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc676; else goto cc675;
       cc676: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Version.parseVersion_m2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc675: // global
           I64[Hp - 48] = lvl4_sc5wV_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = sat_sc5x2_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.295570365 UTC

[section ""data" . Data.Version.$wlvl_closure" {
     Data.Version.$wlvl_closure:
         const Data.Version.$wlvl_info;
 },
 sat_sc5xf_entry() //  [R1, R2]
         { info_tbl: [(cc682,
                       label: sat_sc5xf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc682: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc686; else goto cc685;
       cc686: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc685: // global
           _sc5x3::P64 = P64[R1 + 7];
           _sc5xc::P64 = P64[R1 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sc5xc::P64;
           P64[Hp] = R2;
           R2 = Hp - 14;
           R1 = _sc5x3::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $www1_sc5x4_entry() //  [R1, R2]
         { info_tbl: [(cc687,
                       label: $www1_sc5x4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc687: // global
           _sc5x5::I64 = R2;
           _sc5x4::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cc688; else goto cc689;
       cc689: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cc68b; else goto cc68a;
       cc68b: // global
           HpAlloc = 40;
           goto cc688;
       cc688: // global
           R2 = _sc5x5::I64;
           R1 = _sc5x4::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc68a: // global
           _sc5x3::P64 = P64[_sc5x4::P64 + 7];
           (_sc5xa::I64) = call "ccall" arg hints:  [signed]  result hints:  [signed] u_iswalnum(_sc5x5::I64);
           if (_sc5xa::I64 == 0) goto cc68k; else goto cc68g;
       cc68k: // global
           Hp = Hp - 40;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc68g: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _sc5x5::I64;
           I64[Hp - 16] = sat_sc5xf_info;
           P64[Hp - 8] = _sc5x3::P64;
           P64[Hp] = Hp - 31;
           I64[Sp - 8] = block_cc68c_info;
           R3 = Hp - 15;
           R2 = GHC.Unicode.isAlphaNum_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wmunch_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc68c() //  [R1]
         { info_tbl: [(cc68c,
                       label: block_cc68c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc68c: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc68j; else goto cc68i;
       cc68j: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc68i: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 ww1_sc5xi_entry() //  [R1, R2]
         { info_tbl: [(cc68t,
                       label: ww1_sc5xi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc68t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc68u; else goto cc68v;
       cc68u: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc68v: // global
           I64[Sp - 16] = block_cc68q_info;
           _sc5x4::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sc5x4::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc68z; else goto cc68r;
       uc68z: // global
           call _cc68q(R1) args: 0, res: 0, upd: 0;
       cc68r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc68q() //  [R1]
         { info_tbl: [(cc68q,
                       label: block_cc68q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc68q: // global
           R2 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call $www1_sc5x4_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc5xr_entry() //  [R1, R2]
         { info_tbl: [(cc68J,
                       label: sat_sc5xr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc68J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc68K; else goto cc68L;
       cc68K: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc68L: // global
           I64[Sp - 16] = block_cc68G_info;
           _sc5xm::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sc5xm::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc68T; else goto cc68H;
       uc68T: // global
           call _cc68G(R1) args: 0, res: 0, upd: 0;
       cc68H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc68G() //  [R1]
         { info_tbl: [(cc68G,
                       label: block_cc68G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc68G: // global
           if (I64[R1 + 7] == 45) goto cc68S; else goto cc68R;
       cc68S: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc68R: // global
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.$wlvl_entry() //  [R2]
         { info_tbl: [(cc68U,
                       label: Data.Version.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc68U: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cc68Y; else goto cc68X;
       cc68Y: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = Data.Version.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc68X: // global
           I64[Hp - 56] = $www1_sc5x4_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = ww1_sc5xi_info;
           P64[Hp - 32] = Hp - 55;
           I64[Hp - 24] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp - 16] = Hp - 39;
           I64[Hp - 8] = sat_sc5xr_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.316303871 UTC

[section ""data" . Data.Version.parseVersion2_closure" {
     Data.Version.parseVersion2_closure:
         const Data.Version.parseVersion2_info;
 },
 Data.Version.parseVersion2_entry() //  [R2]
         { info_tbl: [(cc69X,
                       label: Data.Version.parseVersion2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc69X: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc69Y; else goto cc69Z;
       cc69Y: // global
           R2 = R2;
           R1 = Data.Version.parseVersion2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc69Z: // global
           I64[Sp - 8] = block_cc69U_info;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Version.$wlvl_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc69U() //  [R1]
         { info_tbl: [(cc69U,
                       label: block_cc69U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc69U: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc6a2; else goto cc6a1;
       cc6a2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc6a1: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.324022885 UTC

[section ""data" . Data.Version.$wparseVersion_closure" {
     Data.Version.$wparseVersion_closure:
         const Data.Version.$wparseVersion_info;
         const 0;
 },
 a2_sc5xE_entry() //  [R1]
         { info_tbl: [(cc6aR,
                       label: a2_sc5xE_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6aR: // global
           _sc5xE::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cc6aS; else goto cc6aT;
       cc6aT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc6aV; else goto cc6aU;
       cc6aV: // global
           HpAlloc = 24;
           goto cc6aS;
       cc6aS: // global
           R1 = _sc5xE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc6aU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sc5xE::P64;
           _sc5xx::P64 = P64[_sc5xE::P64 + 16];
           _sc5xD::P64 = P64[_sc5xE::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sc5xx::P64;
           P64[Hp] = _sc5xD::P64;
           I64[Sp - 24] = block_cc6aP_info;
           R3 = Hp - 14;
           R2 = Data.Version.parseVersion6_closure;
           Sp = Sp - 24;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc6aP() //  [R1]
         { info_tbl: [(cc6aP,
                       label: block_cc6aP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6aP: // global
           I64[Sp] = block_cc6aY_info;
           R2 = R1;
           call Text.Read.readEither8_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc6aY() //  [R1]
         { info_tbl: [(cc6aY,
                       label: block_cc6aY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6aY: // global
           if (R1 & 7 == 1) goto cc6b5; else goto cc6ba;
       cc6b5: // global
           R1 = Data.Version.parseVersion5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cc6ba: // global
           I64[Sp - 8] = block_cc6b8_info;
           _sc5xI::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sc5xI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc6bo; else goto cc6bb;
       uc6bo: // global
           call _cc6b8(R1) args: 0, res: 0, upd: 0;
       cc6bb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cc6b8() //  [R1]
         { info_tbl: [(cc6b8,
                       label: block_cc6b8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6b8: // global
           if (R1 & 7 == 1) goto cc6bh; else goto cc6bl;
       cc6bh: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cc6bl: // global
           R1 = Data.Version.parseVersion4_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc5xR_entry() //  [R1, R2]
         { info_tbl: [(cc6bB,
                       label: sat_sc5xR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6bB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc6bF; else goto cc6bE;
       cc6bF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc6bE: // global
           _sc5xv::P64 = P64[R1 + 7];
           _sc5xO::P64 = P64[R1 + 15];
           I64[Hp - 16] = Data.Version.Version_con_info;
           P64[Hp - 8] = _sc5xO::P64;
           P64[Hp] = R2;
           R2 = Hp - 15;
           R1 = _sc5xv::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc5xS_entry() //  [R1, R2]
         { info_tbl: [(cc6bG,
                       label: sat_sc5xS_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6bG: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cc6bK; else goto cc6bJ;
       cc6bK: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc6bJ: // global
           _sc5xv::P64 = P64[R1 + 7];
           _sc5xE::P64 = P64[R1 + 15];
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = _sc5xE::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sc5xR_info;
           P64[Hp - 8] = _sc5xv::P64;
           P64[Hp] = Hp - 38;
           R3 = Hp - 15;
           R2 = Data.Version.parseVersion2_closure+1;
           call Text.ParserCombinators.ReadP.endBy3_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc5xT_entry() //  [R1, R2]
         { info_tbl: [(cc6bL,
                       label: sat_sc5xT_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6bL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc6bP; else goto cc6bO;
       cc6bP: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc6bO: // global
           _sc5xv::P64 = P64[R1 + 7];
           _sc5xx::P64 = P64[R1 + 15];
           I64[Hp - 48] = a2_sc5xE_info;
           P64[Hp - 32] = _sc5xx::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sc5xS_info;
           P64[Hp - 8] = _sc5xv::P64;
           P64[Hp] = Hp - 48;
           R3 = Hp - 15;
           R2 = Data.Version.parseVersion_m2_closure+1;
           call Text.ParserCombinators.ReadP.endBy3_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc5xW_entry() //  [R1, R2]
         { info_tbl: [(cc6bQ,
                       label: sat_sc5xW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6bQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc6bR; else goto cc6bS;
       cc6bR: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc6bS: // global
           I64[Sp - 16] = block_cc6an_info;
           _sc5xv::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _sc5xv::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc6c5; else goto cc6ao;
       uc6c5: // global
           call _cc6an(R1) args: 0, res: 0, upd: 0;
       cc6ao: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc6an() //  [R1]
         { info_tbl: [(cc6an,
                       label: block_cc6an_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6an: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc6bV; else goto cc6bU;
       cc6bV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc6bU: // global
           if (I64[R1 + 7] - 48 > 9) goto cc6bX; else goto cc6c1;
       cc6bX: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc6c1: // global
           I64[Hp - 16] = sat_sc5xT_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp + 8] = block_cc6bY_info;
           R3 = Hp - 15;
           R2 = GHC.Unicode.isDigit_closure+1;
           Sp = Sp + 8;
           call Text.ParserCombinators.ReadP.$wmunch_entry(R3,
                                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc6bY() //  [R1]
         { info_tbl: [(cc6bY,
                       label: block_cc6bY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6bY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc6c4; else goto cc6c3;
       cc6c4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc6c3: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Version.$wparseVersion_entry() //  [R2]
         { info_tbl: [(cc6c6,
                       label: Data.Version.$wparseVersion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6c6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc6ca; else goto cc6c9;
       cc6ca: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Version.$wparseVersion_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc6c9: // global
           I64[Hp - 8] = sat_sc5xW_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.349587888 UTC

[section ""data" . Data.Version.parseVersion1_closure" {
     Data.Version.parseVersion1_closure:
         const Data.Version.parseVersion1_info;
         const 0;
 },
 Data.Version.parseVersion1_entry() //  [R2]
         { info_tbl: [(cc6dr,
                       label: Data.Version.parseVersion1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6dr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc6ds; else goto cc6dt;
       cc6ds: // global
           R2 = R2;
           R1 = Data.Version.parseVersion1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc6dt: // global
           I64[Sp - 8] = block_cc6do_info;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Version.$wparseVersion_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc6do() //  [R1]
         { info_tbl: [(cc6do,
                       label: block_cc6do_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6do: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc6dw; else goto cc6dv;
       cc6dw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc6dv: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Get_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.35558636 UTC

[section ""data" . Data.Version.parseVersion_closure" {
     Data.Version.parseVersion_closure:
         const Data.Version.parseVersion_info;
         const 0;
 },
 Data.Version.parseVersion_entry() //  [R2]
         { info_tbl: [(cc6dM,
                       label: Data.Version.parseVersion_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6dM: // global
           R2 = R2;
           call Data.Version.parseVersion1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.359602799 UTC

[section ""data" . Data.Version.Version_closure" {
     Data.Version.Version_closure:
         const Data.Version.Version_info;
 },
 Data.Version.Version_entry() //  [R2, R3]
         { info_tbl: [(cc6dY,
                       label: Data.Version.Version_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6dY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc6e2; else goto cc6e1;
       cc6e2: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Version.Version_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc6e1: // global
           I64[Hp - 16] = Data.Version.Version_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.363844082 UTC

[Data.Version.Version_con_entry() //  [R1]
         { info_tbl: [(cc6e9,
                       label: Data.Version.Version_con_info
                       rep:HeapRep 2 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,86,101,114,115,105,111,110,46,86,101,114,115,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc6e9: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:00.367898823 UTC

[section ""relreadonly" . Sc5NE_srt" {
     Sc5NE_srt:
         const GHC.Show.showLitString_closure;
         const GHC.Show.showCommaSpace1_closure;
         const f1_rc3Yy_closure;
         const Data.Version.$w$cshowsPrec_closure;
         const Data.Version.$fShowVersion_$cshowsPrec_closure;
         const Data.Version.$fShowVersion_$cshow_closure;
         const Data.Version.$fShowVersion1_closure;
         const Data.Version.showVersion1_closure;
         const Data.Version.$wshowVersion_closure;
         const Data.Version.showVersion_closure;
         const GHC.Read.$fReadInt_$creadListPrec_closure;
         const Data.Version.$fReadVersion13_closure;
         const GHC.Read.$fRead[]_$s$creadListPrec1_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Version.$fReadVersion3_closure;
         const GHC.Read.readField_closure;
         const Data.Version.$fReadVersion6_closure;
         const Data.Version.$fReadVersion7_closure;
         const Data.Version.$fReadVersion9_closure;
         const Data.Version.$fReadVersion12_closure;
         const Data.Version.$fReadVersion14_closure;
         const Data.Version.$fReadVersion_lexeme_closure;
         const Data.Version.$w$creadPrec_closure;
         const Data.Version.$fReadVersion_lexeme1_closure;
         const Data.Version.$fReadVersion2_closure;
         const GHC.Read.list3_closure;
         const Data.Version.$fReadVersion_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Version.$fReadVersion1_closure;
         const Data.Version.$fReadVersion_$creadListPrec_closure;
         const Data.Version.$fReadVersion20_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Text.Read.readEither5_closure;
         const Text.Read.readEither2_closure;
         const GHC.Read.$fReadInt2_closure;
         const GHC.Read.$fReadInt_$sreadNumber_closure;
         const Data.Version.parseVersion4_closure;
         const Data.Version.parseVersion5_closure;
         const Data.Version.parseVersion6_closure;
         const Data.Version.$wp_closure;
         const Data.Version.parseVersion3_closure;
         const Data.Version.parseVersion_m2_closure;
         const Text.ParserCombinators.ReadP.endBy3_closure;
         const Data.Version.$wparseVersion_closure;
         const Data.Version.parseVersion1_closure;
 }]

