
==================== Tidy Core ====================
2018-03-16 16:11:17.187089386 UTC

Result size of Tidy Core
  = {terms: 7,703, types: 15,135, coercions: 6,340, joins: 0/115}

-- RHS size: {terms: 21, types: 30, coercions: 7, joins: 0/1}
Data.Semigroup.$w$csconcat1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. Ord a => Min a -> [Min a] -> Min a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,A,C(C1(U)))><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 150 0}]
Data.Semigroup.$w$csconcat1
  = \ (@ a_sfBoZ)
      (w_sfBp0 :: Ord a_sfBoZ)
      (ww_sfBp4 :: Min a_sfBoZ)
      (ww1_sfBp5 :: [Min a_sfBoZ]) ->
      letrec {
        go_sfAiG [Occ=LoopBreaker]
          :: Min a_sfBoZ -> [Min a_sfBoZ] -> Min a_sfBoZ
        [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []]
        go_sfAiG
          = \ (b_i9ine :: Min a_sfBoZ) (ds1_i9inf :: [Min a_sfBoZ]) ->
              case ds1_i9inf of {
                [] -> b_i9ine;
                : c_i9inn cs_i9ino ->
                  (min
                     @ a_sfBoZ
                     w_sfBp0
                     (b_i9ine
                      `cast` (Data.Semigroup.N:Min[0] <a_sfBoZ>_R
                              :: (Min a_sfBoZ :: *) ~R# (a_sfBoZ :: *)))
                     ((go_sfAiG c_i9inn cs_i9ino)
                      `cast` (Data.Semigroup.N:Min[0] <a_sfBoZ>_R
                              :: (Min a_sfBoZ :: *) ~R# (a_sfBoZ :: *))))
                  `cast` (Sym (Data.Semigroup.N:Min[0] <a_sfBoZ>_R)
                          :: (a_sfBoZ :: *) ~R# (Min a_sfBoZ :: *))
              }; } in
      go_sfAiG ww_sfBp4 ww1_sfBp5

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
Data.Semigroup.$fSemigroupMin_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a. Ord a => GHC.Base.NonEmpty (Min a) -> Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,A,C(C1(U)))><S(LS),1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sfBoZ)
                 (w_sfBp0 [Occ=Once] :: Ord a_sfBoZ)
                 (w1_sfBp1 [Occ=Once!] :: GHC.Base.NonEmpty (Min a_sfBoZ)) ->
                 case w1_sfBp1 of
                 { GHC.Base.:| ww1_sfBp4 [Occ=Once] ww2_sfBp5 [Occ=Once] ->
                 Data.Semigroup.$w$csconcat1 @ a_sfBoZ w_sfBp0 ww1_sfBp4 ww2_sfBp5
                 }}]
Data.Semigroup.$fSemigroupMin_$csconcat
  = \ (@ a_sfBoZ)
      (w_sfBp0 :: Ord a_sfBoZ)
      (w1_sfBp1 :: GHC.Base.NonEmpty (Min a_sfBoZ)) ->
      case w1_sfBp1 of { GHC.Base.:| ww1_sfBp4 ww2_sfBp5 ->
      Data.Semigroup.$w$csconcat1 @ a_sfBoZ w_sfBp0 ww1_sfBp4 ww2_sfBp5
      }

-- RHS size: {terms: 9, types: 12, coercions: 0, joins: 0/0}
lvl_rfC66 :: forall a b. Integral b => b -> Min a -> Min a
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []]
lvl_rfC66
  = \ (@ a_afzf5)
      (@ b_afzfx)
      ($dIntegral_afzfz :: Integral b_afzfx)
      (eta_B2 :: b_afzfx)
      (eta1_Xbk :: Min a_afzf5) ->
      stimesIdempotent
        @ b_afzfx @ (Min a_afzf5) $dIntegral_afzfz eta_B2 eta1_Xbk

-- RHS size: {terms: 8, types: 9, coercions: 11, joins: 0/0}
Data.Semigroup.$fSemigroupMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Ord a => Semigroup (Min a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,A,A,A,A,A,A,U)>m,
 Unf=DFun: \ (@ a_afwPb) (v_Xbg :: Ord a_afwPb) ->
       GHC.Base.C:Semigroup TYPE: Min a_afwPb
                            (min @ a_afwPb v_Xbg)
                            `cast` (Sym (Data.Semigroup.N:Min[0] <a_afwPb>_R)
                                    ->_R Sym (Data.Semigroup.N:Min[0] <a_afwPb>_R)
                                    ->_R Sym (Data.Semigroup.N:Min[0] <a_afwPb>_R)
                                    :: (a_afwPb -> a_afwPb -> a_afwPb :: *)
                                       ~R# (Min a_afwPb -> Min a_afwPb -> Min a_afwPb :: *))
                            Data.Semigroup.$fSemigroupMin_$csconcat @ a_afwPb v_Xbg
                            \ (@ b_afzfx) ($dIntegral_afzfz [Occ=Once] :: Integral b_afzfx) ->
                              stimesIdempotent @ b_afzfx @ (Min a_afwPb) $dIntegral_afzfz]
Data.Semigroup.$fSemigroupMin
  = \ (@ a_afzf5) ($dOrd_afzf6 :: Ord a_afzf5) ->
      GHC.Base.C:Semigroup
        @ (Min a_afzf5)
        ((min @ a_afzf5 $dOrd_afzf6)
         `cast` (Sym (Data.Semigroup.N:Min[0] <a_afzf5>_R)
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afzf5>_R)
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afzf5>_R)
                 :: (a_afzf5 -> a_afzf5 -> a_afzf5 :: *)
                    ~R# (Min a_afzf5 -> Min a_afzf5 -> Min a_afzf5 :: *)))
        (Data.Semigroup.$fSemigroupMin_$csconcat @ a_afzf5 $dOrd_afzf6)
        (lvl_rfC66 @ a_afzf5)

-- RHS size: {terms: 6, types: 8, coercions: 2, joins: 0/0}
Data.Semigroup.$fFunctorMin2 :: forall a b. (a -> b) -> Min a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afzeq)
                 (@ b_afzer)
                 (f_afwP8 [Occ=Once!] :: a_afzeq -> b_afzer)
                 (ds_dfzPg [Occ=Once] :: Min a_afzeq) ->
                 f_afwP8
                   (ds_dfzPg
                    `cast` (Data.Semigroup.N:Min[0] <a_afzeq>_R
                            :: (Min a_afzeq :: *) ~R# (a_afzeq :: *)))}]
Data.Semigroup.$fFunctorMin2
  = \ (@ a_afzeq)
      (@ b_afzer)
      (f_afwP8 :: a_afzeq -> b_afzer)
      (ds_dfzPg :: Min a_afzeq) ->
      f_afwP8
        (ds_dfzPg
         `cast` (Data.Semigroup.N:Min[0] <a_afzeq>_R
                 :: (Min a_afzeq :: *) ~R# (a_afzeq :: *)))

-- RHS size: {terms: 5, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fFunctorMin1 :: forall b a. a -> Min b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_afzey)
                 (@ a_afzex)
                 (x_X9DwR [Occ=Once] :: a_afzex)
                 _ [Occ=Dead] ->
                 x_X9DwR}]
Data.Semigroup.$fFunctorMin1
  = \ (@ b_afzey) (@ a_afzex) (x_X9DwR :: a_afzex) _ [Occ=Dead] ->
      x_X9DwR

-- RHS size: {terms: 5, types: 7, coercions: 29, joins: 0/0}
Data.Semigroup.$fFunctorMin [InlPrag=NOUSERINLINE CONLIKE]
  :: Functor Min
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Functor TYPE: Min
                          Data.Semigroup.$fFunctorMin2
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a -> b>_R ->_R <Min a>_R ->_R Sym (Data.Semigroup.N:Min[0] <b>_R)
                                  :: (forall a b. (a -> b) -> Min a -> b :: *)
                                     ~R# (forall a b. (a -> b) -> Min a -> Min b :: *))
                          (\ (@ a_afzex) (@ b_afzey) ->
                             Data.Semigroup.$fFunctorMin1 @ b_afzey @ a_afzex)
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a>_R ->_R <Min b>_R ->_R Sym (Data.Semigroup.N:Min[0] <a>_R)
                                  :: (forall a b. a -> Min b -> a :: *)
                                     ~R# (forall a b. a -> Min b -> Min a :: *))]
Data.Semigroup.$fFunctorMin
  = GHC.Base.C:Functor
      @ Min
      (Data.Semigroup.$fFunctorMin2
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a -> b>_R ->_R <Min a>_R ->_R Sym (Data.Semigroup.N:Min[0] <b>_R)
               :: (forall a b. (a -> b) -> Min a -> b :: *)
                  ~R# (forall a b. (a -> b) -> Min a -> Min b :: *)))
      ((\ (@ a_afzex) (@ b_afzey) ->
          Data.Semigroup.$fFunctorMin1 @ b_afzey @ a_afzex)
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a>_R ->_R <Min b>_R ->_R Sym (Data.Semigroup.N:Min[0] <a>_R)
               :: (forall a b. a -> Min b -> a :: *)
                  ~R# (forall a b. a -> Min b -> Min a :: *)))

-- RHS size: {terms: 7, types: 10, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableMin_$cfoldMap
  :: forall m a. Monoid m => (a -> m) -> Min a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ m_afzca)
                 (@ a_afzcb)
                 _ [Occ=Dead]
                 (f_afwP6 [Occ=Once!] :: a_afzcb -> m_afzca)
                 (ds_dfzPb [Occ=Once] :: Min a_afzcb) ->
                 f_afwP6
                   (ds_dfzPb
                    `cast` (Data.Semigroup.N:Min[0] <a_afzcb>_R
                            :: (Min a_afzcb :: *) ~R# (a_afzcb :: *)))}]
Data.Semigroup.$fFoldableMin_$cfoldMap
  = \ (@ m_afzca)
      (@ a_afzcb)
      _ [Occ=Dead]
      (f_afwP6 :: a_afzcb -> m_afzca)
      (ds_dfzPb :: Min a_afzcb) ->
      f_afwP6
        (ds_dfzPb
         `cast` (Data.Semigroup.N:Min[0] <a_afzcb>_R
                 :: (Min a_afzcb :: *) ~R# (a_afzcb :: *)))

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableMin4
  :: forall m. Monoid m => Min m -> Min m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ m_afzc0)
                 _ [Occ=Dead]
                 (ds_dfzPb [Occ=Once] :: Min m_afzc0) ->
                 ds_dfzPb}]
Data.Semigroup.$fFoldableMin4
  = \ (@ m_afzc0) _ [Occ=Dead] (ds_dfzPb :: Min m_afzc0) -> ds_dfzPb

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableMin1 :: forall a. Num a => Min a -> Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afze4)
                 _ [Occ=Dead]
                 (eta_Xbp [Occ=Once] :: Min a_afze4) ->
                 eta_Xbp}]
Data.Semigroup.$fFoldableMin1
  = \ (@ a_afze4) _ [Occ=Dead] (eta_Xbp :: Min a_afze4) -> eta_Xbp

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableMin2 :: forall a. Ord a => Min a -> Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afzdU)
                 _ [Occ=Dead]
                 (x_ifzGk [Occ=Once] :: Min a_afzdU) ->
                 x_ifzGk}]
Data.Semigroup.$fFoldableMin2
  = \ (@ a_afzdU) _ [Occ=Dead] (x_ifzGk :: Min a_afzdU) -> x_ifzGk

-- RHS size: {terms: 10, types: 10, coercions: 2, joins: 0/1}
Data.Semigroup.$fFoldableMin_$celem
  :: forall a. Eq a => a -> Min a -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afzdA)
                 ($dEq_afzdC [Occ=Once] :: Eq a_afzdA)
                 (eta_XbC [Occ=Once] :: a_afzdA) ->
                 let {
                   f_sfAiE [Occ=OnceL!] :: a_afzdA -> Bool
                   [LclId]
                   f_sfAiE = == @ a_afzdA $dEq_afzdC eta_XbC } in
                 \ (ds_dfzPb [Occ=Once] :: Min a_afzdA) ->
                   f_sfAiE
                     (ds_dfzPb
                      `cast` (Data.Semigroup.N:Min[0] <a_afzdA>_R
                              :: (Min a_afzdA :: *) ~R# (a_afzdA :: *)))}]
Data.Semigroup.$fFoldableMin_$celem
  = \ (@ a_afzdA) ($dEq_afzdC :: Eq a_afzdA) (eta_XbC :: a_afzdA) ->
      let {
        f_sfAiE [Dmd=<L,C(U)>] :: a_afzdA -> Bool
        [LclId]
        f_sfAiE = == @ a_afzdA $dEq_afzdC eta_XbC } in
      \ (ds_dfzPb :: Min a_afzdA) ->
        f_sfAiE
          (ds_dfzPb
           `cast` (Data.Semigroup.N:Min[0] <a_afzdA>_R
                   :: (Min a_afzdA :: *) ~R# (a_afzdA :: *)))

-- RHS size: {terms: 8, types: 10, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableMin_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Min a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_afzcC)
                 (@ a_afzcD)
                 (f_XfzQP [Occ=Once!] :: b_afzcC -> a_afzcD -> b_afzcC)
                 (z_XfzQR [Occ=Once] :: b_afzcC)
                 (t1_XfzQT [Occ=Once] :: Min a_afzcD) ->
                 f_XfzQP
                   z_XfzQR
                   (t1_XfzQT
                    `cast` (Data.Semigroup.N:Min[0] <a_afzcD>_R
                            :: (Min a_afzcD :: *) ~R# (a_afzcD :: *)))}]
Data.Semigroup.$fFoldableMin_$cfoldl
  = \ (@ b_afzcC)
      (@ a_afzcD)
      (f_XfzQP :: b_afzcC -> a_afzcD -> b_afzcC)
      (z_XfzQR :: b_afzcC)
      (t1_XfzQT :: Min a_afzcD) ->
      f_XfzQP
        z_XfzQR
        (t1_XfzQT
         `cast` (Data.Semigroup.N:Min[0] <a_afzcD>_R
                 :: (Min a_afzcD :: *) ~R# (a_afzcD :: *)))

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableMin3
  :: forall a. (a -> a -> a) -> Min a -> Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afzd4)
                 _ [Occ=Dead]
                 (xs_ifzFj [Occ=Once] :: Min a_afzd4) ->
                 xs_ifzFj}]
Data.Semigroup.$fFoldableMin3
  = \ (@ a_afzd4) _ [Occ=Dead] (xs_ifzFj :: Min a_afzd4) -> xs_ifzFj

-- RHS size: {terms: 8, types: 10, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableMin_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Min a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afzcs)
                 (@ b_afzct)
                 (f_ifzEu [Occ=Once!] :: a_afzcs -> b_afzct -> b_afzct)
                 (z0_ifzEv [Occ=Once] :: b_afzct)
                 (xs_ifzEw [Occ=Once] :: Min a_afzcs) ->
                 f_ifzEu
                   (xs_ifzEw
                    `cast` (Data.Semigroup.N:Min[0] <a_afzcs>_R
                            :: (Min a_afzcs :: *) ~R# (a_afzcs :: *)))
                   z0_ifzEv}]
Data.Semigroup.$fFoldableMin_$cfoldr'
  = \ (@ a_afzcs)
      (@ b_afzct)
      (f_ifzEu :: a_afzcs -> b_afzct -> b_afzct)
      (z0_ifzEv :: b_afzct)
      (xs_ifzEw :: Min a_afzcs) ->
      f_ifzEu
        (xs_ifzEw
         `cast` (Data.Semigroup.N:Min[0] <a_afzcs>_R
                 :: (Min a_afzcs :: *) ~R# (a_afzcs :: *)))
        z0_ifzEv

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableFirst3 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fFoldableFirst3 = GHC.Types.I# 1#

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableMin_$clength :: forall a. Min a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afzds) _ [Occ=Dead] ->
                 Data.Semigroup.$fFoldableFirst3}]
Data.Semigroup.$fFoldableMin_$clength
  = \ (@ a_afzds) _ [Occ=Dead] -> Data.Semigroup.$fFoldableFirst3

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableMin_$cnull :: forall a. Min a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afzdk) _ [Occ=Dead] -> GHC.Types.False}]
Data.Semigroup.$fFoldableMin_$cnull
  = \ (@ a_afzdk) _ [Occ=Dead] -> GHC.Types.False

-- RHS size: {terms: 5, types: 6, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableMin_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Min a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_afzdc) (t1_ifzFB [Occ=Once] :: Min a_afzdc) ->
                 GHC.Base.build
                   @ a_afzdc
                   (\ (@ b_ifzFC)
                      (c_ifzFD [Occ=Once!, OS=OneShot] :: a_afzdc -> b_ifzFC -> b_ifzFC)
                      (n_ifzFE [Occ=Once, OS=OneShot] :: b_ifzFC) ->
                      c_ifzFD
                        (t1_ifzFB
                         `cast` (Data.Semigroup.N:Min[0] <a_afzdc>_R
                                 :: (Min a_afzdc :: *) ~R# (a_afzdc :: *)))
                        n_ifzFE)}]
Data.Semigroup.$fFoldableMin_$ctoList
  = \ (@ a_afzdc) (eta_Xc0 :: Min a_afzdc) ->
      GHC.Types.:
        @ a_afzdc
        (eta_Xc0
         `cast` (Data.Semigroup.N:Min[0] <a_afzdc>_R
                 :: (Min a_afzdc :: *) ~R# (a_afzdc :: *)))
        (GHC.Types.[] @ a_afzdc)

-- RHS size: {terms: 17, types: 1, coercions: 79, joins: 0/0}
Data.Semigroup.$fFoldableMin [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable Min
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: Min
                                Data.Semigroup.$fFoldableMin4
                                `cast` (forall (m :: <*>_N).
                                        <Monoid m>_R
                                        ->_R <Min m>_R
                                        ->_R Data.Semigroup.N:Min[0] <m>_R
                                        :: (forall m. Monoid m => Min m -> Min m :: *)
                                           ~R# (forall m. Monoid m => Min m -> m :: *))
                                Data.Semigroup.$fFoldableMin_$cfoldMap
                                Data.Semigroup.$fFoldableMin_$cfoldr'
                                Data.Semigroup.$fFoldableMin_$cfoldr'
                                Data.Semigroup.$fFoldableMin_$cfoldl
                                Data.Semigroup.$fFoldableMin_$cfoldl
                                Data.Semigroup.$fFoldableMin3
                                `cast` (forall (a :: <*>_N).
                                        <a -> a -> a>_R
                                        ->_R <Min a>_R
                                        ->_R Data.Semigroup.N:Min[0] <a>_R
                                        :: (forall a. (a -> a -> a) -> Min a -> Min a :: *)
                                           ~R# (forall a. (a -> a -> a) -> Min a -> a :: *))
                                Data.Semigroup.$fFoldableMin3
                                `cast` (forall (a :: <*>_N).
                                        <a -> a -> a>_R
                                        ->_R <Min a>_R
                                        ->_R Data.Semigroup.N:Min[0] <a>_R
                                        :: (forall a. (a -> a -> a) -> Min a -> Min a :: *)
                                           ~R# (forall a. (a -> a -> a) -> Min a -> a :: *))
                                Data.Semigroup.$fFoldableMin_$ctoList
                                Data.Semigroup.$fFoldableMin_$cnull
                                Data.Semigroup.$fFoldableMin_$clength
                                Data.Semigroup.$fFoldableMin_$celem
                                Data.Semigroup.$fFoldableMin2
                                `cast` (forall (a :: <*>_N).
                                        <Ord a>_R ->_R <Min a>_R ->_R Data.Semigroup.N:Min[0] <a>_R
                                        :: (forall a. Ord a => Min a -> Min a :: *)
                                           ~R# (forall a. Ord a => Min a -> a :: *))
                                Data.Semigroup.$fFoldableMin2
                                `cast` (forall (a :: <*>_N).
                                        <Ord a>_R ->_R <Min a>_R ->_R Data.Semigroup.N:Min[0] <a>_R
                                        :: (forall a. Ord a => Min a -> Min a :: *)
                                           ~R# (forall a. Ord a => Min a -> a :: *))
                                Data.Semigroup.$fFoldableMin1
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R ->_R <Min a>_R ->_R Data.Semigroup.N:Min[0] <a>_R
                                        :: (forall a. Num a => Min a -> Min a :: *)
                                           ~R# (forall a. Num a => Min a -> a :: *))
                                Data.Semigroup.$fFoldableMin1
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R ->_R <Min a>_R ->_R Data.Semigroup.N:Min[0] <a>_R
                                        :: (forall a. Num a => Min a -> Min a :: *)
                                           ~R# (forall a. Num a => Min a -> a :: *))]
Data.Semigroup.$fFoldableMin
  = Data.Foldable.C:Foldable
      @ Min
      (Data.Semigroup.$fFoldableMin4
       `cast` (forall (m :: <*>_N).
               <Monoid m>_R ->_R <Min m>_R ->_R Data.Semigroup.N:Min[0] <m>_R
               :: (forall m. Monoid m => Min m -> Min m :: *)
                  ~R# (forall m. Monoid m => Min m -> m :: *)))
      Data.Semigroup.$fFoldableMin_$cfoldMap
      Data.Semigroup.$fFoldableMin_$cfoldr'
      Data.Semigroup.$fFoldableMin_$cfoldr'
      Data.Semigroup.$fFoldableMin_$cfoldl
      Data.Semigroup.$fFoldableMin_$cfoldl
      (Data.Semigroup.$fFoldableMin3
       `cast` (forall (a :: <*>_N).
               <a -> a -> a>_R ->_R <Min a>_R ->_R Data.Semigroup.N:Min[0] <a>_R
               :: (forall a. (a -> a -> a) -> Min a -> Min a :: *)
                  ~R# (forall a. (a -> a -> a) -> Min a -> a :: *)))
      (Data.Semigroup.$fFoldableMin3
       `cast` (forall (a :: <*>_N).
               <a -> a -> a>_R ->_R <Min a>_R ->_R Data.Semigroup.N:Min[0] <a>_R
               :: (forall a. (a -> a -> a) -> Min a -> Min a :: *)
                  ~R# (forall a. (a -> a -> a) -> Min a -> a :: *)))
      Data.Semigroup.$fFoldableMin_$ctoList
      Data.Semigroup.$fFoldableMin_$cnull
      Data.Semigroup.$fFoldableMin_$clength
      Data.Semigroup.$fFoldableMin_$celem
      (Data.Semigroup.$fFoldableMin2
       `cast` (forall (a :: <*>_N).
               <Ord a>_R ->_R <Min a>_R ->_R Data.Semigroup.N:Min[0] <a>_R
               :: (forall a. Ord a => Min a -> Min a :: *)
                  ~R# (forall a. Ord a => Min a -> a :: *)))
      (Data.Semigroup.$fFoldableMin2
       `cast` (forall (a :: <*>_N).
               <Ord a>_R ->_R <Min a>_R ->_R Data.Semigroup.N:Min[0] <a>_R
               :: (forall a. Ord a => Min a -> Min a :: *)
                  ~R# (forall a. Ord a => Min a -> a :: *)))
      (Data.Semigroup.$fFoldableMin1
       `cast` (forall (a :: <*>_N).
               <Num a>_R ->_R <Min a>_R ->_R Data.Semigroup.N:Min[0] <a>_R
               :: (forall a. Num a => Min a -> Min a :: *)
                  ~R# (forall a. Num a => Min a -> a :: *)))
      (Data.Semigroup.$fFoldableMin1
       `cast` (forall (a :: <*>_N).
               <Num a>_R ->_R <Min a>_R ->_R Data.Semigroup.N:Min[0] <a>_R
               :: (forall a. Num a => Min a -> Min a :: *)
                  ~R# (forall a. Num a => Min a -> a :: *)))

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
Data.Semigroup.$fApplicativeFirst3 :: forall b. b -> b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_afzba) (v_X5 [Occ=Once] :: b_afzba) -> v_X5}]
Data.Semigroup.$fApplicativeFirst3
  = \ (@ b_afzba) (v_X5 :: b_afzba) -> v_X5

-- RHS size: {terms: 12, types: 21, coercions: 7, joins: 0/0}
Data.Semigroup.$fTraversableMin_$ctraverse
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> Min a -> f (Min b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_afzb8 :: * -> *))
                 (@ a_afzb9)
                 (@ b_afzba)
                 ($dApplicative_afzbc [Occ=Once] :: Applicative f_afzb8)
                 (eta_B2 [Occ=Once!] :: a_afzb9 -> f_afzb8 b_afzba)
                 (eta1_Xc6 [Occ=Once] :: Min a_afzb9) ->
                 fmap
                   @ f_afzb8
                   (GHC.Base.$p1Applicative @ f_afzb8 $dApplicative_afzbc)
                   @ b_afzba
                   @ (Min b_afzba)
                   ((Data.Semigroup.$fApplicativeFirst3 @ b_afzba)
                    `cast` (<b_afzba>_R ->_R Sym (Data.Semigroup.N:Min[0] <b_afzba>_R)
                            :: (b_afzba -> b_afzba :: *) ~R# (b_afzba -> Min b_afzba :: *)))
                   (eta_B2
                      (eta1_Xc6
                       `cast` (Data.Semigroup.N:Min[0] <a_afzb9>_R
                               :: (Min a_afzb9 :: *) ~R# (a_afzb9 :: *))))}]
Data.Semigroup.$fTraversableMin_$ctraverse
  = \ (@ (f_afzb8 :: * -> *))
      (@ a_afzb9)
      (@ b_afzba)
      ($dApplicative_afzbc :: Applicative f_afzb8)
      (eta_B2 :: a_afzb9 -> f_afzb8 b_afzba)
      (eta1_Xc6 :: Min a_afzb9) ->
      fmap
        @ f_afzb8
        (GHC.Base.$p1Applicative @ f_afzb8 $dApplicative_afzbc)
        @ b_afzba
        @ (Min b_afzba)
        ((Data.Semigroup.$fApplicativeFirst3 @ b_afzba)
         `cast` (<b_afzba>_R ->_R Sym (Data.Semigroup.N:Min[0] <b_afzba>_R)
                 :: (b_afzba -> b_afzba :: *) ~R# (b_afzba -> Min b_afzba :: *)))
        (eta_B2
           (eta1_Xc6
            `cast` (Data.Semigroup.N:Min[0] <a_afzb9>_R
                    :: (Min a_afzb9 :: *) ~R# (a_afzb9 :: *))))

-- RHS size: {terms: 9, types: 17, coercions: 8, joins: 0/0}
Data.Semigroup.$fTraversableMin_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a. Applicative f => Min (f a) -> f (Min a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_afzbm :: * -> *))
                 (@ a_afzbn)
                 ($dApplicative_afzbp [Occ=Once] :: Applicative f_afzbm)
                 (eta_Xc5 [Occ=Once] :: Min (f_afzbm a_afzbn)) ->
                 fmap
                   @ f_afzbm
                   (GHC.Base.$p1Applicative @ f_afzbm $dApplicative_afzbp)
                   @ a_afzbn
                   @ (Min a_afzbn)
                   ((\ (v_X5 [Occ=Once] :: a_afzbn) -> v_X5)
                    `cast` (<a_afzbn>_R ->_R Sym (Data.Semigroup.N:Min[0] <a_afzbn>_R)
                            :: (a_afzbn -> a_afzbn :: *) ~R# (a_afzbn -> Min a_afzbn :: *)))
                   (eta_Xc5
                    `cast` (Data.Semigroup.N:Min[0] <f_afzbm a_afzbn>_R
                            :: (Min (f_afzbm a_afzbn) :: *) ~R# (f_afzbm a_afzbn :: *)))}]
Data.Semigroup.$fTraversableMin_$csequenceA
  = \ (@ (f_afzbm :: * -> *))
      (@ a_afzbn)
      ($dApplicative_afzbp :: Applicative f_afzbm)
      (eta_Xc5 :: Min (f_afzbm a_afzbn)) ->
      fmap
        @ f_afzbm
        (GHC.Base.$p1Applicative @ f_afzbm $dApplicative_afzbp)
        @ a_afzbn
        @ (Min a_afzbn)
        ((Data.Semigroup.$fApplicativeFirst3 @ a_afzbn)
         `cast` (<a_afzbn>_R ->_R Sym (Data.Semigroup.N:Min[0] <a_afzbn>_R)
                 :: (a_afzbn -> a_afzbn :: *) ~R# (a_afzbn -> Min a_afzbn :: *)))
        (eta_Xc5
         `cast` (Data.Semigroup.N:Min[0] <f_afzbm a_afzbn>_R
                 :: (Min (f_afzbm a_afzbn) :: *) ~R# (f_afzbm a_afzbn :: *)))

-- RHS size: {terms: 13, types: 22, coercions: 7, joins: 0/0}
Data.Semigroup.$fTraversableMin_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Min a -> m (Min b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_afzby :: * -> *))
                 (@ a_afzbz)
                 (@ b_afzbA)
                 ($dMonad_afzbC [Occ=OnceL] :: Monad m_afzby) ->
                 let {
                   $dApplicative_afzbc [Occ=OnceL] :: Applicative m_afzby
                   [LclId]
                   $dApplicative_afzbc
                     = GHC.Base.$p1Monad @ m_afzby $dMonad_afzbC } in
                 \ (eta_B2 [Occ=Once!] :: a_afzbz -> m_afzby b_afzbA)
                   (eta1_Xc6 [Occ=Once] :: Min a_afzbz) ->
                   fmap
                     @ m_afzby
                     (GHC.Base.$p1Applicative @ m_afzby $dApplicative_afzbc)
                     @ b_afzbA
                     @ (Min b_afzbA)
                     ((\ (v_X5 [Occ=Once] :: b_afzbA) -> v_X5)
                      `cast` (<b_afzbA>_R ->_R Sym (Data.Semigroup.N:Min[0] <b_afzbA>_R)
                              :: (b_afzbA -> b_afzbA :: *) ~R# (b_afzbA -> Min b_afzbA :: *)))
                     (eta_B2
                        (eta1_Xc6
                         `cast` (Data.Semigroup.N:Min[0] <a_afzbz>_R
                                 :: (Min a_afzbz :: *) ~R# (a_afzbz :: *))))}]
Data.Semigroup.$fTraversableMin_$cmapM
  = \ (@ (m_afzby :: * -> *))
      (@ a_afzbz)
      (@ b_afzbA)
      ($dMonad_afzbC :: Monad m_afzby)
      (eta_B2 :: a_afzbz -> m_afzby b_afzbA)
      (eta1_Xc8 :: Min a_afzbz) ->
      fmap
        @ m_afzby
        (GHC.Base.$p1Applicative
           @ m_afzby (GHC.Base.$p1Monad @ m_afzby $dMonad_afzbC))
        @ b_afzbA
        @ (Min b_afzbA)
        ((Data.Semigroup.$fApplicativeFirst3 @ b_afzbA)
         `cast` (<b_afzbA>_R ->_R Sym (Data.Semigroup.N:Min[0] <b_afzbA>_R)
                 :: (b_afzbA -> b_afzbA :: *) ~R# (b_afzbA -> Min b_afzbA :: *)))
        (eta_B2
           (eta1_Xc8
            `cast` (Data.Semigroup.N:Min[0] <a_afzbz>_R
                    :: (Min a_afzbz :: *) ~R# (a_afzbz :: *))))

-- RHS size: {terms: 10, types: 18, coercions: 8, joins: 0/0}
Data.Semigroup.$fTraversableMin_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a. Monad m => Min (m a) -> m (Min a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_afzbM :: * -> *))
                 (@ a_afzbN)
                 ($dMonad_afzbP [Occ=OnceL] :: Monad m_afzbM) ->
                 let {
                   $dApplicative_afzbp [Occ=OnceL] :: Applicative m_afzbM
                   [LclId]
                   $dApplicative_afzbp
                     = GHC.Base.$p1Monad @ m_afzbM $dMonad_afzbP } in
                 \ (eta_Xc5 [Occ=Once] :: Min (m_afzbM a_afzbN)) ->
                   fmap
                     @ m_afzbM
                     (GHC.Base.$p1Applicative @ m_afzbM $dApplicative_afzbp)
                     @ a_afzbN
                     @ (Min a_afzbN)
                     ((\ (v_X5 [Occ=Once] :: a_afzbN) -> v_X5)
                      `cast` (<a_afzbN>_R ->_R Sym (Data.Semigroup.N:Min[0] <a_afzbN>_R)
                              :: (a_afzbN -> a_afzbN :: *) ~R# (a_afzbN -> Min a_afzbN :: *)))
                     (eta_Xc5
                      `cast` (Data.Semigroup.N:Min[0] <m_afzbM a_afzbN>_R
                              :: (Min (m_afzbM a_afzbN) :: *) ~R# (m_afzbM a_afzbN :: *)))}]
Data.Semigroup.$fTraversableMin_$csequence
  = \ (@ (m_afzbM :: * -> *))
      (@ a_afzbN)
      ($dMonad_afzbP :: Monad m_afzbM)
      (eta_B1 :: Min (m_afzbM a_afzbN)) ->
      fmap
        @ m_afzbM
        (GHC.Base.$p1Applicative
           @ m_afzbM (GHC.Base.$p1Monad @ m_afzbM $dMonad_afzbP))
        @ a_afzbN
        @ (Min a_afzbN)
        ((Data.Semigroup.$fApplicativeFirst3 @ a_afzbN)
         `cast` (<a_afzbN>_R ->_R Sym (Data.Semigroup.N:Min[0] <a_afzbN>_R)
                 :: (a_afzbN -> a_afzbN :: *) ~R# (a_afzbN -> Min a_afzbN :: *)))
        (eta_B1
         `cast` (Data.Semigroup.N:Min[0] <m_afzbM a_afzbN>_R
                 :: (Min (m_afzbM a_afzbN) :: *) ~R# (m_afzbM a_afzbN :: *)))

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Data.Semigroup.$fTraversableMin [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable Min
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: Min
                                      Data.Semigroup.$fFunctorMin
                                      Data.Semigroup.$fFoldableMin
                                      Data.Semigroup.$fTraversableMin_$ctraverse
                                      Data.Semigroup.$fTraversableMin_$csequenceA
                                      Data.Semigroup.$fTraversableMin_$cmapM
                                      Data.Semigroup.$fTraversableMin_$csequence]
Data.Semigroup.$fTraversableMin
  = Data.Traversable.C:Traversable
      @ Min
      Data.Semigroup.$fFunctorMin
      Data.Semigroup.$fFoldableMin
      Data.Semigroup.$fTraversableMin_$ctraverse
      Data.Semigroup.$fTraversableMin_$csequenceA
      Data.Semigroup.$fTraversableMin_$cmapM
      Data.Semigroup.$fTraversableMin_$csequence

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
Data.Semigroup.$fApplicativeMin_$c<*
  :: forall a b. Min a -> Min b -> Min a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afzaS)
                 (@ b_afzaT)
                 (a1_afwP2 [Occ=Once] :: Min a_afzaS)
                 _ [Occ=Dead] ->
                 a1_afwP2}]
Data.Semigroup.$fApplicativeMin_$c<*
  = \ (@ a_afzaS)
      (@ b_afzaT)
      (a1_afwP2 :: Min a_afzaS)
      _ [Occ=Dead] ->
      a1_afwP2

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
Data.Semigroup.$fApplicativeMin_$c*>
  :: forall a b. Min a -> Min b -> Min b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afzaM)
                 (@ b_afzaN)
                 _ [Occ=Dead]
                 (a1_afwP3 [Occ=Once] :: Min b_afzaN) ->
                 a1_afwP3}]
Data.Semigroup.$fApplicativeMin_$c*>
  = \ (@ a_afzaM)
      (@ b_afzaN)
      _ [Occ=Dead]
      (a1_afwP3 :: Min b_afzaN) ->
      a1_afwP3

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
Data.Semigroup.$fApplicativeFirst1
  :: forall a b c. (a -> b -> c) -> a -> b -> c
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afzaB)
                 (@ b_afzaC)
                 (@ c_afzaD)
                 (v_B2 [Occ=Once] :: a_afzaB -> b_afzaC -> c_afzaD) ->
                 v_B2}]
Data.Semigroup.$fApplicativeFirst1
  = \ (@ a_afzaB)
      (@ b_afzaC)
      (@ c_afzaD)
      (v_B2 :: a_afzaB -> b_afzaC -> c_afzaD) ->
      v_B2

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fApplicativeMin1
  :: forall a b. Min (a -> b) -> Min (a -> b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afzar)
                 (@ b_afzas)
                 (v_XcA [Occ=Once] :: Min (a_afzar -> b_afzas)) ->
                 v_XcA}]
Data.Semigroup.$fApplicativeMin1
  = \ (@ a_afzar) (@ b_afzas) (v_XcA :: Min (a_afzar -> b_afzas)) ->
      v_XcA

-- RHS size: {terms: 7, types: 1, coercions: 50, joins: 0/0}
Data.Semigroup.$fApplicativeMin [InlPrag=NOUSERINLINE CONLIKE]
  :: Applicative Min
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Applicative TYPE: Min
                              Data.Semigroup.$fFunctorMin
                              Data.Semigroup.$fApplicativeFirst3
                              `cast` (forall (a :: <*>_N).
                                      <a>_R ->_R Sym (Data.Semigroup.N:Min[0] <a>_R)
                                      :: (forall a. a -> a :: *) ~R# (forall a. a -> Min a :: *))
                              Data.Semigroup.$fApplicativeMin1
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <Min (a -> b)>_R
                                      ->_R Data.Semigroup.N:Min[0]
                                               (Sym (Data.Semigroup.N:Min[0] <a>_R)
                                                ->_R Sym (Data.Semigroup.N:Min[0] <b>_R))
                                      :: (forall a b. Min (a -> b) -> Min (a -> b) :: *)
                                         ~R# (forall a b. Min (a -> b) -> Min a -> Min b :: *))
                              Data.Semigroup.$fApplicativeFirst1
                              `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                                      <a -> b -> c>_R
                                      ->_R Sym (Data.Semigroup.N:Min[0] <a>_R)
                                      ->_R Sym (Data.Semigroup.N:Min[0] <b>_R)
                                      ->_R Sym (Data.Semigroup.N:Min[0] <c>_R)
                                      :: (forall a b c. (a -> b -> c) -> a -> b -> c :: *)
                                         ~R# (forall a b c.
                                              (a -> b -> c) -> Min a -> Min b -> Min c :: *))
                              Data.Semigroup.$fApplicativeMin_$c*>
                              Data.Semigroup.$fApplicativeMin_$c<*]
Data.Semigroup.$fApplicativeMin
  = GHC.Base.C:Applicative
      @ Min
      Data.Semigroup.$fFunctorMin
      (Data.Semigroup.$fApplicativeFirst3
       `cast` (forall (a :: <*>_N).
               <a>_R ->_R Sym (Data.Semigroup.N:Min[0] <a>_R)
               :: (forall a. a -> a :: *) ~R# (forall a. a -> Min a :: *)))
      (Data.Semigroup.$fApplicativeMin1
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <Min (a -> b)>_R
               ->_R Data.Semigroup.N:Min[0]
                        (Sym (Data.Semigroup.N:Min[0] <a>_R)
                         ->_R Sym (Data.Semigroup.N:Min[0] <b>_R))
               :: (forall a b. Min (a -> b) -> Min (a -> b) :: *)
                  ~R# (forall a b. Min (a -> b) -> Min a -> Min b :: *)))
      (Data.Semigroup.$fApplicativeFirst1
       `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
               <a -> b -> c>_R
               ->_R Sym (Data.Semigroup.N:Min[0] <a>_R)
               ->_R Sym (Data.Semigroup.N:Min[0] <b>_R)
               ->_R Sym (Data.Semigroup.N:Min[0] <c>_R)
               :: (forall a b c. (a -> b -> c) -> a -> b -> c :: *)
                  ~R# (forall a b c. (a -> b -> c) -> Min a -> Min b -> Min c :: *)))
      Data.Semigroup.$fApplicativeMin_$c*>
      Data.Semigroup.$fApplicativeMin_$c<*

-- RHS size: {terms: 6, types: 9, coercions: 2, joins: 0/0}
Data.Semigroup.$fMonadMin_$c>>=
  :: forall a b. Min a -> (a -> Min b) -> Min b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afz9I)
                 (@ b_afz9J)
                 (ds_dfzOS [Occ=Once] :: Min a_afz9I)
                 (f_afwP1 [Occ=Once!] :: a_afz9I -> Min b_afz9J) ->
                 f_afwP1
                   (ds_dfzOS
                    `cast` (Data.Semigroup.N:Min[0] <a_afz9I>_R
                            :: (Min a_afz9I :: *) ~R# (a_afz9I :: *)))}]
Data.Semigroup.$fMonadMin_$c>>=
  = \ (@ a_afz9I)
      (@ b_afz9J)
      (ds_dfzOS :: Min a_afz9I)
      (f_afwP1 :: a_afz9I -> Min b_afz9J) ->
      f_afwP1
        (ds_dfzOS
         `cast` (Data.Semigroup.N:Min[0] <a_afz9I>_R
                 :: (Min a_afz9I :: *) ~R# (a_afz9I :: *)))

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
lvl1_rfC67 :: forall a. [Char] -> Min a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
lvl1_rfC67
  = \ (@ a_afza7) (eta_B1 :: [Char]) ->
      errorWithoutStackTrace
        @ 'GHC.Types.LiftedRep @ (Min a_afza7) eta_B1

-- RHS size: {terms: 6, types: 1, coercions: 8, joins: 0/0}
Data.Semigroup.$fMonadMin [InlPrag=NOUSERINLINE CONLIKE]
  :: Monad Min
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Monad TYPE: Min
                        Data.Semigroup.$fApplicativeMin
                        Data.Semigroup.$fMonadMin_$c>>=
                        Data.Semigroup.$fApplicativeMin_$c*>
                        Data.Semigroup.$fApplicativeFirst3
                        `cast` (forall (a :: <*>_N).
                                <a>_R ->_R Sym (Data.Semigroup.N:Min[0] <a>_R)
                                :: (forall a. a -> a :: *) ~R# (forall a. a -> Min a :: *))
                        \ (@ a_afza7) ->
                          errorWithoutStackTrace @ 'GHC.Types.LiftedRep @ (Min a_afza7)]
Data.Semigroup.$fMonadMin
  = GHC.Base.C:Monad
      @ Min
      Data.Semigroup.$fApplicativeMin
      Data.Semigroup.$fMonadMin_$c>>=
      Data.Semigroup.$fApplicativeMin_$c*>
      (Data.Semigroup.$fApplicativeFirst3
       `cast` (forall (a :: <*>_N).
               <a>_R ->_R Sym (Data.Semigroup.N:Min[0] <a>_R)
               :: (forall a. a -> a :: *) ~R# (forall a. a -> Min a :: *)))
      lvl1_rfC67

-- RHS size: {terms: 37, types: 32, coercions: 68, joins: 0/0}
Data.Semigroup.$fNumMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Num a => Num (Min a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U))>m,
 Unf=DFun: \ (@ a_afwOP) (v_Xdl :: Num a_afwOP) ->
       GHC.Num.C:Num TYPE: Min a_afwOP
                     (\ (ds_XfA1F [Occ=Once] :: Min a_afwOP)
                        (ds1_XfA1H [Occ=Once] :: Min a_afwOP) ->
                        + @ a_afwOP
                          v_Xdl
                          (ds_XfA1F
                           `cast` (Data.Semigroup.N:Min[0] <a_afwOP>_R
                                   :: (Min a_afwOP :: *) ~R# (a_afwOP :: *)))
                          (ds1_XfA1H
                           `cast` (Data.Semigroup.N:Min[0] <a_afwOP>_R
                                   :: (Min a_afwOP :: *) ~R# (a_afwOP :: *))))
                     `cast` (<Min a_afwOP>_R
                             ->_R <Min a_afwOP>_R
                             ->_R Sym (Data.Semigroup.N:Min[0] <a_afwOP>_R)
                             :: (Min a_afwOP -> Min a_afwOP -> a_afwOP :: *)
                                ~R# (Min a_afwOP -> Min a_afwOP -> Min a_afwOP :: *))
                     (\ (ds_XfA1M [Occ=Once] :: Min a_afwOP)
                        (ds1_XfA1O [Occ=Once] :: Min a_afwOP) ->
                        - @ a_afwOP
                          v_Xdl
                          (ds_XfA1M
                           `cast` (Data.Semigroup.N:Min[0] <a_afwOP>_R
                                   :: (Min a_afwOP :: *) ~R# (a_afwOP :: *)))
                          (ds1_XfA1O
                           `cast` (Data.Semigroup.N:Min[0] <a_afwOP>_R
                                   :: (Min a_afwOP :: *) ~R# (a_afwOP :: *))))
                     `cast` (<Min a_afwOP>_R
                             ->_R <Min a_afwOP>_R
                             ->_R Sym (Data.Semigroup.N:Min[0] <a_afwOP>_R)
                             :: (Min a_afwOP -> Min a_afwOP -> a_afwOP :: *)
                                ~R# (Min a_afwOP -> Min a_afwOP -> Min a_afwOP :: *))
                     (\ (ds_XfA1T [Occ=Once] :: Min a_afwOP)
                        (ds1_XfA1V [Occ=Once] :: Min a_afwOP) ->
                        * @ a_afwOP
                          v_Xdl
                          (ds_XfA1T
                           `cast` (Data.Semigroup.N:Min[0] <a_afwOP>_R
                                   :: (Min a_afwOP :: *) ~R# (a_afwOP :: *)))
                          (ds1_XfA1V
                           `cast` (Data.Semigroup.N:Min[0] <a_afwOP>_R
                                   :: (Min a_afwOP :: *) ~R# (a_afwOP :: *))))
                     `cast` (<Min a_afwOP>_R
                             ->_R <Min a_afwOP>_R
                             ->_R Sym (Data.Semigroup.N:Min[0] <a_afwOP>_R)
                             :: (Min a_afwOP -> Min a_afwOP -> a_afwOP :: *)
                                ~R# (Min a_afwOP -> Min a_afwOP -> Min a_afwOP :: *))
                     (\ (ds_XfA20 [Occ=Once] :: Min a_afwOP) ->
                        negate
                          @ a_afwOP
                          v_Xdl
                          (ds_XfA20
                           `cast` (Data.Semigroup.N:Min[0] <a_afwOP>_R
                                   :: (Min a_afwOP :: *) ~R# (a_afwOP :: *))))
                     `cast` (<Min a_afwOP>_R
                             ->_R Sym (Data.Semigroup.N:Min[0] <a_afwOP>_R)
                             :: (Min a_afwOP -> a_afwOP :: *)
                                ~R# (Min a_afwOP -> Min a_afwOP :: *))
                     (\ (ds_XfA24 [Occ=Once] :: Min a_afwOP) ->
                        abs
                          @ a_afwOP
                          v_Xdl
                          (ds_XfA24
                           `cast` (Data.Semigroup.N:Min[0] <a_afwOP>_R
                                   :: (Min a_afwOP :: *) ~R# (a_afwOP :: *))))
                     `cast` (<Min a_afwOP>_R
                             ->_R Sym (Data.Semigroup.N:Min[0] <a_afwOP>_R)
                             :: (Min a_afwOP -> a_afwOP :: *)
                                ~R# (Min a_afwOP -> Min a_afwOP :: *))
                     (\ (ds_XfA28 [Occ=Once] :: Min a_afwOP) ->
                        signum
                          @ a_afwOP
                          v_Xdl
                          (ds_XfA28
                           `cast` (Data.Semigroup.N:Min[0] <a_afwOP>_R
                                   :: (Min a_afwOP :: *) ~R# (a_afwOP :: *))))
                     `cast` (<Min a_afwOP>_R
                             ->_R Sym (Data.Semigroup.N:Min[0] <a_afwOP>_R)
                             :: (Min a_afwOP -> a_afwOP :: *)
                                ~R# (Min a_afwOP -> Min a_afwOP :: *))
                     (\ (eta_XoF [Occ=Once] :: Integer) ->
                        fromInteger @ a_afwOP v_Xdl eta_XoF)
                     `cast` (<Integer>_R ->_R Sym (Data.Semigroup.N:Min[0] <a_afwOP>_R)
                             :: (Integer -> a_afwOP :: *) ~R# (Integer -> Min a_afwOP :: *))]
Data.Semigroup.$fNumMin
  = \ (@ a_XfzlK) ($dNum_XfzlM :: Num a_XfzlK) ->
      GHC.Num.C:Num
        @ (Min a_XfzlK)
        ((\ (ds_XfA1F :: Min a_XfzlK) (ds1_XfA1H :: Min a_XfzlK) ->
            + @ a_XfzlK
              $dNum_XfzlM
              (ds_XfA1F
               `cast` (Data.Semigroup.N:Min[0] <a_XfzlK>_R
                       :: (Min a_XfzlK :: *) ~R# (a_XfzlK :: *)))
              (ds1_XfA1H
               `cast` (Data.Semigroup.N:Min[0] <a_XfzlK>_R
                       :: (Min a_XfzlK :: *) ~R# (a_XfzlK :: *))))
         `cast` (<Min a_XfzlK>_R
                 ->_R <Min a_XfzlK>_R
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_XfzlK>_R)
                 :: (Min a_XfzlK -> Min a_XfzlK -> a_XfzlK :: *)
                    ~R# (Min a_XfzlK -> Min a_XfzlK -> Min a_XfzlK :: *)))
        ((\ (ds_XfA1M :: Min a_XfzlK) (ds1_XfA1O :: Min a_XfzlK) ->
            - @ a_XfzlK
              $dNum_XfzlM
              (ds_XfA1M
               `cast` (Data.Semigroup.N:Min[0] <a_XfzlK>_R
                       :: (Min a_XfzlK :: *) ~R# (a_XfzlK :: *)))
              (ds1_XfA1O
               `cast` (Data.Semigroup.N:Min[0] <a_XfzlK>_R
                       :: (Min a_XfzlK :: *) ~R# (a_XfzlK :: *))))
         `cast` (<Min a_XfzlK>_R
                 ->_R <Min a_XfzlK>_R
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_XfzlK>_R)
                 :: (Min a_XfzlK -> Min a_XfzlK -> a_XfzlK :: *)
                    ~R# (Min a_XfzlK -> Min a_XfzlK -> Min a_XfzlK :: *)))
        ((\ (ds_XfA1T :: Min a_XfzlK) (ds1_XfA1V :: Min a_XfzlK) ->
            * @ a_XfzlK
              $dNum_XfzlM
              (ds_XfA1T
               `cast` (Data.Semigroup.N:Min[0] <a_XfzlK>_R
                       :: (Min a_XfzlK :: *) ~R# (a_XfzlK :: *)))
              (ds1_XfA1V
               `cast` (Data.Semigroup.N:Min[0] <a_XfzlK>_R
                       :: (Min a_XfzlK :: *) ~R# (a_XfzlK :: *))))
         `cast` (<Min a_XfzlK>_R
                 ->_R <Min a_XfzlK>_R
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_XfzlK>_R)
                 :: (Min a_XfzlK -> Min a_XfzlK -> a_XfzlK :: *)
                    ~R# (Min a_XfzlK -> Min a_XfzlK -> Min a_XfzlK :: *)))
        ((\ (ds_XfA20 :: Min a_XfzlK) ->
            negate
              @ a_XfzlK
              $dNum_XfzlM
              (ds_XfA20
               `cast` (Data.Semigroup.N:Min[0] <a_XfzlK>_R
                       :: (Min a_XfzlK :: *) ~R# (a_XfzlK :: *))))
         `cast` (<Min a_XfzlK>_R
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_XfzlK>_R)
                 :: (Min a_XfzlK -> a_XfzlK :: *)
                    ~R# (Min a_XfzlK -> Min a_XfzlK :: *)))
        ((\ (ds_XfA24 :: Min a_XfzlK) ->
            abs
              @ a_XfzlK
              $dNum_XfzlM
              (ds_XfA24
               `cast` (Data.Semigroup.N:Min[0] <a_XfzlK>_R
                       :: (Min a_XfzlK :: *) ~R# (a_XfzlK :: *))))
         `cast` (<Min a_XfzlK>_R
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_XfzlK>_R)
                 :: (Min a_XfzlK -> a_XfzlK :: *)
                    ~R# (Min a_XfzlK -> Min a_XfzlK :: *)))
        ((\ (ds_XfA28 :: Min a_XfzlK) ->
            signum
              @ a_XfzlK
              $dNum_XfzlM
              (ds_XfA28
               `cast` (Data.Semigroup.N:Min[0] <a_XfzlK>_R
                       :: (Min a_XfzlK :: *) ~R# (a_XfzlK :: *))))
         `cast` (<Min a_XfzlK>_R
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_XfzlK>_R)
                 :: (Min a_XfzlK -> a_XfzlK :: *)
                    ~R# (Min a_XfzlK -> Min a_XfzlK :: *)))
        ((\ (eta_XoF :: Integer) ->
            fromInteger @ a_XfzlK $dNum_XfzlM eta_XoF)
         `cast` (<Integer>_R ->_R Sym (Data.Semigroup.N:Min[0] <a_XfzlK>_R)
                 :: (Integer -> a_XfzlK :: *) ~R# (Integer -> Min a_XfzlK :: *)))

-- RHS size: {terms: 21, types: 30, coercions: 7, joins: 0/1}
Data.Semigroup.$w$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a. Ord a => Max a -> [Max a] -> Max a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U)),A)><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 150 0}]
Data.Semigroup.$w$csconcat
  = \ (@ a_sfBpa)
      (w_sfBpb :: Ord a_sfBpa)
      (ww_sfBpf :: Max a_sfBpa)
      (ww1_sfBpg :: [Max a_sfBpa]) ->
      letrec {
        go_sfAiC [Occ=LoopBreaker]
          :: Max a_sfBpa -> [Max a_sfBpa] -> Max a_sfBpa
        [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []]
        go_sfAiC
          = \ (b_i9ine :: Max a_sfBpa) (ds1_i9inf :: [Max a_sfBpa]) ->
              case ds1_i9inf of {
                [] -> b_i9ine;
                : c_i9inn cs_i9ino ->
                  (max
                     @ a_sfBpa
                     w_sfBpb
                     (b_i9ine
                      `cast` (Data.Semigroup.N:Max[0] <a_sfBpa>_R
                              :: (Max a_sfBpa :: *) ~R# (a_sfBpa :: *)))
                     ((go_sfAiC c_i9inn cs_i9ino)
                      `cast` (Data.Semigroup.N:Max[0] <a_sfBpa>_R
                              :: (Max a_sfBpa :: *) ~R# (a_sfBpa :: *))))
                  `cast` (Sym (Data.Semigroup.N:Max[0] <a_sfBpa>_R)
                          :: (a_sfBpa :: *) ~R# (Max a_sfBpa :: *))
              }; } in
      go_sfAiC ww_sfBpf ww1_sfBpg

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
Data.Semigroup.$fSemigroupMax_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a. Ord a => GHC.Base.NonEmpty (Max a) -> Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U)),A)><S(LS),1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sfBpa)
                 (w_sfBpb [Occ=Once] :: Ord a_sfBpa)
                 (w1_sfBpc [Occ=Once!] :: GHC.Base.NonEmpty (Max a_sfBpa)) ->
                 case w1_sfBpc of
                 { GHC.Base.:| ww1_sfBpf [Occ=Once] ww2_sfBpg [Occ=Once] ->
                 Data.Semigroup.$w$csconcat @ a_sfBpa w_sfBpb ww1_sfBpf ww2_sfBpg
                 }}]
Data.Semigroup.$fSemigroupMax_$csconcat
  = \ (@ a_sfBpa)
      (w_sfBpb :: Ord a_sfBpa)
      (w1_sfBpc :: GHC.Base.NonEmpty (Max a_sfBpa)) ->
      case w1_sfBpc of { GHC.Base.:| ww1_sfBpf ww2_sfBpg ->
      Data.Semigroup.$w$csconcat @ a_sfBpa w_sfBpb ww1_sfBpf ww2_sfBpg
      }

-- RHS size: {terms: 9, types: 12, coercions: 0, joins: 0/0}
lvl2_rfC68 :: forall a b. Integral b => b -> Max a -> Max a
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []]
lvl2_rfC68
  = \ (@ a_afz6w)
      (@ b_afz6Y)
      ($dIntegral_afz70 :: Integral b_afz6Y)
      (eta_B2 :: b_afz6Y)
      (eta1_XcB :: Max a_afz6w) ->
      stimesIdempotent
        @ b_afz6Y @ (Max a_afz6w) $dIntegral_afz70 eta_B2 eta1_XcB

-- RHS size: {terms: 8, types: 9, coercions: 11, joins: 0/0}
Data.Semigroup.$fSemigroupMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Ord a => Semigroup (Max a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,A,A,A,A,A,U,A)>m,
 Unf=DFun: \ (@ a_afwOD) (v_XdD :: Ord a_afwOD) ->
       GHC.Base.C:Semigroup TYPE: Max a_afwOD
                            (max @ a_afwOD v_XdD)
                            `cast` (Sym (Data.Semigroup.N:Max[0] <a_afwOD>_R)
                                    ->_R Sym (Data.Semigroup.N:Max[0] <a_afwOD>_R)
                                    ->_R Sym (Data.Semigroup.N:Max[0] <a_afwOD>_R)
                                    :: (a_afwOD -> a_afwOD -> a_afwOD :: *)
                                       ~R# (Max a_afwOD -> Max a_afwOD -> Max a_afwOD :: *))
                            Data.Semigroup.$fSemigroupMax_$csconcat @ a_afwOD v_XdD
                            \ (@ b_afz6Y) ($dIntegral_afz70 [Occ=Once] :: Integral b_afz6Y) ->
                              stimesIdempotent @ b_afz6Y @ (Max a_afwOD) $dIntegral_afz70]
Data.Semigroup.$fSemigroupMax
  = \ (@ a_afz6w) ($dOrd_afz6x :: Ord a_afz6w) ->
      GHC.Base.C:Semigroup
        @ (Max a_afz6w)
        ((max @ a_afz6w $dOrd_afz6x)
         `cast` (Sym (Data.Semigroup.N:Max[0] <a_afz6w>_R)
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afz6w>_R)
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afz6w>_R)
                 :: (a_afz6w -> a_afz6w -> a_afz6w :: *)
                    ~R# (Max a_afz6w -> Max a_afz6w -> Max a_afz6w :: *)))
        (Data.Semigroup.$fSemigroupMax_$csconcat @ a_afz6w $dOrd_afz6x)
        (lvl2_rfC68 @ a_afz6w)

-- RHS size: {terms: 6, types: 8, coercions: 2, joins: 0/0}
Data.Semigroup.$fFunctorMax2 :: forall a b. (a -> b) -> Max a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afz5R)
                 (@ b_afz5S)
                 (f_afwOA [Occ=Once!] :: a_afz5R -> b_afz5S)
                 (ds_dfzNs [Occ=Once] :: Max a_afz5R) ->
                 f_afwOA
                   (ds_dfzNs
                    `cast` (Data.Semigroup.N:Max[0] <a_afz5R>_R
                            :: (Max a_afz5R :: *) ~R# (a_afz5R :: *)))}]
Data.Semigroup.$fFunctorMax2
  = \ (@ a_afz5R)
      (@ b_afz5S)
      (f_afwOA :: a_afz5R -> b_afz5S)
      (ds_dfzNs :: Max a_afz5R) ->
      f_afwOA
        (ds_dfzNs
         `cast` (Data.Semigroup.N:Max[0] <a_afz5R>_R
                 :: (Max a_afz5R :: *) ~R# (a_afz5R :: *)))

-- RHS size: {terms: 5, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fFunctorMax1 :: forall b a. a -> Max b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_afz5Z)
                 (@ a_afz5Y)
                 (x_X9DyJ [Occ=Once] :: a_afz5Y)
                 _ [Occ=Dead] ->
                 x_X9DyJ}]
Data.Semigroup.$fFunctorMax1
  = \ (@ b_afz5Z) (@ a_afz5Y) (x_X9DyJ :: a_afz5Y) _ [Occ=Dead] ->
      x_X9DyJ

-- RHS size: {terms: 5, types: 7, coercions: 29, joins: 0/0}
Data.Semigroup.$fFunctorMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Functor Max
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Functor TYPE: Max
                          Data.Semigroup.$fFunctorMax2
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a -> b>_R ->_R <Max a>_R ->_R Sym (Data.Semigroup.N:Max[0] <b>_R)
                                  :: (forall a b. (a -> b) -> Max a -> b :: *)
                                     ~R# (forall a b. (a -> b) -> Max a -> Max b :: *))
                          (\ (@ a_afz5Y) (@ b_afz5Z) ->
                             Data.Semigroup.$fFunctorMax1 @ b_afz5Z @ a_afz5Y)
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a>_R ->_R <Max b>_R ->_R Sym (Data.Semigroup.N:Max[0] <a>_R)
                                  :: (forall a b. a -> Max b -> a :: *)
                                     ~R# (forall a b. a -> Max b -> Max a :: *))]
Data.Semigroup.$fFunctorMax
  = GHC.Base.C:Functor
      @ Max
      (Data.Semigroup.$fFunctorMax2
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a -> b>_R ->_R <Max a>_R ->_R Sym (Data.Semigroup.N:Max[0] <b>_R)
               :: (forall a b. (a -> b) -> Max a -> b :: *)
                  ~R# (forall a b. (a -> b) -> Max a -> Max b :: *)))
      ((\ (@ a_afz5Y) (@ b_afz5Z) ->
          Data.Semigroup.$fFunctorMax1 @ b_afz5Z @ a_afz5Y)
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a>_R ->_R <Max b>_R ->_R Sym (Data.Semigroup.N:Max[0] <a>_R)
               :: (forall a b. a -> Max b -> a :: *)
                  ~R# (forall a b. a -> Max b -> Max a :: *)))

-- RHS size: {terms: 7, types: 10, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableMax_$cfoldMap
  :: forall m a. Monoid m => (a -> m) -> Max a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ m_afz3B)
                 (@ a_afz3C)
                 _ [Occ=Dead]
                 (f_afwOy [Occ=Once!] :: a_afz3C -> m_afz3B)
                 (ds_dfzNn [Occ=Once] :: Max a_afz3C) ->
                 f_afwOy
                   (ds_dfzNn
                    `cast` (Data.Semigroup.N:Max[0] <a_afz3C>_R
                            :: (Max a_afz3C :: *) ~R# (a_afz3C :: *)))}]
Data.Semigroup.$fFoldableMax_$cfoldMap
  = \ (@ m_afz3B)
      (@ a_afz3C)
      _ [Occ=Dead]
      (f_afwOy :: a_afz3C -> m_afz3B)
      (ds_dfzNn :: Max a_afz3C) ->
      f_afwOy
        (ds_dfzNn
         `cast` (Data.Semigroup.N:Max[0] <a_afz3C>_R
                 :: (Max a_afz3C :: *) ~R# (a_afz3C :: *)))

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableMax4
  :: forall m. Monoid m => Max m -> Max m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ m_afz3r)
                 _ [Occ=Dead]
                 (ds_dfzNn [Occ=Once] :: Max m_afz3r) ->
                 ds_dfzNn}]
Data.Semigroup.$fFoldableMax4
  = \ (@ m_afz3r) _ [Occ=Dead] (ds_dfzNn :: Max m_afz3r) -> ds_dfzNn

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableMax1 :: forall a. Num a => Max a -> Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afz5v)
                 _ [Occ=Dead]
                 (eta_XcG [Occ=Once] :: Max a_afz5v) ->
                 eta_XcG}]
Data.Semigroup.$fFoldableMax1
  = \ (@ a_afz5v) _ [Occ=Dead] (eta_XcG :: Max a_afz5v) -> eta_XcG

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableMax2 :: forall a. Ord a => Max a -> Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afz5l)
                 _ [Occ=Dead]
                 (x_ifzGk [Occ=Once] :: Max a_afz5l) ->
                 x_ifzGk}]
Data.Semigroup.$fFoldableMax2
  = \ (@ a_afz5l) _ [Occ=Dead] (x_ifzGk :: Max a_afz5l) -> x_ifzGk

-- RHS size: {terms: 10, types: 10, coercions: 2, joins: 0/1}
Data.Semigroup.$fFoldableMax_$celem
  :: forall a. Eq a => a -> Max a -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afz51)
                 ($dEq_afz53 [Occ=Once] :: Eq a_afz51)
                 (eta_XcT [Occ=Once] :: a_afz51) ->
                 let {
                   f_sfAiA [Occ=OnceL!] :: a_afz51 -> Bool
                   [LclId]
                   f_sfAiA = == @ a_afz51 $dEq_afz53 eta_XcT } in
                 \ (ds_dfzNn [Occ=Once] :: Max a_afz51) ->
                   f_sfAiA
                     (ds_dfzNn
                      `cast` (Data.Semigroup.N:Max[0] <a_afz51>_R
                              :: (Max a_afz51 :: *) ~R# (a_afz51 :: *)))}]
Data.Semigroup.$fFoldableMax_$celem
  = \ (@ a_afz51) ($dEq_afz53 :: Eq a_afz51) (eta_XcT :: a_afz51) ->
      let {
        f_sfAiA [Dmd=<L,C(U)>] :: a_afz51 -> Bool
        [LclId]
        f_sfAiA = == @ a_afz51 $dEq_afz53 eta_XcT } in
      \ (ds_dfzNn :: Max a_afz51) ->
        f_sfAiA
          (ds_dfzNn
           `cast` (Data.Semigroup.N:Max[0] <a_afz51>_R
                   :: (Max a_afz51 :: *) ~R# (a_afz51 :: *)))

-- RHS size: {terms: 8, types: 10, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableMax_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Max a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_afz43)
                 (@ a_afz44)
                 (f_XfzSH [Occ=Once!] :: b_afz43 -> a_afz44 -> b_afz43)
                 (z_XfzSJ [Occ=Once] :: b_afz43)
                 (t1_XfzSL [Occ=Once] :: Max a_afz44) ->
                 f_XfzSH
                   z_XfzSJ
                   (t1_XfzSL
                    `cast` (Data.Semigroup.N:Max[0] <a_afz44>_R
                            :: (Max a_afz44 :: *) ~R# (a_afz44 :: *)))}]
Data.Semigroup.$fFoldableMax_$cfoldl
  = \ (@ b_afz43)
      (@ a_afz44)
      (f_XfzSH :: b_afz43 -> a_afz44 -> b_afz43)
      (z_XfzSJ :: b_afz43)
      (t1_XfzSL :: Max a_afz44) ->
      f_XfzSH
        z_XfzSJ
        (t1_XfzSL
         `cast` (Data.Semigroup.N:Max[0] <a_afz44>_R
                 :: (Max a_afz44 :: *) ~R# (a_afz44 :: *)))

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableMax3
  :: forall a. (a -> a -> a) -> Max a -> Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afz4v)
                 _ [Occ=Dead]
                 (xs_XfzSg [Occ=Once] :: Max a_afz4v) ->
                 xs_XfzSg}]
Data.Semigroup.$fFoldableMax3
  = \ (@ a_afz4v) _ [Occ=Dead] (xs_XfzSg :: Max a_afz4v) -> xs_XfzSg

-- RHS size: {terms: 8, types: 10, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableMax_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Max a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afz3T)
                 (@ b_afz3U)
                 (f_ifzEu [Occ=Once!] :: a_afz3T -> b_afz3U -> b_afz3U)
                 (z0_ifzEv [Occ=Once] :: b_afz3U)
                 (xs_ifzEw [Occ=Once] :: Max a_afz3T) ->
                 f_ifzEu
                   (xs_ifzEw
                    `cast` (Data.Semigroup.N:Max[0] <a_afz3T>_R
                            :: (Max a_afz3T :: *) ~R# (a_afz3T :: *)))
                   z0_ifzEv}]
Data.Semigroup.$fFoldableMax_$cfoldr'
  = \ (@ a_afz3T)
      (@ b_afz3U)
      (f_ifzEu :: a_afz3T -> b_afz3U -> b_afz3U)
      (z0_ifzEv :: b_afz3U)
      (xs_ifzEw :: Max a_afz3T) ->
      f_ifzEu
        (xs_ifzEw
         `cast` (Data.Semigroup.N:Max[0] <a_afz3T>_R
                 :: (Max a_afz3T :: *) ~R# (a_afz3T :: *)))
        z0_ifzEv

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableMax_$clength :: forall a. Max a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afz4T) _ [Occ=Dead] ->
                 Data.Semigroup.$fFoldableFirst3}]
Data.Semigroup.$fFoldableMax_$clength
  = \ (@ a_afz4T) _ [Occ=Dead] -> Data.Semigroup.$fFoldableFirst3

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableMax_$cnull :: forall a. Max a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afz4L) _ [Occ=Dead] -> GHC.Types.False}]
Data.Semigroup.$fFoldableMax_$cnull
  = \ (@ a_afz4L) _ [Occ=Dead] -> GHC.Types.False

-- RHS size: {terms: 5, types: 6, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableMax_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Max a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_afz4D) (t1_ifzFB [Occ=Once] :: Max a_afz4D) ->
                 GHC.Base.build
                   @ a_afz4D
                   (\ (@ b_ifzFC)
                      (c_ifzFD [Occ=Once!, OS=OneShot] :: a_afz4D -> b_ifzFC -> b_ifzFC)
                      (n_ifzFE [Occ=Once, OS=OneShot] :: b_ifzFC) ->
                      c_ifzFD
                        (t1_ifzFB
                         `cast` (Data.Semigroup.N:Max[0] <a_afz4D>_R
                                 :: (Max a_afz4D :: *) ~R# (a_afz4D :: *)))
                        n_ifzFE)}]
Data.Semigroup.$fFoldableMax_$ctoList
  = \ (@ a_afz4D) (eta_XdR :: Max a_afz4D) ->
      GHC.Types.:
        @ a_afz4D
        (eta_XdR
         `cast` (Data.Semigroup.N:Max[0] <a_afz4D>_R
                 :: (Max a_afz4D :: *) ~R# (a_afz4D :: *)))
        (GHC.Types.[] @ a_afz4D)

-- RHS size: {terms: 17, types: 1, coercions: 79, joins: 0/0}
Data.Semigroup.$fFoldableMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable Max
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: Max
                                Data.Semigroup.$fFoldableMax4
                                `cast` (forall (m :: <*>_N).
                                        <Monoid m>_R
                                        ->_R <Max m>_R
                                        ->_R Data.Semigroup.N:Max[0] <m>_R
                                        :: (forall m. Monoid m => Max m -> Max m :: *)
                                           ~R# (forall m. Monoid m => Max m -> m :: *))
                                Data.Semigroup.$fFoldableMax_$cfoldMap
                                Data.Semigroup.$fFoldableMax_$cfoldr'
                                Data.Semigroup.$fFoldableMax_$cfoldr'
                                Data.Semigroup.$fFoldableMax_$cfoldl
                                Data.Semigroup.$fFoldableMax_$cfoldl
                                Data.Semigroup.$fFoldableMax3
                                `cast` (forall (a :: <*>_N).
                                        <a -> a -> a>_R
                                        ->_R <Max a>_R
                                        ->_R Data.Semigroup.N:Max[0] <a>_R
                                        :: (forall a. (a -> a -> a) -> Max a -> Max a :: *)
                                           ~R# (forall a. (a -> a -> a) -> Max a -> a :: *))
                                Data.Semigroup.$fFoldableMax3
                                `cast` (forall (a :: <*>_N).
                                        <a -> a -> a>_R
                                        ->_R <Max a>_R
                                        ->_R Data.Semigroup.N:Max[0] <a>_R
                                        :: (forall a. (a -> a -> a) -> Max a -> Max a :: *)
                                           ~R# (forall a. (a -> a -> a) -> Max a -> a :: *))
                                Data.Semigroup.$fFoldableMax_$ctoList
                                Data.Semigroup.$fFoldableMax_$cnull
                                Data.Semigroup.$fFoldableMax_$clength
                                Data.Semigroup.$fFoldableMax_$celem
                                Data.Semigroup.$fFoldableMax2
                                `cast` (forall (a :: <*>_N).
                                        <Ord a>_R ->_R <Max a>_R ->_R Data.Semigroup.N:Max[0] <a>_R
                                        :: (forall a. Ord a => Max a -> Max a :: *)
                                           ~R# (forall a. Ord a => Max a -> a :: *))
                                Data.Semigroup.$fFoldableMax2
                                `cast` (forall (a :: <*>_N).
                                        <Ord a>_R ->_R <Max a>_R ->_R Data.Semigroup.N:Max[0] <a>_R
                                        :: (forall a. Ord a => Max a -> Max a :: *)
                                           ~R# (forall a. Ord a => Max a -> a :: *))
                                Data.Semigroup.$fFoldableMax1
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R ->_R <Max a>_R ->_R Data.Semigroup.N:Max[0] <a>_R
                                        :: (forall a. Num a => Max a -> Max a :: *)
                                           ~R# (forall a. Num a => Max a -> a :: *))
                                Data.Semigroup.$fFoldableMax1
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R ->_R <Max a>_R ->_R Data.Semigroup.N:Max[0] <a>_R
                                        :: (forall a. Num a => Max a -> Max a :: *)
                                           ~R# (forall a. Num a => Max a -> a :: *))]
Data.Semigroup.$fFoldableMax
  = Data.Foldable.C:Foldable
      @ Max
      (Data.Semigroup.$fFoldableMax4
       `cast` (forall (m :: <*>_N).
               <Monoid m>_R ->_R <Max m>_R ->_R Data.Semigroup.N:Max[0] <m>_R
               :: (forall m. Monoid m => Max m -> Max m :: *)
                  ~R# (forall m. Monoid m => Max m -> m :: *)))
      Data.Semigroup.$fFoldableMax_$cfoldMap
      Data.Semigroup.$fFoldableMax_$cfoldr'
      Data.Semigroup.$fFoldableMax_$cfoldr'
      Data.Semigroup.$fFoldableMax_$cfoldl
      Data.Semigroup.$fFoldableMax_$cfoldl
      (Data.Semigroup.$fFoldableMax3
       `cast` (forall (a :: <*>_N).
               <a -> a -> a>_R ->_R <Max a>_R ->_R Data.Semigroup.N:Max[0] <a>_R
               :: (forall a. (a -> a -> a) -> Max a -> Max a :: *)
                  ~R# (forall a. (a -> a -> a) -> Max a -> a :: *)))
      (Data.Semigroup.$fFoldableMax3
       `cast` (forall (a :: <*>_N).
               <a -> a -> a>_R ->_R <Max a>_R ->_R Data.Semigroup.N:Max[0] <a>_R
               :: (forall a. (a -> a -> a) -> Max a -> Max a :: *)
                  ~R# (forall a. (a -> a -> a) -> Max a -> a :: *)))
      Data.Semigroup.$fFoldableMax_$ctoList
      Data.Semigroup.$fFoldableMax_$cnull
      Data.Semigroup.$fFoldableMax_$clength
      Data.Semigroup.$fFoldableMax_$celem
      (Data.Semigroup.$fFoldableMax2
       `cast` (forall (a :: <*>_N).
               <Ord a>_R ->_R <Max a>_R ->_R Data.Semigroup.N:Max[0] <a>_R
               :: (forall a. Ord a => Max a -> Max a :: *)
                  ~R# (forall a. Ord a => Max a -> a :: *)))
      (Data.Semigroup.$fFoldableMax2
       `cast` (forall (a :: <*>_N).
               <Ord a>_R ->_R <Max a>_R ->_R Data.Semigroup.N:Max[0] <a>_R
               :: (forall a. Ord a => Max a -> Max a :: *)
                  ~R# (forall a. Ord a => Max a -> a :: *)))
      (Data.Semigroup.$fFoldableMax1
       `cast` (forall (a :: <*>_N).
               <Num a>_R ->_R <Max a>_R ->_R Data.Semigroup.N:Max[0] <a>_R
               :: (forall a. Num a => Max a -> Max a :: *)
                  ~R# (forall a. Num a => Max a -> a :: *)))
      (Data.Semigroup.$fFoldableMax1
       `cast` (forall (a :: <*>_N).
               <Num a>_R ->_R <Max a>_R ->_R Data.Semigroup.N:Max[0] <a>_R
               :: (forall a. Num a => Max a -> Max a :: *)
                  ~R# (forall a. Num a => Max a -> a :: *)))

-- RHS size: {terms: 12, types: 21, coercions: 7, joins: 0/0}
Data.Semigroup.$fTraversableMax_$ctraverse
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> Max a -> f (Max b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_afz2z :: * -> *))
                 (@ a_afz2A)
                 (@ b_afz2B)
                 ($dApplicative_afz2D [Occ=Once] :: Applicative f_afz2z)
                 (eta_B2 [Occ=Once!] :: a_afz2A -> f_afz2z b_afz2B)
                 (eta1_Xdn [Occ=Once] :: Max a_afz2A) ->
                 fmap
                   @ f_afz2z
                   (GHC.Base.$p1Applicative @ f_afz2z $dApplicative_afz2D)
                   @ b_afz2B
                   @ (Max b_afz2B)
                   ((Data.Semigroup.$fApplicativeFirst3 @ b_afz2B)
                    `cast` (<b_afz2B>_R ->_R Sym (Data.Semigroup.N:Max[0] <b_afz2B>_R)
                            :: (b_afz2B -> b_afz2B :: *) ~R# (b_afz2B -> Max b_afz2B :: *)))
                   (eta_B2
                      (eta1_Xdn
                       `cast` (Data.Semigroup.N:Max[0] <a_afz2A>_R
                               :: (Max a_afz2A :: *) ~R# (a_afz2A :: *))))}]
Data.Semigroup.$fTraversableMax_$ctraverse
  = \ (@ (f_afz2z :: * -> *))
      (@ a_afz2A)
      (@ b_afz2B)
      ($dApplicative_afz2D :: Applicative f_afz2z)
      (eta_B2 :: a_afz2A -> f_afz2z b_afz2B)
      (eta1_Xdn :: Max a_afz2A) ->
      fmap
        @ f_afz2z
        (GHC.Base.$p1Applicative @ f_afz2z $dApplicative_afz2D)
        @ b_afz2B
        @ (Max b_afz2B)
        ((Data.Semigroup.$fApplicativeFirst3 @ b_afz2B)
         `cast` (<b_afz2B>_R ->_R Sym (Data.Semigroup.N:Max[0] <b_afz2B>_R)
                 :: (b_afz2B -> b_afz2B :: *) ~R# (b_afz2B -> Max b_afz2B :: *)))
        (eta_B2
           (eta1_Xdn
            `cast` (Data.Semigroup.N:Max[0] <a_afz2A>_R
                    :: (Max a_afz2A :: *) ~R# (a_afz2A :: *))))

-- RHS size: {terms: 9, types: 17, coercions: 8, joins: 0/0}
Data.Semigroup.$fTraversableMax_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a. Applicative f => Max (f a) -> f (Max a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_afz2N :: * -> *))
                 (@ a_afz2O)
                 ($dApplicative_afz2Q [Occ=Once] :: Applicative f_afz2N)
                 (eta_XsF [Occ=Once] :: Max (f_afz2N a_afz2O)) ->
                 fmap
                   @ f_afz2N
                   (GHC.Base.$p1Applicative @ f_afz2N $dApplicative_afz2Q)
                   @ a_afz2O
                   @ (Max a_afz2O)
                   ((\ (v_Xek [Occ=Once] :: a_afz2O) -> v_Xek)
                    `cast` (<a_afz2O>_R ->_R Sym (Data.Semigroup.N:Max[0] <a_afz2O>_R)
                            :: (a_afz2O -> a_afz2O :: *) ~R# (a_afz2O -> Max a_afz2O :: *)))
                   (eta_XsF
                    `cast` (Data.Semigroup.N:Max[0] <f_afz2N a_afz2O>_R
                            :: (Max (f_afz2N a_afz2O) :: *) ~R# (f_afz2N a_afz2O :: *)))}]
Data.Semigroup.$fTraversableMax_$csequenceA
  = \ (@ (f_afz2N :: * -> *))
      (@ a_afz2O)
      ($dApplicative_afz2Q :: Applicative f_afz2N)
      (eta_XsF :: Max (f_afz2N a_afz2O)) ->
      fmap
        @ f_afz2N
        (GHC.Base.$p1Applicative @ f_afz2N $dApplicative_afz2Q)
        @ a_afz2O
        @ (Max a_afz2O)
        ((Data.Semigroup.$fApplicativeFirst3 @ a_afz2O)
         `cast` (<a_afz2O>_R ->_R Sym (Data.Semigroup.N:Max[0] <a_afz2O>_R)
                 :: (a_afz2O -> a_afz2O :: *) ~R# (a_afz2O -> Max a_afz2O :: *)))
        (eta_XsF
         `cast` (Data.Semigroup.N:Max[0] <f_afz2N a_afz2O>_R
                 :: (Max (f_afz2N a_afz2O) :: *) ~R# (f_afz2N a_afz2O :: *)))

-- RHS size: {terms: 13, types: 22, coercions: 7, joins: 0/0}
Data.Semigroup.$fTraversableMax_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Max a -> m (Max b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_afz2Z :: * -> *))
                 (@ a_afz30)
                 (@ b_afz31)
                 ($dMonad_afz33 [Occ=OnceL] :: Monad m_afz2Z) ->
                 let {
                   $dApplicative_afz2D [Occ=OnceL] :: Applicative m_afz2Z
                   [LclId]
                   $dApplicative_afz2D
                     = GHC.Base.$p1Monad @ m_afz2Z $dMonad_afz33 } in
                 \ (eta_B2 [Occ=Once!] :: a_afz30 -> m_afz2Z b_afz31)
                   (eta1_Xdn [Occ=Once] :: Max a_afz30) ->
                   fmap
                     @ m_afz2Z
                     (GHC.Base.$p1Applicative @ m_afz2Z $dApplicative_afz2D)
                     @ b_afz31
                     @ (Max b_afz31)
                     ((\ (v_Xek [Occ=Once] :: b_afz31) -> v_Xek)
                      `cast` (<b_afz31>_R ->_R Sym (Data.Semigroup.N:Max[0] <b_afz31>_R)
                              :: (b_afz31 -> b_afz31 :: *) ~R# (b_afz31 -> Max b_afz31 :: *)))
                     (eta_B2
                        (eta1_Xdn
                         `cast` (Data.Semigroup.N:Max[0] <a_afz30>_R
                                 :: (Max a_afz30 :: *) ~R# (a_afz30 :: *))))}]
Data.Semigroup.$fTraversableMax_$cmapM
  = \ (@ (m_afz2Z :: * -> *))
      (@ a_afz30)
      (@ b_afz31)
      ($dMonad_afz33 :: Monad m_afz2Z)
      (eta_B2 :: a_afz30 -> m_afz2Z b_afz31)
      (eta1_Xdp :: Max a_afz30) ->
      fmap
        @ m_afz2Z
        (GHC.Base.$p1Applicative
           @ m_afz2Z (GHC.Base.$p1Monad @ m_afz2Z $dMonad_afz33))
        @ b_afz31
        @ (Max b_afz31)
        ((Data.Semigroup.$fApplicativeFirst3 @ b_afz31)
         `cast` (<b_afz31>_R ->_R Sym (Data.Semigroup.N:Max[0] <b_afz31>_R)
                 :: (b_afz31 -> b_afz31 :: *) ~R# (b_afz31 -> Max b_afz31 :: *)))
        (eta_B2
           (eta1_Xdp
            `cast` (Data.Semigroup.N:Max[0] <a_afz30>_R
                    :: (Max a_afz30 :: *) ~R# (a_afz30 :: *))))

-- RHS size: {terms: 10, types: 18, coercions: 8, joins: 0/0}
Data.Semigroup.$fTraversableMax_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a. Monad m => Max (m a) -> m (Max a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_afz3d :: * -> *))
                 (@ a_afz3e)
                 ($dMonad_afz3g [Occ=OnceL] :: Monad m_afz3d) ->
                 let {
                   $dApplicative_afz2Q [Occ=OnceL] :: Applicative m_afz3d
                   [LclId]
                   $dApplicative_afz2Q
                     = GHC.Base.$p1Monad @ m_afz3d $dMonad_afz3g } in
                 \ (eta_XsF [Occ=Once] :: Max (m_afz3d a_afz3e)) ->
                   fmap
                     @ m_afz3d
                     (GHC.Base.$p1Applicative @ m_afz3d $dApplicative_afz2Q)
                     @ a_afz3e
                     @ (Max a_afz3e)
                     ((\ (v_Xek [Occ=Once] :: a_afz3e) -> v_Xek)
                      `cast` (<a_afz3e>_R ->_R Sym (Data.Semigroup.N:Max[0] <a_afz3e>_R)
                              :: (a_afz3e -> a_afz3e :: *) ~R# (a_afz3e -> Max a_afz3e :: *)))
                     (eta_XsF
                      `cast` (Data.Semigroup.N:Max[0] <m_afz3d a_afz3e>_R
                              :: (Max (m_afz3d a_afz3e) :: *) ~R# (m_afz3d a_afz3e :: *)))}]
Data.Semigroup.$fTraversableMax_$csequence
  = \ (@ (m_afz3d :: * -> *))
      (@ a_afz3e)
      ($dMonad_afz3g :: Monad m_afz3d)
      (eta_B1 :: Max (m_afz3d a_afz3e)) ->
      fmap
        @ m_afz3d
        (GHC.Base.$p1Applicative
           @ m_afz3d (GHC.Base.$p1Monad @ m_afz3d $dMonad_afz3g))
        @ a_afz3e
        @ (Max a_afz3e)
        ((Data.Semigroup.$fApplicativeFirst3 @ a_afz3e)
         `cast` (<a_afz3e>_R ->_R Sym (Data.Semigroup.N:Max[0] <a_afz3e>_R)
                 :: (a_afz3e -> a_afz3e :: *) ~R# (a_afz3e -> Max a_afz3e :: *)))
        (eta_B1
         `cast` (Data.Semigroup.N:Max[0] <m_afz3d a_afz3e>_R
                 :: (Max (m_afz3d a_afz3e) :: *) ~R# (m_afz3d a_afz3e :: *)))

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Data.Semigroup.$fTraversableMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable Max
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: Max
                                      Data.Semigroup.$fFunctorMax
                                      Data.Semigroup.$fFoldableMax
                                      Data.Semigroup.$fTraversableMax_$ctraverse
                                      Data.Semigroup.$fTraversableMax_$csequenceA
                                      Data.Semigroup.$fTraversableMax_$cmapM
                                      Data.Semigroup.$fTraversableMax_$csequence]
Data.Semigroup.$fTraversableMax
  = Data.Traversable.C:Traversable
      @ Max
      Data.Semigroup.$fFunctorMax
      Data.Semigroup.$fFoldableMax
      Data.Semigroup.$fTraversableMax_$ctraverse
      Data.Semigroup.$fTraversableMax_$csequenceA
      Data.Semigroup.$fTraversableMax_$cmapM
      Data.Semigroup.$fTraversableMax_$csequence

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
Data.Semigroup.$fApplicativeMax_$c<*
  :: forall a b. Max a -> Max b -> Max a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afz2j)
                 (@ b_afz2k)
                 (a1_afwOu [Occ=Once] :: Max a_afz2j)
                 _ [Occ=Dead] ->
                 a1_afwOu}]
Data.Semigroup.$fApplicativeMax_$c<*
  = \ (@ a_afz2j)
      (@ b_afz2k)
      (a1_afwOu :: Max a_afz2j)
      _ [Occ=Dead] ->
      a1_afwOu

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
Data.Semigroup.$fApplicativeMax_$c*>
  :: forall a b. Max a -> Max b -> Max b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afz2d)
                 (@ b_afz2e)
                 _ [Occ=Dead]
                 (a1_afwOv [Occ=Once] :: Max b_afz2e) ->
                 a1_afwOv}]
Data.Semigroup.$fApplicativeMax_$c*>
  = \ (@ a_afz2d)
      (@ b_afz2e)
      _ [Occ=Dead]
      (a1_afwOv :: Max b_afz2e) ->
      a1_afwOv

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fApplicativeMax1
  :: forall a b. Max (a -> b) -> Max (a -> b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afz1S)
                 (@ b_afz1T)
                 (v_Xes [Occ=Once] :: Max (a_afz1S -> b_afz1T)) ->
                 v_Xes}]
Data.Semigroup.$fApplicativeMax1
  = \ (@ a_afz1S) (@ b_afz1T) (v_Xes :: Max (a_afz1S -> b_afz1T)) ->
      v_Xes

-- RHS size: {terms: 7, types: 1, coercions: 50, joins: 0/0}
Data.Semigroup.$fApplicativeMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Applicative Max
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Applicative TYPE: Max
                              Data.Semigroup.$fFunctorMax
                              Data.Semigroup.$fApplicativeFirst3
                              `cast` (forall (a :: <*>_N).
                                      <a>_R ->_R Sym (Data.Semigroup.N:Max[0] <a>_R)
                                      :: (forall a. a -> a :: *) ~R# (forall a. a -> Max a :: *))
                              Data.Semigroup.$fApplicativeMax1
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <Max (a -> b)>_R
                                      ->_R Data.Semigroup.N:Max[0]
                                               (Sym (Data.Semigroup.N:Max[0] <a>_R)
                                                ->_R Sym (Data.Semigroup.N:Max[0] <b>_R))
                                      :: (forall a b. Max (a -> b) -> Max (a -> b) :: *)
                                         ~R# (forall a b. Max (a -> b) -> Max a -> Max b :: *))
                              Data.Semigroup.$fApplicativeFirst1
                              `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                                      <a -> b -> c>_R
                                      ->_R Sym (Data.Semigroup.N:Max[0] <a>_R)
                                      ->_R Sym (Data.Semigroup.N:Max[0] <b>_R)
                                      ->_R Sym (Data.Semigroup.N:Max[0] <c>_R)
                                      :: (forall a b c. (a -> b -> c) -> a -> b -> c :: *)
                                         ~R# (forall a b c.
                                              (a -> b -> c) -> Max a -> Max b -> Max c :: *))
                              Data.Semigroup.$fApplicativeMax_$c*>
                              Data.Semigroup.$fApplicativeMax_$c<*]
Data.Semigroup.$fApplicativeMax
  = GHC.Base.C:Applicative
      @ Max
      Data.Semigroup.$fFunctorMax
      (Data.Semigroup.$fApplicativeFirst3
       `cast` (forall (a :: <*>_N).
               <a>_R ->_R Sym (Data.Semigroup.N:Max[0] <a>_R)
               :: (forall a. a -> a :: *) ~R# (forall a. a -> Max a :: *)))
      (Data.Semigroup.$fApplicativeMax1
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <Max (a -> b)>_R
               ->_R Data.Semigroup.N:Max[0]
                        (Sym (Data.Semigroup.N:Max[0] <a>_R)
                         ->_R Sym (Data.Semigroup.N:Max[0] <b>_R))
               :: (forall a b. Max (a -> b) -> Max (a -> b) :: *)
                  ~R# (forall a b. Max (a -> b) -> Max a -> Max b :: *)))
      (Data.Semigroup.$fApplicativeFirst1
       `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
               <a -> b -> c>_R
               ->_R Sym (Data.Semigroup.N:Max[0] <a>_R)
               ->_R Sym (Data.Semigroup.N:Max[0] <b>_R)
               ->_R Sym (Data.Semigroup.N:Max[0] <c>_R)
               :: (forall a b c. (a -> b -> c) -> a -> b -> c :: *)
                  ~R# (forall a b c. (a -> b -> c) -> Max a -> Max b -> Max c :: *)))
      Data.Semigroup.$fApplicativeMax_$c*>
      Data.Semigroup.$fApplicativeMax_$c<*

-- RHS size: {terms: 6, types: 9, coercions: 2, joins: 0/0}
Data.Semigroup.$fMonadMax_$c>>=
  :: forall a b. Max a -> (a -> Max b) -> Max b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afz19)
                 (@ b_afz1a)
                 (ds_dfzN4 [Occ=Once] :: Max a_afz19)
                 (f_afwOt [Occ=Once!] :: a_afz19 -> Max b_afz1a) ->
                 f_afwOt
                   (ds_dfzN4
                    `cast` (Data.Semigroup.N:Max[0] <a_afz19>_R
                            :: (Max a_afz19 :: *) ~R# (a_afz19 :: *)))}]
Data.Semigroup.$fMonadMax_$c>>=
  = \ (@ a_afz19)
      (@ b_afz1a)
      (ds_dfzN4 :: Max a_afz19)
      (f_afwOt :: a_afz19 -> Max b_afz1a) ->
      f_afwOt
        (ds_dfzN4
         `cast` (Data.Semigroup.N:Max[0] <a_afz19>_R
                 :: (Max a_afz19 :: *) ~R# (a_afz19 :: *)))

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
lvl3_rfC69 :: forall a. [Char] -> Max a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
lvl3_rfC69
  = \ (@ a_afz1y) (eta_B1 :: [Char]) ->
      errorWithoutStackTrace
        @ 'GHC.Types.LiftedRep @ (Max a_afz1y) eta_B1

-- RHS size: {terms: 6, types: 1, coercions: 8, joins: 0/0}
Data.Semigroup.$fMonadMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Monad Max
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Monad TYPE: Max
                        Data.Semigroup.$fApplicativeMax
                        Data.Semigroup.$fMonadMax_$c>>=
                        Data.Semigroup.$fApplicativeMax_$c*>
                        Data.Semigroup.$fApplicativeFirst3
                        `cast` (forall (a :: <*>_N).
                                <a>_R ->_R Sym (Data.Semigroup.N:Max[0] <a>_R)
                                :: (forall a. a -> a :: *) ~R# (forall a. a -> Max a :: *))
                        \ (@ a_afz1y) ->
                          errorWithoutStackTrace @ 'GHC.Types.LiftedRep @ (Max a_afz1y)]
Data.Semigroup.$fMonadMax
  = GHC.Base.C:Monad
      @ Max
      Data.Semigroup.$fApplicativeMax
      Data.Semigroup.$fMonadMax_$c>>=
      Data.Semigroup.$fApplicativeMax_$c*>
      (Data.Semigroup.$fApplicativeFirst3
       `cast` (forall (a :: <*>_N).
               <a>_R ->_R Sym (Data.Semigroup.N:Max[0] <a>_R)
               :: (forall a. a -> a :: *) ~R# (forall a. a -> Max a :: *)))
      lvl3_rfC69

-- RHS size: {terms: 37, types: 32, coercions: 68, joins: 0/0}
Data.Semigroup.$fNumMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Num a => Num (Max a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),C(C1(U)),C(C1(U)),C(U),C(U),C(U),C(U))>m,
 Unf=DFun: \ (@ a_afwOh) (v_Xfd :: Num a_afwOh) ->
       GHC.Num.C:Num TYPE: Max a_afwOh
                     (\ (ds_XfA1J [Occ=Once] :: Max a_afwOh)
                        (ds1_XfA1L [Occ=Once] :: Max a_afwOh) ->
                        + @ a_afwOh
                          v_Xfd
                          (ds_XfA1J
                           `cast` (Data.Semigroup.N:Max[0] <a_afwOh>_R
                                   :: (Max a_afwOh :: *) ~R# (a_afwOh :: *)))
                          (ds1_XfA1L
                           `cast` (Data.Semigroup.N:Max[0] <a_afwOh>_R
                                   :: (Max a_afwOh :: *) ~R# (a_afwOh :: *))))
                     `cast` (<Max a_afwOh>_R
                             ->_R <Max a_afwOh>_R
                             ->_R Sym (Data.Semigroup.N:Max[0] <a_afwOh>_R)
                             :: (Max a_afwOh -> Max a_afwOh -> a_afwOh :: *)
                                ~R# (Max a_afwOh -> Max a_afwOh -> Max a_afwOh :: *))
                     (\ (ds_XfA1Q [Occ=Once] :: Max a_afwOh)
                        (ds1_XfA1S [Occ=Once] :: Max a_afwOh) ->
                        - @ a_afwOh
                          v_Xfd
                          (ds_XfA1Q
                           `cast` (Data.Semigroup.N:Max[0] <a_afwOh>_R
                                   :: (Max a_afwOh :: *) ~R# (a_afwOh :: *)))
                          (ds1_XfA1S
                           `cast` (Data.Semigroup.N:Max[0] <a_afwOh>_R
                                   :: (Max a_afwOh :: *) ~R# (a_afwOh :: *))))
                     `cast` (<Max a_afwOh>_R
                             ->_R <Max a_afwOh>_R
                             ->_R Sym (Data.Semigroup.N:Max[0] <a_afwOh>_R)
                             :: (Max a_afwOh -> Max a_afwOh -> a_afwOh :: *)
                                ~R# (Max a_afwOh -> Max a_afwOh -> Max a_afwOh :: *))
                     (\ (ds_XfA1X [Occ=Once] :: Max a_afwOh)
                        (ds1_XfA1Z [Occ=Once] :: Max a_afwOh) ->
                        * @ a_afwOh
                          v_Xfd
                          (ds_XfA1X
                           `cast` (Data.Semigroup.N:Max[0] <a_afwOh>_R
                                   :: (Max a_afwOh :: *) ~R# (a_afwOh :: *)))
                          (ds1_XfA1Z
                           `cast` (Data.Semigroup.N:Max[0] <a_afwOh>_R
                                   :: (Max a_afwOh :: *) ~R# (a_afwOh :: *))))
                     `cast` (<Max a_afwOh>_R
                             ->_R <Max a_afwOh>_R
                             ->_R Sym (Data.Semigroup.N:Max[0] <a_afwOh>_R)
                             :: (Max a_afwOh -> Max a_afwOh -> a_afwOh :: *)
                                ~R# (Max a_afwOh -> Max a_afwOh -> Max a_afwOh :: *))
                     (\ (ds_XfA24 [Occ=Once] :: Max a_afwOh) ->
                        negate
                          @ a_afwOh
                          v_Xfd
                          (ds_XfA24
                           `cast` (Data.Semigroup.N:Max[0] <a_afwOh>_R
                                   :: (Max a_afwOh :: *) ~R# (a_afwOh :: *))))
                     `cast` (<Max a_afwOh>_R
                             ->_R Sym (Data.Semigroup.N:Max[0] <a_afwOh>_R)
                             :: (Max a_afwOh -> a_afwOh :: *)
                                ~R# (Max a_afwOh -> Max a_afwOh :: *))
                     (\ (ds_XfA28 [Occ=Once] :: Max a_afwOh) ->
                        abs
                          @ a_afwOh
                          v_Xfd
                          (ds_XfA28
                           `cast` (Data.Semigroup.N:Max[0] <a_afwOh>_R
                                   :: (Max a_afwOh :: *) ~R# (a_afwOh :: *))))
                     `cast` (<Max a_afwOh>_R
                             ->_R Sym (Data.Semigroup.N:Max[0] <a_afwOh>_R)
                             :: (Max a_afwOh -> a_afwOh :: *)
                                ~R# (Max a_afwOh -> Max a_afwOh :: *))
                     (\ (ds_XfA2c [Occ=Once] :: Max a_afwOh) ->
                        signum
                          @ a_afwOh
                          v_Xfd
                          (ds_XfA2c
                           `cast` (Data.Semigroup.N:Max[0] <a_afwOh>_R
                                   :: (Max a_afwOh :: *) ~R# (a_afwOh :: *))))
                     `cast` (<Max a_afwOh>_R
                             ->_R Sym (Data.Semigroup.N:Max[0] <a_afwOh>_R)
                             :: (Max a_afwOh -> a_afwOh :: *)
                                ~R# (Max a_afwOh -> Max a_afwOh :: *))
                     (\ (eta_Xrd [Occ=Once] :: Integer) ->
                        fromInteger @ a_afwOh v_Xfd eta_Xrd)
                     `cast` (<Integer>_R ->_R Sym (Data.Semigroup.N:Max[0] <a_afwOh>_R)
                             :: (Integer -> a_afwOh :: *) ~R# (Integer -> Max a_afwOh :: *))]
Data.Semigroup.$fNumMax
  = \ (@ a_Xfzf3) ($dNum_Xfzf5 :: Num a_Xfzf3) ->
      GHC.Num.C:Num
        @ (Max a_Xfzf3)
        ((\ (ds_XfA1J :: Max a_Xfzf3) (ds1_XfA1L :: Max a_Xfzf3) ->
            + @ a_Xfzf3
              $dNum_Xfzf5
              (ds_XfA1J
               `cast` (Data.Semigroup.N:Max[0] <a_Xfzf3>_R
                       :: (Max a_Xfzf3 :: *) ~R# (a_Xfzf3 :: *)))
              (ds1_XfA1L
               `cast` (Data.Semigroup.N:Max[0] <a_Xfzf3>_R
                       :: (Max a_Xfzf3 :: *) ~R# (a_Xfzf3 :: *))))
         `cast` (<Max a_Xfzf3>_R
                 ->_R <Max a_Xfzf3>_R
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_Xfzf3>_R)
                 :: (Max a_Xfzf3 -> Max a_Xfzf3 -> a_Xfzf3 :: *)
                    ~R# (Max a_Xfzf3 -> Max a_Xfzf3 -> Max a_Xfzf3 :: *)))
        ((\ (ds_XfA1Q :: Max a_Xfzf3) (ds1_XfA1S :: Max a_Xfzf3) ->
            - @ a_Xfzf3
              $dNum_Xfzf5
              (ds_XfA1Q
               `cast` (Data.Semigroup.N:Max[0] <a_Xfzf3>_R
                       :: (Max a_Xfzf3 :: *) ~R# (a_Xfzf3 :: *)))
              (ds1_XfA1S
               `cast` (Data.Semigroup.N:Max[0] <a_Xfzf3>_R
                       :: (Max a_Xfzf3 :: *) ~R# (a_Xfzf3 :: *))))
         `cast` (<Max a_Xfzf3>_R
                 ->_R <Max a_Xfzf3>_R
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_Xfzf3>_R)
                 :: (Max a_Xfzf3 -> Max a_Xfzf3 -> a_Xfzf3 :: *)
                    ~R# (Max a_Xfzf3 -> Max a_Xfzf3 -> Max a_Xfzf3 :: *)))
        ((\ (ds_XfA1X :: Max a_Xfzf3) (ds1_XfA1Z :: Max a_Xfzf3) ->
            * @ a_Xfzf3
              $dNum_Xfzf5
              (ds_XfA1X
               `cast` (Data.Semigroup.N:Max[0] <a_Xfzf3>_R
                       :: (Max a_Xfzf3 :: *) ~R# (a_Xfzf3 :: *)))
              (ds1_XfA1Z
               `cast` (Data.Semigroup.N:Max[0] <a_Xfzf3>_R
                       :: (Max a_Xfzf3 :: *) ~R# (a_Xfzf3 :: *))))
         `cast` (<Max a_Xfzf3>_R
                 ->_R <Max a_Xfzf3>_R
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_Xfzf3>_R)
                 :: (Max a_Xfzf3 -> Max a_Xfzf3 -> a_Xfzf3 :: *)
                    ~R# (Max a_Xfzf3 -> Max a_Xfzf3 -> Max a_Xfzf3 :: *)))
        ((\ (ds_XfA24 :: Max a_Xfzf3) ->
            negate
              @ a_Xfzf3
              $dNum_Xfzf5
              (ds_XfA24
               `cast` (Data.Semigroup.N:Max[0] <a_Xfzf3>_R
                       :: (Max a_Xfzf3 :: *) ~R# (a_Xfzf3 :: *))))
         `cast` (<Max a_Xfzf3>_R
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_Xfzf3>_R)
                 :: (Max a_Xfzf3 -> a_Xfzf3 :: *)
                    ~R# (Max a_Xfzf3 -> Max a_Xfzf3 :: *)))
        ((\ (ds_XfA28 :: Max a_Xfzf3) ->
            abs
              @ a_Xfzf3
              $dNum_Xfzf5
              (ds_XfA28
               `cast` (Data.Semigroup.N:Max[0] <a_Xfzf3>_R
                       :: (Max a_Xfzf3 :: *) ~R# (a_Xfzf3 :: *))))
         `cast` (<Max a_Xfzf3>_R
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_Xfzf3>_R)
                 :: (Max a_Xfzf3 -> a_Xfzf3 :: *)
                    ~R# (Max a_Xfzf3 -> Max a_Xfzf3 :: *)))
        ((\ (ds_XfA2c :: Max a_Xfzf3) ->
            signum
              @ a_Xfzf3
              $dNum_Xfzf5
              (ds_XfA2c
               `cast` (Data.Semigroup.N:Max[0] <a_Xfzf3>_R
                       :: (Max a_Xfzf3 :: *) ~R# (a_Xfzf3 :: *))))
         `cast` (<Max a_Xfzf3>_R
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_Xfzf3>_R)
                 :: (Max a_Xfzf3 -> a_Xfzf3 :: *)
                    ~R# (Max a_Xfzf3 -> Max a_Xfzf3 :: *)))
        ((\ (eta_Xrd :: Integer) ->
            fromInteger @ a_Xfzf3 $dNum_Xfzf5 eta_Xrd)
         `cast` (<Integer>_R ->_R Sym (Data.Semigroup.N:Max[0] <a_Xfzf3>_R)
                 :: (Integer -> a_Xfzf3 :: *) ~R# (Integer -> Max a_Xfzf3 :: *)))

-- RHS size: {terms: 12, types: 18, coercions: 0, joins: 0/0}
Data.Semigroup.$fFunctorArg_$cfmap
  :: forall a1 a2 b. (a2 -> b) -> Arg a1 a2 -> Arg a1 b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyZx)
                 (@ a1_afyZB)
                 (@ b_afyZC)
                 (f_afwOe [Occ=Once!] :: a1_afyZB -> b_afyZC)
                 (ds_dfzMq [Occ=Once!] :: Arg a_afyZx a1_afyZB) ->
                 case ds_dfzMq of { Arg x_afwOf [Occ=Once] a2_afwOg [Occ=Once] ->
                 Data.Semigroup.Arg @ a_afyZx @ b_afyZC x_afwOf (f_afwOe a2_afwOg)
                 }}]
Data.Semigroup.$fFunctorArg_$cfmap
  = \ (@ a_afyZx)
      (@ a1_afyZB)
      (@ b_afyZC)
      (f_afwOe :: a1_afyZB -> b_afyZC)
      (ds_dfzMq :: Arg a_afyZx a1_afyZB) ->
      case ds_dfzMq of { Arg x_afwOf a2_afwOg ->
      Data.Semigroup.Arg @ a_afyZx @ b_afyZC x_afwOf (f_afwOe a2_afwOg)
      }

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
Data.Semigroup.$fFunctorArg_$c<$
  :: forall a1 a2 b. a2 -> Arg a1 b -> Arg a1 a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U(U,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyZx)
                 (@ a1_afyZJ)
                 (@ b_afyZK)
                 (x_i9DkS [Occ=Once] :: a1_afyZJ)
                 (ds_dfzMq [Occ=Once!] :: Arg a_afyZx b_afyZK) ->
                 case ds_dfzMq of { Arg x1_afwOf [Occ=Once] _ [Occ=Dead] ->
                 Data.Semigroup.Arg @ a_afyZx @ a1_afyZJ x1_afwOf x_i9DkS
                 }}]
Data.Semigroup.$fFunctorArg_$c<$
  = \ (@ a_afyZx)
      (@ a1_afyZJ)
      (@ b_afyZK)
      (x_i9DkS :: a1_afyZJ)
      (ds_dfzMq :: Arg a_afyZx b_afyZK) ->
      case ds_dfzMq of { Arg x1_afwOf a2_afwOg ->
      Data.Semigroup.Arg @ a_afyZx @ a1_afyZJ x1_afwOf x_i9DkS
      }

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Semigroup.$fFunctorArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Functor (Arg a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_afwOd) ->
       GHC.Base.C:Functor TYPE: Arg a_afwOd
                          Data.Semigroup.$fFunctorArg_$cfmap @ a_afwOd
                          Data.Semigroup.$fFunctorArg_$c<$ @ a_afwOd]
Data.Semigroup.$fFunctorArg
  = \ (@ a_afyZx) ->
      GHC.Base.C:Functor
        @ (Arg a_afyZx)
        (Data.Semigroup.$fFunctorArg_$cfmap @ a_afyZx)
        (Data.Semigroup.$fFunctorArg_$c<$ @ a_afyZx)

-- RHS size: {terms: 11, types: 18, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableArg_$cfoldMap
  :: forall a1 m a2. Monoid m => (a2 -> m) -> Arg a1 a2 -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*U(A,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyX6)
                 (@ m_afyXk)
                 (@ a1_afyXl)
                 _ [Occ=Dead]
                 (f_afwOb [Occ=Once!] :: a1_afyXl -> m_afyXk)
                 (ds_dfzMi [Occ=Once!] :: Arg a_afyX6 a1_afyXl) ->
                 case ds_dfzMi of { Arg _ [Occ=Dead] a2_afwOc [Occ=Once] ->
                 f_afwOb a2_afwOc
                 }}]
Data.Semigroup.$fFoldableArg_$cfoldMap
  = \ (@ a_afyX6)
      (@ m_afyXk)
      (@ a1_afyXl)
      _ [Occ=Dead]
      (f_afwOb :: a1_afyXl -> m_afyXk)
      (ds_dfzMi :: Arg a_afyX6 a1_afyXl) ->
      case ds_dfzMi of { Arg ds1_dfzMp a2_afwOc -> f_afwOb a2_afwOc }

-- RHS size: {terms: 8, types: 14, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableArg_$cfold
  :: forall a m. Monoid m => Arg a m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyX6)
                 (@ m_afyXa)
                 _ [Occ=Dead]
                 (ds_dfzMi [Occ=Once!] :: Arg a_afyX6 m_afyXa) ->
                 case ds_dfzMi of { Arg _ [Occ=Dead] a1_afwOc [Occ=Once] ->
                 a1_afwOc
                 }}]
Data.Semigroup.$fFoldableArg_$cfold
  = \ (@ a_afyX6)
      (@ m_afyXa)
      _ [Occ=Dead]
      (ds_dfzMi :: Arg a_afyX6 m_afyXa) ->
      case ds_dfzMi of { Arg ds1_dfzMp a1_afwOc -> a1_afwOc }

-- RHS size: {terms: 8, types: 14, coercions: 3, joins: 0/0}
Data.Semigroup.$fFoldableArg2
  :: forall a1 a2. Num a2 => Arg a1 a2 -> Sum a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyX6)
                 (@ a1_afyZe)
                 _ [Occ=Dead]
                 (eta_XdL [Occ=Once!] :: Arg a_afyX6 a1_afyZe) ->
                 case eta_XdL of { Arg _ [Occ=Dead] a2_afwOc [Occ=Once] ->
                 a2_afwOc
                 `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a1_afyZe>_R)
                         :: (a1_afyZe :: *) ~R# (Sum a1_afyZe :: *))
                 }}]
Data.Semigroup.$fFoldableArg2
  = \ (@ a_afyX6)
      (@ a1_afyZe)
      _ [Occ=Dead]
      (eta_XdL :: Arg a_afyX6 a1_afyZe) ->
      case eta_XdL of { Arg ds_dfzMp a2_afwOc ->
      a2_afwOc
      `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a1_afyZe>_R)
              :: (a1_afyZe :: *) ~R# (Sum a1_afyZe :: *))
      }

-- RHS size: {terms: 7, types: 12, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableArg3 :: forall a1 a2. Arg a2 a1 -> a1
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyZ4)
                 (@ a1_XfzaT)
                 (x_ifzGk [Occ=Once!] :: Arg a1_XfzaT a_afyZ4) ->
                 case x_ifzGk of { Arg _ [Occ=Dead] a2_afwOc [Occ=Once] ->
                 a2_afwOc
                 }}]
Data.Semigroup.$fFoldableArg3
  = \ (@ a_afyZ4) (@ a1_XfzaT) (x_ifzGk :: Arg a1_XfzaT a_afyZ4) ->
      case x_ifzGk of { Arg ds_dfzMp a2_afwOc -> a2_afwOc }

-- RHS size: {terms: 4, types: 8, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableArg_$cminimum
  :: forall a1 a2. Ord a2 => Arg a1 a2 -> a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_XfzaT) (@ a1_afyZ4) _ [Occ=Dead] ->
                 Data.Semigroup.$fFoldableArg3 @ a1_afyZ4 @ a_XfzaT}]
Data.Semigroup.$fFoldableArg_$cminimum
  = \ (@ a_XfzaT) (@ a1_afyZ4) _ [Occ=Dead] ->
      Data.Semigroup.$fFoldableArg3 @ a1_afyZ4 @ a_XfzaT

-- RHS size: {terms: 14, types: 18, coercions: 7, joins: 0/1}
Data.Semigroup.$fFoldableArg_$celem
  :: forall a1 a2. Eq a2 => a2 -> Arg a1 a2 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XfzaV)
                 (@ a1_afyYK)
                 ($dEq_afyYM [Occ=Once] :: Eq a1_afyYK)
                 (eta_XdT [Occ=Once] :: a1_afyYK) ->
                 let {
                   f_sfAiu [Occ=OnceL!] :: a1_afyYK -> Bool
                   [LclId]
                   f_sfAiu = == @ a1_afyYK $dEq_afyYM eta_XdT } in
                 (\ (ds_dfzMi [Occ=Once!] :: Arg a_XfzaV a1_afyYK) ->
                    case ds_dfzMi of { Arg _ [Occ=Dead] a2_afwOc [Occ=Once] ->
                    (f_sfAiu a2_afwOc)
                    `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                            :: (Bool :: *) ~R# (Any :: *))
                    })
                 `cast` (<Arg a_XfzaV a1_afyYK>_R
                         ->_R Data.Semigroup.Internal.N:Any[0]
                         :: (Arg a_XfzaV a1_afyYK -> Any :: *)
                            ~R# (Arg a_XfzaV a1_afyYK -> Bool :: *))}]
Data.Semigroup.$fFoldableArg_$celem
  = \ (@ a_XfzaV)
      (@ a1_afyYK)
      ($dEq_afyYM :: Eq a1_afyYK)
      (eta_XdT :: a1_afyYK) ->
      let {
        f_sfAiu [Dmd=<L,C(U)>] :: a1_afyYK -> Bool
        [LclId]
        f_sfAiu = == @ a1_afyYK $dEq_afyYM eta_XdT } in
      (\ (ds_dfzMi :: Arg a_XfzaV a1_afyYK) ->
         case ds_dfzMi of { Arg ds1_dfzMp a2_afwOc ->
         (f_sfAiu a2_afwOc)
         `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                 :: (Bool :: *) ~R# (Any :: *))
         })
      `cast` (<Arg a_XfzaV a1_afyYK>_R
              ->_R Data.Semigroup.Internal.N:Any[0]
              :: (Arg a_XfzaV a1_afyYK -> Any :: *)
                 ~R# (Arg a_XfzaV a1_afyYK -> Bool :: *))

-- RHS size: {terms: 12, types: 18, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableArg_$cfoldl
  :: forall a1 b a2. (b -> a2 -> b) -> b -> Arg a1 a2 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XfzaZ)
                 (@ b_afyXM)
                 (@ a1_afyXN)
                 (f_XfzUa [Occ=Once!] :: b_afyXM -> a1_afyXN -> b_afyXM)
                 (z_XfzUc [Occ=Once] :: b_afyXM)
                 (t1_XfzUe [Occ=Once!] :: Arg a_XfzaZ a1_afyXN) ->
                 case t1_XfzUe of { Arg _ [Occ=Dead] a2_afwOc [Occ=Once] ->
                 f_XfzUa z_XfzUc a2_afwOc
                 }}]
Data.Semigroup.$fFoldableArg_$cfoldl
  = \ (@ a_XfzaZ)
      (@ b_afyXM)
      (@ a1_afyXN)
      (f_XfzUa :: b_afyXM -> a1_afyXN -> b_afyXM)
      (z_XfzUc :: b_afyXM)
      (t1_XfzUe :: Arg a_XfzaZ a1_afyXN) ->
      case t1_XfzUe of { Arg ds_dfzMp a2_afwOc ->
      f_XfzUa z_XfzUc a2_afwOc
      }

-- RHS size: {terms: 8, types: 15, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableArg_$cfoldl1
  :: forall a1 a2. (a2 -> a2 -> a2) -> Arg a1 a2 -> a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xfzb0)
                 (@ a1_afyYe)
                 _ [Occ=Dead]
                 (xs_XfzTg [Occ=Once!] :: Arg a_Xfzb0 a1_afyYe) ->
                 case xs_XfzTg of { Arg _ [Occ=Dead] a2_afwOc [Occ=Once] ->
                 a2_afwOc
                 }}]
Data.Semigroup.$fFoldableArg_$cfoldl1
  = \ (@ a_Xfzb0)
      (@ a1_afyYe)
      _ [Occ=Dead]
      (xs_XfzTg :: Arg a_Xfzb0 a1_afyYe) ->
      case xs_XfzTg of { Arg ds_dfzMp a2_afwOc -> a2_afwOc }

-- RHS size: {terms: 12, types: 18, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableArg_$cfoldr'
  :: forall a1 a2 b. (a2 -> b -> b) -> b -> Arg a1 a2 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xfzb1)
                 (@ a1_afyXC)
                 (@ b_afyXD)
                 (f_ifzEu [Occ=Once!] :: a1_afyXC -> b_afyXD -> b_afyXD)
                 (z0_ifzEv [Occ=Once] :: b_afyXD)
                 (xs_ifzEw [Occ=Once!] :: Arg a_Xfzb1 a1_afyXC) ->
                 case xs_ifzEw of { Arg _ [Occ=Dead] a2_afwOc [Occ=Once] ->
                 f_ifzEu a2_afwOc z0_ifzEv
                 }}]
Data.Semigroup.$fFoldableArg_$cfoldr'
  = \ (@ a_Xfzb1)
      (@ a1_afyXC)
      (@ b_afyXD)
      (f_ifzEu :: a1_afyXC -> b_afyXD -> b_afyXD)
      (z0_ifzEv :: b_afyXD)
      (xs_ifzEw :: Arg a_Xfzb1 a1_afyXC) ->
      case xs_ifzEw of { Arg ds_dfzMp a2_afwOc ->
      f_ifzEu a2_afwOc z0_ifzEv
      }

-- RHS size: {terms: 7, types: 12, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableArg_$clength
  :: forall a1 a2. Arg a1 a2 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xfzb4)
                 (@ a1_afyYC)
                 (xs_ifzER [Occ=Once!] :: Arg a_Xfzb4 a1_afyYC) ->
                 case xs_ifzER of { Arg _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.I# 1#
                 }}]
Data.Semigroup.$fFoldableArg_$clength
  = \ (@ a_Xfzb4) (@ a1_afyYC) (xs_ifzER :: Arg a_Xfzb4 a1_afyYC) ->
      case xs_ifzER of { Arg ds_dfzMp a2_afwOc ->
      Data.Semigroup.$fFoldableFirst3
      }

-- RHS size: {terms: 7, types: 12, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableArg_$cnull
  :: forall a1 a2. Arg a1 a2 -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xfzb6)
                 (@ a1_afyYu)
                 (t1_ifzEp [Occ=Once!] :: Arg a_Xfzb6 a1_afyYu) ->
                 case t1_ifzEp of { Arg _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.False
                 }}]
Data.Semigroup.$fFoldableArg_$cnull
  = \ (@ a_Xfzb6) (@ a1_afyYu) (t1_ifzEp :: Arg a_Xfzb6 a1_afyYu) ->
      case t1_ifzEp of { Arg ds_dfzMp a2_afwOc -> GHC.Types.False }

-- RHS size: {terms: 8, types: 14, coercions: 3, joins: 0/0}
Data.Semigroup.$fFoldableArg1
  :: forall a1 a2. Num a2 => Arg a1 a2 -> Product a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xfzb7)
                 (@ a1_afyZo)
                 _ [Occ=Dead]
                 (eta_Xe5 [Occ=Once!] :: Arg a_Xfzb7 a1_afyZo) ->
                 case eta_Xe5 of { Arg _ [Occ=Dead] a2_afwOc [Occ=Once] ->
                 a2_afwOc
                 `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a1_afyZo>_R)
                         :: (a1_afyZo :: *) ~R# (Product a1_afyZo :: *))
                 }}]
Data.Semigroup.$fFoldableArg1
  = \ (@ a_Xfzb7)
      (@ a1_afyZo)
      _ [Occ=Dead]
      (eta_Xe5 :: Arg a_Xfzb7 a1_afyZo) ->
      case eta_Xe5 of { Arg ds_dfzMp a2_afwOc ->
      a2_afwOc
      `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a1_afyZo>_R)
              :: (a1_afyZo :: *) ~R# (Product a1_afyZo :: *))
      }

-- RHS size: {terms: 9, types: 14, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableArg_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a1 a2. Arg a1 a2 -> [a2]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(A,U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_Xfzbd)
                 (@ a1_afyYm)
                 (t1_ifzFB [Occ=Once!] :: Arg a_Xfzbd a1_afyYm) ->
                 GHC.Base.build
                   @ a1_afyYm
                   (\ (@ b_ifzFC)
                      (c_ifzFD [Occ=Once!, OS=OneShot] :: a1_afyYm -> b_ifzFC -> b_ifzFC)
                      (n_ifzFE [Occ=Once, OS=OneShot] :: b_ifzFC) ->
                      case t1_ifzFB of { Arg _ [Occ=Dead] a2_afwOc [Occ=Once] ->
                      c_ifzFD a2_afwOc n_ifzFE
                      })}]
Data.Semigroup.$fFoldableArg_$ctoList
  = \ (@ a_Xfzbd) (@ a1_afyYm) (eta_Xfk :: Arg a_Xfzbd a1_afyYm) ->
      case eta_Xfk of { Arg ds_dfzMp a2_afwOc ->
      GHC.Types.: @ a1_afyYm a2_afwOc (GHC.Types.[] @ a1_afyYm)
      }

-- RHS size: {terms: 18, types: 20, coercions: 24, joins: 0/0}
Data.Semigroup.$fFoldableArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Foldable (Arg a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ (@ a_afwOa) ->
       Data.Foldable.C:Foldable TYPE: Arg a_afwOa
                                Data.Semigroup.$fFoldableArg_$cfold @ a_afwOa
                                Data.Semigroup.$fFoldableArg_$cfoldMap @ a_afwOa
                                Data.Semigroup.$fFoldableArg_$cfoldr' @ a_afwOa
                                Data.Semigroup.$fFoldableArg_$cfoldr' @ a_afwOa
                                Data.Semigroup.$fFoldableArg_$cfoldl @ a_afwOa
                                Data.Semigroup.$fFoldableArg_$cfoldl @ a_afwOa
                                Data.Semigroup.$fFoldableArg_$cfoldl1 @ a_afwOa
                                Data.Semigroup.$fFoldableArg_$cfoldl1 @ a_afwOa
                                Data.Semigroup.$fFoldableArg_$ctoList @ a_afwOa
                                Data.Semigroup.$fFoldableArg_$cnull @ a_afwOa
                                Data.Semigroup.$fFoldableArg_$clength @ a_afwOa
                                Data.Semigroup.$fFoldableArg_$celem @ a_afwOa
                                Data.Semigroup.$fFoldableArg_$cminimum @ a_afwOa
                                Data.Semigroup.$fFoldableArg_$cminimum @ a_afwOa
                                (Data.Semigroup.$fFoldableArg2 @ a_afwOa)
                                `cast` (forall (a1 :: <*>_N).
                                        <Num a1>_R
                                        ->_R <Arg a_afwOa a1>_R
                                        ->_R Data.Semigroup.Internal.N:Sum[0] <a1>_R
                                        :: (forall a1. Num a1 => Arg a_afwOa a1 -> Sum a1 :: *)
                                           ~R# (forall a1. Num a1 => Arg a_afwOa a1 -> a1 :: *))
                                (Data.Semigroup.$fFoldableArg1 @ a_afwOa)
                                `cast` (forall (a1 :: <*>_N).
                                        <Num a1>_R
                                        ->_R <Arg a_afwOa a1>_R
                                        ->_R Data.Semigroup.Internal.N:Product[0] <a1>_R
                                        :: (forall a1. Num a1 => Arg a_afwOa a1 -> Product a1 :: *)
                                           ~R# (forall a1. Num a1 => Arg a_afwOa a1 -> a1 :: *))]
Data.Semigroup.$fFoldableArg
  = \ (@ a_Xfzbe) ->
      Data.Foldable.C:Foldable
        @ (Arg a_Xfzbe)
        (Data.Semigroup.$fFoldableArg_$cfold @ a_Xfzbe)
        (Data.Semigroup.$fFoldableArg_$cfoldMap @ a_Xfzbe)
        (Data.Semigroup.$fFoldableArg_$cfoldr' @ a_Xfzbe)
        (Data.Semigroup.$fFoldableArg_$cfoldr' @ a_Xfzbe)
        (Data.Semigroup.$fFoldableArg_$cfoldl @ a_Xfzbe)
        (Data.Semigroup.$fFoldableArg_$cfoldl @ a_Xfzbe)
        (Data.Semigroup.$fFoldableArg_$cfoldl1 @ a_Xfzbe)
        (Data.Semigroup.$fFoldableArg_$cfoldl1 @ a_Xfzbe)
        (Data.Semigroup.$fFoldableArg_$ctoList @ a_Xfzbe)
        (Data.Semigroup.$fFoldableArg_$cnull @ a_Xfzbe)
        (Data.Semigroup.$fFoldableArg_$clength @ a_Xfzbe)
        (Data.Semigroup.$fFoldableArg_$celem @ a_Xfzbe)
        (Data.Semigroup.$fFoldableArg_$cminimum @ a_Xfzbe)
        (Data.Semigroup.$fFoldableArg_$cminimum @ a_Xfzbe)
        ((Data.Semigroup.$fFoldableArg2 @ a_Xfzbe)
         `cast` (forall (a1 :: <*>_N).
                 <Num a1>_R
                 ->_R <Arg a_Xfzbe a1>_R
                 ->_R Data.Semigroup.Internal.N:Sum[0] <a1>_R
                 :: (forall a1. Num a1 => Arg a_Xfzbe a1 -> Sum a1 :: *)
                    ~R# (forall a1. Num a1 => Arg a_Xfzbe a1 -> a1 :: *)))
        ((Data.Semigroup.$fFoldableArg1 @ a_Xfzbe)
         `cast` (forall (a1 :: <*>_N).
                 <Num a1>_R
                 ->_R <Arg a_Xfzbe a1>_R
                 ->_R Data.Semigroup.Internal.N:Product[0] <a1>_R
                 :: (forall a1. Num a1 => Arg a_Xfzbe a1 -> Product a1 :: *)
                    ~R# (forall a1. Num a1 => Arg a_Xfzbe a1 -> a1 :: *)))

-- RHS size: {terms: 17, types: 31, coercions: 0, joins: 0/0}
Data.Semigroup.$fTraversableArg_$ctraverse
  :: forall a1 (f :: * -> *) a2 b.
     Applicative f =>
     (a2 -> f b) -> Arg a1 a2 -> f (Arg a1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyW4)
                 (@ (f_afyWg :: * -> *))
                 (@ a1_afyWh)
                 (@ b_afyWi)
                 ($dApplicative_afyWk [Occ=Once] :: Applicative f_afyWg)
                 (eta_B2 [Occ=Once!] :: a1_afyWh -> f_afyWg b_afyWi)
                 (eta1_Xeg [Occ=Once!] :: Arg a_afyW4 a1_afyWh) ->
                 case eta1_Xeg of { Arg x_afwO8 [Occ=Once] a2_afwO9 [Occ=Once] ->
                 fmap
                   @ f_afyWg
                   (GHC.Base.$p1Applicative @ f_afyWg $dApplicative_afyWk)
                   @ b_afyWi
                   @ (Arg a_afyW4 b_afyWi)
                   (Data.Semigroup.Arg @ a_afyW4 @ b_afyWi x_afwO8)
                   (eta_B2 a2_afwO9)
                 }}]
Data.Semigroup.$fTraversableArg_$ctraverse
  = \ (@ a_afyW4)
      (@ (f_afyWg :: * -> *))
      (@ a1_afyWh)
      (@ b_afyWi)
      ($dApplicative_afyWk :: Applicative f_afyWg)
      (eta_B2 :: a1_afyWh -> f_afyWg b_afyWi)
      (eta1_Xeg :: Arg a_afyW4 a1_afyWh) ->
      case eta1_Xeg of { Arg x_afwO8 a2_afwO9 ->
      fmap
        @ f_afyWg
        (GHC.Base.$p1Applicative @ f_afyWg $dApplicative_afyWk)
        @ b_afyWi
        @ (Arg a_afyW4 b_afyWi)
        (Data.Semigroup.Arg @ a_afyW4 @ b_afyWi x_afwO8)
        (eta_B2 a2_afwO9)
      }

-- RHS size: {terms: 14, types: 29, coercions: 0, joins: 0/0}
Data.Semigroup.$fTraversableArg_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (f :: * -> *) a2.
     Applicative f =>
     Arg a1 (f a2) -> f (Arg a1 a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_afyW4)
                 (@ (f_afyWv :: * -> *))
                 (@ a1_afyWw)
                 ($dApplicative_afyWy [Occ=Once] :: Applicative f_afyWv)
                 (eta_Xvv [Occ=Once!] :: Arg a_afyW4 (f_afyWv a1_afyWw)) ->
                 case eta_Xvv of { Arg x_afwO8 [Occ=Once] a2_afwO9 [Occ=Once] ->
                 fmap
                   @ f_afyWv
                   (GHC.Base.$p1Applicative @ f_afyWv $dApplicative_afyWy)
                   @ a1_afyWw
                   @ (Arg a_afyW4 a1_afyWw)
                   (Data.Semigroup.Arg @ a_afyW4 @ a1_afyWw x_afwO8)
                   a2_afwO9
                 }}]
Data.Semigroup.$fTraversableArg_$csequenceA
  = \ (@ a_afyW4)
      (@ (f_afyWv :: * -> *))
      (@ a1_afyWw)
      ($dApplicative_afyWy :: Applicative f_afyWv)
      (eta_Xvv :: Arg a_afyW4 (f_afyWv a1_afyWw)) ->
      case eta_Xvv of { Arg x_afwO8 a2_afwO9 ->
      fmap
        @ f_afyWv
        (GHC.Base.$p1Applicative @ f_afyWv $dApplicative_afyWy)
        @ a1_afyWw
        @ (Arg a_afyW4 a1_afyWw)
        (Data.Semigroup.Arg @ a_afyW4 @ a1_afyWw x_afwO8)
        a2_afwO9
      }

-- RHS size: {terms: 18, types: 32, coercions: 0, joins: 0/0}
Data.Semigroup.$fTraversableArg_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2 b.
     Monad m =>
     (a2 -> m b) -> Arg a1 a2 -> m (Arg a1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_afyW4)
                 (@ (m_afyWH :: * -> *))
                 (@ a1_afyWI)
                 (@ b_afyWJ)
                 ($dMonad_afyWL [Occ=OnceL] :: Monad m_afyWH) ->
                 let {
                   $dApplicative_afyWk [Occ=OnceL] :: Applicative m_afyWH
                   [LclId]
                   $dApplicative_afyWk
                     = GHC.Base.$p1Monad @ m_afyWH $dMonad_afyWL } in
                 \ (eta_B2 [Occ=Once!] :: a1_afyWI -> m_afyWH b_afyWJ)
                   (eta1_Xeg [Occ=Once!] :: Arg a_afyW4 a1_afyWI) ->
                   case eta1_Xeg of { Arg x_afwO8 [Occ=Once] a2_afwO9 [Occ=Once] ->
                   fmap
                     @ m_afyWH
                     (GHC.Base.$p1Applicative @ m_afyWH $dApplicative_afyWk)
                     @ b_afyWJ
                     @ (Arg a_afyW4 b_afyWJ)
                     (Data.Semigroup.Arg @ a_afyW4 @ b_afyWJ x_afwO8)
                     (eta_B2 a2_afwO9)
                   }}]
Data.Semigroup.$fTraversableArg_$cmapM
  = \ (@ a_afyW4)
      (@ (m_afyWH :: * -> *))
      (@ a1_afyWI)
      (@ b_afyWJ)
      ($dMonad_afyWL :: Monad m_afyWH)
      (eta_B2 :: a1_afyWI -> m_afyWH b_afyWJ)
      (eta1_Xei :: Arg a_afyW4 a1_afyWI) ->
      case eta1_Xei of { Arg x_afwO8 a2_afwO9 ->
      fmap
        @ m_afyWH
        (GHC.Base.$p1Applicative
           @ m_afyWH (GHC.Base.$p1Monad @ m_afyWH $dMonad_afyWL))
        @ b_afyWJ
        @ (Arg a_afyW4 b_afyWJ)
        (Data.Semigroup.Arg @ a_afyW4 @ b_afyWJ x_afwO8)
        (eta_B2 a2_afwO9)
      }

-- RHS size: {terms: 15, types: 30, coercions: 0, joins: 0/0}
Data.Semigroup.$fTraversableArg_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2.
     Monad m =>
     Arg a1 (m a2) -> m (Arg a1 a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_afyW4)
                 (@ (m_afyWV :: * -> *))
                 (@ a1_afyWW)
                 ($dMonad_afyWY [Occ=OnceL] :: Monad m_afyWV) ->
                 let {
                   $dApplicative_afyWy [Occ=OnceL] :: Applicative m_afyWV
                   [LclId]
                   $dApplicative_afyWy
                     = GHC.Base.$p1Monad @ m_afyWV $dMonad_afyWY } in
                 \ (eta_Xvv [Occ=Once!] :: Arg a_afyW4 (m_afyWV a1_afyWW)) ->
                   case eta_Xvv of { Arg x_afwO8 [Occ=Once] a2_afwO9 [Occ=Once] ->
                   fmap
                     @ m_afyWV
                     (GHC.Base.$p1Applicative @ m_afyWV $dApplicative_afyWy)
                     @ a1_afyWW
                     @ (Arg a_afyW4 a1_afyWW)
                     (Data.Semigroup.Arg @ a_afyW4 @ a1_afyWW x_afwO8)
                     a2_afwO9
                   }}]
Data.Semigroup.$fTraversableArg_$csequence
  = \ (@ a_afyW4)
      (@ (m_afyWV :: * -> *))
      (@ a1_afyWW)
      ($dMonad_afyWY :: Monad m_afyWV)
      (eta_B1 :: Arg a_afyW4 (m_afyWV a1_afyWW)) ->
      case eta_B1 of { Arg x_afwO8 a2_afwO9 ->
      fmap
        @ m_afyWV
        (GHC.Base.$p1Applicative
           @ m_afyWV (GHC.Base.$p1Monad @ m_afyWV $dMonad_afyWY))
        @ a1_afyWW
        @ (Arg a_afyW4 a1_afyWW)
        (Data.Semigroup.Arg @ a_afyW4 @ a1_afyWW x_afwO8)
        a2_afwO9
      }

-- RHS size: {terms: 8, types: 10, coercions: 0, joins: 0/0}
Data.Semigroup.$fTraversableArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Traversable (Arg a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_afwO6) ->
       Data.Traversable.C:Traversable TYPE: Arg a_afwO6
                                      Data.Semigroup.$fFunctorArg @ a_afwO6
                                      Data.Semigroup.$fFoldableArg @ a_afwO6
                                      Data.Semigroup.$fTraversableArg_$ctraverse @ a_afwO6
                                      Data.Semigroup.$fTraversableArg_$csequenceA @ a_afwO6
                                      Data.Semigroup.$fTraversableArg_$cmapM @ a_afwO6
                                      Data.Semigroup.$fTraversableArg_$csequence @ a_afwO6]
Data.Semigroup.$fTraversableArg
  = \ (@ a_afyW4) ->
      Data.Traversable.C:Traversable
        @ (Arg a_afyW4)
        (Data.Semigroup.$fFunctorArg @ a_afyW4)
        (Data.Semigroup.$fFoldableArg @ a_afyW4)
        (Data.Semigroup.$fTraversableArg_$ctraverse @ a_afyW4)
        (Data.Semigroup.$fTraversableArg_$csequenceA @ a_afyW4)
        (Data.Semigroup.$fTraversableArg_$cmapM @ a_afyW4)
        (Data.Semigroup.$fTraversableArg_$csequence @ a_afyW4)

-- RHS size: {terms: 15, types: 23, coercions: 0, joins: 0/0}
Data.Semigroup.$fEqArg_$c==
  :: forall a b. Eq a => Arg a b -> Arg a b -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyVO)
                 (@ b_afyVP)
                 ($dEq_afyVQ [Occ=Once] :: Eq a_afyVO)
                 (ds_dfzLZ [Occ=Once!] :: Arg a_afyVO b_afyVP)
                 (ds1_dfzM0 [Occ=Once!] :: Arg a_afyVO b_afyVP) ->
                 case ds_dfzLZ of { Arg a1_afwO4 [Occ=Once] _ [Occ=Dead] ->
                 case ds1_dfzM0 of { Arg b1_afwO5 [Occ=Once] _ [Occ=Dead] ->
                 == @ a_afyVO $dEq_afyVQ a1_afwO4 b1_afwO5
                 }
                 }}]
Data.Semigroup.$fEqArg_$c==
  = \ (@ a_afyVO)
      (@ b_afyVP)
      ($dEq_afyVQ :: Eq a_afyVO)
      (ds_dfzLZ :: Arg a_afyVO b_afyVP)
      (ds1_dfzM0 :: Arg a_afyVO b_afyVP) ->
      case ds_dfzLZ of { Arg a1_afwO4 ds2_dfzMa ->
      case ds1_dfzM0 of { Arg b1_afwO5 ds3_dfzMb ->
      == @ a_afyVO $dEq_afyVQ a1_afwO4 b1_afwO5
      }
      }

-- RHS size: {terms: 20, types: 24, coercions: 0, joins: 0/0}
Data.Semigroup.$fEqArg_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a b. Eq a => Arg a b -> Arg a b -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_afyVO)
                 (@ b_afyVP)
                 ($dEq_afyVQ [Occ=Once] :: Eq a_afyVO)
                 (x_a22b [Occ=Once!] :: Arg a_afyVO b_afyVP)
                 (y_a22c [Occ=Once!] :: Arg a_afyVO b_afyVP) ->
                 case x_a22b of { Arg a1_afwO4 [Occ=Once] _ [Occ=Dead] ->
                 case y_a22c of { Arg b1_afwO5 [Occ=Once] _ [Occ=Dead] ->
                 case == @ a_afyVO $dEq_afyVQ a1_afwO4 b1_afwO5 of {
                   False -> GHC.Types.True;
                   True -> GHC.Types.False
                 }
                 }
                 }}]
Data.Semigroup.$fEqArg_$c/=
  = \ (@ a_afyVO)
      (@ b_afyVP)
      ($dEq_afyVQ :: Eq a_afyVO)
      (eta_XfM :: Arg a_afyVO b_afyVP)
      (eta1_Xvx :: Arg a_afyVO b_afyVP) ->
      case eta_XfM of { Arg a1_afwO4 ds_dfzMa ->
      case eta1_Xvx of { Arg b1_afwO5 ds1_dfzMb ->
      case == @ a_afyVO $dEq_afyVQ a1_afwO4 b1_afwO5 of {
        False -> GHC.Types.True;
        True -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 8, types: 13, coercions: 0, joins: 0/0}
Data.Semigroup.$fEqArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. Eq a => Eq (Arg a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)>m,
 Unf=DFun: \ (@ a_afwO2) (@ b_afwO3) (v_XfJ :: Eq a_afwO2) ->
       GHC.Classes.C:Eq TYPE: Arg a_afwO2 b_afwO3
                        Data.Semigroup.$fEqArg_$c== @ a_afwO2 @ b_afwO3 v_XfJ
                        Data.Semigroup.$fEqArg_$c/= @ a_afwO2 @ b_afwO3 v_XfJ]
Data.Semigroup.$fEqArg
  = \ (@ a_afyVO) (@ b_afyVP) ($dEq_afyVQ :: Eq a_afyVO) ->
      GHC.Classes.C:Eq
        @ (Arg a_afyVO b_afyVP)
        (Data.Semigroup.$fEqArg_$c== @ a_afyVO @ b_afyVP $dEq_afyVQ)
        (Data.Semigroup.$fEqArg_$c/= @ a_afyVO @ b_afyVP $dEq_afyVQ)

-- RHS size: {terms: 20, types: 24, coercions: 0, joins: 0/0}
Data.Semigroup.$fOrdArg_$cmin
  :: forall a b. Ord a => Arg a b -> Arg a b -> Arg a b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyV3)
                 (@ b_afyV4)
                 ($dOrd_afyV5 [Occ=Once] :: Ord a_afyV3)
                 (x_afwNU [Occ=Once!] :: Arg a_afyV3 b_afyV4)
                 (y_afwNW [Occ=Once!] :: Arg a_afyV3 b_afyV4) ->
                 case x_afwNU of wild_XfN { Arg a1_afwNV [Occ=Once] _ [Occ=Dead] ->
                 case y_afwNW of wild1_X2p { Arg b1_afwNX [Occ=Once] _ [Occ=Dead] ->
                 case <= @ a_afyV3 $dOrd_afyV5 a1_afwNV b1_afwNX of {
                   False -> wild1_X2p;
                   True -> wild_XfN
                 }
                 }
                 }}]
Data.Semigroup.$fOrdArg_$cmin
  = \ (@ a_afyV3)
      (@ b_afyV4)
      ($dOrd_afyV5 :: Ord a_afyV3)
      (x_afwNU :: Arg a_afyV3 b_afyV4)
      (y_afwNW :: Arg a_afyV3 b_afyV4) ->
      case x_afwNU of wild_XfN { Arg a1_afwNV ds_dfzLV ->
      case y_afwNW of wild1_X2p { Arg b1_afwNX ds1_dfzLW ->
      case <= @ a_afyV3 $dOrd_afyV5 a1_afwNV b1_afwNX of {
        False -> wild1_X2p;
        True -> wild_XfN
      }
      }
      }

-- RHS size: {terms: 20, types: 24, coercions: 0, joins: 0/0}
Data.Semigroup.$fOrdArg_$cmax
  :: forall a b. Ord a => Arg a b -> Arg a b -> Arg a b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyV3)
                 (@ b_afyV4)
                 ($dOrd_afyV5 [Occ=Once] :: Ord a_afyV3)
                 (x_afwNY [Occ=Once!] :: Arg a_afyV3 b_afyV4)
                 (y_afwO0 [Occ=Once!] :: Arg a_afyV3 b_afyV4) ->
                 case x_afwNY of wild_XfO { Arg a1_afwNZ [Occ=Once] _ [Occ=Dead] ->
                 case y_afwO0 of wild1_X2q { Arg b1_afwO1 [Occ=Once] _ [Occ=Dead] ->
                 case >= @ a_afyV3 $dOrd_afyV5 a1_afwNZ b1_afwO1 of {
                   False -> wild1_X2q;
                   True -> wild_XfO
                 }
                 }
                 }}]
Data.Semigroup.$fOrdArg_$cmax
  = \ (@ a_afyV3)
      (@ b_afyV4)
      ($dOrd_afyV5 :: Ord a_afyV3)
      (x_afwNY :: Arg a_afyV3 b_afyV4)
      (y_afwO0 :: Arg a_afyV3 b_afyV4) ->
      case x_afwNY of wild_XfO { Arg a1_afwNZ ds_dfzLF ->
      case y_afwO0 of wild1_X2q { Arg b1_afwO1 ds1_dfzLG ->
      case >= @ a_afyV3 $dOrd_afyV5 a1_afwNZ b1_afwO1 of {
        False -> wild1_X2q;
        True -> wild_XfO
      }
      }
      }

-- RHS size: {terms: 15, types: 23, coercions: 0, joins: 0/0}
Data.Semigroup.$fOrdArg_$ccompare
  :: forall a b. Ord a => Arg a b -> Arg a b -> Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyV3)
                 (@ b_afyV4)
                 ($dOrd_afyV5 [Occ=Once] :: Ord a_afyV3)
                 (ds_dfzLf [Occ=Once!] :: Arg a_afyV3 b_afyV4)
                 (ds1_dfzLg [Occ=Once!] :: Arg a_afyV3 b_afyV4) ->
                 case ds_dfzLf of { Arg a1_afwNS [Occ=Once] _ [Occ=Dead] ->
                 case ds1_dfzLg of { Arg b1_afwNT [Occ=Once] _ [Occ=Dead] ->
                 compare @ a_afyV3 $dOrd_afyV5 a1_afwNS b1_afwNT
                 }
                 }}]
Data.Semigroup.$fOrdArg_$ccompare
  = \ (@ a_afyV3)
      (@ b_afyV4)
      ($dOrd_afyV5 :: Ord a_afyV3)
      (ds_dfzLf :: Arg a_afyV3 b_afyV4)
      (ds1_dfzLg :: Arg a_afyV3 b_afyV4) ->
      case ds_dfzLf of { Arg a1_afwNS ds2_dfzLr ->
      case ds1_dfzLg of { Arg b1_afwNT ds3_dfzLs ->
      compare @ a_afyV3 $dOrd_afyV5 a1_afwNS b1_afwNT
      }
      }

-- RHS size: {terms: 6, types: 9, coercions: 0, joins: 0/0}
Data.Semigroup.$fOrdArg_$cp1Ord
  :: forall a b. Ord a => Eq (Arg a b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyV3)
                 (@ b_afyV4)
                 ($dOrd_afyV5 [Occ=Once] :: Ord a_afyV3) ->
                 Data.Semigroup.$fEqArg
                   @ a_afyV3 @ b_afyV4 (GHC.Classes.$p1Ord @ a_afyV3 $dOrd_afyV5)}]
Data.Semigroup.$fOrdArg_$cp1Ord
  = \ (@ a_afyV3) (@ b_afyV4) ($dOrd_afyV5 :: Ord a_afyV3) ->
      Data.Semigroup.$fEqArg
        @ a_afyV3 @ b_afyV4 (GHC.Classes.$p1Ord @ a_afyV3 $dOrd_afyV5)

-- RHS size: {terms: 20, types: 24, coercions: 0, joins: 0/0}
Data.Semigroup.$fOrdArg_$c<
  :: forall a b. Ord a => Arg a b -> Arg a b -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyV3)
                 (@ b_afyV4)
                 ($dOrd_afyV5 [Occ=Once] :: Ord a_afyV3)
                 (x_a1MiF [Occ=Once!] :: Arg a_afyV3 b_afyV4)
                 (y_a1MiG [Occ=Once!] :: Arg a_afyV3 b_afyV4) ->
                 case x_a1MiF of { Arg a1_afwNS [Occ=Once] _ [Occ=Dead] ->
                 case y_a1MiG of { Arg b1_afwNT [Occ=Once] _ [Occ=Dead] ->
                 case compare @ a_afyV3 $dOrd_afyV5 a1_afwNS b1_afwNT of {
                   __DEFAULT -> GHC.Types.False;
                   LT -> GHC.Types.True
                 }
                 }
                 }}]
Data.Semigroup.$fOrdArg_$c<
  = \ (@ a_afyV3)
      (@ b_afyV4)
      ($dOrd_afyV5 :: Ord a_afyV3)
      (x_a1MiF :: Arg a_afyV3 b_afyV4)
      (y_a1MiG :: Arg a_afyV3 b_afyV4) ->
      case x_a1MiF of { Arg a1_afwNS ds_dfzLr ->
      case y_a1MiG of { Arg b1_afwNT ds1_dfzLs ->
      case compare @ a_afyV3 $dOrd_afyV5 a1_afwNS b1_afwNT of {
        __DEFAULT -> GHC.Types.False;
        LT -> GHC.Types.True
      }
      }
      }

-- RHS size: {terms: 20, types: 24, coercions: 0, joins: 0/0}
Data.Semigroup.$fOrdArg_$c>
  :: forall a b. Ord a => Arg a b -> Arg a b -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyV3)
                 (@ b_afyV4)
                 ($dOrd_afyV5 [Occ=Once] :: Ord a_afyV3)
                 (x_a1fiM [Occ=Once!] :: Arg a_afyV3 b_afyV4)
                 (y_a1fiN [Occ=Once!] :: Arg a_afyV3 b_afyV4) ->
                 case x_a1fiM of { Arg a1_afwNS [Occ=Once] _ [Occ=Dead] ->
                 case y_a1fiN of { Arg b1_afwNT [Occ=Once] _ [Occ=Dead] ->
                 case compare @ a_afyV3 $dOrd_afyV5 a1_afwNS b1_afwNT of {
                   __DEFAULT -> GHC.Types.False;
                   GT -> GHC.Types.True
                 }
                 }
                 }}]
Data.Semigroup.$fOrdArg_$c>
  = \ (@ a_afyV3)
      (@ b_afyV4)
      ($dOrd_afyV5 :: Ord a_afyV3)
      (x_a1fiM :: Arg a_afyV3 b_afyV4)
      (y_a1fiN :: Arg a_afyV3 b_afyV4) ->
      case x_a1fiM of { Arg a1_afwNS ds_dfzLr ->
      case y_a1fiN of { Arg b1_afwNT ds1_dfzLs ->
      case compare @ a_afyV3 $dOrd_afyV5 a1_afwNS b1_afwNT of {
        __DEFAULT -> GHC.Types.False;
        GT -> GHC.Types.True
      }
      }
      }

-- RHS size: {terms: 20, types: 24, coercions: 0, joins: 0/0}
Data.Semigroup.$fOrdArg_$c<=
  :: forall a b. Ord a => Arg a b -> Arg a b -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyV3)
                 (@ b_afyV4)
                 ($dOrd_afyV5 [Occ=Once] :: Ord a_afyV3)
                 (x_a1MiL [Occ=Once!] :: Arg a_afyV3 b_afyV4)
                 (y_a1MiM [Occ=Once!] :: Arg a_afyV3 b_afyV4) ->
                 case x_a1MiL of { Arg a1_afwNS [Occ=Once] _ [Occ=Dead] ->
                 case y_a1MiM of { Arg b1_afwNT [Occ=Once] _ [Occ=Dead] ->
                 case compare @ a_afyV3 $dOrd_afyV5 a1_afwNS b1_afwNT of {
                   __DEFAULT -> GHC.Types.True;
                   GT -> GHC.Types.False
                 }
                 }
                 }}]
Data.Semigroup.$fOrdArg_$c<=
  = \ (@ a_afyV3)
      (@ b_afyV4)
      ($dOrd_afyV5 :: Ord a_afyV3)
      (x_a1MiL :: Arg a_afyV3 b_afyV4)
      (y_a1MiM :: Arg a_afyV3 b_afyV4) ->
      case x_a1MiL of { Arg a1_afwNS ds_dfzLr ->
      case y_a1MiM of { Arg b1_afwNT ds1_dfzLs ->
      case compare @ a_afyV3 $dOrd_afyV5 a1_afwNS b1_afwNT of {
        __DEFAULT -> GHC.Types.True;
        GT -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 20, types: 24, coercions: 0, joins: 0/0}
Data.Semigroup.$fOrdArg_$c>=
  :: forall a b. Ord a => Arg a b -> Arg a b -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(U,A)><S,1*U(U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyV3)
                 (@ b_afyV4)
                 ($dOrd_afyV5 [Occ=Once] :: Ord a_afyV3)
                 (x_a1fiT [Occ=Once!] :: Arg a_afyV3 b_afyV4)
                 (y_a1fiU [Occ=Once!] :: Arg a_afyV3 b_afyV4) ->
                 case x_a1fiT of { Arg a1_afwNS [Occ=Once] _ [Occ=Dead] ->
                 case y_a1fiU of { Arg b1_afwNT [Occ=Once] _ [Occ=Dead] ->
                 case compare @ a_afyV3 $dOrd_afyV5 a1_afwNS b1_afwNT of {
                   __DEFAULT -> GHC.Types.True;
                   LT -> GHC.Types.False
                 }
                 }
                 }}]
Data.Semigroup.$fOrdArg_$c>=
  = \ (@ a_afyV3)
      (@ b_afyV4)
      ($dOrd_afyV5 :: Ord a_afyV3)
      (x_a1fiT :: Arg a_afyV3 b_afyV4)
      (y_a1fiU :: Arg a_afyV3 b_afyV4) ->
      case x_a1fiT of { Arg a1_afwNS ds_dfzLr ->
      case y_a1fiU of { Arg b1_afwNT ds1_dfzLs ->
      case compare @ a_afyV3 $dOrd_afyV5 a1_afwNS b1_afwNT of {
        __DEFAULT -> GHC.Types.True;
        LT -> GHC.Types.False
      }
      }
      }

-- RHS size: {terms: 20, types: 25, coercions: 0, joins: 0/0}
Data.Semigroup.$fOrdArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. Ord a => Ord (Arg a b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,C(C1(U)),A,C(C1(U)),A,A)>m,
 Unf=DFun: \ (@ a_afwNQ) (@ b_afwNR) (v_XfP :: Ord a_afwNQ) ->
       GHC.Classes.C:Ord TYPE: Arg a_afwNQ b_afwNR
                         Data.Semigroup.$fOrdArg_$cp1Ord @ a_afwNQ @ b_afwNR v_XfP
                         Data.Semigroup.$fOrdArg_$ccompare @ a_afwNQ @ b_afwNR v_XfP
                         Data.Semigroup.$fOrdArg_$c< @ a_afwNQ @ b_afwNR v_XfP
                         Data.Semigroup.$fOrdArg_$c<= @ a_afwNQ @ b_afwNR v_XfP
                         Data.Semigroup.$fOrdArg_$c> @ a_afwNQ @ b_afwNR v_XfP
                         Data.Semigroup.$fOrdArg_$c>= @ a_afwNQ @ b_afwNR v_XfP
                         Data.Semigroup.$fOrdArg_$cmax @ a_afwNQ @ b_afwNR v_XfP
                         Data.Semigroup.$fOrdArg_$cmin @ a_afwNQ @ b_afwNR v_XfP]
Data.Semigroup.$fOrdArg
  = \ (@ a_afyV3) (@ b_afyV4) ($dOrd_afyV5 :: Ord a_afyV3) ->
      GHC.Classes.C:Ord
        @ (Arg a_afyV3 b_afyV4)
        (Data.Semigroup.$fOrdArg_$cp1Ord @ a_afyV3 @ b_afyV4 $dOrd_afyV5)
        (Data.Semigroup.$fOrdArg_$ccompare @ a_afyV3 @ b_afyV4 $dOrd_afyV5)
        (Data.Semigroup.$fOrdArg_$c< @ a_afyV3 @ b_afyV4 $dOrd_afyV5)
        (Data.Semigroup.$fOrdArg_$c<= @ a_afyV3 @ b_afyV4 $dOrd_afyV5)
        (Data.Semigroup.$fOrdArg_$c> @ a_afyV3 @ b_afyV4 $dOrd_afyV5)
        (Data.Semigroup.$fOrdArg_$c>= @ a_afyV3 @ b_afyV4 $dOrd_afyV5)
        (Data.Semigroup.$fOrdArg_$cmax @ a_afyV3 @ b_afyV4 $dOrd_afyV5)
        (Data.Semigroup.$fOrdArg_$cmin @ a_afyV3 @ b_afyV4 $dOrd_afyV5)

-- RHS size: {terms: 15, types: 22, coercions: 0, joins: 0/0}
Data.Semigroup.$fBifunctorArg_$cbimap
  :: forall a b c d. (a -> b) -> (c -> d) -> Arg a c -> Arg b d
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyUw)
                 (@ b_afyUx)
                 (@ c_afyUy)
                 (@ d_afyUz)
                 (f_afwNM [Occ=Once!] :: a_afyUw -> b_afyUx)
                 (g_afwNN [Occ=Once!] :: c_afyUy -> d_afyUz)
                 (ds_dfzLa [Occ=Once!] :: Arg a_afyUw c_afyUy) ->
                 case ds_dfzLa of { Arg a1_afwNO [Occ=Once] b1_afwNP [Occ=Once] ->
                 Data.Semigroup.Arg
                   @ b_afyUx @ d_afyUz (f_afwNM a1_afwNO) (g_afwNN b1_afwNP)
                 }}]
Data.Semigroup.$fBifunctorArg_$cbimap
  = \ (@ a_afyUw)
      (@ b_afyUx)
      (@ c_afyUy)
      (@ d_afyUz)
      (f_afwNM :: a_afyUw -> b_afyUx)
      (g_afwNN :: c_afyUy -> d_afyUz)
      (ds_dfzLa :: Arg a_afyUw c_afyUy) ->
      case ds_dfzLa of { Arg a1_afwNO b1_afwNP ->
      Data.Semigroup.Arg
        @ b_afyUx @ d_afyUz (f_afwNM a1_afwNO) (g_afwNN b1_afwNP)
      }

-- RHS size: {terms: 12, types: 18, coercions: 0, joins: 0/0}
Data.Semigroup.$fBifunctorArg_$cfirst
  :: forall a b c. (a -> b) -> Arg a c -> Arg b c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyUG)
                 (@ b_afyUH)
                 (@ c_afyUI)
                 (f_adHN9 [Occ=Once!] :: a_afyUG -> b_afyUH)
                 (ds_dfzLa [Occ=Once!] :: Arg a_afyUG c_afyUI) ->
                 case ds_dfzLa of { Arg a1_afwNO [Occ=Once] b1_afwNP [Occ=Once] ->
                 Data.Semigroup.Arg @ b_afyUH @ c_afyUI (f_adHN9 a1_afwNO) b1_afwNP
                 }}]
Data.Semigroup.$fBifunctorArg_$cfirst
  = \ (@ a_afyUG)
      (@ b_afyUH)
      (@ c_afyUI)
      (f_adHN9 :: a_afyUG -> b_afyUH)
      (ds_dfzLa :: Arg a_afyUG c_afyUI) ->
      case ds_dfzLa of { Arg a1_afwNO b1_afwNP ->
      Data.Semigroup.Arg @ b_afyUH @ c_afyUI (f_adHN9 a1_afwNO) b1_afwNP
      }

-- RHS size: {terms: 12, types: 18, coercions: 0, joins: 0/0}
Data.Semigroup.$fBifunctorArg_$csecond
  :: forall b c a. (b -> c) -> Arg a b -> Arg a c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_afyUS)
                 (@ c_afyUT)
                 (@ a_afyUU)
                 (g_afwNN [Occ=Once!] :: b_afyUS -> c_afyUT)
                 (ds_dfzLa [Occ=Once!] :: Arg a_afyUU b_afyUS) ->
                 case ds_dfzLa of { Arg a1_afwNO [Occ=Once] b1_afwNP [Occ=Once] ->
                 Data.Semigroup.Arg @ a_afyUU @ c_afyUT a1_afwNO (g_afwNN b1_afwNP)
                 }}]
Data.Semigroup.$fBifunctorArg_$csecond
  = \ (@ b_afyUS)
      (@ c_afyUT)
      (@ a_afyUU)
      (g_afwNN :: b_afyUS -> c_afyUT)
      (ds_dfzLa :: Arg a_afyUU b_afyUS) ->
      case ds_dfzLa of { Arg a1_afwNO b1_afwNP ->
      Data.Semigroup.Arg @ a_afyUU @ c_afyUT a1_afwNO (g_afwNN b1_afwNP)
      }

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
Data.Semigroup.$fBifunctorArg [InlPrag=NOUSERINLINE CONLIKE]
  :: Bifunctor Arg
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bifunctor.C:Bifunctor TYPE: Arg
                                  Data.Semigroup.$fBifunctorArg_$cbimap
                                  Data.Semigroup.$fBifunctorArg_$cfirst
                                  Data.Semigroup.$fBifunctorArg_$csecond]
Data.Semigroup.$fBifunctorArg
  = Data.Bifunctor.C:Bifunctor
      @ Arg
      Data.Semigroup.$fBifunctorArg_$cbimap
      Data.Semigroup.$fBifunctorArg_$cfirst
      Data.Semigroup.$fBifunctorArg_$csecond

-- RHS size: {terms: 17, types: 22, coercions: 0, joins: 0/0}
Data.Semigroup.$fBifoldableArg_$cbifoldMap
  :: forall m a b. Monoid m => (a -> m) -> (b -> m) -> Arg a b -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*C1(U)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_afyTV)
                 (@ a_afyTW)
                 (@ b_afyTX)
                 ($dMonoid_afyTZ [Occ=Once] :: Monoid m_afyTV)
                 (eta_B3 [Occ=Once!] :: a_afyTW -> m_afyTV)
                 (eta1_B2 [Occ=Once!] :: b_afyTX -> m_afyTV)
                 (eta2_XeB [Occ=Once!] :: Arg a_afyTW b_afyTX) ->
                 case eta2_XeB of { Arg a1_afwNK [Occ=Once] b1_afwNL [Occ=Once] ->
                 <>
                   @ m_afyTV
                   (GHC.Base.$p1Monoid @ m_afyTV $dMonoid_afyTZ)
                   (eta_B3 a1_afwNK)
                   (eta1_B2 b1_afwNL)
                 }}]
Data.Semigroup.$fBifoldableArg_$cbifoldMap
  = \ (@ m_afyTV)
      (@ a_afyTW)
      (@ b_afyTX)
      ($dMonoid_afyTZ :: Monoid m_afyTV)
      (eta_B3 :: a_afyTW -> m_afyTV)
      (eta1_B2 :: b_afyTX -> m_afyTV)
      (eta2_XeB :: Arg a_afyTW b_afyTX) ->
      case eta2_XeB of { Arg a1_afwNK b1_afwNL ->
      <>
        @ m_afyTV
        (GHC.Base.$p1Monoid @ m_afyTV $dMonoid_afyTZ)
        (eta_B3 a1_afwNK)
        (eta1_B2 b1_afwNL)
      }

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
Data.Semigroup.$fBifoldableArg_$cbifold
  :: forall m. Monoid m => Arg m m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_afyTL)
                 ($dMonoid_afyTN [Occ=Once] :: Monoid m_afyTL)
                 (eta_Xwb [Occ=Once!] :: Arg m_afyTL m_afyTL) ->
                 case eta_Xwb of { Arg a_afwNK [Occ=Once] b_afwNL [Occ=Once] ->
                 <>
                   @ m_afyTL
                   (GHC.Base.$p1Monoid @ m_afyTL $dMonoid_afyTN)
                   a_afwNK
                   b_afwNL
                 }}]
Data.Semigroup.$fBifoldableArg_$cbifold
  = \ (@ m_afyTL)
      ($dMonoid_afyTN :: Monoid m_afyTL)
      (eta_Xwb :: Arg m_afyTL m_afyTL) ->
      case eta_Xwb of { Arg a_afwNK b_afwNL ->
      <>
        @ m_afyTL
        (GHC.Base.$p1Monoid @ m_afyTL $dMonoid_afyTN)
        a_afwNK
        b_afwNL
      }

-- RHS size: {terms: 15, types: 21, coercions: 0, joins: 0/0}
Data.Semigroup.$fBifoldableArg_$cbifoldr
  :: forall a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> Arg a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyU6)
                 (@ c_afyU7)
                 (@ b_afyU8)
                 (f_adJP5 [Occ=Once!] :: a_afyU6 -> c_afyU7 -> c_afyU7)
                 (g_adJP6 [Occ=Once!] :: b_afyU8 -> c_afyU7 -> c_afyU7)
                 (z_adJP7 [Occ=Once] :: c_afyU7)
                 (t_adJP8 [Occ=Once!] :: Arg a_afyU6 b_afyU8) ->
                 case t_adJP8 of { Arg a1_afwNK [Occ=Once] b1_afwNL [Occ=Once] ->
                 f_adJP5 a1_afwNK (g_adJP6 b1_afwNL z_adJP7)
                 }}]
Data.Semigroup.$fBifoldableArg_$cbifoldr
  = \ (@ a_afyU6)
      (@ c_afyU7)
      (@ b_afyU8)
      (f_adJP5 :: a_afyU6 -> c_afyU7 -> c_afyU7)
      (g_adJP6 :: b_afyU8 -> c_afyU7 -> c_afyU7)
      (z_adJP7 :: c_afyU7)
      (t_adJP8 :: Arg a_afyU6 b_afyU8) ->
      case t_adJP8 of { Arg a1_afwNK b1_afwNL ->
      f_adJP5 a1_afwNK (g_adJP6 b1_afwNL z_adJP7)
      }

-- RHS size: {terms: 15, types: 21, coercions: 0, joins: 0/0}
Data.Semigroup.$fBifoldableArg_$cbifoldl
  :: forall c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> Arg a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ c_afyUi)
                 (@ a_afyUj)
                 (@ b_afyUk)
                 (f_XdK5g [Occ=Once!] :: c_afyUi -> a_afyUj -> c_afyUi)
                 (g_XdK5i [Occ=Once!] :: c_afyUi -> b_afyUk -> c_afyUi)
                 (z_XdK5k [Occ=Once] :: c_afyUi)
                 (t_XdK5m [Occ=Once!] :: Arg a_afyUj b_afyUk) ->
                 case t_XdK5m of { Arg a1_afwNK [Occ=Once] b1_afwNL [Occ=Once] ->
                 g_XdK5i (f_XdK5g z_XdK5k a1_afwNK) b1_afwNL
                 }}]
Data.Semigroup.$fBifoldableArg_$cbifoldl
  = \ (@ c_afyUi)
      (@ a_afyUj)
      (@ b_afyUk)
      (f_XdK5g :: c_afyUi -> a_afyUj -> c_afyUi)
      (g_XdK5i :: c_afyUi -> b_afyUk -> c_afyUi)
      (z_XdK5k :: c_afyUi)
      (t_XdK5m :: Arg a_afyUj b_afyUk) ->
      case t_XdK5m of { Arg a1_afwNK b1_afwNL ->
      g_XdK5i (f_XdK5g z_XdK5k a1_afwNK) b1_afwNL
      }

-- RHS size: {terms: 5, types: 1, coercions: 0, joins: 0/0}
Data.Semigroup.$fBifoldableArg [InlPrag=NOUSERINLINE CONLIKE]
  :: Bifoldable Arg
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bifoldable.C:Bifoldable TYPE: Arg
                                    Data.Semigroup.$fBifoldableArg_$cbifold
                                    Data.Semigroup.$fBifoldableArg_$cbifoldMap
                                    Data.Semigroup.$fBifoldableArg_$cbifoldr
                                    Data.Semigroup.$fBifoldableArg_$cbifoldl]
Data.Semigroup.$fBifoldableArg
  = Data.Bifoldable.C:Bifoldable
      @ Arg
      Data.Semigroup.$fBifoldableArg_$cbifold
      Data.Semigroup.$fBifoldableArg_$cbifoldMap
      Data.Semigroup.$fBifoldableArg_$cbifoldr
      Data.Semigroup.$fBifoldableArg_$cbifoldl

-- RHS size: {terms: 20, types: 36, coercions: 0, joins: 0/0}
Data.Semigroup.$w$cbitraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a c b d.
     Applicative f =>
     (a -> f c) -> (b -> f d) -> a -> b -> f (Arg c d)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 60 0 0] 140 0}]
Data.Semigroup.$w$cbitraverse
  = \ (@ (f_sfBpj :: * -> *))
      (@ a_sfBpk)
      (@ c_sfBpl)
      (@ b_sfBpm)
      (@ d_sfBpn)
      (w_sfBpo :: Applicative f_sfBpj)
      (w1_sfBpp :: a_sfBpk -> f_sfBpj c_sfBpl)
      (w2_sfBpq :: b_sfBpm -> f_sfBpj d_sfBpn)
      (ww_sfBpu :: a_sfBpk)
      (ww1_sfBpv :: b_sfBpm) ->
      <*>
        @ f_sfBpj
        w_sfBpo
        @ d_sfBpn
        @ (Arg c_sfBpl d_sfBpn)
        (fmap
           @ f_sfBpj
           (GHC.Base.$p1Applicative @ f_sfBpj w_sfBpo)
           @ c_sfBpl
           @ (d_sfBpn -> Arg c_sfBpl d_sfBpn)
           (Data.Semigroup.Arg @ c_sfBpl @ d_sfBpn)
           (w1_sfBpp ww_sfBpu))
        (w2_sfBpq ww1_sfBpv)

-- RHS size: {terms: 18, types: 33, coercions: 0, joins: 0/0}
Data.Semigroup.$fBitraversableArg_$cbitraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a c b d.
     Applicative f =>
     (a -> f c) -> (b -> f d) -> Arg a b -> f (Arg c d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A)><L,1*C1(U)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_sfBpj :: * -> *))
                 (@ a_sfBpk)
                 (@ c_sfBpl)
                 (@ b_sfBpm)
                 (@ d_sfBpn)
                 (w_sfBpo [Occ=Once] :: Applicative f_sfBpj)
                 (w1_sfBpp [Occ=Once] :: a_sfBpk -> f_sfBpj c_sfBpl)
                 (w2_sfBpq [Occ=Once] :: b_sfBpm -> f_sfBpj d_sfBpn)
                 (w3_sfBpr [Occ=Once!] :: Arg a_sfBpk b_sfBpm) ->
                 case w3_sfBpr of { Arg ww1_sfBpu [Occ=Once] ww2_sfBpv [Occ=Once] ->
                 Data.Semigroup.$w$cbitraverse
                   @ f_sfBpj
                   @ a_sfBpk
                   @ c_sfBpl
                   @ b_sfBpm
                   @ d_sfBpn
                   w_sfBpo
                   w1_sfBpp
                   w2_sfBpq
                   ww1_sfBpu
                   ww2_sfBpv
                 }}]
Data.Semigroup.$fBitraversableArg_$cbitraverse
  = \ (@ (f_sfBpj :: * -> *))
      (@ a_sfBpk)
      (@ c_sfBpl)
      (@ b_sfBpm)
      (@ d_sfBpn)
      (w_sfBpo :: Applicative f_sfBpj)
      (w1_sfBpp :: a_sfBpk -> f_sfBpj c_sfBpl)
      (w2_sfBpq :: b_sfBpm -> f_sfBpj d_sfBpn)
      (w3_sfBpr :: Arg a_sfBpk b_sfBpm) ->
      case w3_sfBpr of { Arg ww1_sfBpu ww2_sfBpv ->
      Data.Semigroup.$w$cbitraverse
        @ f_sfBpj
        @ a_sfBpk
        @ c_sfBpl
        @ b_sfBpm
        @ d_sfBpn
        w_sfBpo
        w1_sfBpp
        w2_sfBpq
        ww1_sfBpu
        ww2_sfBpv
      }

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
Data.Semigroup.$fBitraversableArg [InlPrag=NOUSERINLINE CONLIKE]
  :: Bitraversable Arg
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bitraversable.C:Bitraversable TYPE: Arg
                                          Data.Semigroup.$fBifunctorArg
                                          Data.Semigroup.$fBifoldableArg
                                          Data.Semigroup.$fBitraversableArg_$cbitraverse]
Data.Semigroup.$fBitraversableArg
  = Data.Bitraversable.C:Bitraversable
      @ Arg
      Data.Semigroup.$fBifunctorArg
      Data.Semigroup.$fBifoldableArg
      Data.Semigroup.$fBitraversableArg_$cbitraverse

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
Data.Semigroup.$fSemigroupFirst_$cstimes
  :: forall a b. Integral b => b -> First a -> First a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyRx)
                 (@ b_afyRK)
                 ($dIntegral_afyRM [Occ=Once] :: Integral b_afyRK) ->
                 stimesIdempotent @ b_afyRK @ (First a_afyRx) $dIntegral_afyRM}]
Data.Semigroup.$fSemigroupFirst_$cstimes
  = \ (@ a_afyRx)
      (@ b_afyRK)
      ($dIntegral_afyRM :: Integral b_afyRK) ->
      stimesIdempotent @ b_afyRK @ (First a_afyRx) $dIntegral_afyRM

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Semigroup.$fSemigroupFirst_$c<>
  :: forall a. First a -> First a -> First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyRx)
                 (a1_afwNs [Occ=Once] :: First a_afyRx)
                 _ [Occ=Dead] ->
                 a1_afwNs}]
Data.Semigroup.$fSemigroupFirst_$c<>
  = \ (@ a_afyRx) (a1_afwNs :: First a_afyRx) _ [Occ=Dead] ->
      a1_afwNs

-- RHS size: {terms: 9, types: 16, coercions: 0, joins: 0/0}
Data.Semigroup.$fSemigroupFirst_$csconcat
  :: forall a. GHC.Base.NonEmpty (First a) -> First a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyRx)
                 (ds_i9in9 [Occ=Once!] :: GHC.Base.NonEmpty (First a_afyRx)) ->
                 case ds_i9in9 of
                 { GHC.Base.:| a1_i9ing [Occ=Once] as_i9inh [Occ=Once] ->
                 case as_i9inh of { __DEFAULT -> a1_i9ing }
                 }}]
Data.Semigroup.$fSemigroupFirst_$csconcat
  = \ (@ a_afyRx) (ds_i9in9 :: GHC.Base.NonEmpty (First a_afyRx)) ->
      case ds_i9in9 of { GHC.Base.:| a1_i9ing as_i9inh ->
      case as_i9inh of { __DEFAULT -> a1_i9ing }
      }

-- RHS size: {terms: 5, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fSemigroupFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Semigroup (First a)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ a_afwNr) ->
       GHC.Base.C:Semigroup TYPE: First a_afwNr
                            Data.Semigroup.$fSemigroupFirst_$c<> @ a_afwNr
                            Data.Semigroup.$fSemigroupFirst_$csconcat @ a_afwNr
                            Data.Semigroup.$fSemigroupFirst_$cstimes @ a_afwNr]
Data.Semigroup.$fSemigroupFirst
  = \ (@ a_afyRx) ->
      GHC.Base.C:Semigroup
        @ (First a_afyRx)
        (Data.Semigroup.$fSemigroupFirst_$c<> @ a_afyRx)
        (Data.Semigroup.$fSemigroupFirst_$csconcat @ a_afyRx)
        (Data.Semigroup.$fSemigroupFirst_$cstimes @ a_afyRx)

-- RHS size: {terms: 6, types: 8, coercions: 2, joins: 0/0}
Data.Semigroup.$fFunctorFirst2
  :: forall a b. (a -> b) -> First a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyRh)
                 (@ b_afyRi)
                 (f_afwNp [Occ=Once!] :: a_afyRh -> b_afyRi)
                 (ds_dfzK9 [Occ=Once] :: First a_afyRh) ->
                 f_afwNp
                   (ds_dfzK9
                    `cast` (Data.Semigroup.N:First[0] <a_afyRh>_R
                            :: (First a_afyRh :: *) ~R# (a_afyRh :: *)))}]
Data.Semigroup.$fFunctorFirst2
  = \ (@ a_afyRh)
      (@ b_afyRi)
      (f_afwNp :: a_afyRh -> b_afyRi)
      (ds_dfzK9 :: First a_afyRh) ->
      f_afwNp
        (ds_dfzK9
         `cast` (Data.Semigroup.N:First[0] <a_afyRh>_R
                 :: (First a_afyRh :: *) ~R# (a_afyRh :: *)))

-- RHS size: {terms: 5, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fFunctorFirst1 :: forall b a. a -> First b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_afyRp)
                 (@ a_afyRo)
                 (x_X9DBr [Occ=Once] :: a_afyRo)
                 _ [Occ=Dead] ->
                 x_X9DBr}]
Data.Semigroup.$fFunctorFirst1
  = \ (@ b_afyRp) (@ a_afyRo) (x_X9DBr :: a_afyRo) _ [Occ=Dead] ->
      x_X9DBr

-- RHS size: {terms: 5, types: 7, coercions: 29, joins: 0/0}
Data.Semigroup.$fFunctorFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Functor First
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Functor TYPE: First
                          Data.Semigroup.$fFunctorFirst2
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a -> b>_R
                                  ->_R <First a>_R
                                  ->_R Sym (Data.Semigroup.N:First[0] <b>_R)
                                  :: (forall a b. (a -> b) -> First a -> b :: *)
                                     ~R# (forall a b. (a -> b) -> First a -> First b :: *))
                          (\ (@ a_afyRo) (@ b_afyRp) ->
                             Data.Semigroup.$fFunctorFirst1 @ b_afyRp @ a_afyRo)
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a>_R ->_R <First b>_R ->_R Sym (Data.Semigroup.N:First[0] <a>_R)
                                  :: (forall a b. a -> First b -> a :: *)
                                     ~R# (forall a b. a -> First b -> First a :: *))]
Data.Semigroup.$fFunctorFirst
  = GHC.Base.C:Functor
      @ First
      (Data.Semigroup.$fFunctorFirst2
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a -> b>_R
               ->_R <First a>_R
               ->_R Sym (Data.Semigroup.N:First[0] <b>_R)
               :: (forall a b. (a -> b) -> First a -> b :: *)
                  ~R# (forall a b. (a -> b) -> First a -> First b :: *)))
      ((\ (@ a_afyRo) (@ b_afyRp) ->
          Data.Semigroup.$fFunctorFirst1 @ b_afyRp @ a_afyRo)
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a>_R ->_R <First b>_R ->_R Sym (Data.Semigroup.N:First[0] <a>_R)
               :: (forall a b. a -> First b -> a :: *)
                  ~R# (forall a b. a -> First b -> First a :: *)))

-- RHS size: {terms: 7, types: 10, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableFirst_$cfoldMap
  :: forall m a. Monoid m => (a -> m) -> First a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ m_afyP1)
                 (@ a_afyP2)
                 _ [Occ=Dead]
                 (f_afwNn [Occ=Once!] :: a_afyP2 -> m_afyP1)
                 (ds_dfzK4 [Occ=Once] :: First a_afyP2) ->
                 f_afwNn
                   (ds_dfzK4
                    `cast` (Data.Semigroup.N:First[0] <a_afyP2>_R
                            :: (First a_afyP2 :: *) ~R# (a_afyP2 :: *)))}]
Data.Semigroup.$fFoldableFirst_$cfoldMap
  = \ (@ m_afyP1)
      (@ a_afyP2)
      _ [Occ=Dead]
      (f_afwNn :: a_afyP2 -> m_afyP1)
      (ds_dfzK4 :: First a_afyP2) ->
      f_afwNn
        (ds_dfzK4
         `cast` (Data.Semigroup.N:First[0] <a_afyP2>_R
                 :: (First a_afyP2 :: *) ~R# (a_afyP2 :: *)))

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableFirst5
  :: forall m. Monoid m => First m -> First m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ m_afyOR)
                 _ [Occ=Dead]
                 (ds_dfzK4 [Occ=Once] :: First m_afyOR) ->
                 ds_dfzK4}]
Data.Semigroup.$fFoldableFirst5
  = \ (@ m_afyOR) _ [Occ=Dead] (ds_dfzK4 :: First m_afyOR) ->
      ds_dfzK4

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableFirst1
  :: forall a. Num a => First a -> First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyQV)
                 _ [Occ=Dead]
                 (eta_XeY [Occ=Once] :: First a_afyQV) ->
                 eta_XeY}]
Data.Semigroup.$fFoldableFirst1
  = \ (@ a_afyQV) _ [Occ=Dead] (eta_XeY :: First a_afyQV) -> eta_XeY

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableFirst2
  :: forall a. Ord a => First a -> First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyQL)
                 _ [Occ=Dead]
                 (x_ifzGk [Occ=Once] :: First a_afyQL) ->
                 x_ifzGk}]
Data.Semigroup.$fFoldableFirst2
  = \ (@ a_afyQL) _ [Occ=Dead] (x_ifzGk :: First a_afyQL) -> x_ifzGk

-- RHS size: {terms: 10, types: 10, coercions: 2, joins: 0/1}
Data.Semigroup.$fFoldableFirst_$celem
  :: forall a. Eq a => a -> First a -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyQr)
                 ($dEq_afyQt [Occ=Once] :: Eq a_afyQr)
                 (eta_Xfb [Occ=Once] :: a_afyQr) ->
                 let {
                   f_sfAis [Occ=OnceL!] :: a_afyQr -> Bool
                   [LclId]
                   f_sfAis = == @ a_afyQr $dEq_afyQt eta_Xfb } in
                 \ (ds_dfzK4 [Occ=Once] :: First a_afyQr) ->
                   f_sfAis
                     (ds_dfzK4
                      `cast` (Data.Semigroup.N:First[0] <a_afyQr>_R
                              :: (First a_afyQr :: *) ~R# (a_afyQr :: *)))}]
Data.Semigroup.$fFoldableFirst_$celem
  = \ (@ a_afyQr) ($dEq_afyQt :: Eq a_afyQr) (eta_Xfb :: a_afyQr) ->
      let {
        f_sfAis [Dmd=<L,C(U)>] :: a_afyQr -> Bool
        [LclId]
        f_sfAis = == @ a_afyQr $dEq_afyQt eta_Xfb } in
      \ (ds_dfzK4 :: First a_afyQr) ->
        f_sfAis
          (ds_dfzK4
           `cast` (Data.Semigroup.N:First[0] <a_afyQr>_R
                   :: (First a_afyQr :: *) ~R# (a_afyQr :: *)))

-- RHS size: {terms: 8, types: 10, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableFirst_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> First a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_afyPt)
                 (@ a_afyPu)
                 (f_XfzVp [Occ=Once!] :: b_afyPt -> a_afyPu -> b_afyPt)
                 (z_XfzVr [Occ=Once] :: b_afyPt)
                 (t1_XfzVt [Occ=Once] :: First a_afyPu) ->
                 f_XfzVp
                   z_XfzVr
                   (t1_XfzVt
                    `cast` (Data.Semigroup.N:First[0] <a_afyPu>_R
                            :: (First a_afyPu :: *) ~R# (a_afyPu :: *)))}]
Data.Semigroup.$fFoldableFirst_$cfoldl
  = \ (@ b_afyPt)
      (@ a_afyPu)
      (f_XfzVp :: b_afyPt -> a_afyPu -> b_afyPt)
      (z_XfzVr :: b_afyPt)
      (t1_XfzVt :: First a_afyPu) ->
      f_XfzVp
        z_XfzVr
        (t1_XfzVt
         `cast` (Data.Semigroup.N:First[0] <a_afyPu>_R
                 :: (First a_afyPu :: *) ~R# (a_afyPu :: *)))

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableFirst4
  :: forall a. (a -> a -> a) -> First a -> First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyPV)
                 _ [Occ=Dead]
                 (xs_XfzUy [Occ=Once] :: First a_afyPV) ->
                 xs_XfzUy}]
Data.Semigroup.$fFoldableFirst4
  = \ (@ a_afyPV) _ [Occ=Dead] (xs_XfzUy :: First a_afyPV) ->
      xs_XfzUy

-- RHS size: {terms: 8, types: 10, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableFirst_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> First a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyPj)
                 (@ b_afyPk)
                 (f_ifzEu [Occ=Once!] :: a_afyPj -> b_afyPk -> b_afyPk)
                 (z0_ifzEv [Occ=Once] :: b_afyPk)
                 (xs_ifzEw [Occ=Once] :: First a_afyPj) ->
                 f_ifzEu
                   (xs_ifzEw
                    `cast` (Data.Semigroup.N:First[0] <a_afyPj>_R
                            :: (First a_afyPj :: *) ~R# (a_afyPj :: *)))
                   z0_ifzEv}]
Data.Semigroup.$fFoldableFirst_$cfoldr'
  = \ (@ a_afyPj)
      (@ b_afyPk)
      (f_ifzEu :: a_afyPj -> b_afyPk -> b_afyPk)
      (z0_ifzEv :: b_afyPk)
      (xs_ifzEw :: First a_afyPj) ->
      f_ifzEu
        (xs_ifzEw
         `cast` (Data.Semigroup.N:First[0] <a_afyPj>_R
                 :: (First a_afyPj :: *) ~R# (a_afyPj :: *)))
        z0_ifzEv

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableFirst_$clength :: forall a. First a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyQj) _ [Occ=Dead] ->
                 Data.Semigroup.$fFoldableFirst3}]
Data.Semigroup.$fFoldableFirst_$clength
  = \ (@ a_afyQj) _ [Occ=Dead] -> Data.Semigroup.$fFoldableFirst3

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableFirst_$cnull :: forall a. First a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyQb) _ [Occ=Dead] -> GHC.Types.False}]
Data.Semigroup.$fFoldableFirst_$cnull
  = \ (@ a_afyQb) _ [Occ=Dead] -> GHC.Types.False

-- RHS size: {terms: 5, types: 6, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableFirst_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. First a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_afyQ3) (t1_ifzFB [Occ=Once] :: First a_afyQ3) ->
                 GHC.Base.build
                   @ a_afyQ3
                   (\ (@ b_ifzFC)
                      (c_ifzFD [Occ=Once!, OS=OneShot] :: a_afyQ3 -> b_ifzFC -> b_ifzFC)
                      (n_ifzFE [Occ=Once, OS=OneShot] :: b_ifzFC) ->
                      c_ifzFD
                        (t1_ifzFB
                         `cast` (Data.Semigroup.N:First[0] <a_afyQ3>_R
                                 :: (First a_afyQ3 :: *) ~R# (a_afyQ3 :: *)))
                        n_ifzFE)}]
Data.Semigroup.$fFoldableFirst_$ctoList
  = \ (@ a_afyQ3) (eta_Xgz :: First a_afyQ3) ->
      GHC.Types.:
        @ a_afyQ3
        (eta_Xgz
         `cast` (Data.Semigroup.N:First[0] <a_afyQ3>_R
                 :: (First a_afyQ3 :: *) ~R# (a_afyQ3 :: *)))
        (GHC.Types.[] @ a_afyQ3)

-- RHS size: {terms: 17, types: 1, coercions: 79, joins: 0/0}
Data.Semigroup.$fFoldableFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable First
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: First
                                Data.Semigroup.$fFoldableFirst5
                                `cast` (forall (m :: <*>_N).
                                        <Monoid m>_R
                                        ->_R <First m>_R
                                        ->_R Data.Semigroup.N:First[0] <m>_R
                                        :: (forall m. Monoid m => First m -> First m :: *)
                                           ~R# (forall m. Monoid m => First m -> m :: *))
                                Data.Semigroup.$fFoldableFirst_$cfoldMap
                                Data.Semigroup.$fFoldableFirst_$cfoldr'
                                Data.Semigroup.$fFoldableFirst_$cfoldr'
                                Data.Semigroup.$fFoldableFirst_$cfoldl
                                Data.Semigroup.$fFoldableFirst_$cfoldl
                                Data.Semigroup.$fFoldableFirst4
                                `cast` (forall (a :: <*>_N).
                                        <a -> a -> a>_R
                                        ->_R <First a>_R
                                        ->_R Data.Semigroup.N:First[0] <a>_R
                                        :: (forall a. (a -> a -> a) -> First a -> First a :: *)
                                           ~R# (forall a. (a -> a -> a) -> First a -> a :: *))
                                Data.Semigroup.$fFoldableFirst4
                                `cast` (forall (a :: <*>_N).
                                        <a -> a -> a>_R
                                        ->_R <First a>_R
                                        ->_R Data.Semigroup.N:First[0] <a>_R
                                        :: (forall a. (a -> a -> a) -> First a -> First a :: *)
                                           ~R# (forall a. (a -> a -> a) -> First a -> a :: *))
                                Data.Semigroup.$fFoldableFirst_$ctoList
                                Data.Semigroup.$fFoldableFirst_$cnull
                                Data.Semigroup.$fFoldableFirst_$clength
                                Data.Semigroup.$fFoldableFirst_$celem
                                Data.Semigroup.$fFoldableFirst2
                                `cast` (forall (a :: <*>_N).
                                        <Ord a>_R
                                        ->_R <First a>_R
                                        ->_R Data.Semigroup.N:First[0] <a>_R
                                        :: (forall a. Ord a => First a -> First a :: *)
                                           ~R# (forall a. Ord a => First a -> a :: *))
                                Data.Semigroup.$fFoldableFirst2
                                `cast` (forall (a :: <*>_N).
                                        <Ord a>_R
                                        ->_R <First a>_R
                                        ->_R Data.Semigroup.N:First[0] <a>_R
                                        :: (forall a. Ord a => First a -> First a :: *)
                                           ~R# (forall a. Ord a => First a -> a :: *))
                                Data.Semigroup.$fFoldableFirst1
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <First a>_R
                                        ->_R Data.Semigroup.N:First[0] <a>_R
                                        :: (forall a. Num a => First a -> First a :: *)
                                           ~R# (forall a. Num a => First a -> a :: *))
                                Data.Semigroup.$fFoldableFirst1
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <First a>_R
                                        ->_R Data.Semigroup.N:First[0] <a>_R
                                        :: (forall a. Num a => First a -> First a :: *)
                                           ~R# (forall a. Num a => First a -> a :: *))]
Data.Semigroup.$fFoldableFirst
  = Data.Foldable.C:Foldable
      @ First
      (Data.Semigroup.$fFoldableFirst5
       `cast` (forall (m :: <*>_N).
               <Monoid m>_R ->_R <First m>_R ->_R Data.Semigroup.N:First[0] <m>_R
               :: (forall m. Monoid m => First m -> First m :: *)
                  ~R# (forall m. Monoid m => First m -> m :: *)))
      Data.Semigroup.$fFoldableFirst_$cfoldMap
      Data.Semigroup.$fFoldableFirst_$cfoldr'
      Data.Semigroup.$fFoldableFirst_$cfoldr'
      Data.Semigroup.$fFoldableFirst_$cfoldl
      Data.Semigroup.$fFoldableFirst_$cfoldl
      (Data.Semigroup.$fFoldableFirst4
       `cast` (forall (a :: <*>_N).
               <a -> a -> a>_R
               ->_R <First a>_R
               ->_R Data.Semigroup.N:First[0] <a>_R
               :: (forall a. (a -> a -> a) -> First a -> First a :: *)
                  ~R# (forall a. (a -> a -> a) -> First a -> a :: *)))
      (Data.Semigroup.$fFoldableFirst4
       `cast` (forall (a :: <*>_N).
               <a -> a -> a>_R
               ->_R <First a>_R
               ->_R Data.Semigroup.N:First[0] <a>_R
               :: (forall a. (a -> a -> a) -> First a -> First a :: *)
                  ~R# (forall a. (a -> a -> a) -> First a -> a :: *)))
      Data.Semigroup.$fFoldableFirst_$ctoList
      Data.Semigroup.$fFoldableFirst_$cnull
      Data.Semigroup.$fFoldableFirst_$clength
      Data.Semigroup.$fFoldableFirst_$celem
      (Data.Semigroup.$fFoldableFirst2
       `cast` (forall (a :: <*>_N).
               <Ord a>_R ->_R <First a>_R ->_R Data.Semigroup.N:First[0] <a>_R
               :: (forall a. Ord a => First a -> First a :: *)
                  ~R# (forall a. Ord a => First a -> a :: *)))
      (Data.Semigroup.$fFoldableFirst2
       `cast` (forall (a :: <*>_N).
               <Ord a>_R ->_R <First a>_R ->_R Data.Semigroup.N:First[0] <a>_R
               :: (forall a. Ord a => First a -> First a :: *)
                  ~R# (forall a. Ord a => First a -> a :: *)))
      (Data.Semigroup.$fFoldableFirst1
       `cast` (forall (a :: <*>_N).
               <Num a>_R ->_R <First a>_R ->_R Data.Semigroup.N:First[0] <a>_R
               :: (forall a. Num a => First a -> First a :: *)
                  ~R# (forall a. Num a => First a -> a :: *)))
      (Data.Semigroup.$fFoldableFirst1
       `cast` (forall (a :: <*>_N).
               <Num a>_R ->_R <First a>_R ->_R Data.Semigroup.N:First[0] <a>_R
               :: (forall a. Num a => First a -> First a :: *)
                  ~R# (forall a. Num a => First a -> a :: *)))

-- RHS size: {terms: 12, types: 21, coercions: 7, joins: 0/0}
Data.Semigroup.$fTraversableFirst_$ctraverse
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> First a -> f (First b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_afyNZ :: * -> *))
                 (@ a_afyO0)
                 (@ b_afyO1)
                 ($dApplicative_afyO3 [Occ=Once] :: Applicative f_afyNZ)
                 (eta_B2 [Occ=Once!] :: a_afyO0 -> f_afyNZ b_afyO1)
                 (eta1_XfF [Occ=Once] :: First a_afyO0) ->
                 fmap
                   @ f_afyNZ
                   (GHC.Base.$p1Applicative @ f_afyNZ $dApplicative_afyO3)
                   @ b_afyO1
                   @ (First b_afyO1)
                   ((Data.Semigroup.$fApplicativeFirst3 @ b_afyO1)
                    `cast` (<b_afyO1>_R
                            ->_R Sym (Data.Semigroup.N:First[0] <b_afyO1>_R)
                            :: (b_afyO1 -> b_afyO1 :: *) ~R# (b_afyO1 -> First b_afyO1 :: *)))
                   (eta_B2
                      (eta1_XfF
                       `cast` (Data.Semigroup.N:First[0] <a_afyO0>_R
                               :: (First a_afyO0 :: *) ~R# (a_afyO0 :: *))))}]
Data.Semigroup.$fTraversableFirst_$ctraverse
  = \ (@ (f_afyNZ :: * -> *))
      (@ a_afyO0)
      (@ b_afyO1)
      ($dApplicative_afyO3 :: Applicative f_afyNZ)
      (eta_B2 :: a_afyO0 -> f_afyNZ b_afyO1)
      (eta1_XfF :: First a_afyO0) ->
      fmap
        @ f_afyNZ
        (GHC.Base.$p1Applicative @ f_afyNZ $dApplicative_afyO3)
        @ b_afyO1
        @ (First b_afyO1)
        ((Data.Semigroup.$fApplicativeFirst3 @ b_afyO1)
         `cast` (<b_afyO1>_R
                 ->_R Sym (Data.Semigroup.N:First[0] <b_afyO1>_R)
                 :: (b_afyO1 -> b_afyO1 :: *) ~R# (b_afyO1 -> First b_afyO1 :: *)))
        (eta_B2
           (eta1_XfF
            `cast` (Data.Semigroup.N:First[0] <a_afyO0>_R
                    :: (First a_afyO0 :: *) ~R# (a_afyO0 :: *))))

-- RHS size: {terms: 9, types: 17, coercions: 8, joins: 0/0}
Data.Semigroup.$fTraversableFirst_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     Applicative f =>
     First (f a) -> f (First a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_afyOd :: * -> *))
                 (@ a_afyOe)
                 ($dApplicative_afyOg [Occ=Once] :: Applicative f_afyOd)
                 (eta_Xy5 [Occ=Once] :: First (f_afyOd a_afyOe)) ->
                 fmap
                   @ f_afyOd
                   (GHC.Base.$p1Applicative @ f_afyOd $dApplicative_afyOg)
                   @ a_afyOe
                   @ (First a_afyOe)
                   ((\ (v_Xh2 [Occ=Once] :: a_afyOe) -> v_Xh2)
                    `cast` (<a_afyOe>_R
                            ->_R Sym (Data.Semigroup.N:First[0] <a_afyOe>_R)
                            :: (a_afyOe -> a_afyOe :: *) ~R# (a_afyOe -> First a_afyOe :: *)))
                   (eta_Xy5
                    `cast` (Data.Semigroup.N:First[0] <f_afyOd a_afyOe>_R
                            :: (First (f_afyOd a_afyOe) :: *) ~R# (f_afyOd a_afyOe :: *)))}]
Data.Semigroup.$fTraversableFirst_$csequenceA
  = \ (@ (f_afyOd :: * -> *))
      (@ a_afyOe)
      ($dApplicative_afyOg :: Applicative f_afyOd)
      (eta_Xy5 :: First (f_afyOd a_afyOe)) ->
      fmap
        @ f_afyOd
        (GHC.Base.$p1Applicative @ f_afyOd $dApplicative_afyOg)
        @ a_afyOe
        @ (First a_afyOe)
        ((Data.Semigroup.$fApplicativeFirst3 @ a_afyOe)
         `cast` (<a_afyOe>_R
                 ->_R Sym (Data.Semigroup.N:First[0] <a_afyOe>_R)
                 :: (a_afyOe -> a_afyOe :: *) ~R# (a_afyOe -> First a_afyOe :: *)))
        (eta_Xy5
         `cast` (Data.Semigroup.N:First[0] <f_afyOd a_afyOe>_R
                 :: (First (f_afyOd a_afyOe) :: *) ~R# (f_afyOd a_afyOe :: *)))

-- RHS size: {terms: 13, types: 22, coercions: 7, joins: 0/0}
Data.Semigroup.$fTraversableFirst_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> First a -> m (First b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_afyOp :: * -> *))
                 (@ a_afyOq)
                 (@ b_afyOr)
                 ($dMonad_afyOt [Occ=OnceL] :: Monad m_afyOp) ->
                 let {
                   $dApplicative_afyO3 [Occ=OnceL] :: Applicative m_afyOp
                   [LclId]
                   $dApplicative_afyO3
                     = GHC.Base.$p1Monad @ m_afyOp $dMonad_afyOt } in
                 \ (eta_B2 [Occ=Once!] :: a_afyOq -> m_afyOp b_afyOr)
                   (eta1_XfF [Occ=Once] :: First a_afyOq) ->
                   fmap
                     @ m_afyOp
                     (GHC.Base.$p1Applicative @ m_afyOp $dApplicative_afyO3)
                     @ b_afyOr
                     @ (First b_afyOr)
                     ((\ (v_Xh2 [Occ=Once] :: b_afyOr) -> v_Xh2)
                      `cast` (<b_afyOr>_R
                              ->_R Sym (Data.Semigroup.N:First[0] <b_afyOr>_R)
                              :: (b_afyOr -> b_afyOr :: *) ~R# (b_afyOr -> First b_afyOr :: *)))
                     (eta_B2
                        (eta1_XfF
                         `cast` (Data.Semigroup.N:First[0] <a_afyOq>_R
                                 :: (First a_afyOq :: *) ~R# (a_afyOq :: *))))}]
Data.Semigroup.$fTraversableFirst_$cmapM
  = \ (@ (m_afyOp :: * -> *))
      (@ a_afyOq)
      (@ b_afyOr)
      ($dMonad_afyOt :: Monad m_afyOp)
      (eta_B2 :: a_afyOq -> m_afyOp b_afyOr)
      (eta1_XfH :: First a_afyOq) ->
      fmap
        @ m_afyOp
        (GHC.Base.$p1Applicative
           @ m_afyOp (GHC.Base.$p1Monad @ m_afyOp $dMonad_afyOt))
        @ b_afyOr
        @ (First b_afyOr)
        ((Data.Semigroup.$fApplicativeFirst3 @ b_afyOr)
         `cast` (<b_afyOr>_R
                 ->_R Sym (Data.Semigroup.N:First[0] <b_afyOr>_R)
                 :: (b_afyOr -> b_afyOr :: *) ~R# (b_afyOr -> First b_afyOr :: *)))
        (eta_B2
           (eta1_XfH
            `cast` (Data.Semigroup.N:First[0] <a_afyOq>_R
                    :: (First a_afyOq :: *) ~R# (a_afyOq :: *))))

-- RHS size: {terms: 10, types: 18, coercions: 8, joins: 0/0}
Data.Semigroup.$fTraversableFirst_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a. Monad m => First (m a) -> m (First a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_afyOD :: * -> *))
                 (@ a_afyOE)
                 ($dMonad_afyOG [Occ=OnceL] :: Monad m_afyOD) ->
                 let {
                   $dApplicative_afyOg [Occ=OnceL] :: Applicative m_afyOD
                   [LclId]
                   $dApplicative_afyOg
                     = GHC.Base.$p1Monad @ m_afyOD $dMonad_afyOG } in
                 \ (eta_Xy5 [Occ=Once] :: First (m_afyOD a_afyOE)) ->
                   fmap
                     @ m_afyOD
                     (GHC.Base.$p1Applicative @ m_afyOD $dApplicative_afyOg)
                     @ a_afyOE
                     @ (First a_afyOE)
                     ((\ (v_Xh2 [Occ=Once] :: a_afyOE) -> v_Xh2)
                      `cast` (<a_afyOE>_R
                              ->_R Sym (Data.Semigroup.N:First[0] <a_afyOE>_R)
                              :: (a_afyOE -> a_afyOE :: *) ~R# (a_afyOE -> First a_afyOE :: *)))
                     (eta_Xy5
                      `cast` (Data.Semigroup.N:First[0] <m_afyOD a_afyOE>_R
                              :: (First (m_afyOD a_afyOE) :: *) ~R# (m_afyOD a_afyOE :: *)))}]
Data.Semigroup.$fTraversableFirst_$csequence
  = \ (@ (m_afyOD :: * -> *))
      (@ a_afyOE)
      ($dMonad_afyOG :: Monad m_afyOD)
      (eta_B1 :: First (m_afyOD a_afyOE)) ->
      fmap
        @ m_afyOD
        (GHC.Base.$p1Applicative
           @ m_afyOD (GHC.Base.$p1Monad @ m_afyOD $dMonad_afyOG))
        @ a_afyOE
        @ (First a_afyOE)
        ((Data.Semigroup.$fApplicativeFirst3 @ a_afyOE)
         `cast` (<a_afyOE>_R
                 ->_R Sym (Data.Semigroup.N:First[0] <a_afyOE>_R)
                 :: (a_afyOE -> a_afyOE :: *) ~R# (a_afyOE -> First a_afyOE :: *)))
        (eta_B1
         `cast` (Data.Semigroup.N:First[0] <m_afyOD a_afyOE>_R
                 :: (First (m_afyOD a_afyOE) :: *) ~R# (m_afyOD a_afyOE :: *)))

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Data.Semigroup.$fTraversableFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable First
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: First
                                      Data.Semigroup.$fFunctorFirst
                                      Data.Semigroup.$fFoldableFirst
                                      Data.Semigroup.$fTraversableFirst_$ctraverse
                                      Data.Semigroup.$fTraversableFirst_$csequenceA
                                      Data.Semigroup.$fTraversableFirst_$cmapM
                                      Data.Semigroup.$fTraversableFirst_$csequence]
Data.Semigroup.$fTraversableFirst
  = Data.Traversable.C:Traversable
      @ First
      Data.Semigroup.$fFunctorFirst
      Data.Semigroup.$fFoldableFirst
      Data.Semigroup.$fTraversableFirst_$ctraverse
      Data.Semigroup.$fTraversableFirst_$csequenceA
      Data.Semigroup.$fTraversableFirst_$cmapM
      Data.Semigroup.$fTraversableFirst_$csequence

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
Data.Semigroup.$fApplicativeFirst_$c<*
  :: forall a b. First a -> First b -> First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyNJ)
                 (@ b_afyNK)
                 (a1_afwNj [Occ=Once] :: First a_afyNJ)
                 _ [Occ=Dead] ->
                 a1_afwNj}]
Data.Semigroup.$fApplicativeFirst_$c<*
  = \ (@ a_afyNJ)
      (@ b_afyNK)
      (a1_afwNj :: First a_afyNJ)
      _ [Occ=Dead] ->
      a1_afwNj

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
Data.Semigroup.$fApplicativeFirst_$c*>
  :: forall a b. First a -> First b -> First b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyND)
                 (@ b_afyNE)
                 _ [Occ=Dead]
                 (a1_afwNk [Occ=Once] :: First b_afyNE) ->
                 a1_afwNk}]
Data.Semigroup.$fApplicativeFirst_$c*>
  = \ (@ a_afyND)
      (@ b_afyNE)
      _ [Occ=Dead]
      (a1_afwNk :: First b_afyNE) ->
      a1_afwNk

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fApplicativeFirst2
  :: forall a b. First (a -> b) -> First (a -> b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyNi)
                 (@ b_afyNj)
                 (v_Xha [Occ=Once] :: First (a_afyNi -> b_afyNj)) ->
                 v_Xha}]
Data.Semigroup.$fApplicativeFirst2
  = \ (@ a_afyNi)
      (@ b_afyNj)
      (v_Xha :: First (a_afyNi -> b_afyNj)) ->
      v_Xha

-- RHS size: {terms: 7, types: 1, coercions: 50, joins: 0/0}
Data.Semigroup.$fApplicativeFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Applicative First
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Applicative TYPE: First
                              Data.Semigroup.$fFunctorFirst
                              Data.Semigroup.$fApplicativeFirst3
                              `cast` (forall (a :: <*>_N).
                                      <a>_R ->_R Sym (Data.Semigroup.N:First[0] <a>_R)
                                      :: (forall a. a -> a :: *) ~R# (forall a. a -> First a :: *))
                              Data.Semigroup.$fApplicativeFirst2
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <First (a -> b)>_R
                                      ->_R Data.Semigroup.N:First[0]
                                               (Sym (Data.Semigroup.N:First[0] <a>_R)
                                                ->_R Sym (Data.Semigroup.N:First[0] <b>_R))
                                      :: (forall a b. First (a -> b) -> First (a -> b) :: *)
                                         ~R# (forall a b.
                                              First (a -> b) -> First a -> First b :: *))
                              Data.Semigroup.$fApplicativeFirst1
                              `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                                      <a -> b -> c>_R
                                      ->_R Sym (Data.Semigroup.N:First[0] <a>_R)
                                      ->_R Sym (Data.Semigroup.N:First[0] <b>_R)
                                      ->_R Sym (Data.Semigroup.N:First[0] <c>_R)
                                      :: (forall a b c. (a -> b -> c) -> a -> b -> c :: *)
                                         ~R# (forall a b c.
                                              (a -> b -> c) -> First a -> First b -> First c :: *))
                              Data.Semigroup.$fApplicativeFirst_$c*>
                              Data.Semigroup.$fApplicativeFirst_$c<*]
Data.Semigroup.$fApplicativeFirst
  = GHC.Base.C:Applicative
      @ First
      Data.Semigroup.$fFunctorFirst
      (Data.Semigroup.$fApplicativeFirst3
       `cast` (forall (a :: <*>_N).
               <a>_R ->_R Sym (Data.Semigroup.N:First[0] <a>_R)
               :: (forall a. a -> a :: *) ~R# (forall a. a -> First a :: *)))
      (Data.Semigroup.$fApplicativeFirst2
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <First (a -> b)>_R
               ->_R Data.Semigroup.N:First[0]
                        (Sym (Data.Semigroup.N:First[0] <a>_R)
                         ->_R Sym (Data.Semigroup.N:First[0] <b>_R))
               :: (forall a b. First (a -> b) -> First (a -> b) :: *)
                  ~R# (forall a b. First (a -> b) -> First a -> First b :: *)))
      (Data.Semigroup.$fApplicativeFirst1
       `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
               <a -> b -> c>_R
               ->_R Sym (Data.Semigroup.N:First[0] <a>_R)
               ->_R Sym (Data.Semigroup.N:First[0] <b>_R)
               ->_R Sym (Data.Semigroup.N:First[0] <c>_R)
               :: (forall a b c. (a -> b -> c) -> a -> b -> c :: *)
                  ~R# (forall a b c.
                       (a -> b -> c) -> First a -> First b -> First c :: *)))
      Data.Semigroup.$fApplicativeFirst_$c*>
      Data.Semigroup.$fApplicativeFirst_$c<*

-- RHS size: {terms: 6, types: 9, coercions: 2, joins: 0/0}
Data.Semigroup.$fMonadFirst_$c>>=
  :: forall a b. First a -> (a -> First b) -> First b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyMz)
                 (@ b_afyMA)
                 (ds_dfzJL [Occ=Once] :: First a_afyMz)
                 (f_afwNh [Occ=Once!] :: a_afyMz -> First b_afyMA) ->
                 f_afwNh
                   (ds_dfzJL
                    `cast` (Data.Semigroup.N:First[0] <a_afyMz>_R
                            :: (First a_afyMz :: *) ~R# (a_afyMz :: *)))}]
Data.Semigroup.$fMonadFirst_$c>>=
  = \ (@ a_afyMz)
      (@ b_afyMA)
      (ds_dfzJL :: First a_afyMz)
      (f_afwNh :: a_afyMz -> First b_afyMA) ->
      f_afwNh
        (ds_dfzJL
         `cast` (Data.Semigroup.N:First[0] <a_afyMz>_R
                 :: (First a_afyMz :: *) ~R# (a_afyMz :: *)))

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
lvl4_rfC6a :: forall a. [Char] -> First a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
lvl4_rfC6a
  = \ (@ a_afyMY) (eta_B1 :: [Char]) ->
      errorWithoutStackTrace
        @ 'GHC.Types.LiftedRep @ (First a_afyMY) eta_B1

-- RHS size: {terms: 6, types: 1, coercions: 8, joins: 0/0}
Data.Semigroup.$fMonadFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Monad First
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Monad TYPE: First
                        Data.Semigroup.$fApplicativeFirst
                        Data.Semigroup.$fMonadFirst_$c>>=
                        Data.Semigroup.$fApplicativeFirst_$c*>
                        Data.Semigroup.$fApplicativeFirst3
                        `cast` (forall (a :: <*>_N).
                                <a>_R ->_R Sym (Data.Semigroup.N:First[0] <a>_R)
                                :: (forall a. a -> a :: *) ~R# (forall a. a -> First a :: *))
                        \ (@ a_afyMY) ->
                          errorWithoutStackTrace @ 'GHC.Types.LiftedRep @ (First a_afyMY)]
Data.Semigroup.$fMonadFirst
  = GHC.Base.C:Monad
      @ First
      Data.Semigroup.$fApplicativeFirst
      Data.Semigroup.$fMonadFirst_$c>>=
      Data.Semigroup.$fApplicativeFirst_$c*>
      (Data.Semigroup.$fApplicativeFirst3
       `cast` (forall (a :: <*>_N).
               <a>_R ->_R Sym (Data.Semigroup.N:First[0] <a>_R)
               :: (forall a. a -> a :: *) ~R# (forall a. a -> First a :: *)))
      lvl4_rfC6a

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
Data.Semigroup.$fSemigroupLast_$cstimes
  :: forall a b. Integral b => b -> Last a -> Last a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyKt)
                 (@ b_afyKG)
                 ($dIntegral_afyKI [Occ=Once] :: Integral b_afyKG) ->
                 stimesIdempotent @ b_afyKG @ (Last a_afyKt) $dIntegral_afyKI}]
Data.Semigroup.$fSemigroupLast_$cstimes
  = \ (@ a_afyKt)
      (@ b_afyKG)
      ($dIntegral_afyKI :: Integral b_afyKG) ->
      stimesIdempotent @ b_afyKG @ (Last a_afyKt) $dIntegral_afyKI

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Semigroup.$fSemigroupLast_$c<>
  :: forall a. Last a -> Last a -> Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyKt)
                 _ [Occ=Dead]
                 (b_afwN3 [Occ=Once] :: Last a_afyKt) ->
                 b_afwN3}]
Data.Semigroup.$fSemigroupLast_$c<>
  = \ (@ a_afyKt) _ [Occ=Dead] (b_afwN3 :: Last a_afyKt) -> b_afwN3

Rec {
-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
Data.Semigroup.$fSemigroupLast1 [Occ=LoopBreaker]
  :: forall a. Last a -> [Last a] -> Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []]
Data.Semigroup.$fSemigroupLast1
  = \ (@ a_afyKt)
      (b_i9ine :: Last a_afyKt)
      (ds1_i9inf :: [Last a_afyKt]) ->
      case ds1_i9inf of {
        [] -> b_i9ine;
        : c_i9inn cs_i9ino ->
          Data.Semigroup.$fSemigroupLast1 @ a_afyKt c_i9inn cs_i9ino
      }
end Rec }

-- RHS size: {terms: 8, types: 14, coercions: 0, joins: 0/0}
Data.Semigroup.$fSemigroupLast_$csconcat
  :: forall a. GHC.Base.NonEmpty (Last a) -> Last a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyKt)
                 (ds_i9in9 [Occ=Once!] :: GHC.Base.NonEmpty (Last a_afyKt)) ->
                 case ds_i9in9 of
                 { GHC.Base.:| a1_i9ing [Occ=Once] as_i9inh [Occ=Once] ->
                 Data.Semigroup.$fSemigroupLast1 @ a_afyKt a1_i9ing as_i9inh
                 }}]
Data.Semigroup.$fSemigroupLast_$csconcat
  = \ (@ a_afyKt) (ds_i9in9 :: GHC.Base.NonEmpty (Last a_afyKt)) ->
      case ds_i9in9 of { GHC.Base.:| a1_i9ing as_i9inh ->
      Data.Semigroup.$fSemigroupLast1 @ a_afyKt a1_i9ing as_i9inh
      }

-- RHS size: {terms: 5, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fSemigroupLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Semigroup (Last a)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ a_afwN2) ->
       GHC.Base.C:Semigroup TYPE: Last a_afwN2
                            Data.Semigroup.$fSemigroupLast_$c<> @ a_afwN2
                            Data.Semigroup.$fSemigroupLast_$csconcat @ a_afwN2
                            Data.Semigroup.$fSemigroupLast_$cstimes @ a_afwN2]
Data.Semigroup.$fSemigroupLast
  = \ (@ a_afyKt) ->
      GHC.Base.C:Semigroup
        @ (Last a_afyKt)
        (Data.Semigroup.$fSemigroupLast_$c<> @ a_afyKt)
        (Data.Semigroup.$fSemigroupLast_$csconcat @ a_afyKt)
        (Data.Semigroup.$fSemigroupLast_$cstimes @ a_afyKt)

-- RHS size: {terms: 5, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fFunctorLast1 :: forall a b. a -> Last b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyKn)
                 (@ b_afyKo)
                 (a1_afwN1 [Occ=Once] :: a_afyKn)
                 _ [Occ=Dead] ->
                 a1_afwN1}]
Data.Semigroup.$fFunctorLast1
  = \ (@ a_afyKn) (@ b_afyKo) (a1_afwN1 :: a_afyKn) _ [Occ=Dead] ->
      a1_afwN1

-- RHS size: {terms: 6, types: 8, coercions: 2, joins: 0/0}
Data.Semigroup.$fFunctorLast2
  :: forall a b. (a -> b) -> Last a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyKg)
                 (@ b_afyKh)
                 (f_afwMZ [Occ=Once!] :: a_afyKg -> b_afyKh)
                 (ds_dfzIG [Occ=Once] :: Last a_afyKg) ->
                 f_afwMZ
                   (ds_dfzIG
                    `cast` (Data.Semigroup.N:Last[0] <a_afyKg>_R
                            :: (Last a_afyKg :: *) ~R# (a_afyKg :: *)))}]
Data.Semigroup.$fFunctorLast2
  = \ (@ a_afyKg)
      (@ b_afyKh)
      (f_afwMZ :: a_afyKg -> b_afyKh)
      (ds_dfzIG :: Last a_afyKg) ->
      f_afwMZ
        (ds_dfzIG
         `cast` (Data.Semigroup.N:Last[0] <a_afyKg>_R
                 :: (Last a_afyKg :: *) ~R# (a_afyKg :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 29, joins: 0/0}
Data.Semigroup.$fFunctorLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Functor Last
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Functor TYPE: Last
                          Data.Semigroup.$fFunctorLast2
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a -> b>_R
                                  ->_R <Last a>_R
                                  ->_R Sym (Data.Semigroup.N:Last[0] <b>_R)
                                  :: (forall a b. (a -> b) -> Last a -> b :: *)
                                     ~R# (forall a b. (a -> b) -> Last a -> Last b :: *))
                          Data.Semigroup.$fFunctorLast1
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a>_R ->_R <Last b>_R ->_R Sym (Data.Semigroup.N:Last[0] <a>_R)
                                  :: (forall a b. a -> Last b -> a :: *)
                                     ~R# (forall a b. a -> Last b -> Last a :: *))]
Data.Semigroup.$fFunctorLast
  = GHC.Base.C:Functor
      @ Last
      (Data.Semigroup.$fFunctorLast2
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a -> b>_R
               ->_R <Last a>_R
               ->_R Sym (Data.Semigroup.N:Last[0] <b>_R)
               :: (forall a b. (a -> b) -> Last a -> b :: *)
                  ~R# (forall a b. (a -> b) -> Last a -> Last b :: *)))
      (Data.Semigroup.$fFunctorLast1
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a>_R ->_R <Last b>_R ->_R Sym (Data.Semigroup.N:Last[0] <a>_R)
               :: (forall a b. a -> Last b -> a :: *)
                  ~R# (forall a b. a -> Last b -> Last a :: *)))

-- RHS size: {terms: 7, types: 10, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableLast_$cfoldMap
  :: forall m a. Monoid m => (a -> m) -> Last a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ m_afyI0)
                 (@ a_afyI1)
                 _ [Occ=Dead]
                 (f_afwMX [Occ=Once!] :: a_afyI1 -> m_afyI0)
                 (ds_dfzIB [Occ=Once] :: Last a_afyI1) ->
                 f_afwMX
                   (ds_dfzIB
                    `cast` (Data.Semigroup.N:Last[0] <a_afyI1>_R
                            :: (Last a_afyI1 :: *) ~R# (a_afyI1 :: *)))}]
Data.Semigroup.$fFoldableLast_$cfoldMap
  = \ (@ m_afyI0)
      (@ a_afyI1)
      _ [Occ=Dead]
      (f_afwMX :: a_afyI1 -> m_afyI0)
      (ds_dfzIB :: Last a_afyI1) ->
      f_afwMX
        (ds_dfzIB
         `cast` (Data.Semigroup.N:Last[0] <a_afyI1>_R
                 :: (Last a_afyI1 :: *) ~R# (a_afyI1 :: *)))

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableLast4
  :: forall m. Monoid m => Last m -> Last m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ m_afyHQ)
                 _ [Occ=Dead]
                 (ds_dfzIB [Occ=Once] :: Last m_afyHQ) ->
                 ds_dfzIB}]
Data.Semigroup.$fFoldableLast4
  = \ (@ m_afyHQ) _ [Occ=Dead] (ds_dfzIB :: Last m_afyHQ) -> ds_dfzIB

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableLast1
  :: forall a. Num a => Last a -> Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyJU)
                 _ [Occ=Dead]
                 (eta_Xga [Occ=Once] :: Last a_afyJU) ->
                 eta_Xga}]
Data.Semigroup.$fFoldableLast1
  = \ (@ a_afyJU) _ [Occ=Dead] (eta_Xga :: Last a_afyJU) -> eta_Xga

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableLast2
  :: forall a. Ord a => Last a -> Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyJK)
                 _ [Occ=Dead]
                 (x_ifzGk [Occ=Once] :: Last a_afyJK) ->
                 x_ifzGk}]
Data.Semigroup.$fFoldableLast2
  = \ (@ a_afyJK) _ [Occ=Dead] (x_ifzGk :: Last a_afyJK) -> x_ifzGk

-- RHS size: {terms: 10, types: 10, coercions: 2, joins: 0/1}
Data.Semigroup.$fFoldableLast_$celem
  :: forall a. Eq a => a -> Last a -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyJq)
                 ($dEq_afyJs [Occ=Once] :: Eq a_afyJq)
                 (eta_Xgn [Occ=Once] :: a_afyJq) ->
                 let {
                   f_sfAio [Occ=OnceL!] :: a_afyJq -> Bool
                   [LclId]
                   f_sfAio = == @ a_afyJq $dEq_afyJs eta_Xgn } in
                 \ (ds_dfzIB [Occ=Once] :: Last a_afyJq) ->
                   f_sfAio
                     (ds_dfzIB
                      `cast` (Data.Semigroup.N:Last[0] <a_afyJq>_R
                              :: (Last a_afyJq :: *) ~R# (a_afyJq :: *)))}]
Data.Semigroup.$fFoldableLast_$celem
  = \ (@ a_afyJq) ($dEq_afyJs :: Eq a_afyJq) (eta_Xgn :: a_afyJq) ->
      let {
        f_sfAio [Dmd=<L,C(U)>] :: a_afyJq -> Bool
        [LclId]
        f_sfAio = == @ a_afyJq $dEq_afyJs eta_Xgn } in
      \ (ds_dfzIB :: Last a_afyJq) ->
        f_sfAio
          (ds_dfzIB
           `cast` (Data.Semigroup.N:Last[0] <a_afyJq>_R
                   :: (Last a_afyJq :: *) ~R# (a_afyJq :: *)))

-- RHS size: {terms: 8, types: 10, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableLast_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Last a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_afyIs)
                 (@ a_afyIt)
                 (f_XfzWL [Occ=Once!] :: b_afyIs -> a_afyIt -> b_afyIs)
                 (z_XfzWN [Occ=Once] :: b_afyIs)
                 (t1_XfzWP [Occ=Once] :: Last a_afyIt) ->
                 f_XfzWL
                   z_XfzWN
                   (t1_XfzWP
                    `cast` (Data.Semigroup.N:Last[0] <a_afyIt>_R
                            :: (Last a_afyIt :: *) ~R# (a_afyIt :: *)))}]
Data.Semigroup.$fFoldableLast_$cfoldl
  = \ (@ b_afyIs)
      (@ a_afyIt)
      (f_XfzWL :: b_afyIs -> a_afyIt -> b_afyIs)
      (z_XfzWN :: b_afyIs)
      (t1_XfzWP :: Last a_afyIt) ->
      f_XfzWL
        z_XfzWN
        (t1_XfzWP
         `cast` (Data.Semigroup.N:Last[0] <a_afyIt>_R
                 :: (Last a_afyIt :: *) ~R# (a_afyIt :: *)))

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableLast3
  :: forall a. (a -> a -> a) -> Last a -> Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyIU)
                 _ [Occ=Dead]
                 (xs_XfzVK [Occ=Once] :: Last a_afyIU) ->
                 xs_XfzVK}]
Data.Semigroup.$fFoldableLast3
  = \ (@ a_afyIU) _ [Occ=Dead] (xs_XfzVK :: Last a_afyIU) -> xs_XfzVK

-- RHS size: {terms: 8, types: 10, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableLast_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Last a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyIi)
                 (@ b_afyIj)
                 (f_ifzEu [Occ=Once!] :: a_afyIi -> b_afyIj -> b_afyIj)
                 (z0_ifzEv [Occ=Once] :: b_afyIj)
                 (xs_ifzEw [Occ=Once] :: Last a_afyIi) ->
                 f_ifzEu
                   (xs_ifzEw
                    `cast` (Data.Semigroup.N:Last[0] <a_afyIi>_R
                            :: (Last a_afyIi :: *) ~R# (a_afyIi :: *)))
                   z0_ifzEv}]
Data.Semigroup.$fFoldableLast_$cfoldr'
  = \ (@ a_afyIi)
      (@ b_afyIj)
      (f_ifzEu :: a_afyIi -> b_afyIj -> b_afyIj)
      (z0_ifzEv :: b_afyIj)
      (xs_ifzEw :: Last a_afyIi) ->
      f_ifzEu
        (xs_ifzEw
         `cast` (Data.Semigroup.N:Last[0] <a_afyIi>_R
                 :: (Last a_afyIi :: *) ~R# (a_afyIi :: *)))
        z0_ifzEv

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableLast_$clength :: forall a. Last a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyJi) _ [Occ=Dead] ->
                 Data.Semigroup.$fFoldableFirst3}]
Data.Semigroup.$fFoldableLast_$clength
  = \ (@ a_afyJi) _ [Occ=Dead] -> Data.Semigroup.$fFoldableFirst3

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableLast_$cnull :: forall a. Last a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyJa) _ [Occ=Dead] -> GHC.Types.False}]
Data.Semigroup.$fFoldableLast_$cnull
  = \ (@ a_afyJa) _ [Occ=Dead] -> GHC.Types.False

-- RHS size: {terms: 5, types: 6, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableLast_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Last a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_afyJ2) (t1_ifzFB [Occ=Once] :: Last a_afyJ2) ->
                 GHC.Base.build
                   @ a_afyJ2
                   (\ (@ b_ifzFC)
                      (c_ifzFD [Occ=Once!, OS=OneShot] :: a_afyJ2 -> b_ifzFC -> b_ifzFC)
                      (n_ifzFE [Occ=Once, OS=OneShot] :: b_ifzFC) ->
                      c_ifzFD
                        (t1_ifzFB
                         `cast` (Data.Semigroup.N:Last[0] <a_afyJ2>_R
                                 :: (Last a_afyJ2 :: *) ~R# (a_afyJ2 :: *)))
                        n_ifzFE)}]
Data.Semigroup.$fFoldableLast_$ctoList
  = \ (@ a_afyJ2) (eta_XhV :: Last a_afyJ2) ->
      GHC.Types.:
        @ a_afyJ2
        (eta_XhV
         `cast` (Data.Semigroup.N:Last[0] <a_afyJ2>_R
                 :: (Last a_afyJ2 :: *) ~R# (a_afyJ2 :: *)))
        (GHC.Types.[] @ a_afyJ2)

-- RHS size: {terms: 17, types: 1, coercions: 79, joins: 0/0}
Data.Semigroup.$fFoldableLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable Last
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: Last
                                Data.Semigroup.$fFoldableLast4
                                `cast` (forall (m :: <*>_N).
                                        <Monoid m>_R
                                        ->_R <Last m>_R
                                        ->_R Data.Semigroup.N:Last[0] <m>_R
                                        :: (forall m. Monoid m => Last m -> Last m :: *)
                                           ~R# (forall m. Monoid m => Last m -> m :: *))
                                Data.Semigroup.$fFoldableLast_$cfoldMap
                                Data.Semigroup.$fFoldableLast_$cfoldr'
                                Data.Semigroup.$fFoldableLast_$cfoldr'
                                Data.Semigroup.$fFoldableLast_$cfoldl
                                Data.Semigroup.$fFoldableLast_$cfoldl
                                Data.Semigroup.$fFoldableLast3
                                `cast` (forall (a :: <*>_N).
                                        <a -> a -> a>_R
                                        ->_R <Last a>_R
                                        ->_R Data.Semigroup.N:Last[0] <a>_R
                                        :: (forall a. (a -> a -> a) -> Last a -> Last a :: *)
                                           ~R# (forall a. (a -> a -> a) -> Last a -> a :: *))
                                Data.Semigroup.$fFoldableLast3
                                `cast` (forall (a :: <*>_N).
                                        <a -> a -> a>_R
                                        ->_R <Last a>_R
                                        ->_R Data.Semigroup.N:Last[0] <a>_R
                                        :: (forall a. (a -> a -> a) -> Last a -> Last a :: *)
                                           ~R# (forall a. (a -> a -> a) -> Last a -> a :: *))
                                Data.Semigroup.$fFoldableLast_$ctoList
                                Data.Semigroup.$fFoldableLast_$cnull
                                Data.Semigroup.$fFoldableLast_$clength
                                Data.Semigroup.$fFoldableLast_$celem
                                Data.Semigroup.$fFoldableLast2
                                `cast` (forall (a :: <*>_N).
                                        <Ord a>_R
                                        ->_R <Last a>_R
                                        ->_R Data.Semigroup.N:Last[0] <a>_R
                                        :: (forall a. Ord a => Last a -> Last a :: *)
                                           ~R# (forall a. Ord a => Last a -> a :: *))
                                Data.Semigroup.$fFoldableLast2
                                `cast` (forall (a :: <*>_N).
                                        <Ord a>_R
                                        ->_R <Last a>_R
                                        ->_R Data.Semigroup.N:Last[0] <a>_R
                                        :: (forall a. Ord a => Last a -> Last a :: *)
                                           ~R# (forall a. Ord a => Last a -> a :: *))
                                Data.Semigroup.$fFoldableLast1
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <Last a>_R
                                        ->_R Data.Semigroup.N:Last[0] <a>_R
                                        :: (forall a. Num a => Last a -> Last a :: *)
                                           ~R# (forall a. Num a => Last a -> a :: *))
                                Data.Semigroup.$fFoldableLast1
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <Last a>_R
                                        ->_R Data.Semigroup.N:Last[0] <a>_R
                                        :: (forall a. Num a => Last a -> Last a :: *)
                                           ~R# (forall a. Num a => Last a -> a :: *))]
Data.Semigroup.$fFoldableLast
  = Data.Foldable.C:Foldable
      @ Last
      (Data.Semigroup.$fFoldableLast4
       `cast` (forall (m :: <*>_N).
               <Monoid m>_R ->_R <Last m>_R ->_R Data.Semigroup.N:Last[0] <m>_R
               :: (forall m. Monoid m => Last m -> Last m :: *)
                  ~R# (forall m. Monoid m => Last m -> m :: *)))
      Data.Semigroup.$fFoldableLast_$cfoldMap
      Data.Semigroup.$fFoldableLast_$cfoldr'
      Data.Semigroup.$fFoldableLast_$cfoldr'
      Data.Semigroup.$fFoldableLast_$cfoldl
      Data.Semigroup.$fFoldableLast_$cfoldl
      (Data.Semigroup.$fFoldableLast3
       `cast` (forall (a :: <*>_N).
               <a -> a -> a>_R ->_R <Last a>_R ->_R Data.Semigroup.N:Last[0] <a>_R
               :: (forall a. (a -> a -> a) -> Last a -> Last a :: *)
                  ~R# (forall a. (a -> a -> a) -> Last a -> a :: *)))
      (Data.Semigroup.$fFoldableLast3
       `cast` (forall (a :: <*>_N).
               <a -> a -> a>_R ->_R <Last a>_R ->_R Data.Semigroup.N:Last[0] <a>_R
               :: (forall a. (a -> a -> a) -> Last a -> Last a :: *)
                  ~R# (forall a. (a -> a -> a) -> Last a -> a :: *)))
      Data.Semigroup.$fFoldableLast_$ctoList
      Data.Semigroup.$fFoldableLast_$cnull
      Data.Semigroup.$fFoldableLast_$clength
      Data.Semigroup.$fFoldableLast_$celem
      (Data.Semigroup.$fFoldableLast2
       `cast` (forall (a :: <*>_N).
               <Ord a>_R ->_R <Last a>_R ->_R Data.Semigroup.N:Last[0] <a>_R
               :: (forall a. Ord a => Last a -> Last a :: *)
                  ~R# (forall a. Ord a => Last a -> a :: *)))
      (Data.Semigroup.$fFoldableLast2
       `cast` (forall (a :: <*>_N).
               <Ord a>_R ->_R <Last a>_R ->_R Data.Semigroup.N:Last[0] <a>_R
               :: (forall a. Ord a => Last a -> Last a :: *)
                  ~R# (forall a. Ord a => Last a -> a :: *)))
      (Data.Semigroup.$fFoldableLast1
       `cast` (forall (a :: <*>_N).
               <Num a>_R ->_R <Last a>_R ->_R Data.Semigroup.N:Last[0] <a>_R
               :: (forall a. Num a => Last a -> Last a :: *)
                  ~R# (forall a. Num a => Last a -> a :: *)))
      (Data.Semigroup.$fFoldableLast1
       `cast` (forall (a :: <*>_N).
               <Num a>_R ->_R <Last a>_R ->_R Data.Semigroup.N:Last[0] <a>_R
               :: (forall a. Num a => Last a -> Last a :: *)
                  ~R# (forall a. Num a => Last a -> a :: *)))

-- RHS size: {terms: 12, types: 21, coercions: 7, joins: 0/0}
Data.Semigroup.$fTraversableLast_$ctraverse
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> Last a -> f (Last b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_afyGY :: * -> *))
                 (@ a_afyGZ)
                 (@ b_afyH0)
                 ($dApplicative_afyH2 [Occ=Once] :: Applicative f_afyGY)
                 (eta_B2 [Occ=Once!] :: a_afyGZ -> f_afyGY b_afyH0)
                 (eta1_XgR [Occ=Once] :: Last a_afyGZ) ->
                 fmap
                   @ f_afyGY
                   (GHC.Base.$p1Applicative @ f_afyGY $dApplicative_afyH2)
                   @ b_afyH0
                   @ (Last b_afyH0)
                   ((Data.Semigroup.$fApplicativeFirst3 @ b_afyH0)
                    `cast` (<b_afyH0>_R ->_R Sym (Data.Semigroup.N:Last[0] <b_afyH0>_R)
                            :: (b_afyH0 -> b_afyH0 :: *) ~R# (b_afyH0 -> Last b_afyH0 :: *)))
                   (eta_B2
                      (eta1_XgR
                       `cast` (Data.Semigroup.N:Last[0] <a_afyGZ>_R
                               :: (Last a_afyGZ :: *) ~R# (a_afyGZ :: *))))}]
Data.Semigroup.$fTraversableLast_$ctraverse
  = \ (@ (f_afyGY :: * -> *))
      (@ a_afyGZ)
      (@ b_afyH0)
      ($dApplicative_afyH2 :: Applicative f_afyGY)
      (eta_B2 :: a_afyGZ -> f_afyGY b_afyH0)
      (eta1_XgR :: Last a_afyGZ) ->
      fmap
        @ f_afyGY
        (GHC.Base.$p1Applicative @ f_afyGY $dApplicative_afyH2)
        @ b_afyH0
        @ (Last b_afyH0)
        ((Data.Semigroup.$fApplicativeFirst3 @ b_afyH0)
         `cast` (<b_afyH0>_R ->_R Sym (Data.Semigroup.N:Last[0] <b_afyH0>_R)
                 :: (b_afyH0 -> b_afyH0 :: *) ~R# (b_afyH0 -> Last b_afyH0 :: *)))
        (eta_B2
           (eta1_XgR
            `cast` (Data.Semigroup.N:Last[0] <a_afyGZ>_R
                    :: (Last a_afyGZ :: *) ~R# (a_afyGZ :: *))))

-- RHS size: {terms: 9, types: 17, coercions: 8, joins: 0/0}
Data.Semigroup.$fTraversableLast_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     Applicative f =>
     Last (f a) -> f (Last a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_afyHc :: * -> *))
                 (@ a_afyHd)
                 ($dApplicative_afyHf [Occ=Once] :: Applicative f_afyHc)
                 (eta_XAN [Occ=Once] :: Last (f_afyHc a_afyHd)) ->
                 fmap
                   @ f_afyHc
                   (GHC.Base.$p1Applicative @ f_afyHc $dApplicative_afyHf)
                   @ a_afyHd
                   @ (Last a_afyHd)
                   ((\ (v_Xio [Occ=Once] :: a_afyHd) -> v_Xio)
                    `cast` (<a_afyHd>_R ->_R Sym (Data.Semigroup.N:Last[0] <a_afyHd>_R)
                            :: (a_afyHd -> a_afyHd :: *) ~R# (a_afyHd -> Last a_afyHd :: *)))
                   (eta_XAN
                    `cast` (Data.Semigroup.N:Last[0] <f_afyHc a_afyHd>_R
                            :: (Last (f_afyHc a_afyHd) :: *) ~R# (f_afyHc a_afyHd :: *)))}]
Data.Semigroup.$fTraversableLast_$csequenceA
  = \ (@ (f_afyHc :: * -> *))
      (@ a_afyHd)
      ($dApplicative_afyHf :: Applicative f_afyHc)
      (eta_XAN :: Last (f_afyHc a_afyHd)) ->
      fmap
        @ f_afyHc
        (GHC.Base.$p1Applicative @ f_afyHc $dApplicative_afyHf)
        @ a_afyHd
        @ (Last a_afyHd)
        ((Data.Semigroup.$fApplicativeFirst3 @ a_afyHd)
         `cast` (<a_afyHd>_R ->_R Sym (Data.Semigroup.N:Last[0] <a_afyHd>_R)
                 :: (a_afyHd -> a_afyHd :: *) ~R# (a_afyHd -> Last a_afyHd :: *)))
        (eta_XAN
         `cast` (Data.Semigroup.N:Last[0] <f_afyHc a_afyHd>_R
                 :: (Last (f_afyHc a_afyHd) :: *) ~R# (f_afyHc a_afyHd :: *)))

-- RHS size: {terms: 13, types: 22, coercions: 7, joins: 0/0}
Data.Semigroup.$fTraversableLast_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Last a -> m (Last b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_afyHo :: * -> *))
                 (@ a_afyHp)
                 (@ b_afyHq)
                 ($dMonad_afyHs [Occ=OnceL] :: Monad m_afyHo) ->
                 let {
                   $dApplicative_afyH2 [Occ=OnceL] :: Applicative m_afyHo
                   [LclId]
                   $dApplicative_afyH2
                     = GHC.Base.$p1Monad @ m_afyHo $dMonad_afyHs } in
                 \ (eta_B2 [Occ=Once!] :: a_afyHp -> m_afyHo b_afyHq)
                   (eta1_XgR [Occ=Once] :: Last a_afyHp) ->
                   fmap
                     @ m_afyHo
                     (GHC.Base.$p1Applicative @ m_afyHo $dApplicative_afyH2)
                     @ b_afyHq
                     @ (Last b_afyHq)
                     ((\ (v_Xio [Occ=Once] :: b_afyHq) -> v_Xio)
                      `cast` (<b_afyHq>_R ->_R Sym (Data.Semigroup.N:Last[0] <b_afyHq>_R)
                              :: (b_afyHq -> b_afyHq :: *) ~R# (b_afyHq -> Last b_afyHq :: *)))
                     (eta_B2
                        (eta1_XgR
                         `cast` (Data.Semigroup.N:Last[0] <a_afyHp>_R
                                 :: (Last a_afyHp :: *) ~R# (a_afyHp :: *))))}]
Data.Semigroup.$fTraversableLast_$cmapM
  = \ (@ (m_afyHo :: * -> *))
      (@ a_afyHp)
      (@ b_afyHq)
      ($dMonad_afyHs :: Monad m_afyHo)
      (eta_B2 :: a_afyHp -> m_afyHo b_afyHq)
      (eta1_XgT :: Last a_afyHp) ->
      fmap
        @ m_afyHo
        (GHC.Base.$p1Applicative
           @ m_afyHo (GHC.Base.$p1Monad @ m_afyHo $dMonad_afyHs))
        @ b_afyHq
        @ (Last b_afyHq)
        ((Data.Semigroup.$fApplicativeFirst3 @ b_afyHq)
         `cast` (<b_afyHq>_R ->_R Sym (Data.Semigroup.N:Last[0] <b_afyHq>_R)
                 :: (b_afyHq -> b_afyHq :: *) ~R# (b_afyHq -> Last b_afyHq :: *)))
        (eta_B2
           (eta1_XgT
            `cast` (Data.Semigroup.N:Last[0] <a_afyHp>_R
                    :: (Last a_afyHp :: *) ~R# (a_afyHp :: *))))

-- RHS size: {terms: 10, types: 18, coercions: 8, joins: 0/0}
Data.Semigroup.$fTraversableLast_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a. Monad m => Last (m a) -> m (Last a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_afyHC :: * -> *))
                 (@ a_afyHD)
                 ($dMonad_afyHF [Occ=OnceL] :: Monad m_afyHC) ->
                 let {
                   $dApplicative_afyHf [Occ=OnceL] :: Applicative m_afyHC
                   [LclId]
                   $dApplicative_afyHf
                     = GHC.Base.$p1Monad @ m_afyHC $dMonad_afyHF } in
                 \ (eta_XAN [Occ=Once] :: Last (m_afyHC a_afyHD)) ->
                   fmap
                     @ m_afyHC
                     (GHC.Base.$p1Applicative @ m_afyHC $dApplicative_afyHf)
                     @ a_afyHD
                     @ (Last a_afyHD)
                     ((\ (v_Xio [Occ=Once] :: a_afyHD) -> v_Xio)
                      `cast` (<a_afyHD>_R ->_R Sym (Data.Semigroup.N:Last[0] <a_afyHD>_R)
                              :: (a_afyHD -> a_afyHD :: *) ~R# (a_afyHD -> Last a_afyHD :: *)))
                     (eta_XAN
                      `cast` (Data.Semigroup.N:Last[0] <m_afyHC a_afyHD>_R
                              :: (Last (m_afyHC a_afyHD) :: *) ~R# (m_afyHC a_afyHD :: *)))}]
Data.Semigroup.$fTraversableLast_$csequence
  = \ (@ (m_afyHC :: * -> *))
      (@ a_afyHD)
      ($dMonad_afyHF :: Monad m_afyHC)
      (eta_B1 :: Last (m_afyHC a_afyHD)) ->
      fmap
        @ m_afyHC
        (GHC.Base.$p1Applicative
           @ m_afyHC (GHC.Base.$p1Monad @ m_afyHC $dMonad_afyHF))
        @ a_afyHD
        @ (Last a_afyHD)
        ((Data.Semigroup.$fApplicativeFirst3 @ a_afyHD)
         `cast` (<a_afyHD>_R ->_R Sym (Data.Semigroup.N:Last[0] <a_afyHD>_R)
                 :: (a_afyHD -> a_afyHD :: *) ~R# (a_afyHD -> Last a_afyHD :: *)))
        (eta_B1
         `cast` (Data.Semigroup.N:Last[0] <m_afyHC a_afyHD>_R
                 :: (Last (m_afyHC a_afyHD) :: *) ~R# (m_afyHC a_afyHD :: *)))

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Data.Semigroup.$fTraversableLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable Last
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: Last
                                      Data.Semigroup.$fFunctorLast
                                      Data.Semigroup.$fFoldableLast
                                      Data.Semigroup.$fTraversableLast_$ctraverse
                                      Data.Semigroup.$fTraversableLast_$csequenceA
                                      Data.Semigroup.$fTraversableLast_$cmapM
                                      Data.Semigroup.$fTraversableLast_$csequence]
Data.Semigroup.$fTraversableLast
  = Data.Traversable.C:Traversable
      @ Last
      Data.Semigroup.$fFunctorLast
      Data.Semigroup.$fFoldableLast
      Data.Semigroup.$fTraversableLast_$ctraverse
      Data.Semigroup.$fTraversableLast_$csequenceA
      Data.Semigroup.$fTraversableLast_$cmapM
      Data.Semigroup.$fTraversableLast_$csequence

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
Data.Semigroup.$fApplicativeLast_$c<*
  :: forall a b. Last a -> Last b -> Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyGI)
                 (@ b_afyGJ)
                 (a1_afwMT [Occ=Once] :: Last a_afyGI)
                 _ [Occ=Dead] ->
                 a1_afwMT}]
Data.Semigroup.$fApplicativeLast_$c<*
  = \ (@ a_afyGI)
      (@ b_afyGJ)
      (a1_afwMT :: Last a_afyGI)
      _ [Occ=Dead] ->
      a1_afwMT

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
Data.Semigroup.$fApplicativeLast_$c*>
  :: forall a b. Last a -> Last b -> Last b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyGC)
                 (@ b_afyGD)
                 _ [Occ=Dead]
                 (a1_afwMU [Occ=Once] :: Last b_afyGD) ->
                 a1_afwMU}]
Data.Semigroup.$fApplicativeLast_$c*>
  = \ (@ a_afyGC)
      (@ b_afyGD)
      _ [Occ=Dead]
      (a1_afwMU :: Last b_afyGD) ->
      a1_afwMU

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fApplicativeLast1
  :: forall a b. Last (a -> b) -> Last (a -> b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyGh)
                 (@ b_afyGi)
                 (v_Xiw [Occ=Once] :: Last (a_afyGh -> b_afyGi)) ->
                 v_Xiw}]
Data.Semigroup.$fApplicativeLast1
  = \ (@ a_afyGh) (@ b_afyGi) (v_Xiw :: Last (a_afyGh -> b_afyGi)) ->
      v_Xiw

-- RHS size: {terms: 7, types: 1, coercions: 50, joins: 0/0}
Data.Semigroup.$fApplicativeLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Applicative Last
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Applicative TYPE: Last
                              Data.Semigroup.$fFunctorLast
                              Data.Semigroup.$fApplicativeFirst3
                              `cast` (forall (a :: <*>_N).
                                      <a>_R ->_R Sym (Data.Semigroup.N:Last[0] <a>_R)
                                      :: (forall a. a -> a :: *) ~R# (forall a. a -> Last a :: *))
                              Data.Semigroup.$fApplicativeLast1
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <Last (a -> b)>_R
                                      ->_R Data.Semigroup.N:Last[0]
                                               (Sym (Data.Semigroup.N:Last[0] <a>_R)
                                                ->_R Sym (Data.Semigroup.N:Last[0] <b>_R))
                                      :: (forall a b. Last (a -> b) -> Last (a -> b) :: *)
                                         ~R# (forall a b. Last (a -> b) -> Last a -> Last b :: *))
                              Data.Semigroup.$fApplicativeFirst1
                              `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                                      <a -> b -> c>_R
                                      ->_R Sym (Data.Semigroup.N:Last[0] <a>_R)
                                      ->_R Sym (Data.Semigroup.N:Last[0] <b>_R)
                                      ->_R Sym (Data.Semigroup.N:Last[0] <c>_R)
                                      :: (forall a b c. (a -> b -> c) -> a -> b -> c :: *)
                                         ~R# (forall a b c.
                                              (a -> b -> c) -> Last a -> Last b -> Last c :: *))
                              Data.Semigroup.$fApplicativeLast_$c*>
                              Data.Semigroup.$fApplicativeLast_$c<*]
Data.Semigroup.$fApplicativeLast
  = GHC.Base.C:Applicative
      @ Last
      Data.Semigroup.$fFunctorLast
      (Data.Semigroup.$fApplicativeFirst3
       `cast` (forall (a :: <*>_N).
               <a>_R ->_R Sym (Data.Semigroup.N:Last[0] <a>_R)
               :: (forall a. a -> a :: *) ~R# (forall a. a -> Last a :: *)))
      (Data.Semigroup.$fApplicativeLast1
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <Last (a -> b)>_R
               ->_R Data.Semigroup.N:Last[0]
                        (Sym (Data.Semigroup.N:Last[0] <a>_R)
                         ->_R Sym (Data.Semigroup.N:Last[0] <b>_R))
               :: (forall a b. Last (a -> b) -> Last (a -> b) :: *)
                  ~R# (forall a b. Last (a -> b) -> Last a -> Last b :: *)))
      (Data.Semigroup.$fApplicativeFirst1
       `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
               <a -> b -> c>_R
               ->_R Sym (Data.Semigroup.N:Last[0] <a>_R)
               ->_R Sym (Data.Semigroup.N:Last[0] <b>_R)
               ->_R Sym (Data.Semigroup.N:Last[0] <c>_R)
               :: (forall a b c. (a -> b -> c) -> a -> b -> c :: *)
                  ~R# (forall a b c.
                       (a -> b -> c) -> Last a -> Last b -> Last c :: *)))
      Data.Semigroup.$fApplicativeLast_$c*>
      Data.Semigroup.$fApplicativeLast_$c<*

-- RHS size: {terms: 6, types: 9, coercions: 2, joins: 0/0}
Data.Semigroup.$fMonadLast_$c>>=
  :: forall a b. Last a -> (a -> Last b) -> Last b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyFy)
                 (@ b_afyFz)
                 (ds_dfzIi [Occ=Once] :: Last a_afyFy)
                 (f_afwMS [Occ=Once!] :: a_afyFy -> Last b_afyFz) ->
                 f_afwMS
                   (ds_dfzIi
                    `cast` (Data.Semigroup.N:Last[0] <a_afyFy>_R
                            :: (Last a_afyFy :: *) ~R# (a_afyFy :: *)))}]
Data.Semigroup.$fMonadLast_$c>>=
  = \ (@ a_afyFy)
      (@ b_afyFz)
      (ds_dfzIi :: Last a_afyFy)
      (f_afwMS :: a_afyFy -> Last b_afyFz) ->
      f_afwMS
        (ds_dfzIi
         `cast` (Data.Semigroup.N:Last[0] <a_afyFy>_R
                 :: (Last a_afyFy :: *) ~R# (a_afyFy :: *)))

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
lvl5_rfC6b :: forall a. [Char] -> Last a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
lvl5_rfC6b
  = \ (@ a_afyFX) (eta_B1 :: [Char]) ->
      errorWithoutStackTrace
        @ 'GHC.Types.LiftedRep @ (Last a_afyFX) eta_B1

-- RHS size: {terms: 6, types: 1, coercions: 8, joins: 0/0}
Data.Semigroup.$fMonadLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Monad Last
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Monad TYPE: Last
                        Data.Semigroup.$fApplicativeLast
                        Data.Semigroup.$fMonadLast_$c>>=
                        Data.Semigroup.$fApplicativeLast_$c*>
                        Data.Semigroup.$fApplicativeFirst3
                        `cast` (forall (a :: <*>_N).
                                <a>_R ->_R Sym (Data.Semigroup.N:Last[0] <a>_R)
                                :: (forall a. a -> a :: *) ~R# (forall a. a -> Last a :: *))
                        \ (@ a_afyFX) ->
                          errorWithoutStackTrace @ 'GHC.Types.LiftedRep @ (Last a_afyFX)]
Data.Semigroup.$fMonadLast
  = GHC.Base.C:Monad
      @ Last
      Data.Semigroup.$fApplicativeLast
      Data.Semigroup.$fMonadLast_$c>>=
      Data.Semigroup.$fApplicativeLast_$c*>
      (Data.Semigroup.$fApplicativeFirst3
       `cast` (forall (a :: <*>_N).
               <a>_R ->_R Sym (Data.Semigroup.N:Last[0] <a>_R)
               :: (forall a. a -> a :: *) ~R# (forall a. a -> Last a :: *)))
      lvl5_rfC6b

-- RHS size: {terms: 21, types: 30, coercions: 7, joins: 0/1}
Data.Semigroup.$w$csconcat3 [InlPrag=NOUSERINLINE[0]]
  :: forall m.
     Monoid m =>
     WrappedMonoid m -> [WrappedMonoid m] -> WrappedMonoid m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A)><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 150 0}]
Data.Semigroup.$w$csconcat3
  = \ (@ m_sfBpD)
      (w_sfBpE :: Monoid m_sfBpD)
      (ww_sfBpI :: WrappedMonoid m_sfBpD)
      (ww1_sfBpJ :: [WrappedMonoid m_sfBpD]) ->
      letrec {
        go_sfAim [Occ=LoopBreaker]
          :: WrappedMonoid m_sfBpD
             -> [WrappedMonoid m_sfBpD] -> WrappedMonoid m_sfBpD
        [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []]
        go_sfAim
          = \ (b_i9ine :: WrappedMonoid m_sfBpD)
              (ds1_i9inf :: [WrappedMonoid m_sfBpD]) ->
              case ds1_i9inf of {
                [] -> b_i9ine;
                : c_i9inn cs_i9ino ->
                  (mappend
                     @ m_sfBpD
                     w_sfBpE
                     (b_i9ine
                      `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_sfBpD>_R
                              :: (WrappedMonoid m_sfBpD :: *) ~R# (m_sfBpD :: *)))
                     ((go_sfAim c_i9inn cs_i9ino)
                      `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_sfBpD>_R
                              :: (WrappedMonoid m_sfBpD :: *) ~R# (m_sfBpD :: *))))
                  `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_sfBpD>_R)
                          :: (m_sfBpD :: *) ~R# (WrappedMonoid m_sfBpD :: *))
              }; } in
      go_sfAim ww_sfBpI ww1_sfBpJ

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
Data.Semigroup.$fSemigroupWrappedMonoid_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall m.
     Monoid m =>
     GHC.Base.NonEmpty (WrappedMonoid m) -> WrappedMonoid m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A)><S(LS),1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_sfBpD)
                 (w_sfBpE [Occ=Once] :: Monoid m_sfBpD)
                 (w1_sfBpF [Occ=Once!]
                    :: GHC.Base.NonEmpty (WrappedMonoid m_sfBpD)) ->
                 case w1_sfBpF of
                 { GHC.Base.:| ww1_sfBpI [Occ=Once] ww2_sfBpJ [Occ=Once] ->
                 Data.Semigroup.$w$csconcat3 @ m_sfBpD w_sfBpE ww1_sfBpI ww2_sfBpJ
                 }}]
Data.Semigroup.$fSemigroupWrappedMonoid_$csconcat
  = \ (@ m_sfBpD)
      (w_sfBpE :: Monoid m_sfBpD)
      (w1_sfBpF :: GHC.Base.NonEmpty (WrappedMonoid m_sfBpD)) ->
      case w1_sfBpF of { GHC.Base.:| ww1_sfBpI ww2_sfBpJ ->
      Data.Semigroup.$w$csconcat3 @ m_sfBpD w_sfBpE ww1_sfBpI ww2_sfBpJ
      }

Rec {
-- RHS size: {terms: 9, types: 9, coercions: 11, joins: 0/0}
Data.Semigroup.$fSemigroupWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m. Monoid m => Semigroup (WrappedMonoid m)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,A,U,A)>m,
 Unf=DFun: \ (@ m_afwMP) (v_XiK :: Monoid m_afwMP) ->
       GHC.Base.C:Semigroup TYPE: WrappedMonoid m_afwMP
                            (mappend @ m_afwMP v_XiK)
                            `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwMP>_R)
                                    ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwMP>_R)
                                    ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwMP>_R)
                                    :: (m_afwMP -> m_afwMP -> m_afwMP :: *)
                                       ~R# (WrappedMonoid m_afwMP
                                            -> WrappedMonoid m_afwMP -> WrappedMonoid m_afwMP :: *))
                            Data.Semigroup.$fSemigroupWrappedMonoid_$csconcat @ m_afwMP v_XiK
                            Data.Semigroup.$fSemigroupWrappedMonoid_$cstimes @ m_afwMP v_XiK]
Data.Semigroup.$fSemigroupWrappedMonoid
  = \ (@ m_afyEA) ($dMonoid_afyEB :: Monoid m_afyEA) ->
      GHC.Base.C:Semigroup
        @ (WrappedMonoid m_afyEA)
        ((mappend @ m_afyEA $dMonoid_afyEB)
         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyEA>_R)
                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyEA>_R)
                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyEA>_R)
                 :: (m_afyEA -> m_afyEA -> m_afyEA :: *)
                    ~R# (WrappedMonoid m_afyEA
                         -> WrappedMonoid m_afyEA -> WrappedMonoid m_afyEA :: *)))
        (Data.Semigroup.$fSemigroupWrappedMonoid_$csconcat
           @ m_afyEA $dMonoid_afyEB)
        (Data.Semigroup.$fSemigroupWrappedMonoid_$cstimes
           @ m_afyEA $dMonoid_afyEB)

-- RHS size: {terms: 9, types: 23, coercions: 0, joins: 0/0}
Data.Semigroup.$fSemigroupWrappedMonoid_$cstimes [Occ=LoopBreaker]
  :: forall m.
     Monoid m =>
     forall b. Integral b => b -> WrappedMonoid m -> WrappedMonoid m
[GblId, Arity=2, Str=<L,U(A,A,U,A)><L,U>, Unf=OtherCon []]
Data.Semigroup.$fSemigroupWrappedMonoid_$cstimes
  = \ (@ m_afyEA)
      ($dMonoid_afyEB :: Monoid m_afyEA)
      (@ b_afyF2)
      ($dIntegral_afyF4 :: Integral b_afyF2) ->
      GHC.Magic.noinline
        @ (forall b1 a. (Integral b1, Semigroup a) => b1 -> a -> a)
        stimesDefault
        @ b_afyF2
        @ (WrappedMonoid m_afyEA)
        $dIntegral_afyF4
        (Data.Semigroup.$fSemigroupWrappedMonoid @ m_afyEA $dMonoid_afyEB)
end Rec }

-- RHS size: {terms: 20, types: 26, coercions: 10, joins: 0/2}
Data.Semigroup.$fMonoidWrappedMonoid_$cmconcat
  :: forall m. Monoid m => [WrappedMonoid m] -> WrappedMonoid m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 150 0}]
Data.Semigroup.$fMonoidWrappedMonoid_$cmconcat
  = \ (@ m_afyEb)
      ($dMonoid_afyEc :: Monoid m_afyEb)
      (eta_B1 :: [WrappedMonoid m_afyEb]) ->
      let {
        z_sfAWV :: m_afyEb
        [LclId]
        z_sfAWV = mempty @ m_afyEb $dMonoid_afyEc } in
      letrec {
        go_i7Jcj [Occ=LoopBreaker]
          :: [WrappedMonoid m_afyEb] -> WrappedMonoid m_afyEb
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_i7Jcj
          = \ (ds_i7Jck :: [WrappedMonoid m_afyEb]) ->
              case ds_i7Jck of {
                [] ->
                  z_sfAWV
                  `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyEb>_R)
                          :: (m_afyEb :: *) ~R# (WrappedMonoid m_afyEb :: *));
                : y_i7Jcp ys_i7Jcq ->
                  (mappend
                     @ m_afyEb
                     $dMonoid_afyEc
                     (y_i7Jcp
                      `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_afyEb>_R
                              :: (WrappedMonoid m_afyEb :: *) ~R# (m_afyEb :: *)))
                     ((go_i7Jcj ys_i7Jcq)
                      `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_afyEb>_R
                              :: (WrappedMonoid m_afyEb :: *) ~R# (m_afyEb :: *))))
                  `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyEb>_R)
                          :: (m_afyEb :: *) ~R# (WrappedMonoid m_afyEb :: *))
              }; } in
      go_i7Jcj eta_B1

-- RHS size: {terms: 11, types: 10, coercions: 14, joins: 0/0}
Data.Semigroup.$fMonoidWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m. Monoid m => Monoid (WrappedMonoid m)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,U,U,A)>m,
 Unf=DFun: \ (@ m_afwMO) (v_XiO :: Monoid m_afwMO) ->
       GHC.Base.C:Monoid TYPE: WrappedMonoid m_afwMO
                         Data.Semigroup.$fSemigroupWrappedMonoid @ m_afwMO v_XiO
                         (mempty @ m_afwMO v_XiO)
                         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwMO>_R)
                                 :: (m_afwMO :: *) ~R# (WrappedMonoid m_afwMO :: *))
                         (mappend @ m_afwMO v_XiO)
                         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwMO>_R)
                                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwMO>_R)
                                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwMO>_R)
                                 :: (m_afwMO -> m_afwMO -> m_afwMO :: *)
                                    ~R# (WrappedMonoid m_afwMO
                                         -> WrappedMonoid m_afwMO -> WrappedMonoid m_afwMO :: *))
                         Data.Semigroup.$fMonoidWrappedMonoid_$cmconcat @ m_afwMO v_XiO]
Data.Semigroup.$fMonoidWrappedMonoid
  = \ (@ m_afyEb) ($dMonoid_afyEc :: Monoid m_afyEb) ->
      GHC.Base.C:Monoid
        @ (WrappedMonoid m_afyEb)
        (Data.Semigroup.$fSemigroupWrappedMonoid @ m_afyEb $dMonoid_afyEc)
        ((mempty @ m_afyEb $dMonoid_afyEc)
         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyEb>_R)
                 :: (m_afyEb :: *) ~R# (WrappedMonoid m_afyEb :: *)))
        ((mappend @ m_afyEb $dMonoid_afyEc)
         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyEb>_R)
                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyEb>_R)
                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyEb>_R)
                 :: (m_afyEb -> m_afyEb -> m_afyEb :: *)
                    ~R# (WrappedMonoid m_afyEb
                         -> WrappedMonoid m_afyEb -> WrappedMonoid m_afyEb :: *)))
        (Data.Semigroup.$fMonoidWrappedMonoid_$cmconcat
           @ m_afyEb $dMonoid_afyEc)

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
Data.Semigroup.$fFunctorOption1
  :: forall a b. a -> Maybe b -> Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyCI)
                 (@ b_afyCJ)
                 (x_X9DE4 [Occ=Once] :: a_afyCI)
                 (ds1_iaIvS [Occ=Once!] :: Maybe b_afyCJ) ->
                 case ds1_iaIvS of {
                   Nothing -> GHC.Base.Nothing @ a_afyCI;
                   Just _ [Occ=Dead] -> GHC.Base.Just @ a_afyCI x_X9DE4
                 }}]
Data.Semigroup.$fFunctorOption1
  = \ (@ a_afyCI)
      (@ b_afyCJ)
      (x_X9DE4 :: a_afyCI)
      (ds1_iaIvS :: Maybe b_afyCJ) ->
      case ds1_iaIvS of {
        Nothing -> GHC.Base.Nothing @ a_afyCI;
        Just a1_iaIvW -> GHC.Base.Just @ a_afyCI x_X9DE4
      }

-- RHS size: {terms: 3, types: 1, coercions: 31, joins: 0/0}
Data.Semigroup.$fFunctorOption [InlPrag=NOUSERINLINE CONLIKE]
  :: Functor Option
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Functor TYPE: Option
                          GHC.Base.$fApplicativeMaybe_$cfmap
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a -> b>_R
                                  ->_R Sym (Data.Semigroup.N:Option[0]) <a>_N
                                  ->_R Sym (Data.Semigroup.N:Option[0]) <b>_N
                                  :: (forall a b. (a -> b) -> Maybe a -> Maybe b :: *)
                                     ~R# (forall a b. (a -> b) -> Option a -> Option b :: *))
                          Data.Semigroup.$fFunctorOption1
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a>_R
                                  ->_R Sym (Data.Semigroup.N:Option[0]) <b>_N
                                  ->_R Sym (Data.Semigroup.N:Option[0]) <a>_N
                                  :: (forall a b. a -> Maybe b -> Maybe a :: *)
                                     ~R# (forall a b. a -> Option b -> Option a :: *))]
Data.Semigroup.$fFunctorOption
  = GHC.Base.C:Functor
      @ Option
      (GHC.Base.$fApplicativeMaybe_$cfmap
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a -> b>_R
               ->_R Sym (Data.Semigroup.N:Option[0]) <a>_N
               ->_R Sym (Data.Semigroup.N:Option[0]) <b>_N
               :: (forall a b. (a -> b) -> Maybe a -> Maybe b :: *)
                  ~R# (forall a b. (a -> b) -> Option a -> Option b :: *)))
      (Data.Semigroup.$fFunctorOption1
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a>_R
               ->_R Sym (Data.Semigroup.N:Option[0]) <b>_N
               ->_R Sym (Data.Semigroup.N:Option[0]) <a>_N
               :: (forall a b. a -> Maybe b -> Maybe a :: *)
                  ~R# (forall a b. a -> Option b -> Option a :: *)))

-- RHS size: {terms: 10, types: 12, coercions: 5, joins: 0/0}
Data.Semigroup.$fApplicativeOption_$c*>
  :: forall a b. Option a -> Option b -> Option b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyCc)
                 (@ b_afyCd)
                 (ds_dfzHk [Occ=Once] :: Option a_afyCc)
                 (ds1_dfzHl [Occ=Once] :: Option b_afyCd) ->
                 case ds_dfzHk
                      `cast` (Data.Semigroup.N:Option[0] <a_afyCc>_N
                              :: (Option a_afyCc :: *) ~R# (Maybe a_afyCc :: *))
                 of {
                   Nothing ->
                     (GHC.Base.Nothing @ b_afyCd)
                     `cast` (Sym (Data.Semigroup.N:Option[0]) <b_afyCd>_N
                             :: (Maybe b_afyCd :: *) ~R# (Option b_afyCd :: *));
                   Just _ [Occ=Dead] -> ds1_dfzHl
                 }}]
Data.Semigroup.$fApplicativeOption_$c*>
  = \ (@ a_afyCc)
      (@ b_afyCd)
      (ds_dfzHk :: Option a_afyCc)
      (ds1_dfzHl :: Option b_afyCd) ->
      case ds_dfzHk
           `cast` (Data.Semigroup.N:Option[0] <a_afyCc>_N
                   :: (Option a_afyCc :: *) ~R# (Maybe a_afyCc :: *))
      of {
        Nothing ->
          (GHC.Base.Nothing @ b_afyCd)
          `cast` (Sym (Data.Semigroup.N:Option[0]) <b_afyCd>_N
                  :: (Maybe b_afyCd :: *) ~R# (Option b_afyCd :: *));
        Just ipv_sfzTw -> ds1_dfzHl
      }

-- RHS size: {terms: 15, types: 16, coercions: 0, joins: 0/0}
Data.Semigroup.$fApplicativeOption1
  :: forall a b. Maybe a -> Maybe b -> Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyCk)
                 (@ b_afyCl)
                 (ds_Xc6S2 [Occ=Once!] :: Maybe a_afyCk)
                 (ds1_Xc6S4 [Occ=Once!] :: Maybe b_afyCl) ->
                 case ds_Xc6S2 of {
                   Nothing -> GHC.Base.Nothing @ a_afyCk;
                   Just x_ic6yO [Occ=Once] ->
                     case ds1_Xc6S4 of {
                       Nothing -> GHC.Base.Nothing @ a_afyCk;
                       Just _ [Occ=Dead] -> GHC.Base.Just @ a_afyCk x_ic6yO
                     }
                 }}]
Data.Semigroup.$fApplicativeOption1
  = \ (@ a_afyCk)
      (@ b_afyCl)
      (ds_Xc6S2 :: Maybe a_afyCk)
      (ds1_Xc6S4 :: Maybe b_afyCl) ->
      case ds_Xc6S2 of wild_ic6yL {
        Nothing -> GHC.Base.Nothing @ a_afyCk;
        Just x_ic6yO ->
          case ds1_Xc6S4 of {
            Nothing -> GHC.Base.Nothing @ a_afyCk;
            Just y_ic6yT -> wild_ic6yL
          }
      }

-- RHS size: {terms: 7, types: 1, coercions: 67, joins: 0/0}
Data.Semigroup.$fApplicativeOption [InlPrag=NOUSERINLINE CONLIKE]
  :: Applicative Option
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Applicative TYPE: Option
                              Data.Semigroup.$fFunctorOption
                              GHC.Base.Just
                              `cast` (forall (a :: <*>_N).
                                      <a>_R ->_R Sym (Data.Semigroup.N:Option[0]) <a>_N
                                      :: (forall a. a -> Maybe a :: *)
                                         ~R# (forall a. a -> Option a :: *))
                              GHC.Base.$fApplicativeMaybe_$c<*>
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      Sym (Data.Semigroup.N:Option[0]) <a -> b>_N
                                      ->_R Sym (Data.Semigroup.N:Option[0]) <a>_N
                                      ->_R Sym (Data.Semigroup.N:Option[0]) <b>_N
                                      :: (forall a b. Maybe (a -> b) -> Maybe a -> Maybe b :: *)
                                         ~R# (forall a b.
                                              Option (a -> b) -> Option a -> Option b :: *))
                              GHC.Base.$fApplicativeMaybe_$cliftA2
                              `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                                      <a -> b -> c>_R
                                      ->_R Sym (Data.Semigroup.N:Option[0]) <a>_N
                                      ->_R Sym (Data.Semigroup.N:Option[0]) <b>_N
                                      ->_R Sym (Data.Semigroup.N:Option[0]) <c>_N
                                      :: (forall a b c.
                                          (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c :: *)
                                         ~R# (forall a b c.
                                              (a -> b -> c)
                                              -> Option a -> Option b -> Option c :: *))
                              Data.Semigroup.$fApplicativeOption_$c*>
                              Data.Semigroup.$fApplicativeOption1
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      Sym (Data.Semigroup.N:Option[0]) <a>_N
                                      ->_R Sym (Data.Semigroup.N:Option[0]) <b>_N
                                      ->_R Sym (Data.Semigroup.N:Option[0]) <a>_N
                                      :: (forall a b. Maybe a -> Maybe b -> Maybe a :: *)
                                         ~R# (forall a b. Option a -> Option b -> Option a :: *))]
Data.Semigroup.$fApplicativeOption
  = GHC.Base.C:Applicative
      @ Option
      Data.Semigroup.$fFunctorOption
      (GHC.Base.Just
       `cast` (forall (a :: <*>_N).
               <a>_R ->_R Sym (Data.Semigroup.N:Option[0]) <a>_N
               :: (forall a. a -> Maybe a :: *)
                  ~R# (forall a. a -> Option a :: *)))
      (GHC.Base.$fApplicativeMaybe_$c<*>
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               Sym (Data.Semigroup.N:Option[0]) <a -> b>_N
               ->_R Sym (Data.Semigroup.N:Option[0]) <a>_N
               ->_R Sym (Data.Semigroup.N:Option[0]) <b>_N
               :: (forall a b. Maybe (a -> b) -> Maybe a -> Maybe b :: *)
                  ~R# (forall a b. Option (a -> b) -> Option a -> Option b :: *)))
      (GHC.Base.$fApplicativeMaybe_$cliftA2
       `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
               <a -> b -> c>_R
               ->_R Sym (Data.Semigroup.N:Option[0]) <a>_N
               ->_R Sym (Data.Semigroup.N:Option[0]) <b>_N
               ->_R Sym (Data.Semigroup.N:Option[0]) <c>_N
               :: (forall a b c.
                   (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c :: *)
                  ~R# (forall a b c.
                       (a -> b -> c) -> Option a -> Option b -> Option c :: *)))
      Data.Semigroup.$fApplicativeOption_$c*>
      (Data.Semigroup.$fApplicativeOption1
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               Sym (Data.Semigroup.N:Option[0]) <a>_N
               ->_R Sym (Data.Semigroup.N:Option[0]) <b>_N
               ->_R Sym (Data.Semigroup.N:Option[0]) <a>_N
               :: (forall a b. Maybe a -> Maybe b -> Maybe a :: *)
                  ~R# (forall a b. Option a -> Option b -> Option a :: *)))

-- RHS size: {terms: 11, types: 13, coercions: 5, joins: 0/0}
Data.Semigroup.$fMonadOption_$c>>=
  :: forall a b. Option a -> (a -> Option b) -> Option b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyB0)
                 (@ b_afyB1)
                 (ds_dfzGS [Occ=Once] :: Option a_afyB0)
                 (k_afwMt [Occ=Once!] :: a_afyB0 -> Option b_afyB1) ->
                 case ds_dfzGS
                      `cast` (Data.Semigroup.N:Option[0] <a_afyB0>_N
                              :: (Option a_afyB0 :: *) ~R# (Maybe a_afyB0 :: *))
                 of {
                   Nothing ->
                     (GHC.Base.Nothing @ b_afyB1)
                     `cast` (Sym (Data.Semigroup.N:Option[0]) <b_afyB1>_N
                             :: (Maybe b_afyB1 :: *) ~R# (Option b_afyB1 :: *));
                   Just a1_afwMs [Occ=Once] -> k_afwMt a1_afwMs
                 }}]
Data.Semigroup.$fMonadOption_$c>>=
  = \ (@ a_afyB0)
      (@ b_afyB1)
      (ds_dfzGS :: Option a_afyB0)
      (k_afwMt :: a_afyB0 -> Option b_afyB1) ->
      case ds_dfzGS
           `cast` (Data.Semigroup.N:Option[0] <a_afyB0>_N
                   :: (Option a_afyB0 :: *) ~R# (Maybe a_afyB0 :: *))
      of {
        Nothing ->
          (GHC.Base.Nothing @ b_afyB1)
          `cast` (Sym (Data.Semigroup.N:Option[0]) <b_afyB1>_N
                  :: (Maybe b_afyB1 :: *) ~R# (Option b_afyB1 :: *));
        Just a1_afwMs -> k_afwMt a1_afwMs
      }

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
lvl6_rfC6c :: forall a. [Char] -> Option a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
lvl6_rfC6c
  = \ (@ a_afyBr) (eta_B1 :: [Char]) ->
      errorWithoutStackTrace
        @ 'GHC.Types.LiftedRep @ (Option a_afyBr) eta_B1

-- RHS size: {terms: 6, types: 1, coercions: 8, joins: 0/0}
Data.Semigroup.$fMonadOption [InlPrag=NOUSERINLINE CONLIKE]
  :: Monad Option
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Monad TYPE: Option
                        Data.Semigroup.$fApplicativeOption
                        Data.Semigroup.$fMonadOption_$c>>=
                        Data.Semigroup.$fApplicativeOption_$c*>
                        GHC.Base.Just
                        `cast` (forall (a :: <*>_N).
                                <a>_R ->_R Sym (Data.Semigroup.N:Option[0]) <a>_N
                                :: (forall a. a -> Maybe a :: *)
                                   ~R# (forall a. a -> Option a :: *))
                        \ (@ a_afyBr) ->
                          errorWithoutStackTrace @ 'GHC.Types.LiftedRep @ (Option a_afyBr)]
Data.Semigroup.$fMonadOption
  = GHC.Base.C:Monad
      @ Option
      Data.Semigroup.$fApplicativeOption
      Data.Semigroup.$fMonadOption_$c>>=
      Data.Semigroup.$fApplicativeOption_$c*>
      (GHC.Base.Just
       `cast` (forall (a :: <*>_N).
               <a>_R ->_R Sym (Data.Semigroup.N:Option[0]) <a>_N
               :: (forall a. a -> Maybe a :: *)
                  ~R# (forall a. a -> Option a :: *)))
      lvl6_rfC6c

-- RHS size: {terms: 9, types: 9, coercions: 5, joins: 0/0}
Data.Semigroup.$fAlternativeOption_$c<|>
  :: forall a. Option a -> Option a -> Option a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyAz)
                 (ds_dfzGH [Occ=Once] :: Option a_afyAz)
                 (b_afwMq [Occ=Once] :: Option a_afyAz) ->
                 case ds_dfzGH
                      `cast` (Data.Semigroup.N:Option[0] <a_afyAz>_N
                              :: (Option a_afyAz :: *) ~R# (Maybe a_afyAz :: *))
                 of wild_Xjn {
                   Nothing -> b_afwMq;
                   Just _ [Occ=Dead] ->
                     wild_Xjn
                     `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afyAz>_N
                             :: (Maybe a_afyAz :: *) ~R# (Option a_afyAz :: *))
                 }}]
Data.Semigroup.$fAlternativeOption_$c<|>
  = \ (@ a_afyAz)
      (ds_dfzGH :: Option a_afyAz)
      (b_afwMq :: Option a_afyAz) ->
      case ds_dfzGH
           `cast` (Data.Semigroup.N:Option[0] <a_afyAz>_N
                   :: (Option a_afyAz :: *) ~R# (Maybe a_afyAz :: *))
      of wild_Xjn {
        Nothing -> b_afwMq;
        Just ipv_sfzTO ->
          wild_Xjn
          `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afyAz>_N
                  :: (Maybe a_afyAz :: *) ~R# (Option a_afyAz :: *))
      }

-- RHS size: {terms: 21, types: 24, coercions: 6, joins: 0/1}
Data.Semigroup.$fAlternativeOption_$csome
  :: forall a. Option a -> Option [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30] 90 0}]
Data.Semigroup.$fAlternativeOption_$csome
  = \ (@ a_afyAE) (v_i9Dk5 :: Option a_afyAE) ->
      letrec {
        some_v_sfAik [Occ=LoopBreaker] :: Maybe [a_afyAE]
        [LclId]
        some_v_sfAik
          = case v_i9Dk5
                 `cast` (Data.Semigroup.N:Option[0] <a_afyAE>_N
                         :: (Option a_afyAE :: *) ~R# (Maybe a_afyAE :: *))
            of {
              Nothing -> GHC.Base.Nothing @ [a_afyAE];
              Just x_ic6yO ->
                case some_v_sfAik of {
                  Nothing ->
                    GHC.Base.Just
                      @ [a_afyAE]
                      (GHC.Types.: @ a_afyAE x_ic6yO (GHC.Types.[] @ a_afyAE));
                  Just ipv_sfzTO ->
                    GHC.Base.Just @ [a_afyAE] (GHC.Types.: @ a_afyAE x_ic6yO ipv_sfzTO)
                }
            }; } in
      some_v_sfAik
      `cast` (Sym (Data.Semigroup.N:Option[0]) <[a_afyAE]>_N
              :: (Maybe [a_afyAE] :: *) ~R# (Option [a_afyAE] :: *))

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Data.Semigroup.$fAlternativeOption1 :: forall a. Maybe [a]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fAlternativeOption1
  = \ (@ a_afyAM) ->
      GHC.Base.Just @ [a_afyAM] (GHC.Types.[] @ a_afyAM)

-- RHS size: {terms: 18, types: 20, coercions: 17, joins: 0/1}
Data.Semigroup.$fAlternativeOption_$cmany
  :: forall a. Option a -> Option [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyAM) (v_i9Dkb [Occ=Once] :: Option a_afyAM) ->
                 letrec {
                   many_v_sfAii [Occ=LoopBreaker] :: Option [a_afyAM]
                   [LclId]
                   many_v_sfAii
                     = case v_i9Dkb
                            `cast` (Data.Semigroup.N:Option[0] <a_afyAM>_N
                                    :: (Option a_afyAM :: *) ~R# (Maybe a_afyAM :: *))
                       of {
                         Nothing ->
                           (Data.Semigroup.$fAlternativeOption1 @ a_afyAM)
                           `cast` (Sym (Data.Semigroup.N:Option[0]) <[a_afyAM]>_N
                                   :: (Maybe [a_afyAM] :: *) ~R# (Option [a_afyAM] :: *));
                         Just x_ic6yO [Occ=Once] ->
                           case many_v_sfAii
                                `cast` (Data.Semigroup.N:Option[0] <[a_afyAM]>_N
                                        :: (Option [a_afyAM] :: *) ~R# (Maybe [a_afyAM] :: *))
                           of {
                             Nothing ->
                               (Data.Semigroup.$fAlternativeOption1 @ a_afyAM)
                               `cast` (Sym (Data.Semigroup.N:Option[0]) <[a_afyAM]>_N
                                       :: (Maybe [a_afyAM] :: *) ~R# (Option [a_afyAM] :: *));
                             Just y_ic6yT [Occ=Once] ->
                               (GHC.Base.Just @ [a_afyAM] (GHC.Types.: @ a_afyAM x_ic6yO y_ic6yT))
                               `cast` (Sym (Data.Semigroup.N:Option[0]) <[a_afyAM]>_N
                                       :: (Maybe [a_afyAM] :: *) ~R# (Option [a_afyAM] :: *))
                           }
                       }; } in
                 many_v_sfAii}]
Data.Semigroup.$fAlternativeOption_$cmany
  = \ (@ a_afyAM) (v_i9Dkb :: Option a_afyAM) ->
      letrec {
        many_v_sfAii [Occ=LoopBreaker] :: Option [a_afyAM]
        [LclId]
        many_v_sfAii
          = case v_i9Dkb
                 `cast` (Data.Semigroup.N:Option[0] <a_afyAM>_N
                         :: (Option a_afyAM :: *) ~R# (Maybe a_afyAM :: *))
            of {
              Nothing ->
                (Data.Semigroup.$fAlternativeOption1 @ a_afyAM)
                `cast` (Sym (Data.Semigroup.N:Option[0]) <[a_afyAM]>_N
                        :: (Maybe [a_afyAM] :: *) ~R# (Option [a_afyAM] :: *));
              Just x_ic6yO ->
                case many_v_sfAii
                     `cast` (Data.Semigroup.N:Option[0] <[a_afyAM]>_N
                             :: (Option [a_afyAM] :: *) ~R# (Maybe [a_afyAM] :: *))
                of {
                  Nothing ->
                    (Data.Semigroup.$fAlternativeOption1 @ a_afyAM)
                    `cast` (Sym (Data.Semigroup.N:Option[0]) <[a_afyAM]>_N
                            :: (Maybe [a_afyAM] :: *) ~R# (Option [a_afyAM] :: *));
                  Just y_ic6yT ->
                    (GHC.Base.Just @ [a_afyAM] (GHC.Types.: @ a_afyAM x_ic6yO y_ic6yT))
                    `cast` (Sym (Data.Semigroup.N:Option[0]) <[a_afyAM]>_N
                            :: (Maybe [a_afyAM] :: *) ~R# (Option [a_afyAM] :: *))
                }
            }; } in
      many_v_sfAii

-- RHS size: {terms: 6, types: 1, coercions: 6, joins: 0/0}
Data.Semigroup.$fAlternativeOption [InlPrag=NOUSERINLINE CONLIKE]
  :: Alternative Option
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Alternative TYPE: Option
                              Data.Semigroup.$fApplicativeOption
                              GHC.Base.Nothing
                              `cast` (forall (a :: <*>_N). Sym (Data.Semigroup.N:Option[0]) <a>_N
                                      :: (forall a. Maybe a :: *) ~R# (forall a. Option a :: *))
                              Data.Semigroup.$fAlternativeOption_$c<|>
                              Data.Semigroup.$fAlternativeOption_$csome
                              Data.Semigroup.$fAlternativeOption_$cmany]
Data.Semigroup.$fAlternativeOption
  = GHC.Base.C:Alternative
      @ Option
      Data.Semigroup.$fApplicativeOption
      (GHC.Base.Nothing
       `cast` (forall (a :: <*>_N). Sym (Data.Semigroup.N:Option[0]) <a>_N
               :: (forall a. Maybe a :: *) ~R# (forall a. Option a :: *)))
      Data.Semigroup.$fAlternativeOption_$c<|>
      Data.Semigroup.$fAlternativeOption_$csome
      Data.Semigroup.$fAlternativeOption_$cmany

-- RHS size: {terms: 5, types: 1, coercions: 6, joins: 0/0}
Data.Semigroup.$fMonadPlusOption [InlPrag=NOUSERINLINE CONLIKE]
  :: MonadPlus Option
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:MonadPlus TYPE: Option
                            Data.Semigroup.$fAlternativeOption
                            Data.Semigroup.$fMonadOption
                            GHC.Base.Nothing
                            `cast` (forall (a :: <*>_N). Sym (Data.Semigroup.N:Option[0]) <a>_N
                                    :: (forall a. Maybe a :: *) ~R# (forall a. Option a :: *))
                            Data.Semigroup.$fAlternativeOption_$c<|>]
Data.Semigroup.$fMonadPlusOption
  = GHC.Base.C:MonadPlus
      @ Option
      Data.Semigroup.$fAlternativeOption
      Data.Semigroup.$fMonadOption
      (GHC.Base.Nothing
       `cast` (forall (a :: <*>_N). Sym (Data.Semigroup.N:Option[0]) <a>_N
               :: (forall a. Maybe a :: *) ~R# (forall a. Option a :: *)))
      Data.Semigroup.$fAlternativeOption_$c<|>

-- RHS size: {terms: 13, types: 14, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableOption_$cfoldMap
  :: forall m a. Monoid m => (a -> m) -> Option a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_afywC)
                 (@ a_afywD)
                 ($dMonoid_afywF [Occ=Once] :: Monoid m_afywC)
                 (f_afwMn [Occ=Once!] :: a_afywD -> m_afywC)
                 (ds_dfzE9 [Occ=Once] :: Option a_afywD) ->
                 case ds_dfzE9
                      `cast` (Data.Semigroup.N:Option[0] <a_afywD>_N
                              :: (Option a_afywD :: *) ~R# (Maybe a_afywD :: *))
                 of {
                   Nothing -> mempty @ m_afywC $dMonoid_afywF;
                   Just m1_afwMo [Occ=Once] -> f_afwMn m1_afwMo
                 }}]
Data.Semigroup.$fFoldableOption_$cfoldMap
  = \ (@ m_afywC)
      (@ a_afywD)
      ($dMonoid_afywF :: Monoid m_afywC)
      (f_afwMn :: a_afywD -> m_afywC)
      (ds_dfzE9 :: Option a_afywD) ->
      case ds_dfzE9
           `cast` (Data.Semigroup.N:Option[0] <a_afywD>_N
                   :: (Option a_afywD :: *) ~R# (Maybe a_afywD :: *))
      of {
        Nothing -> mempty @ m_afywC $dMonoid_afywF;
        Just m1_afwMo -> f_afwMn m1_afwMo
      }

-- RHS size: {terms: 10, types: 10, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableOption_$cfold
  :: forall m. Monoid m => Option m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_afyws)
                 ($dMonoid_afywu [Occ=Once] :: Monoid m_afyws)
                 (ds_dfzE9 [Occ=Once] :: Option m_afyws) ->
                 case ds_dfzE9
                      `cast` (Data.Semigroup.N:Option[0] <m_afyws>_N
                              :: (Option m_afyws :: *) ~R# (Maybe m_afyws :: *))
                 of {
                   Nothing -> mempty @ m_afyws $dMonoid_afywu;
                   Just m1_afwMo [Occ=Once] -> m1_afwMo
                 }}]
Data.Semigroup.$fFoldableOption_$cfold
  = \ (@ m_afyws)
      ($dMonoid_afywu :: Monoid m_afyws)
      (ds_dfzE9 :: Option m_afyws) ->
      case ds_dfzE9
           `cast` (Data.Semigroup.N:Option[0] <m_afyws>_N
                   :: (Option m_afyws :: *) ~R# (Maybe m_afyws :: *))
      of {
        Nothing -> mempty @ m_afyws $dMonoid_afywu;
        Just m1_afwMo -> m1_afwMo
      }

-- RHS size: {terms: 10, types: 10, coercions: 8, joins: 0/0}
Data.Semigroup.$fFoldableOption2
  :: forall a. Num a => Option a -> Sum a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyzf)
                 ($dNum_afyzh [Occ=Once] :: Num a_afyzf)
                 (ds_dfzE9 [Occ=Once] :: Option a_afyzf) ->
                 case ds_dfzE9
                      `cast` (Data.Semigroup.N:Option[0] <a_afyzf>_N
                              :: (Option a_afyzf :: *) ~R# (Maybe a_afyzf :: *))
                 of {
                   Nothing ->
                     (Data.Semigroup.Internal.$fMonoidSum2 @ a_afyzf $dNum_afyzh)
                     `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_afyzf>_R)
                             :: (a_afyzf :: *) ~R# (Sum a_afyzf :: *));
                   Just m_afwMo [Occ=Once] ->
                     m_afwMo
                     `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_afyzf>_R)
                             :: (a_afyzf :: *) ~R# (Sum a_afyzf :: *))
                 }}]
Data.Semigroup.$fFoldableOption2
  = \ (@ a_afyzf)
      ($dNum_afyzh :: Num a_afyzf)
      (ds_dfzE9 :: Option a_afyzf) ->
      case ds_dfzE9
           `cast` (Data.Semigroup.N:Option[0] <a_afyzf>_N
                   :: (Option a_afyzf :: *) ~R# (Maybe a_afyzf :: *))
      of {
        Nothing ->
          (Data.Semigroup.Internal.$fMonoidSum2 @ a_afyzf $dNum_afyzh)
          `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_afyzf>_R)
                  :: (a_afyzf :: *) ~R# (Sum a_afyzf :: *));
        Just m_afwMo ->
          m_afwMo
          `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_afyzf>_R)
                  :: (a_afyzf :: *) ~R# (Sum a_afyzf :: *))
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl7_rfC6d :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl7_rfC6d = "minimum: empty structure"#

-- RHS size: {terms: 4, types: 4, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableOption4 :: forall a. a
[GblId, Str=x]
Data.Semigroup.$fFoldableOption4
  = \ (@ a_afyz2) ->
      errorWithoutStackTrace
        @ 'GHC.Types.LiftedRep
        @ a_afyz2
        (GHC.CString.unpackCString# lvl7_rfC6d)

-- RHS size: {terms: 8, types: 8, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableOption3 :: forall a. Option a -> a
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyz2) (x_ifzGk [Occ=Once] :: Option a_afyz2) ->
                 case x_ifzGk
                      `cast` (Data.Semigroup.N:Option[0] <a_afyz2>_N
                              :: (Option a_afyz2 :: *) ~R# (Maybe a_afyz2 :: *))
                 of {
                   Nothing -> Data.Semigroup.$fFoldableOption4 @ a_afyz2;
                   Just v_ifzGp [Occ=Once] -> v_ifzGp
                 }}]
Data.Semigroup.$fFoldableOption3
  = \ (@ a_afyz2) (x_ifzGk :: Option a_afyz2) ->
      case x_ifzGk
           `cast` (Data.Semigroup.N:Option[0] <a_afyz2>_N
                   :: (Option a_afyz2 :: *) ~R# (Maybe a_afyz2 :: *))
      of {
        Nothing -> Data.Semigroup.$fFoldableOption4 @ a_afyz2;
        Just v_ifzGp -> v_ifzGp
      }

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableOption_$cminimum
  :: forall a. Ord a => Option a -> a
[GblId,
 Arity=2,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyz2) _ [Occ=Dead] ->
                 Data.Semigroup.$fFoldableOption3 @ a_afyz2}]
Data.Semigroup.$fFoldableOption_$cminimum
  = \ (@ a_afyz2) _ [Occ=Dead] ->
      Data.Semigroup.$fFoldableOption3 @ a_afyz2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl8_rfC6e :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl8_rfC6e = "maximum: empty structure"#

-- RHS size: {terms: 4, types: 4, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableOption6 :: forall a. a
[GblId, Str=x]
Data.Semigroup.$fFoldableOption6
  = \ (@ a_afyyP) ->
      errorWithoutStackTrace
        @ 'GHC.Types.LiftedRep
        @ a_afyyP
        (GHC.CString.unpackCString# lvl8_rfC6e)

-- RHS size: {terms: 8, types: 8, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableOption5 :: forall a. Option a -> a
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyyP) (x_ifzG6 [Occ=Once] :: Option a_afyyP) ->
                 case x_ifzG6
                      `cast` (Data.Semigroup.N:Option[0] <a_afyyP>_N
                              :: (Option a_afyyP :: *) ~R# (Maybe a_afyyP :: *))
                 of {
                   Nothing -> Data.Semigroup.$fFoldableOption6 @ a_afyyP;
                   Just v_ifzGb [Occ=Once] -> v_ifzGb
                 }}]
Data.Semigroup.$fFoldableOption5
  = \ (@ a_afyyP) (x_ifzG6 :: Option a_afyyP) ->
      case x_ifzG6
           `cast` (Data.Semigroup.N:Option[0] <a_afyyP>_N
                   :: (Option a_afyyP :: *) ~R# (Maybe a_afyyP :: *))
      of {
        Nothing -> Data.Semigroup.$fFoldableOption6 @ a_afyyP;
        Just v_ifzGb -> v_ifzGb
      }

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableOption_$cmaximum
  :: forall a. Ord a => Option a -> a
[GblId,
 Arity=2,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyyP) _ [Occ=Dead] ->
                 Data.Semigroup.$fFoldableOption5 @ a_afyyP}]
Data.Semigroup.$fFoldableOption_$cmaximum
  = \ (@ a_afyyP) _ [Occ=Dead] ->
      Data.Semigroup.$fFoldableOption5 @ a_afyyP

-- RHS size: {terms: 15, types: 13, coercions: 10, joins: 0/1}
Data.Semigroup.$fFoldableOption_$celem
  :: forall a. Eq a => a -> Option a -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyyC)
                 ($dEq_afyyE [Occ=Once] :: Eq a_afyyC)
                 (eta_XhI [Occ=Once] :: a_afyyC) ->
                 let {
                   f_sfAic [Occ=OnceL!] :: a_afyyC -> Bool
                   [LclId]
                   f_sfAic = == @ a_afyyC $dEq_afyyE eta_XhI } in
                 (\ (ds_dfzE9 [Occ=Once] :: Option a_afyyC) ->
                    case ds_dfzE9
                         `cast` (Data.Semigroup.N:Option[0] <a_afyyC>_N
                                 :: (Option a_afyyC :: *) ~R# (Maybe a_afyyC :: *))
                    of {
                      Nothing ->
                        GHC.Types.False
                        `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                                :: (Bool :: *) ~R# (Any :: *));
                      Just m_afwMo [Occ=Once] ->
                        (f_sfAic m_afwMo)
                        `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                                :: (Bool :: *) ~R# (Any :: *))
                    })
                 `cast` (<Option a_afyyC>_R ->_R Data.Semigroup.Internal.N:Any[0]
                         :: (Option a_afyyC -> Any :: *)
                            ~R# (Option a_afyyC -> Bool :: *))}]
Data.Semigroup.$fFoldableOption_$celem
  = \ (@ a_afyyC) ($dEq_afyyE :: Eq a_afyyC) (eta_XhI :: a_afyyC) ->
      let {
        f_sfAic [Dmd=<L,C(U)>] :: a_afyyC -> Bool
        [LclId]
        f_sfAic = == @ a_afyyC $dEq_afyyE eta_XhI } in
      (\ (ds_dfzE9 :: Option a_afyyC) ->
         case ds_dfzE9
              `cast` (Data.Semigroup.N:Option[0] <a_afyyC>_N
                      :: (Option a_afyyC :: *) ~R# (Maybe a_afyyC :: *))
         of {
           Nothing ->
             GHC.Types.False
             `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                     :: (Bool :: *) ~R# (Any :: *));
           Just m_afwMo ->
             (f_sfAic m_afwMo)
             `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                     :: (Bool :: *) ~R# (Any :: *))
         })
      `cast` (<Option a_afyyC>_R ->_R Data.Semigroup.Internal.N:Any[0]
              :: (Option a_afyyC -> Any :: *) ~R# (Option a_afyyC -> Bool :: *))

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableOption7 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fFoldableOption7 = GHC.Types.I# 0#

-- RHS size: {terms: 13, types: 13, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableOption_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Option a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_afyxi)
                 (@ a_afyxj)
                 (f_XfzYl [Occ=Once!] :: b_afyxi -> a_afyxj -> b_afyxi)
                 (z_XfzYn [Occ=Once*] :: b_afyxi)
                 (t1_XfzYp [Occ=Once] :: Option a_afyxj) ->
                 case t1_XfzYp
                      `cast` (Data.Semigroup.N:Option[0] <a_afyxj>_N
                              :: (Option a_afyxj :: *) ~R# (Maybe a_afyxj :: *))
                 of {
                   Nothing -> z_XfzYn;
                   Just m_afwMo [Occ=Once] -> f_XfzYl z_XfzYn m_afwMo
                 }}]
Data.Semigroup.$fFoldableOption_$cfoldl
  = \ (@ b_afyxi)
      (@ a_afyxj)
      (f_XfzYl :: b_afyxi -> a_afyxj -> b_afyxi)
      (z_XfzYn :: b_afyxi)
      (t1_XfzYp :: Option a_afyxj) ->
      case t1_XfzYp
           `cast` (Data.Semigroup.N:Option[0] <a_afyxj>_N
                   :: (Option a_afyxj :: *) ~R# (Maybe a_afyxj :: *))
      of {
        Nothing -> z_XfzYn;
        Just m_afwMo -> f_XfzYl z_XfzYn m_afwMo
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl9_rfC6f :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl9_rfC6f = "foldl1: empty structure"#

-- RHS size: {terms: 4, types: 4, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableOption8 :: forall a. a
[GblId, Str=x]
Data.Semigroup.$fFoldableOption8
  = \ (@ a_afyxU) ->
      errorWithoutStackTrace
        @ 'GHC.Types.LiftedRep
        @ a_afyxU
        (GHC.CString.unpackCString# lvl9_rfC6f)

-- RHS size: {terms: 9, types: 11, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableOption_$cfoldl1
  :: forall a. (a -> a -> a) -> Option a -> a
[GblId,
 Arity=2,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyxU)
                 _ [Occ=Dead]
                 (xs_XfzX5 [Occ=Once] :: Option a_afyxU) ->
                 case xs_XfzX5
                      `cast` (Data.Semigroup.N:Option[0] <a_afyxU>_N
                              :: (Option a_afyxU :: *) ~R# (Maybe a_afyxU :: *))
                 of {
                   Nothing -> Data.Semigroup.$fFoldableOption8 @ a_afyxU;
                   Just m_afwMo [Occ=Once] -> m_afwMo
                 }}]
Data.Semigroup.$fFoldableOption_$cfoldl1
  = \ (@ a_afyxU) _ [Occ=Dead] (xs_XfzX5 :: Option a_afyxU) ->
      case xs_XfzX5
           `cast` (Data.Semigroup.N:Option[0] <a_afyxU>_N
                   :: (Option a_afyxU :: *) ~R# (Maybe a_afyxU :: *))
      of {
        Nothing -> Data.Semigroup.$fFoldableOption8 @ a_afyxU;
        Just m_afwMo -> m_afwMo
      }

-- RHS size: {terms: 13, types: 13, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableOption_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Option a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyx4)
                 (@ b_afyx5)
                 (f_ifzEu [Occ=Once!] :: a_afyx4 -> b_afyx5 -> b_afyx5)
                 (z0_ifzEv [Occ=Once*] :: b_afyx5)
                 (xs_ifzEw [Occ=Once] :: Option a_afyx4) ->
                 case xs_ifzEw
                      `cast` (Data.Semigroup.N:Option[0] <a_afyx4>_N
                              :: (Option a_afyx4 :: *) ~R# (Maybe a_afyx4 :: *))
                 of {
                   Nothing -> z0_ifzEv;
                   Just m_afwMo [Occ=Once] -> f_ifzEu m_afwMo z0_ifzEv
                 }}]
Data.Semigroup.$fFoldableOption_$cfoldr'
  = \ (@ a_afyx4)
      (@ b_afyx5)
      (f_ifzEu :: a_afyx4 -> b_afyx5 -> b_afyx5)
      (z0_ifzEv :: b_afyx5)
      (xs_ifzEw :: Option a_afyx4) ->
      case xs_ifzEw
           `cast` (Data.Semigroup.N:Option[0] <a_afyx4>_N
                   :: (Option a_afyx4 :: *) ~R# (Maybe a_afyx4 :: *))
      of {
        Nothing -> z0_ifzEv;
        Just m_afwMo -> f_ifzEu m_afwMo z0_ifzEv
      }

-- RHS size: {terms: 8, types: 7, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableOption_$clength
  :: forall a. Option a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyyr) (xs_ifzER [Occ=Once] :: Option a_afyyr) ->
                 case xs_ifzER
                      `cast` (Data.Semigroup.N:Option[0] <a_afyyr>_N
                              :: (Option a_afyyr :: *) ~R# (Maybe a_afyyr :: *))
                 of {
                   Nothing -> Data.Semigroup.$fFoldableOption7;
                   Just _ [Occ=Dead] -> GHC.Types.I# 1#
                 }}]
Data.Semigroup.$fFoldableOption_$clength
  = \ (@ a_afyyr) (xs_ifzER :: Option a_afyyr) ->
      case xs_ifzER
           `cast` (Data.Semigroup.N:Option[0] <a_afyyr>_N
                   :: (Option a_afyyr :: *) ~R# (Maybe a_afyyr :: *))
      of {
        Nothing -> Data.Semigroup.$fFoldableOption7;
        Just m_afwMo -> Data.Semigroup.$fFoldableFirst3
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl10_rfC6g :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl10_rfC6g = "foldr1: empty structure"#

-- RHS size: {terms: 4, types: 4, coercions: 0, joins: 0/0}
Data.Semigroup.$fFoldableOption9 :: forall a. a
[GblId, Str=x]
Data.Semigroup.$fFoldableOption9
  = \ (@ a_afyxJ) ->
      errorWithoutStackTrace
        @ 'GHC.Types.LiftedRep
        @ a_afyxJ
        (GHC.CString.unpackCString# lvl10_rfC6g)

-- RHS size: {terms: 9, types: 11, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableOption_$cfoldr1
  :: forall a. (a -> a -> a) -> Option a -> a
[GblId,
 Arity=2,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyxJ)
                 _ [Occ=Dead]
                 (xs_XfzWR [Occ=Once] :: Option a_afyxJ) ->
                 case xs_XfzWR
                      `cast` (Data.Semigroup.N:Option[0] <a_afyxJ>_N
                              :: (Option a_afyxJ :: *) ~R# (Maybe a_afyxJ :: *))
                 of {
                   Nothing -> Data.Semigroup.$fFoldableOption9 @ a_afyxJ;
                   Just m_afwMo [Occ=Once] -> m_afwMo
                 }}]
Data.Semigroup.$fFoldableOption_$cfoldr1
  = \ (@ a_afyxJ) _ [Occ=Dead] (xs_XfzWR :: Option a_afyxJ) ->
      case xs_XfzWR
           `cast` (Data.Semigroup.N:Option[0] <a_afyxJ>_N
                   :: (Option a_afyxJ :: *) ~R# (Maybe a_afyxJ :: *))
      of {
        Nothing -> Data.Semigroup.$fFoldableOption9 @ a_afyxJ;
        Just m_afwMo -> m_afwMo
      }

-- RHS size: {terms: 8, types: 7, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableOption_$cnull
  :: forall a. Option a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyyg) (t1_ifzEp [Occ=Once] :: Option a_afyyg) ->
                 case t1_ifzEp
                      `cast` (Data.Semigroup.N:Option[0] <a_afyyg>_N
                              :: (Option a_afyyg :: *) ~R# (Maybe a_afyyg :: *))
                 of {
                   Nothing -> GHC.Types.True;
                   Just _ [Occ=Dead] -> GHC.Types.False
                 }}]
Data.Semigroup.$fFoldableOption_$cnull
  = \ (@ a_afyyg) (t1_ifzEp :: Option a_afyyg) ->
      case t1_ifzEp
           `cast` (Data.Semigroup.N:Option[0] <a_afyyg>_N
                   :: (Option a_afyyg :: *) ~R# (Maybe a_afyyg :: *))
      of {
        Nothing -> GHC.Types.True;
        Just m_afwMo -> GHC.Types.False
      }

-- RHS size: {terms: 10, types: 10, coercions: 8, joins: 0/0}
Data.Semigroup.$fFoldableOption1
  :: forall a. Num a => Option a -> Product a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyzs)
                 ($dNum_afyzu [Occ=Once] :: Num a_afyzs)
                 (ds_dfzE9 [Occ=Once] :: Option a_afyzs) ->
                 case ds_dfzE9
                      `cast` (Data.Semigroup.N:Option[0] <a_afyzs>_N
                              :: (Option a_afyzs :: *) ~R# (Maybe a_afyzs :: *))
                 of {
                   Nothing ->
                     (Data.Semigroup.Internal.$fMonoidProduct2 @ a_afyzs $dNum_afyzu)
                     `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_afyzs>_R)
                             :: (a_afyzs :: *) ~R# (Product a_afyzs :: *));
                   Just m_afwMo [Occ=Once] ->
                     m_afwMo
                     `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_afyzs>_R)
                             :: (a_afyzs :: *) ~R# (Product a_afyzs :: *))
                 }}]
Data.Semigroup.$fFoldableOption1
  = \ (@ a_afyzs)
      ($dNum_afyzu :: Num a_afyzs)
      (ds_dfzE9 :: Option a_afyzs) ->
      case ds_dfzE9
           `cast` (Data.Semigroup.N:Option[0] <a_afyzs>_N
                   :: (Option a_afyzs :: *) ~R# (Maybe a_afyzs :: *))
      of {
        Nothing ->
          (Data.Semigroup.Internal.$fMonoidProduct2 @ a_afyzs $dNum_afyzu)
          `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_afyzs>_R)
                  :: (a_afyzs :: *) ~R# (Product a_afyzs :: *));
        Just m_afwMo ->
          m_afwMo
          `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_afyzs>_R)
                  :: (a_afyzs :: *) ~R# (Product a_afyzs :: *))
      }

-- RHS size: {terms: 10, types: 10, coercions: 2, joins: 0/0}
Data.Semigroup.$fFoldableOption_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Option a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_afyy5) (t1_ifzFB [Occ=Once] :: Option a_afyy5) ->
                 GHC.Base.build
                   @ a_afyy5
                   (\ (@ b_ifzFC)
                      (c_ifzFD [Occ=Once, OS=OneShot] :: a_afyy5 -> b_ifzFC -> b_ifzFC)
                      (n_ifzFE [Occ=Once, OS=OneShot] :: b_ifzFC) ->
                      Data.Semigroup.$fFoldableOption_$cfoldr'
                        @ a_afyy5 @ b_ifzFC c_ifzFD n_ifzFE t1_ifzFB)}]
Data.Semigroup.$fFoldableOption_$ctoList
  = \ (@ a_afyy5) (eta_Xjv :: Option a_afyy5) ->
      case eta_Xjv
           `cast` (Data.Semigroup.N:Option[0] <a_afyy5>_N
                   :: (Option a_afyy5 :: *) ~R# (Maybe a_afyy5 :: *))
      of {
        Nothing -> GHC.Types.[] @ a_afyy5;
        Just m_afwMo ->
          GHC.Types.: @ a_afyy5 m_afwMo (GHC.Types.[] @ a_afyy5)
      }

-- RHS size: {terms: 17, types: 1, coercions: 22, joins: 0/0}
Data.Semigroup.$fFoldableOption [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable Option
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: Option
                                Data.Semigroup.$fFoldableOption_$cfold
                                Data.Semigroup.$fFoldableOption_$cfoldMap
                                Data.Semigroup.$fFoldableOption_$cfoldr'
                                Data.Semigroup.$fFoldableOption_$cfoldr'
                                Data.Semigroup.$fFoldableOption_$cfoldl
                                Data.Semigroup.$fFoldableOption_$cfoldl
                                Data.Semigroup.$fFoldableOption_$cfoldr1
                                Data.Semigroup.$fFoldableOption_$cfoldl1
                                Data.Semigroup.$fFoldableOption_$ctoList
                                Data.Semigroup.$fFoldableOption_$cnull
                                Data.Semigroup.$fFoldableOption_$clength
                                Data.Semigroup.$fFoldableOption_$celem
                                Data.Semigroup.$fFoldableOption_$cmaximum
                                Data.Semigroup.$fFoldableOption_$cminimum
                                Data.Semigroup.$fFoldableOption2
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <Option a>_R
                                        ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
                                        :: (forall a. Num a => Option a -> Sum a :: *)
                                           ~R# (forall a. Num a => Option a -> a :: *))
                                Data.Semigroup.$fFoldableOption1
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <Option a>_R
                                        ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
                                        :: (forall a. Num a => Option a -> Product a :: *)
                                           ~R# (forall a. Num a => Option a -> a :: *))]
Data.Semigroup.$fFoldableOption
  = Data.Foldable.C:Foldable
      @ Option
      Data.Semigroup.$fFoldableOption_$cfold
      Data.Semigroup.$fFoldableOption_$cfoldMap
      Data.Semigroup.$fFoldableOption_$cfoldr'
      Data.Semigroup.$fFoldableOption_$cfoldr'
      Data.Semigroup.$fFoldableOption_$cfoldl
      Data.Semigroup.$fFoldableOption_$cfoldl
      Data.Semigroup.$fFoldableOption_$cfoldr1
      Data.Semigroup.$fFoldableOption_$cfoldl1
      Data.Semigroup.$fFoldableOption_$ctoList
      Data.Semigroup.$fFoldableOption_$cnull
      Data.Semigroup.$fFoldableOption_$clength
      Data.Semigroup.$fFoldableOption_$celem
      Data.Semigroup.$fFoldableOption_$cmaximum
      Data.Semigroup.$fFoldableOption_$cminimum
      (Data.Semigroup.$fFoldableOption2
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <Option a>_R
               ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall a. Num a => Option a -> Sum a :: *)
                  ~R# (forall a. Num a => Option a -> a :: *)))
      (Data.Semigroup.$fFoldableOption1
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <Option a>_R
               ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall a. Num a => Option a -> Product a :: *)
                  ~R# (forall a. Num a => Option a -> a :: *)))

-- RHS size: {terms: 19, types: 28, coercions: 10, joins: 0/0}
Data.Semigroup.$fTraversableOption_$ctraverse
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> f b) -> Option a -> f (Option b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 60 60] 130 0}]
Data.Semigroup.$fTraversableOption_$ctraverse
  = \ (@ (f_afyvr :: * -> *))
      (@ a_afyvs)
      (@ b_afyvt)
      ($dApplicative_afyvv :: Applicative f_afyvr)
      (eta_B2 :: a_afyvs -> f_afyvr b_afyvt)
      (eta1_Xi3 :: Option a_afyvs) ->
      case eta1_Xi3
           `cast` (Data.Semigroup.N:Option[0] <a_afyvs>_N
                   :: (Option a_afyvs :: *) ~R# (Maybe a_afyvs :: *))
      of {
        Nothing ->
          pure
            @ f_afyvr
            $dApplicative_afyvv
            @ (Option b_afyvt)
            ((GHC.Base.Nothing @ b_afyvt)
             `cast` (Sym (Data.Semigroup.N:Option[0]) <b_afyvt>_N
                     :: (Maybe b_afyvt :: *) ~R# (Option b_afyvt :: *)));
        Just a1_afwMm ->
          fmap
            @ f_afyvr
            (GHC.Base.$p1Applicative @ f_afyvr $dApplicative_afyvv)
            @ b_afyvt
            @ (Option b_afyvt)
            ((GHC.Base.Just @ b_afyvt)
             `cast` (<b_afyvt>_R
                     ->_R Sym (Data.Semigroup.N:Option[0]) <b_afyvt>_N
                     :: (b_afyvt -> Maybe b_afyvt :: *)
                        ~R# (b_afyvt -> Option b_afyvt :: *)))
            (eta_B2 a1_afwMm)
      }

-- RHS size: {terms: 16, types: 26, coercions: 11, joins: 0/0}
Data.Semigroup.$fTraversableOption_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     Applicative f =>
     Option (f a) -> f (Option a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_afyvO :: * -> *))
                 (@ a_afyvP)
                 ($dApplicative_afyvR [Occ=Once*] :: Applicative f_afyvO)
                 (eta_XDR [Occ=Once] :: Option (f_afyvO a_afyvP)) ->
                 case eta_XDR
                      `cast` (Data.Semigroup.N:Option[0] <f_afyvO a_afyvP>_N
                              :: (Option (f_afyvO a_afyvP) :: *)
                                 ~R# (Maybe (f_afyvO a_afyvP) :: *))
                 of {
                   Nothing ->
                     pure
                       @ f_afyvO
                       $dApplicative_afyvR
                       @ (Option a_afyvP)
                       ((GHC.Base.Nothing @ a_afyvP)
                        `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afyvP>_N
                                :: (Maybe a_afyvP :: *) ~R# (Option a_afyvP :: *)));
                   Just a1_afwMm [Occ=Once] ->
                     fmap
                       @ f_afyvO
                       (GHC.Base.$p1Applicative @ f_afyvO $dApplicative_afyvR)
                       @ a_afyvP
                       @ (Option a_afyvP)
                       ((GHC.Base.Just @ a_afyvP)
                        `cast` (<a_afyvP>_R
                                ->_R Sym (Data.Semigroup.N:Option[0]) <a_afyvP>_N
                                :: (a_afyvP -> Maybe a_afyvP :: *)
                                   ~R# (a_afyvP -> Option a_afyvP :: *)))
                       a1_afwMm
                 }}]
Data.Semigroup.$fTraversableOption_$csequenceA
  = \ (@ (f_afyvO :: * -> *))
      (@ a_afyvP)
      ($dApplicative_afyvR :: Applicative f_afyvO)
      (eta_XDR :: Option (f_afyvO a_afyvP)) ->
      case eta_XDR
           `cast` (Data.Semigroup.N:Option[0] <f_afyvO a_afyvP>_N
                   :: (Option (f_afyvO a_afyvP) :: *)
                      ~R# (Maybe (f_afyvO a_afyvP) :: *))
      of {
        Nothing ->
          pure
            @ f_afyvO
            $dApplicative_afyvR
            @ (Option a_afyvP)
            ((GHC.Base.Nothing @ a_afyvP)
             `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afyvP>_N
                     :: (Maybe a_afyvP :: *) ~R# (Option a_afyvP :: *)));
        Just a1_afwMm ->
          fmap
            @ f_afyvO
            (GHC.Base.$p1Applicative @ f_afyvO $dApplicative_afyvR)
            @ a_afyvP
            @ (Option a_afyvP)
            ((GHC.Base.Just @ a_afyvP)
             `cast` (<a_afyvP>_R
                     ->_R Sym (Data.Semigroup.N:Option[0]) <a_afyvP>_N
                     :: (a_afyvP -> Maybe a_afyvP :: *)
                        ~R# (a_afyvP -> Option a_afyvP :: *)))
            a1_afwMm
      }

-- RHS size: {terms: 11, types: 19, coercions: 0, joins: 0/0}
Data.Semigroup.$fTraversableOption_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     Monad m =>
     (a -> m b) -> Option a -> m (Option b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_afyw0 :: * -> *))
                 (@ a_afyw1)
                 (@ b_afyw2)
                 ($dMonad_afyw4 [Occ=Once] :: Monad m_afyw0) ->
                 Data.Semigroup.$fTraversableOption_$ctraverse
                   @ m_afyw0
                   @ a_afyw1
                   @ b_afyw2
                   (GHC.Base.$p1Monad @ m_afyw0 $dMonad_afyw4)}]
Data.Semigroup.$fTraversableOption_$cmapM
  = \ (@ (m_afyw0 :: * -> *))
      (@ a_afyw1)
      (@ b_afyw2)
      ($dMonad_afyw4 :: Monad m_afyw0)
      (eta_B2 :: a_afyw1 -> m_afyw0 b_afyw2)
      (eta1_Xi5 :: Option a_afyw1) ->
      Data.Semigroup.$fTraversableOption_$ctraverse
        @ m_afyw0
        @ a_afyw1
        @ b_afyw2
        (GHC.Base.$p1Monad @ m_afyw0 $dMonad_afyw4)
        eta_B2
        eta1_Xi5

-- RHS size: {terms: 18, types: 28, coercions: 11, joins: 0/0}
Data.Semigroup.$fTraversableOption_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a. Monad m => Option (m a) -> m (Option a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_afywe :: * -> *))
                 (@ a_afywf)
                 ($dMonad_afywh [Occ=OnceL] :: Monad m_afywe) ->
                 let {
                   $dApplicative_afyvR [Occ=OnceL*] :: Applicative m_afywe
                   [LclId]
                   $dApplicative_afyvR
                     = GHC.Base.$p1Monad @ m_afywe $dMonad_afywh } in
                 \ (eta_XDR [Occ=Once] :: Option (m_afywe a_afywf)) ->
                   case eta_XDR
                        `cast` (Data.Semigroup.N:Option[0] <m_afywe a_afywf>_N
                                :: (Option (m_afywe a_afywf) :: *)
                                   ~R# (Maybe (m_afywe a_afywf) :: *))
                   of {
                     Nothing ->
                       pure
                         @ m_afywe
                         $dApplicative_afyvR
                         @ (Option a_afywf)
                         ((GHC.Base.Nothing @ a_afywf)
                          `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afywf>_N
                                  :: (Maybe a_afywf :: *) ~R# (Option a_afywf :: *)));
                     Just a1_afwMm [Occ=Once] ->
                       fmap
                         @ m_afywe
                         (GHC.Base.$p1Applicative @ m_afywe $dApplicative_afyvR)
                         @ a_afywf
                         @ (Option a_afywf)
                         ((GHC.Base.Just @ a_afywf)
                          `cast` (<a_afywf>_R
                                  ->_R Sym (Data.Semigroup.N:Option[0]) <a_afywf>_N
                                  :: (a_afywf -> Maybe a_afywf :: *)
                                     ~R# (a_afywf -> Option a_afywf :: *)))
                         a1_afwMm
                   }}]
Data.Semigroup.$fTraversableOption_$csequence
  = \ (@ (m_afywe :: * -> *))
      (@ a_afywf)
      ($dMonad_afywh :: Monad m_afywe)
      (eta_B1 :: Option (m_afywe a_afywf)) ->
      case eta_B1
           `cast` (Data.Semigroup.N:Option[0] <m_afywe a_afywf>_N
                   :: (Option (m_afywe a_afywf) :: *)
                      ~R# (Maybe (m_afywe a_afywf) :: *))
      of {
        Nothing ->
          pure
            @ m_afywe
            (GHC.Base.$p1Monad @ m_afywe $dMonad_afywh)
            @ (Option a_afywf)
            ((GHC.Base.Nothing @ a_afywf)
             `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afywf>_N
                     :: (Maybe a_afywf :: *) ~R# (Option a_afywf :: *)));
        Just a1_afwMm ->
          fmap
            @ m_afywe
            (GHC.Base.$p1Applicative
               @ m_afywe (GHC.Base.$p1Monad @ m_afywe $dMonad_afywh))
            @ a_afywf
            @ (Option a_afywf)
            ((GHC.Base.Just @ a_afywf)
             `cast` (<a_afywf>_R
                     ->_R Sym (Data.Semigroup.N:Option[0]) <a_afywf>_N
                     :: (a_afywf -> Maybe a_afywf :: *)
                        ~R# (a_afywf -> Option a_afywf :: *)))
            a1_afwMm
      }

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
Data.Semigroup.$fTraversableOption [InlPrag=NOUSERINLINE CONLIKE]
  :: Traversable Option
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Data.Traversable.C:Traversable TYPE: Option
                                      Data.Semigroup.$fFunctorOption
                                      Data.Semigroup.$fFoldableOption
                                      Data.Semigroup.$fTraversableOption_$ctraverse
                                      Data.Semigroup.$fTraversableOption_$csequenceA
                                      Data.Semigroup.$fTraversableOption_$cmapM
                                      Data.Semigroup.$fTraversableOption_$csequence]
Data.Semigroup.$fTraversableOption
  = Data.Traversable.C:Traversable
      @ Option
      Data.Semigroup.$fFunctorOption
      Data.Semigroup.$fFoldableOption
      Data.Semigroup.$fTraversableOption_$ctraverse
      Data.Semigroup.$fTraversableOption_$csequenceA
      Data.Semigroup.$fTraversableOption_$cmapM
      Data.Semigroup.$fTraversableOption_$csequence

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl11_rfC6h :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl11_rfC6h = "stimes: Option, negative multiplier"#

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Data.Semigroup.$fSemigroupOption1 :: forall a. Option a
[GblId, Str=x]
Data.Semigroup.$fSemigroupOption1
  = \ (@ a_afyuq) ->
      errorWithoutStackTrace
        @ 'GHC.Types.LiftedRep
        @ (Option a_afyuq)
        (GHC.CString.unpackCString# lvl11_rfC6h)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fSemigroupOption2 :: Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Data.Semigroup.$fSemigroupOption2 = 0

-- RHS size: {terms: 34, types: 28, coercions: 11, joins: 0/1}
Data.Semigroup.$fSemigroupOption_$cstimes
  :: forall a.
     Semigroup a =>
     forall b. Integral b => b -> Option a -> Option a
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,U(U(U(U,U,U,U,U,U,U),U(U,U,U,U,U,U,U,U),U),U,U,U,U,U,U,U,U)><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 30] 250 40}]
Data.Semigroup.$fSemigroupOption_$cstimes
  = \ (@ a_afyuq)
      ($dSemigroup_afyur :: Semigroup a_afyuq)
      (@ b_afyuS)
      ($dIntegral_afyuU :: Integral b_afyuS)
      (eta_B2 :: b_afyuS)
      (eta1_Xi8 :: Option a_afyuq) ->
      case eta1_Xi8
           `cast` (Data.Semigroup.N:Option[0] <a_afyuq>_N
                   :: (Option a_afyuq :: *) ~R# (Maybe a_afyuq :: *))
      of {
        Nothing ->
          (GHC.Base.Nothing @ a_afyuq)
          `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afyuq>_N
                  :: (Maybe a_afyuq :: *) ~R# (Option a_afyuq :: *));
        Just a1_afwMk ->
          let {
            $dReal_sfAia [Dmd=<S(LS(LC(C(S))LLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,1*C1(C1(U)),A,A,A,A,A,A),A)>]
              :: Real b_afyuS
            [LclId]
            $dReal_sfAia = GHC.Real.$p1Integral @ b_afyuS $dIntegral_afyuU } in
          case compare
                 @ b_afyuS
                 (GHC.Real.$p2Real @ b_afyuS $dReal_sfAia)
                 eta_B2
                 (fromInteger
                    @ b_afyuS
                    (GHC.Real.$p1Real @ b_afyuS $dReal_sfAia)
                    Data.Semigroup.$fSemigroupOption2)
          of {
            LT -> Data.Semigroup.$fSemigroupOption1 @ a_afyuq;
            EQ ->
              (GHC.Base.Nothing @ a_afyuq)
              `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afyuq>_N
                      :: (Maybe a_afyuq :: *) ~R# (Option a_afyuq :: *));
            GT ->
              (GHC.Base.Just
                 @ a_afyuq
                 (stimes
                    @ a_afyuq
                    $dSemigroup_afyur
                    @ b_afyuS
                    $dIntegral_afyuU
                    eta_B2
                    a1_afwMk))
              `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afyuq>_N
                      :: (Maybe a_afyuq :: *) ~R# (Option a_afyuq :: *))
          }
      }

-- RHS size: {terms: 34, types: 37, coercions: 10, joins: 0/1}
Data.Semigroup.$w$csconcat2 [InlPrag=NOUSERINLINE[0]]
  :: forall a. Semigroup a => Option a -> [Option a] -> Option a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 230 0}]
Data.Semigroup.$w$csconcat2
  = \ (@ a_sfBqa)
      (w_sfBqb :: Semigroup a_sfBqa)
      (ww_sfBqf :: Option a_sfBqa)
      (ww1_sfBqg :: [Option a_sfBqa]) ->
      letrec {
        go_sfAi8 [Occ=LoopBreaker]
          :: Option a_sfBqa -> [Option a_sfBqa] -> Option a_sfBqa
        [LclId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
        go_sfAi8
          = \ (b_i9ine :: Option a_sfBqa) (ds1_i9inf :: [Option a_sfBqa]) ->
              case ds1_i9inf of {
                [] -> b_i9ine;
                : c_i9inn cs_i9ino ->
                  case b_i9ine
                       `cast` (Data.Semigroup.N:Option[0] <a_sfBqa>_N
                               :: (Option a_sfBqa :: *) ~R# (Maybe a_sfBqa :: *))
                  of wild_ifzUE {
                    Nothing -> go_sfAi8 c_i9inn cs_i9ino;
                    Just ipv_ifzUI ->
                      case (go_sfAi8 c_i9inn cs_i9ino)
                           `cast` (Data.Semigroup.N:Option[0] <a_sfBqa>_N
                                   :: (Option a_sfBqa :: *) ~R# (Maybe a_sfBqa :: *))
                      of {
                        Nothing ->
                          wild_ifzUE
                          `cast` (Sym (Data.Semigroup.N:Option[0]) <a_sfBqa>_N
                                  :: (Maybe a_sfBqa :: *) ~R# (Option a_sfBqa :: *));
                        Just ipv1_ifzUO ->
                          (GHC.Base.Just
                             @ a_sfBqa (<> @ a_sfBqa w_sfBqb ipv_ifzUI ipv1_ifzUO))
                          `cast` (Sym (Data.Semigroup.N:Option[0]) <a_sfBqa>_N
                                  :: (Maybe a_sfBqa :: *) ~R# (Option a_sfBqa :: *))
                      }
                  }
              }; } in
      go_sfAi8 ww_sfBqf ww1_sfBqg

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
Data.Semigroup.$fSemigroupOption_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Semigroup a =>
     GHC.Base.NonEmpty (Option a) -> Option a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(SS),1*U(1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sfBqa)
                 (w_sfBqb [Occ=Once] :: Semigroup a_sfBqa)
                 (w1_sfBqc [Occ=Once!] :: GHC.Base.NonEmpty (Option a_sfBqa)) ->
                 case w1_sfBqc of
                 { GHC.Base.:| ww1_sfBqf [Occ=Once] ww2_sfBqg [Occ=Once] ->
                 Data.Semigroup.$w$csconcat2 @ a_sfBqa w_sfBqb ww1_sfBqf ww2_sfBqg
                 }}]
Data.Semigroup.$fSemigroupOption_$csconcat
  = \ (@ a_sfBqa)
      (w_sfBqb :: Semigroup a_sfBqa)
      (w1_sfBqc :: GHC.Base.NonEmpty (Option a_sfBqa)) ->
      case w1_sfBqc of { GHC.Base.:| ww1_sfBqf ww2_sfBqg ->
      Data.Semigroup.$w$csconcat2 @ a_sfBqa w_sfBqb ww1_sfBqf ww2_sfBqg
      }

-- RHS size: {terms: 9, types: 9, coercions: 11, joins: 0/0}
Data.Semigroup.$fSemigroupOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Semigroup a => Semigroup (Option a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m,
 Unf=DFun: \ (@ a_afwMi) (v_XjV :: Semigroup a_afwMi) ->
       GHC.Base.C:Semigroup TYPE: Option a_afwMi
                            (GHC.Base.$fMonoidMaybe_$c<> @ a_afwMi v_XjV)
                            `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afwMi>_N
                                    ->_R Sym (Data.Semigroup.N:Option[0]) <a_afwMi>_N
                                    ->_R Sym (Data.Semigroup.N:Option[0]) <a_afwMi>_N
                                    :: (Maybe a_afwMi -> Maybe a_afwMi -> Maybe a_afwMi :: *)
                                       ~R# (Option a_afwMi
                                            -> Option a_afwMi -> Option a_afwMi :: *))
                            Data.Semigroup.$fSemigroupOption_$csconcat @ a_afwMi v_XjV
                            Data.Semigroup.$fSemigroupOption_$cstimes @ a_afwMi v_XjV]
Data.Semigroup.$fSemigroupOption
  = \ (@ a_afyuq) ($dSemigroup_afyur :: Semigroup a_afyuq) ->
      GHC.Base.C:Semigroup
        @ (Option a_afyuq)
        ((GHC.Base.$fMonoidMaybe_$c<> @ a_afyuq $dSemigroup_afyur)
         `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afyuq>_N
                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_afyuq>_N
                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_afyuq>_N
                 :: (Maybe a_afyuq -> Maybe a_afyuq -> Maybe a_afyuq :: *)
                    ~R# (Option a_afyuq -> Option a_afyuq -> Option a_afyuq :: *)))
        (Data.Semigroup.$fSemigroupOption_$csconcat
           @ a_afyuq $dSemigroup_afyur)
        (Data.Semigroup.$fSemigroupOption_$cstimes
           @ a_afyuq $dSemigroup_afyur)

-- RHS size: {terms: 29, types: 32, coercions: 13, joins: 0/1}
Data.Semigroup.$fMonoidOption_$cmconcat
  :: forall a. Semigroup a => [Option a] -> Option a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 190 0}]
Data.Semigroup.$fMonoidOption_$cmconcat
  = \ (@ a_XfyO3)
      ($dSemigroup_XfyO5 :: Semigroup a_XfyO3)
      (eta_B1 :: [Option a_XfyO3]) ->
      letrec {
        go_i7Jcj [Occ=LoopBreaker] :: [Option a_XfyO3] -> Option a_XfyO3
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_i7Jcj
          = \ (ds_i7Jck :: [Option a_XfyO3]) ->
              case ds_i7Jck of {
                [] ->
                  (GHC.Base.Nothing @ a_XfyO3)
                  `cast` (Sym (Data.Semigroup.N:Option[0]) <a_XfyO3>_N
                          :: (Maybe a_XfyO3 :: *) ~R# (Option a_XfyO3 :: *));
                : y_i7Jcp ys_i7Jcq ->
                  case y_i7Jcp
                       `cast` (Data.Semigroup.N:Option[0] <a_XfyO3>_N
                               :: (Option a_XfyO3 :: *) ~R# (Maybe a_XfyO3 :: *))
                  of wild1_ifzUE {
                    Nothing -> go_i7Jcj ys_i7Jcq;
                    Just ipv_ifzUI ->
                      case (go_i7Jcj ys_i7Jcq)
                           `cast` (Data.Semigroup.N:Option[0] <a_XfyO3>_N
                                   :: (Option a_XfyO3 :: *) ~R# (Maybe a_XfyO3 :: *))
                      of {
                        Nothing ->
                          wild1_ifzUE
                          `cast` (Sym (Data.Semigroup.N:Option[0]) <a_XfyO3>_N
                                  :: (Maybe a_XfyO3 :: *) ~R# (Option a_XfyO3 :: *));
                        Just ipv1_ifzUO ->
                          (GHC.Base.Just
                             @ a_XfyO3 (<> @ a_XfyO3 $dSemigroup_XfyO5 ipv_ifzUI ipv1_ifzUO))
                          `cast` (Sym (Data.Semigroup.N:Option[0]) <a_XfyO3>_N
                                  :: (Maybe a_XfyO3 :: *) ~R# (Option a_XfyO3 :: *))
                      }
                  }
              }; } in
      go_i7Jcj eta_B1

-- RHS size: {terms: 10, types: 10, coercions: 14, joins: 0/0}
Data.Semigroup.$fMonoidOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Semigroup a => Monoid (Option a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m,
 Unf=DFun: \ (@ a_afwMh) (v_Xk1 :: Semigroup a_afwMh) ->
       GHC.Base.C:Monoid TYPE: Option a_afwMh
                         Data.Semigroup.$fSemigroupOption @ a_afwMh v_Xk1
                         (GHC.Base.Nothing @ a_afwMh)
                         `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afwMh>_N
                                 :: (Maybe a_afwMh :: *) ~R# (Option a_afwMh :: *))
                         (GHC.Base.$fMonoidMaybe_$c<> @ a_afwMh v_Xk1)
                         `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afwMh>_N
                                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_afwMh>_N
                                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_afwMh>_N
                                 :: (Maybe a_afwMh -> Maybe a_afwMh -> Maybe a_afwMh :: *)
                                    ~R# (Option a_afwMh -> Option a_afwMh -> Option a_afwMh :: *))
                         Data.Semigroup.$fMonoidOption_$cmconcat @ a_afwMh v_Xk1]
Data.Semigroup.$fMonoidOption
  = \ (@ a_XfyO1) ($dSemigroup_XfyO3 :: Semigroup a_XfyO1) ->
      GHC.Base.C:Monoid
        @ (Option a_XfyO1)
        (Data.Semigroup.$fSemigroupOption @ a_XfyO1 $dSemigroup_XfyO3)
        ((GHC.Base.Nothing @ a_XfyO1)
         `cast` (Sym (Data.Semigroup.N:Option[0]) <a_XfyO1>_N
                 :: (Maybe a_XfyO1 :: *) ~R# (Option a_XfyO1 :: *)))
        ((GHC.Base.$fMonoidMaybe_$c<> @ a_XfyO1 $dSemigroup_XfyO3)
         `cast` (Sym (Data.Semigroup.N:Option[0]) <a_XfyO1>_N
                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_XfyO1>_N
                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_XfyO1>_N
                 :: (Maybe a_XfyO1 -> Maybe a_XfyO1 -> Maybe a_XfyO1 :: *)
                    ~R# (Option a_XfyO1 -> Option a_XfyO1 -> Option a_XfyO1 :: *)))
        (Data.Semigroup.$fMonoidOption_$cmconcat
           @ a_XfyO1 $dSemigroup_XfyO3)

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fGeneric1Option1
  :: forall a. Rep1 Option a -> Rep1 Option a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afytB) (ds_dfzDu [Occ=Once] :: Rep1 Option a_afytB) ->
                 ds_dfzDu}]
Data.Semigroup.$fGeneric1Option1
  = \ (@ a_afytB) (ds_dfzDu :: Rep1 Option a_afytB) -> ds_dfzDu

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Semigroup.$fGeneric1Option2 :: forall a. Option a -> Option a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyta) (x_afxr4 [Occ=Once] :: Option a_afyta) ->
                 x_afxr4}]
Data.Semigroup.$fGeneric1Option2
  = \ (@ a_afyta) (x_afxr4 :: Option a_afyta) -> x_afxr4

-- RHS size: {terms: 3, types: 3, coercions: 184, joins: 0/0}
Data.Semigroup.$fGeneric1Option [InlPrag=NOUSERINLINE CONLIKE]
  :: Generic1 Option
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Generics.C:Generic1 TYPE: *
                               TYPE: Option
                               Data.Semigroup.$fGeneric1Option2
                               `cast` (forall (a :: <*>_N).
                                       <Option a>_R
                                       ->_R (Sym (GHC.Generics.N:Rec1[0]
                                                      <*>_N
                                                      (Sym (Data.Semigroup.N:Option[0]))) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                      <*>_N
                                                                                                      <S>_P
                                                                                                      <'MetaSel
                                                                                                         ('Just
                                                                                                            "getOption")
                                                                                                         'NoSourceUnpackedness
                                                                                                         'NoSourceStrictness
                                                                                                         'DecidedLazy>_P
                                                                                                      <Rec1
                                                                                                         Maybe>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                               <*>_N
                                                                                                                               <C>_P
                                                                                                                               <'MetaCons
                                                                                                                                  "Option"
                                                                                                                                  'PrefixI
                                                                                                                                  'True>_P
                                                                                                                               <M1
                                                                                                                                  S
                                                                                                                                  ('MetaSel
                                                                                                                                     ('Just
                                                                                                                                        "getOption")
                                                                                                                                     'NoSourceUnpackedness
                                                                                                                                     'NoSourceStrictness
                                                                                                                                     'DecidedLazy)
                                                                                                                                  (Rec1
                                                                                                                                     Maybe)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                            <*>_N
                                                                                                                                                            <D>_P
                                                                                                                                                            <'MetaData
                                                                                                                                                               "Option"
                                                                                                                                                               "Data.Semigroup"
                                                                                                                                                               "base"
                                                                                                                                                               'True>_P
                                                                                                                                                            <M1
                                                                                                                                                               C
                                                                                                                                                               ('MetaCons
                                                                                                                                                                  "Option"
                                                                                                                                                                  'PrefixI
                                                                                                                                                                  'True)
                                                                                                                                                               (M1
                                                                                                                                                                  S
                                                                                                                                                                  ('MetaSel
                                                                                                                                                                     ('Just
                                                                                                                                                                        "getOption")
                                                                                                                                                                     'NoSourceUnpackedness
                                                                                                                                                                     'NoSourceStrictness
                                                                                                                                                                     'DecidedLazy)
                                                                                                                                                                  (Rec1
                                                                                                                                                                     Maybe))>_R) ; Sub (Sym (Data.Semigroup.Rep1_Option[0])))))) <a>_N
                                       :: (forall a. Option a -> Option a :: *)
                                          ~R# (forall a. Option a -> Rep1 Option a :: *))
                               Data.Semigroup.$fGeneric1Option1
                               `cast` (forall (a :: <*>_N).
                                       <Rep1 Option a>_R
                                       ->_R (Sub (Data.Semigroup.Rep1_Option[0]) ; (GHC.Generics.N:M1[0]
                                                                                        <*>_N
                                                                                        <D>_P
                                                                                        <'MetaData
                                                                                           "Option"
                                                                                           "Data.Semigroup"
                                                                                           "base"
                                                                                           'True>_P
                                                                                        <M1
                                                                                           C
                                                                                           ('MetaCons
                                                                                              "Option"
                                                                                              'PrefixI
                                                                                              'True)
                                                                                           (M1
                                                                                              S
                                                                                              ('MetaSel
                                                                                                 ('Just
                                                                                                    "getOption")
                                                                                                 'NoSourceUnpackedness
                                                                                                 'NoSourceStrictness
                                                                                                 'DecidedLazy)
                                                                                              (Rec1
                                                                                                 Maybe))>_R ; (GHC.Generics.N:M1[0]
                                                                                                                   <*>_N
                                                                                                                   <C>_P
                                                                                                                   <'MetaCons
                                                                                                                      "Option"
                                                                                                                      'PrefixI
                                                                                                                      'True>_P
                                                                                                                   <M1
                                                                                                                      S
                                                                                                                      ('MetaSel
                                                                                                                         ('Just
                                                                                                                            "getOption")
                                                                                                                         'NoSourceUnpackedness
                                                                                                                         'NoSourceStrictness
                                                                                                                         'DecidedLazy)
                                                                                                                      (Rec1
                                                                                                                         Maybe)>_R ; (GHC.Generics.N:M1[0]
                                                                                                                                          <*>_N
                                                                                                                                          <S>_P
                                                                                                                                          <'MetaSel
                                                                                                                                             ('Just
                                                                                                                                                "getOption")
                                                                                                                                             'NoSourceUnpackedness
                                                                                                                                             'NoSourceStrictness
                                                                                                                                             'DecidedLazy>_P
                                                                                                                                          <Rec1
                                                                                                                                             Maybe>_R ; GHC.Generics.N:Rec1[0]
                                                                                                                                                            <*>_N
                                                                                                                                                            (Sym (Data.Semigroup.N:Option[0])))))) <a>_N
                                       :: (forall a. Rep1 Option a -> Rep1 Option a :: *)
                                          ~R# (forall a. Rep1 Option a -> Option a :: *))]
Data.Semigroup.$fGeneric1Option
  = GHC.Generics.C:Generic1
      @ *
      @ Option
      (Data.Semigroup.$fGeneric1Option2
       `cast` (forall (a :: <*>_N).
               <Option a>_R
               ->_R (Sym (GHC.Generics.N:Rec1[0]
                              <*>_N
                              (Sym (Data.Semigroup.N:Option[0]))) ; (Sym (GHC.Generics.N:M1[0]
                                                                              <*>_N
                                                                              <S>_P
                                                                              <'MetaSel
                                                                                 ('Just "getOption")
                                                                                 'NoSourceUnpackedness
                                                                                 'NoSourceStrictness
                                                                                 'DecidedLazy>_P
                                                                              <Rec1
                                                                                 Maybe>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                       <*>_N
                                                                                                       <C>_P
                                                                                                       <'MetaCons
                                                                                                          "Option"
                                                                                                          'PrefixI
                                                                                                          'True>_P
                                                                                                       <M1
                                                                                                          S
                                                                                                          ('MetaSel
                                                                                                             ('Just
                                                                                                                "getOption")
                                                                                                             'NoSourceUnpackedness
                                                                                                             'NoSourceStrictness
                                                                                                             'DecidedLazy)
                                                                                                          (Rec1
                                                                                                             Maybe)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                    <*>_N
                                                                                                                                    <D>_P
                                                                                                                                    <'MetaData
                                                                                                                                       "Option"
                                                                                                                                       "Data.Semigroup"
                                                                                                                                       "base"
                                                                                                                                       'True>_P
                                                                                                                                    <M1
                                                                                                                                       C
                                                                                                                                       ('MetaCons
                                                                                                                                          "Option"
                                                                                                                                          'PrefixI
                                                                                                                                          'True)
                                                                                                                                       (M1
                                                                                                                                          S
                                                                                                                                          ('MetaSel
                                                                                                                                             ('Just
                                                                                                                                                "getOption")
                                                                                                                                             'NoSourceUnpackedness
                                                                                                                                             'NoSourceStrictness
                                                                                                                                             'DecidedLazy)
                                                                                                                                          (Rec1
                                                                                                                                             Maybe))>_R) ; Sub (Sym (Data.Semigroup.Rep1_Option[0])))))) <a>_N
               :: (forall a. Option a -> Option a :: *)
                  ~R# (forall a. Option a -> Rep1 Option a :: *)))
      (Data.Semigroup.$fGeneric1Option1
       `cast` (forall (a :: <*>_N).
               <Rep1 Option a>_R
               ->_R (Sub (Data.Semigroup.Rep1_Option[0]) ; (GHC.Generics.N:M1[0]
                                                                <*>_N
                                                                <D>_P
                                                                <'MetaData
                                                                   "Option"
                                                                   "Data.Semigroup"
                                                                   "base"
                                                                   'True>_P
                                                                <M1
                                                                   C
                                                                   ('MetaCons
                                                                      "Option" 'PrefixI 'True)
                                                                   (M1
                                                                      S
                                                                      ('MetaSel
                                                                         ('Just "getOption")
                                                                         'NoSourceUnpackedness
                                                                         'NoSourceStrictness
                                                                         'DecidedLazy)
                                                                      (Rec1
                                                                         Maybe))>_R ; (GHC.Generics.N:M1[0]
                                                                                           <*>_N
                                                                                           <C>_P
                                                                                           <'MetaCons
                                                                                              "Option"
                                                                                              'PrefixI
                                                                                              'True>_P
                                                                                           <M1
                                                                                              S
                                                                                              ('MetaSel
                                                                                                 ('Just
                                                                                                    "getOption")
                                                                                                 'NoSourceUnpackedness
                                                                                                 'NoSourceStrictness
                                                                                                 'DecidedLazy)
                                                                                              (Rec1
                                                                                                 Maybe)>_R ; (GHC.Generics.N:M1[0]
                                                                                                                  <*>_N
                                                                                                                  <S>_P
                                                                                                                  <'MetaSel
                                                                                                                     ('Just
                                                                                                                        "getOption")
                                                                                                                     'NoSourceUnpackedness
                                                                                                                     'NoSourceStrictness
                                                                                                                     'DecidedLazy>_P
                                                                                                                  <Rec1
                                                                                                                     Maybe>_R ; GHC.Generics.N:Rec1[0]
                                                                                                                                    <*>_N
                                                                                                                                    (Sym (Data.Semigroup.N:Option[0])))))) <a>_N
               :: (forall a. Rep1 Option a -> Rep1 Option a :: *)
                  ~R# (forall a. Rep1 Option a -> Option a :: *)))

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fGenericOption1
  :: forall a x. Rep (Option a) x -> Rep (Option a) x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afys9)
                 (@ x_afysF)
                 (ds_dfzDo [Occ=Once] :: Rep (Option a_afys9) x_afysF) ->
                 ds_dfzDo}]
Data.Semigroup.$fGenericOption1
  = \ (@ a_afys9)
      (@ x_afysF)
      (ds_dfzDo :: Rep (Option a_afys9) x_afysF) ->
      ds_dfzDo

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Data.Semigroup.$fGenericOption2 :: forall a x. Option a -> Option a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_XfyMp)
                 (@ x_afysd)
                 (x1_afxr0 [Occ=Once] :: Option a_XfyMp) ->
                 x1_afxr0}]
Data.Semigroup.$fGenericOption2
  = \ (@ a_XfyMp) (@ x_afysd) (x1_afxr0 :: Option a_XfyMp) ->
      x1_afxr0

-- RHS size: {terms: 4, types: 6, coercions: 206, joins: 0/0}
Data.Semigroup.$fGenericOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Generic (Option a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_afwM5) ->
       GHC.Generics.C:Generic TYPE: Option a_afwM5
                              (Data.Semigroup.$fGenericOption2 @ a_afwM5)
                              `cast` (forall (x :: <*>_N).
                                      <Option a_afwM5>_R
                                      ->_R Data.Semigroup.N:Option[0] <a_afwM5>_N ; (Sym (GHC.Generics.N:K1[0]
                                                                                              <*>_N
                                                                                              <R>_P
                                                                                              <Maybe
                                                                                                 a_afwM5>_R
                                                                                              <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                 <*>_N
                                                                                                                 <S>_P
                                                                                                                 <'MetaSel
                                                                                                                    ('Just
                                                                                                                       "getOption")
                                                                                                                    'NoSourceUnpackedness
                                                                                                                    'NoSourceStrictness
                                                                                                                    'DecidedLazy>_P
                                                                                                                 <K1
                                                                                                                    R
                                                                                                                    (Maybe
                                                                                                                       a_afwM5)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                <*>_N
                                                                                                                                                <C>_P
                                                                                                                                                <'MetaCons
                                                                                                                                                   "Option"
                                                                                                                                                   'PrefixI
                                                                                                                                                   'True>_P
                                                                                                                                                <M1
                                                                                                                                                   S
                                                                                                                                                   ('MetaSel
                                                                                                                                                      ('Just
                                                                                                                                                         "getOption")
                                                                                                                                                      'NoSourceUnpackedness
                                                                                                                                                      'NoSourceStrictness
                                                                                                                                                      'DecidedLazy)
                                                                                                                                                   (K1
                                                                                                                                                      R
                                                                                                                                                      (Maybe
                                                                                                                                                         a_afwM5))>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                                                   <*>_N
                                                                                                                                                                                   <D>_P
                                                                                                                                                                                   <'MetaData
                                                                                                                                                                                      "Option"
                                                                                                                                                                                      "Data.Semigroup"
                                                                                                                                                                                      "base"
                                                                                                                                                                                      'True>_P
                                                                                                                                                                                   <M1
                                                                                                                                                                                      C
                                                                                                                                                                                      ('MetaCons
                                                                                                                                                                                         "Option"
                                                                                                                                                                                         'PrefixI
                                                                                                                                                                                         'True)
                                                                                                                                                                                      (M1
                                                                                                                                                                                         S
                                                                                                                                                                                         ('MetaSel
                                                                                                                                                                                            ('Just
                                                                                                                                                                                               "getOption")
                                                                                                                                                                                            'NoSourceUnpackedness
                                                                                                                                                                                            'NoSourceStrictness
                                                                                                                                                                                            'DecidedLazy)
                                                                                                                                                                                         (K1
                                                                                                                                                                                            R
                                                                                                                                                                                            (Maybe
                                                                                                                                                                                               a_afwM5)))>_R) ; Sub (Sym (Data.Semigroup.Rep_Option[0]
                                                                                                                                                                                                                              <a_afwM5>_N))))) <x>_N)
                                      :: (forall x. Option a_afwM5 -> Option a_afwM5 :: *)
                                         ~R# (forall x.
                                              Option a_afwM5 -> Rep (Option a_afwM5) x :: *))
                              (Data.Semigroup.$fGenericOption1 @ a_afwM5)
                              `cast` (forall (x :: <*>_N).
                                      <Rep (Option a_afwM5) x>_R
                                      ->_R (Sub (Data.Semigroup.Rep_Option[0]
                                                     <a_afwM5>_N) ; (GHC.Generics.N:M1[0]
                                                                         <*>_N
                                                                         <D>_P
                                                                         <'MetaData
                                                                            "Option"
                                                                            "Data.Semigroup"
                                                                            "base"
                                                                            'True>_P
                                                                         <M1
                                                                            C
                                                                            ('MetaCons
                                                                               "Option"
                                                                               'PrefixI
                                                                               'True)
                                                                            (M1
                                                                               S
                                                                               ('MetaSel
                                                                                  ('Just
                                                                                     "getOption")
                                                                                  'NoSourceUnpackedness
                                                                                  'NoSourceStrictness
                                                                                  'DecidedLazy)
                                                                               (K1
                                                                                  R
                                                                                  (Maybe
                                                                                     a_afwM5)))>_R ; (GHC.Generics.N:M1[0]
                                                                                                          <*>_N
                                                                                                          <C>_P
                                                                                                          <'MetaCons
                                                                                                             "Option"
                                                                                                             'PrefixI
                                                                                                             'True>_P
                                                                                                          <M1
                                                                                                             S
                                                                                                             ('MetaSel
                                                                                                                ('Just
                                                                                                                   "getOption")
                                                                                                                'NoSourceUnpackedness
                                                                                                                'NoSourceStrictness
                                                                                                                'DecidedLazy)
                                                                                                             (K1
                                                                                                                R
                                                                                                                (Maybe
                                                                                                                   a_afwM5))>_R ; GHC.Generics.N:M1[0]
                                                                                                                                      <*>_N
                                                                                                                                      <S>_P
                                                                                                                                      <'MetaSel
                                                                                                                                         ('Just
                                                                                                                                            "getOption")
                                                                                                                                         'NoSourceUnpackedness
                                                                                                                                         'NoSourceStrictness
                                                                                                                                         'DecidedLazy>_P
                                                                                                                                      <K1
                                                                                                                                         R
                                                                                                                                         (Maybe
                                                                                                                                            a_afwM5)>_R))) <x>_N ; (GHC.Generics.N:K1[0]
                                                                                                                                                                        <*>_N
                                                                                                                                                                        <R>_P
                                                                                                                                                                        <Maybe
                                                                                                                                                                           a_afwM5>_R
                                                                                                                                                                        <x>_P ; Sym (Data.Semigroup.N:Option[0]) <a_afwM5>_N)
                                      :: (forall x.
                                          Rep (Option a_afwM5) x -> Rep (Option a_afwM5) x :: *)
                                         ~R# (forall x.
                                              Rep (Option a_afwM5) x -> Option a_afwM5 :: *))]
Data.Semigroup.$fGenericOption
  = \ (@ a_XfyMu) ->
      GHC.Generics.C:Generic
        @ (Option a_XfyMu)
        ((Data.Semigroup.$fGenericOption2 @ a_XfyMu)
         `cast` (forall (x :: <*>_N).
                 <Option a_XfyMu>_R
                 ->_R Data.Semigroup.N:Option[0] <a_XfyMu>_N ; (Sym (GHC.Generics.N:K1[0]
                                                                         <*>_N
                                                                         <R>_P
                                                                         <Maybe a_XfyMu>_R
                                                                         <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                            <*>_N
                                                                                            <S>_P
                                                                                            <'MetaSel
                                                                                               ('Just
                                                                                                  "getOption")
                                                                                               'NoSourceUnpackedness
                                                                                               'NoSourceStrictness
                                                                                               'DecidedLazy>_P
                                                                                            <K1
                                                                                               R
                                                                                               (Maybe
                                                                                                  a_XfyMu)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                           <*>_N
                                                                                                                           <C>_P
                                                                                                                           <'MetaCons
                                                                                                                              "Option"
                                                                                                                              'PrefixI
                                                                                                                              'True>_P
                                                                                                                           <M1
                                                                                                                              S
                                                                                                                              ('MetaSel
                                                                                                                                 ('Just
                                                                                                                                    "getOption")
                                                                                                                                 'NoSourceUnpackedness
                                                                                                                                 'NoSourceStrictness
                                                                                                                                 'DecidedLazy)
                                                                                                                              (K1
                                                                                                                                 R
                                                                                                                                 (Maybe
                                                                                                                                    a_XfyMu))>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                              <*>_N
                                                                                                                                                              <D>_P
                                                                                                                                                              <'MetaData
                                                                                                                                                                 "Option"
                                                                                                                                                                 "Data.Semigroup"
                                                                                                                                                                 "base"
                                                                                                                                                                 'True>_P
                                                                                                                                                              <M1
                                                                                                                                                                 C
                                                                                                                                                                 ('MetaCons
                                                                                                                                                                    "Option"
                                                                                                                                                                    'PrefixI
                                                                                                                                                                    'True)
                                                                                                                                                                 (M1
                                                                                                                                                                    S
                                                                                                                                                                    ('MetaSel
                                                                                                                                                                       ('Just
                                                                                                                                                                          "getOption")
                                                                                                                                                                       'NoSourceUnpackedness
                                                                                                                                                                       'NoSourceStrictness
                                                                                                                                                                       'DecidedLazy)
                                                                                                                                                                    (K1
                                                                                                                                                                       R
                                                                                                                                                                       (Maybe
                                                                                                                                                                          a_XfyMu)))>_R) ; Sub (Sym (Data.Semigroup.Rep_Option[0]
                                                                                                                                                                                                         <a_XfyMu>_N))))) <x>_N)
                 :: (forall x. Option a_XfyMu -> Option a_XfyMu :: *)
                    ~R# (forall x. Option a_XfyMu -> Rep (Option a_XfyMu) x :: *)))
        ((Data.Semigroup.$fGenericOption1 @ a_XfyMu)
         `cast` (forall (x :: <*>_N).
                 <Rep (Option a_XfyMu) x>_R
                 ->_R (Sub (Data.Semigroup.Rep_Option[0]
                                <a_XfyMu>_N) ; (GHC.Generics.N:M1[0]
                                                    <*>_N
                                                    <D>_P
                                                    <'MetaData
                                                       "Option" "Data.Semigroup" "base" 'True>_P
                                                    <M1
                                                       C
                                                       ('MetaCons "Option" 'PrefixI 'True)
                                                       (M1
                                                          S
                                                          ('MetaSel
                                                             ('Just "getOption")
                                                             'NoSourceUnpackedness
                                                             'NoSourceStrictness
                                                             'DecidedLazy)
                                                          (K1
                                                             R
                                                             (Maybe
                                                                a_XfyMu)))>_R ; (GHC.Generics.N:M1[0]
                                                                                     <*>_N
                                                                                     <C>_P
                                                                                     <'MetaCons
                                                                                        "Option"
                                                                                        'PrefixI
                                                                                        'True>_P
                                                                                     <M1
                                                                                        S
                                                                                        ('MetaSel
                                                                                           ('Just
                                                                                              "getOption")
                                                                                           'NoSourceUnpackedness
                                                                                           'NoSourceStrictness
                                                                                           'DecidedLazy)
                                                                                        (K1
                                                                                           R
                                                                                           (Maybe
                                                                                              a_XfyMu))>_R ; GHC.Generics.N:M1[0]
                                                                                                                 <*>_N
                                                                                                                 <S>_P
                                                                                                                 <'MetaSel
                                                                                                                    ('Just
                                                                                                                       "getOption")
                                                                                                                    'NoSourceUnpackedness
                                                                                                                    'NoSourceStrictness
                                                                                                                    'DecidedLazy>_P
                                                                                                                 <K1
                                                                                                                    R
                                                                                                                    (Maybe
                                                                                                                       a_XfyMu)>_R))) <x>_N ; (GHC.Generics.N:K1[0]
                                                                                                                                                   <*>_N
                                                                                                                                                   <R>_P
                                                                                                                                                   <Maybe
                                                                                                                                                      a_XfyMu>_R
                                                                                                                                                   <x>_P ; Sym (Data.Semigroup.N:Option[0]) <a_XfyMu>_N)
                 :: (forall x.
                     Rep (Option a_XfyMu) x -> Rep (Option a_XfyMu) x :: *)
                    ~R# (forall x. Rep (Option a_XfyMu) x -> Option a_XfyMu :: *)))

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataOption2 :: forall a. Maybe a -> Maybe a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyoV) (v_Xkv [Occ=Once] :: Maybe a_afyoV) -> v_Xkv}]
Data.Semigroup.$fDataOption2
  = \ (@ a_afyoV) (v_Xkv :: Maybe a_afyoV) -> v_Xkv

-- RHS size: {terms: 13, types: 38, coercions: 6, joins: 0/1}
Data.Semigroup.$fDataOption_$cgunfold
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c (Option a)
[GblId,
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 110 60}]
Data.Semigroup.$fDataOption_$cgunfold
  = \ (@ a_afyoV)
      ($dData_afyoW :: Data a_afyoV)
      (@ (c_afypf :: * -> *)) ->
      let {
        $dData1_sfAi6 :: Data (Maybe a_afyoV)
        [LclId]
        $dData1_sfAi6 = Data.Data.$fDataMaybe @ a_afyoV $dData_afyoW } in
      \ (k_afxqX :: forall b r. Data b => c_afypf (b -> r) -> c_afypf r)
        (z_afxqY :: forall r. r -> c_afypf r)
        _ [Occ=Dead] ->
        k_afxqX
          @ (Maybe a_afyoV)
          @ (Option a_afyoV)
          $dData1_sfAi6
          (z_afxqY
             @ (Maybe a_afyoV -> Option a_afyoV)
             ((Data.Semigroup.$fDataOption2 @ a_afyoV)
              `cast` (<Maybe a_afyoV>_R
                      ->_R Sym (Data.Semigroup.N:Option[0]) <a_afyoV>_N
                      :: (Maybe a_afyoV -> Maybe a_afyoV :: *)
                         ~R# (Maybe a_afyoV -> Option a_afyoV :: *))))

-- RHS size: {terms: 14, types: 40, coercions: 8, joins: 0/1}
Data.Semigroup.$fDataOption_$cgfoldl
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Option a -> c (Option a)
[GblId,
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 120 60}]
Data.Semigroup.$fDataOption_$cgfoldl
  = \ (@ a_afyoV)
      ($dData_afyoW :: Data a_afyoV)
      (@ (c_afyp4 :: * -> *)) ->
      let {
        $dData1_sfAi4 :: Data (Maybe a_afyoV)
        [LclId]
        $dData1_sfAi4 = Data.Data.$fDataMaybe @ a_afyoV $dData_afyoW } in
      \ (k_afxqU
           :: forall d b. Data d => c_afyp4 (d -> b) -> d -> c_afyp4 b)
        (z_afxqV :: forall g. g -> c_afyp4 g)
        (ds_dfzD4 :: Option a_afyoV) ->
        k_afxqU
          @ (Maybe a_afyoV)
          @ (Option a_afyoV)
          $dData1_sfAi4
          (z_afxqV
             @ (Maybe a_afyoV -> Option a_afyoV)
             ((Data.Semigroup.$fDataOption2 @ a_afyoV)
              `cast` (<Maybe a_afyoV>_R
                      ->_R Sym (Data.Semigroup.N:Option[0]) <a_afyoV>_N
                      :: (Maybe a_afyoV -> Maybe a_afyoV :: *)
                         ~R# (Maybe a_afyoV -> Option a_afyoV :: *))))
          (ds_dfzD4
           `cast` (Data.Semigroup.N:Option[0] <a_afyoV>_N
                   :: (Option a_afyoV :: *) ~R# (Maybe a_afyoV :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataOption6 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Semigroup.$fDataOption6 = "Option"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataOption9 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fDataOption9
  = GHC.CString.unpackCString# Data.Semigroup.$fDataOption6

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadOption_lexeme :: Text.Read.Lex.Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fReadOption_lexeme
  = Text.Read.Lex.Ident Data.Semigroup.$fDataOption9

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadFirst8 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fReadFirst8 = "{"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadFirst7 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fReadFirst7
  = GHC.CString.unpackCString# Data.Semigroup.$fReadFirst8

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadFirst_lexeme :: Text.Read.Lex.Lexeme
[GblId,
 Str=m3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fReadFirst_lexeme
  = Text.Read.Lex.Punc Data.Semigroup.$fReadFirst7

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadOption3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Semigroup.$fReadOption3 = "getOption"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadOption2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fReadOption2
  = GHC.CString.unpackCString# Data.Semigroup.$fReadOption3

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadArg2 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fReadArg2 = GHC.Types.I# 11#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadFirst4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fReadFirst4 = "}"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadFirst3 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fReadFirst3
  = GHC.CString.unpackCString# Data.Semigroup.$fReadFirst4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadFirst2 :: Text.Read.Lex.Lexeme
[GblId,
 Str=m3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fReadFirst2
  = Text.Read.Lex.Punc Data.Semigroup.$fReadFirst3

-- RHS size: {terms: 57, types: 81, coercions: 31, joins: 0/1}
Data.Semigroup.$fReadOption1
  :: forall a.
     Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Option a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 421 0}]
Data.Semigroup.$fReadOption1
  = \ (@ a_afyo6)
      ($dRead_afyo7 :: Read a_afyo6)
      (eta_B2 :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b_i815e)
      (eta1_B1
         :: Option a_afyo6 -> Text.ParserCombinators.ReadP.P b_i815e) ->
      GHC.Read.list3
        @ (Option a_afyo6)
        (let {
           ds_sfAhX [Dmd=<L,C(C1(U))>]
             :: Text.ParserCombinators.ReadPrec.Prec
                -> forall b1.
                   (Maybe a_afyo6 -> Text.ParserCombinators.ReadP.P b1)
                   -> Text.ParserCombinators.ReadP.P b1
           [LclId,
            Arity=2,
            Str=<L,A><L,U>,
            Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                    WorkFree=True, Expandable=True,
                    Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
                    Tmpl= \ _ [Occ=Dead]
                            (@ b1_i88UP)
                            (eta2_Xiw [Occ=Once]
                               :: Maybe a_afyo6 -> Text.ParserCombinators.ReadP.P b1_i88UP) ->
                            GHC.Read.$fReadMaybe1
                              @ a_afyo6
                              $dRead_afyo7
                              Text.ParserCombinators.ReadPrec.minPrec
                              @ b1_i88UP
                              eta2_Xiw}]
           ds_sfAhX
             = \ _ [Occ=Dead]
                 (@ b1_i88UP)
                 (eta2_Xiw [OS=OneShot]
                    :: Maybe a_afyo6 -> Text.ParserCombinators.ReadP.P b1_i88UP) ->
                 GHC.Read.$fReadMaybe1
                   @ a_afyo6
                   $dRead_afyo7
                   Text.ParserCombinators.ReadPrec.minPrec
                   @ b1_i88UP
                   eta2_Xiw } in
         (\ (c_i88VW :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b1_i815E)
            (eta2_XiA
               :: Option a_afyo6 -> Text.ParserCombinators.ReadP.P b1_i815E) ->
            case c_i88VW of { GHC.Types.I# x_i88VZ ->
            case GHC.Prim.<=# x_i88VZ 11# of {
              __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1_i815E;
              1# ->
                case Text.Read.Lex.$wexpect
                       Data.Semigroup.$fReadOption_lexeme
                       @ b1_i815E
                       (\ _ [Occ=Dead, OS=OneShot] ->
                          case Text.Read.Lex.$wexpect
                                 Data.Semigroup.$fReadFirst_lexeme
                                 @ b1_i815E
                                 (\ _ [Occ=Dead, OS=OneShot] ->
                                    ((((GHC.Read.readField
                                          @ (Maybe a_afyo6)
                                          Data.Semigroup.$fReadOption2
                                          (ds_sfAhX
                                           `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                                  <Maybe
                                                                     a_afyo6>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                                             <Maybe
                                                                                                a_afyo6>_R)
                                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                                       -> forall b.
                                                          (Maybe a_afyo6
                                                           -> Text.ParserCombinators.ReadP.P b)
                                                          -> Text.ParserCombinators.ReadP.P b :: *)
                                                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                                             (Maybe a_afyo6) :: *))))
                                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                   <Maybe a_afyo6>_R
                                               :: (Text.ParserCombinators.ReadPrec.ReadPrec
                                                     (Maybe a_afyo6) :: *)
                                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                       -> Text.ParserCombinators.ReadP.ReadP
                                                            (Maybe a_afyo6) :: *)))
                                        Data.Semigroup.$fReadArg2)
                                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                 <Maybe a_afyo6>_R
                                             :: (Text.ParserCombinators.ReadP.ReadP
                                                   (Maybe a_afyo6) :: *)
                                                ~R# (forall b.
                                                     (Maybe a_afyo6
                                                      -> Text.ParserCombinators.ReadP.P b)
                                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                                      @ b1_i815E
                                      (\ (a3_i88WJ :: Maybe a_afyo6) ->
                                         case Text.Read.Lex.$wexpect
                                                Data.Semigroup.$fReadFirst2
                                                @ b1_i815E
                                                (\ _ [Occ=Dead, OS=OneShot] ->
                                                   eta2_XiA
                                                     (a3_i88WJ
                                                      `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afyo6>_N
                                                              :: (Maybe a_afyo6 :: *)
                                                                 ~R# (Option a_afyo6 :: *))))
                                         of
                                         { (# ww1_i88Ww #) ->
                                         Text.ParserCombinators.ReadP.Look @ b1_i815E ww1_i88Ww
                                         }))
                          of
                          { (# ww1_i88Ww #) ->
                          Text.ParserCombinators.ReadP.Look @ b1_i815E ww1_i88Ww
                          })
                of
                { (# ww1_i88Ww #) ->
                Text.ParserCombinators.ReadP.Look @ b1_i815E ww1_i88Ww
                }
            }
            })
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Option
                                   a_afyo6>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Option a_afyo6>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Option a_afyo6 -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (Option a_afyo6) :: *)))
        eta_B2
        @ b_i815e
        eta1_B1

-- RHS size: {terms: 8, types: 12, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadOption_$creadsPrec
  :: forall a. Read a => Int -> ReadS (Option a)
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XfyIB)
                 ($dRead_XfyID [Occ=Once] :: Read a_XfyIB)
                 (n_i8156 [Occ=Once] :: Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ (Option a_XfyIB)
                   (Data.Semigroup.$fReadOption1
                      @ a_XfyIB
                      $dRead_XfyID
                      n_i8156
                      @ (Option a_XfyIB)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ (Option a_XfyIB)))}]
Data.Semigroup.$fReadOption_$creadsPrec
  = \ (@ a_XfyIB) ($dRead_XfyID :: Read a_XfyIB) (n_i8156 :: Int) ->
      Text.ParserCombinators.ReadP.run
        @ (Option a_XfyIB)
        (Data.Semigroup.$fReadOption1
           @ a_XfyIB
           $dRead_XfyID
           n_i8156
           @ (Option a_XfyIB)
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ (Option a_XfyIB)))

-- RHS size: {terms: 5, types: 7, coercions: 11, joins: 0/0}
Data.Semigroup.$fReadOption_$creadListPrec
  :: forall a.
     Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Option a]
[GblId,
 Arity=1,
 Str=<L,U(A,A,C(C1(U)),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XfyIz) ($dRead_XfyIB [Occ=Once] :: Read a_XfyIz) ->
                 GHC.Read.list
                   @ (Option a_XfyIz)
                   ((Data.Semigroup.$fReadOption1 @ a_XfyIz $dRead_XfyIB)
                    `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Option
                                              a_XfyIz>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <Option a_XfyIz>_R)
                            :: (Text.ParserCombinators.ReadPrec.Prec
                                -> forall b.
                                   (Option a_XfyIz -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)
                               ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                      (Option a_XfyIz) :: *)))}]
Data.Semigroup.$fReadOption_$creadListPrec
  = \ (@ a_XfyIz) ($dRead_XfyIB :: Read a_XfyIz) ->
      GHC.Read.list
        @ (Option a_XfyIz)
        ((Data.Semigroup.$fReadOption1 @ a_XfyIz $dRead_XfyIB)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Option
                                   a_XfyIz>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Option a_XfyIz>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Option a_XfyIz -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (Option a_XfyIz) :: *)))

-- RHS size: {terms: 8, types: 16, coercions: 19, joins: 0/0}
Data.Semigroup.$fReadOption_$creadList
  :: forall a. Read a => ReadS [Option a]
[GblId,
 Arity=1,
 Str=<L,U(A,A,C(C1(U)),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XfyIA) ($dRead_XfyIC [Occ=Once] :: Read a_XfyIA) ->
                 Text.ParserCombinators.ReadP.run
                   @ [Option a_XfyIA]
                   (((((GHC.Read.list
                          @ (Option a_XfyIA)
                          ((Data.Semigroup.$fReadOption1 @ a_XfyIA $dRead_XfyIC)
                           `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                  <Option
                                                     a_XfyIA>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                             <Option a_XfyIA>_R)
                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                       -> forall b.
                                          (Option a_XfyIA -> Text.ParserCombinators.ReadP.P b)
                                          -> Text.ParserCombinators.ReadP.P b :: *)
                                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                             (Option a_XfyIA) :: *))))
                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                   <[Option a_XfyIA]>_R
                               :: (Text.ParserCombinators.ReadPrec.ReadPrec [Option a_XfyIA] :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                       -> Text.ParserCombinators.ReadP.ReadP
                                            [Option a_XfyIA] :: *)))
                        GHC.Read.$fRead()7)
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                                 <[Option a_XfyIA]>_R
                             :: (Text.ParserCombinators.ReadP.ReadP [Option a_XfyIA] :: *)
                                ~R# (forall b.
                                     ([Option a_XfyIA] -> Text.ParserCombinators.ReadP.P b)
                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                      @ [Option a_XfyIA]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [Option a_XfyIA]))}]
Data.Semigroup.$fReadOption_$creadList
  = \ (@ a_XfyIA) ($dRead_XfyIC :: Read a_XfyIA) ->
      Text.ParserCombinators.ReadP.run
        @ [Option a_XfyIA]
        (((((GHC.Read.list
               @ (Option a_XfyIA)
               ((Data.Semigroup.$fReadOption1 @ a_XfyIA $dRead_XfyIC)
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Option
                                          a_XfyIA>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <Option a_XfyIA>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               (Option a_XfyIA -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                  (Option a_XfyIA) :: *))))
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[Option a_XfyIA]>_R
                    :: (Text.ParserCombinators.ReadPrec.ReadPrec [Option a_XfyIA] :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.Prec
                            -> Text.ParserCombinators.ReadP.ReadP [Option a_XfyIA] :: *)))
             GHC.Read.$fRead()7)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                      <[Option a_XfyIA]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP [Option a_XfyIA] :: *)
                     ~R# (forall b.
                          ([Option a_XfyIA] -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [Option a_XfyIA]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ [Option a_XfyIA]))

-- RHS size: {terms: 11, types: 10, coercions: 11, joins: 0/0}
Data.Semigroup.$fReadOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Read a => Read (Option a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,A,C(C1(U)),A)>m,
 Unf=DFun: \ (@ a_afwM5) (v_Xku :: Read a_afwM5) ->
       GHC.Read.C:Read TYPE: Option a_afwM5
                       Data.Semigroup.$fReadOption_$creadsPrec @ a_afwM5 v_Xku
                       Data.Semigroup.$fReadOption_$creadList @ a_afwM5 v_Xku
                       (Data.Semigroup.$fReadOption1 @ a_afwM5 v_Xku)
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Option
                                                 a_afwM5>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                         <Option a_afwM5>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Option a_afwM5 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                         (Option a_afwM5) :: *))
                       Data.Semigroup.$fReadOption_$creadListPrec @ a_afwM5 v_Xku]
Data.Semigroup.$fReadOption
  = \ (@ a_XfyIy) ($dRead_XfyIA :: Read a_XfyIy) ->
      GHC.Read.C:Read
        @ (Option a_XfyIy)
        (Data.Semigroup.$fReadOption_$creadsPrec @ a_XfyIy $dRead_XfyIA)
        (Data.Semigroup.$fReadOption_$creadList @ a_XfyIy $dRead_XfyIA)
        ((Data.Semigroup.$fReadOption1 @ a_XfyIy $dRead_XfyIA)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Option
                                   a_XfyIy>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Option a_XfyIy>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Option a_XfyIy -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (Option a_XfyIy) :: *)))
        (Data.Semigroup.$fReadOption_$creadListPrec @ a_XfyIy $dRead_XfyIA)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowOption2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Semigroup.$fShowOption2 = "Option {"#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowOption1 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Semigroup.$fShowOption1 = "getOption = "#

-- RHS size: {terms: 37, types: 15, coercions: 2, joins: 0/1}
Data.Semigroup.$w$cshowsPrec5 [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => GHC.Prim.Int# -> Option a -> ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 331 120}]
Data.Semigroup.$w$cshowsPrec5
  = \ (@ a_sfBqw)
      (w_sfBqx :: Show a_sfBqw)
      (ww_sfBqC :: GHC.Prim.Int#)
      (w1_sfBqz :: Option a_sfBqw) ->
      let {
        f_sfAhM [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        f_sfAhM
          = GHC.Show.$fShowMaybe_$cshowsPrec
              @ a_sfBqw
              w_sfBqx
              Data.Semigroup.$fFoldableOption7
              (w1_sfBqz
               `cast` (Data.Semigroup.N:Option[0] <a_sfBqw>_N
                       :: (Option a_sfBqw :: *) ~R# (Maybe a_sfBqw :: *))) } in
      case GHC.Prim.>=# ww_sfBqC 11# of {
        __DEFAULT ->
          \ (x_X7RS9 :: String) ->
            GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowOption2
              (GHC.CString.unpackAppendCString#
                 Data.Semigroup.$fShowOption1
                 (f_sfAhM
                    (GHC.CString.unpackAppendCString#
                       Data.Semigroup.$fReadFirst4 x_X7RS9)));
        1# ->
          \ (x_i88RR :: String) ->
            GHC.Types.:
              @ Char
              GHC.Show.$fShow(,)4
              (GHC.CString.unpackAppendCString#
                 Data.Semigroup.$fShowOption2
                 (GHC.CString.unpackAppendCString#
                    Data.Semigroup.$fShowOption1
                    (f_sfAhM
                       (GHC.CString.unpackAppendCString#
                          Data.Semigroup.$fReadFirst4
                          (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x_i88RR)))))
      }

-- RHS size: {terms: 11, types: 10, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowOption_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => Int -> Option a -> ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sfBqw)
                 (w_sfBqx [Occ=Once] :: Show a_sfBqw)
                 (w1_sfBqy [Occ=Once!] :: Int)
                 (w2_sfBqz [Occ=Once] :: Option a_sfBqw) ->
                 case w1_sfBqy of { GHC.Types.I# ww1_sfBqC [Occ=Once] ->
                 Data.Semigroup.$w$cshowsPrec5 @ a_sfBqw w_sfBqx ww1_sfBqC w2_sfBqz
                 }}]
Data.Semigroup.$fShowOption_$cshowsPrec
  = \ (@ a_sfBqw)
      (w_sfBqx :: Show a_sfBqw)
      (w1_sfBqy :: Int)
      (w2_sfBqz :: Option a_sfBqw) ->
      case w1_sfBqy of { GHC.Types.I# ww1_sfBqC ->
      Data.Semigroup.$w$cshowsPrec5 @ a_sfBqw w_sfBqx ww1_sfBqC w2_sfBqz
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowOption3 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
Data.Semigroup.$fShowOption3
  = ++ @ Char GHC.Show.$fShowMaybe4 Data.Semigroup.$fReadFirst3

-- RHS size: {terms: 19, types: 11, coercions: 2, joins: 0/0}
Data.Semigroup.$fShowOption_$cshow
  :: forall a. Show a => Option a -> String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30] 160 0}]
Data.Semigroup.$fShowOption_$cshow
  = \ (@ a_afynB)
      ($dShow_afynC :: Show a_afynB)
      (x_i7Jay :: Option a_afynB) ->
      GHC.CString.unpackAppendCString#
        Data.Semigroup.$fShowOption2
        (GHC.CString.unpackAppendCString#
           Data.Semigroup.$fShowOption1
           (case x_i7Jay
                 `cast` (Data.Semigroup.N:Option[0] <a_afynB>_N
                         :: (Option a_afynB :: *) ~R# (Maybe a_afynB :: *))
            of {
              Nothing -> Data.Semigroup.$fShowOption3;
              Just b1_i88XW ->
                ++
                  @ Char
                  GHC.Show.$fShowMaybe1
                  (showsPrec
                     @ a_afynB
                     $dShow_afynC
                     GHC.Show.appPrec1
                     b1_i88XW
                     Data.Semigroup.$fReadFirst3)
            }))

-- RHS size: {terms: 12, types: 13, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowOption_$cshowList
  :: forall a. Show a => [Option a] -> ShowS
[GblId,
 Arity=3,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afynB)
                 ($dShow_afynC [Occ=Once] :: Show a_afynB)
                 (ls_i7JaB [Occ=Once] :: [Option a_afynB])
                 (s_i7JaC [Occ=Once] :: String) ->
                 GHC.Show.showList__
                   @ (Option a_afynB)
                   (Data.Semigroup.$fShowOption_$cshowsPrec
                      @ a_afynB $dShow_afynC Data.Semigroup.$fFoldableOption7)
                   ls_i7JaB
                   s_i7JaC}]
Data.Semigroup.$fShowOption_$cshowList
  = \ (@ a_afynB)
      ($dShow_afynC :: Show a_afynB)
      (ls_i7JaB :: [Option a_afynB])
      (s_i7JaC :: String) ->
      GHC.Show.showList__
        @ (Option a_afynB)
        (\ (w_sfBqz :: Option a_afynB) ->
           Data.Semigroup.$w$cshowsPrec5 @ a_afynB $dShow_afynC 0# w_sfBqz)
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 9, types: 9, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Show a => Show (Option a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(C1(C(U))),A,A)>m,
 Unf=DFun: \ (@ a_afwM5) (v_Xkz :: Show a_afwM5) ->
       GHC.Show.C:Show TYPE: Option a_afwM5
                       Data.Semigroup.$fShowOption_$cshowsPrec @ a_afwM5 v_Xkz
                       Data.Semigroup.$fShowOption_$cshow @ a_afwM5 v_Xkz
                       Data.Semigroup.$fShowOption_$cshowList @ a_afwM5 v_Xkz]
Data.Semigroup.$fShowOption
  = \ (@ a_afynB) ($dShow_afynC :: Show a_afynB) ->
      GHC.Show.C:Show
        @ (Option a_afynB)
        (Data.Semigroup.$fShowOption_$cshowsPrec @ a_afynB $dShow_afynC)
        (Data.Semigroup.$fShowOption_$cshow @ a_afynB $dShow_afynC)
        (Data.Semigroup.$fShowOption_$cshowList @ a_afynB $dShow_afynC)

-- RHS size: {terms: 7, types: 8, coercions: 18, joins: 0/0}
Data.Semigroup.$fEqOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Eq a => Eq (Option a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)>m,
 Unf=DFun: \ (@ a_afwM5) (v_XkO :: Eq a_afwM5) ->
       GHC.Classes.C:Eq TYPE: Option a_afwM5
                        (GHC.Base.$fEqMaybe_$c== @ a_afwM5 v_XkO)
                        `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afwM5>_N
                                ->_R Sym (Data.Semigroup.N:Option[0]) <a_afwM5>_N
                                ->_R <Bool>_R
                                :: (Maybe a_afwM5 -> Maybe a_afwM5 -> Bool :: *)
                                   ~R# (Option a_afwM5 -> Option a_afwM5 -> Bool :: *))
                        (GHC.Base.$fEqMaybe_$c/= @ a_afwM5 v_XkO)
                        `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afwM5>_N
                                ->_R Sym (Data.Semigroup.N:Option[0]) <a_afwM5>_N
                                ->_R <Bool>_R
                                :: (Maybe a_afwM5 -> Maybe a_afwM5 -> Bool :: *)
                                   ~R# (Option a_afwM5 -> Option a_afwM5 -> Bool :: *))]
Data.Semigroup.$fEqOption
  = \ (@ a_afyle) ($dEq_afylf :: Eq a_afyle) ->
      GHC.Classes.C:Eq
        @ (Option a_afyle)
        ((GHC.Base.$fEqMaybe_$c== @ a_afyle $dEq_afylf)
         `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afyle>_N
                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_afyle>_N
                 ->_R <Bool>_R
                 :: (Maybe a_afyle -> Maybe a_afyle -> Bool :: *)
                    ~R# (Option a_afyle -> Option a_afyle -> Bool :: *)))
        ((GHC.Base.$fEqMaybe_$c/= @ a_afyle $dEq_afylf)
         `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afyle>_N
                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_afyle>_N
                 ->_R <Bool>_R
                 :: (Maybe a_afyle -> Maybe a_afyle -> Bool :: *)
                    ~R# (Option a_afyle -> Option a_afyle -> Bool :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Semigroup.$fOrdOption_$cp1Ord
  :: forall a. Ord a => Eq (Option a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XfyGz) ($dOrd_XfyGB [Occ=Once] :: Ord a_XfyGz) ->
                 Data.Semigroup.$fEqOption
                   @ a_XfyGz (GHC.Classes.$p1Ord @ a_XfyGz $dOrd_XfyGB)}]
Data.Semigroup.$fOrdOption_$cp1Ord
  = \ (@ a_XfyGz) ($dOrd_XfyGB :: Ord a_XfyGz) ->
      Data.Semigroup.$fEqOption
        @ a_XfyGz (GHC.Classes.$p1Ord @ a_XfyGz $dOrd_XfyGB)

-- RHS size: {terms: 23, types: 18, coercions: 67, joins: 0/0}
Data.Semigroup.$fOrdOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Ord a => Ord (Option a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m,
 Unf=DFun: \ (@ a_afwM5) (v_XkQ :: Ord a_afwM5) ->
       GHC.Classes.C:Ord TYPE: Option a_afwM5
                         Data.Semigroup.$fOrdOption_$cp1Ord @ a_afwM5 v_XkQ
                         (GHC.Base.$fOrdMaybe_$ccompare @ a_afwM5 v_XkQ)
                         `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afwM5>_N
                                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_afwM5>_N
                                 ->_R <Ordering>_R
                                 :: (Maybe a_afwM5 -> Maybe a_afwM5 -> Ordering :: *)
                                    ~R# (Option a_afwM5 -> Option a_afwM5 -> Ordering :: *))
                         (GHC.Base.$fOrdMaybe_$c< @ a_afwM5 v_XkQ)
                         `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afwM5>_N
                                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_afwM5>_N
                                 ->_R <Bool>_R
                                 :: (Maybe a_afwM5 -> Maybe a_afwM5 -> Bool :: *)
                                    ~R# (Option a_afwM5 -> Option a_afwM5 -> Bool :: *))
                         (GHC.Base.$fOrdMaybe_$c<= @ a_afwM5 v_XkQ)
                         `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afwM5>_N
                                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_afwM5>_N
                                 ->_R <Bool>_R
                                 :: (Maybe a_afwM5 -> Maybe a_afwM5 -> Bool :: *)
                                    ~R# (Option a_afwM5 -> Option a_afwM5 -> Bool :: *))
                         (\ (a1_i88V1 [Occ=Once] :: Maybe a_afwM5)
                            (b_i88V2 [Occ=Once] :: Maybe a_afwM5) ->
                            GHC.Base.$fOrdMaybe_$c< @ a_afwM5 v_XkQ b_i88V2 a1_i88V1)
                         `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afwM5>_N
                                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_afwM5>_N
                                 ->_R <Bool>_R
                                 :: (Maybe a_afwM5 -> Maybe a_afwM5 -> Bool :: *)
                                    ~R# (Option a_afwM5 -> Option a_afwM5 -> Bool :: *))
                         (GHC.Base.$fOrdMaybe_$c>= @ a_afwM5 v_XkQ)
                         `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afwM5>_N
                                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_afwM5>_N
                                 ->_R <Bool>_R
                                 :: (Maybe a_afwM5 -> Maybe a_afwM5 -> Bool :: *)
                                    ~R# (Option a_afwM5 -> Option a_afwM5 -> Bool :: *))
                         (GHC.Base.$fOrdMaybe_$cmax @ a_afwM5 v_XkQ)
                         `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afwM5>_N
                                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_afwM5>_N
                                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_afwM5>_N
                                 :: (Maybe a_afwM5 -> Maybe a_afwM5 -> Maybe a_afwM5 :: *)
                                    ~R# (Option a_afwM5 -> Option a_afwM5 -> Option a_afwM5 :: *))
                         (GHC.Base.$fOrdMaybe_$cmin @ a_afwM5 v_XkQ)
                         `cast` (Sym (Data.Semigroup.N:Option[0]) <a_afwM5>_N
                                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_afwM5>_N
                                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_afwM5>_N
                                 :: (Maybe a_afwM5 -> Maybe a_afwM5 -> Maybe a_afwM5 :: *)
                                    ~R# (Option a_afwM5 -> Option a_afwM5 -> Option a_afwM5 :: *))]
Data.Semigroup.$fOrdOption
  = \ (@ a_XfyGA) ($dOrd_XfyGC :: Ord a_XfyGA) ->
      GHC.Classes.C:Ord
        @ (Option a_XfyGA)
        (Data.Semigroup.$fOrdOption_$cp1Ord @ a_XfyGA $dOrd_XfyGC)
        ((GHC.Base.$fOrdMaybe_$ccompare @ a_XfyGA $dOrd_XfyGC)
         `cast` (Sym (Data.Semigroup.N:Option[0]) <a_XfyGA>_N
                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_XfyGA>_N
                 ->_R <Ordering>_R
                 :: (Maybe a_XfyGA -> Maybe a_XfyGA -> Ordering :: *)
                    ~R# (Option a_XfyGA -> Option a_XfyGA -> Ordering :: *)))
        ((GHC.Base.$fOrdMaybe_$c< @ a_XfyGA $dOrd_XfyGC)
         `cast` (Sym (Data.Semigroup.N:Option[0]) <a_XfyGA>_N
                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_XfyGA>_N
                 ->_R <Bool>_R
                 :: (Maybe a_XfyGA -> Maybe a_XfyGA -> Bool :: *)
                    ~R# (Option a_XfyGA -> Option a_XfyGA -> Bool :: *)))
        ((GHC.Base.$fOrdMaybe_$c<= @ a_XfyGA $dOrd_XfyGC)
         `cast` (Sym (Data.Semigroup.N:Option[0]) <a_XfyGA>_N
                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_XfyGA>_N
                 ->_R <Bool>_R
                 :: (Maybe a_XfyGA -> Maybe a_XfyGA -> Bool :: *)
                    ~R# (Option a_XfyGA -> Option a_XfyGA -> Bool :: *)))
        ((\ (a1_i88V1 :: Maybe a_XfyGA) (b_i88V2 :: Maybe a_XfyGA) ->
            GHC.Base.$fOrdMaybe_$c< @ a_XfyGA $dOrd_XfyGC b_i88V2 a1_i88V1)
         `cast` (Sym (Data.Semigroup.N:Option[0]) <a_XfyGA>_N
                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_XfyGA>_N
                 ->_R <Bool>_R
                 :: (Maybe a_XfyGA -> Maybe a_XfyGA -> Bool :: *)
                    ~R# (Option a_XfyGA -> Option a_XfyGA -> Bool :: *)))
        ((GHC.Base.$fOrdMaybe_$c>= @ a_XfyGA $dOrd_XfyGC)
         `cast` (Sym (Data.Semigroup.N:Option[0]) <a_XfyGA>_N
                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_XfyGA>_N
                 ->_R <Bool>_R
                 :: (Maybe a_XfyGA -> Maybe a_XfyGA -> Bool :: *)
                    ~R# (Option a_XfyGA -> Option a_XfyGA -> Bool :: *)))
        ((GHC.Base.$fOrdMaybe_$cmax @ a_XfyGA $dOrd_XfyGC)
         `cast` (Sym (Data.Semigroup.N:Option[0]) <a_XfyGA>_N
                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_XfyGA>_N
                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_XfyGA>_N
                 :: (Maybe a_XfyGA -> Maybe a_XfyGA -> Maybe a_XfyGA :: *)
                    ~R# (Option a_XfyGA -> Option a_XfyGA -> Option a_XfyGA :: *)))
        ((GHC.Base.$fOrdMaybe_$cmin @ a_XfyGA $dOrd_XfyGC)
         `cast` (Sym (Data.Semigroup.N:Option[0]) <a_XfyGA>_N
                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_XfyGA>_N
                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_XfyGA>_N
                 :: (Maybe a_XfyGA -> Maybe a_XfyGA -> Maybe a_XfyGA :: *)
                    ~R# (Option a_XfyGA -> Option a_XfyGA -> Option a_XfyGA :: *)))

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fGeneric1WrappedMonoid1
  :: forall a. Rep1 WrappedMonoid a -> Rep1 WrappedMonoid a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afykP)
                 (ds_dfzCY [Occ=Once] :: Rep1 WrappedMonoid a_afykP) ->
                 ds_dfzCY}]
Data.Semigroup.$fGeneric1WrappedMonoid1
  = \ (@ a_afykP) (ds_dfzCY :: Rep1 WrappedMonoid a_afykP) ->
      ds_dfzCY

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Semigroup.$fGeneric1WrappedMonoid2
  :: forall a. WrappedMonoid a -> WrappedMonoid a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afykq)
                 (x_afxqN [Occ=Once] :: WrappedMonoid a_afykq) ->
                 x_afxqN}]
Data.Semigroup.$fGeneric1WrappedMonoid2
  = \ (@ a_afykq) (x_afxqN :: WrappedMonoid a_afykq) -> x_afxqN

-- RHS size: {terms: 3, types: 3, coercions: 163, joins: 0/0}
Data.Semigroup.$fGeneric1WrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: Generic1 WrappedMonoid
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Generics.C:Generic1 TYPE: *
                               TYPE: WrappedMonoid
                               Data.Semigroup.$fGeneric1WrappedMonoid2
                               `cast` (forall (a :: <*>_N).
                                       <WrappedMonoid a>_R
                                       ->_R Data.Semigroup.N:WrappedMonoid[0]
                                                (Sym (GHC.Generics.N:Par1[0]
                                                          <a>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                             <*>_N
                                                                             <S>_P
                                                                             <'MetaSel
                                                                                ('Just
                                                                                   "unwrapMonoid")
                                                                                'NoSourceUnpackedness
                                                                                'NoSourceStrictness
                                                                                'DecidedLazy>_P
                                                                             <Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                   <*>_N
                                                                                                   <C>_P
                                                                                                   <'MetaCons
                                                                                                      "WrapMonoid"
                                                                                                      'PrefixI
                                                                                                      'True>_P
                                                                                                   <M1
                                                                                                      S
                                                                                                      ('MetaSel
                                                                                                         ('Just
                                                                                                            "unwrapMonoid")
                                                                                                         'NoSourceUnpackedness
                                                                                                         'NoSourceStrictness
                                                                                                         'DecidedLazy)
                                                                                                      Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                           <*>_N
                                                                                                                           <D>_P
                                                                                                                           <'MetaData
                                                                                                                              "WrappedMonoid"
                                                                                                                              "Data.Semigroup"
                                                                                                                              "base"
                                                                                                                              'True>_P
                                                                                                                           <M1
                                                                                                                              C
                                                                                                                              ('MetaCons
                                                                                                                                 "WrapMonoid"
                                                                                                                                 'PrefixI
                                                                                                                                 'True)
                                                                                                                              (M1
                                                                                                                                 S
                                                                                                                                 ('MetaSel
                                                                                                                                    ('Just
                                                                                                                                       "unwrapMonoid")
                                                                                                                                    'NoSourceUnpackedness
                                                                                                                                    'NoSourceStrictness
                                                                                                                                    'DecidedLazy)
                                                                                                                                 Par1)>_R) ; Sub (Sym (Data.Semigroup.Rep1_WrappedMonoid[0]))))) <a>_N)
                                       :: (forall a. WrappedMonoid a -> WrappedMonoid a :: *)
                                          ~R# (forall a.
                                               WrappedMonoid a -> Rep1 WrappedMonoid a :: *))
                               Data.Semigroup.$fGeneric1WrappedMonoid1
                               `cast` (forall (a :: <*>_N).
                                       <Rep1 WrappedMonoid a>_R
                                       ->_R (Sub (Data.Semigroup.Rep1_WrappedMonoid[0]) ; (GHC.Generics.N:M1[0]
                                                                                               <*>_N
                                                                                               <D>_P
                                                                                               <'MetaData
                                                                                                  "WrappedMonoid"
                                                                                                  "Data.Semigroup"
                                                                                                  "base"
                                                                                                  'True>_P
                                                                                               <M1
                                                                                                  C
                                                                                                  ('MetaCons
                                                                                                     "WrapMonoid"
                                                                                                     'PrefixI
                                                                                                     'True)
                                                                                                  (M1
                                                                                                     S
                                                                                                     ('MetaSel
                                                                                                        ('Just
                                                                                                           "unwrapMonoid")
                                                                                                        'NoSourceUnpackedness
                                                                                                        'NoSourceStrictness
                                                                                                        'DecidedLazy)
                                                                                                     Par1)>_R ; (GHC.Generics.N:M1[0]
                                                                                                                     <*>_N
                                                                                                                     <C>_P
                                                                                                                     <'MetaCons
                                                                                                                        "WrapMonoid"
                                                                                                                        'PrefixI
                                                                                                                        'True>_P
                                                                                                                     <M1
                                                                                                                        S
                                                                                                                        ('MetaSel
                                                                                                                           ('Just
                                                                                                                              "unwrapMonoid")
                                                                                                                           'NoSourceUnpackedness
                                                                                                                           'NoSourceStrictness
                                                                                                                           'DecidedLazy)
                                                                                                                        Par1>_R ; GHC.Generics.N:M1[0]
                                                                                                                                      <*>_N
                                                                                                                                      <S>_P
                                                                                                                                      <'MetaSel
                                                                                                                                         ('Just
                                                                                                                                            "unwrapMonoid")
                                                                                                                                         'NoSourceUnpackedness
                                                                                                                                         'NoSourceStrictness
                                                                                                                                         'DecidedLazy>_P
                                                                                                                                      <Par1>_R))) <a>_N ; GHC.Generics.N:Par1[0]
                                                                                                                                                              (Sym (Data.Semigroup.N:WrappedMonoid[0]
                                                                                                                                                                        <a>_R))
                                       :: (forall a.
                                           Rep1 WrappedMonoid a -> Rep1 WrappedMonoid a :: *)
                                          ~R# (forall a.
                                               Rep1 WrappedMonoid a -> WrappedMonoid a :: *))]
Data.Semigroup.$fGeneric1WrappedMonoid
  = GHC.Generics.C:Generic1
      @ *
      @ WrappedMonoid
      (Data.Semigroup.$fGeneric1WrappedMonoid2
       `cast` (forall (a :: <*>_N).
               <WrappedMonoid a>_R
               ->_R Data.Semigroup.N:WrappedMonoid[0]
                        (Sym (GHC.Generics.N:Par1[0] <a>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                        <*>_N
                                                                        <S>_P
                                                                        <'MetaSel
                                                                           ('Just "unwrapMonoid")
                                                                           'NoSourceUnpackedness
                                                                           'NoSourceStrictness
                                                                           'DecidedLazy>_P
                                                                        <Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                              <*>_N
                                                                                              <C>_P
                                                                                              <'MetaCons
                                                                                                 "WrapMonoid"
                                                                                                 'PrefixI
                                                                                                 'True>_P
                                                                                              <M1
                                                                                                 S
                                                                                                 ('MetaSel
                                                                                                    ('Just
                                                                                                       "unwrapMonoid")
                                                                                                    'NoSourceUnpackedness
                                                                                                    'NoSourceStrictness
                                                                                                    'DecidedLazy)
                                                                                                 Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                      <*>_N
                                                                                                                      <D>_P
                                                                                                                      <'MetaData
                                                                                                                         "WrappedMonoid"
                                                                                                                         "Data.Semigroup"
                                                                                                                         "base"
                                                                                                                         'True>_P
                                                                                                                      <M1
                                                                                                                         C
                                                                                                                         ('MetaCons
                                                                                                                            "WrapMonoid"
                                                                                                                            'PrefixI
                                                                                                                            'True)
                                                                                                                         (M1
                                                                                                                            S
                                                                                                                            ('MetaSel
                                                                                                                               ('Just
                                                                                                                                  "unwrapMonoid")
                                                                                                                               'NoSourceUnpackedness
                                                                                                                               'NoSourceStrictness
                                                                                                                               'DecidedLazy)
                                                                                                                            Par1)>_R) ; Sub (Sym (Data.Semigroup.Rep1_WrappedMonoid[0]))))) <a>_N)
               :: (forall a. WrappedMonoid a -> WrappedMonoid a :: *)
                  ~R# (forall a. WrappedMonoid a -> Rep1 WrappedMonoid a :: *)))
      (Data.Semigroup.$fGeneric1WrappedMonoid1
       `cast` (forall (a :: <*>_N).
               <Rep1 WrappedMonoid a>_R
               ->_R (Sub (Data.Semigroup.Rep1_WrappedMonoid[0]) ; (GHC.Generics.N:M1[0]
                                                                       <*>_N
                                                                       <D>_P
                                                                       <'MetaData
                                                                          "WrappedMonoid"
                                                                          "Data.Semigroup"
                                                                          "base"
                                                                          'True>_P
                                                                       <M1
                                                                          C
                                                                          ('MetaCons
                                                                             "WrapMonoid"
                                                                             'PrefixI
                                                                             'True)
                                                                          (M1
                                                                             S
                                                                             ('MetaSel
                                                                                ('Just
                                                                                   "unwrapMonoid")
                                                                                'NoSourceUnpackedness
                                                                                'NoSourceStrictness
                                                                                'DecidedLazy)
                                                                             Par1)>_R ; (GHC.Generics.N:M1[0]
                                                                                             <*>_N
                                                                                             <C>_P
                                                                                             <'MetaCons
                                                                                                "WrapMonoid"
                                                                                                'PrefixI
                                                                                                'True>_P
                                                                                             <M1
                                                                                                S
                                                                                                ('MetaSel
                                                                                                   ('Just
                                                                                                      "unwrapMonoid")
                                                                                                   'NoSourceUnpackedness
                                                                                                   'NoSourceStrictness
                                                                                                   'DecidedLazy)
                                                                                                Par1>_R ; GHC.Generics.N:M1[0]
                                                                                                              <*>_N
                                                                                                              <S>_P
                                                                                                              <'MetaSel
                                                                                                                 ('Just
                                                                                                                    "unwrapMonoid")
                                                                                                                 'NoSourceUnpackedness
                                                                                                                 'NoSourceStrictness
                                                                                                                 'DecidedLazy>_P
                                                                                                              <Par1>_R))) <a>_N ; GHC.Generics.N:Par1[0]
                                                                                                                                      (Sym (Data.Semigroup.N:WrappedMonoid[0]
                                                                                                                                                <a>_R))
               :: (forall a. Rep1 WrappedMonoid a -> Rep1 WrappedMonoid a :: *)
                  ~R# (forall a. Rep1 WrappedMonoid a -> WrappedMonoid a :: *)))

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fGenericWrappedMonoid1
  :: forall m x. Rep (WrappedMonoid m) x -> Rep (WrappedMonoid m) x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ m_afyjp)
                 (@ x_afyjV)
                 (ds_dfzCS [Occ=Once] :: Rep (WrappedMonoid m_afyjp) x_afyjV) ->
                 ds_dfzCS}]
Data.Semigroup.$fGenericWrappedMonoid1
  = \ (@ m_afyjp)
      (@ x_afyjV)
      (ds_dfzCS :: Rep (WrappedMonoid m_afyjp) x_afyjV) ->
      ds_dfzCS

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Data.Semigroup.$fGenericWrappedMonoid2
  :: forall m x. WrappedMonoid m -> WrappedMonoid m
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ m_XfyEs)
                 (@ x_afyjt)
                 (x1_afxqJ [Occ=Once] :: WrappedMonoid m_XfyEs) ->
                 x1_afxqJ}]
Data.Semigroup.$fGenericWrappedMonoid2
  = \ (@ m_XfyEs) (@ x_afyjt) (x1_afxqJ :: WrappedMonoid m_XfyEs) ->
      x1_afxqJ

-- RHS size: {terms: 4, types: 6, coercions: 199, joins: 0/0}
Data.Semigroup.$fGenericWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m. Generic (WrappedMonoid m)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ m_afwM6) ->
       GHC.Generics.C:Generic TYPE: WrappedMonoid m_afwM6
                              (Data.Semigroup.$fGenericWrappedMonoid2 @ m_afwM6)
                              `cast` (forall (x :: <*>_N).
                                      <WrappedMonoid m_afwM6>_R
                                      ->_R Data.Semigroup.N:WrappedMonoid[0]
                                               (Sym (GHC.Generics.N:K1[0]
                                                         <*>_N
                                                         <R>_P
                                                         <m_afwM6>_R
                                                         <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                            <*>_N
                                                                            <S>_P
                                                                            <'MetaSel
                                                                               ('Just
                                                                                  "unwrapMonoid")
                                                                               'NoSourceUnpackedness
                                                                               'NoSourceStrictness
                                                                               'DecidedLazy>_P
                                                                            <K1
                                                                               R
                                                                               m_afwM6>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                       <*>_N
                                                                                                       <C>_P
                                                                                                       <'MetaCons
                                                                                                          "WrapMonoid"
                                                                                                          'PrefixI
                                                                                                          'True>_P
                                                                                                       <M1
                                                                                                          S
                                                                                                          ('MetaSel
                                                                                                             ('Just
                                                                                                                "unwrapMonoid")
                                                                                                             'NoSourceUnpackedness
                                                                                                             'NoSourceStrictness
                                                                                                             'DecidedLazy)
                                                                                                          (K1
                                                                                                             R
                                                                                                             m_afwM6)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                      <*>_N
                                                                                                                                      <D>_P
                                                                                                                                      <'MetaData
                                                                                                                                         "WrappedMonoid"
                                                                                                                                         "Data.Semigroup"
                                                                                                                                         "base"
                                                                                                                                         'True>_P
                                                                                                                                      <M1
                                                                                                                                         C
                                                                                                                                         ('MetaCons
                                                                                                                                            "WrapMonoid"
                                                                                                                                            'PrefixI
                                                                                                                                            'True)
                                                                                                                                         (M1
                                                                                                                                            S
                                                                                                                                            ('MetaSel
                                                                                                                                               ('Just
                                                                                                                                                  "unwrapMonoid")
                                                                                                                                               'NoSourceUnpackedness
                                                                                                                                               'NoSourceStrictness
                                                                                                                                               'DecidedLazy)
                                                                                                                                            (K1
                                                                                                                                               R
                                                                                                                                               m_afwM6))>_R) ; Sub (Sym (Data.Semigroup.Rep_WrappedMonoid[0]
                                                                                                                                                                             <m_afwM6>_N))))) <x>_N)
                                      :: (forall x.
                                          WrappedMonoid m_afwM6 -> WrappedMonoid m_afwM6 :: *)
                                         ~R# (forall x.
                                              WrappedMonoid m_afwM6
                                              -> Rep (WrappedMonoid m_afwM6) x :: *))
                              (Data.Semigroup.$fGenericWrappedMonoid1 @ m_afwM6)
                              `cast` (forall (x :: <*>_N).
                                      <Rep (WrappedMonoid m_afwM6) x>_R
                                      ->_R Sym (Data.Semigroup.N:WrappedMonoid[0]
                                                    (Sym (GHC.Generics.N:K1[0]
                                                              <*>_N
                                                              <R>_P
                                                              <m_afwM6>_R
                                                              <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                 <*>_N
                                                                                 <S>_P
                                                                                 <'MetaSel
                                                                                    ('Just
                                                                                       "unwrapMonoid")
                                                                                    'NoSourceUnpackedness
                                                                                    'NoSourceStrictness
                                                                                    'DecidedLazy>_P
                                                                                 <K1
                                                                                    R
                                                                                    m_afwM6>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                            <*>_N
                                                                                                            <C>_P
                                                                                                            <'MetaCons
                                                                                                               "WrapMonoid"
                                                                                                               'PrefixI
                                                                                                               'True>_P
                                                                                                            <M1
                                                                                                               S
                                                                                                               ('MetaSel
                                                                                                                  ('Just
                                                                                                                     "unwrapMonoid")
                                                                                                                  'NoSourceUnpackedness
                                                                                                                  'NoSourceStrictness
                                                                                                                  'DecidedLazy)
                                                                                                               (K1
                                                                                                                  R
                                                                                                                  m_afwM6)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                           <*>_N
                                                                                                                                           <D>_P
                                                                                                                                           <'MetaData
                                                                                                                                              "WrappedMonoid"
                                                                                                                                              "Data.Semigroup"
                                                                                                                                              "base"
                                                                                                                                              'True>_P
                                                                                                                                           <M1
                                                                                                                                              C
                                                                                                                                              ('MetaCons
                                                                                                                                                 "WrapMonoid"
                                                                                                                                                 'PrefixI
                                                                                                                                                 'True)
                                                                                                                                              (M1
                                                                                                                                                 S
                                                                                                                                                 ('MetaSel
                                                                                                                                                    ('Just
                                                                                                                                                       "unwrapMonoid")
                                                                                                                                                    'NoSourceUnpackedness
                                                                                                                                                    'NoSourceStrictness
                                                                                                                                                    'DecidedLazy)
                                                                                                                                                 (K1
                                                                                                                                                    R
                                                                                                                                                    m_afwM6))>_R) ; Sub (Sym (Data.Semigroup.Rep_WrappedMonoid[0]
                                                                                                                                                                                  <m_afwM6>_N))))) <x>_N))
                                      :: (forall x.
                                          Rep (WrappedMonoid m_afwM6) x
                                          -> Rep (WrappedMonoid m_afwM6) x :: *)
                                         ~R# (forall x.
                                              Rep (WrappedMonoid m_afwM6) x
                                              -> WrappedMonoid m_afwM6 :: *))]
Data.Semigroup.$fGenericWrappedMonoid
  = \ (@ m_XfyEx) ->
      GHC.Generics.C:Generic
        @ (WrappedMonoid m_XfyEx)
        ((Data.Semigroup.$fGenericWrappedMonoid2 @ m_XfyEx)
         `cast` (forall (x :: <*>_N).
                 <WrappedMonoid m_XfyEx>_R
                 ->_R Data.Semigroup.N:WrappedMonoid[0]
                          (Sym (GHC.Generics.N:K1[0]
                                    <*>_N <R>_P <m_XfyEx>_R <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                               <*>_N
                                                                               <S>_P
                                                                               <'MetaSel
                                                                                  ('Just
                                                                                     "unwrapMonoid")
                                                                                  'NoSourceUnpackedness
                                                                                  'NoSourceStrictness
                                                                                  'DecidedLazy>_P
                                                                               <K1
                                                                                  R
                                                                                  m_XfyEx>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                          <*>_N
                                                                                                          <C>_P
                                                                                                          <'MetaCons
                                                                                                             "WrapMonoid"
                                                                                                             'PrefixI
                                                                                                             'True>_P
                                                                                                          <M1
                                                                                                             S
                                                                                                             ('MetaSel
                                                                                                                ('Just
                                                                                                                   "unwrapMonoid")
                                                                                                                'NoSourceUnpackedness
                                                                                                                'NoSourceStrictness
                                                                                                                'DecidedLazy)
                                                                                                             (K1
                                                                                                                R
                                                                                                                m_XfyEx)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                         <*>_N
                                                                                                                                         <D>_P
                                                                                                                                         <'MetaData
                                                                                                                                            "WrappedMonoid"
                                                                                                                                            "Data.Semigroup"
                                                                                                                                            "base"
                                                                                                                                            'True>_P
                                                                                                                                         <M1
                                                                                                                                            C
                                                                                                                                            ('MetaCons
                                                                                                                                               "WrapMonoid"
                                                                                                                                               'PrefixI
                                                                                                                                               'True)
                                                                                                                                            (M1
                                                                                                                                               S
                                                                                                                                               ('MetaSel
                                                                                                                                                  ('Just
                                                                                                                                                     "unwrapMonoid")
                                                                                                                                                  'NoSourceUnpackedness
                                                                                                                                                  'NoSourceStrictness
                                                                                                                                                  'DecidedLazy)
                                                                                                                                               (K1
                                                                                                                                                  R
                                                                                                                                                  m_XfyEx))>_R) ; Sub (Sym (Data.Semigroup.Rep_WrappedMonoid[0]
                                                                                                                                                                                <m_XfyEx>_N))))) <x>_N)
                 :: (forall x. WrappedMonoid m_XfyEx -> WrappedMonoid m_XfyEx :: *)
                    ~R# (forall x.
                         WrappedMonoid m_XfyEx -> Rep (WrappedMonoid m_XfyEx) x :: *)))
        ((Data.Semigroup.$fGenericWrappedMonoid1 @ m_XfyEx)
         `cast` (forall (x :: <*>_N).
                 <Rep (WrappedMonoid m_XfyEx) x>_R
                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0]
                               (Sym (GHC.Generics.N:K1[0]
                                         <*>_N <R>_P <m_XfyEx>_R <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                    <*>_N
                                                                                    <S>_P
                                                                                    <'MetaSel
                                                                                       ('Just
                                                                                          "unwrapMonoid")
                                                                                       'NoSourceUnpackedness
                                                                                       'NoSourceStrictness
                                                                                       'DecidedLazy>_P
                                                                                    <K1
                                                                                       R
                                                                                       m_XfyEx>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                               <*>_N
                                                                                                               <C>_P
                                                                                                               <'MetaCons
                                                                                                                  "WrapMonoid"
                                                                                                                  'PrefixI
                                                                                                                  'True>_P
                                                                                                               <M1
                                                                                                                  S
                                                                                                                  ('MetaSel
                                                                                                                     ('Just
                                                                                                                        "unwrapMonoid")
                                                                                                                     'NoSourceUnpackedness
                                                                                                                     'NoSourceStrictness
                                                                                                                     'DecidedLazy)
                                                                                                                  (K1
                                                                                                                     R
                                                                                                                     m_XfyEx)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                              <*>_N
                                                                                                                                              <D>_P
                                                                                                                                              <'MetaData
                                                                                                                                                 "WrappedMonoid"
                                                                                                                                                 "Data.Semigroup"
                                                                                                                                                 "base"
                                                                                                                                                 'True>_P
                                                                                                                                              <M1
                                                                                                                                                 C
                                                                                                                                                 ('MetaCons
                                                                                                                                                    "WrapMonoid"
                                                                                                                                                    'PrefixI
                                                                                                                                                    'True)
                                                                                                                                                 (M1
                                                                                                                                                    S
                                                                                                                                                    ('MetaSel
                                                                                                                                                       ('Just
                                                                                                                                                          "unwrapMonoid")
                                                                                                                                                       'NoSourceUnpackedness
                                                                                                                                                       'NoSourceStrictness
                                                                                                                                                       'DecidedLazy)
                                                                                                                                                    (K1
                                                                                                                                                       R
                                                                                                                                                       m_XfyEx))>_R) ; Sub (Sym (Data.Semigroup.Rep_WrappedMonoid[0]
                                                                                                                                                                                     <m_XfyEx>_N))))) <x>_N))
                 :: (forall x.
                     Rep (WrappedMonoid m_XfyEx) x
                     -> Rep (WrappedMonoid m_XfyEx) x :: *)
                    ~R# (forall x.
                         Rep (WrappedMonoid m_XfyEx) x -> WrappedMonoid m_XfyEx :: *)))

-- RHS size: {terms: 11, types: 34, coercions: 7, joins: 0/0}
Data.Semigroup.$fDataWrappedMonoid_$cgfoldl
  :: forall m.
     Data m =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> WrappedMonoid m -> c (WrappedMonoid m)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_afygb)
                 ($dData_afygc [Occ=Once] :: Data m_afygb)
                 (@ (c_afygk :: * -> *))
                 (k_afxqD [Occ=Once!]
                    :: forall d b. Data d => c_afygk (d -> b) -> d -> c_afygk b)
                 (z_afxqE [Occ=Once!] :: forall g. g -> c_afygk g)
                 (ds_dfzCy [Occ=Once] :: WrappedMonoid m_afygb) ->
                 k_afxqD
                   @ m_afygb
                   @ (WrappedMonoid m_afygb)
                   $dData_afygc
                   (z_afxqE
                      @ (m_afygb -> WrappedMonoid m_afygb)
                      ((Data.Semigroup.$fApplicativeFirst3 @ m_afygb)
                       `cast` (<m_afygb>_R
                               ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afygb>_R)
                               :: (m_afygb -> m_afygb :: *)
                                  ~R# (m_afygb -> WrappedMonoid m_afygb :: *))))
                   (ds_dfzCy
                    `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_afygb>_R
                            :: (WrappedMonoid m_afygb :: *) ~R# (m_afygb :: *)))}]
Data.Semigroup.$fDataWrappedMonoid_$cgfoldl
  = \ (@ m_afygb)
      ($dData_afygc :: Data m_afygb)
      (@ (c_afygk :: * -> *))
      (k_afxqD
         :: forall d b. Data d => c_afygk (d -> b) -> d -> c_afygk b)
      (z_afxqE :: forall g. g -> c_afygk g)
      (ds_dfzCy :: WrappedMonoid m_afygb) ->
      k_afxqD
        @ m_afygb
        @ (WrappedMonoid m_afygb)
        $dData_afygc
        (z_afxqE
           @ (m_afygb -> WrappedMonoid m_afygb)
           ((Data.Semigroup.$fApplicativeFirst3 @ m_afygb)
            `cast` (<m_afygb>_R
                    ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afygb>_R)
                    :: (m_afygb -> m_afygb :: *)
                       ~R# (m_afygb -> WrappedMonoid m_afygb :: *))))
        (ds_dfzCy
         `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_afygb>_R
                 :: (WrappedMonoid m_afygb :: *) ~R# (m_afygb :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadWrappedMonoid5 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Semigroup.$fReadWrappedMonoid5 = "WrapMonoid"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadWrappedMonoid4 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fReadWrappedMonoid4
  = GHC.CString.unpackCString# Data.Semigroup.$fReadWrappedMonoid5

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadWrappedMonoid_lexeme :: Text.Read.Lex.Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fReadWrappedMonoid_lexeme
  = Text.Read.Lex.Ident Data.Semigroup.$fReadWrappedMonoid4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadWrappedMonoid3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Semigroup.$fReadWrappedMonoid3 = "unwrapMonoid"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadWrappedMonoid2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fReadWrappedMonoid2
  = GHC.CString.unpackCString# Data.Semigroup.$fReadWrappedMonoid3

-- RHS size: {terms: 51, types: 60, coercions: 23, joins: 0/2}
Data.Semigroup.$fReadWrappedMonoid1
  :: forall m.
     Read m =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (WrappedMonoid m -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,1*C1(U),A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30] 391 60}]
Data.Semigroup.$fReadWrappedMonoid1
  = \ (@ m_afyfm) ($dRead_afyfn :: Read m_afyfm) ->
      GHC.Read.list3
        @ (WrappedMonoid m_afyfm)
        (let {
           lvl33_sfAlc :: Text.ParserCombinators.ReadP.ReadP m_afyfm
           [LclId]
           lvl33_sfAlc
             = ((GHC.Read.readPrec @ m_afyfm $dRead_afyfn)
                `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <m_afyfm>_R
                        :: (Text.ParserCombinators.ReadPrec.ReadPrec m_afyfm :: *)
                           ~R# (Text.ParserCombinators.ReadPrec.Prec
                                -> Text.ParserCombinators.ReadP.ReadP m_afyfm :: *)))
                 Text.ParserCombinators.ReadPrec.minPrec } in
         let {
           ds_sfAhy [Dmd=<L,C(C1(U))>]
             :: Text.ParserCombinators.ReadPrec.Prec
                -> Text.ParserCombinators.ReadP.ReadP m_afyfm
           [LclId,
            Arity=1,
            Str=<L,A>,
            Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                    WorkFree=True, Expandable=True,
                    Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
                    Tmpl= \ _ [Occ=Dead] -> lvl33_sfAlc}]
           ds_sfAhy = \ _ [Occ=Dead] -> lvl33_sfAlc } in
         (\ (c_i88VW :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b_i815E)
            (eta_XiU
               :: WrappedMonoid m_afyfm
                  -> Text.ParserCombinators.ReadP.P b_i815E) ->
            case c_i88VW of { GHC.Types.I# x_i88VZ ->
            case GHC.Prim.<=# x_i88VZ 11# of {
              __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b_i815E;
              1# ->
                case Text.Read.Lex.$wexpect
                       Data.Semigroup.$fReadWrappedMonoid_lexeme
                       @ b_i815E
                       (\ _ [Occ=Dead, OS=OneShot] ->
                          case Text.Read.Lex.$wexpect
                                 Data.Semigroup.$fReadFirst_lexeme
                                 @ b_i815E
                                 (\ _ [Occ=Dead, OS=OneShot] ->
                                    ((((GHC.Read.readField
                                          @ m_afyfm
                                          Data.Semigroup.$fReadWrappedMonoid2
                                          (ds_sfAhy
                                           `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                            <m_afyfm>_R)
                                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                                       -> Text.ParserCombinators.ReadP.ReadP
                                                            m_afyfm :: *)
                                                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                                             m_afyfm :: *))))
                                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                   <m_afyfm>_R
                                               :: (Text.ParserCombinators.ReadPrec.ReadPrec
                                                     m_afyfm :: *)
                                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                       -> Text.ParserCombinators.ReadP.ReadP
                                                            m_afyfm :: *)))
                                        Data.Semigroup.$fReadArg2)
                                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <m_afyfm>_R
                                             :: (Text.ParserCombinators.ReadP.ReadP m_afyfm :: *)
                                                ~R# (forall b.
                                                     (m_afyfm -> Text.ParserCombinators.ReadP.P b)
                                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                                      @ b_i815E
                                      (\ (a3_i88WJ :: m_afyfm) ->
                                         case Text.Read.Lex.$wexpect
                                                Data.Semigroup.$fReadFirst2
                                                @ b_i815E
                                                (\ _ [Occ=Dead, OS=OneShot] ->
                                                   eta_XiU
                                                     (a3_i88WJ
                                                      `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0]
                                                                       <m_afyfm>_R)
                                                              :: (m_afyfm :: *)
                                                                 ~R# (WrappedMonoid m_afyfm :: *))))
                                         of
                                         { (# ww1_i88Ww #) ->
                                         Text.ParserCombinators.ReadP.Look @ b_i815E ww1_i88Ww
                                         }))
                          of
                          { (# ww1_i88Ww #) ->
                          Text.ParserCombinators.ReadP.Look @ b_i815E ww1_i88Ww
                          })
                of
                { (# ww1_i88Ww #) ->
                Text.ParserCombinators.ReadP.Look @ b_i815E ww1_i88Ww
                }
            }
            })
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <WrappedMonoid
                                   m_afyfm>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <WrappedMonoid m_afyfm>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (WrappedMonoid m_afyfm -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (WrappedMonoid m_afyfm) :: *)))

-- RHS size: {terms: 10, types: 21, coercions: 0, joins: 0/1}
Data.Semigroup.$fReadWrappedMonoid_$creadsPrec
  :: forall m. Read m => Int -> ReadS (WrappedMonoid m)
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,1*C1(U),A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 90 60}]
Data.Semigroup.$fReadWrappedMonoid_$creadsPrec
  = \ (@ m_XfyAE) ($dRead_XfyAG :: Read m_XfyAE) ->
      let {
        ds_sfAhq [Dmd=<L,C(C1(U))>]
          :: Text.ParserCombinators.ReadPrec.Prec
             -> forall b.
                (WrappedMonoid m_XfyAE -> Text.ParserCombinators.ReadP.P b)
                -> Text.ParserCombinators.ReadP.P b
        [LclId]
        ds_sfAhq
          = Data.Semigroup.$fReadWrappedMonoid1 @ m_XfyAE $dRead_XfyAG } in
      \ (n_i8156 :: Int) ->
        Text.ParserCombinators.ReadP.run
          @ (WrappedMonoid m_XfyAE)
          (ds_sfAhq
             n_i8156
             @ (WrappedMonoid m_XfyAE)
             (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                @ (WrappedMonoid m_XfyAE)))

-- RHS size: {terms: 5, types: 7, coercions: 11, joins: 0/0}
Data.Semigroup.$fReadWrappedMonoid_$creadListPrec
  :: forall m.
     Read m =>
     Text.ParserCombinators.ReadPrec.ReadPrec [WrappedMonoid m]
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,1*C1(U),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_XfyAC) ($dRead_XfyAE [Occ=Once] :: Read m_XfyAC) ->
                 GHC.Read.list
                   @ (WrappedMonoid m_XfyAC)
                   ((Data.Semigroup.$fReadWrappedMonoid1 @ m_XfyAC $dRead_XfyAE)
                    `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <WrappedMonoid
                                              m_XfyAC>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <WrappedMonoid m_XfyAC>_R)
                            :: (Text.ParserCombinators.ReadPrec.Prec
                                -> forall b.
                                   (WrappedMonoid m_XfyAC -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)
                               ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                      (WrappedMonoid m_XfyAC) :: *)))}]
Data.Semigroup.$fReadWrappedMonoid_$creadListPrec
  = \ (@ m_XfyAC) ($dRead_XfyAE :: Read m_XfyAC) ->
      GHC.Read.list
        @ (WrappedMonoid m_XfyAC)
        ((Data.Semigroup.$fReadWrappedMonoid1 @ m_XfyAC $dRead_XfyAE)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <WrappedMonoid
                                   m_XfyAC>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <WrappedMonoid m_XfyAC>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (WrappedMonoid m_XfyAC -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (WrappedMonoid m_XfyAC) :: *)))

-- RHS size: {terms: 8, types: 16, coercions: 19, joins: 0/0}
Data.Semigroup.$fReadWrappedMonoid_$creadList
  :: forall m. Read m => ReadS [WrappedMonoid m]
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,1*C1(U),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_XfyAD) ($dRead_XfyAF [Occ=Once] :: Read m_XfyAD) ->
                 Text.ParserCombinators.ReadP.run
                   @ [WrappedMonoid m_XfyAD]
                   (((((GHC.Read.list
                          @ (WrappedMonoid m_XfyAD)
                          ((Data.Semigroup.$fReadWrappedMonoid1 @ m_XfyAD $dRead_XfyAF)
                           `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                  <WrappedMonoid
                                                     m_XfyAD>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                             <WrappedMonoid
                                                                                m_XfyAD>_R)
                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                       -> forall b.
                                          (WrappedMonoid m_XfyAD
                                           -> Text.ParserCombinators.ReadP.P b)
                                          -> Text.ParserCombinators.ReadP.P b :: *)
                                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                             (WrappedMonoid m_XfyAD) :: *))))
                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                   <[WrappedMonoid m_XfyAD]>_R
                               :: (Text.ParserCombinators.ReadPrec.ReadPrec
                                     [WrappedMonoid m_XfyAD] :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                       -> Text.ParserCombinators.ReadP.ReadP
                                            [WrappedMonoid m_XfyAD] :: *)))
                        GHC.Read.$fRead()7)
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                                 <[WrappedMonoid m_XfyAD]>_R
                             :: (Text.ParserCombinators.ReadP.ReadP
                                   [WrappedMonoid m_XfyAD] :: *)
                                ~R# (forall b.
                                     ([WrappedMonoid m_XfyAD] -> Text.ParserCombinators.ReadP.P b)
                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                      @ [WrappedMonoid m_XfyAD]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [WrappedMonoid m_XfyAD]))}]
Data.Semigroup.$fReadWrappedMonoid_$creadList
  = \ (@ m_XfyAD) ($dRead_XfyAF :: Read m_XfyAD) ->
      Text.ParserCombinators.ReadP.run
        @ [WrappedMonoid m_XfyAD]
        (((((GHC.Read.list
               @ (WrappedMonoid m_XfyAD)
               ((Data.Semigroup.$fReadWrappedMonoid1 @ m_XfyAD $dRead_XfyAF)
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <WrappedMonoid
                                          m_XfyAD>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <WrappedMonoid m_XfyAD>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               (WrappedMonoid m_XfyAD -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                  (WrappedMonoid m_XfyAD) :: *))))
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[WrappedMonoid m_XfyAD]>_R
                    :: (Text.ParserCombinators.ReadPrec.ReadPrec
                          [WrappedMonoid m_XfyAD] :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.Prec
                            -> Text.ParserCombinators.ReadP.ReadP
                                 [WrappedMonoid m_XfyAD] :: *)))
             GHC.Read.$fRead()7)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                      <[WrappedMonoid m_XfyAD]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP
                        [WrappedMonoid m_XfyAD] :: *)
                     ~R# (forall b.
                          ([WrappedMonoid m_XfyAD] -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [WrappedMonoid m_XfyAD]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ [WrappedMonoid m_XfyAD]))

-- RHS size: {terms: 11, types: 10, coercions: 11, joins: 0/0}
Data.Semigroup.$fReadWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m. Read m => Read (WrappedMonoid m)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,A,C(U),A)>m,
 Unf=DFun: \ (@ m_afwM6) (v_Xlh :: Read m_afwM6) ->
       GHC.Read.C:Read TYPE: WrappedMonoid m_afwM6
                       Data.Semigroup.$fReadWrappedMonoid_$creadsPrec @ m_afwM6 v_Xlh
                       Data.Semigroup.$fReadWrappedMonoid_$creadList @ m_afwM6 v_Xlh
                       (Data.Semigroup.$fReadWrappedMonoid1 @ m_afwM6 v_Xlh)
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <WrappedMonoid
                                                 m_afwM6>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                         <WrappedMonoid m_afwM6>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (WrappedMonoid m_afwM6 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                         (WrappedMonoid m_afwM6) :: *))
                       Data.Semigroup.$fReadWrappedMonoid_$creadListPrec @ m_afwM6 v_Xlh]
Data.Semigroup.$fReadWrappedMonoid
  = \ (@ m_XfyAB) ($dRead_XfyAD :: Read m_XfyAB) ->
      GHC.Read.C:Read
        @ (WrappedMonoid m_XfyAB)
        (Data.Semigroup.$fReadWrappedMonoid_$creadsPrec
           @ m_XfyAB $dRead_XfyAD)
        (Data.Semigroup.$fReadWrappedMonoid_$creadList
           @ m_XfyAB $dRead_XfyAD)
        ((Data.Semigroup.$fReadWrappedMonoid1 @ m_XfyAB $dRead_XfyAD)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <WrappedMonoid
                                   m_XfyAB>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <WrappedMonoid m_XfyAB>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (WrappedMonoid m_XfyAB -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (WrappedMonoid m_XfyAB) :: *)))
        (Data.Semigroup.$fReadWrappedMonoid_$creadListPrec
           @ m_XfyAB $dRead_XfyAD)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowWrappedMonoid2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Semigroup.$fShowWrappedMonoid2 = "WrapMonoid {"#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowWrappedMonoid1 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Semigroup.$fShowWrappedMonoid1 = "unwrapMonoid = "#

-- RHS size: {terms: 37, types: 15, coercions: 2, joins: 0/1}
Data.Semigroup.$w$cshowsPrec6 [InlPrag=NOUSERINLINE[0]]
  :: forall m. Show m => GHC.Prim.Int# -> WrappedMonoid m -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 331 120}]
Data.Semigroup.$w$cshowsPrec6
  = \ (@ m_sfBqM)
      (w_sfBqN :: Show m_sfBqM)
      (ww_sfBqS :: GHC.Prim.Int#)
      (w1_sfBqP :: WrappedMonoid m_sfBqM) ->
      let {
        f_sfAhm [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        f_sfAhm
          = showsPrec
              @ m_sfBqM
              w_sfBqN
              Data.Semigroup.$fFoldableOption7
              (w1_sfBqP
               `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_sfBqM>_R
                       :: (WrappedMonoid m_sfBqM :: *) ~R# (m_sfBqM :: *))) } in
      case GHC.Prim.>=# ww_sfBqS 11# of {
        __DEFAULT ->
          \ (x_X7RSU :: String) ->
            GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowWrappedMonoid2
              (GHC.CString.unpackAppendCString#
                 Data.Semigroup.$fShowWrappedMonoid1
                 (f_sfAhm
                    (GHC.CString.unpackAppendCString#
                       Data.Semigroup.$fReadFirst4 x_X7RSU)));
        1# ->
          \ (x_i88RR :: String) ->
            GHC.Types.:
              @ Char
              GHC.Show.$fShow(,)4
              (GHC.CString.unpackAppendCString#
                 Data.Semigroup.$fShowWrappedMonoid2
                 (GHC.CString.unpackAppendCString#
                    Data.Semigroup.$fShowWrappedMonoid1
                    (f_sfAhm
                       (GHC.CString.unpackAppendCString#
                          Data.Semigroup.$fReadFirst4
                          (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x_i88RR)))))
      }

-- RHS size: {terms: 11, types: 10, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowWrappedMonoid_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall m. Show m => Int -> WrappedMonoid m -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_sfBqM)
                 (w_sfBqN [Occ=Once] :: Show m_sfBqM)
                 (w1_sfBqO [Occ=Once!] :: Int)
                 (w2_sfBqP [Occ=Once] :: WrappedMonoid m_sfBqM) ->
                 case w1_sfBqO of { GHC.Types.I# ww1_sfBqS [Occ=Once] ->
                 Data.Semigroup.$w$cshowsPrec6 @ m_sfBqM w_sfBqN ww1_sfBqS w2_sfBqP
                 }}]
Data.Semigroup.$fShowWrappedMonoid_$cshowsPrec
  = \ (@ m_sfBqM)
      (w_sfBqN :: Show m_sfBqM)
      (w1_sfBqO :: Int)
      (w2_sfBqP :: WrappedMonoid m_sfBqM) ->
      case w1_sfBqO of { GHC.Types.I# ww1_sfBqS ->
      Data.Semigroup.$w$cshowsPrec6 @ m_sfBqM w_sfBqN ww1_sfBqS w2_sfBqP
      }

-- RHS size: {terms: 12, types: 7, coercions: 2, joins: 0/0}
Data.Semigroup.$fShowWrappedMonoid_$cshow
  :: forall m. Show m => WrappedMonoid m -> String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 110 0}]
Data.Semigroup.$fShowWrappedMonoid_$cshow
  = \ (@ m_afyeR)
      ($dShow_afyeS :: Show m_afyeR)
      (x_i7Jay :: WrappedMonoid m_afyeR) ->
      GHC.CString.unpackAppendCString#
        Data.Semigroup.$fShowWrappedMonoid2
        (GHC.CString.unpackAppendCString#
           Data.Semigroup.$fShowWrappedMonoid1
           (showsPrec
              @ m_afyeR
              $dShow_afyeS
              Data.Semigroup.$fFoldableOption7
              (x_i7Jay
               `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_afyeR>_R
                       :: (WrappedMonoid m_afyeR :: *) ~R# (m_afyeR :: *)))
              Data.Semigroup.$fReadFirst3))

-- RHS size: {terms: 12, types: 13, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowWrappedMonoid_$cshowList
  :: forall m. Show m => [WrappedMonoid m] -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_afyeR)
                 ($dShow_afyeS [Occ=Once] :: Show m_afyeR)
                 (ls_i7JaB [Occ=Once] :: [WrappedMonoid m_afyeR])
                 (s_i7JaC [Occ=Once] :: String) ->
                 GHC.Show.showList__
                   @ (WrappedMonoid m_afyeR)
                   (Data.Semigroup.$fShowWrappedMonoid_$cshowsPrec
                      @ m_afyeR $dShow_afyeS Data.Semigroup.$fFoldableOption7)
                   ls_i7JaB
                   s_i7JaC}]
Data.Semigroup.$fShowWrappedMonoid_$cshowList
  = \ (@ m_afyeR)
      ($dShow_afyeS :: Show m_afyeR)
      (ls_i7JaB :: [WrappedMonoid m_afyeR])
      (s_i7JaC :: String) ->
      GHC.Show.showList__
        @ (WrappedMonoid m_afyeR)
        (\ (w_sfBqP :: WrappedMonoid m_afyeR) ->
           Data.Semigroup.$w$cshowsPrec6 @ m_afyeR $dShow_afyeS 0# w_sfBqP)
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 9, types: 9, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m. Show m => Show (WrappedMonoid m)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(C1(C(U))),A,A)>m,
 Unf=DFun: \ (@ m_afwM6) (v_Xlm :: Show m_afwM6) ->
       GHC.Show.C:Show TYPE: WrappedMonoid m_afwM6
                       Data.Semigroup.$fShowWrappedMonoid_$cshowsPrec @ m_afwM6 v_Xlm
                       Data.Semigroup.$fShowWrappedMonoid_$cshow @ m_afwM6 v_Xlm
                       Data.Semigroup.$fShowWrappedMonoid_$cshowList @ m_afwM6 v_Xlm]
Data.Semigroup.$fShowWrappedMonoid
  = \ (@ m_afyeR) ($dShow_afyeS :: Show m_afyeR) ->
      GHC.Show.C:Show
        @ (WrappedMonoid m_afyeR)
        (Data.Semigroup.$fShowWrappedMonoid_$cshowsPrec
           @ m_afyeR $dShow_afyeS)
        (Data.Semigroup.$fShowWrappedMonoid_$cshow @ m_afyeR $dShow_afyeS)
        (Data.Semigroup.$fShowWrappedMonoid_$cshowList
           @ m_afyeR $dShow_afyeS)

-- RHS size: {terms: 7, types: 8, coercions: 18, joins: 0/0}
Data.Semigroup.$fEqWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m. Eq m => Eq (WrappedMonoid m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ m_afwM6) (v_Xly :: Eq m_afwM6) ->
       GHC.Classes.C:Eq TYPE: WrappedMonoid m_afwM6
                        (== @ m_afwM6 v_Xly)
                        `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                ->_R <Bool>_R
                                :: (m_afwM6 -> m_afwM6 -> Bool :: *)
                                   ~R# (WrappedMonoid m_afwM6
                                        -> WrappedMonoid m_afwM6 -> Bool :: *))
                        (/= @ m_afwM6 v_Xly)
                        `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                ->_R <Bool>_R
                                :: (m_afwM6 -> m_afwM6 -> Bool :: *)
                                   ~R# (WrappedMonoid m_afwM6
                                        -> WrappedMonoid m_afwM6 -> Bool :: *))]
Data.Semigroup.$fEqWrappedMonoid
  = \ (@ m_afycu) ($dEq_afycv :: Eq m_afycu) ->
      GHC.Classes.C:Eq
        @ (WrappedMonoid m_afycu)
        ((== @ m_afycu $dEq_afycv)
         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afycu>_R)
                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afycu>_R)
                 ->_R <Bool>_R
                 :: (m_afycu -> m_afycu -> Bool :: *)
                    ~R# (WrappedMonoid m_afycu -> WrappedMonoid m_afycu -> Bool :: *)))
        ((/= @ m_afycu $dEq_afycv)
         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afycu>_R)
                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afycu>_R)
                 ->_R <Bool>_R
                 :: (m_afycu -> m_afycu -> Bool :: *)
                    ~R# (WrappedMonoid m_afycu -> WrappedMonoid m_afycu -> Bool :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Semigroup.$fOrdWrappedMonoid_$cp1Ord
  :: forall m. Ord m => Eq (WrappedMonoid m)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_afyd2) ($dOrd_afyd3 [Occ=Once] :: Ord m_afyd2) ->
                 Data.Semigroup.$fEqWrappedMonoid
                   @ m_afyd2 (GHC.Classes.$p1Ord @ m_afyd2 $dOrd_afyd3)}]
Data.Semigroup.$fOrdWrappedMonoid_$cp1Ord
  = \ (@ m_afyd2) ($dOrd_afyd3 :: Ord m_afyd2) ->
      Data.Semigroup.$fEqWrappedMonoid
        @ m_afyd2 (GHC.Classes.$p1Ord @ m_afyd2 $dOrd_afyd3)

-- RHS size: {terms: 19, types: 14, coercions: 67, joins: 0/0}
Data.Semigroup.$fOrdWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m. Ord m => Ord (WrappedMonoid m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=DFun: \ (@ m_afwM6) (v_XlA :: Ord m_afwM6) ->
       GHC.Classes.C:Ord TYPE: WrappedMonoid m_afwM6
                         Data.Semigroup.$fOrdWrappedMonoid_$cp1Ord @ m_afwM6 v_XlA
                         (compare @ m_afwM6 v_XlA)
                         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                 ->_R <Ordering>_R
                                 :: (m_afwM6 -> m_afwM6 -> Ordering :: *)
                                    ~R# (WrappedMonoid m_afwM6
                                         -> WrappedMonoid m_afwM6 -> Ordering :: *))
                         (< @ m_afwM6 v_XlA)
                         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                 ->_R <Bool>_R
                                 :: (m_afwM6 -> m_afwM6 -> Bool :: *)
                                    ~R# (WrappedMonoid m_afwM6
                                         -> WrappedMonoid m_afwM6 -> Bool :: *))
                         (<= @ m_afwM6 v_XlA)
                         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                 ->_R <Bool>_R
                                 :: (m_afwM6 -> m_afwM6 -> Bool :: *)
                                    ~R# (WrappedMonoid m_afwM6
                                         -> WrappedMonoid m_afwM6 -> Bool :: *))
                         (> @ m_afwM6 v_XlA)
                         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                 ->_R <Bool>_R
                                 :: (m_afwM6 -> m_afwM6 -> Bool :: *)
                                    ~R# (WrappedMonoid m_afwM6
                                         -> WrappedMonoid m_afwM6 -> Bool :: *))
                         (>= @ m_afwM6 v_XlA)
                         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                 ->_R <Bool>_R
                                 :: (m_afwM6 -> m_afwM6 -> Bool :: *)
                                    ~R# (WrappedMonoid m_afwM6
                                         -> WrappedMonoid m_afwM6 -> Bool :: *))
                         (max @ m_afwM6 v_XlA)
                         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                 :: (m_afwM6 -> m_afwM6 -> m_afwM6 :: *)
                                    ~R# (WrappedMonoid m_afwM6
                                         -> WrappedMonoid m_afwM6 -> WrappedMonoid m_afwM6 :: *))
                         (min @ m_afwM6 v_XlA)
                         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                 :: (m_afwM6 -> m_afwM6 -> m_afwM6 :: *)
                                    ~R# (WrappedMonoid m_afwM6
                                         -> WrappedMonoid m_afwM6 -> WrappedMonoid m_afwM6 :: *))]
Data.Semigroup.$fOrdWrappedMonoid
  = \ (@ m_afyd2) ($dOrd_afyd3 :: Ord m_afyd2) ->
      GHC.Classes.C:Ord
        @ (WrappedMonoid m_afyd2)
        (Data.Semigroup.$fOrdWrappedMonoid_$cp1Ord @ m_afyd2 $dOrd_afyd3)
        ((compare @ m_afyd2 $dOrd_afyd3)
         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyd2>_R)
                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyd2>_R)
                 ->_R <Ordering>_R
                 :: (m_afyd2 -> m_afyd2 -> Ordering :: *)
                    ~R# (WrappedMonoid m_afyd2
                         -> WrappedMonoid m_afyd2 -> Ordering :: *)))
        ((< @ m_afyd2 $dOrd_afyd3)
         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyd2>_R)
                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyd2>_R)
                 ->_R <Bool>_R
                 :: (m_afyd2 -> m_afyd2 -> Bool :: *)
                    ~R# (WrappedMonoid m_afyd2 -> WrappedMonoid m_afyd2 -> Bool :: *)))
        ((<= @ m_afyd2 $dOrd_afyd3)
         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyd2>_R)
                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyd2>_R)
                 ->_R <Bool>_R
                 :: (m_afyd2 -> m_afyd2 -> Bool :: *)
                    ~R# (WrappedMonoid m_afyd2 -> WrappedMonoid m_afyd2 -> Bool :: *)))
        ((> @ m_afyd2 $dOrd_afyd3)
         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyd2>_R)
                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyd2>_R)
                 ->_R <Bool>_R
                 :: (m_afyd2 -> m_afyd2 -> Bool :: *)
                    ~R# (WrappedMonoid m_afyd2 -> WrappedMonoid m_afyd2 -> Bool :: *)))
        ((>= @ m_afyd2 $dOrd_afyd3)
         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyd2>_R)
                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyd2>_R)
                 ->_R <Bool>_R
                 :: (m_afyd2 -> m_afyd2 -> Bool :: *)
                    ~R# (WrappedMonoid m_afyd2 -> WrappedMonoid m_afyd2 -> Bool :: *)))
        ((max @ m_afyd2 $dOrd_afyd3)
         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyd2>_R)
                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyd2>_R)
                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyd2>_R)
                 :: (m_afyd2 -> m_afyd2 -> m_afyd2 :: *)
                    ~R# (WrappedMonoid m_afyd2
                         -> WrappedMonoid m_afyd2 -> WrappedMonoid m_afyd2 :: *)))
        ((min @ m_afyd2 $dOrd_afyd3)
         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyd2>_R)
                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyd2>_R)
                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afyd2>_R)
                 :: (m_afyd2 -> m_afyd2 -> m_afyd2 :: *)
                    ~R# (WrappedMonoid m_afyd2
                         -> WrappedMonoid m_afyd2 -> WrappedMonoid m_afyd2 :: *)))

-- RHS size: {terms: 7, types: 8, coercions: 6, joins: 0/0}
Data.Semigroup.$fBoundedWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m. Bounded m => Bounded (WrappedMonoid m)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ m_afwM6) (v_XlD :: Bounded m_afwM6) ->
       GHC.Enum.C:Bounded TYPE: WrappedMonoid m_afwM6
                          (minBound @ m_afwM6 v_XlD)
                          `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                  :: (m_afwM6 :: *) ~R# (WrappedMonoid m_afwM6 :: *))
                          (maxBound @ m_afwM6 v_XlD)
                          `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                  :: (m_afwM6 :: *) ~R# (WrappedMonoid m_afwM6 :: *))]
Data.Semigroup.$fBoundedWrappedMonoid
  = \ (@ m_afycc) ($dBounded_afycd :: Bounded m_afycc) ->
      GHC.Enum.C:Bounded
        @ (WrappedMonoid m_afycc)
        ((minBound @ m_afycc $dBounded_afycd)
         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afycc>_R)
                 :: (m_afycc :: *) ~R# (WrappedMonoid m_afycc :: *)))
        ((maxBound @ m_afycc $dBounded_afycd)
         `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afycc>_R)
                 :: (m_afycc :: *) ~R# (WrappedMonoid m_afycc :: *)))

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fGeneric1Last1
  :: forall a. Rep1 Last a -> Rep1 Last a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afybN) (ds_dfzCs [Occ=Once] :: Rep1 Last a_afybN) ->
                 ds_dfzCs}]
Data.Semigroup.$fGeneric1Last1
  = \ (@ a_afybN) (ds_dfzCs :: Rep1 Last a_afybN) -> ds_dfzCs

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Semigroup.$fGeneric1Last2 :: forall a. Last a -> Last a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afybo) (x_afxqw [Occ=Once] :: Last a_afybo) ->
                 x_afxqw}]
Data.Semigroup.$fGeneric1Last2
  = \ (@ a_afybo) (x_afxqw :: Last a_afybo) -> x_afxqw

-- RHS size: {terms: 3, types: 3, coercions: 163, joins: 0/0}
Data.Semigroup.$fGeneric1Last [InlPrag=NOUSERINLINE CONLIKE]
  :: Generic1 Last
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Generics.C:Generic1 TYPE: *
                               TYPE: Last
                               Data.Semigroup.$fGeneric1Last2
                               `cast` (forall (a :: <*>_N).
                                       <Last a>_R
                                       ->_R Data.Semigroup.N:Last[0]
                                                (Sym (GHC.Generics.N:Par1[0]
                                                          <a>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                             <*>_N
                                                                             <S>_P
                                                                             <'MetaSel
                                                                                ('Just "getLast")
                                                                                'NoSourceUnpackedness
                                                                                'NoSourceStrictness
                                                                                'DecidedLazy>_P
                                                                             <Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                   <*>_N
                                                                                                   <C>_P
                                                                                                   <'MetaCons
                                                                                                      "Last"
                                                                                                      'PrefixI
                                                                                                      'True>_P
                                                                                                   <M1
                                                                                                      S
                                                                                                      ('MetaSel
                                                                                                         ('Just
                                                                                                            "getLast")
                                                                                                         'NoSourceUnpackedness
                                                                                                         'NoSourceStrictness
                                                                                                         'DecidedLazy)
                                                                                                      Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                           <*>_N
                                                                                                                           <D>_P
                                                                                                                           <'MetaData
                                                                                                                              "Last"
                                                                                                                              "Data.Semigroup"
                                                                                                                              "base"
                                                                                                                              'True>_P
                                                                                                                           <M1
                                                                                                                              C
                                                                                                                              ('MetaCons
                                                                                                                                 "Last"
                                                                                                                                 'PrefixI
                                                                                                                                 'True)
                                                                                                                              (M1
                                                                                                                                 S
                                                                                                                                 ('MetaSel
                                                                                                                                    ('Just
                                                                                                                                       "getLast")
                                                                                                                                    'NoSourceUnpackedness
                                                                                                                                    'NoSourceStrictness
                                                                                                                                    'DecidedLazy)
                                                                                                                                 Par1)>_R) ; Sub (Sym (Data.Semigroup.Rep1_Last[0]))))) <a>_N)
                                       :: (forall a. Last a -> Last a :: *)
                                          ~R# (forall a. Last a -> Rep1 Last a :: *))
                               Data.Semigroup.$fGeneric1Last1
                               `cast` (forall (a :: <*>_N).
                                       <Rep1 Last a>_R
                                       ->_R (Sub (Data.Semigroup.Rep1_Last[0]) ; (GHC.Generics.N:M1[0]
                                                                                      <*>_N
                                                                                      <D>_P
                                                                                      <'MetaData
                                                                                         "Last"
                                                                                         "Data.Semigroup"
                                                                                         "base"
                                                                                         'True>_P
                                                                                      <M1
                                                                                         C
                                                                                         ('MetaCons
                                                                                            "Last"
                                                                                            'PrefixI
                                                                                            'True)
                                                                                         (M1
                                                                                            S
                                                                                            ('MetaSel
                                                                                               ('Just
                                                                                                  "getLast")
                                                                                               'NoSourceUnpackedness
                                                                                               'NoSourceStrictness
                                                                                               'DecidedLazy)
                                                                                            Par1)>_R ; (GHC.Generics.N:M1[0]
                                                                                                            <*>_N
                                                                                                            <C>_P
                                                                                                            <'MetaCons
                                                                                                               "Last"
                                                                                                               'PrefixI
                                                                                                               'True>_P
                                                                                                            <M1
                                                                                                               S
                                                                                                               ('MetaSel
                                                                                                                  ('Just
                                                                                                                     "getLast")
                                                                                                                  'NoSourceUnpackedness
                                                                                                                  'NoSourceStrictness
                                                                                                                  'DecidedLazy)
                                                                                                               Par1>_R ; GHC.Generics.N:M1[0]
                                                                                                                             <*>_N
                                                                                                                             <S>_P
                                                                                                                             <'MetaSel
                                                                                                                                ('Just
                                                                                                                                   "getLast")
                                                                                                                                'NoSourceUnpackedness
                                                                                                                                'NoSourceStrictness
                                                                                                                                'DecidedLazy>_P
                                                                                                                             <Par1>_R))) <a>_N ; GHC.Generics.N:Par1[0]
                                                                                                                                                     (Sym (Data.Semigroup.N:Last[0]
                                                                                                                                                               <a>_R))
                                       :: (forall a. Rep1 Last a -> Rep1 Last a :: *)
                                          ~R# (forall a. Rep1 Last a -> Last a :: *))]
Data.Semigroup.$fGeneric1Last
  = GHC.Generics.C:Generic1
      @ *
      @ Last
      (Data.Semigroup.$fGeneric1Last2
       `cast` (forall (a :: <*>_N).
               <Last a>_R
               ->_R Data.Semigroup.N:Last[0]
                        (Sym (GHC.Generics.N:Par1[0] <a>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                        <*>_N
                                                                        <S>_P
                                                                        <'MetaSel
                                                                           ('Just "getLast")
                                                                           'NoSourceUnpackedness
                                                                           'NoSourceStrictness
                                                                           'DecidedLazy>_P
                                                                        <Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                              <*>_N
                                                                                              <C>_P
                                                                                              <'MetaCons
                                                                                                 "Last"
                                                                                                 'PrefixI
                                                                                                 'True>_P
                                                                                              <M1
                                                                                                 S
                                                                                                 ('MetaSel
                                                                                                    ('Just
                                                                                                       "getLast")
                                                                                                    'NoSourceUnpackedness
                                                                                                    'NoSourceStrictness
                                                                                                    'DecidedLazy)
                                                                                                 Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                      <*>_N
                                                                                                                      <D>_P
                                                                                                                      <'MetaData
                                                                                                                         "Last"
                                                                                                                         "Data.Semigroup"
                                                                                                                         "base"
                                                                                                                         'True>_P
                                                                                                                      <M1
                                                                                                                         C
                                                                                                                         ('MetaCons
                                                                                                                            "Last"
                                                                                                                            'PrefixI
                                                                                                                            'True)
                                                                                                                         (M1
                                                                                                                            S
                                                                                                                            ('MetaSel
                                                                                                                               ('Just
                                                                                                                                  "getLast")
                                                                                                                               'NoSourceUnpackedness
                                                                                                                               'NoSourceStrictness
                                                                                                                               'DecidedLazy)
                                                                                                                            Par1)>_R) ; Sub (Sym (Data.Semigroup.Rep1_Last[0]))))) <a>_N)
               :: (forall a. Last a -> Last a :: *)
                  ~R# (forall a. Last a -> Rep1 Last a :: *)))
      (Data.Semigroup.$fGeneric1Last1
       `cast` (forall (a :: <*>_N).
               <Rep1 Last a>_R
               ->_R (Sub (Data.Semigroup.Rep1_Last[0]) ; (GHC.Generics.N:M1[0]
                                                              <*>_N
                                                              <D>_P
                                                              <'MetaData
                                                                 "Last"
                                                                 "Data.Semigroup"
                                                                 "base"
                                                                 'True>_P
                                                              <M1
                                                                 C
                                                                 ('MetaCons "Last" 'PrefixI 'True)
                                                                 (M1
                                                                    S
                                                                    ('MetaSel
                                                                       ('Just "getLast")
                                                                       'NoSourceUnpackedness
                                                                       'NoSourceStrictness
                                                                       'DecidedLazy)
                                                                    Par1)>_R ; (GHC.Generics.N:M1[0]
                                                                                    <*>_N
                                                                                    <C>_P
                                                                                    <'MetaCons
                                                                                       "Last"
                                                                                       'PrefixI
                                                                                       'True>_P
                                                                                    <M1
                                                                                       S
                                                                                       ('MetaSel
                                                                                          ('Just
                                                                                             "getLast")
                                                                                          'NoSourceUnpackedness
                                                                                          'NoSourceStrictness
                                                                                          'DecidedLazy)
                                                                                       Par1>_R ; GHC.Generics.N:M1[0]
                                                                                                     <*>_N
                                                                                                     <S>_P
                                                                                                     <'MetaSel
                                                                                                        ('Just
                                                                                                           "getLast")
                                                                                                        'NoSourceUnpackedness
                                                                                                        'NoSourceStrictness
                                                                                                        'DecidedLazy>_P
                                                                                                     <Par1>_R))) <a>_N ; GHC.Generics.N:Par1[0]
                                                                                                                             (Sym (Data.Semigroup.N:Last[0]
                                                                                                                                       <a>_R))
               :: (forall a. Rep1 Last a -> Rep1 Last a :: *)
                  ~R# (forall a. Rep1 Last a -> Last a :: *)))

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fGenericLast1
  :: forall a x. Rep (Last a) x -> Rep (Last a) x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afyan)
                 (@ x_afyaT)
                 (ds_dfzCm [Occ=Once] :: Rep (Last a_afyan) x_afyaT) ->
                 ds_dfzCm}]
Data.Semigroup.$fGenericLast1
  = \ (@ a_afyan)
      (@ x_afyaT)
      (ds_dfzCm :: Rep (Last a_afyan) x_afyaT) ->
      ds_dfzCm

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Data.Semigroup.$fGenericLast2 :: forall a x. Last a -> Last a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_Xfywd)
                 (@ x_afyar)
                 (x1_afxqs [Occ=Once] :: Last a_Xfywd) ->
                 x1_afxqs}]
Data.Semigroup.$fGenericLast2
  = \ (@ a_Xfywd) (@ x_afyar) (x1_afxqs :: Last a_Xfywd) -> x1_afxqs

-- RHS size: {terms: 4, types: 6, coercions: 199, joins: 0/0}
Data.Semigroup.$fGenericLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Generic (Last a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_afwM7) ->
       GHC.Generics.C:Generic TYPE: Last a_afwM7
                              (Data.Semigroup.$fGenericLast2 @ a_afwM7)
                              `cast` (forall (x :: <*>_N).
                                      <Last a_afwM7>_R
                                      ->_R Data.Semigroup.N:Last[0]
                                               (Sym (GHC.Generics.N:K1[0]
                                                         <*>_N
                                                         <R>_P
                                                         <a_afwM7>_R
                                                         <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                            <*>_N
                                                                            <S>_P
                                                                            <'MetaSel
                                                                               ('Just "getLast")
                                                                               'NoSourceUnpackedness
                                                                               'NoSourceStrictness
                                                                               'DecidedLazy>_P
                                                                            <K1
                                                                               R
                                                                               a_afwM7>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                       <*>_N
                                                                                                       <C>_P
                                                                                                       <'MetaCons
                                                                                                          "Last"
                                                                                                          'PrefixI
                                                                                                          'True>_P
                                                                                                       <M1
                                                                                                          S
                                                                                                          ('MetaSel
                                                                                                             ('Just
                                                                                                                "getLast")
                                                                                                             'NoSourceUnpackedness
                                                                                                             'NoSourceStrictness
                                                                                                             'DecidedLazy)
                                                                                                          (K1
                                                                                                             R
                                                                                                             a_afwM7)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                      <*>_N
                                                                                                                                      <D>_P
                                                                                                                                      <'MetaData
                                                                                                                                         "Last"
                                                                                                                                         "Data.Semigroup"
                                                                                                                                         "base"
                                                                                                                                         'True>_P
                                                                                                                                      <M1
                                                                                                                                         C
                                                                                                                                         ('MetaCons
                                                                                                                                            "Last"
                                                                                                                                            'PrefixI
                                                                                                                                            'True)
                                                                                                                                         (M1
                                                                                                                                            S
                                                                                                                                            ('MetaSel
                                                                                                                                               ('Just
                                                                                                                                                  "getLast")
                                                                                                                                               'NoSourceUnpackedness
                                                                                                                                               'NoSourceStrictness
                                                                                                                                               'DecidedLazy)
                                                                                                                                            (K1
                                                                                                                                               R
                                                                                                                                               a_afwM7))>_R) ; Sub (Sym (Data.Semigroup.Rep_Last[0]
                                                                                                                                                                             <a_afwM7>_N))))) <x>_N)
                                      :: (forall x. Last a_afwM7 -> Last a_afwM7 :: *)
                                         ~R# (forall x. Last a_afwM7 -> Rep (Last a_afwM7) x :: *))
                              (Data.Semigroup.$fGenericLast1 @ a_afwM7)
                              `cast` (forall (x :: <*>_N).
                                      <Rep (Last a_afwM7) x>_R
                                      ->_R Sym (Data.Semigroup.N:Last[0]
                                                    (Sym (GHC.Generics.N:K1[0]
                                                              <*>_N
                                                              <R>_P
                                                              <a_afwM7>_R
                                                              <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                 <*>_N
                                                                                 <S>_P
                                                                                 <'MetaSel
                                                                                    ('Just
                                                                                       "getLast")
                                                                                    'NoSourceUnpackedness
                                                                                    'NoSourceStrictness
                                                                                    'DecidedLazy>_P
                                                                                 <K1
                                                                                    R
                                                                                    a_afwM7>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                            <*>_N
                                                                                                            <C>_P
                                                                                                            <'MetaCons
                                                                                                               "Last"
                                                                                                               'PrefixI
                                                                                                               'True>_P
                                                                                                            <M1
                                                                                                               S
                                                                                                               ('MetaSel
                                                                                                                  ('Just
                                                                                                                     "getLast")
                                                                                                                  'NoSourceUnpackedness
                                                                                                                  'NoSourceStrictness
                                                                                                                  'DecidedLazy)
                                                                                                               (K1
                                                                                                                  R
                                                                                                                  a_afwM7)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                           <*>_N
                                                                                                                                           <D>_P
                                                                                                                                           <'MetaData
                                                                                                                                              "Last"
                                                                                                                                              "Data.Semigroup"
                                                                                                                                              "base"
                                                                                                                                              'True>_P
                                                                                                                                           <M1
                                                                                                                                              C
                                                                                                                                              ('MetaCons
                                                                                                                                                 "Last"
                                                                                                                                                 'PrefixI
                                                                                                                                                 'True)
                                                                                                                                              (M1
                                                                                                                                                 S
                                                                                                                                                 ('MetaSel
                                                                                                                                                    ('Just
                                                                                                                                                       "getLast")
                                                                                                                                                    'NoSourceUnpackedness
                                                                                                                                                    'NoSourceStrictness
                                                                                                                                                    'DecidedLazy)
                                                                                                                                                 (K1
                                                                                                                                                    R
                                                                                                                                                    a_afwM7))>_R) ; Sub (Sym (Data.Semigroup.Rep_Last[0]
                                                                                                                                                                                  <a_afwM7>_N))))) <x>_N))
                                      :: (forall x.
                                          Rep (Last a_afwM7) x -> Rep (Last a_afwM7) x :: *)
                                         ~R# (forall x. Rep (Last a_afwM7) x -> Last a_afwM7 :: *))]
Data.Semigroup.$fGenericLast
  = \ (@ a_Xfywi) ->
      GHC.Generics.C:Generic
        @ (Last a_Xfywi)
        ((Data.Semigroup.$fGenericLast2 @ a_Xfywi)
         `cast` (forall (x :: <*>_N).
                 <Last a_Xfywi>_R
                 ->_R Data.Semigroup.N:Last[0]
                          (Sym (GHC.Generics.N:K1[0]
                                    <*>_N <R>_P <a_Xfywi>_R <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                               <*>_N
                                                                               <S>_P
                                                                               <'MetaSel
                                                                                  ('Just "getLast")
                                                                                  'NoSourceUnpackedness
                                                                                  'NoSourceStrictness
                                                                                  'DecidedLazy>_P
                                                                               <K1
                                                                                  R
                                                                                  a_Xfywi>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                          <*>_N
                                                                                                          <C>_P
                                                                                                          <'MetaCons
                                                                                                             "Last"
                                                                                                             'PrefixI
                                                                                                             'True>_P
                                                                                                          <M1
                                                                                                             S
                                                                                                             ('MetaSel
                                                                                                                ('Just
                                                                                                                   "getLast")
                                                                                                                'NoSourceUnpackedness
                                                                                                                'NoSourceStrictness
                                                                                                                'DecidedLazy)
                                                                                                             (K1
                                                                                                                R
                                                                                                                a_Xfywi)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                         <*>_N
                                                                                                                                         <D>_P
                                                                                                                                         <'MetaData
                                                                                                                                            "Last"
                                                                                                                                            "Data.Semigroup"
                                                                                                                                            "base"
                                                                                                                                            'True>_P
                                                                                                                                         <M1
                                                                                                                                            C
                                                                                                                                            ('MetaCons
                                                                                                                                               "Last"
                                                                                                                                               'PrefixI
                                                                                                                                               'True)
                                                                                                                                            (M1
                                                                                                                                               S
                                                                                                                                               ('MetaSel
                                                                                                                                                  ('Just
                                                                                                                                                     "getLast")
                                                                                                                                                  'NoSourceUnpackedness
                                                                                                                                                  'NoSourceStrictness
                                                                                                                                                  'DecidedLazy)
                                                                                                                                               (K1
                                                                                                                                                  R
                                                                                                                                                  a_Xfywi))>_R) ; Sub (Sym (Data.Semigroup.Rep_Last[0]
                                                                                                                                                                                <a_Xfywi>_N))))) <x>_N)
                 :: (forall x. Last a_Xfywi -> Last a_Xfywi :: *)
                    ~R# (forall x. Last a_Xfywi -> Rep (Last a_Xfywi) x :: *)))
        ((Data.Semigroup.$fGenericLast1 @ a_Xfywi)
         `cast` (forall (x :: <*>_N).
                 <Rep (Last a_Xfywi) x>_R
                 ->_R Sym (Data.Semigroup.N:Last[0]
                               (Sym (GHC.Generics.N:K1[0]
                                         <*>_N <R>_P <a_Xfywi>_R <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                    <*>_N
                                                                                    <S>_P
                                                                                    <'MetaSel
                                                                                       ('Just
                                                                                          "getLast")
                                                                                       'NoSourceUnpackedness
                                                                                       'NoSourceStrictness
                                                                                       'DecidedLazy>_P
                                                                                    <K1
                                                                                       R
                                                                                       a_Xfywi>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                               <*>_N
                                                                                                               <C>_P
                                                                                                               <'MetaCons
                                                                                                                  "Last"
                                                                                                                  'PrefixI
                                                                                                                  'True>_P
                                                                                                               <M1
                                                                                                                  S
                                                                                                                  ('MetaSel
                                                                                                                     ('Just
                                                                                                                        "getLast")
                                                                                                                     'NoSourceUnpackedness
                                                                                                                     'NoSourceStrictness
                                                                                                                     'DecidedLazy)
                                                                                                                  (K1
                                                                                                                     R
                                                                                                                     a_Xfywi)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                              <*>_N
                                                                                                                                              <D>_P
                                                                                                                                              <'MetaData
                                                                                                                                                 "Last"
                                                                                                                                                 "Data.Semigroup"
                                                                                                                                                 "base"
                                                                                                                                                 'True>_P
                                                                                                                                              <M1
                                                                                                                                                 C
                                                                                                                                                 ('MetaCons
                                                                                                                                                    "Last"
                                                                                                                                                    'PrefixI
                                                                                                                                                    'True)
                                                                                                                                                 (M1
                                                                                                                                                    S
                                                                                                                                                    ('MetaSel
                                                                                                                                                       ('Just
                                                                                                                                                          "getLast")
                                                                                                                                                       'NoSourceUnpackedness
                                                                                                                                                       'NoSourceStrictness
                                                                                                                                                       'DecidedLazy)
                                                                                                                                                    (K1
                                                                                                                                                       R
                                                                                                                                                       a_Xfywi))>_R) ; Sub (Sym (Data.Semigroup.Rep_Last[0]
                                                                                                                                                                                     <a_Xfywi>_N))))) <x>_N))
                 :: (forall x. Rep (Last a_Xfywi) x -> Rep (Last a_Xfywi) x :: *)
                    ~R# (forall x. Rep (Last a_Xfywi) x -> Last a_Xfywi :: *)))

-- RHS size: {terms: 11, types: 34, coercions: 7, joins: 0/0}
Data.Semigroup.$fDataLast_$cgfoldl
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Last a -> c (Last a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afy79)
                 ($dData_afy7a [Occ=Once] :: Data a_afy79)
                 (@ (c_afy7i :: * -> *))
                 (k_afxqm [Occ=Once!]
                    :: forall d b. Data d => c_afy7i (d -> b) -> d -> c_afy7i b)
                 (z_afxqn [Occ=Once!] :: forall g. g -> c_afy7i g)
                 (ds_dfzC2 [Occ=Once] :: Last a_afy79) ->
                 k_afxqm
                   @ a_afy79
                   @ (Last a_afy79)
                   $dData_afy7a
                   (z_afxqn
                      @ (a_afy79 -> Last a_afy79)
                      ((Data.Semigroup.$fApplicativeFirst3 @ a_afy79)
                       `cast` (<a_afy79>_R ->_R Sym (Data.Semigroup.N:Last[0] <a_afy79>_R)
                               :: (a_afy79 -> a_afy79 :: *) ~R# (a_afy79 -> Last a_afy79 :: *))))
                   (ds_dfzC2
                    `cast` (Data.Semigroup.N:Last[0] <a_afy79>_R
                            :: (Last a_afy79 :: *) ~R# (a_afy79 :: *)))}]
Data.Semigroup.$fDataLast_$cgfoldl
  = \ (@ a_afy79)
      ($dData_afy7a :: Data a_afy79)
      (@ (c_afy7i :: * -> *))
      (k_afxqm
         :: forall d b. Data d => c_afy7i (d -> b) -> d -> c_afy7i b)
      (z_afxqn :: forall g. g -> c_afy7i g)
      (ds_dfzC2 :: Last a_afy79) ->
      k_afxqm
        @ a_afy79
        @ (Last a_afy79)
        $dData_afy7a
        (z_afxqn
           @ (a_afy79 -> Last a_afy79)
           ((Data.Semigroup.$fApplicativeFirst3 @ a_afy79)
            `cast` (<a_afy79>_R ->_R Sym (Data.Semigroup.N:Last[0] <a_afy79>_R)
                    :: (a_afy79 -> a_afy79 :: *) ~R# (a_afy79 -> Last a_afy79 :: *))))
        (ds_dfzC2
         `cast` (Data.Semigroup.N:Last[0] <a_afy79>_R
                 :: (Last a_afy79 :: *) ~R# (a_afy79 :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataLast4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fDataLast4 = "Last"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataLast7 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fDataLast7
  = GHC.CString.unpackCString# Data.Semigroup.$fDataLast4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadLast_lexeme :: Text.Read.Lex.Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fReadLast_lexeme
  = Text.Read.Lex.Ident Data.Semigroup.$fDataLast7

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadLast3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Semigroup.$fReadLast3 = "getLast"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadLast2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fReadLast2
  = GHC.CString.unpackCString# Data.Semigroup.$fReadLast3

-- RHS size: {terms: 51, types: 60, coercions: 23, joins: 0/2}
Data.Semigroup.$fReadLast1
  :: forall a.
     Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Last a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,1*C1(U),A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30] 391 60}]
Data.Semigroup.$fReadLast1
  = \ (@ a_afy6k) ($dRead_afy6l :: Read a_afy6k) ->
      GHC.Read.list3
        @ (Last a_afy6k)
        (let {
           lvl33_sfAlT :: Text.ParserCombinators.ReadP.ReadP a_afy6k
           [LclId]
           lvl33_sfAlT
             = ((GHC.Read.readPrec @ a_afy6k $dRead_afy6l)
                `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <a_afy6k>_R
                        :: (Text.ParserCombinators.ReadPrec.ReadPrec a_afy6k :: *)
                           ~R# (Text.ParserCombinators.ReadPrec.Prec
                                -> Text.ParserCombinators.ReadP.ReadP a_afy6k :: *)))
                 Text.ParserCombinators.ReadPrec.minPrec } in
         let {
           ds_sfAh8 [Dmd=<L,C(C1(U))>]
             :: Text.ParserCombinators.ReadPrec.Prec
                -> Text.ParserCombinators.ReadP.ReadP a_afy6k
           [LclId,
            Arity=1,
            Str=<L,A>,
            Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                    WorkFree=True, Expandable=True,
                    Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
                    Tmpl= \ _ [Occ=Dead] -> lvl33_sfAlT}]
           ds_sfAh8 = \ _ [Occ=Dead] -> lvl33_sfAlT } in
         (\ (c_i88VW :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b_i815E)
            (eta_Xjf
               :: Last a_afy6k -> Text.ParserCombinators.ReadP.P b_i815E) ->
            case c_i88VW of { GHC.Types.I# x_i88VZ ->
            case GHC.Prim.<=# x_i88VZ 11# of {
              __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b_i815E;
              1# ->
                case Text.Read.Lex.$wexpect
                       Data.Semigroup.$fReadLast_lexeme
                       @ b_i815E
                       (\ _ [Occ=Dead, OS=OneShot] ->
                          case Text.Read.Lex.$wexpect
                                 Data.Semigroup.$fReadFirst_lexeme
                                 @ b_i815E
                                 (\ _ [Occ=Dead, OS=OneShot] ->
                                    ((((GHC.Read.readField
                                          @ a_afy6k
                                          Data.Semigroup.$fReadLast2
                                          (ds_sfAh8
                                           `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                            <a_afy6k>_R)
                                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                                       -> Text.ParserCombinators.ReadP.ReadP
                                                            a_afy6k :: *)
                                                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                                             a_afy6k :: *))))
                                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                   <a_afy6k>_R
                                               :: (Text.ParserCombinators.ReadPrec.ReadPrec
                                                     a_afy6k :: *)
                                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                       -> Text.ParserCombinators.ReadP.ReadP
                                                            a_afy6k :: *)))
                                        Data.Semigroup.$fReadArg2)
                                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_afy6k>_R
                                             :: (Text.ParserCombinators.ReadP.ReadP a_afy6k :: *)
                                                ~R# (forall b.
                                                     (a_afy6k -> Text.ParserCombinators.ReadP.P b)
                                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                                      @ b_i815E
                                      (\ (a3_i88WJ :: a_afy6k) ->
                                         case Text.Read.Lex.$wexpect
                                                Data.Semigroup.$fReadFirst2
                                                @ b_i815E
                                                (\ _ [Occ=Dead, OS=OneShot] ->
                                                   eta_Xjf
                                                     (a3_i88WJ
                                                      `cast` (Sym (Data.Semigroup.N:Last[0]
                                                                       <a_afy6k>_R)
                                                              :: (a_afy6k :: *)
                                                                 ~R# (Last a_afy6k :: *))))
                                         of
                                         { (# ww1_i88Ww #) ->
                                         Text.ParserCombinators.ReadP.Look @ b_i815E ww1_i88Ww
                                         }))
                          of
                          { (# ww1_i88Ww #) ->
                          Text.ParserCombinators.ReadP.Look @ b_i815E ww1_i88Ww
                          })
                of
                { (# ww1_i88Ww #) ->
                Text.ParserCombinators.ReadP.Look @ b_i815E ww1_i88Ww
                }
            }
            })
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Last
                                   a_afy6k>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Last a_afy6k>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Last a_afy6k -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (Last a_afy6k) :: *)))

-- RHS size: {terms: 10, types: 21, coercions: 0, joins: 0/1}
Data.Semigroup.$fReadLast_$creadsPrec
  :: forall a. Read a => Int -> ReadS (Last a)
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,1*C1(U),A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 90 60}]
Data.Semigroup.$fReadLast_$creadsPrec
  = \ (@ a_Xfysp) ($dRead_Xfysr :: Read a_Xfysp) ->
      let {
        ds_sfAh0 [Dmd=<L,C(C1(U))>]
          :: Text.ParserCombinators.ReadPrec.Prec
             -> forall b.
                (Last a_Xfysp -> Text.ParserCombinators.ReadP.P b)
                -> Text.ParserCombinators.ReadP.P b
        [LclId]
        ds_sfAh0 = Data.Semigroup.$fReadLast1 @ a_Xfysp $dRead_Xfysr } in
      \ (n_i8156 :: Int) ->
        Text.ParserCombinators.ReadP.run
          @ (Last a_Xfysp)
          (ds_sfAh0
             n_i8156
             @ (Last a_Xfysp)
             (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                @ (Last a_Xfysp)))

-- RHS size: {terms: 5, types: 7, coercions: 11, joins: 0/0}
Data.Semigroup.$fReadLast_$creadListPrec
  :: forall a.
     Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Last a]
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,1*C1(U),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xfysn) ($dRead_Xfysp [Occ=Once] :: Read a_Xfysn) ->
                 GHC.Read.list
                   @ (Last a_Xfysn)
                   ((Data.Semigroup.$fReadLast1 @ a_Xfysn $dRead_Xfysp)
                    `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Last
                                              a_Xfysn>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <Last a_Xfysn>_R)
                            :: (Text.ParserCombinators.ReadPrec.Prec
                                -> forall b.
                                   (Last a_Xfysn -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)
                               ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                      (Last a_Xfysn) :: *)))}]
Data.Semigroup.$fReadLast_$creadListPrec
  = \ (@ a_Xfysn) ($dRead_Xfysp :: Read a_Xfysn) ->
      GHC.Read.list
        @ (Last a_Xfysn)
        ((Data.Semigroup.$fReadLast1 @ a_Xfysn $dRead_Xfysp)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Last
                                   a_Xfysn>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Last a_Xfysn>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Last a_Xfysn -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (Last a_Xfysn) :: *)))

-- RHS size: {terms: 8, types: 16, coercions: 19, joins: 0/0}
Data.Semigroup.$fReadLast_$creadList
  :: forall a. Read a => ReadS [Last a]
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,1*C1(U),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xfyso) ($dRead_Xfysq [Occ=Once] :: Read a_Xfyso) ->
                 Text.ParserCombinators.ReadP.run
                   @ [Last a_Xfyso]
                   (((((GHC.Read.list
                          @ (Last a_Xfyso)
                          ((Data.Semigroup.$fReadLast1 @ a_Xfyso $dRead_Xfysq)
                           `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                  <Last
                                                     a_Xfyso>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                             <Last a_Xfyso>_R)
                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                       -> forall b.
                                          (Last a_Xfyso -> Text.ParserCombinators.ReadP.P b)
                                          -> Text.ParserCombinators.ReadP.P b :: *)
                                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                             (Last a_Xfyso) :: *))))
                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                   <[Last a_Xfyso]>_R
                               :: (Text.ParserCombinators.ReadPrec.ReadPrec [Last a_Xfyso] :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                       -> Text.ParserCombinators.ReadP.ReadP [Last a_Xfyso] :: *)))
                        GHC.Read.$fRead()7)
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[Last a_Xfyso]>_R
                             :: (Text.ParserCombinators.ReadP.ReadP [Last a_Xfyso] :: *)
                                ~R# (forall b.
                                     ([Last a_Xfyso] -> Text.ParserCombinators.ReadP.P b)
                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                      @ [Last a_Xfyso]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [Last a_Xfyso]))}]
Data.Semigroup.$fReadLast_$creadList
  = \ (@ a_Xfyso) ($dRead_Xfysq :: Read a_Xfyso) ->
      Text.ParserCombinators.ReadP.run
        @ [Last a_Xfyso]
        (((((GHC.Read.list
               @ (Last a_Xfyso)
               ((Data.Semigroup.$fReadLast1 @ a_Xfyso $dRead_Xfysq)
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Last
                                          a_Xfyso>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <Last a_Xfyso>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               (Last a_Xfyso -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                  (Last a_Xfyso) :: *))))
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[Last a_Xfyso]>_R
                    :: (Text.ParserCombinators.ReadPrec.ReadPrec [Last a_Xfyso] :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.Prec
                            -> Text.ParserCombinators.ReadP.ReadP [Last a_Xfyso] :: *)))
             GHC.Read.$fRead()7)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[Last a_Xfyso]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP [Last a_Xfyso] :: *)
                     ~R# (forall b.
                          ([Last a_Xfyso] -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [Last a_Xfyso]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ [Last a_Xfyso]))

-- RHS size: {terms: 11, types: 10, coercions: 11, joins: 0/0}
Data.Semigroup.$fReadLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Read a => Read (Last a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,A,C(U),A)>m,
 Unf=DFun: \ (@ a_afwM7) (v_Xm4 :: Read a_afwM7) ->
       GHC.Read.C:Read TYPE: Last a_afwM7
                       Data.Semigroup.$fReadLast_$creadsPrec @ a_afwM7 v_Xm4
                       Data.Semigroup.$fReadLast_$creadList @ a_afwM7 v_Xm4
                       (Data.Semigroup.$fReadLast1 @ a_afwM7 v_Xm4)
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Last
                                                 a_afwM7>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                         <Last a_afwM7>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Last a_afwM7 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                         (Last a_afwM7) :: *))
                       Data.Semigroup.$fReadLast_$creadListPrec @ a_afwM7 v_Xm4]
Data.Semigroup.$fReadLast
  = \ (@ a_Xfysm) ($dRead_Xfyso :: Read a_Xfysm) ->
      GHC.Read.C:Read
        @ (Last a_Xfysm)
        (Data.Semigroup.$fReadLast_$creadsPrec @ a_Xfysm $dRead_Xfyso)
        (Data.Semigroup.$fReadLast_$creadList @ a_Xfysm $dRead_Xfyso)
        ((Data.Semigroup.$fReadLast1 @ a_Xfysm $dRead_Xfyso)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Last
                                   a_Xfysm>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Last a_Xfysm>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Last a_Xfysm -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (Last a_Xfysm) :: *)))
        (Data.Semigroup.$fReadLast_$creadListPrec @ a_Xfysm $dRead_Xfyso)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowLast2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Semigroup.$fShowLast2 = "Last {"#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowLast1 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Semigroup.$fShowLast1 = "getLast = "#

-- RHS size: {terms: 37, types: 15, coercions: 2, joins: 0/1}
Data.Semigroup.$w$cshowsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => GHC.Prim.Int# -> Last a -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 331 120}]
Data.Semigroup.$w$cshowsPrec2
  = \ (@ a_sfBr2)
      (w_sfBr3 :: Show a_sfBr2)
      (ww_sfBr8 :: GHC.Prim.Int#)
      (w1_sfBr5 :: Last a_sfBr2) ->
      let {
        f_sfAgW [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        f_sfAgW
          = showsPrec
              @ a_sfBr2
              w_sfBr3
              Data.Semigroup.$fFoldableOption7
              (w1_sfBr5
               `cast` (Data.Semigroup.N:Last[0] <a_sfBr2>_R
                       :: (Last a_sfBr2 :: *) ~R# (a_sfBr2 :: *))) } in
      case GHC.Prim.>=# ww_sfBr8 11# of {
        __DEFAULT ->
          \ (x_X7RTH :: String) ->
            GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowLast2
              (GHC.CString.unpackAppendCString#
                 Data.Semigroup.$fShowLast1
                 (f_sfAgW
                    (GHC.CString.unpackAppendCString#
                       Data.Semigroup.$fReadFirst4 x_X7RTH)));
        1# ->
          \ (x_i88RR :: String) ->
            GHC.Types.:
              @ Char
              GHC.Show.$fShow(,)4
              (GHC.CString.unpackAppendCString#
                 Data.Semigroup.$fShowLast2
                 (GHC.CString.unpackAppendCString#
                    Data.Semigroup.$fShowLast1
                    (f_sfAgW
                       (GHC.CString.unpackAppendCString#
                          Data.Semigroup.$fReadFirst4
                          (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x_i88RR)))))
      }

-- RHS size: {terms: 11, types: 10, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowLast_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => Int -> Last a -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sfBr2)
                 (w_sfBr3 [Occ=Once] :: Show a_sfBr2)
                 (w1_sfBr4 [Occ=Once!] :: Int)
                 (w2_sfBr5 [Occ=Once] :: Last a_sfBr2) ->
                 case w1_sfBr4 of { GHC.Types.I# ww1_sfBr8 [Occ=Once] ->
                 Data.Semigroup.$w$cshowsPrec2 @ a_sfBr2 w_sfBr3 ww1_sfBr8 w2_sfBr5
                 }}]
Data.Semigroup.$fShowLast_$cshowsPrec
  = \ (@ a_sfBr2)
      (w_sfBr3 :: Show a_sfBr2)
      (w1_sfBr4 :: Int)
      (w2_sfBr5 :: Last a_sfBr2) ->
      case w1_sfBr4 of { GHC.Types.I# ww1_sfBr8 ->
      Data.Semigroup.$w$cshowsPrec2 @ a_sfBr2 w_sfBr3 ww1_sfBr8 w2_sfBr5
      }

-- RHS size: {terms: 12, types: 7, coercions: 2, joins: 0/0}
Data.Semigroup.$fShowLast_$cshow
  :: forall a. Show a => Last a -> String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 110 0}]
Data.Semigroup.$fShowLast_$cshow
  = \ (@ a_afy5P)
      ($dShow_afy5Q :: Show a_afy5P)
      (x_i7Jay :: Last a_afy5P) ->
      GHC.CString.unpackAppendCString#
        Data.Semigroup.$fShowLast2
        (GHC.CString.unpackAppendCString#
           Data.Semigroup.$fShowLast1
           (showsPrec
              @ a_afy5P
              $dShow_afy5Q
              Data.Semigroup.$fFoldableOption7
              (x_i7Jay
               `cast` (Data.Semigroup.N:Last[0] <a_afy5P>_R
                       :: (Last a_afy5P :: *) ~R# (a_afy5P :: *)))
              Data.Semigroup.$fReadFirst3))

-- RHS size: {terms: 12, types: 13, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowLast_$cshowList
  :: forall a. Show a => [Last a] -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afy5P)
                 ($dShow_afy5Q [Occ=Once] :: Show a_afy5P)
                 (ls_i7JaB [Occ=Once] :: [Last a_afy5P])
                 (s_i7JaC [Occ=Once] :: String) ->
                 GHC.Show.showList__
                   @ (Last a_afy5P)
                   (Data.Semigroup.$fShowLast_$cshowsPrec
                      @ a_afy5P $dShow_afy5Q Data.Semigroup.$fFoldableOption7)
                   ls_i7JaB
                   s_i7JaC}]
Data.Semigroup.$fShowLast_$cshowList
  = \ (@ a_afy5P)
      ($dShow_afy5Q :: Show a_afy5P)
      (ls_i7JaB :: [Last a_afy5P])
      (s_i7JaC :: String) ->
      GHC.Show.showList__
        @ (Last a_afy5P)
        (\ (w_sfBr5 :: Last a_afy5P) ->
           Data.Semigroup.$w$cshowsPrec2 @ a_afy5P $dShow_afy5Q 0# w_sfBr5)
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 9, types: 9, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Show a => Show (Last a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(C1(C(U))),A,A)>m,
 Unf=DFun: \ (@ a_afwM7) (v_Xm9 :: Show a_afwM7) ->
       GHC.Show.C:Show TYPE: Last a_afwM7
                       Data.Semigroup.$fShowLast_$cshowsPrec @ a_afwM7 v_Xm9
                       Data.Semigroup.$fShowLast_$cshow @ a_afwM7 v_Xm9
                       Data.Semigroup.$fShowLast_$cshowList @ a_afwM7 v_Xm9]
Data.Semigroup.$fShowLast
  = \ (@ a_afy5P) ($dShow_afy5Q :: Show a_afy5P) ->
      GHC.Show.C:Show
        @ (Last a_afy5P)
        (Data.Semigroup.$fShowLast_$cshowsPrec @ a_afy5P $dShow_afy5Q)
        (Data.Semigroup.$fShowLast_$cshow @ a_afy5P $dShow_afy5Q)
        (Data.Semigroup.$fShowLast_$cshowList @ a_afy5P $dShow_afy5Q)

-- RHS size: {terms: 7, types: 8, coercions: 18, joins: 0/0}
Data.Semigroup.$fEqLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Eq a => Eq (Last a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_afwM7) (v_Xml :: Eq a_afwM7) ->
       GHC.Classes.C:Eq TYPE: Last a_afwM7
                        (== @ a_afwM7 v_Xml)
                        `cast` (Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                ->_R Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                ->_R <Bool>_R
                                :: (a_afwM7 -> a_afwM7 -> Bool :: *)
                                   ~R# (Last a_afwM7 -> Last a_afwM7 -> Bool :: *))
                        (/= @ a_afwM7 v_Xml)
                        `cast` (Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                ->_R Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                ->_R <Bool>_R
                                :: (a_afwM7 -> a_afwM7 -> Bool :: *)
                                   ~R# (Last a_afwM7 -> Last a_afwM7 -> Bool :: *))]
Data.Semigroup.$fEqLast
  = \ (@ a_afy3s) ($dEq_afy3t :: Eq a_afy3s) ->
      GHC.Classes.C:Eq
        @ (Last a_afy3s)
        ((== @ a_afy3s $dEq_afy3t)
         `cast` (Sym (Data.Semigroup.N:Last[0] <a_afy3s>_R)
                 ->_R Sym (Data.Semigroup.N:Last[0] <a_afy3s>_R)
                 ->_R <Bool>_R
                 :: (a_afy3s -> a_afy3s -> Bool :: *)
                    ~R# (Last a_afy3s -> Last a_afy3s -> Bool :: *)))
        ((/= @ a_afy3s $dEq_afy3t)
         `cast` (Sym (Data.Semigroup.N:Last[0] <a_afy3s>_R)
                 ->_R Sym (Data.Semigroup.N:Last[0] <a_afy3s>_R)
                 ->_R <Bool>_R
                 :: (a_afy3s -> a_afy3s -> Bool :: *)
                    ~R# (Last a_afy3s -> Last a_afy3s -> Bool :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Semigroup.$fOrdLast_$cp1Ord :: forall a. Ord a => Eq (Last a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afy40) ($dOrd_afy41 [Occ=Once] :: Ord a_afy40) ->
                 Data.Semigroup.$fEqLast
                   @ a_afy40 (GHC.Classes.$p1Ord @ a_afy40 $dOrd_afy41)}]
Data.Semigroup.$fOrdLast_$cp1Ord
  = \ (@ a_afy40) ($dOrd_afy41 :: Ord a_afy40) ->
      Data.Semigroup.$fEqLast
        @ a_afy40 (GHC.Classes.$p1Ord @ a_afy40 $dOrd_afy41)

-- RHS size: {terms: 19, types: 14, coercions: 67, joins: 0/0}
Data.Semigroup.$fOrdLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Ord a => Ord (Last a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=DFun: \ (@ a_afwM7) (v_Xmn :: Ord a_afwM7) ->
       GHC.Classes.C:Ord TYPE: Last a_afwM7
                         Data.Semigroup.$fOrdLast_$cp1Ord @ a_afwM7 v_Xmn
                         (compare @ a_afwM7 v_Xmn)
                         `cast` (Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                 ->_R Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                 ->_R <Ordering>_R
                                 :: (a_afwM7 -> a_afwM7 -> Ordering :: *)
                                    ~R# (Last a_afwM7 -> Last a_afwM7 -> Ordering :: *))
                         (< @ a_afwM7 v_Xmn)
                         `cast` (Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                 ->_R Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                 ->_R <Bool>_R
                                 :: (a_afwM7 -> a_afwM7 -> Bool :: *)
                                    ~R# (Last a_afwM7 -> Last a_afwM7 -> Bool :: *))
                         (<= @ a_afwM7 v_Xmn)
                         `cast` (Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                 ->_R Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                 ->_R <Bool>_R
                                 :: (a_afwM7 -> a_afwM7 -> Bool :: *)
                                    ~R# (Last a_afwM7 -> Last a_afwM7 -> Bool :: *))
                         (> @ a_afwM7 v_Xmn)
                         `cast` (Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                 ->_R Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                 ->_R <Bool>_R
                                 :: (a_afwM7 -> a_afwM7 -> Bool :: *)
                                    ~R# (Last a_afwM7 -> Last a_afwM7 -> Bool :: *))
                         (>= @ a_afwM7 v_Xmn)
                         `cast` (Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                 ->_R Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                 ->_R <Bool>_R
                                 :: (a_afwM7 -> a_afwM7 -> Bool :: *)
                                    ~R# (Last a_afwM7 -> Last a_afwM7 -> Bool :: *))
                         (max @ a_afwM7 v_Xmn)
                         `cast` (Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                 ->_R Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                 ->_R Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                 :: (a_afwM7 -> a_afwM7 -> a_afwM7 :: *)
                                    ~R# (Last a_afwM7 -> Last a_afwM7 -> Last a_afwM7 :: *))
                         (min @ a_afwM7 v_Xmn)
                         `cast` (Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                 ->_R Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                 ->_R Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                 :: (a_afwM7 -> a_afwM7 -> a_afwM7 :: *)
                                    ~R# (Last a_afwM7 -> Last a_afwM7 -> Last a_afwM7 :: *))]
Data.Semigroup.$fOrdLast
  = \ (@ a_afy40) ($dOrd_afy41 :: Ord a_afy40) ->
      GHC.Classes.C:Ord
        @ (Last a_afy40)
        (Data.Semigroup.$fOrdLast_$cp1Ord @ a_afy40 $dOrd_afy41)
        ((compare @ a_afy40 $dOrd_afy41)
         `cast` (Sym (Data.Semigroup.N:Last[0] <a_afy40>_R)
                 ->_R Sym (Data.Semigroup.N:Last[0] <a_afy40>_R)
                 ->_R <Ordering>_R
                 :: (a_afy40 -> a_afy40 -> Ordering :: *)
                    ~R# (Last a_afy40 -> Last a_afy40 -> Ordering :: *)))
        ((< @ a_afy40 $dOrd_afy41)
         `cast` (Sym (Data.Semigroup.N:Last[0] <a_afy40>_R)
                 ->_R Sym (Data.Semigroup.N:Last[0] <a_afy40>_R)
                 ->_R <Bool>_R
                 :: (a_afy40 -> a_afy40 -> Bool :: *)
                    ~R# (Last a_afy40 -> Last a_afy40 -> Bool :: *)))
        ((<= @ a_afy40 $dOrd_afy41)
         `cast` (Sym (Data.Semigroup.N:Last[0] <a_afy40>_R)
                 ->_R Sym (Data.Semigroup.N:Last[0] <a_afy40>_R)
                 ->_R <Bool>_R
                 :: (a_afy40 -> a_afy40 -> Bool :: *)
                    ~R# (Last a_afy40 -> Last a_afy40 -> Bool :: *)))
        ((> @ a_afy40 $dOrd_afy41)
         `cast` (Sym (Data.Semigroup.N:Last[0] <a_afy40>_R)
                 ->_R Sym (Data.Semigroup.N:Last[0] <a_afy40>_R)
                 ->_R <Bool>_R
                 :: (a_afy40 -> a_afy40 -> Bool :: *)
                    ~R# (Last a_afy40 -> Last a_afy40 -> Bool :: *)))
        ((>= @ a_afy40 $dOrd_afy41)
         `cast` (Sym (Data.Semigroup.N:Last[0] <a_afy40>_R)
                 ->_R Sym (Data.Semigroup.N:Last[0] <a_afy40>_R)
                 ->_R <Bool>_R
                 :: (a_afy40 -> a_afy40 -> Bool :: *)
                    ~R# (Last a_afy40 -> Last a_afy40 -> Bool :: *)))
        ((max @ a_afy40 $dOrd_afy41)
         `cast` (Sym (Data.Semigroup.N:Last[0] <a_afy40>_R)
                 ->_R Sym (Data.Semigroup.N:Last[0] <a_afy40>_R)
                 ->_R Sym (Data.Semigroup.N:Last[0] <a_afy40>_R)
                 :: (a_afy40 -> a_afy40 -> a_afy40 :: *)
                    ~R# (Last a_afy40 -> Last a_afy40 -> Last a_afy40 :: *)))
        ((min @ a_afy40 $dOrd_afy41)
         `cast` (Sym (Data.Semigroup.N:Last[0] <a_afy40>_R)
                 ->_R Sym (Data.Semigroup.N:Last[0] <a_afy40>_R)
                 ->_R Sym (Data.Semigroup.N:Last[0] <a_afy40>_R)
                 :: (a_afy40 -> a_afy40 -> a_afy40 :: *)
                    ~R# (Last a_afy40 -> Last a_afy40 -> Last a_afy40 :: *)))

-- RHS size: {terms: 7, types: 8, coercions: 6, joins: 0/0}
Data.Semigroup.$fBoundedLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Bounded a => Bounded (Last a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_afwM7) (v_Xmq :: Bounded a_afwM7) ->
       GHC.Enum.C:Bounded TYPE: Last a_afwM7
                          (minBound @ a_afwM7 v_Xmq)
                          `cast` (Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                  :: (a_afwM7 :: *) ~R# (Last a_afwM7 :: *))
                          (maxBound @ a_afwM7 v_Xmq)
                          `cast` (Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                  :: (a_afwM7 :: *) ~R# (Last a_afwM7 :: *))]
Data.Semigroup.$fBoundedLast
  = \ (@ a_afy3a) ($dBounded_afy3b :: Bounded a_afy3a) ->
      GHC.Enum.C:Bounded
        @ (Last a_afy3a)
        ((minBound @ a_afy3a $dBounded_afy3b)
         `cast` (Sym (Data.Semigroup.N:Last[0] <a_afy3a>_R)
                 :: (a_afy3a :: *) ~R# (Last a_afy3a :: *)))
        ((maxBound @ a_afy3a $dBounded_afy3b)
         `cast` (Sym (Data.Semigroup.N:Last[0] <a_afy3a>_R)
                 :: (a_afy3a :: *) ~R# (Last a_afy3a :: *)))

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fGeneric1First1
  :: forall a. Rep1 First a -> Rep1 First a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afy2L) (ds_dfzBW [Occ=Once] :: Rep1 First a_afy2L) ->
                 ds_dfzBW}]
Data.Semigroup.$fGeneric1First1
  = \ (@ a_afy2L) (ds_dfzBW :: Rep1 First a_afy2L) -> ds_dfzBW

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Semigroup.$fGeneric1First2 :: forall a. First a -> First a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afy2m) (x_afxqf [Occ=Once] :: First a_afy2m) ->
                 x_afxqf}]
Data.Semigroup.$fGeneric1First2
  = \ (@ a_afy2m) (x_afxqf :: First a_afy2m) -> x_afxqf

-- RHS size: {terms: 3, types: 3, coercions: 163, joins: 0/0}
Data.Semigroup.$fGeneric1First [InlPrag=NOUSERINLINE CONLIKE]
  :: Generic1 First
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Generics.C:Generic1 TYPE: *
                               TYPE: First
                               Data.Semigroup.$fGeneric1First2
                               `cast` (forall (a :: <*>_N).
                                       <First a>_R
                                       ->_R Data.Semigroup.N:First[0]
                                                (Sym (GHC.Generics.N:Par1[0]
                                                          <a>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                             <*>_N
                                                                             <S>_P
                                                                             <'MetaSel
                                                                                ('Just "getFirst")
                                                                                'NoSourceUnpackedness
                                                                                'NoSourceStrictness
                                                                                'DecidedLazy>_P
                                                                             <Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                   <*>_N
                                                                                                   <C>_P
                                                                                                   <'MetaCons
                                                                                                      "First"
                                                                                                      'PrefixI
                                                                                                      'True>_P
                                                                                                   <M1
                                                                                                      S
                                                                                                      ('MetaSel
                                                                                                         ('Just
                                                                                                            "getFirst")
                                                                                                         'NoSourceUnpackedness
                                                                                                         'NoSourceStrictness
                                                                                                         'DecidedLazy)
                                                                                                      Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                           <*>_N
                                                                                                                           <D>_P
                                                                                                                           <'MetaData
                                                                                                                              "First"
                                                                                                                              "Data.Semigroup"
                                                                                                                              "base"
                                                                                                                              'True>_P
                                                                                                                           <M1
                                                                                                                              C
                                                                                                                              ('MetaCons
                                                                                                                                 "First"
                                                                                                                                 'PrefixI
                                                                                                                                 'True)
                                                                                                                              (M1
                                                                                                                                 S
                                                                                                                                 ('MetaSel
                                                                                                                                    ('Just
                                                                                                                                       "getFirst")
                                                                                                                                    'NoSourceUnpackedness
                                                                                                                                    'NoSourceStrictness
                                                                                                                                    'DecidedLazy)
                                                                                                                                 Par1)>_R) ; Sub (Sym (Data.Semigroup.Rep1_First[0]))))) <a>_N)
                                       :: (forall a. First a -> First a :: *)
                                          ~R# (forall a. First a -> Rep1 First a :: *))
                               Data.Semigroup.$fGeneric1First1
                               `cast` (forall (a :: <*>_N).
                                       <Rep1 First a>_R
                                       ->_R (Sub (Data.Semigroup.Rep1_First[0]) ; (GHC.Generics.N:M1[0]
                                                                                       <*>_N
                                                                                       <D>_P
                                                                                       <'MetaData
                                                                                          "First"
                                                                                          "Data.Semigroup"
                                                                                          "base"
                                                                                          'True>_P
                                                                                       <M1
                                                                                          C
                                                                                          ('MetaCons
                                                                                             "First"
                                                                                             'PrefixI
                                                                                             'True)
                                                                                          (M1
                                                                                             S
                                                                                             ('MetaSel
                                                                                                ('Just
                                                                                                   "getFirst")
                                                                                                'NoSourceUnpackedness
                                                                                                'NoSourceStrictness
                                                                                                'DecidedLazy)
                                                                                             Par1)>_R ; (GHC.Generics.N:M1[0]
                                                                                                             <*>_N
                                                                                                             <C>_P
                                                                                                             <'MetaCons
                                                                                                                "First"
                                                                                                                'PrefixI
                                                                                                                'True>_P
                                                                                                             <M1
                                                                                                                S
                                                                                                                ('MetaSel
                                                                                                                   ('Just
                                                                                                                      "getFirst")
                                                                                                                   'NoSourceUnpackedness
                                                                                                                   'NoSourceStrictness
                                                                                                                   'DecidedLazy)
                                                                                                                Par1>_R ; GHC.Generics.N:M1[0]
                                                                                                                              <*>_N
                                                                                                                              <S>_P
                                                                                                                              <'MetaSel
                                                                                                                                 ('Just
                                                                                                                                    "getFirst")
                                                                                                                                 'NoSourceUnpackedness
                                                                                                                                 'NoSourceStrictness
                                                                                                                                 'DecidedLazy>_P
                                                                                                                              <Par1>_R))) <a>_N ; GHC.Generics.N:Par1[0]
                                                                                                                                                      (Sym (Data.Semigroup.N:First[0]
                                                                                                                                                                <a>_R))
                                       :: (forall a. Rep1 First a -> Rep1 First a :: *)
                                          ~R# (forall a. Rep1 First a -> First a :: *))]
Data.Semigroup.$fGeneric1First
  = GHC.Generics.C:Generic1
      @ *
      @ First
      (Data.Semigroup.$fGeneric1First2
       `cast` (forall (a :: <*>_N).
               <First a>_R
               ->_R Data.Semigroup.N:First[0]
                        (Sym (GHC.Generics.N:Par1[0] <a>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                        <*>_N
                                                                        <S>_P
                                                                        <'MetaSel
                                                                           ('Just "getFirst")
                                                                           'NoSourceUnpackedness
                                                                           'NoSourceStrictness
                                                                           'DecidedLazy>_P
                                                                        <Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                              <*>_N
                                                                                              <C>_P
                                                                                              <'MetaCons
                                                                                                 "First"
                                                                                                 'PrefixI
                                                                                                 'True>_P
                                                                                              <M1
                                                                                                 S
                                                                                                 ('MetaSel
                                                                                                    ('Just
                                                                                                       "getFirst")
                                                                                                    'NoSourceUnpackedness
                                                                                                    'NoSourceStrictness
                                                                                                    'DecidedLazy)
                                                                                                 Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                      <*>_N
                                                                                                                      <D>_P
                                                                                                                      <'MetaData
                                                                                                                         "First"
                                                                                                                         "Data.Semigroup"
                                                                                                                         "base"
                                                                                                                         'True>_P
                                                                                                                      <M1
                                                                                                                         C
                                                                                                                         ('MetaCons
                                                                                                                            "First"
                                                                                                                            'PrefixI
                                                                                                                            'True)
                                                                                                                         (M1
                                                                                                                            S
                                                                                                                            ('MetaSel
                                                                                                                               ('Just
                                                                                                                                  "getFirst")
                                                                                                                               'NoSourceUnpackedness
                                                                                                                               'NoSourceStrictness
                                                                                                                               'DecidedLazy)
                                                                                                                            Par1)>_R) ; Sub (Sym (Data.Semigroup.Rep1_First[0]))))) <a>_N)
               :: (forall a. First a -> First a :: *)
                  ~R# (forall a. First a -> Rep1 First a :: *)))
      (Data.Semigroup.$fGeneric1First1
       `cast` (forall (a :: <*>_N).
               <Rep1 First a>_R
               ->_R (Sub (Data.Semigroup.Rep1_First[0]) ; (GHC.Generics.N:M1[0]
                                                               <*>_N
                                                               <D>_P
                                                               <'MetaData
                                                                  "First"
                                                                  "Data.Semigroup"
                                                                  "base"
                                                                  'True>_P
                                                               <M1
                                                                  C
                                                                  ('MetaCons "First" 'PrefixI 'True)
                                                                  (M1
                                                                     S
                                                                     ('MetaSel
                                                                        ('Just "getFirst")
                                                                        'NoSourceUnpackedness
                                                                        'NoSourceStrictness
                                                                        'DecidedLazy)
                                                                     Par1)>_R ; (GHC.Generics.N:M1[0]
                                                                                     <*>_N
                                                                                     <C>_P
                                                                                     <'MetaCons
                                                                                        "First"
                                                                                        'PrefixI
                                                                                        'True>_P
                                                                                     <M1
                                                                                        S
                                                                                        ('MetaSel
                                                                                           ('Just
                                                                                              "getFirst")
                                                                                           'NoSourceUnpackedness
                                                                                           'NoSourceStrictness
                                                                                           'DecidedLazy)
                                                                                        Par1>_R ; GHC.Generics.N:M1[0]
                                                                                                      <*>_N
                                                                                                      <S>_P
                                                                                                      <'MetaSel
                                                                                                         ('Just
                                                                                                            "getFirst")
                                                                                                         'NoSourceUnpackedness
                                                                                                         'NoSourceStrictness
                                                                                                         'DecidedLazy>_P
                                                                                                      <Par1>_R))) <a>_N ; GHC.Generics.N:Par1[0]
                                                                                                                              (Sym (Data.Semigroup.N:First[0]
                                                                                                                                        <a>_R))
               :: (forall a. Rep1 First a -> Rep1 First a :: *)
                  ~R# (forall a. Rep1 First a -> First a :: *)))

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fGenericFirst1
  :: forall a x. Rep (First a) x -> Rep (First a) x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afy1l)
                 (@ x_afy1R)
                 (ds_dfzBQ [Occ=Once] :: Rep (First a_afy1l) x_afy1R) ->
                 ds_dfzBQ}]
Data.Semigroup.$fGenericFirst1
  = \ (@ a_afy1l)
      (@ x_afy1R)
      (ds_dfzBQ :: Rep (First a_afy1l) x_afy1R) ->
      ds_dfzBQ

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Data.Semigroup.$fGenericFirst2 :: forall a x. First a -> First a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_XfynY)
                 (@ x_afy1p)
                 (x1_afxqb [Occ=Once] :: First a_XfynY) ->
                 x1_afxqb}]
Data.Semigroup.$fGenericFirst2
  = \ (@ a_XfynY) (@ x_afy1p) (x1_afxqb :: First a_XfynY) -> x1_afxqb

-- RHS size: {terms: 4, types: 6, coercions: 199, joins: 0/0}
Data.Semigroup.$fGenericFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Generic (First a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_afwM8) ->
       GHC.Generics.C:Generic TYPE: First a_afwM8
                              (Data.Semigroup.$fGenericFirst2 @ a_afwM8)
                              `cast` (forall (x :: <*>_N).
                                      <First a_afwM8>_R
                                      ->_R Data.Semigroup.N:First[0]
                                               (Sym (GHC.Generics.N:K1[0]
                                                         <*>_N
                                                         <R>_P
                                                         <a_afwM8>_R
                                                         <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                            <*>_N
                                                                            <S>_P
                                                                            <'MetaSel
                                                                               ('Just "getFirst")
                                                                               'NoSourceUnpackedness
                                                                               'NoSourceStrictness
                                                                               'DecidedLazy>_P
                                                                            <K1
                                                                               R
                                                                               a_afwM8>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                       <*>_N
                                                                                                       <C>_P
                                                                                                       <'MetaCons
                                                                                                          "First"
                                                                                                          'PrefixI
                                                                                                          'True>_P
                                                                                                       <M1
                                                                                                          S
                                                                                                          ('MetaSel
                                                                                                             ('Just
                                                                                                                "getFirst")
                                                                                                             'NoSourceUnpackedness
                                                                                                             'NoSourceStrictness
                                                                                                             'DecidedLazy)
                                                                                                          (K1
                                                                                                             R
                                                                                                             a_afwM8)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                      <*>_N
                                                                                                                                      <D>_P
                                                                                                                                      <'MetaData
                                                                                                                                         "First"
                                                                                                                                         "Data.Semigroup"
                                                                                                                                         "base"
                                                                                                                                         'True>_P
                                                                                                                                      <M1
                                                                                                                                         C
                                                                                                                                         ('MetaCons
                                                                                                                                            "First"
                                                                                                                                            'PrefixI
                                                                                                                                            'True)
                                                                                                                                         (M1
                                                                                                                                            S
                                                                                                                                            ('MetaSel
                                                                                                                                               ('Just
                                                                                                                                                  "getFirst")
                                                                                                                                               'NoSourceUnpackedness
                                                                                                                                               'NoSourceStrictness
                                                                                                                                               'DecidedLazy)
                                                                                                                                            (K1
                                                                                                                                               R
                                                                                                                                               a_afwM8))>_R) ; Sub (Sym (Data.Semigroup.Rep_First[0]
                                                                                                                                                                             <a_afwM8>_N))))) <x>_N)
                                      :: (forall x. First a_afwM8 -> First a_afwM8 :: *)
                                         ~R# (forall x.
                                              First a_afwM8 -> Rep (First a_afwM8) x :: *))
                              (Data.Semigroup.$fGenericFirst1 @ a_afwM8)
                              `cast` (forall (x :: <*>_N).
                                      <Rep (First a_afwM8) x>_R
                                      ->_R Sym (Data.Semigroup.N:First[0]
                                                    (Sym (GHC.Generics.N:K1[0]
                                                              <*>_N
                                                              <R>_P
                                                              <a_afwM8>_R
                                                              <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                 <*>_N
                                                                                 <S>_P
                                                                                 <'MetaSel
                                                                                    ('Just
                                                                                       "getFirst")
                                                                                    'NoSourceUnpackedness
                                                                                    'NoSourceStrictness
                                                                                    'DecidedLazy>_P
                                                                                 <K1
                                                                                    R
                                                                                    a_afwM8>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                            <*>_N
                                                                                                            <C>_P
                                                                                                            <'MetaCons
                                                                                                               "First"
                                                                                                               'PrefixI
                                                                                                               'True>_P
                                                                                                            <M1
                                                                                                               S
                                                                                                               ('MetaSel
                                                                                                                  ('Just
                                                                                                                     "getFirst")
                                                                                                                  'NoSourceUnpackedness
                                                                                                                  'NoSourceStrictness
                                                                                                                  'DecidedLazy)
                                                                                                               (K1
                                                                                                                  R
                                                                                                                  a_afwM8)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                           <*>_N
                                                                                                                                           <D>_P
                                                                                                                                           <'MetaData
                                                                                                                                              "First"
                                                                                                                                              "Data.Semigroup"
                                                                                                                                              "base"
                                                                                                                                              'True>_P
                                                                                                                                           <M1
                                                                                                                                              C
                                                                                                                                              ('MetaCons
                                                                                                                                                 "First"
                                                                                                                                                 'PrefixI
                                                                                                                                                 'True)
                                                                                                                                              (M1
                                                                                                                                                 S
                                                                                                                                                 ('MetaSel
                                                                                                                                                    ('Just
                                                                                                                                                       "getFirst")
                                                                                                                                                    'NoSourceUnpackedness
                                                                                                                                                    'NoSourceStrictness
                                                                                                                                                    'DecidedLazy)
                                                                                                                                                 (K1
                                                                                                                                                    R
                                                                                                                                                    a_afwM8))>_R) ; Sub (Sym (Data.Semigroup.Rep_First[0]
                                                                                                                                                                                  <a_afwM8>_N))))) <x>_N))
                                      :: (forall x.
                                          Rep (First a_afwM8) x -> Rep (First a_afwM8) x :: *)
                                         ~R# (forall x.
                                              Rep (First a_afwM8) x -> First a_afwM8 :: *))]
Data.Semigroup.$fGenericFirst
  = \ (@ a_Xfyo3) ->
      GHC.Generics.C:Generic
        @ (First a_Xfyo3)
        ((Data.Semigroup.$fGenericFirst2 @ a_Xfyo3)
         `cast` (forall (x :: <*>_N).
                 <First a_Xfyo3>_R
                 ->_R Data.Semigroup.N:First[0]
                          (Sym (GHC.Generics.N:K1[0]
                                    <*>_N <R>_P <a_Xfyo3>_R <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                               <*>_N
                                                                               <S>_P
                                                                               <'MetaSel
                                                                                  ('Just "getFirst")
                                                                                  'NoSourceUnpackedness
                                                                                  'NoSourceStrictness
                                                                                  'DecidedLazy>_P
                                                                               <K1
                                                                                  R
                                                                                  a_Xfyo3>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                          <*>_N
                                                                                                          <C>_P
                                                                                                          <'MetaCons
                                                                                                             "First"
                                                                                                             'PrefixI
                                                                                                             'True>_P
                                                                                                          <M1
                                                                                                             S
                                                                                                             ('MetaSel
                                                                                                                ('Just
                                                                                                                   "getFirst")
                                                                                                                'NoSourceUnpackedness
                                                                                                                'NoSourceStrictness
                                                                                                                'DecidedLazy)
                                                                                                             (K1
                                                                                                                R
                                                                                                                a_Xfyo3)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                         <*>_N
                                                                                                                                         <D>_P
                                                                                                                                         <'MetaData
                                                                                                                                            "First"
                                                                                                                                            "Data.Semigroup"
                                                                                                                                            "base"
                                                                                                                                            'True>_P
                                                                                                                                         <M1
                                                                                                                                            C
                                                                                                                                            ('MetaCons
                                                                                                                                               "First"
                                                                                                                                               'PrefixI
                                                                                                                                               'True)
                                                                                                                                            (M1
                                                                                                                                               S
                                                                                                                                               ('MetaSel
                                                                                                                                                  ('Just
                                                                                                                                                     "getFirst")
                                                                                                                                                  'NoSourceUnpackedness
                                                                                                                                                  'NoSourceStrictness
                                                                                                                                                  'DecidedLazy)
                                                                                                                                               (K1
                                                                                                                                                  R
                                                                                                                                                  a_Xfyo3))>_R) ; Sub (Sym (Data.Semigroup.Rep_First[0]
                                                                                                                                                                                <a_Xfyo3>_N))))) <x>_N)
                 :: (forall x. First a_Xfyo3 -> First a_Xfyo3 :: *)
                    ~R# (forall x. First a_Xfyo3 -> Rep (First a_Xfyo3) x :: *)))
        ((Data.Semigroup.$fGenericFirst1 @ a_Xfyo3)
         `cast` (forall (x :: <*>_N).
                 <Rep (First a_Xfyo3) x>_R
                 ->_R Sym (Data.Semigroup.N:First[0]
                               (Sym (GHC.Generics.N:K1[0]
                                         <*>_N <R>_P <a_Xfyo3>_R <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                    <*>_N
                                                                                    <S>_P
                                                                                    <'MetaSel
                                                                                       ('Just
                                                                                          "getFirst")
                                                                                       'NoSourceUnpackedness
                                                                                       'NoSourceStrictness
                                                                                       'DecidedLazy>_P
                                                                                    <K1
                                                                                       R
                                                                                       a_Xfyo3>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                               <*>_N
                                                                                                               <C>_P
                                                                                                               <'MetaCons
                                                                                                                  "First"
                                                                                                                  'PrefixI
                                                                                                                  'True>_P
                                                                                                               <M1
                                                                                                                  S
                                                                                                                  ('MetaSel
                                                                                                                     ('Just
                                                                                                                        "getFirst")
                                                                                                                     'NoSourceUnpackedness
                                                                                                                     'NoSourceStrictness
                                                                                                                     'DecidedLazy)
                                                                                                                  (K1
                                                                                                                     R
                                                                                                                     a_Xfyo3)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                              <*>_N
                                                                                                                                              <D>_P
                                                                                                                                              <'MetaData
                                                                                                                                                 "First"
                                                                                                                                                 "Data.Semigroup"
                                                                                                                                                 "base"
                                                                                                                                                 'True>_P
                                                                                                                                              <M1
                                                                                                                                                 C
                                                                                                                                                 ('MetaCons
                                                                                                                                                    "First"
                                                                                                                                                    'PrefixI
                                                                                                                                                    'True)
                                                                                                                                                 (M1
                                                                                                                                                    S
                                                                                                                                                    ('MetaSel
                                                                                                                                                       ('Just
                                                                                                                                                          "getFirst")
                                                                                                                                                       'NoSourceUnpackedness
                                                                                                                                                       'NoSourceStrictness
                                                                                                                                                       'DecidedLazy)
                                                                                                                                                    (K1
                                                                                                                                                       R
                                                                                                                                                       a_Xfyo3))>_R) ; Sub (Sym (Data.Semigroup.Rep_First[0]
                                                                                                                                                                                     <a_Xfyo3>_N))))) <x>_N))
                 :: (forall x. Rep (First a_Xfyo3) x -> Rep (First a_Xfyo3) x :: *)
                    ~R# (forall x. Rep (First a_Xfyo3) x -> First a_Xfyo3 :: *)))

-- RHS size: {terms: 11, types: 34, coercions: 7, joins: 0/0}
Data.Semigroup.$fDataFirst_$cgfoldl
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> First a -> c (First a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afxY7)
                 ($dData_afxY8 [Occ=Once] :: Data a_afxY7)
                 (@ (c_afxYg :: * -> *))
                 (k_afxq5 [Occ=Once!]
                    :: forall d b. Data d => c_afxYg (d -> b) -> d -> c_afxYg b)
                 (z_afxq6 [Occ=Once!] :: forall g. g -> c_afxYg g)
                 (ds_dfzBw [Occ=Once] :: First a_afxY7) ->
                 k_afxq5
                   @ a_afxY7
                   @ (First a_afxY7)
                   $dData_afxY8
                   (z_afxq6
                      @ (a_afxY7 -> First a_afxY7)
                      ((Data.Semigroup.$fApplicativeFirst3 @ a_afxY7)
                       `cast` (<a_afxY7>_R
                               ->_R Sym (Data.Semigroup.N:First[0] <a_afxY7>_R)
                               :: (a_afxY7 -> a_afxY7 :: *) ~R# (a_afxY7 -> First a_afxY7 :: *))))
                   (ds_dfzBw
                    `cast` (Data.Semigroup.N:First[0] <a_afxY7>_R
                            :: (First a_afxY7 :: *) ~R# (a_afxY7 :: *)))}]
Data.Semigroup.$fDataFirst_$cgfoldl
  = \ (@ a_afxY7)
      ($dData_afxY8 :: Data a_afxY7)
      (@ (c_afxYg :: * -> *))
      (k_afxq5
         :: forall d b. Data d => c_afxYg (d -> b) -> d -> c_afxYg b)
      (z_afxq6 :: forall g. g -> c_afxYg g)
      (ds_dfzBw :: First a_afxY7) ->
      k_afxq5
        @ a_afxY7
        @ (First a_afxY7)
        $dData_afxY8
        (z_afxq6
           @ (a_afxY7 -> First a_afxY7)
           ((Data.Semigroup.$fApplicativeFirst3 @ a_afxY7)
            `cast` (<a_afxY7>_R
                    ->_R Sym (Data.Semigroup.N:First[0] <a_afxY7>_R)
                    :: (a_afxY7 -> a_afxY7 :: *) ~R# (a_afxY7 -> First a_afxY7 :: *))))
        (ds_dfzBw
         `cast` (Data.Semigroup.N:First[0] <a_afxY7>_R
                 :: (First a_afxY7 :: *) ~R# (a_afxY7 :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataFirst4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Semigroup.$fDataFirst4 = "First"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataFirst7 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fDataFirst7
  = GHC.CString.unpackCString# Data.Semigroup.$fDataFirst4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadFirst_lexeme1 :: Text.Read.Lex.Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fReadFirst_lexeme1
  = Text.Read.Lex.Ident Data.Semigroup.$fDataFirst7

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadFirst6 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Semigroup.$fReadFirst6 = "getFirst"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadFirst5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fReadFirst5
  = GHC.CString.unpackCString# Data.Semigroup.$fReadFirst6

-- RHS size: {terms: 51, types: 60, coercions: 23, joins: 0/2}
Data.Semigroup.$fReadFirst1
  :: forall a.
     Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (First a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,1*C1(U),A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30] 391 60}]
Data.Semigroup.$fReadFirst1
  = \ (@ a_afxXi) ($dRead_afxXj :: Read a_afxXi) ->
      GHC.Read.list3
        @ (First a_afxXi)
        (let {
           lvl33_sfAmA :: Text.ParserCombinators.ReadP.ReadP a_afxXi
           [LclId]
           lvl33_sfAmA
             = ((GHC.Read.readPrec @ a_afxXi $dRead_afxXj)
                `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <a_afxXi>_R
                        :: (Text.ParserCombinators.ReadPrec.ReadPrec a_afxXi :: *)
                           ~R# (Text.ParserCombinators.ReadPrec.Prec
                                -> Text.ParserCombinators.ReadP.ReadP a_afxXi :: *)))
                 Text.ParserCombinators.ReadPrec.minPrec } in
         let {
           ds_sfAgI [Dmd=<L,C(C1(U))>]
             :: Text.ParserCombinators.ReadPrec.Prec
                -> Text.ParserCombinators.ReadP.ReadP a_afxXi
           [LclId,
            Arity=1,
            Str=<L,A>,
            Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                    WorkFree=True, Expandable=True,
                    Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
                    Tmpl= \ _ [Occ=Dead] -> lvl33_sfAmA}]
           ds_sfAgI = \ _ [Occ=Dead] -> lvl33_sfAmA } in
         (\ (c_i88VW :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b_i815E)
            (eta_XjA
               :: First a_afxXi -> Text.ParserCombinators.ReadP.P b_i815E) ->
            case c_i88VW of { GHC.Types.I# x_i88VZ ->
            case GHC.Prim.<=# x_i88VZ 11# of {
              __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b_i815E;
              1# ->
                case Text.Read.Lex.$wexpect
                       Data.Semigroup.$fReadFirst_lexeme1
                       @ b_i815E
                       (\ _ [Occ=Dead, OS=OneShot] ->
                          case Text.Read.Lex.$wexpect
                                 Data.Semigroup.$fReadFirst_lexeme
                                 @ b_i815E
                                 (\ _ [Occ=Dead, OS=OneShot] ->
                                    ((((GHC.Read.readField
                                          @ a_afxXi
                                          Data.Semigroup.$fReadFirst5
                                          (ds_sfAgI
                                           `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                            <a_afxXi>_R)
                                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                                       -> Text.ParserCombinators.ReadP.ReadP
                                                            a_afxXi :: *)
                                                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                                             a_afxXi :: *))))
                                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                   <a_afxXi>_R
                                               :: (Text.ParserCombinators.ReadPrec.ReadPrec
                                                     a_afxXi :: *)
                                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                       -> Text.ParserCombinators.ReadP.ReadP
                                                            a_afxXi :: *)))
                                        Data.Semigroup.$fReadArg2)
                                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_afxXi>_R
                                             :: (Text.ParserCombinators.ReadP.ReadP a_afxXi :: *)
                                                ~R# (forall b.
                                                     (a_afxXi -> Text.ParserCombinators.ReadP.P b)
                                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                                      @ b_i815E
                                      (\ (a3_i88WJ :: a_afxXi) ->
                                         case Text.Read.Lex.$wexpect
                                                Data.Semigroup.$fReadFirst2
                                                @ b_i815E
                                                (\ _ [Occ=Dead, OS=OneShot] ->
                                                   eta_XjA
                                                     (a3_i88WJ
                                                      `cast` (Sym (Data.Semigroup.N:First[0]
                                                                       <a_afxXi>_R)
                                                              :: (a_afxXi :: *)
                                                                 ~R# (First a_afxXi :: *))))
                                         of
                                         { (# ww1_i88Ww #) ->
                                         Text.ParserCombinators.ReadP.Look @ b_i815E ww1_i88Ww
                                         }))
                          of
                          { (# ww1_i88Ww #) ->
                          Text.ParserCombinators.ReadP.Look @ b_i815E ww1_i88Ww
                          })
                of
                { (# ww1_i88Ww #) ->
                Text.ParserCombinators.ReadP.Look @ b_i815E ww1_i88Ww
                }
            }
            })
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <First
                                   a_afxXi>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <First a_afxXi>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (First a_afxXi -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (First a_afxXi) :: *)))

-- RHS size: {terms: 10, types: 21, coercions: 0, joins: 0/1}
Data.Semigroup.$fReadFirst_$creadsPrec
  :: forall a. Read a => Int -> ReadS (First a)
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,1*C1(U),A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 90 60}]
Data.Semigroup.$fReadFirst_$creadsPrec
  = \ (@ a_Xfyka) ($dRead_Xfykc :: Read a_Xfyka) ->
      let {
        ds_sfAgA [Dmd=<L,C(C1(U))>]
          :: Text.ParserCombinators.ReadPrec.Prec
             -> forall b.
                (First a_Xfyka -> Text.ParserCombinators.ReadP.P b)
                -> Text.ParserCombinators.ReadP.P b
        [LclId]
        ds_sfAgA = Data.Semigroup.$fReadFirst1 @ a_Xfyka $dRead_Xfykc } in
      \ (n_i8156 :: Int) ->
        Text.ParserCombinators.ReadP.run
          @ (First a_Xfyka)
          (ds_sfAgA
             n_i8156
             @ (First a_Xfyka)
             (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                @ (First a_Xfyka)))

-- RHS size: {terms: 5, types: 7, coercions: 11, joins: 0/0}
Data.Semigroup.$fReadFirst_$creadListPrec
  :: forall a.
     Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [First a]
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,1*C1(U),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xfyk8) ($dRead_Xfyka [Occ=Once] :: Read a_Xfyk8) ->
                 GHC.Read.list
                   @ (First a_Xfyk8)
                   ((Data.Semigroup.$fReadFirst1 @ a_Xfyk8 $dRead_Xfyka)
                    `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <First
                                              a_Xfyk8>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <First a_Xfyk8>_R)
                            :: (Text.ParserCombinators.ReadPrec.Prec
                                -> forall b.
                                   (First a_Xfyk8 -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)
                               ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                      (First a_Xfyk8) :: *)))}]
Data.Semigroup.$fReadFirst_$creadListPrec
  = \ (@ a_Xfyk8) ($dRead_Xfyka :: Read a_Xfyk8) ->
      GHC.Read.list
        @ (First a_Xfyk8)
        ((Data.Semigroup.$fReadFirst1 @ a_Xfyk8 $dRead_Xfyka)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <First
                                   a_Xfyk8>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <First a_Xfyk8>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (First a_Xfyk8 -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (First a_Xfyk8) :: *)))

-- RHS size: {terms: 8, types: 16, coercions: 19, joins: 0/0}
Data.Semigroup.$fReadFirst_$creadList
  :: forall a. Read a => ReadS [First a]
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,1*C1(U),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xfyk9) ($dRead_Xfykb [Occ=Once] :: Read a_Xfyk9) ->
                 Text.ParserCombinators.ReadP.run
                   @ [First a_Xfyk9]
                   (((((GHC.Read.list
                          @ (First a_Xfyk9)
                          ((Data.Semigroup.$fReadFirst1 @ a_Xfyk9 $dRead_Xfykb)
                           `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                  <First
                                                     a_Xfyk9>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                             <First a_Xfyk9>_R)
                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                       -> forall b.
                                          (First a_Xfyk9 -> Text.ParserCombinators.ReadP.P b)
                                          -> Text.ParserCombinators.ReadP.P b :: *)
                                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                             (First a_Xfyk9) :: *))))
                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                   <[First a_Xfyk9]>_R
                               :: (Text.ParserCombinators.ReadPrec.ReadPrec [First a_Xfyk9] :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                       -> Text.ParserCombinators.ReadP.ReadP [First a_Xfyk9] :: *)))
                        GHC.Read.$fRead()7)
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[First a_Xfyk9]>_R
                             :: (Text.ParserCombinators.ReadP.ReadP [First a_Xfyk9] :: *)
                                ~R# (forall b.
                                     ([First a_Xfyk9] -> Text.ParserCombinators.ReadP.P b)
                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                      @ [First a_Xfyk9]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [First a_Xfyk9]))}]
Data.Semigroup.$fReadFirst_$creadList
  = \ (@ a_Xfyk9) ($dRead_Xfykb :: Read a_Xfyk9) ->
      Text.ParserCombinators.ReadP.run
        @ [First a_Xfyk9]
        (((((GHC.Read.list
               @ (First a_Xfyk9)
               ((Data.Semigroup.$fReadFirst1 @ a_Xfyk9 $dRead_Xfykb)
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <First
                                          a_Xfyk9>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <First a_Xfyk9>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               (First a_Xfyk9 -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                  (First a_Xfyk9) :: *))))
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[First a_Xfyk9]>_R
                    :: (Text.ParserCombinators.ReadPrec.ReadPrec [First a_Xfyk9] :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.Prec
                            -> Text.ParserCombinators.ReadP.ReadP [First a_Xfyk9] :: *)))
             GHC.Read.$fRead()7)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[First a_Xfyk9]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP [First a_Xfyk9] :: *)
                     ~R# (forall b.
                          ([First a_Xfyk9] -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [First a_Xfyk9]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ [First a_Xfyk9]))

-- RHS size: {terms: 11, types: 10, coercions: 11, joins: 0/0}
Data.Semigroup.$fReadFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Read a => Read (First a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,A,C(U),A)>m,
 Unf=DFun: \ (@ a_afwM8) (v_XmR :: Read a_afwM8) ->
       GHC.Read.C:Read TYPE: First a_afwM8
                       Data.Semigroup.$fReadFirst_$creadsPrec @ a_afwM8 v_XmR
                       Data.Semigroup.$fReadFirst_$creadList @ a_afwM8 v_XmR
                       (Data.Semigroup.$fReadFirst1 @ a_afwM8 v_XmR)
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <First
                                                 a_afwM8>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                         <First a_afwM8>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (First a_afwM8 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                         (First a_afwM8) :: *))
                       Data.Semigroup.$fReadFirst_$creadListPrec @ a_afwM8 v_XmR]
Data.Semigroup.$fReadFirst
  = \ (@ a_Xfyk7) ($dRead_Xfyk9 :: Read a_Xfyk7) ->
      GHC.Read.C:Read
        @ (First a_Xfyk7)
        (Data.Semigroup.$fReadFirst_$creadsPrec @ a_Xfyk7 $dRead_Xfyk9)
        (Data.Semigroup.$fReadFirst_$creadList @ a_Xfyk7 $dRead_Xfyk9)
        ((Data.Semigroup.$fReadFirst1 @ a_Xfyk7 $dRead_Xfyk9)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <First
                                   a_Xfyk7>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <First a_Xfyk7>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (First a_Xfyk7 -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (First a_Xfyk7) :: *)))
        (Data.Semigroup.$fReadFirst_$creadListPrec @ a_Xfyk7 $dRead_Xfyk9)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowFirst2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Semigroup.$fShowFirst2 = "First {"#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowFirst1 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Semigroup.$fShowFirst1 = "getFirst = "#

-- RHS size: {terms: 37, types: 15, coercions: 2, joins: 0/1}
Data.Semigroup.$w$cshowsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => GHC.Prim.Int# -> First a -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 331 120}]
Data.Semigroup.$w$cshowsPrec1
  = \ (@ a_sfBri)
      (w_sfBrj :: Show a_sfBri)
      (ww_sfBro :: GHC.Prim.Int#)
      (w1_sfBrl :: First a_sfBri) ->
      let {
        f_sfAgw [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        f_sfAgw
          = showsPrec
              @ a_sfBri
              w_sfBrj
              Data.Semigroup.$fFoldableOption7
              (w1_sfBrl
               `cast` (Data.Semigroup.N:First[0] <a_sfBri>_R
                       :: (First a_sfBri :: *) ~R# (a_sfBri :: *))) } in
      case GHC.Prim.>=# ww_sfBro 11# of {
        __DEFAULT ->
          \ (x_X7RUu :: String) ->
            GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowFirst2
              (GHC.CString.unpackAppendCString#
                 Data.Semigroup.$fShowFirst1
                 (f_sfAgw
                    (GHC.CString.unpackAppendCString#
                       Data.Semigroup.$fReadFirst4 x_X7RUu)));
        1# ->
          \ (x_i88RR :: String) ->
            GHC.Types.:
              @ Char
              GHC.Show.$fShow(,)4
              (GHC.CString.unpackAppendCString#
                 Data.Semigroup.$fShowFirst2
                 (GHC.CString.unpackAppendCString#
                    Data.Semigroup.$fShowFirst1
                    (f_sfAgw
                       (GHC.CString.unpackAppendCString#
                          Data.Semigroup.$fReadFirst4
                          (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x_i88RR)))))
      }

-- RHS size: {terms: 11, types: 10, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowFirst_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => Int -> First a -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sfBri)
                 (w_sfBrj [Occ=Once] :: Show a_sfBri)
                 (w1_sfBrk [Occ=Once!] :: Int)
                 (w2_sfBrl [Occ=Once] :: First a_sfBri) ->
                 case w1_sfBrk of { GHC.Types.I# ww1_sfBro [Occ=Once] ->
                 Data.Semigroup.$w$cshowsPrec1 @ a_sfBri w_sfBrj ww1_sfBro w2_sfBrl
                 }}]
Data.Semigroup.$fShowFirst_$cshowsPrec
  = \ (@ a_sfBri)
      (w_sfBrj :: Show a_sfBri)
      (w1_sfBrk :: Int)
      (w2_sfBrl :: First a_sfBri) ->
      case w1_sfBrk of { GHC.Types.I# ww1_sfBro ->
      Data.Semigroup.$w$cshowsPrec1 @ a_sfBri w_sfBrj ww1_sfBro w2_sfBrl
      }

-- RHS size: {terms: 12, types: 7, coercions: 2, joins: 0/0}
Data.Semigroup.$fShowFirst_$cshow
  :: forall a. Show a => First a -> String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 110 0}]
Data.Semigroup.$fShowFirst_$cshow
  = \ (@ a_afxWN)
      ($dShow_afxWO :: Show a_afxWN)
      (x_i7Jay :: First a_afxWN) ->
      GHC.CString.unpackAppendCString#
        Data.Semigroup.$fShowFirst2
        (GHC.CString.unpackAppendCString#
           Data.Semigroup.$fShowFirst1
           (showsPrec
              @ a_afxWN
              $dShow_afxWO
              Data.Semigroup.$fFoldableOption7
              (x_i7Jay
               `cast` (Data.Semigroup.N:First[0] <a_afxWN>_R
                       :: (First a_afxWN :: *) ~R# (a_afxWN :: *)))
              Data.Semigroup.$fReadFirst3))

-- RHS size: {terms: 12, types: 13, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowFirst_$cshowList
  :: forall a. Show a => [First a] -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afxWN)
                 ($dShow_afxWO [Occ=Once] :: Show a_afxWN)
                 (ls_i7JaB [Occ=Once] :: [First a_afxWN])
                 (s_i7JaC [Occ=Once] :: String) ->
                 GHC.Show.showList__
                   @ (First a_afxWN)
                   (Data.Semigroup.$fShowFirst_$cshowsPrec
                      @ a_afxWN $dShow_afxWO Data.Semigroup.$fFoldableOption7)
                   ls_i7JaB
                   s_i7JaC}]
Data.Semigroup.$fShowFirst_$cshowList
  = \ (@ a_afxWN)
      ($dShow_afxWO :: Show a_afxWN)
      (ls_i7JaB :: [First a_afxWN])
      (s_i7JaC :: String) ->
      GHC.Show.showList__
        @ (First a_afxWN)
        (\ (w_sfBrl :: First a_afxWN) ->
           Data.Semigroup.$w$cshowsPrec1 @ a_afxWN $dShow_afxWO 0# w_sfBrl)
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 9, types: 9, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Show a => Show (First a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(C1(C(U))),A,A)>m,
 Unf=DFun: \ (@ a_afwM8) (v_XmW :: Show a_afwM8) ->
       GHC.Show.C:Show TYPE: First a_afwM8
                       Data.Semigroup.$fShowFirst_$cshowsPrec @ a_afwM8 v_XmW
                       Data.Semigroup.$fShowFirst_$cshow @ a_afwM8 v_XmW
                       Data.Semigroup.$fShowFirst_$cshowList @ a_afwM8 v_XmW]
Data.Semigroup.$fShowFirst
  = \ (@ a_afxWN) ($dShow_afxWO :: Show a_afxWN) ->
      GHC.Show.C:Show
        @ (First a_afxWN)
        (Data.Semigroup.$fShowFirst_$cshowsPrec @ a_afxWN $dShow_afxWO)
        (Data.Semigroup.$fShowFirst_$cshow @ a_afxWN $dShow_afxWO)
        (Data.Semigroup.$fShowFirst_$cshowList @ a_afxWN $dShow_afxWO)

-- RHS size: {terms: 7, types: 8, coercions: 18, joins: 0/0}
Data.Semigroup.$fEqFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Eq a => Eq (First a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_afwM8) (v_Xn8 :: Eq a_afwM8) ->
       GHC.Classes.C:Eq TYPE: First a_afwM8
                        (== @ a_afwM8 v_Xn8)
                        `cast` (Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                ->_R Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                ->_R <Bool>_R
                                :: (a_afwM8 -> a_afwM8 -> Bool :: *)
                                   ~R# (First a_afwM8 -> First a_afwM8 -> Bool :: *))
                        (/= @ a_afwM8 v_Xn8)
                        `cast` (Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                ->_R Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                ->_R <Bool>_R
                                :: (a_afwM8 -> a_afwM8 -> Bool :: *)
                                   ~R# (First a_afwM8 -> First a_afwM8 -> Bool :: *))]
Data.Semigroup.$fEqFirst
  = \ (@ a_afxUq) ($dEq_afxUr :: Eq a_afxUq) ->
      GHC.Classes.C:Eq
        @ (First a_afxUq)
        ((== @ a_afxUq $dEq_afxUr)
         `cast` (Sym (Data.Semigroup.N:First[0] <a_afxUq>_R)
                 ->_R Sym (Data.Semigroup.N:First[0] <a_afxUq>_R)
                 ->_R <Bool>_R
                 :: (a_afxUq -> a_afxUq -> Bool :: *)
                    ~R# (First a_afxUq -> First a_afxUq -> Bool :: *)))
        ((/= @ a_afxUq $dEq_afxUr)
         `cast` (Sym (Data.Semigroup.N:First[0] <a_afxUq>_R)
                 ->_R Sym (Data.Semigroup.N:First[0] <a_afxUq>_R)
                 ->_R <Bool>_R
                 :: (a_afxUq -> a_afxUq -> Bool :: *)
                    ~R# (First a_afxUq -> First a_afxUq -> Bool :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Semigroup.$fOrdFirst_$cp1Ord
  :: forall a. Ord a => Eq (First a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afxUY) ($dOrd_afxUZ [Occ=Once] :: Ord a_afxUY) ->
                 Data.Semigroup.$fEqFirst
                   @ a_afxUY (GHC.Classes.$p1Ord @ a_afxUY $dOrd_afxUZ)}]
Data.Semigroup.$fOrdFirst_$cp1Ord
  = \ (@ a_afxUY) ($dOrd_afxUZ :: Ord a_afxUY) ->
      Data.Semigroup.$fEqFirst
        @ a_afxUY (GHC.Classes.$p1Ord @ a_afxUY $dOrd_afxUZ)

-- RHS size: {terms: 19, types: 14, coercions: 67, joins: 0/0}
Data.Semigroup.$fOrdFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Ord a => Ord (First a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=DFun: \ (@ a_afwM8) (v_Xna :: Ord a_afwM8) ->
       GHC.Classes.C:Ord TYPE: First a_afwM8
                         Data.Semigroup.$fOrdFirst_$cp1Ord @ a_afwM8 v_Xna
                         (compare @ a_afwM8 v_Xna)
                         `cast` (Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                 ->_R Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                 ->_R <Ordering>_R
                                 :: (a_afwM8 -> a_afwM8 -> Ordering :: *)
                                    ~R# (First a_afwM8 -> First a_afwM8 -> Ordering :: *))
                         (< @ a_afwM8 v_Xna)
                         `cast` (Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                 ->_R Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                 ->_R <Bool>_R
                                 :: (a_afwM8 -> a_afwM8 -> Bool :: *)
                                    ~R# (First a_afwM8 -> First a_afwM8 -> Bool :: *))
                         (<= @ a_afwM8 v_Xna)
                         `cast` (Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                 ->_R Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                 ->_R <Bool>_R
                                 :: (a_afwM8 -> a_afwM8 -> Bool :: *)
                                    ~R# (First a_afwM8 -> First a_afwM8 -> Bool :: *))
                         (> @ a_afwM8 v_Xna)
                         `cast` (Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                 ->_R Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                 ->_R <Bool>_R
                                 :: (a_afwM8 -> a_afwM8 -> Bool :: *)
                                    ~R# (First a_afwM8 -> First a_afwM8 -> Bool :: *))
                         (>= @ a_afwM8 v_Xna)
                         `cast` (Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                 ->_R Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                 ->_R <Bool>_R
                                 :: (a_afwM8 -> a_afwM8 -> Bool :: *)
                                    ~R# (First a_afwM8 -> First a_afwM8 -> Bool :: *))
                         (max @ a_afwM8 v_Xna)
                         `cast` (Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                 ->_R Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                 ->_R Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                 :: (a_afwM8 -> a_afwM8 -> a_afwM8 :: *)
                                    ~R# (First a_afwM8 -> First a_afwM8 -> First a_afwM8 :: *))
                         (min @ a_afwM8 v_Xna)
                         `cast` (Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                 ->_R Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                 ->_R Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                 :: (a_afwM8 -> a_afwM8 -> a_afwM8 :: *)
                                    ~R# (First a_afwM8 -> First a_afwM8 -> First a_afwM8 :: *))]
Data.Semigroup.$fOrdFirst
  = \ (@ a_afxUY) ($dOrd_afxUZ :: Ord a_afxUY) ->
      GHC.Classes.C:Ord
        @ (First a_afxUY)
        (Data.Semigroup.$fOrdFirst_$cp1Ord @ a_afxUY $dOrd_afxUZ)
        ((compare @ a_afxUY $dOrd_afxUZ)
         `cast` (Sym (Data.Semigroup.N:First[0] <a_afxUY>_R)
                 ->_R Sym (Data.Semigroup.N:First[0] <a_afxUY>_R)
                 ->_R <Ordering>_R
                 :: (a_afxUY -> a_afxUY -> Ordering :: *)
                    ~R# (First a_afxUY -> First a_afxUY -> Ordering :: *)))
        ((< @ a_afxUY $dOrd_afxUZ)
         `cast` (Sym (Data.Semigroup.N:First[0] <a_afxUY>_R)
                 ->_R Sym (Data.Semigroup.N:First[0] <a_afxUY>_R)
                 ->_R <Bool>_R
                 :: (a_afxUY -> a_afxUY -> Bool :: *)
                    ~R# (First a_afxUY -> First a_afxUY -> Bool :: *)))
        ((<= @ a_afxUY $dOrd_afxUZ)
         `cast` (Sym (Data.Semigroup.N:First[0] <a_afxUY>_R)
                 ->_R Sym (Data.Semigroup.N:First[0] <a_afxUY>_R)
                 ->_R <Bool>_R
                 :: (a_afxUY -> a_afxUY -> Bool :: *)
                    ~R# (First a_afxUY -> First a_afxUY -> Bool :: *)))
        ((> @ a_afxUY $dOrd_afxUZ)
         `cast` (Sym (Data.Semigroup.N:First[0] <a_afxUY>_R)
                 ->_R Sym (Data.Semigroup.N:First[0] <a_afxUY>_R)
                 ->_R <Bool>_R
                 :: (a_afxUY -> a_afxUY -> Bool :: *)
                    ~R# (First a_afxUY -> First a_afxUY -> Bool :: *)))
        ((>= @ a_afxUY $dOrd_afxUZ)
         `cast` (Sym (Data.Semigroup.N:First[0] <a_afxUY>_R)
                 ->_R Sym (Data.Semigroup.N:First[0] <a_afxUY>_R)
                 ->_R <Bool>_R
                 :: (a_afxUY -> a_afxUY -> Bool :: *)
                    ~R# (First a_afxUY -> First a_afxUY -> Bool :: *)))
        ((max @ a_afxUY $dOrd_afxUZ)
         `cast` (Sym (Data.Semigroup.N:First[0] <a_afxUY>_R)
                 ->_R Sym (Data.Semigroup.N:First[0] <a_afxUY>_R)
                 ->_R Sym (Data.Semigroup.N:First[0] <a_afxUY>_R)
                 :: (a_afxUY -> a_afxUY -> a_afxUY :: *)
                    ~R# (First a_afxUY -> First a_afxUY -> First a_afxUY :: *)))
        ((min @ a_afxUY $dOrd_afxUZ)
         `cast` (Sym (Data.Semigroup.N:First[0] <a_afxUY>_R)
                 ->_R Sym (Data.Semigroup.N:First[0] <a_afxUY>_R)
                 ->_R Sym (Data.Semigroup.N:First[0] <a_afxUY>_R)
                 :: (a_afxUY -> a_afxUY -> a_afxUY :: *)
                    ~R# (First a_afxUY -> First a_afxUY -> First a_afxUY :: *)))

-- RHS size: {terms: 7, types: 8, coercions: 6, joins: 0/0}
Data.Semigroup.$fBoundedFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Bounded a => Bounded (First a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_afwM8) (v_Xnd :: Bounded a_afwM8) ->
       GHC.Enum.C:Bounded TYPE: First a_afwM8
                          (minBound @ a_afwM8 v_Xnd)
                          `cast` (Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                  :: (a_afwM8 :: *) ~R# (First a_afwM8 :: *))
                          (maxBound @ a_afwM8 v_Xnd)
                          `cast` (Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                  :: (a_afwM8 :: *) ~R# (First a_afwM8 :: *))]
Data.Semigroup.$fBoundedFirst
  = \ (@ a_afxU8) ($dBounded_afxU9 :: Bounded a_afxU8) ->
      GHC.Enum.C:Bounded
        @ (First a_afxU8)
        ((minBound @ a_afxU8 $dBounded_afxU9)
         `cast` (Sym (Data.Semigroup.N:First[0] <a_afxU8>_R)
                 :: (a_afxU8 :: *) ~R# (First a_afxU8 :: *)))
        ((maxBound @ a_afxU8 $dBounded_afxU9)
         `cast` (Sym (Data.Semigroup.N:First[0] <a_afxU8>_R)
                 :: (a_afxU8 :: *) ~R# (First a_afxU8 :: *)))

-- RHS size: {terms: 9, types: 70, coercions: 127, joins: 0/0}
Data.Semigroup.$fGeneric1Arg_$cto1
  :: forall a1 a2. Rep1 (Arg a1) a2 -> Arg a1 a2
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afxSK)
                 (@ a1_afxTq)
                 (ds_dfzBf [Occ=Once] :: Rep1 (Arg a_afxSK) a1_afxTq) ->
                 case ds_dfzBf
                      `cast` ((Sub (Data.Semigroup.Rep1_Arg[0]
                                        <a_afxSK>_N) ; (GHC.Generics.N:M1[0]
                                                            <*>_N
                                                            <D>_P
                                                            <'MetaData
                                                               "Arg"
                                                               "Data.Semigroup"
                                                               "base"
                                                               'False>_P
                                                            <M1
                                                               C
                                                               ('MetaCons "Arg" 'PrefixI 'False)
                                                               (M1
                                                                  S
                                                                  ('MetaSel
                                                                     'Nothing
                                                                     'NoSourceUnpackedness
                                                                     'NoSourceStrictness
                                                                     'DecidedLazy)
                                                                  (K1 R a_afxSK)
                                                                :*: M1
                                                                      S
                                                                      ('MetaSel
                                                                         'Nothing
                                                                         'NoSourceUnpackedness
                                                                         'NoSourceStrictness
                                                                         'DecidedLazy)
                                                                      Par1)>_R ; GHC.Generics.N:M1[0]
                                                                                     <*>_N
                                                                                     <C>_P
                                                                                     <'MetaCons
                                                                                        "Arg"
                                                                                        'PrefixI
                                                                                        'False>_P
                                                                                     <M1
                                                                                        S
                                                                                        ('MetaSel
                                                                                           'Nothing
                                                                                           'NoSourceUnpackedness
                                                                                           'NoSourceStrictness
                                                                                           'DecidedLazy)
                                                                                        (K1
                                                                                           R
                                                                                           a_afxSK)
                                                                                      :*: M1
                                                                                            S
                                                                                            ('MetaSel
                                                                                               'Nothing
                                                                                               'NoSourceUnpackedness
                                                                                               'NoSourceStrictness
                                                                                               'DecidedLazy)
                                                                                            Par1>_R)) <a1_afxTq>_N
                              :: (Rep1 (Arg a_afxSK) a1_afxTq :: *)
                                 ~R# ((:*:)
                                        (M1
                                           S
                                           ('MetaSel
                                              'Nothing
                                              'NoSourceUnpackedness
                                              'NoSourceStrictness
                                              'DecidedLazy)
                                           (K1 R a_afxSK))
                                        (M1
                                           S
                                           ('MetaSel
                                              'Nothing
                                              'NoSourceUnpackedness
                                              'NoSourceStrictness
                                              'DecidedLazy)
                                           Par1)
                                        a1_afxTq :: *))
                 of
                 { :*: ds1_dfzBr [Occ=Once] ds2_dfzBs [Occ=Once] ->
                 Data.Semigroup.Arg
                   @ a_afxSK
                   @ a1_afxTq
                   (ds1_dfzBr
                    `cast` (GHC.Generics.N:M1[0]
                                <*>_N
                                <S>_P
                                <'MetaSel
                                   'Nothing
                                   'NoSourceUnpackedness
                                   'NoSourceStrictness
                                   'DecidedLazy>_P
                                <K1 R a_afxSK>_R <a1_afxTq>_N ; GHC.Generics.N:K1[0]
                                                                    <*>_N
                                                                    <R>_P
                                                                    <a_afxSK>_R
                                                                    <a1_afxTq>_P
                            :: (M1
                                  S
                                  ('MetaSel
                                     'Nothing
                                     'NoSourceUnpackedness
                                     'NoSourceStrictness
                                     'DecidedLazy)
                                  (K1 R a_afxSK)
                                  a1_afxTq :: *)
                               ~R# (a_afxSK :: *)))
                   (ds2_dfzBs
                    `cast` (GHC.Generics.N:M1[0]
                                <*>_N
                                <S>_P
                                <'MetaSel
                                   'Nothing
                                   'NoSourceUnpackedness
                                   'NoSourceStrictness
                                   'DecidedLazy>_P
                                <Par1>_R <a1_afxTq>_N ; GHC.Generics.N:Par1[0] <a1_afxTq>_R
                            :: (M1
                                  S
                                  ('MetaSel
                                     'Nothing
                                     'NoSourceUnpackedness
                                     'NoSourceStrictness
                                     'DecidedLazy)
                                  Par1
                                  a1_afxTq :: *)
                               ~R# (a1_afxTq :: *)))
                 }}]
Data.Semigroup.$fGeneric1Arg_$cto1
  = \ (@ a_afxSK)
      (@ a1_afxTq)
      (ds_dfzBf :: Rep1 (Arg a_afxSK) a1_afxTq) ->
      case ds_dfzBf
           `cast` ((Sub (Data.Semigroup.Rep1_Arg[0]
                             <a_afxSK>_N) ; (GHC.Generics.N:M1[0]
                                                 <*>_N
                                                 <D>_P
                                                 <'MetaData "Arg" "Data.Semigroup" "base" 'False>_P
                                                 <M1
                                                    C
                                                    ('MetaCons "Arg" 'PrefixI 'False)
                                                    (M1
                                                       S
                                                       ('MetaSel
                                                          'Nothing
                                                          'NoSourceUnpackedness
                                                          'NoSourceStrictness
                                                          'DecidedLazy)
                                                       (K1 R a_afxSK)
                                                     :*: M1
                                                           S
                                                           ('MetaSel
                                                              'Nothing
                                                              'NoSourceUnpackedness
                                                              'NoSourceStrictness
                                                              'DecidedLazy)
                                                           Par1)>_R ; GHC.Generics.N:M1[0]
                                                                          <*>_N
                                                                          <C>_P
                                                                          <'MetaCons
                                                                             "Arg"
                                                                             'PrefixI
                                                                             'False>_P
                                                                          <M1
                                                                             S
                                                                             ('MetaSel
                                                                                'Nothing
                                                                                'NoSourceUnpackedness
                                                                                'NoSourceStrictness
                                                                                'DecidedLazy)
                                                                             (K1 R a_afxSK)
                                                                           :*: M1
                                                                                 S
                                                                                 ('MetaSel
                                                                                    'Nothing
                                                                                    'NoSourceUnpackedness
                                                                                    'NoSourceStrictness
                                                                                    'DecidedLazy)
                                                                                 Par1>_R)) <a1_afxTq>_N
                   :: (Rep1 (Arg a_afxSK) a1_afxTq :: *)
                      ~R# ((:*:)
                             (M1
                                S
                                ('MetaSel
                                   'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                                (K1 R a_afxSK))
                             (M1
                                S
                                ('MetaSel
                                   'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                                Par1)
                             a1_afxTq :: *))
      of
      { :*: ds1_dfzBr ds2_dfzBs ->
      Data.Semigroup.Arg
        @ a_afxSK
        @ a1_afxTq
        (ds1_dfzBr
         `cast` (GHC.Generics.N:M1[0]
                     <*>_N
                     <S>_P
                     <'MetaSel
                        'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy>_P
                     <K1 R a_afxSK>_R <a1_afxTq>_N ; GHC.Generics.N:K1[0]
                                                         <*>_N <R>_P <a_afxSK>_R <a1_afxTq>_P
                 :: (M1
                       S
                       ('MetaSel
                          'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                       (K1 R a_afxSK)
                       a1_afxTq :: *)
                    ~R# (a_afxSK :: *)))
        (ds2_dfzBs
         `cast` (GHC.Generics.N:M1[0]
                     <*>_N
                     <S>_P
                     <'MetaSel
                        'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy>_P
                     <Par1>_R <a1_afxTq>_N ; GHC.Generics.N:Par1[0] <a1_afxTq>_R
                 :: (M1
                       S
                       ('MetaSel
                          'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                       Par1
                       a1_afxTq :: *)
                    ~R# (a1_afxTq :: *)))
      }

-- RHS size: {terms: 9, types: 41, coercions: 81, joins: 0/0}
Data.Semigroup.$fGeneric1Arg1
  :: forall a1 a2.
     Arg a1 a2
     -> M1
          C
          ('MetaCons "Arg" 'PrefixI 'False)
          (M1
             S
             ('MetaSel
                'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
             (K1 R a1)
           :*: M1
                 S
                 ('MetaSel
                    'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                 Par1)
          a2
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afxSK)
                 (@ a1_afxSO)
                 (x_afxpW [Occ=Once!] :: Arg a_afxSK a1_afxSO) ->
                 case x_afxpW of { Arg g1_afxpX [Occ=Once] g2_afxpY [Occ=Once] ->
                 (GHC.Generics.:*:
                    @ *
                    @ (M1
                         S
                         ('MetaSel
                            'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                         (K1 R a_afxSK))
                    @ (M1
                         S
                         ('MetaSel
                            'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                         Par1)
                    @ a1_afxSO
                    (g1_afxpX
                     `cast` (Sym (GHC.Generics.N:K1[0]
                                      <*>_N
                                      <R>_P
                                      <a_afxSK>_R
                                      <a1_afxSO>_P) ; Sym (GHC.Generics.N:M1[0]
                                                               <*>_N
                                                               <S>_P
                                                               <'MetaSel
                                                                  'Nothing
                                                                  'NoSourceUnpackedness
                                                                  'NoSourceStrictness
                                                                  'DecidedLazy>_P
                                                               <K1 R a_afxSK>_R) <a1_afxSO>_N
                             :: (a_afxSK :: *)
                                ~R# (M1
                                       S
                                       ('MetaSel
                                          'Nothing
                                          'NoSourceUnpackedness
                                          'NoSourceStrictness
                                          'DecidedLazy)
                                       (K1 R a_afxSK)
                                       a1_afxSO :: *)))
                    (g2_afxpY
                     `cast` (Sym (GHC.Generics.N:Par1[0]
                                      <a1_afxSO>_R) ; Sym (GHC.Generics.N:M1[0]
                                                               <*>_N
                                                               <S>_P
                                                               <'MetaSel
                                                                  'Nothing
                                                                  'NoSourceUnpackedness
                                                                  'NoSourceStrictness
                                                                  'DecidedLazy>_P
                                                               <Par1>_R) <a1_afxSO>_N
                             :: (a1_afxSO :: *)
                                ~R# (M1
                                       S
                                       ('MetaSel
                                          'Nothing
                                          'NoSourceUnpackedness
                                          'NoSourceStrictness
                                          'DecidedLazy)
                                       Par1
                                       a1_afxSO :: *))))
                 `cast` (Sym (GHC.Generics.N:M1[0]
                                  <*>_N
                                  <C>_P
                                  <'MetaCons "Arg" 'PrefixI 'False>_P
                                  <M1
                                     S
                                     ('MetaSel
                                        'Nothing
                                        'NoSourceUnpackedness
                                        'NoSourceStrictness
                                        'DecidedLazy)
                                     (K1 R a_afxSK)
                                   :*: M1
                                         S
                                         ('MetaSel
                                            'Nothing
                                            'NoSourceUnpackedness
                                            'NoSourceStrictness
                                            'DecidedLazy)
                                         Par1>_R) <a1_afxSO>_N
                         :: ((:*:)
                               (M1
                                  S
                                  ('MetaSel
                                     'Nothing
                                     'NoSourceUnpackedness
                                     'NoSourceStrictness
                                     'DecidedLazy)
                                  (K1 R a_afxSK))
                               (M1
                                  S
                                  ('MetaSel
                                     'Nothing
                                     'NoSourceUnpackedness
                                     'NoSourceStrictness
                                     'DecidedLazy)
                                  Par1)
                               a1_afxSO :: *)
                            ~R# (M1
                                   C
                                   ('MetaCons "Arg" 'PrefixI 'False)
                                   (M1
                                      S
                                      ('MetaSel
                                         'Nothing
                                         'NoSourceUnpackedness
                                         'NoSourceStrictness
                                         'DecidedLazy)
                                      (K1 R a_afxSK)
                                    :*: M1
                                          S
                                          ('MetaSel
                                             'Nothing
                                             'NoSourceUnpackedness
                                             'NoSourceStrictness
                                             'DecidedLazy)
                                          Par1)
                                   a1_afxSO :: *))
                 }}]
Data.Semigroup.$fGeneric1Arg1
  = \ (@ a_afxSK) (@ a1_afxSO) (x_afxpW :: Arg a_afxSK a1_afxSO) ->
      case x_afxpW of { Arg g1_afxpX g2_afxpY ->
      (GHC.Generics.:*:
         @ *
         @ (M1
              S
              ('MetaSel
                 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
              (K1 R a_afxSK))
         @ (M1
              S
              ('MetaSel
                 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
              Par1)
         @ a1_afxSO
         (g1_afxpX
          `cast` (Sym (GHC.Generics.N:K1[0]
                           <*>_N <R>_P <a_afxSK>_R <a1_afxSO>_P) ; Sym (GHC.Generics.N:M1[0]
                                                                            <*>_N
                                                                            <S>_P
                                                                            <'MetaSel
                                                                               'Nothing
                                                                               'NoSourceUnpackedness
                                                                               'NoSourceStrictness
                                                                               'DecidedLazy>_P
                                                                            <K1
                                                                               R
                                                                               a_afxSK>_R) <a1_afxSO>_N
                  :: (a_afxSK :: *)
                     ~R# (M1
                            S
                            ('MetaSel
                               'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                            (K1 R a_afxSK)
                            a1_afxSO :: *)))
         (g2_afxpY
          `cast` (Sym (GHC.Generics.N:Par1[0]
                           <a1_afxSO>_R) ; Sym (GHC.Generics.N:M1[0]
                                                    <*>_N
                                                    <S>_P
                                                    <'MetaSel
                                                       'Nothing
                                                       'NoSourceUnpackedness
                                                       'NoSourceStrictness
                                                       'DecidedLazy>_P
                                                    <Par1>_R) <a1_afxSO>_N
                  :: (a1_afxSO :: *)
                     ~R# (M1
                            S
                            ('MetaSel
                               'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                            Par1
                            a1_afxSO :: *))))
      `cast` (Sym (GHC.Generics.N:M1[0]
                       <*>_N
                       <C>_P
                       <'MetaCons "Arg" 'PrefixI 'False>_P
                       <M1
                          S
                          ('MetaSel
                             'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                          (K1 R a_afxSK)
                        :*: M1
                              S
                              ('MetaSel
                                 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                              Par1>_R) <a1_afxSO>_N
              :: ((:*:)
                    (M1
                       S
                       ('MetaSel
                          'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                       (K1 R a_afxSK))
                    (M1
                       S
                       ('MetaSel
                          'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                       Par1)
                    a1_afxSO :: *)
                 ~R# (M1
                        C
                        ('MetaCons "Arg" 'PrefixI 'False)
                        (M1
                           S
                           ('MetaSel
                              'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                           (K1 R a_afxSK)
                         :*: M1
                               S
                               ('MetaSel
                                  'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                               Par1)
                        a1_afxSO :: *))
      }

-- RHS size: {terms: 4, types: 8, coercions: 60, joins: 0/0}
Data.Semigroup.$fGeneric1Arg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Generic1 (Arg a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_afwMd) ->
       GHC.Generics.C:Generic1 TYPE: *
                               TYPE: Arg a_afwMd
                               (Data.Semigroup.$fGeneric1Arg1 @ a_afwMd)
                               `cast` (forall (a1 :: <*>_N).
                                       <Arg a_afwMd a1>_R
                                       ->_R (Sym (GHC.Generics.N:M1[0]
                                                      <*>_N
                                                      <D>_P
                                                      <'MetaData
                                                         "Arg" "Data.Semigroup" "base" 'False>_P
                                                      <M1
                                                         C
                                                         ('MetaCons "Arg" 'PrefixI 'False)
                                                         (M1
                                                            S
                                                            ('MetaSel
                                                               'Nothing
                                                               'NoSourceUnpackedness
                                                               'NoSourceStrictness
                                                               'DecidedLazy)
                                                            (K1 R a_afwMd)
                                                          :*: M1
                                                                S
                                                                ('MetaSel
                                                                   'Nothing
                                                                   'NoSourceUnpackedness
                                                                   'NoSourceStrictness
                                                                   'DecidedLazy)
                                                                Par1)>_R) ; Sub (Sym (Data.Semigroup.Rep1_Arg[0]
                                                                                          <a_afwMd>_N))) <a1>_N
                                       :: (forall a1.
                                           Arg a_afwMd a1
                                           -> M1
                                                C
                                                ('MetaCons "Arg" 'PrefixI 'False)
                                                (M1
                                                   S
                                                   ('MetaSel
                                                      'Nothing
                                                      'NoSourceUnpackedness
                                                      'NoSourceStrictness
                                                      'DecidedLazy)
                                                   (K1 R a_afwMd)
                                                 :*: M1
                                                       S
                                                       ('MetaSel
                                                          'Nothing
                                                          'NoSourceUnpackedness
                                                          'NoSourceStrictness
                                                          'DecidedLazy)
                                                       Par1)
                                                a1 :: *)
                                          ~R# (forall a1.
                                               Arg a_afwMd a1 -> Rep1 (Arg a_afwMd) a1 :: *))
                               Data.Semigroup.$fGeneric1Arg_$cto1 @ a_afwMd]
Data.Semigroup.$fGeneric1Arg
  = \ (@ a_Xfyg2) ->
      GHC.Generics.C:Generic1
        @ *
        @ (Arg a_Xfyg2)
        ((Data.Semigroup.$fGeneric1Arg1 @ a_Xfyg2)
         `cast` (forall (a1 :: <*>_N).
                 <Arg a_Xfyg2 a1>_R
                 ->_R (Sym (GHC.Generics.N:M1[0]
                                <*>_N
                                <D>_P
                                <'MetaData "Arg" "Data.Semigroup" "base" 'False>_P
                                <M1
                                   C
                                   ('MetaCons "Arg" 'PrefixI 'False)
                                   (M1
                                      S
                                      ('MetaSel
                                         'Nothing
                                         'NoSourceUnpackedness
                                         'NoSourceStrictness
                                         'DecidedLazy)
                                      (K1 R a_Xfyg2)
                                    :*: M1
                                          S
                                          ('MetaSel
                                             'Nothing
                                             'NoSourceUnpackedness
                                             'NoSourceStrictness
                                             'DecidedLazy)
                                          Par1)>_R) ; Sub (Sym (Data.Semigroup.Rep1_Arg[0]
                                                                    <a_Xfyg2>_N))) <a1>_N
                 :: (forall a1.
                     Arg a_Xfyg2 a1
                     -> M1
                          C
                          ('MetaCons "Arg" 'PrefixI 'False)
                          (M1
                             S
                             ('MetaSel
                                'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                             (K1 R a_Xfyg2)
                           :*: M1
                                 S
                                 ('MetaSel
                                    'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                                 Par1)
                          a1 :: *)
                    ~R# (forall a1. Arg a_Xfyg2 a1 -> Rep1 (Arg a_Xfyg2) a1 :: *)))
        (Data.Semigroup.$fGeneric1Arg_$cto1 @ a_Xfyg2)

-- RHS size: {terms: 10, types: 78, coercions: 144, joins: 0/0}
Data.Semigroup.$fGenericArg_$cto
  :: forall a b x. Rep (Arg a b) x -> Arg a b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afxRk)
                 (@ b_afxRl)
                 (@ x_afxS4)
                 (ds_dfzB6 [Occ=Once] :: Rep (Arg a_afxRk b_afxRl) x_afxS4) ->
                 case ds_dfzB6
                      `cast` ((Sub (Data.Semigroup.Rep_Arg[0]
                                        <a_afxRk>_N <b_afxRl>_N) ; (GHC.Generics.N:M1[0]
                                                                        <*>_N
                                                                        <D>_P
                                                                        <'MetaData
                                                                           "Arg"
                                                                           "Data.Semigroup"
                                                                           "base"
                                                                           'False>_P
                                                                        <M1
                                                                           C
                                                                           ('MetaCons
                                                                              "Arg" 'PrefixI 'False)
                                                                           (M1
                                                                              S
                                                                              ('MetaSel
                                                                                 'Nothing
                                                                                 'NoSourceUnpackedness
                                                                                 'NoSourceStrictness
                                                                                 'DecidedLazy)
                                                                              (K1 R a_afxRk)
                                                                            :*: M1
                                                                                  S
                                                                                  ('MetaSel
                                                                                     'Nothing
                                                                                     'NoSourceUnpackedness
                                                                                     'NoSourceStrictness
                                                                                     'DecidedLazy)
                                                                                  (K1
                                                                                     R
                                                                                     b_afxRl))>_R ; GHC.Generics.N:M1[0]
                                                                                                        <*>_N
                                                                                                        <C>_P
                                                                                                        <'MetaCons
                                                                                                           "Arg"
                                                                                                           'PrefixI
                                                                                                           'False>_P
                                                                                                        <M1
                                                                                                           S
                                                                                                           ('MetaSel
                                                                                                              'Nothing
                                                                                                              'NoSourceUnpackedness
                                                                                                              'NoSourceStrictness
                                                                                                              'DecidedLazy)
                                                                                                           (K1
                                                                                                              R
                                                                                                              a_afxRk)
                                                                                                         :*: M1
                                                                                                               S
                                                                                                               ('MetaSel
                                                                                                                  'Nothing
                                                                                                                  'NoSourceUnpackedness
                                                                                                                  'NoSourceStrictness
                                                                                                                  'DecidedLazy)
                                                                                                               (K1
                                                                                                                  R
                                                                                                                  b_afxRl)>_R)) <x_afxS4>_N
                              :: (Rep (Arg a_afxRk b_afxRl) x_afxS4 :: *)
                                 ~R# ((:*:)
                                        (M1
                                           S
                                           ('MetaSel
                                              'Nothing
                                              'NoSourceUnpackedness
                                              'NoSourceStrictness
                                              'DecidedLazy)
                                           (K1 R a_afxRk))
                                        (M1
                                           S
                                           ('MetaSel
                                              'Nothing
                                              'NoSourceUnpackedness
                                              'NoSourceStrictness
                                              'DecidedLazy)
                                           (K1 R b_afxRl))
                                        x_afxS4 :: *))
                 of
                 { :*: ds1_dfzB9 [Occ=Once] ds2_dfzBa [Occ=Once] ->
                 Data.Semigroup.Arg
                   @ a_afxRk
                   @ b_afxRl
                   (ds1_dfzB9
                    `cast` (GHC.Generics.N:M1[0]
                                <*>_N
                                <S>_P
                                <'MetaSel
                                   'Nothing
                                   'NoSourceUnpackedness
                                   'NoSourceStrictness
                                   'DecidedLazy>_P
                                <K1 R a_afxRk>_R <x_afxS4>_N ; GHC.Generics.N:K1[0]
                                                                   <*>_N
                                                                   <R>_P
                                                                   <a_afxRk>_R
                                                                   <x_afxS4>_P
                            :: (M1
                                  S
                                  ('MetaSel
                                     'Nothing
                                     'NoSourceUnpackedness
                                     'NoSourceStrictness
                                     'DecidedLazy)
                                  (K1 R a_afxRk)
                                  x_afxS4 :: *)
                               ~R# (a_afxRk :: *)))
                   (ds2_dfzBa
                    `cast` (GHC.Generics.N:M1[0]
                                <*>_N
                                <S>_P
                                <'MetaSel
                                   'Nothing
                                   'NoSourceUnpackedness
                                   'NoSourceStrictness
                                   'DecidedLazy>_P
                                <K1 R b_afxRl>_R <x_afxS4>_N ; GHC.Generics.N:K1[0]
                                                                   <*>_N
                                                                   <R>_P
                                                                   <b_afxRl>_R
                                                                   <x_afxS4>_P
                            :: (M1
                                  S
                                  ('MetaSel
                                     'Nothing
                                     'NoSourceUnpackedness
                                     'NoSourceStrictness
                                     'DecidedLazy)
                                  (K1 R b_afxRl)
                                  x_afxS4 :: *)
                               ~R# (b_afxRl :: *)))
                 }}]
Data.Semigroup.$fGenericArg_$cto
  = \ (@ a_afxRk)
      (@ b_afxRl)
      (@ x_afxS4)
      (ds_dfzB6 :: Rep (Arg a_afxRk b_afxRl) x_afxS4) ->
      case ds_dfzB6
           `cast` ((Sub (Data.Semigroup.Rep_Arg[0]
                             <a_afxRk>_N <b_afxRl>_N) ; (GHC.Generics.N:M1[0]
                                                             <*>_N
                                                             <D>_P
                                                             <'MetaData
                                                                "Arg"
                                                                "Data.Semigroup"
                                                                "base"
                                                                'False>_P
                                                             <M1
                                                                C
                                                                ('MetaCons "Arg" 'PrefixI 'False)
                                                                (M1
                                                                   S
                                                                   ('MetaSel
                                                                      'Nothing
                                                                      'NoSourceUnpackedness
                                                                      'NoSourceStrictness
                                                                      'DecidedLazy)
                                                                   (K1 R a_afxRk)
                                                                 :*: M1
                                                                       S
                                                                       ('MetaSel
                                                                          'Nothing
                                                                          'NoSourceUnpackedness
                                                                          'NoSourceStrictness
                                                                          'DecidedLazy)
                                                                       (K1
                                                                          R
                                                                          b_afxRl))>_R ; GHC.Generics.N:M1[0]
                                                                                             <*>_N
                                                                                             <C>_P
                                                                                             <'MetaCons
                                                                                                "Arg"
                                                                                                'PrefixI
                                                                                                'False>_P
                                                                                             <M1
                                                                                                S
                                                                                                ('MetaSel
                                                                                                   'Nothing
                                                                                                   'NoSourceUnpackedness
                                                                                                   'NoSourceStrictness
                                                                                                   'DecidedLazy)
                                                                                                (K1
                                                                                                   R
                                                                                                   a_afxRk)
                                                                                              :*: M1
                                                                                                    S
                                                                                                    ('MetaSel
                                                                                                       'Nothing
                                                                                                       'NoSourceUnpackedness
                                                                                                       'NoSourceStrictness
                                                                                                       'DecidedLazy)
                                                                                                    (K1
                                                                                                       R
                                                                                                       b_afxRl)>_R)) <x_afxS4>_N
                   :: (Rep (Arg a_afxRk b_afxRl) x_afxS4 :: *)
                      ~R# ((:*:)
                             (M1
                                S
                                ('MetaSel
                                   'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                                (K1 R a_afxRk))
                             (M1
                                S
                                ('MetaSel
                                   'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                                (K1 R b_afxRl))
                             x_afxS4 :: *))
      of
      { :*: ds1_dfzB9 ds2_dfzBa ->
      Data.Semigroup.Arg
        @ a_afxRk
        @ b_afxRl
        (ds1_dfzB9
         `cast` (GHC.Generics.N:M1[0]
                     <*>_N
                     <S>_P
                     <'MetaSel
                        'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy>_P
                     <K1 R a_afxRk>_R <x_afxS4>_N ; GHC.Generics.N:K1[0]
                                                        <*>_N <R>_P <a_afxRk>_R <x_afxS4>_P
                 :: (M1
                       S
                       ('MetaSel
                          'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                       (K1 R a_afxRk)
                       x_afxS4 :: *)
                    ~R# (a_afxRk :: *)))
        (ds2_dfzBa
         `cast` (GHC.Generics.N:M1[0]
                     <*>_N
                     <S>_P
                     <'MetaSel
                        'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy>_P
                     <K1 R b_afxRl>_R <x_afxS4>_N ; GHC.Generics.N:K1[0]
                                                        <*>_N <R>_P <b_afxRl>_R <x_afxS4>_P
                 :: (M1
                       S
                       ('MetaSel
                          'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                       (K1 R b_afxRl)
                       x_afxS4 :: *)
                    ~R# (b_afxRl :: *)))
      }

-- RHS size: {terms: 10, types: 46, coercions: 93, joins: 0/0}
Data.Semigroup.$fGenericArg1
  :: forall a b x.
     Arg a b
     -> M1
          C
          ('MetaCons "Arg" 'PrefixI 'False)
          (M1
             S
             ('MetaSel
                'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
             (K1 R a)
           :*: M1
                 S
                 ('MetaSel
                    'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                 (K1 R b))
          x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afxRk)
                 (@ b_afxRl)
                 (@ x_afxRp)
                 (x1_afxpQ [Occ=Once!] :: Arg a_afxRk b_afxRl) ->
                 case x1_afxpQ of { Arg g1_afxpR [Occ=Once] g2_afxpS [Occ=Once] ->
                 (GHC.Generics.:*:
                    @ *
                    @ (M1
                         S
                         ('MetaSel
                            'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                         (K1 R a_afxRk))
                    @ (M1
                         S
                         ('MetaSel
                            'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                         (K1 R b_afxRl))
                    @ x_afxRp
                    (g1_afxpR
                     `cast` (Sym (GHC.Generics.N:K1[0]
                                      <*>_N
                                      <R>_P
                                      <a_afxRk>_R
                                      <x_afxRp>_P) ; Sym (GHC.Generics.N:M1[0]
                                                              <*>_N
                                                              <S>_P
                                                              <'MetaSel
                                                                 'Nothing
                                                                 'NoSourceUnpackedness
                                                                 'NoSourceStrictness
                                                                 'DecidedLazy>_P
                                                              <K1 R a_afxRk>_R) <x_afxRp>_N
                             :: (a_afxRk :: *)
                                ~R# (M1
                                       S
                                       ('MetaSel
                                          'Nothing
                                          'NoSourceUnpackedness
                                          'NoSourceStrictness
                                          'DecidedLazy)
                                       (K1 R a_afxRk)
                                       x_afxRp :: *)))
                    (g2_afxpS
                     `cast` (Sym (GHC.Generics.N:K1[0]
                                      <*>_N
                                      <R>_P
                                      <b_afxRl>_R
                                      <x_afxRp>_P) ; Sym (GHC.Generics.N:M1[0]
                                                              <*>_N
                                                              <S>_P
                                                              <'MetaSel
                                                                 'Nothing
                                                                 'NoSourceUnpackedness
                                                                 'NoSourceStrictness
                                                                 'DecidedLazy>_P
                                                              <K1 R b_afxRl>_R) <x_afxRp>_N
                             :: (b_afxRl :: *)
                                ~R# (M1
                                       S
                                       ('MetaSel
                                          'Nothing
                                          'NoSourceUnpackedness
                                          'NoSourceStrictness
                                          'DecidedLazy)
                                       (K1 R b_afxRl)
                                       x_afxRp :: *))))
                 `cast` (Sym (GHC.Generics.N:M1[0]
                                  <*>_N
                                  <C>_P
                                  <'MetaCons "Arg" 'PrefixI 'False>_P
                                  <M1
                                     S
                                     ('MetaSel
                                        'Nothing
                                        'NoSourceUnpackedness
                                        'NoSourceStrictness
                                        'DecidedLazy)
                                     (K1 R a_afxRk)
                                   :*: M1
                                         S
                                         ('MetaSel
                                            'Nothing
                                            'NoSourceUnpackedness
                                            'NoSourceStrictness
                                            'DecidedLazy)
                                         (K1 R b_afxRl)>_R) <x_afxRp>_N
                         :: ((:*:)
                               (M1
                                  S
                                  ('MetaSel
                                     'Nothing
                                     'NoSourceUnpackedness
                                     'NoSourceStrictness
                                     'DecidedLazy)
                                  (K1 R a_afxRk))
                               (M1
                                  S
                                  ('MetaSel
                                     'Nothing
                                     'NoSourceUnpackedness
                                     'NoSourceStrictness
                                     'DecidedLazy)
                                  (K1 R b_afxRl))
                               x_afxRp :: *)
                            ~R# (M1
                                   C
                                   ('MetaCons "Arg" 'PrefixI 'False)
                                   (M1
                                      S
                                      ('MetaSel
                                         'Nothing
                                         'NoSourceUnpackedness
                                         'NoSourceStrictness
                                         'DecidedLazy)
                                      (K1 R a_afxRk)
                                    :*: M1
                                          S
                                          ('MetaSel
                                             'Nothing
                                             'NoSourceUnpackedness
                                             'NoSourceStrictness
                                             'DecidedLazy)
                                          (K1 R b_afxRl))
                                   x_afxRp :: *))
                 }}]
Data.Semigroup.$fGenericArg1
  = \ (@ a_afxRk)
      (@ b_afxRl)
      (@ x_afxRp)
      (x1_afxpQ :: Arg a_afxRk b_afxRl) ->
      case x1_afxpQ of { Arg g1_afxpR g2_afxpS ->
      (GHC.Generics.:*:
         @ *
         @ (M1
              S
              ('MetaSel
                 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
              (K1 R a_afxRk))
         @ (M1
              S
              ('MetaSel
                 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
              (K1 R b_afxRl))
         @ x_afxRp
         (g1_afxpR
          `cast` (Sym (GHC.Generics.N:K1[0]
                           <*>_N <R>_P <a_afxRk>_R <x_afxRp>_P) ; Sym (GHC.Generics.N:M1[0]
                                                                           <*>_N
                                                                           <S>_P
                                                                           <'MetaSel
                                                                              'Nothing
                                                                              'NoSourceUnpackedness
                                                                              'NoSourceStrictness
                                                                              'DecidedLazy>_P
                                                                           <K1
                                                                              R
                                                                              a_afxRk>_R) <x_afxRp>_N
                  :: (a_afxRk :: *)
                     ~R# (M1
                            S
                            ('MetaSel
                               'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                            (K1 R a_afxRk)
                            x_afxRp :: *)))
         (g2_afxpS
          `cast` (Sym (GHC.Generics.N:K1[0]
                           <*>_N <R>_P <b_afxRl>_R <x_afxRp>_P) ; Sym (GHC.Generics.N:M1[0]
                                                                           <*>_N
                                                                           <S>_P
                                                                           <'MetaSel
                                                                              'Nothing
                                                                              'NoSourceUnpackedness
                                                                              'NoSourceStrictness
                                                                              'DecidedLazy>_P
                                                                           <K1
                                                                              R
                                                                              b_afxRl>_R) <x_afxRp>_N
                  :: (b_afxRl :: *)
                     ~R# (M1
                            S
                            ('MetaSel
                               'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                            (K1 R b_afxRl)
                            x_afxRp :: *))))
      `cast` (Sym (GHC.Generics.N:M1[0]
                       <*>_N
                       <C>_P
                       <'MetaCons "Arg" 'PrefixI 'False>_P
                       <M1
                          S
                          ('MetaSel
                             'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                          (K1 R a_afxRk)
                        :*: M1
                              S
                              ('MetaSel
                                 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                              (K1 R b_afxRl)>_R) <x_afxRp>_N
              :: ((:*:)
                    (M1
                       S
                       ('MetaSel
                          'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                       (K1 R a_afxRk))
                    (M1
                       S
                       ('MetaSel
                          'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                       (K1 R b_afxRl))
                    x_afxRp :: *)
                 ~R# (M1
                        C
                        ('MetaCons "Arg" 'PrefixI 'False)
                        (M1
                           S
                           ('MetaSel
                              'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                           (K1 R a_afxRk)
                         :*: M1
                               S
                               ('MetaSel
                                  'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                               (K1 R b_afxRl))
                        x_afxRp :: *))
      }

-- RHS size: {terms: 5, types: 11, coercions: 64, joins: 0/0}
Data.Semigroup.$fGenericArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. Generic (Arg a b)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_afwMd) (@ b_afwMe) ->
       GHC.Generics.C:Generic TYPE: Arg a_afwMd b_afwMe
                              (Data.Semigroup.$fGenericArg1 @ a_afwMd @ b_afwMe)
                              `cast` (forall (x :: <*>_N).
                                      <Arg a_afwMd b_afwMe>_R
                                      ->_R (Sym (GHC.Generics.N:M1[0]
                                                     <*>_N
                                                     <D>_P
                                                     <'MetaData
                                                        "Arg" "Data.Semigroup" "base" 'False>_P
                                                     <M1
                                                        C
                                                        ('MetaCons "Arg" 'PrefixI 'False)
                                                        (M1
                                                           S
                                                           ('MetaSel
                                                              'Nothing
                                                              'NoSourceUnpackedness
                                                              'NoSourceStrictness
                                                              'DecidedLazy)
                                                           (K1 R a_afwMd)
                                                         :*: M1
                                                               S
                                                               ('MetaSel
                                                                  'Nothing
                                                                  'NoSourceUnpackedness
                                                                  'NoSourceStrictness
                                                                  'DecidedLazy)
                                                               (K1
                                                                  R
                                                                  b_afwMe))>_R) ; Sub (Sym (Data.Semigroup.Rep_Arg[0]
                                                                                                <a_afwMd>_N
                                                                                                <b_afwMe>_N))) <x>_N
                                      :: (forall x.
                                          Arg a_afwMd b_afwMe
                                          -> M1
                                               C
                                               ('MetaCons "Arg" 'PrefixI 'False)
                                               (M1
                                                  S
                                                  ('MetaSel
                                                     'Nothing
                                                     'NoSourceUnpackedness
                                                     'NoSourceStrictness
                                                     'DecidedLazy)
                                                  (K1 R a_afwMd)
                                                :*: M1
                                                      S
                                                      ('MetaSel
                                                         'Nothing
                                                         'NoSourceUnpackedness
                                                         'NoSourceStrictness
                                                         'DecidedLazy)
                                                      (K1 R b_afwMe))
                                               x :: *)
                                         ~R# (forall x.
                                              Arg a_afwMd b_afwMe
                                              -> Rep (Arg a_afwMd b_afwMe) x :: *))
                              Data.Semigroup.$fGenericArg_$cto @ a_afwMd @ b_afwMe]
Data.Semigroup.$fGenericArg
  = \ (@ a_XfyeK) (@ b_XfyeM) ->
      GHC.Generics.C:Generic
        @ (Arg a_XfyeK b_XfyeM)
        ((Data.Semigroup.$fGenericArg1 @ a_XfyeK @ b_XfyeM)
         `cast` (forall (x :: <*>_N).
                 <Arg a_XfyeK b_XfyeM>_R
                 ->_R (Sym (GHC.Generics.N:M1[0]
                                <*>_N
                                <D>_P
                                <'MetaData "Arg" "Data.Semigroup" "base" 'False>_P
                                <M1
                                   C
                                   ('MetaCons "Arg" 'PrefixI 'False)
                                   (M1
                                      S
                                      ('MetaSel
                                         'Nothing
                                         'NoSourceUnpackedness
                                         'NoSourceStrictness
                                         'DecidedLazy)
                                      (K1 R a_XfyeK)
                                    :*: M1
                                          S
                                          ('MetaSel
                                             'Nothing
                                             'NoSourceUnpackedness
                                             'NoSourceStrictness
                                             'DecidedLazy)
                                          (K1 R b_XfyeM))>_R) ; Sub (Sym (Data.Semigroup.Rep_Arg[0]
                                                                              <a_XfyeK>_N
                                                                              <b_XfyeM>_N))) <x>_N
                 :: (forall x.
                     Arg a_XfyeK b_XfyeM
                     -> M1
                          C
                          ('MetaCons "Arg" 'PrefixI 'False)
                          (M1
                             S
                             ('MetaSel
                                'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                             (K1 R a_XfyeK)
                           :*: M1
                                 S
                                 ('MetaSel
                                    'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                                 (K1 R b_XfyeM))
                          x :: *)
                    ~R# (forall x.
                         Arg a_XfyeK b_XfyeM -> Rep (Arg a_XfyeK b_XfyeM) x :: *)))
        (Data.Semigroup.$fGenericArg_$cto @ a_XfyeK @ b_XfyeM)

-- RHS size: {terms: 14, types: 45, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataArg_$cgunfold
  :: forall a b.
     (Data a, Data b) =>
     forall (c :: * -> *).
     (forall b1 r. Data b1 => c (b1 -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c (Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(S)),C(C1(U))><L,1*C1(U)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afxNW)
                 (@ b_afxNX)
                 ($dData_afxNY [Occ=Once] :: Data a_afxNW)
                 ($dData1_afxNZ [Occ=Once] :: Data b_afxNX)
                 (@ (c_afxOm :: * -> *))
                 (k_afxpN :: forall b1 r. Data b1 => c_afxOm (b1 -> r) -> c_afxOm r)
                 (z_afxpO [Occ=Once!] :: forall r. r -> c_afxOm r)
                 _ [Occ=Dead] ->
                 k_afxpN
                   @ b_afxNX
                   @ (Arg a_afxNW b_afxNX)
                   $dData1_afxNZ
                   (k_afxpN
                      @ a_afxNW
                      @ (b_afxNX -> Arg a_afxNW b_afxNX)
                      $dData_afxNY
                      (z_afxpO
                         @ (a_afxNW -> b_afxNX -> Arg a_afxNW b_afxNX)
                         (Data.Semigroup.Arg @ a_afxNW @ b_afxNX)))}]
Data.Semigroup.$fDataArg_$cgunfold
  = \ (@ a_afxNW)
      (@ b_afxNX)
      ($dData_afxNY :: Data a_afxNW)
      ($dData1_afxNZ :: Data b_afxNX)
      (@ (c_afxOm :: * -> *))
      (k_afxpN :: forall b1 r. Data b1 => c_afxOm (b1 -> r) -> c_afxOm r)
      (z_afxpO :: forall r. r -> c_afxOm r)
      _ [Occ=Dead] ->
      k_afxpN
        @ b_afxNX
        @ (Arg a_afxNW b_afxNX)
        $dData1_afxNZ
        (k_afxpN
           @ a_afxNW
           @ (b_afxNX -> Arg a_afxNW b_afxNX)
           $dData_afxNY
           (z_afxpO
              @ (a_afxNW -> b_afxNX -> Arg a_afxNW b_afxNX)
              (Data.Semigroup.Arg @ a_afxNW @ b_afxNX)))

-- RHS size: {terms: 19, types: 53, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataArg_$cgfoldl
  :: forall a b.
     (Data a, Data b) =>
     forall (c :: * -> *).
     (forall d b1. Data d => c (d -> b1) -> d -> c b1)
     -> (forall g. g -> c g) -> Arg a b -> c (Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(C(S))),C(C1(C1(U)))><L,1*C1(U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afxNW)
                 (@ b_afxNX)
                 ($dData_afxNY [Occ=Once] :: Data a_afxNW)
                 ($dData1_afxNZ [Occ=Once] :: Data b_afxNX)
                 (@ (c_afxO7 :: * -> *))
                 (k_afxpJ
                    :: forall d b1. Data d => c_afxO7 (d -> b1) -> d -> c_afxO7 b1)
                 (z_afxpK [Occ=Once!] :: forall g. g -> c_afxO7 g)
                 (ds_dfzAL [Occ=Once!] :: Arg a_afxNW b_afxNX) ->
                 case ds_dfzAL of { Arg a1_afxpL [Occ=Once] a2_afxpM [Occ=Once] ->
                 k_afxpJ
                   @ b_afxNX
                   @ (Arg a_afxNW b_afxNX)
                   $dData1_afxNZ
                   (k_afxpJ
                      @ a_afxNW
                      @ (b_afxNX -> Arg a_afxNW b_afxNX)
                      $dData_afxNY
                      (z_afxpK
                         @ (a_afxNW -> b_afxNX -> Arg a_afxNW b_afxNX)
                         (Data.Semigroup.Arg @ a_afxNW @ b_afxNX))
                      a1_afxpL)
                   a2_afxpM
                 }}]
Data.Semigroup.$fDataArg_$cgfoldl
  = \ (@ a_afxNW)
      (@ b_afxNX)
      ($dData_afxNY :: Data a_afxNW)
      ($dData1_afxNZ :: Data b_afxNX)
      (@ (c_afxO7 :: * -> *))
      (k_afxpJ
         :: forall d b1. Data d => c_afxO7 (d -> b1) -> d -> c_afxO7 b1)
      (z_afxpK :: forall g. g -> c_afxO7 g)
      (ds_dfzAL :: Arg a_afxNW b_afxNX) ->
      case ds_dfzAL of { Arg a1_afxpL a2_afxpM ->
      k_afxpJ
        @ b_afxNX
        @ (Arg a_afxNW b_afxNX)
        $dData1_afxNZ
        (k_afxpJ
           @ a_afxNW
           @ (b_afxNX -> Arg a_afxNW b_afxNX)
           $dData_afxNY
           (z_afxpK
              @ (a_afxNW -> b_afxNX -> Arg a_afxNW b_afxNX)
              (Data.Semigroup.Arg @ a_afxNW @ b_afxNX))
           a1_afxpL)
        a2_afxpM
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataArg6 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fDataArg6 = "Arg"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataArg9 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fDataArg9
  = GHC.CString.unpackCString# Data.Semigroup.$fDataArg6

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadArg_lexeme :: Text.Read.Lex.Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fReadArg_lexeme
  = Text.Read.Lex.Ident Data.Semigroup.$fDataArg9

-- RHS size: {terms: 42, types: 51, coercions: 21, joins: 0/0}
Data.Semigroup.$fReadArg1
  :: forall a b.
     (Read a, Read b) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Arg a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 0] 281 0}]
Data.Semigroup.$fReadArg1
  = \ (@ a_afxN6)
      (@ b_afxN7)
      ($dRead_afxN8 :: Read a_afxN6)
      ($dRead1_afxN9 :: Read b_afxN7)
      (eta_B2 :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b1_i815e)
      (eta1_B1
         :: Arg a_afxN6 b_afxN7
            -> Text.ParserCombinators.ReadP.P b1_i815e) ->
      GHC.Read.list3
        @ (Arg a_afxN6 b_afxN7)
        ((\ (c_i88VW :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b2_i815E)
            (eta2_XjO
               :: Arg a_afxN6 b_afxN7
                  -> Text.ParserCombinators.ReadP.P b2_i815E) ->
            case c_i88VW of { GHC.Types.I# x_i88VZ ->
            case GHC.Prim.<=# x_i88VZ 10# of {
              __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b2_i815E;
              1# ->
                case Text.Read.Lex.$wexpect
                       Data.Semigroup.$fReadArg_lexeme
                       @ b2_i815E
                       (\ _ [Occ=Dead, OS=OneShot] ->
                          ((((GHC.Read.readPrec @ a_afxN6 $dRead_afxN8)
                             `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <a_afxN6>_R
                                     :: (Text.ParserCombinators.ReadPrec.ReadPrec a_afxN6 :: *)
                                        ~R# (Text.ParserCombinators.ReadPrec.Prec
                                             -> Text.ParserCombinators.ReadP.ReadP a_afxN6 :: *)))
                              Data.Semigroup.$fReadArg2)
                           `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_afxN6>_R
                                   :: (Text.ParserCombinators.ReadP.ReadP a_afxN6 :: *)
                                      ~R# (forall b.
                                           (a_afxN6 -> Text.ParserCombinators.ReadP.P b)
                                           -> Text.ParserCombinators.ReadP.P b :: *)))
                            @ b2_i815E
                            (\ (a2_i88WJ :: a_afxN6) ->
                               ((((GHC.Read.readPrec @ b_afxN7 $dRead1_afxN9)
                                  `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <b_afxN7>_R
                                          :: (Text.ParserCombinators.ReadPrec.ReadPrec b_afxN7 :: *)
                                             ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                  -> Text.ParserCombinators.ReadP.ReadP
                                                       b_afxN7 :: *)))
                                   Data.Semigroup.$fReadArg2)
                                `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <b_afxN7>_R
                                        :: (Text.ParserCombinators.ReadP.ReadP b_afxN7 :: *)
                                           ~R# (forall b.
                                                (b_afxN7 -> Text.ParserCombinators.ReadP.P b)
                                                -> Text.ParserCombinators.ReadP.P b :: *)))
                                 @ b2_i815E
                                 (\ (a3_X89kM :: b_afxN7) ->
                                    eta2_XjO
                                      (Data.Semigroup.Arg @ a_afxN6 @ b_afxN7 a2_i88WJ a3_X89kM))))
                of
                { (# ww1_i88Ww #) ->
                Text.ParserCombinators.ReadP.Look @ b2_i815E ww1_i88Ww
                }
            }
            })
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Arg
                                   a_afxN6
                                   b_afxN7>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Arg a_afxN6 b_afxN7>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Arg a_afxN6 b_afxN7 -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (Arg a_afxN6 b_afxN7) :: *)))
        eta_B2
        @ b1_i815e
        eta1_B1

-- RHS size: {terms: 11, types: 20, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadArg_$creadsPrec
  :: forall a b. (Read a, Read b) => Int -> ReadS (Arg a b)
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XfyaI)
                 (@ b_XfyaK)
                 ($dRead_XfyaM [Occ=Once] :: Read a_XfyaI)
                 ($dRead1_XfyaO [Occ=Once] :: Read b_XfyaK)
                 (n_i8156 [Occ=Once] :: Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ (Arg a_XfyaI b_XfyaK)
                   (Data.Semigroup.$fReadArg1
                      @ a_XfyaI
                      @ b_XfyaK
                      $dRead_XfyaM
                      $dRead1_XfyaO
                      n_i8156
                      @ (Arg a_XfyaI b_XfyaK)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ (Arg a_XfyaI b_XfyaK)))}]
Data.Semigroup.$fReadArg_$creadsPrec
  = \ (@ a_XfyaI)
      (@ b_XfyaK)
      ($dRead_XfyaM :: Read a_XfyaI)
      ($dRead1_XfyaO :: Read b_XfyaK)
      (n_i8156 :: Int) ->
      Text.ParserCombinators.ReadP.run
        @ (Arg a_XfyaI b_XfyaK)
        (Data.Semigroup.$fReadArg1
           @ a_XfyaI
           @ b_XfyaK
           $dRead_XfyaM
           $dRead1_XfyaO
           n_i8156
           @ (Arg a_XfyaI b_XfyaK)
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ (Arg a_XfyaI b_XfyaK)))

-- RHS size: {terms: 8, types: 13, coercions: 13, joins: 0/0}
Data.Semigroup.$fReadArg_$creadListPrec
  :: forall a b.
     (Read a, Read b) =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Arg a b]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XfyaG)
                 (@ b_XfyaI)
                 ($dRead_XfyaK [Occ=Once] :: Read a_XfyaG)
                 ($dRead1_XfyaM [Occ=Once] :: Read b_XfyaI) ->
                 GHC.Read.list
                   @ (Arg a_XfyaG b_XfyaI)
                   ((Data.Semigroup.$fReadArg1
                       @ a_XfyaG @ b_XfyaI $dRead_XfyaK $dRead1_XfyaM)
                    `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Arg
                                              a_XfyaG
                                              b_XfyaI>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <Arg a_XfyaG b_XfyaI>_R)
                            :: (Text.ParserCombinators.ReadPrec.Prec
                                -> forall b.
                                   (Arg a_XfyaG b_XfyaI -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)
                               ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                      (Arg a_XfyaG b_XfyaI) :: *)))}]
Data.Semigroup.$fReadArg_$creadListPrec
  = \ (@ a_XfyaG)
      (@ b_XfyaI)
      ($dRead_XfyaK :: Read a_XfyaG)
      ($dRead1_XfyaM :: Read b_XfyaI) ->
      GHC.Read.list
        @ (Arg a_XfyaG b_XfyaI)
        ((Data.Semigroup.$fReadArg1
            @ a_XfyaG @ b_XfyaI $dRead_XfyaK $dRead1_XfyaM)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Arg
                                   a_XfyaG
                                   b_XfyaI>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Arg a_XfyaG b_XfyaI>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Arg a_XfyaG b_XfyaI -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (Arg a_XfyaG b_XfyaI) :: *)))

-- RHS size: {terms: 11, types: 25, coercions: 23, joins: 0/0}
Data.Semigroup.$fReadArg_$creadList
  :: forall a b. (Read a, Read b) => ReadS [Arg a b]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XfyaH)
                 (@ b_XfyaJ)
                 ($dRead_XfyaL [Occ=Once] :: Read a_XfyaH)
                 ($dRead1_XfyaN [Occ=Once] :: Read b_XfyaJ) ->
                 Text.ParserCombinators.ReadP.run
                   @ [Arg a_XfyaH b_XfyaJ]
                   (((((GHC.Read.list
                          @ (Arg a_XfyaH b_XfyaJ)
                          ((Data.Semigroup.$fReadArg1
                              @ a_XfyaH @ b_XfyaJ $dRead_XfyaL $dRead1_XfyaN)
                           `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                  <Arg
                                                     a_XfyaH
                                                     b_XfyaJ>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                             <Arg
                                                                                a_XfyaH b_XfyaJ>_R)
                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                       -> forall b.
                                          (Arg a_XfyaH b_XfyaJ -> Text.ParserCombinators.ReadP.P b)
                                          -> Text.ParserCombinators.ReadP.P b :: *)
                                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                             (Arg a_XfyaH b_XfyaJ) :: *))))
                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                   <[Arg a_XfyaH b_XfyaJ]>_R
                               :: (Text.ParserCombinators.ReadPrec.ReadPrec
                                     [Arg a_XfyaH b_XfyaJ] :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                       -> Text.ParserCombinators.ReadP.ReadP
                                            [Arg a_XfyaH b_XfyaJ] :: *)))
                        GHC.Read.$fRead()7)
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                                 <[Arg a_XfyaH b_XfyaJ]>_R
                             :: (Text.ParserCombinators.ReadP.ReadP [Arg a_XfyaH b_XfyaJ] :: *)
                                ~R# (forall b.
                                     ([Arg a_XfyaH b_XfyaJ] -> Text.ParserCombinators.ReadP.P b)
                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                      @ [Arg a_XfyaH b_XfyaJ]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [Arg a_XfyaH b_XfyaJ]))}]
Data.Semigroup.$fReadArg_$creadList
  = \ (@ a_XfyaH)
      (@ b_XfyaJ)
      ($dRead_XfyaL :: Read a_XfyaH)
      ($dRead1_XfyaN :: Read b_XfyaJ) ->
      Text.ParserCombinators.ReadP.run
        @ [Arg a_XfyaH b_XfyaJ]
        (((((GHC.Read.list
               @ (Arg a_XfyaH b_XfyaJ)
               ((Data.Semigroup.$fReadArg1
                   @ a_XfyaH @ b_XfyaJ $dRead_XfyaL $dRead1_XfyaN)
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Arg
                                          a_XfyaH
                                          b_XfyaJ>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <Arg a_XfyaH b_XfyaJ>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               (Arg a_XfyaH b_XfyaJ -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                  (Arg a_XfyaH b_XfyaJ) :: *))))
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[Arg a_XfyaH b_XfyaJ]>_R
                    :: (Text.ParserCombinators.ReadPrec.ReadPrec
                          [Arg a_XfyaH b_XfyaJ] :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.Prec
                            -> Text.ParserCombinators.ReadP.ReadP [Arg a_XfyaH b_XfyaJ] :: *)))
             GHC.Read.$fRead()7)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                      <[Arg a_XfyaH b_XfyaJ]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP [Arg a_XfyaH b_XfyaJ] :: *)
                     ~R# (forall b.
                          ([Arg a_XfyaH b_XfyaJ] -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [Arg a_XfyaH b_XfyaJ]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ [Arg a_XfyaH b_XfyaJ]))

-- RHS size: {terms: 17, types: 19, coercions: 13, joins: 0/0}
Data.Semigroup.$fReadArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. (Read a, Read b) => Read (Arg a b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>m,
 Unf=DFun: \ (@ a_afwMd)
             (@ b_afwMe)
             (v_XnC :: Read a_afwMd)
             (v1_XnE :: Read b_afwMe) ->
       GHC.Read.C:Read TYPE: Arg a_afwMd b_afwMe
                       Data.Semigroup.$fReadArg_$creadsPrec
                         @ a_afwMd @ b_afwMe v_XnC v1_XnE
                       Data.Semigroup.$fReadArg_$creadList
                         @ a_afwMd @ b_afwMe v_XnC v1_XnE
                       (Data.Semigroup.$fReadArg1 @ a_afwMd @ b_afwMe v_XnC v1_XnE)
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Arg
                                                 a_afwMd
                                                 b_afwMe>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                         <Arg a_afwMd b_afwMe>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Arg a_afwMd b_afwMe -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                         (Arg a_afwMd b_afwMe) :: *))
                       Data.Semigroup.$fReadArg_$creadListPrec
                         @ a_afwMd @ b_afwMe v_XnC v1_XnE]
Data.Semigroup.$fReadArg
  = \ (@ a_XfyaF)
      (@ b_XfyaH)
      ($dRead_XfyaJ :: Read a_XfyaF)
      ($dRead1_XfyaL :: Read b_XfyaH) ->
      GHC.Read.C:Read
        @ (Arg a_XfyaF b_XfyaH)
        (Data.Semigroup.$fReadArg_$creadsPrec
           @ a_XfyaF @ b_XfyaH $dRead_XfyaJ $dRead1_XfyaL)
        (Data.Semigroup.$fReadArg_$creadList
           @ a_XfyaF @ b_XfyaH $dRead_XfyaJ $dRead1_XfyaL)
        ((Data.Semigroup.$fReadArg1
            @ a_XfyaF @ b_XfyaH $dRead_XfyaJ $dRead1_XfyaL)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Arg
                                   a_XfyaF
                                   b_XfyaH>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Arg a_XfyaF b_XfyaH>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Arg a_XfyaF b_XfyaH -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (Arg a_XfyaF b_XfyaH) :: *)))
        (Data.Semigroup.$fReadArg_$creadListPrec
           @ a_XfyaF @ b_XfyaH $dRead_XfyaJ $dRead1_XfyaL)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowArg1 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fShowArg1 = "Arg "#

-- RHS size: {terms: 43, types: 24, coercions: 0, joins: 0/2}
Data.Semigroup.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (Show a, Show b) => GHC.Prim.Int# -> a -> b -> ShowS
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 0 0] 321 120}]
Data.Semigroup.$w$cshowsPrec
  = \ (@ a_sfBrB)
      (@ b_sfBrC)
      (w_sfBrD :: Show a_sfBrB)
      (w1_sfBrE :: Show b_sfBrC)
      (ww_sfBrJ :: GHC.Prim.Int#)
      (ww1_sfBrN :: a_sfBrB)
      (ww2_sfBrO :: b_sfBrC) ->
      let {
        f_sfAgf [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        f_sfAgf
          = showsPrec
              @ a_sfBrB w_sfBrD Data.Semigroup.$fReadArg2 ww1_sfBrN } in
      let {
        g_sfAge [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        g_sfAge
          = showsPrec
              @ b_sfBrC w1_sfBrE Data.Semigroup.$fReadArg2 ww2_sfBrO } in
      case GHC.Prim.>=# ww_sfBrJ 11# of {
        __DEFAULT ->
          \ (x_X7RVj :: String) ->
            GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowArg1
              (f_sfAgf
                 (GHC.Types.: @ Char GHC.Show.showSpace1 (g_sfAge x_X7RVj)));
        1# ->
          \ (x_i88RR :: String) ->
            GHC.Types.:
              @ Char
              GHC.Show.$fShow(,)4
              (GHC.CString.unpackAppendCString#
                 Data.Semigroup.$fShowArg1
                 (f_sfAgf
                    (GHC.Types.:
                       @ Char
                       GHC.Show.showSpace1
                       (g_sfAge (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x_i88RR)))))
      }

-- RHS size: {terms: 18, types: 21, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowArg_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (Show a, Show b) => Int -> Arg a b -> ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sfBrB)
                 (@ b_sfBrC)
                 (w_sfBrD [Occ=Once] :: Show a_sfBrB)
                 (w1_sfBrE [Occ=Once] :: Show b_sfBrC)
                 (w2_sfBrF [Occ=Once!] :: Int)
                 (w3_sfBrG [Occ=Once!] :: Arg a_sfBrB b_sfBrC) ->
                 case w2_sfBrF of { GHC.Types.I# ww1_sfBrJ [Occ=Once] ->
                 case w3_sfBrG of { Arg ww3_sfBrN [Occ=Once] ww4_sfBrO [Occ=Once] ->
                 Data.Semigroup.$w$cshowsPrec
                   @ a_sfBrB @ b_sfBrC w_sfBrD w1_sfBrE ww1_sfBrJ ww3_sfBrN ww4_sfBrO
                 }
                 }}]
Data.Semigroup.$fShowArg_$cshowsPrec
  = \ (@ a_sfBrB)
      (@ b_sfBrC)
      (w_sfBrD :: Show a_sfBrB)
      (w1_sfBrE :: Show b_sfBrC)
      (w2_sfBrF :: Int)
      (w3_sfBrG :: Arg a_sfBrB b_sfBrC) ->
      case w2_sfBrF of { GHC.Types.I# ww1_sfBrJ ->
      case w3_sfBrG of { Arg ww3_sfBrN ww4_sfBrO ->
      Data.Semigroup.$w$cshowsPrec
        @ a_sfBrB @ b_sfBrC w_sfBrD w1_sfBrE ww1_sfBrJ ww3_sfBrN ww4_sfBrO
      }
      }

-- RHS size: {terms: 15, types: 19, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowArg_$cshow
  :: forall a b. (Show a, Show b) => Arg a b -> String
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afxMx)
                 (@ b_afxMy)
                 ($dShow_afxMz [Occ=Once] :: Show a_afxMx)
                 ($dShow1_afxMA [Occ=Once] :: Show b_afxMy)
                 (x_i7Jay [Occ=Once] :: Arg a_afxMx b_afxMy) ->
                 Data.Semigroup.$fShowArg_$cshowsPrec
                   @ a_afxMx
                   @ b_afxMy
                   $dShow_afxMz
                   $dShow1_afxMA
                   Data.Semigroup.$fFoldableOption7
                   x_i7Jay
                   (GHC.Types.[] @ Char)}]
Data.Semigroup.$fShowArg_$cshow
  = \ (@ a_afxMx)
      (@ b_afxMy)
      ($dShow_afxMz :: Show a_afxMx)
      ($dShow1_afxMA :: Show b_afxMy)
      (x_i7Jay :: Arg a_afxMx b_afxMy) ->
      case x_i7Jay of { Arg ww1_sfBrN ww2_sfBrO ->
      Data.Semigroup.$w$cshowsPrec
        @ a_afxMx
        @ b_afxMy
        $dShow_afxMz
        $dShow1_afxMA
        0#
        ww1_sfBrN
        ww2_sfBrO
        (GHC.Types.[] @ Char)
      }

-- RHS size: {terms: 19, types: 26, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowArg_$cshowList
  :: forall a b. (Show a, Show b) => [Arg a b] -> ShowS
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afxMx)
                 (@ b_afxMy)
                 ($dShow_afxMz [Occ=Once] :: Show a_afxMx)
                 ($dShow1_afxMA [Occ=Once] :: Show b_afxMy)
                 (ls_i7JaB [Occ=Once] :: [Arg a_afxMx b_afxMy])
                 (s_i7JaC [Occ=Once] :: String) ->
                 GHC.Show.showList__
                   @ (Arg a_afxMx b_afxMy)
                   (Data.Semigroup.$fShowArg_$cshowsPrec
                      @ a_afxMx
                      @ b_afxMy
                      $dShow_afxMz
                      $dShow1_afxMA
                      Data.Semigroup.$fFoldableOption7)
                   ls_i7JaB
                   s_i7JaC}]
Data.Semigroup.$fShowArg_$cshowList
  = \ (@ a_afxMx)
      (@ b_afxMy)
      ($dShow_afxMz :: Show a_afxMx)
      ($dShow1_afxMA :: Show b_afxMy)
      (ls_i7JaB :: [Arg a_afxMx b_afxMy])
      (s_i7JaC :: String) ->
      GHC.Show.showList__
        @ (Arg a_afxMx b_afxMy)
        (\ (w_sfBrG :: Arg a_afxMx b_afxMy) ->
           case w_sfBrG of { Arg ww1_sfBrN ww2_sfBrO ->
           Data.Semigroup.$w$cshowsPrec
             @ a_afxMx
             @ b_afxMy
             $dShow_afxMz
             $dShow1_afxMA
             0#
             ww1_sfBrN
             ww2_sfBrO
           })
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 14, types: 17, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. (Show a, Show b) => Show (Arg a b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)>m,
 Unf=DFun: \ (@ a_afwMd)
             (@ b_afwMe)
             (v_XnH :: Show a_afwMd)
             (v1_XnJ :: Show b_afwMe) ->
       GHC.Show.C:Show TYPE: Arg a_afwMd b_afwMe
                       Data.Semigroup.$fShowArg_$cshowsPrec
                         @ a_afwMd @ b_afwMe v_XnH v1_XnJ
                       Data.Semigroup.$fShowArg_$cshow @ a_afwMd @ b_afwMe v_XnH v1_XnJ
                       Data.Semigroup.$fShowArg_$cshowList
                         @ a_afwMd @ b_afwMe v_XnH v1_XnJ]
Data.Semigroup.$fShowArg
  = \ (@ a_afxMx)
      (@ b_afxMy)
      ($dShow_afxMz :: Show a_afxMx)
      ($dShow1_afxMA :: Show b_afxMy) ->
      GHC.Show.C:Show
        @ (Arg a_afxMx b_afxMy)
        (Data.Semigroup.$fShowArg_$cshowsPrec
           @ a_afxMx @ b_afxMy $dShow_afxMz $dShow1_afxMA)
        (Data.Semigroup.$fShowArg_$cshow
           @ a_afxMx @ b_afxMy $dShow_afxMz $dShow1_afxMA)
        (Data.Semigroup.$fShowArg_$cshowList
           @ a_afxMx @ b_afxMy $dShow_afxMz $dShow1_afxMA)

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fGeneric1Max1 :: forall a. Rep1 Max a -> Rep1 Max a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afxM8) (ds_dfzAE [Occ=Once] :: Rep1 Max a_afxM8) ->
                 ds_dfzAE}]
Data.Semigroup.$fGeneric1Max1
  = \ (@ a_afxM8) (ds_dfzAE :: Rep1 Max a_afxM8) -> ds_dfzAE

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Semigroup.$fGeneric1Max2 :: forall a. Max a -> Max a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afxLJ) (x_afxpA [Occ=Once] :: Max a_afxLJ) ->
                 x_afxpA}]
Data.Semigroup.$fGeneric1Max2
  = \ (@ a_afxLJ) (x_afxpA :: Max a_afxLJ) -> x_afxpA

-- RHS size: {terms: 3, types: 3, coercions: 163, joins: 0/0}
Data.Semigroup.$fGeneric1Max [InlPrag=NOUSERINLINE CONLIKE]
  :: Generic1 Max
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Generics.C:Generic1 TYPE: *
                               TYPE: Max
                               Data.Semigroup.$fGeneric1Max2
                               `cast` (forall (a :: <*>_N).
                                       <Max a>_R
                                       ->_R Data.Semigroup.N:Max[0]
                                                (Sym (GHC.Generics.N:Par1[0]
                                                          <a>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                             <*>_N
                                                                             <S>_P
                                                                             <'MetaSel
                                                                                ('Just "getMax")
                                                                                'NoSourceUnpackedness
                                                                                'NoSourceStrictness
                                                                                'DecidedLazy>_P
                                                                             <Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                   <*>_N
                                                                                                   <C>_P
                                                                                                   <'MetaCons
                                                                                                      "Max"
                                                                                                      'PrefixI
                                                                                                      'True>_P
                                                                                                   <M1
                                                                                                      S
                                                                                                      ('MetaSel
                                                                                                         ('Just
                                                                                                            "getMax")
                                                                                                         'NoSourceUnpackedness
                                                                                                         'NoSourceStrictness
                                                                                                         'DecidedLazy)
                                                                                                      Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                           <*>_N
                                                                                                                           <D>_P
                                                                                                                           <'MetaData
                                                                                                                              "Max"
                                                                                                                              "Data.Semigroup"
                                                                                                                              "base"
                                                                                                                              'True>_P
                                                                                                                           <M1
                                                                                                                              C
                                                                                                                              ('MetaCons
                                                                                                                                 "Max"
                                                                                                                                 'PrefixI
                                                                                                                                 'True)
                                                                                                                              (M1
                                                                                                                                 S
                                                                                                                                 ('MetaSel
                                                                                                                                    ('Just
                                                                                                                                       "getMax")
                                                                                                                                    'NoSourceUnpackedness
                                                                                                                                    'NoSourceStrictness
                                                                                                                                    'DecidedLazy)
                                                                                                                                 Par1)>_R) ; Sub (Sym (Data.Semigroup.Rep1_Max[0]))))) <a>_N)
                                       :: (forall a. Max a -> Max a :: *)
                                          ~R# (forall a. Max a -> Rep1 Max a :: *))
                               Data.Semigroup.$fGeneric1Max1
                               `cast` (forall (a :: <*>_N).
                                       <Rep1 Max a>_R
                                       ->_R (Sub (Data.Semigroup.Rep1_Max[0]) ; (GHC.Generics.N:M1[0]
                                                                                     <*>_N
                                                                                     <D>_P
                                                                                     <'MetaData
                                                                                        "Max"
                                                                                        "Data.Semigroup"
                                                                                        "base"
                                                                                        'True>_P
                                                                                     <M1
                                                                                        C
                                                                                        ('MetaCons
                                                                                           "Max"
                                                                                           'PrefixI
                                                                                           'True)
                                                                                        (M1
                                                                                           S
                                                                                           ('MetaSel
                                                                                              ('Just
                                                                                                 "getMax")
                                                                                              'NoSourceUnpackedness
                                                                                              'NoSourceStrictness
                                                                                              'DecidedLazy)
                                                                                           Par1)>_R ; (GHC.Generics.N:M1[0]
                                                                                                           <*>_N
                                                                                                           <C>_P
                                                                                                           <'MetaCons
                                                                                                              "Max"
                                                                                                              'PrefixI
                                                                                                              'True>_P
                                                                                                           <M1
                                                                                                              S
                                                                                                              ('MetaSel
                                                                                                                 ('Just
                                                                                                                    "getMax")
                                                                                                                 'NoSourceUnpackedness
                                                                                                                 'NoSourceStrictness
                                                                                                                 'DecidedLazy)
                                                                                                              Par1>_R ; GHC.Generics.N:M1[0]
                                                                                                                            <*>_N
                                                                                                                            <S>_P
                                                                                                                            <'MetaSel
                                                                                                                               ('Just
                                                                                                                                  "getMax")
                                                                                                                               'NoSourceUnpackedness
                                                                                                                               'NoSourceStrictness
                                                                                                                               'DecidedLazy>_P
                                                                                                                            <Par1>_R))) <a>_N ; GHC.Generics.N:Par1[0]
                                                                                                                                                    (Sym (Data.Semigroup.N:Max[0]
                                                                                                                                                              <a>_R))
                                       :: (forall a. Rep1 Max a -> Rep1 Max a :: *)
                                          ~R# (forall a. Rep1 Max a -> Max a :: *))]
Data.Semigroup.$fGeneric1Max
  = GHC.Generics.C:Generic1
      @ *
      @ Max
      (Data.Semigroup.$fGeneric1Max2
       `cast` (forall (a :: <*>_N).
               <Max a>_R
               ->_R Data.Semigroup.N:Max[0]
                        (Sym (GHC.Generics.N:Par1[0] <a>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                        <*>_N
                                                                        <S>_P
                                                                        <'MetaSel
                                                                           ('Just "getMax")
                                                                           'NoSourceUnpackedness
                                                                           'NoSourceStrictness
                                                                           'DecidedLazy>_P
                                                                        <Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                              <*>_N
                                                                                              <C>_P
                                                                                              <'MetaCons
                                                                                                 "Max"
                                                                                                 'PrefixI
                                                                                                 'True>_P
                                                                                              <M1
                                                                                                 S
                                                                                                 ('MetaSel
                                                                                                    ('Just
                                                                                                       "getMax")
                                                                                                    'NoSourceUnpackedness
                                                                                                    'NoSourceStrictness
                                                                                                    'DecidedLazy)
                                                                                                 Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                      <*>_N
                                                                                                                      <D>_P
                                                                                                                      <'MetaData
                                                                                                                         "Max"
                                                                                                                         "Data.Semigroup"
                                                                                                                         "base"
                                                                                                                         'True>_P
                                                                                                                      <M1
                                                                                                                         C
                                                                                                                         ('MetaCons
                                                                                                                            "Max"
                                                                                                                            'PrefixI
                                                                                                                            'True)
                                                                                                                         (M1
                                                                                                                            S
                                                                                                                            ('MetaSel
                                                                                                                               ('Just
                                                                                                                                  "getMax")
                                                                                                                               'NoSourceUnpackedness
                                                                                                                               'NoSourceStrictness
                                                                                                                               'DecidedLazy)
                                                                                                                            Par1)>_R) ; Sub (Sym (Data.Semigroup.Rep1_Max[0]))))) <a>_N)
               :: (forall a. Max a -> Max a :: *)
                  ~R# (forall a. Max a -> Rep1 Max a :: *)))
      (Data.Semigroup.$fGeneric1Max1
       `cast` (forall (a :: <*>_N).
               <Rep1 Max a>_R
               ->_R (Sub (Data.Semigroup.Rep1_Max[0]) ; (GHC.Generics.N:M1[0]
                                                             <*>_N
                                                             <D>_P
                                                             <'MetaData
                                                                "Max"
                                                                "Data.Semigroup"
                                                                "base"
                                                                'True>_P
                                                             <M1
                                                                C
                                                                ('MetaCons "Max" 'PrefixI 'True)
                                                                (M1
                                                                   S
                                                                   ('MetaSel
                                                                      ('Just "getMax")
                                                                      'NoSourceUnpackedness
                                                                      'NoSourceStrictness
                                                                      'DecidedLazy)
                                                                   Par1)>_R ; (GHC.Generics.N:M1[0]
                                                                                   <*>_N
                                                                                   <C>_P
                                                                                   <'MetaCons
                                                                                      "Max"
                                                                                      'PrefixI
                                                                                      'True>_P
                                                                                   <M1
                                                                                      S
                                                                                      ('MetaSel
                                                                                         ('Just
                                                                                            "getMax")
                                                                                         'NoSourceUnpackedness
                                                                                         'NoSourceStrictness
                                                                                         'DecidedLazy)
                                                                                      Par1>_R ; GHC.Generics.N:M1[0]
                                                                                                    <*>_N
                                                                                                    <S>_P
                                                                                                    <'MetaSel
                                                                                                       ('Just
                                                                                                          "getMax")
                                                                                                       'NoSourceUnpackedness
                                                                                                       'NoSourceStrictness
                                                                                                       'DecidedLazy>_P
                                                                                                    <Par1>_R))) <a>_N ; GHC.Generics.N:Par1[0]
                                                                                                                            (Sym (Data.Semigroup.N:Max[0]
                                                                                                                                      <a>_R))
               :: (forall a. Rep1 Max a -> Rep1 Max a :: *)
                  ~R# (forall a. Rep1 Max a -> Max a :: *)))

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fGenericMax1
  :: forall a x. Rep (Max a) x -> Rep (Max a) x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afxKI)
                 (@ x_afxLe)
                 (ds_dfzAy [Occ=Once] :: Rep (Max a_afxKI) x_afxLe) ->
                 ds_dfzAy}]
Data.Semigroup.$fGenericMax1
  = \ (@ a_afxKI)
      (@ x_afxLe)
      (ds_dfzAy :: Rep (Max a_afxKI) x_afxLe) ->
      ds_dfzAy

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Data.Semigroup.$fGenericMax2 :: forall a x. Max a -> Max a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_Xfy8D)
                 (@ x_afxKM)
                 (x1_afxpw [Occ=Once] :: Max a_Xfy8D) ->
                 x1_afxpw}]
Data.Semigroup.$fGenericMax2
  = \ (@ a_Xfy8D) (@ x_afxKM) (x1_afxpw :: Max a_Xfy8D) -> x1_afxpw

-- RHS size: {terms: 4, types: 6, coercions: 199, joins: 0/0}
Data.Semigroup.$fGenericMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Generic (Max a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_afwMf) ->
       GHC.Generics.C:Generic TYPE: Max a_afwMf
                              (Data.Semigroup.$fGenericMax2 @ a_afwMf)
                              `cast` (forall (x :: <*>_N).
                                      <Max a_afwMf>_R
                                      ->_R Data.Semigroup.N:Max[0]
                                               (Sym (GHC.Generics.N:K1[0]
                                                         <*>_N
                                                         <R>_P
                                                         <a_afwMf>_R
                                                         <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                            <*>_N
                                                                            <S>_P
                                                                            <'MetaSel
                                                                               ('Just "getMax")
                                                                               'NoSourceUnpackedness
                                                                               'NoSourceStrictness
                                                                               'DecidedLazy>_P
                                                                            <K1
                                                                               R
                                                                               a_afwMf>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                       <*>_N
                                                                                                       <C>_P
                                                                                                       <'MetaCons
                                                                                                          "Max"
                                                                                                          'PrefixI
                                                                                                          'True>_P
                                                                                                       <M1
                                                                                                          S
                                                                                                          ('MetaSel
                                                                                                             ('Just
                                                                                                                "getMax")
                                                                                                             'NoSourceUnpackedness
                                                                                                             'NoSourceStrictness
                                                                                                             'DecidedLazy)
                                                                                                          (K1
                                                                                                             R
                                                                                                             a_afwMf)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                      <*>_N
                                                                                                                                      <D>_P
                                                                                                                                      <'MetaData
                                                                                                                                         "Max"
                                                                                                                                         "Data.Semigroup"
                                                                                                                                         "base"
                                                                                                                                         'True>_P
                                                                                                                                      <M1
                                                                                                                                         C
                                                                                                                                         ('MetaCons
                                                                                                                                            "Max"
                                                                                                                                            'PrefixI
                                                                                                                                            'True)
                                                                                                                                         (M1
                                                                                                                                            S
                                                                                                                                            ('MetaSel
                                                                                                                                               ('Just
                                                                                                                                                  "getMax")
                                                                                                                                               'NoSourceUnpackedness
                                                                                                                                               'NoSourceStrictness
                                                                                                                                               'DecidedLazy)
                                                                                                                                            (K1
                                                                                                                                               R
                                                                                                                                               a_afwMf))>_R) ; Sub (Sym (Data.Semigroup.Rep_Max[0]
                                                                                                                                                                             <a_afwMf>_N))))) <x>_N)
                                      :: (forall x. Max a_afwMf -> Max a_afwMf :: *)
                                         ~R# (forall x. Max a_afwMf -> Rep (Max a_afwMf) x :: *))
                              (Data.Semigroup.$fGenericMax1 @ a_afwMf)
                              `cast` (forall (x :: <*>_N).
                                      <Rep (Max a_afwMf) x>_R
                                      ->_R Sym (Data.Semigroup.N:Max[0]
                                                    (Sym (GHC.Generics.N:K1[0]
                                                              <*>_N
                                                              <R>_P
                                                              <a_afwMf>_R
                                                              <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                 <*>_N
                                                                                 <S>_P
                                                                                 <'MetaSel
                                                                                    ('Just "getMax")
                                                                                    'NoSourceUnpackedness
                                                                                    'NoSourceStrictness
                                                                                    'DecidedLazy>_P
                                                                                 <K1
                                                                                    R
                                                                                    a_afwMf>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                            <*>_N
                                                                                                            <C>_P
                                                                                                            <'MetaCons
                                                                                                               "Max"
                                                                                                               'PrefixI
                                                                                                               'True>_P
                                                                                                            <M1
                                                                                                               S
                                                                                                               ('MetaSel
                                                                                                                  ('Just
                                                                                                                     "getMax")
                                                                                                                  'NoSourceUnpackedness
                                                                                                                  'NoSourceStrictness
                                                                                                                  'DecidedLazy)
                                                                                                               (K1
                                                                                                                  R
                                                                                                                  a_afwMf)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                           <*>_N
                                                                                                                                           <D>_P
                                                                                                                                           <'MetaData
                                                                                                                                              "Max"
                                                                                                                                              "Data.Semigroup"
                                                                                                                                              "base"
                                                                                                                                              'True>_P
                                                                                                                                           <M1
                                                                                                                                              C
                                                                                                                                              ('MetaCons
                                                                                                                                                 "Max"
                                                                                                                                                 'PrefixI
                                                                                                                                                 'True)
                                                                                                                                              (M1
                                                                                                                                                 S
                                                                                                                                                 ('MetaSel
                                                                                                                                                    ('Just
                                                                                                                                                       "getMax")
                                                                                                                                                    'NoSourceUnpackedness
                                                                                                                                                    'NoSourceStrictness
                                                                                                                                                    'DecidedLazy)
                                                                                                                                                 (K1
                                                                                                                                                    R
                                                                                                                                                    a_afwMf))>_R) ; Sub (Sym (Data.Semigroup.Rep_Max[0]
                                                                                                                                                                                  <a_afwMf>_N))))) <x>_N))
                                      :: (forall x. Rep (Max a_afwMf) x -> Rep (Max a_afwMf) x :: *)
                                         ~R# (forall x. Rep (Max a_afwMf) x -> Max a_afwMf :: *))]
Data.Semigroup.$fGenericMax
  = \ (@ a_Xfy8I) ->
      GHC.Generics.C:Generic
        @ (Max a_Xfy8I)
        ((Data.Semigroup.$fGenericMax2 @ a_Xfy8I)
         `cast` (forall (x :: <*>_N).
                 <Max a_Xfy8I>_R
                 ->_R Data.Semigroup.N:Max[0]
                          (Sym (GHC.Generics.N:K1[0]
                                    <*>_N <R>_P <a_Xfy8I>_R <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                               <*>_N
                                                                               <S>_P
                                                                               <'MetaSel
                                                                                  ('Just "getMax")
                                                                                  'NoSourceUnpackedness
                                                                                  'NoSourceStrictness
                                                                                  'DecidedLazy>_P
                                                                               <K1
                                                                                  R
                                                                                  a_Xfy8I>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                          <*>_N
                                                                                                          <C>_P
                                                                                                          <'MetaCons
                                                                                                             "Max"
                                                                                                             'PrefixI
                                                                                                             'True>_P
                                                                                                          <M1
                                                                                                             S
                                                                                                             ('MetaSel
                                                                                                                ('Just
                                                                                                                   "getMax")
                                                                                                                'NoSourceUnpackedness
                                                                                                                'NoSourceStrictness
                                                                                                                'DecidedLazy)
                                                                                                             (K1
                                                                                                                R
                                                                                                                a_Xfy8I)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                         <*>_N
                                                                                                                                         <D>_P
                                                                                                                                         <'MetaData
                                                                                                                                            "Max"
                                                                                                                                            "Data.Semigroup"
                                                                                                                                            "base"
                                                                                                                                            'True>_P
                                                                                                                                         <M1
                                                                                                                                            C
                                                                                                                                            ('MetaCons
                                                                                                                                               "Max"
                                                                                                                                               'PrefixI
                                                                                                                                               'True)
                                                                                                                                            (M1
                                                                                                                                               S
                                                                                                                                               ('MetaSel
                                                                                                                                                  ('Just
                                                                                                                                                     "getMax")
                                                                                                                                                  'NoSourceUnpackedness
                                                                                                                                                  'NoSourceStrictness
                                                                                                                                                  'DecidedLazy)
                                                                                                                                               (K1
                                                                                                                                                  R
                                                                                                                                                  a_Xfy8I))>_R) ; Sub (Sym (Data.Semigroup.Rep_Max[0]
                                                                                                                                                                                <a_Xfy8I>_N))))) <x>_N)
                 :: (forall x. Max a_Xfy8I -> Max a_Xfy8I :: *)
                    ~R# (forall x. Max a_Xfy8I -> Rep (Max a_Xfy8I) x :: *)))
        ((Data.Semigroup.$fGenericMax1 @ a_Xfy8I)
         `cast` (forall (x :: <*>_N).
                 <Rep (Max a_Xfy8I) x>_R
                 ->_R Sym (Data.Semigroup.N:Max[0]
                               (Sym (GHC.Generics.N:K1[0]
                                         <*>_N <R>_P <a_Xfy8I>_R <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                    <*>_N
                                                                                    <S>_P
                                                                                    <'MetaSel
                                                                                       ('Just
                                                                                          "getMax")
                                                                                       'NoSourceUnpackedness
                                                                                       'NoSourceStrictness
                                                                                       'DecidedLazy>_P
                                                                                    <K1
                                                                                       R
                                                                                       a_Xfy8I>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                               <*>_N
                                                                                                               <C>_P
                                                                                                               <'MetaCons
                                                                                                                  "Max"
                                                                                                                  'PrefixI
                                                                                                                  'True>_P
                                                                                                               <M1
                                                                                                                  S
                                                                                                                  ('MetaSel
                                                                                                                     ('Just
                                                                                                                        "getMax")
                                                                                                                     'NoSourceUnpackedness
                                                                                                                     'NoSourceStrictness
                                                                                                                     'DecidedLazy)
                                                                                                                  (K1
                                                                                                                     R
                                                                                                                     a_Xfy8I)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                              <*>_N
                                                                                                                                              <D>_P
                                                                                                                                              <'MetaData
                                                                                                                                                 "Max"
                                                                                                                                                 "Data.Semigroup"
                                                                                                                                                 "base"
                                                                                                                                                 'True>_P
                                                                                                                                              <M1
                                                                                                                                                 C
                                                                                                                                                 ('MetaCons
                                                                                                                                                    "Max"
                                                                                                                                                    'PrefixI
                                                                                                                                                    'True)
                                                                                                                                                 (M1
                                                                                                                                                    S
                                                                                                                                                    ('MetaSel
                                                                                                                                                       ('Just
                                                                                                                                                          "getMax")
                                                                                                                                                       'NoSourceUnpackedness
                                                                                                                                                       'NoSourceStrictness
                                                                                                                                                       'DecidedLazy)
                                                                                                                                                    (K1
                                                                                                                                                       R
                                                                                                                                                       a_Xfy8I))>_R) ; Sub (Sym (Data.Semigroup.Rep_Max[0]
                                                                                                                                                                                     <a_Xfy8I>_N))))) <x>_N))
                 :: (forall x. Rep (Max a_Xfy8I) x -> Rep (Max a_Xfy8I) x :: *)
                    ~R# (forall x. Rep (Max a_Xfy8I) x -> Max a_Xfy8I :: *)))

-- RHS size: {terms: 11, types: 34, coercions: 7, joins: 0/0}
Data.Semigroup.$fDataMax_$cgfoldl
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Max a -> c (Max a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afxHu)
                 ($dData_afxHv [Occ=Once] :: Data a_afxHu)
                 (@ (c_afxHD :: * -> *))
                 (k_afxpq [Occ=Once!]
                    :: forall d b. Data d => c_afxHD (d -> b) -> d -> c_afxHD b)
                 (z_afxpr [Occ=Once!] :: forall g. g -> c_afxHD g)
                 (ds_dfzAe [Occ=Once] :: Max a_afxHu) ->
                 k_afxpq
                   @ a_afxHu
                   @ (Max a_afxHu)
                   $dData_afxHv
                   (z_afxpr
                      @ (a_afxHu -> Max a_afxHu)
                      ((Data.Semigroup.$fApplicativeFirst3 @ a_afxHu)
                       `cast` (<a_afxHu>_R ->_R Sym (Data.Semigroup.N:Max[0] <a_afxHu>_R)
                               :: (a_afxHu -> a_afxHu :: *) ~R# (a_afxHu -> Max a_afxHu :: *))))
                   (ds_dfzAe
                    `cast` (Data.Semigroup.N:Max[0] <a_afxHu>_R
                            :: (Max a_afxHu :: *) ~R# (a_afxHu :: *)))}]
Data.Semigroup.$fDataMax_$cgfoldl
  = \ (@ a_afxHu)
      ($dData_afxHv :: Data a_afxHu)
      (@ (c_afxHD :: * -> *))
      (k_afxpq
         :: forall d b. Data d => c_afxHD (d -> b) -> d -> c_afxHD b)
      (z_afxpr :: forall g. g -> c_afxHD g)
      (ds_dfzAe :: Max a_afxHu) ->
      k_afxpq
        @ a_afxHu
        @ (Max a_afxHu)
        $dData_afxHv
        (z_afxpr
           @ (a_afxHu -> Max a_afxHu)
           ((Data.Semigroup.$fApplicativeFirst3 @ a_afxHu)
            `cast` (<a_afxHu>_R ->_R Sym (Data.Semigroup.N:Max[0] <a_afxHu>_R)
                    :: (a_afxHu -> a_afxHu :: *) ~R# (a_afxHu -> Max a_afxHu :: *))))
        (ds_dfzAe
         `cast` (Data.Semigroup.N:Max[0] <a_afxHu>_R
                 :: (Max a_afxHu :: *) ~R# (a_afxHu :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataMax4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fDataMax4 = "Max"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataMax7 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fDataMax7
  = GHC.CString.unpackCString# Data.Semigroup.$fDataMax4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadMax_lexeme :: Text.Read.Lex.Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fReadMax_lexeme
  = Text.Read.Lex.Ident Data.Semigroup.$fDataMax7

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadMax3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Semigroup.$fReadMax3 = "getMax"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadMax2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fReadMax2
  = GHC.CString.unpackCString# Data.Semigroup.$fReadMax3

-- RHS size: {terms: 51, types: 60, coercions: 23, joins: 0/2}
Data.Semigroup.$fReadMax1
  :: forall a.
     Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Max a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,1*C1(U),A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30] 391 60}]
Data.Semigroup.$fReadMax1
  = \ (@ a_afxGF) ($dRead_afxGG :: Read a_afxGF) ->
      GHC.Read.list3
        @ (Max a_afxGF)
        (let {
           lvl33_sfAnz :: Text.ParserCombinators.ReadP.ReadP a_afxGF
           [LclId]
           lvl33_sfAnz
             = ((GHC.Read.readPrec @ a_afxGF $dRead_afxGG)
                `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <a_afxGF>_R
                        :: (Text.ParserCombinators.ReadPrec.ReadPrec a_afxGF :: *)
                           ~R# (Text.ParserCombinators.ReadPrec.Prec
                                -> Text.ParserCombinators.ReadP.ReadP a_afxGF :: *)))
                 Text.ParserCombinators.ReadPrec.minPrec } in
         let {
           ds_sfAg2 [Dmd=<L,C(C1(U))>]
             :: Text.ParserCombinators.ReadPrec.Prec
                -> Text.ParserCombinators.ReadP.ReadP a_afxGF
           [LclId,
            Arity=1,
            Str=<L,A>,
            Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                    WorkFree=True, Expandable=True,
                    Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
                    Tmpl= \ _ [Occ=Dead] -> lvl33_sfAnz}]
           ds_sfAg2 = \ _ [Occ=Dead] -> lvl33_sfAnz } in
         (\ (c_i88VW :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b_i815E)
            (eta_Xkc
               :: Max a_afxGF -> Text.ParserCombinators.ReadP.P b_i815E) ->
            case c_i88VW of { GHC.Types.I# x_i88VZ ->
            case GHC.Prim.<=# x_i88VZ 11# of {
              __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b_i815E;
              1# ->
                case Text.Read.Lex.$wexpect
                       Data.Semigroup.$fReadMax_lexeme
                       @ b_i815E
                       (\ _ [Occ=Dead, OS=OneShot] ->
                          case Text.Read.Lex.$wexpect
                                 Data.Semigroup.$fReadFirst_lexeme
                                 @ b_i815E
                                 (\ _ [Occ=Dead, OS=OneShot] ->
                                    ((((GHC.Read.readField
                                          @ a_afxGF
                                          Data.Semigroup.$fReadMax2
                                          (ds_sfAg2
                                           `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                            <a_afxGF>_R)
                                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                                       -> Text.ParserCombinators.ReadP.ReadP
                                                            a_afxGF :: *)
                                                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                                             a_afxGF :: *))))
                                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                   <a_afxGF>_R
                                               :: (Text.ParserCombinators.ReadPrec.ReadPrec
                                                     a_afxGF :: *)
                                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                       -> Text.ParserCombinators.ReadP.ReadP
                                                            a_afxGF :: *)))
                                        Data.Semigroup.$fReadArg2)
                                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_afxGF>_R
                                             :: (Text.ParserCombinators.ReadP.ReadP a_afxGF :: *)
                                                ~R# (forall b.
                                                     (a_afxGF -> Text.ParserCombinators.ReadP.P b)
                                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                                      @ b_i815E
                                      (\ (a3_i88WJ :: a_afxGF) ->
                                         case Text.Read.Lex.$wexpect
                                                Data.Semigroup.$fReadFirst2
                                                @ b_i815E
                                                (\ _ [Occ=Dead, OS=OneShot] ->
                                                   eta_Xkc
                                                     (a3_i88WJ
                                                      `cast` (Sym (Data.Semigroup.N:Max[0]
                                                                       <a_afxGF>_R)
                                                              :: (a_afxGF :: *)
                                                                 ~R# (Max a_afxGF :: *))))
                                         of
                                         { (# ww1_i88Ww #) ->
                                         Text.ParserCombinators.ReadP.Look @ b_i815E ww1_i88Ww
                                         }))
                          of
                          { (# ww1_i88Ww #) ->
                          Text.ParserCombinators.ReadP.Look @ b_i815E ww1_i88Ww
                          })
                of
                { (# ww1_i88Ww #) ->
                Text.ParserCombinators.ReadP.Look @ b_i815E ww1_i88Ww
                }
            }
            })
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Max
                                   a_afxGF>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Max a_afxGF>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Max a_afxGF -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec (Max a_afxGF) :: *)))

-- RHS size: {terms: 10, types: 21, coercions: 0, joins: 0/1}
Data.Semigroup.$fReadMax_$creadsPrec
  :: forall a. Read a => Int -> ReadS (Max a)
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,1*C1(U),A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 90 60}]
Data.Semigroup.$fReadMax_$creadsPrec
  = \ (@ a_Xfy4P) ($dRead_Xfy4R :: Read a_Xfy4P) ->
      let {
        ds_sfAfU [Dmd=<L,C(C1(U))>]
          :: Text.ParserCombinators.ReadPrec.Prec
             -> forall b.
                (Max a_Xfy4P -> Text.ParserCombinators.ReadP.P b)
                -> Text.ParserCombinators.ReadP.P b
        [LclId]
        ds_sfAfU = Data.Semigroup.$fReadMax1 @ a_Xfy4P $dRead_Xfy4R } in
      \ (n_i8156 :: Int) ->
        Text.ParserCombinators.ReadP.run
          @ (Max a_Xfy4P)
          (ds_sfAfU
             n_i8156
             @ (Max a_Xfy4P)
             (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                @ (Max a_Xfy4P)))

-- RHS size: {terms: 5, types: 7, coercions: 11, joins: 0/0}
Data.Semigroup.$fReadMax_$creadListPrec
  :: forall a.
     Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Max a]
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,1*C1(U),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xfy4N) ($dRead_Xfy4P [Occ=Once] :: Read a_Xfy4N) ->
                 GHC.Read.list
                   @ (Max a_Xfy4N)
                   ((Data.Semigroup.$fReadMax1 @ a_Xfy4N $dRead_Xfy4P)
                    `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Max
                                              a_Xfy4N>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <Max a_Xfy4N>_R)
                            :: (Text.ParserCombinators.ReadPrec.Prec
                                -> forall b.
                                   (Max a_Xfy4N -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)
                               ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                      (Max a_Xfy4N) :: *)))}]
Data.Semigroup.$fReadMax_$creadListPrec
  = \ (@ a_Xfy4N) ($dRead_Xfy4P :: Read a_Xfy4N) ->
      GHC.Read.list
        @ (Max a_Xfy4N)
        ((Data.Semigroup.$fReadMax1 @ a_Xfy4N $dRead_Xfy4P)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Max
                                   a_Xfy4N>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Max a_Xfy4N>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Max a_Xfy4N -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec (Max a_Xfy4N) :: *)))

-- RHS size: {terms: 8, types: 16, coercions: 19, joins: 0/0}
Data.Semigroup.$fReadMax_$creadList
  :: forall a. Read a => ReadS [Max a]
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,1*C1(U),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xfy4O) ($dRead_Xfy4Q [Occ=Once] :: Read a_Xfy4O) ->
                 Text.ParserCombinators.ReadP.run
                   @ [Max a_Xfy4O]
                   (((((GHC.Read.list
                          @ (Max a_Xfy4O)
                          ((Data.Semigroup.$fReadMax1 @ a_Xfy4O $dRead_Xfy4Q)
                           `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                  <Max
                                                     a_Xfy4O>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                             <Max a_Xfy4O>_R)
                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                       -> forall b.
                                          (Max a_Xfy4O -> Text.ParserCombinators.ReadP.P b)
                                          -> Text.ParserCombinators.ReadP.P b :: *)
                                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                             (Max a_Xfy4O) :: *))))
                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                   <[Max a_Xfy4O]>_R
                               :: (Text.ParserCombinators.ReadPrec.ReadPrec [Max a_Xfy4O] :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                       -> Text.ParserCombinators.ReadP.ReadP [Max a_Xfy4O] :: *)))
                        GHC.Read.$fRead()7)
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[Max a_Xfy4O]>_R
                             :: (Text.ParserCombinators.ReadP.ReadP [Max a_Xfy4O] :: *)
                                ~R# (forall b.
                                     ([Max a_Xfy4O] -> Text.ParserCombinators.ReadP.P b)
                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                      @ [Max a_Xfy4O]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [Max a_Xfy4O]))}]
Data.Semigroup.$fReadMax_$creadList
  = \ (@ a_Xfy4O) ($dRead_Xfy4Q :: Read a_Xfy4O) ->
      Text.ParserCombinators.ReadP.run
        @ [Max a_Xfy4O]
        (((((GHC.Read.list
               @ (Max a_Xfy4O)
               ((Data.Semigroup.$fReadMax1 @ a_Xfy4O $dRead_Xfy4Q)
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Max
                                          a_Xfy4O>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <Max a_Xfy4O>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               (Max a_Xfy4O -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                  (Max a_Xfy4O) :: *))))
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[Max a_Xfy4O]>_R
                    :: (Text.ParserCombinators.ReadPrec.ReadPrec [Max a_Xfy4O] :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.Prec
                            -> Text.ParserCombinators.ReadP.ReadP [Max a_Xfy4O] :: *)))
             GHC.Read.$fRead()7)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[Max a_Xfy4O]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP [Max a_Xfy4O] :: *)
                     ~R# (forall b.
                          ([Max a_Xfy4O] -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [Max a_Xfy4O]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ [Max a_Xfy4O]))

-- RHS size: {terms: 11, types: 10, coercions: 11, joins: 0/0}
Data.Semigroup.$fReadMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Read a => Read (Max a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,A,C(U),A)>m,
 Unf=DFun: \ (@ a_afwMf) (v_Xo9 :: Read a_afwMf) ->
       GHC.Read.C:Read TYPE: Max a_afwMf
                       Data.Semigroup.$fReadMax_$creadsPrec @ a_afwMf v_Xo9
                       Data.Semigroup.$fReadMax_$creadList @ a_afwMf v_Xo9
                       (Data.Semigroup.$fReadMax1 @ a_afwMf v_Xo9)
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Max
                                                 a_afwMf>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                         <Max a_afwMf>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Max a_afwMf -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec (Max a_afwMf) :: *))
                       Data.Semigroup.$fReadMax_$creadListPrec @ a_afwMf v_Xo9]
Data.Semigroup.$fReadMax
  = \ (@ a_Xfy4M) ($dRead_Xfy4O :: Read a_Xfy4M) ->
      GHC.Read.C:Read
        @ (Max a_Xfy4M)
        (Data.Semigroup.$fReadMax_$creadsPrec @ a_Xfy4M $dRead_Xfy4O)
        (Data.Semigroup.$fReadMax_$creadList @ a_Xfy4M $dRead_Xfy4O)
        ((Data.Semigroup.$fReadMax1 @ a_Xfy4M $dRead_Xfy4O)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Max
                                   a_Xfy4M>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Max a_Xfy4M>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Max a_Xfy4M -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec (Max a_Xfy4M) :: *)))
        (Data.Semigroup.$fReadMax_$creadListPrec @ a_Xfy4M $dRead_Xfy4O)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowMax2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Semigroup.$fShowMax2 = "Max {"#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowMax1 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Semigroup.$fShowMax1 = "getMax = "#

-- RHS size: {terms: 37, types: 15, coercions: 2, joins: 0/1}
Data.Semigroup.$w$cshowsPrec3 [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => GHC.Prim.Int# -> Max a -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 331 120}]
Data.Semigroup.$w$cshowsPrec3
  = \ (@ a_sfBrV)
      (w_sfBrW :: Show a_sfBrV)
      (ww_sfBs1 :: GHC.Prim.Int#)
      (w1_sfBrY :: Max a_sfBrV) ->
      let {
        f_sfAfQ [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        f_sfAfQ
          = showsPrec
              @ a_sfBrV
              w_sfBrW
              Data.Semigroup.$fFoldableOption7
              (w1_sfBrY
               `cast` (Data.Semigroup.N:Max[0] <a_sfBrV>_R
                       :: (Max a_sfBrV :: *) ~R# (a_sfBrV :: *))) } in
      case GHC.Prim.>=# ww_sfBs1 11# of {
        __DEFAULT ->
          \ (x_X7RVM :: String) ->
            GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowMax2
              (GHC.CString.unpackAppendCString#
                 Data.Semigroup.$fShowMax1
                 (f_sfAfQ
                    (GHC.CString.unpackAppendCString#
                       Data.Semigroup.$fReadFirst4 x_X7RVM)));
        1# ->
          \ (x_i88RR :: String) ->
            GHC.Types.:
              @ Char
              GHC.Show.$fShow(,)4
              (GHC.CString.unpackAppendCString#
                 Data.Semigroup.$fShowMax2
                 (GHC.CString.unpackAppendCString#
                    Data.Semigroup.$fShowMax1
                    (f_sfAfQ
                       (GHC.CString.unpackAppendCString#
                          Data.Semigroup.$fReadFirst4
                          (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x_i88RR)))))
      }

-- RHS size: {terms: 11, types: 10, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowMax_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => Int -> Max a -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sfBrV)
                 (w_sfBrW [Occ=Once] :: Show a_sfBrV)
                 (w1_sfBrX [Occ=Once!] :: Int)
                 (w2_sfBrY [Occ=Once] :: Max a_sfBrV) ->
                 case w1_sfBrX of { GHC.Types.I# ww1_sfBs1 [Occ=Once] ->
                 Data.Semigroup.$w$cshowsPrec3 @ a_sfBrV w_sfBrW ww1_sfBs1 w2_sfBrY
                 }}]
Data.Semigroup.$fShowMax_$cshowsPrec
  = \ (@ a_sfBrV)
      (w_sfBrW :: Show a_sfBrV)
      (w1_sfBrX :: Int)
      (w2_sfBrY :: Max a_sfBrV) ->
      case w1_sfBrX of { GHC.Types.I# ww1_sfBs1 ->
      Data.Semigroup.$w$cshowsPrec3 @ a_sfBrV w_sfBrW ww1_sfBs1 w2_sfBrY
      }

-- RHS size: {terms: 12, types: 7, coercions: 2, joins: 0/0}
Data.Semigroup.$fShowMax_$cshow
  :: forall a. Show a => Max a -> String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 110 0}]
Data.Semigroup.$fShowMax_$cshow
  = \ (@ a_afxGa)
      ($dShow_afxGb :: Show a_afxGa)
      (x_i7Jay :: Max a_afxGa) ->
      GHC.CString.unpackAppendCString#
        Data.Semigroup.$fShowMax2
        (GHC.CString.unpackAppendCString#
           Data.Semigroup.$fShowMax1
           (showsPrec
              @ a_afxGa
              $dShow_afxGb
              Data.Semigroup.$fFoldableOption7
              (x_i7Jay
               `cast` (Data.Semigroup.N:Max[0] <a_afxGa>_R
                       :: (Max a_afxGa :: *) ~R# (a_afxGa :: *)))
              Data.Semigroup.$fReadFirst3))

-- RHS size: {terms: 12, types: 13, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowMax_$cshowList
  :: forall a. Show a => [Max a] -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afxGa)
                 ($dShow_afxGb [Occ=Once] :: Show a_afxGa)
                 (ls_i7JaB [Occ=Once] :: [Max a_afxGa])
                 (s_i7JaC [Occ=Once] :: String) ->
                 GHC.Show.showList__
                   @ (Max a_afxGa)
                   (Data.Semigroup.$fShowMax_$cshowsPrec
                      @ a_afxGa $dShow_afxGb Data.Semigroup.$fFoldableOption7)
                   ls_i7JaB
                   s_i7JaC}]
Data.Semigroup.$fShowMax_$cshowList
  = \ (@ a_afxGa)
      ($dShow_afxGb :: Show a_afxGa)
      (ls_i7JaB :: [Max a_afxGa])
      (s_i7JaC :: String) ->
      GHC.Show.showList__
        @ (Max a_afxGa)
        (\ (w_sfBrY :: Max a_afxGa) ->
           Data.Semigroup.$w$cshowsPrec3 @ a_afxGa $dShow_afxGb 0# w_sfBrY)
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 9, types: 9, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Show a => Show (Max a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(C1(C(U))),A,A)>m,
 Unf=DFun: \ (@ a_afwMf) (v_Xoe :: Show a_afwMf) ->
       GHC.Show.C:Show TYPE: Max a_afwMf
                       Data.Semigroup.$fShowMax_$cshowsPrec @ a_afwMf v_Xoe
                       Data.Semigroup.$fShowMax_$cshow @ a_afwMf v_Xoe
                       Data.Semigroup.$fShowMax_$cshowList @ a_afwMf v_Xoe]
Data.Semigroup.$fShowMax
  = \ (@ a_afxGa) ($dShow_afxGb :: Show a_afxGa) ->
      GHC.Show.C:Show
        @ (Max a_afxGa)
        (Data.Semigroup.$fShowMax_$cshowsPrec @ a_afxGa $dShow_afxGb)
        (Data.Semigroup.$fShowMax_$cshow @ a_afxGa $dShow_afxGb)
        (Data.Semigroup.$fShowMax_$cshowList @ a_afxGa $dShow_afxGb)

-- RHS size: {terms: 7, types: 8, coercions: 18, joins: 0/0}
Data.Semigroup.$fEqMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Eq a => Eq (Max a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_afwMf) (v_Xoq :: Eq a_afwMf) ->
       GHC.Classes.C:Eq TYPE: Max a_afwMf
                        (== @ a_afwMf v_Xoq)
                        `cast` (Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                ->_R Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                ->_R <Bool>_R
                                :: (a_afwMf -> a_afwMf -> Bool :: *)
                                   ~R# (Max a_afwMf -> Max a_afwMf -> Bool :: *))
                        (/= @ a_afwMf v_Xoq)
                        `cast` (Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                ->_R Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                ->_R <Bool>_R
                                :: (a_afwMf -> a_afwMf -> Bool :: *)
                                   ~R# (Max a_afwMf -> Max a_afwMf -> Bool :: *))]
Data.Semigroup.$fEqMax
  = \ (@ a_afxDN) ($dEq_afxDO :: Eq a_afxDN) ->
      GHC.Classes.C:Eq
        @ (Max a_afxDN)
        ((== @ a_afxDN $dEq_afxDO)
         `cast` (Sym (Data.Semigroup.N:Max[0] <a_afxDN>_R)
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afxDN>_R)
                 ->_R <Bool>_R
                 :: (a_afxDN -> a_afxDN -> Bool :: *)
                    ~R# (Max a_afxDN -> Max a_afxDN -> Bool :: *)))
        ((/= @ a_afxDN $dEq_afxDO)
         `cast` (Sym (Data.Semigroup.N:Max[0] <a_afxDN>_R)
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afxDN>_R)
                 ->_R <Bool>_R
                 :: (a_afxDN -> a_afxDN -> Bool :: *)
                    ~R# (Max a_afxDN -> Max a_afxDN -> Bool :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Semigroup.$fOrdMax_$cp1Ord :: forall a. Ord a => Eq (Max a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afxEl) ($dOrd_afxEm [Occ=Once] :: Ord a_afxEl) ->
                 Data.Semigroup.$fEqMax
                   @ a_afxEl (GHC.Classes.$p1Ord @ a_afxEl $dOrd_afxEm)}]
Data.Semigroup.$fOrdMax_$cp1Ord
  = \ (@ a_afxEl) ($dOrd_afxEm :: Ord a_afxEl) ->
      Data.Semigroup.$fEqMax
        @ a_afxEl (GHC.Classes.$p1Ord @ a_afxEl $dOrd_afxEm)

-- RHS size: {terms: 19, types: 14, coercions: 67, joins: 0/0}
Data.Semigroup.$fOrdMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Ord a => Ord (Max a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=DFun: \ (@ a_afwMf) (v_Xos :: Ord a_afwMf) ->
       GHC.Classes.C:Ord TYPE: Max a_afwMf
                         Data.Semigroup.$fOrdMax_$cp1Ord @ a_afwMf v_Xos
                         (compare @ a_afwMf v_Xos)
                         `cast` (Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                 ->_R <Ordering>_R
                                 :: (a_afwMf -> a_afwMf -> Ordering :: *)
                                    ~R# (Max a_afwMf -> Max a_afwMf -> Ordering :: *))
                         (< @ a_afwMf v_Xos)
                         `cast` (Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                 ->_R <Bool>_R
                                 :: (a_afwMf -> a_afwMf -> Bool :: *)
                                    ~R# (Max a_afwMf -> Max a_afwMf -> Bool :: *))
                         (<= @ a_afwMf v_Xos)
                         `cast` (Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                 ->_R <Bool>_R
                                 :: (a_afwMf -> a_afwMf -> Bool :: *)
                                    ~R# (Max a_afwMf -> Max a_afwMf -> Bool :: *))
                         (> @ a_afwMf v_Xos)
                         `cast` (Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                 ->_R <Bool>_R
                                 :: (a_afwMf -> a_afwMf -> Bool :: *)
                                    ~R# (Max a_afwMf -> Max a_afwMf -> Bool :: *))
                         (>= @ a_afwMf v_Xos)
                         `cast` (Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                 ->_R <Bool>_R
                                 :: (a_afwMf -> a_afwMf -> Bool :: *)
                                    ~R# (Max a_afwMf -> Max a_afwMf -> Bool :: *))
                         (max @ a_afwMf v_Xos)
                         `cast` (Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                 :: (a_afwMf -> a_afwMf -> a_afwMf :: *)
                                    ~R# (Max a_afwMf -> Max a_afwMf -> Max a_afwMf :: *))
                         (min @ a_afwMf v_Xos)
                         `cast` (Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                 :: (a_afwMf -> a_afwMf -> a_afwMf :: *)
                                    ~R# (Max a_afwMf -> Max a_afwMf -> Max a_afwMf :: *))]
Data.Semigroup.$fOrdMax
  = \ (@ a_afxEl) ($dOrd_afxEm :: Ord a_afxEl) ->
      GHC.Classes.C:Ord
        @ (Max a_afxEl)
        (Data.Semigroup.$fOrdMax_$cp1Ord @ a_afxEl $dOrd_afxEm)
        ((compare @ a_afxEl $dOrd_afxEm)
         `cast` (Sym (Data.Semigroup.N:Max[0] <a_afxEl>_R)
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afxEl>_R)
                 ->_R <Ordering>_R
                 :: (a_afxEl -> a_afxEl -> Ordering :: *)
                    ~R# (Max a_afxEl -> Max a_afxEl -> Ordering :: *)))
        ((< @ a_afxEl $dOrd_afxEm)
         `cast` (Sym (Data.Semigroup.N:Max[0] <a_afxEl>_R)
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afxEl>_R)
                 ->_R <Bool>_R
                 :: (a_afxEl -> a_afxEl -> Bool :: *)
                    ~R# (Max a_afxEl -> Max a_afxEl -> Bool :: *)))
        ((<= @ a_afxEl $dOrd_afxEm)
         `cast` (Sym (Data.Semigroup.N:Max[0] <a_afxEl>_R)
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afxEl>_R)
                 ->_R <Bool>_R
                 :: (a_afxEl -> a_afxEl -> Bool :: *)
                    ~R# (Max a_afxEl -> Max a_afxEl -> Bool :: *)))
        ((> @ a_afxEl $dOrd_afxEm)
         `cast` (Sym (Data.Semigroup.N:Max[0] <a_afxEl>_R)
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afxEl>_R)
                 ->_R <Bool>_R
                 :: (a_afxEl -> a_afxEl -> Bool :: *)
                    ~R# (Max a_afxEl -> Max a_afxEl -> Bool :: *)))
        ((>= @ a_afxEl $dOrd_afxEm)
         `cast` (Sym (Data.Semigroup.N:Max[0] <a_afxEl>_R)
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afxEl>_R)
                 ->_R <Bool>_R
                 :: (a_afxEl -> a_afxEl -> Bool :: *)
                    ~R# (Max a_afxEl -> Max a_afxEl -> Bool :: *)))
        ((max @ a_afxEl $dOrd_afxEm)
         `cast` (Sym (Data.Semigroup.N:Max[0] <a_afxEl>_R)
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afxEl>_R)
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afxEl>_R)
                 :: (a_afxEl -> a_afxEl -> a_afxEl :: *)
                    ~R# (Max a_afxEl -> Max a_afxEl -> Max a_afxEl :: *)))
        ((min @ a_afxEl $dOrd_afxEm)
         `cast` (Sym (Data.Semigroup.N:Max[0] <a_afxEl>_R)
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afxEl>_R)
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afxEl>_R)
                 :: (a_afxEl -> a_afxEl -> a_afxEl :: *)
                    ~R# (Max a_afxEl -> Max a_afxEl -> Max a_afxEl :: *)))

-- RHS size: {terms: 7, types: 8, coercions: 6, joins: 0/0}
Data.Semigroup.$fBoundedMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Bounded a => Bounded (Max a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_afwMf) (v_Xov :: Bounded a_afwMf) ->
       GHC.Enum.C:Bounded TYPE: Max a_afwMf
                          (minBound @ a_afwMf v_Xov)
                          `cast` (Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                  :: (a_afwMf :: *) ~R# (Max a_afwMf :: *))
                          (maxBound @ a_afwMf v_Xov)
                          `cast` (Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                  :: (a_afwMf :: *) ~R# (Max a_afwMf :: *))]
Data.Semigroup.$fBoundedMax
  = \ (@ a_afxDv) ($dBounded_afxDw :: Bounded a_afxDv) ->
      GHC.Enum.C:Bounded
        @ (Max a_afxDv)
        ((minBound @ a_afxDv $dBounded_afxDw)
         `cast` (Sym (Data.Semigroup.N:Max[0] <a_afxDv>_R)
                 :: (a_afxDv :: *) ~R# (Max a_afxDv :: *)))
        ((maxBound @ a_afxDv $dBounded_afxDw)
         `cast` (Sym (Data.Semigroup.N:Max[0] <a_afxDv>_R)
                 :: (a_afxDv :: *) ~R# (Max a_afxDv :: *)))

-- RHS size: {terms: 21, types: 28, coercions: 10, joins: 0/2}
Data.Semigroup.$fMonoidMax_$cmconcat
  :: forall a. (Ord a, Bounded a) => [Max a] -> Max a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,C(C1(U)),A)><L,1*U(1*U,A)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30 0] 150 0}]
Data.Semigroup.$fMonoidMax_$cmconcat
  = \ (@ a_XfzuM)
      ($dOrd_XfzuO :: Ord a_XfzuM)
      ($dBounded_XfzuQ :: Bounded a_XfzuM)
      (eta_B1 :: [Max a_XfzuM]) ->
      let {
        z_sfAYp :: a_XfzuM
        [LclId]
        z_sfAYp = minBound @ a_XfzuM $dBounded_XfzuQ } in
      letrec {
        go_i7Jcj [Occ=LoopBreaker] :: [Max a_XfzuM] -> Max a_XfzuM
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_i7Jcj
          = \ (ds_i7Jck :: [Max a_XfzuM]) ->
              case ds_i7Jck of {
                [] ->
                  z_sfAYp
                  `cast` (Sym (Data.Semigroup.N:Max[0] <a_XfzuM>_R)
                          :: (a_XfzuM :: *) ~R# (Max a_XfzuM :: *));
                : y_i7Jcp ys_i7Jcq ->
                  (max
                     @ a_XfzuM
                     $dOrd_XfzuO
                     (y_i7Jcp
                      `cast` (Data.Semigroup.N:Max[0] <a_XfzuM>_R
                              :: (Max a_XfzuM :: *) ~R# (a_XfzuM :: *)))
                     ((go_i7Jcj ys_i7Jcq)
                      `cast` (Data.Semigroup.N:Max[0] <a_XfzuM>_R
                              :: (Max a_XfzuM :: *) ~R# (a_XfzuM :: *))))
                  `cast` (Sym (Data.Semigroup.N:Max[0] <a_XfzuM>_R)
                          :: (a_XfzuM :: *) ~R# (Max a_XfzuM :: *))
              }; } in
      go_i7Jcj eta_B1

-- RHS size: {terms: 13, types: 12, coercions: 14, joins: 0/0}
Data.Semigroup.$fMonoidMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. (Ord a, Bounded a) => Monoid (Max a)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,A,A,A,A,U,A)><L,U(U,A)>m,
 Unf=DFun: \ (@ a_afwOC)
             (v_XoB :: Ord a_afwOC)
             (v1_XoD :: Bounded a_afwOC) ->
       GHC.Base.C:Monoid TYPE: Max a_afwOC
                         Data.Semigroup.$fSemigroupMax @ a_afwOC v_XoB
                         (minBound @ a_afwOC v1_XoD)
                         `cast` (Sym (Data.Semigroup.N:Max[0] <a_afwOC>_R)
                                 :: (a_afwOC :: *) ~R# (Max a_afwOC :: *))
                         (max @ a_afwOC v_XoB)
                         `cast` (Sym (Data.Semigroup.N:Max[0] <a_afwOC>_R)
                                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afwOC>_R)
                                 ->_R Sym (Data.Semigroup.N:Max[0] <a_afwOC>_R)
                                 :: (a_afwOC -> a_afwOC -> a_afwOC :: *)
                                    ~R# (Max a_afwOC -> Max a_afwOC -> Max a_afwOC :: *))
                         Data.Semigroup.$fMonoidMax_$cmconcat @ a_afwOC v_XoB v1_XoD]
Data.Semigroup.$fMonoidMax
  = \ (@ a_XfzuG)
      ($dOrd_XfzuI :: Ord a_XfzuG)
      ($dBounded_XfzuK :: Bounded a_XfzuG) ->
      GHC.Base.C:Monoid
        @ (Max a_XfzuG)
        (Data.Semigroup.$fSemigroupMax @ a_XfzuG $dOrd_XfzuI)
        ((minBound @ a_XfzuG $dBounded_XfzuK)
         `cast` (Sym (Data.Semigroup.N:Max[0] <a_XfzuG>_R)
                 :: (a_XfzuG :: *) ~R# (Max a_XfzuG :: *)))
        ((max @ a_XfzuG $dOrd_XfzuI)
         `cast` (Sym (Data.Semigroup.N:Max[0] <a_XfzuG>_R)
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_XfzuG>_R)
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_XfzuG>_R)
                 :: (a_XfzuG -> a_XfzuG -> a_XfzuG :: *)
                    ~R# (Max a_XfzuG -> Max a_XfzuG -> Max a_XfzuG :: *)))
        (Data.Semigroup.$fMonoidMax_$cmconcat
           @ a_XfzuG $dOrd_XfzuI $dBounded_XfzuK)

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fGeneric1Min1 :: forall a. Rep1 Min a -> Rep1 Min a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afxD6) (ds_dfzA8 [Occ=Once] :: Rep1 Min a_afxD6) ->
                 ds_dfzA8}]
Data.Semigroup.$fGeneric1Min1
  = \ (@ a_afxD6) (ds_dfzA8 :: Rep1 Min a_afxD6) -> ds_dfzA8

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Semigroup.$fGeneric1Min2 :: forall a. Min a -> Min a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afxCH) (x_afxpj [Occ=Once] :: Min a_afxCH) ->
                 x_afxpj}]
Data.Semigroup.$fGeneric1Min2
  = \ (@ a_afxCH) (x_afxpj :: Min a_afxCH) -> x_afxpj

-- RHS size: {terms: 3, types: 3, coercions: 163, joins: 0/0}
Data.Semigroup.$fGeneric1Min [InlPrag=NOUSERINLINE CONLIKE]
  :: Generic1 Min
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Generics.C:Generic1 TYPE: *
                               TYPE: Min
                               Data.Semigroup.$fGeneric1Min2
                               `cast` (forall (a :: <*>_N).
                                       <Min a>_R
                                       ->_R Data.Semigroup.N:Min[0]
                                                (Sym (GHC.Generics.N:Par1[0]
                                                          <a>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                             <*>_N
                                                                             <S>_P
                                                                             <'MetaSel
                                                                                ('Just "getMin")
                                                                                'NoSourceUnpackedness
                                                                                'NoSourceStrictness
                                                                                'DecidedLazy>_P
                                                                             <Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                   <*>_N
                                                                                                   <C>_P
                                                                                                   <'MetaCons
                                                                                                      "Min"
                                                                                                      'PrefixI
                                                                                                      'True>_P
                                                                                                   <M1
                                                                                                      S
                                                                                                      ('MetaSel
                                                                                                         ('Just
                                                                                                            "getMin")
                                                                                                         'NoSourceUnpackedness
                                                                                                         'NoSourceStrictness
                                                                                                         'DecidedLazy)
                                                                                                      Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                           <*>_N
                                                                                                                           <D>_P
                                                                                                                           <'MetaData
                                                                                                                              "Min"
                                                                                                                              "Data.Semigroup"
                                                                                                                              "base"
                                                                                                                              'True>_P
                                                                                                                           <M1
                                                                                                                              C
                                                                                                                              ('MetaCons
                                                                                                                                 "Min"
                                                                                                                                 'PrefixI
                                                                                                                                 'True)
                                                                                                                              (M1
                                                                                                                                 S
                                                                                                                                 ('MetaSel
                                                                                                                                    ('Just
                                                                                                                                       "getMin")
                                                                                                                                    'NoSourceUnpackedness
                                                                                                                                    'NoSourceStrictness
                                                                                                                                    'DecidedLazy)
                                                                                                                                 Par1)>_R) ; Sub (Sym (Data.Semigroup.Rep1_Min[0]))))) <a>_N)
                                       :: (forall a. Min a -> Min a :: *)
                                          ~R# (forall a. Min a -> Rep1 Min a :: *))
                               Data.Semigroup.$fGeneric1Min1
                               `cast` (forall (a :: <*>_N).
                                       <Rep1 Min a>_R
                                       ->_R (Sub (Data.Semigroup.Rep1_Min[0]) ; (GHC.Generics.N:M1[0]
                                                                                     <*>_N
                                                                                     <D>_P
                                                                                     <'MetaData
                                                                                        "Min"
                                                                                        "Data.Semigroup"
                                                                                        "base"
                                                                                        'True>_P
                                                                                     <M1
                                                                                        C
                                                                                        ('MetaCons
                                                                                           "Min"
                                                                                           'PrefixI
                                                                                           'True)
                                                                                        (M1
                                                                                           S
                                                                                           ('MetaSel
                                                                                              ('Just
                                                                                                 "getMin")
                                                                                              'NoSourceUnpackedness
                                                                                              'NoSourceStrictness
                                                                                              'DecidedLazy)
                                                                                           Par1)>_R ; (GHC.Generics.N:M1[0]
                                                                                                           <*>_N
                                                                                                           <C>_P
                                                                                                           <'MetaCons
                                                                                                              "Min"
                                                                                                              'PrefixI
                                                                                                              'True>_P
                                                                                                           <M1
                                                                                                              S
                                                                                                              ('MetaSel
                                                                                                                 ('Just
                                                                                                                    "getMin")
                                                                                                                 'NoSourceUnpackedness
                                                                                                                 'NoSourceStrictness
                                                                                                                 'DecidedLazy)
                                                                                                              Par1>_R ; GHC.Generics.N:M1[0]
                                                                                                                            <*>_N
                                                                                                                            <S>_P
                                                                                                                            <'MetaSel
                                                                                                                               ('Just
                                                                                                                                  "getMin")
                                                                                                                               'NoSourceUnpackedness
                                                                                                                               'NoSourceStrictness
                                                                                                                               'DecidedLazy>_P
                                                                                                                            <Par1>_R))) <a>_N ; GHC.Generics.N:Par1[0]
                                                                                                                                                    (Sym (Data.Semigroup.N:Min[0]
                                                                                                                                                              <a>_R))
                                       :: (forall a. Rep1 Min a -> Rep1 Min a :: *)
                                          ~R# (forall a. Rep1 Min a -> Min a :: *))]
Data.Semigroup.$fGeneric1Min
  = GHC.Generics.C:Generic1
      @ *
      @ Min
      (Data.Semigroup.$fGeneric1Min2
       `cast` (forall (a :: <*>_N).
               <Min a>_R
               ->_R Data.Semigroup.N:Min[0]
                        (Sym (GHC.Generics.N:Par1[0] <a>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                        <*>_N
                                                                        <S>_P
                                                                        <'MetaSel
                                                                           ('Just "getMin")
                                                                           'NoSourceUnpackedness
                                                                           'NoSourceStrictness
                                                                           'DecidedLazy>_P
                                                                        <Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                              <*>_N
                                                                                              <C>_P
                                                                                              <'MetaCons
                                                                                                 "Min"
                                                                                                 'PrefixI
                                                                                                 'True>_P
                                                                                              <M1
                                                                                                 S
                                                                                                 ('MetaSel
                                                                                                    ('Just
                                                                                                       "getMin")
                                                                                                    'NoSourceUnpackedness
                                                                                                    'NoSourceStrictness
                                                                                                    'DecidedLazy)
                                                                                                 Par1>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                      <*>_N
                                                                                                                      <D>_P
                                                                                                                      <'MetaData
                                                                                                                         "Min"
                                                                                                                         "Data.Semigroup"
                                                                                                                         "base"
                                                                                                                         'True>_P
                                                                                                                      <M1
                                                                                                                         C
                                                                                                                         ('MetaCons
                                                                                                                            "Min"
                                                                                                                            'PrefixI
                                                                                                                            'True)
                                                                                                                         (M1
                                                                                                                            S
                                                                                                                            ('MetaSel
                                                                                                                               ('Just
                                                                                                                                  "getMin")
                                                                                                                               'NoSourceUnpackedness
                                                                                                                               'NoSourceStrictness
                                                                                                                               'DecidedLazy)
                                                                                                                            Par1)>_R) ; Sub (Sym (Data.Semigroup.Rep1_Min[0]))))) <a>_N)
               :: (forall a. Min a -> Min a :: *)
                  ~R# (forall a. Min a -> Rep1 Min a :: *)))
      (Data.Semigroup.$fGeneric1Min1
       `cast` (forall (a :: <*>_N).
               <Rep1 Min a>_R
               ->_R (Sub (Data.Semigroup.Rep1_Min[0]) ; (GHC.Generics.N:M1[0]
                                                             <*>_N
                                                             <D>_P
                                                             <'MetaData
                                                                "Min"
                                                                "Data.Semigroup"
                                                                "base"
                                                                'True>_P
                                                             <M1
                                                                C
                                                                ('MetaCons "Min" 'PrefixI 'True)
                                                                (M1
                                                                   S
                                                                   ('MetaSel
                                                                      ('Just "getMin")
                                                                      'NoSourceUnpackedness
                                                                      'NoSourceStrictness
                                                                      'DecidedLazy)
                                                                   Par1)>_R ; (GHC.Generics.N:M1[0]
                                                                                   <*>_N
                                                                                   <C>_P
                                                                                   <'MetaCons
                                                                                      "Min"
                                                                                      'PrefixI
                                                                                      'True>_P
                                                                                   <M1
                                                                                      S
                                                                                      ('MetaSel
                                                                                         ('Just
                                                                                            "getMin")
                                                                                         'NoSourceUnpackedness
                                                                                         'NoSourceStrictness
                                                                                         'DecidedLazy)
                                                                                      Par1>_R ; GHC.Generics.N:M1[0]
                                                                                                    <*>_N
                                                                                                    <S>_P
                                                                                                    <'MetaSel
                                                                                                       ('Just
                                                                                                          "getMin")
                                                                                                       'NoSourceUnpackedness
                                                                                                       'NoSourceStrictness
                                                                                                       'DecidedLazy>_P
                                                                                                    <Par1>_R))) <a>_N ; GHC.Generics.N:Par1[0]
                                                                                                                            (Sym (Data.Semigroup.N:Min[0]
                                                                                                                                      <a>_R))
               :: (forall a. Rep1 Min a -> Rep1 Min a :: *)
                  ~R# (forall a. Rep1 Min a -> Min a :: *)))

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Semigroup.$fGenericMin1
  :: forall a x. Rep (Min a) x -> Rep (Min a) x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_afxBG)
                 (@ x_afxCc)
                 (ds_dfzA2 [Occ=Once] :: Rep (Min a_afxBG) x_afxCc) ->
                 ds_dfzA2}]
Data.Semigroup.$fGenericMin1
  = \ (@ a_afxBG)
      (@ x_afxCc)
      (ds_dfzA2 :: Rep (Min a_afxBG) x_afxCc) ->
      ds_dfzA2

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Data.Semigroup.$fGenericMin2 :: forall a x. Min a -> Min a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_Xfy0A)
                 (@ x_afxBK)
                 (x1_afxpf [Occ=Once] :: Min a_Xfy0A) ->
                 x1_afxpf}]
Data.Semigroup.$fGenericMin2
  = \ (@ a_Xfy0A) (@ x_afxBK) (x1_afxpf :: Min a_Xfy0A) -> x1_afxpf

-- RHS size: {terms: 4, types: 6, coercions: 199, joins: 0/0}
Data.Semigroup.$fGenericMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Generic (Min a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_afwMg) ->
       GHC.Generics.C:Generic TYPE: Min a_afwMg
                              (Data.Semigroup.$fGenericMin2 @ a_afwMg)
                              `cast` (forall (x :: <*>_N).
                                      <Min a_afwMg>_R
                                      ->_R Data.Semigroup.N:Min[0]
                                               (Sym (GHC.Generics.N:K1[0]
                                                         <*>_N
                                                         <R>_P
                                                         <a_afwMg>_R
                                                         <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                            <*>_N
                                                                            <S>_P
                                                                            <'MetaSel
                                                                               ('Just "getMin")
                                                                               'NoSourceUnpackedness
                                                                               'NoSourceStrictness
                                                                               'DecidedLazy>_P
                                                                            <K1
                                                                               R
                                                                               a_afwMg>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                       <*>_N
                                                                                                       <C>_P
                                                                                                       <'MetaCons
                                                                                                          "Min"
                                                                                                          'PrefixI
                                                                                                          'True>_P
                                                                                                       <M1
                                                                                                          S
                                                                                                          ('MetaSel
                                                                                                             ('Just
                                                                                                                "getMin")
                                                                                                             'NoSourceUnpackedness
                                                                                                             'NoSourceStrictness
                                                                                                             'DecidedLazy)
                                                                                                          (K1
                                                                                                             R
                                                                                                             a_afwMg)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                      <*>_N
                                                                                                                                      <D>_P
                                                                                                                                      <'MetaData
                                                                                                                                         "Min"
                                                                                                                                         "Data.Semigroup"
                                                                                                                                         "base"
                                                                                                                                         'True>_P
                                                                                                                                      <M1
                                                                                                                                         C
                                                                                                                                         ('MetaCons
                                                                                                                                            "Min"
                                                                                                                                            'PrefixI
                                                                                                                                            'True)
                                                                                                                                         (M1
                                                                                                                                            S
                                                                                                                                            ('MetaSel
                                                                                                                                               ('Just
                                                                                                                                                  "getMin")
                                                                                                                                               'NoSourceUnpackedness
                                                                                                                                               'NoSourceStrictness
                                                                                                                                               'DecidedLazy)
                                                                                                                                            (K1
                                                                                                                                               R
                                                                                                                                               a_afwMg))>_R) ; Sub (Sym (Data.Semigroup.Rep_Min[0]
                                                                                                                                                                             <a_afwMg>_N))))) <x>_N)
                                      :: (forall x. Min a_afwMg -> Min a_afwMg :: *)
                                         ~R# (forall x. Min a_afwMg -> Rep (Min a_afwMg) x :: *))
                              (Data.Semigroup.$fGenericMin1 @ a_afwMg)
                              `cast` (forall (x :: <*>_N).
                                      <Rep (Min a_afwMg) x>_R
                                      ->_R Sym (Data.Semigroup.N:Min[0]
                                                    (Sym (GHC.Generics.N:K1[0]
                                                              <*>_N
                                                              <R>_P
                                                              <a_afwMg>_R
                                                              <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                 <*>_N
                                                                                 <S>_P
                                                                                 <'MetaSel
                                                                                    ('Just "getMin")
                                                                                    'NoSourceUnpackedness
                                                                                    'NoSourceStrictness
                                                                                    'DecidedLazy>_P
                                                                                 <K1
                                                                                    R
                                                                                    a_afwMg>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                            <*>_N
                                                                                                            <C>_P
                                                                                                            <'MetaCons
                                                                                                               "Min"
                                                                                                               'PrefixI
                                                                                                               'True>_P
                                                                                                            <M1
                                                                                                               S
                                                                                                               ('MetaSel
                                                                                                                  ('Just
                                                                                                                     "getMin")
                                                                                                                  'NoSourceUnpackedness
                                                                                                                  'NoSourceStrictness
                                                                                                                  'DecidedLazy)
                                                                                                               (K1
                                                                                                                  R
                                                                                                                  a_afwMg)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                           <*>_N
                                                                                                                                           <D>_P
                                                                                                                                           <'MetaData
                                                                                                                                              "Min"
                                                                                                                                              "Data.Semigroup"
                                                                                                                                              "base"
                                                                                                                                              'True>_P
                                                                                                                                           <M1
                                                                                                                                              C
                                                                                                                                              ('MetaCons
                                                                                                                                                 "Min"
                                                                                                                                                 'PrefixI
                                                                                                                                                 'True)
                                                                                                                                              (M1
                                                                                                                                                 S
                                                                                                                                                 ('MetaSel
                                                                                                                                                    ('Just
                                                                                                                                                       "getMin")
                                                                                                                                                    'NoSourceUnpackedness
                                                                                                                                                    'NoSourceStrictness
                                                                                                                                                    'DecidedLazy)
                                                                                                                                                 (K1
                                                                                                                                                    R
                                                                                                                                                    a_afwMg))>_R) ; Sub (Sym (Data.Semigroup.Rep_Min[0]
                                                                                                                                                                                  <a_afwMg>_N))))) <x>_N))
                                      :: (forall x. Rep (Min a_afwMg) x -> Rep (Min a_afwMg) x :: *)
                                         ~R# (forall x. Rep (Min a_afwMg) x -> Min a_afwMg :: *))]
Data.Semigroup.$fGenericMin
  = \ (@ a_Xfy0F) ->
      GHC.Generics.C:Generic
        @ (Min a_Xfy0F)
        ((Data.Semigroup.$fGenericMin2 @ a_Xfy0F)
         `cast` (forall (x :: <*>_N).
                 <Min a_Xfy0F>_R
                 ->_R Data.Semigroup.N:Min[0]
                          (Sym (GHC.Generics.N:K1[0]
                                    <*>_N <R>_P <a_Xfy0F>_R <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                               <*>_N
                                                                               <S>_P
                                                                               <'MetaSel
                                                                                  ('Just "getMin")
                                                                                  'NoSourceUnpackedness
                                                                                  'NoSourceStrictness
                                                                                  'DecidedLazy>_P
                                                                               <K1
                                                                                  R
                                                                                  a_Xfy0F>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                          <*>_N
                                                                                                          <C>_P
                                                                                                          <'MetaCons
                                                                                                             "Min"
                                                                                                             'PrefixI
                                                                                                             'True>_P
                                                                                                          <M1
                                                                                                             S
                                                                                                             ('MetaSel
                                                                                                                ('Just
                                                                                                                   "getMin")
                                                                                                                'NoSourceUnpackedness
                                                                                                                'NoSourceStrictness
                                                                                                                'DecidedLazy)
                                                                                                             (K1
                                                                                                                R
                                                                                                                a_Xfy0F)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                         <*>_N
                                                                                                                                         <D>_P
                                                                                                                                         <'MetaData
                                                                                                                                            "Min"
                                                                                                                                            "Data.Semigroup"
                                                                                                                                            "base"
                                                                                                                                            'True>_P
                                                                                                                                         <M1
                                                                                                                                            C
                                                                                                                                            ('MetaCons
                                                                                                                                               "Min"
                                                                                                                                               'PrefixI
                                                                                                                                               'True)
                                                                                                                                            (M1
                                                                                                                                               S
                                                                                                                                               ('MetaSel
                                                                                                                                                  ('Just
                                                                                                                                                     "getMin")
                                                                                                                                                  'NoSourceUnpackedness
                                                                                                                                                  'NoSourceStrictness
                                                                                                                                                  'DecidedLazy)
                                                                                                                                               (K1
                                                                                                                                                  R
                                                                                                                                                  a_Xfy0F))>_R) ; Sub (Sym (Data.Semigroup.Rep_Min[0]
                                                                                                                                                                                <a_Xfy0F>_N))))) <x>_N)
                 :: (forall x. Min a_Xfy0F -> Min a_Xfy0F :: *)
                    ~R# (forall x. Min a_Xfy0F -> Rep (Min a_Xfy0F) x :: *)))
        ((Data.Semigroup.$fGenericMin1 @ a_Xfy0F)
         `cast` (forall (x :: <*>_N).
                 <Rep (Min a_Xfy0F) x>_R
                 ->_R Sym (Data.Semigroup.N:Min[0]
                               (Sym (GHC.Generics.N:K1[0]
                                         <*>_N <R>_P <a_Xfy0F>_R <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                    <*>_N
                                                                                    <S>_P
                                                                                    <'MetaSel
                                                                                       ('Just
                                                                                          "getMin")
                                                                                       'NoSourceUnpackedness
                                                                                       'NoSourceStrictness
                                                                                       'DecidedLazy>_P
                                                                                    <K1
                                                                                       R
                                                                                       a_Xfy0F>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                               <*>_N
                                                                                                               <C>_P
                                                                                                               <'MetaCons
                                                                                                                  "Min"
                                                                                                                  'PrefixI
                                                                                                                  'True>_P
                                                                                                               <M1
                                                                                                                  S
                                                                                                                  ('MetaSel
                                                                                                                     ('Just
                                                                                                                        "getMin")
                                                                                                                     'NoSourceUnpackedness
                                                                                                                     'NoSourceStrictness
                                                                                                                     'DecidedLazy)
                                                                                                                  (K1
                                                                                                                     R
                                                                                                                     a_Xfy0F)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                              <*>_N
                                                                                                                                              <D>_P
                                                                                                                                              <'MetaData
                                                                                                                                                 "Min"
                                                                                                                                                 "Data.Semigroup"
                                                                                                                                                 "base"
                                                                                                                                                 'True>_P
                                                                                                                                              <M1
                                                                                                                                                 C
                                                                                                                                                 ('MetaCons
                                                                                                                                                    "Min"
                                                                                                                                                    'PrefixI
                                                                                                                                                    'True)
                                                                                                                                                 (M1
                                                                                                                                                    S
                                                                                                                                                    ('MetaSel
                                                                                                                                                       ('Just
                                                                                                                                                          "getMin")
                                                                                                                                                       'NoSourceUnpackedness
                                                                                                                                                       'NoSourceStrictness
                                                                                                                                                       'DecidedLazy)
                                                                                                                                                    (K1
                                                                                                                                                       R
                                                                                                                                                       a_Xfy0F))>_R) ; Sub (Sym (Data.Semigroup.Rep_Min[0]
                                                                                                                                                                                     <a_Xfy0F>_N))))) <x>_N))
                 :: (forall x. Rep (Min a_Xfy0F) x -> Rep (Min a_Xfy0F) x :: *)
                    ~R# (forall x. Rep (Min a_Xfy0F) x -> Min a_Xfy0F :: *)))

-- RHS size: {terms: 11, types: 34, coercions: 7, joins: 0/0}
Data.Semigroup.$fDataMin_$cgfoldl
  :: forall a.
     Data a =>
     forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Min a -> c (Min a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afxys)
                 ($dData_afxyt [Occ=Once] :: Data a_afxys)
                 (@ (c_afxyB :: * -> *))
                 (k_afxp9 [Occ=Once!]
                    :: forall d b. Data d => c_afxyB (d -> b) -> d -> c_afxyB b)
                 (z_afxpa [Occ=Once!] :: forall g. g -> c_afxyB g)
                 (ds_dfzzI [Occ=Once] :: Min a_afxys) ->
                 k_afxp9
                   @ a_afxys
                   @ (Min a_afxys)
                   $dData_afxyt
                   (z_afxpa
                      @ (a_afxys -> Min a_afxys)
                      ((Data.Semigroup.$fApplicativeFirst3 @ a_afxys)
                       `cast` (<a_afxys>_R ->_R Sym (Data.Semigroup.N:Min[0] <a_afxys>_R)
                               :: (a_afxys -> a_afxys :: *) ~R# (a_afxys -> Min a_afxys :: *))))
                   (ds_dfzzI
                    `cast` (Data.Semigroup.N:Min[0] <a_afxys>_R
                            :: (Min a_afxys :: *) ~R# (a_afxys :: *)))}]
Data.Semigroup.$fDataMin_$cgfoldl
  = \ (@ a_afxys)
      ($dData_afxyt :: Data a_afxys)
      (@ (c_afxyB :: * -> *))
      (k_afxp9
         :: forall d b. Data d => c_afxyB (d -> b) -> d -> c_afxyB b)
      (z_afxpa :: forall g. g -> c_afxyB g)
      (ds_dfzzI :: Min a_afxys) ->
      k_afxp9
        @ a_afxys
        @ (Min a_afxys)
        $dData_afxyt
        (z_afxpa
           @ (a_afxys -> Min a_afxys)
           ((Data.Semigroup.$fApplicativeFirst3 @ a_afxys)
            `cast` (<a_afxys>_R ->_R Sym (Data.Semigroup.N:Min[0] <a_afxys>_R)
                    :: (a_afxys -> a_afxys :: *) ~R# (a_afxys -> Min a_afxys :: *))))
        (ds_dfzzI
         `cast` (Data.Semigroup.N:Min[0] <a_afxys>_R
                 :: (Min a_afxys :: *) ~R# (a_afxys :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataMin4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fDataMin4 = "Min"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataMin7 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fDataMin7
  = GHC.CString.unpackCString# Data.Semigroup.$fDataMin4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadMin_lexeme :: Text.Read.Lex.Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fReadMin_lexeme
  = Text.Read.Lex.Ident Data.Semigroup.$fDataMin7

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadMin3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Semigroup.$fReadMin3 = "getMin"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fReadMin2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fReadMin2
  = GHC.CString.unpackCString# Data.Semigroup.$fReadMin3

-- RHS size: {terms: 51, types: 60, coercions: 23, joins: 0/2}
Data.Semigroup.$fReadMin1
  :: forall a.
     Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Min a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,1*C1(U),A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30] 391 60}]
Data.Semigroup.$fReadMin1
  = \ (@ a_afxxD) ($dRead_afxxE :: Read a_afxxD) ->
      GHC.Read.list3
        @ (Min a_afxxD)
        (let {
           lvl33_sfAog :: Text.ParserCombinators.ReadP.ReadP a_afxxD
           [LclId]
           lvl33_sfAog
             = ((GHC.Read.readPrec @ a_afxxD $dRead_afxxE)
                `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <a_afxxD>_R
                        :: (Text.ParserCombinators.ReadPrec.ReadPrec a_afxxD :: *)
                           ~R# (Text.ParserCombinators.ReadPrec.Prec
                                -> Text.ParserCombinators.ReadP.ReadP a_afxxD :: *)))
                 Text.ParserCombinators.ReadPrec.minPrec } in
         let {
           ds_sfAfC [Dmd=<L,C(C1(U))>]
             :: Text.ParserCombinators.ReadPrec.Prec
                -> Text.ParserCombinators.ReadP.ReadP a_afxxD
           [LclId,
            Arity=1,
            Str=<L,A>,
            Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                    WorkFree=True, Expandable=True,
                    Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
                    Tmpl= \ _ [Occ=Dead] -> lvl33_sfAog}]
           ds_sfAfC = \ _ [Occ=Dead] -> lvl33_sfAog } in
         (\ (c_i88VW :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b_i815E)
            (eta_XkB
               :: Min a_afxxD -> Text.ParserCombinators.ReadP.P b_i815E) ->
            case c_i88VW of { GHC.Types.I# x_i88VZ ->
            case GHC.Prim.<=# x_i88VZ 11# of {
              __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b_i815E;
              1# ->
                case Text.Read.Lex.$wexpect
                       Data.Semigroup.$fReadMin_lexeme
                       @ b_i815E
                       (\ _ [Occ=Dead, OS=OneShot] ->
                          case Text.Read.Lex.$wexpect
                                 Data.Semigroup.$fReadFirst_lexeme
                                 @ b_i815E
                                 (\ _ [Occ=Dead, OS=OneShot] ->
                                    ((((GHC.Read.readField
                                          @ a_afxxD
                                          Data.Semigroup.$fReadMin2
                                          (ds_sfAfC
                                           `cast` (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                            <a_afxxD>_R)
                                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                                       -> Text.ParserCombinators.ReadP.ReadP
                                                            a_afxxD :: *)
                                                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                                             a_afxxD :: *))))
                                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                   <a_afxxD>_R
                                               :: (Text.ParserCombinators.ReadPrec.ReadPrec
                                                     a_afxxD :: *)
                                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                       -> Text.ParserCombinators.ReadP.ReadP
                                                            a_afxxD :: *)))
                                        Data.Semigroup.$fReadArg2)
                                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_afxxD>_R
                                             :: (Text.ParserCombinators.ReadP.ReadP a_afxxD :: *)
                                                ~R# (forall b.
                                                     (a_afxxD -> Text.ParserCombinators.ReadP.P b)
                                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                                      @ b_i815E
                                      (\ (a3_i88WJ :: a_afxxD) ->
                                         case Text.Read.Lex.$wexpect
                                                Data.Semigroup.$fReadFirst2
                                                @ b_i815E
                                                (\ _ [Occ=Dead, OS=OneShot] ->
                                                   eta_XkB
                                                     (a3_i88WJ
                                                      `cast` (Sym (Data.Semigroup.N:Min[0]
                                                                       <a_afxxD>_R)
                                                              :: (a_afxxD :: *)
                                                                 ~R# (Min a_afxxD :: *))))
                                         of
                                         { (# ww1_i88Ww #) ->
                                         Text.ParserCombinators.ReadP.Look @ b_i815E ww1_i88Ww
                                         }))
                          of
                          { (# ww1_i88Ww #) ->
                          Text.ParserCombinators.ReadP.Look @ b_i815E ww1_i88Ww
                          })
                of
                { (# ww1_i88Ww #) ->
                Text.ParserCombinators.ReadP.Look @ b_i815E ww1_i88Ww
                }
            }
            })
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Min
                                   a_afxxD>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Min a_afxxD>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Min a_afxxD -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec (Min a_afxxD) :: *)))

-- RHS size: {terms: 10, types: 21, coercions: 0, joins: 0/1}
Data.Semigroup.$fReadMin_$creadsPrec
  :: forall a. Read a => Int -> ReadS (Min a)
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,1*C1(U),A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 90 60}]
Data.Semigroup.$fReadMin_$creadsPrec
  = \ (@ a_XfxWM) ($dRead_XfxWO :: Read a_XfxWM) ->
      let {
        ds_sfAfu [Dmd=<L,C(C1(U))>]
          :: Text.ParserCombinators.ReadPrec.Prec
             -> forall b.
                (Min a_XfxWM -> Text.ParserCombinators.ReadP.P b)
                -> Text.ParserCombinators.ReadP.P b
        [LclId]
        ds_sfAfu = Data.Semigroup.$fReadMin1 @ a_XfxWM $dRead_XfxWO } in
      \ (n_i8156 :: Int) ->
        Text.ParserCombinators.ReadP.run
          @ (Min a_XfxWM)
          (ds_sfAfu
             n_i8156
             @ (Min a_XfxWM)
             (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                @ (Min a_XfxWM)))

-- RHS size: {terms: 5, types: 7, coercions: 11, joins: 0/0}
Data.Semigroup.$fReadMin_$creadListPrec
  :: forall a.
     Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Min a]
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,1*C1(U),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XfxWK) ($dRead_XfxWM [Occ=Once] :: Read a_XfxWK) ->
                 GHC.Read.list
                   @ (Min a_XfxWK)
                   ((Data.Semigroup.$fReadMin1 @ a_XfxWK $dRead_XfxWM)
                    `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Min
                                              a_XfxWK>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <Min a_XfxWK>_R)
                            :: (Text.ParserCombinators.ReadPrec.Prec
                                -> forall b.
                                   (Min a_XfxWK -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)
                               ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                      (Min a_XfxWK) :: *)))}]
Data.Semigroup.$fReadMin_$creadListPrec
  = \ (@ a_XfxWK) ($dRead_XfxWM :: Read a_XfxWK) ->
      GHC.Read.list
        @ (Min a_XfxWK)
        ((Data.Semigroup.$fReadMin1 @ a_XfxWK $dRead_XfxWM)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Min
                                   a_XfxWK>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Min a_XfxWK>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Min a_XfxWK -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec (Min a_XfxWK) :: *)))

-- RHS size: {terms: 8, types: 16, coercions: 19, joins: 0/0}
Data.Semigroup.$fReadMin_$creadList
  :: forall a. Read a => ReadS [Min a]
[GblId,
 Arity=1,
 Str=<L,1*U(A,A,1*C1(U),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XfxWL) ($dRead_XfxWN [Occ=Once] :: Read a_XfxWL) ->
                 Text.ParserCombinators.ReadP.run
                   @ [Min a_XfxWL]
                   (((((GHC.Read.list
                          @ (Min a_XfxWL)
                          ((Data.Semigroup.$fReadMin1 @ a_XfxWL $dRead_XfxWN)
                           `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                  <Min
                                                     a_XfxWL>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                             <Min a_XfxWL>_R)
                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                       -> forall b.
                                          (Min a_XfxWL -> Text.ParserCombinators.ReadP.P b)
                                          -> Text.ParserCombinators.ReadP.P b :: *)
                                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                             (Min a_XfxWL) :: *))))
                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                   <[Min a_XfxWL]>_R
                               :: (Text.ParserCombinators.ReadPrec.ReadPrec [Min a_XfxWL] :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                       -> Text.ParserCombinators.ReadP.ReadP [Min a_XfxWL] :: *)))
                        GHC.Read.$fRead()7)
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[Min a_XfxWL]>_R
                             :: (Text.ParserCombinators.ReadP.ReadP [Min a_XfxWL] :: *)
                                ~R# (forall b.
                                     ([Min a_XfxWL] -> Text.ParserCombinators.ReadP.P b)
                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                      @ [Min a_XfxWL]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [Min a_XfxWL]))}]
Data.Semigroup.$fReadMin_$creadList
  = \ (@ a_XfxWL) ($dRead_XfxWN :: Read a_XfxWL) ->
      Text.ParserCombinators.ReadP.run
        @ [Min a_XfxWL]
        (((((GHC.Read.list
               @ (Min a_XfxWL)
               ((Data.Semigroup.$fReadMin1 @ a_XfxWL $dRead_XfxWN)
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Min
                                          a_XfxWL>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <Min a_XfxWL>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               (Min a_XfxWL -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                  (Min a_XfxWL) :: *))))
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[Min a_XfxWL]>_R
                    :: (Text.ParserCombinators.ReadPrec.ReadPrec [Min a_XfxWL] :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.Prec
                            -> Text.ParserCombinators.ReadP.ReadP [Min a_XfxWL] :: *)))
             GHC.Read.$fRead()7)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[Min a_XfxWL]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP [Min a_XfxWL] :: *)
                     ~R# (forall b.
                          ([Min a_XfxWL] -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [Min a_XfxWL]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ [Min a_XfxWL]))

-- RHS size: {terms: 11, types: 10, coercions: 11, joins: 0/0}
Data.Semigroup.$fReadMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Read a => Read (Min a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,A,C(U),A)>m,
 Unf=DFun: \ (@ a_afwMg) (v_Xp8 :: Read a_afwMg) ->
       GHC.Read.C:Read TYPE: Min a_afwMg
                       Data.Semigroup.$fReadMin_$creadsPrec @ a_afwMg v_Xp8
                       Data.Semigroup.$fReadMin_$creadList @ a_afwMg v_Xp8
                       (Data.Semigroup.$fReadMin1 @ a_afwMg v_Xp8)
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Min
                                                 a_afwMg>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                         <Min a_afwMg>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Min a_afwMg -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec (Min a_afwMg) :: *))
                       Data.Semigroup.$fReadMin_$creadListPrec @ a_afwMg v_Xp8]
Data.Semigroup.$fReadMin
  = \ (@ a_XfxWJ) ($dRead_XfxWL :: Read a_XfxWJ) ->
      GHC.Read.C:Read
        @ (Min a_XfxWJ)
        (Data.Semigroup.$fReadMin_$creadsPrec @ a_XfxWJ $dRead_XfxWL)
        (Data.Semigroup.$fReadMin_$creadList @ a_XfxWJ $dRead_XfxWL)
        ((Data.Semigroup.$fReadMin1 @ a_XfxWJ $dRead_XfxWL)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Min
                                   a_XfxWJ>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Min a_XfxWJ>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Min a_XfxWJ -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec (Min a_XfxWJ) :: *)))
        (Data.Semigroup.$fReadMin_$creadListPrec @ a_XfxWJ $dRead_XfxWL)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowMin2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Semigroup.$fShowMin2 = "Min {"#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowMin1 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Semigroup.$fShowMin1 = "getMin = "#

-- RHS size: {terms: 37, types: 15, coercions: 2, joins: 0/1}
Data.Semigroup.$w$cshowsPrec4 [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => GHC.Prim.Int# -> Min a -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 331 120}]
Data.Semigroup.$w$cshowsPrec4
  = \ (@ a_sfBsg)
      (w_sfBsh :: Show a_sfBsg)
      (ww_sfBsm :: GHC.Prim.Int#)
      (w1_sfBsj :: Min a_sfBsg) ->
      let {
        f_sfAfq [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        f_sfAfq
          = showsPrec
              @ a_sfBsg
              w_sfBsh
              Data.Semigroup.$fFoldableOption7
              (w1_sfBsj
               `cast` (Data.Semigroup.N:Min[0] <a_sfBsg>_R
                       :: (Min a_sfBsg :: *) ~R# (a_sfBsg :: *))) } in
      case GHC.Prim.>=# ww_sfBsm 11# of {
        __DEFAULT ->
          \ (x_X7RWL :: String) ->
            GHC.CString.unpackAppendCString#
              Data.Semigroup.$fShowMin2
              (GHC.CString.unpackAppendCString#
                 Data.Semigroup.$fShowMin1
                 (f_sfAfq
                    (GHC.CString.unpackAppendCString#
                       Data.Semigroup.$fReadFirst4 x_X7RWL)));
        1# ->
          \ (x_i88RR :: String) ->
            GHC.Types.:
              @ Char
              GHC.Show.$fShow(,)4
              (GHC.CString.unpackAppendCString#
                 Data.Semigroup.$fShowMin2
                 (GHC.CString.unpackAppendCString#
                    Data.Semigroup.$fShowMin1
                    (f_sfAfq
                       (GHC.CString.unpackAppendCString#
                          Data.Semigroup.$fReadFirst4
                          (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x_i88RR)))))
      }

-- RHS size: {terms: 11, types: 10, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowMin_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => Int -> Min a -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sfBsg)
                 (w_sfBsh [Occ=Once] :: Show a_sfBsg)
                 (w1_sfBsi [Occ=Once!] :: Int)
                 (w2_sfBsj [Occ=Once] :: Min a_sfBsg) ->
                 case w1_sfBsi of { GHC.Types.I# ww1_sfBsm [Occ=Once] ->
                 Data.Semigroup.$w$cshowsPrec4 @ a_sfBsg w_sfBsh ww1_sfBsm w2_sfBsj
                 }}]
Data.Semigroup.$fShowMin_$cshowsPrec
  = \ (@ a_sfBsg)
      (w_sfBsh :: Show a_sfBsg)
      (w1_sfBsi :: Int)
      (w2_sfBsj :: Min a_sfBsg) ->
      case w1_sfBsi of { GHC.Types.I# ww1_sfBsm ->
      Data.Semigroup.$w$cshowsPrec4 @ a_sfBsg w_sfBsh ww1_sfBsm w2_sfBsj
      }

-- RHS size: {terms: 12, types: 7, coercions: 2, joins: 0/0}
Data.Semigroup.$fShowMin_$cshow
  :: forall a. Show a => Min a -> String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 110 0}]
Data.Semigroup.$fShowMin_$cshow
  = \ (@ a_afxx8)
      ($dShow_afxx9 :: Show a_afxx8)
      (x_i7Jay :: Min a_afxx8) ->
      GHC.CString.unpackAppendCString#
        Data.Semigroup.$fShowMin2
        (GHC.CString.unpackAppendCString#
           Data.Semigroup.$fShowMin1
           (showsPrec
              @ a_afxx8
              $dShow_afxx9
              Data.Semigroup.$fFoldableOption7
              (x_i7Jay
               `cast` (Data.Semigroup.N:Min[0] <a_afxx8>_R
                       :: (Min a_afxx8 :: *) ~R# (a_afxx8 :: *)))
              Data.Semigroup.$fReadFirst3))

-- RHS size: {terms: 12, types: 13, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowMin_$cshowList
  :: forall a. Show a => [Min a] -> ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afxx8)
                 ($dShow_afxx9 [Occ=Once] :: Show a_afxx8)
                 (ls_i7JaB [Occ=Once] :: [Min a_afxx8])
                 (s_i7JaC [Occ=Once] :: String) ->
                 GHC.Show.showList__
                   @ (Min a_afxx8)
                   (Data.Semigroup.$fShowMin_$cshowsPrec
                      @ a_afxx8 $dShow_afxx9 Data.Semigroup.$fFoldableOption7)
                   ls_i7JaB
                   s_i7JaC}]
Data.Semigroup.$fShowMin_$cshowList
  = \ (@ a_afxx8)
      ($dShow_afxx9 :: Show a_afxx8)
      (ls_i7JaB :: [Min a_afxx8])
      (s_i7JaC :: String) ->
      GHC.Show.showList__
        @ (Min a_afxx8)
        (\ (w_sfBsj :: Min a_afxx8) ->
           Data.Semigroup.$w$cshowsPrec4 @ a_afxx8 $dShow_afxx9 0# w_sfBsj)
        ls_i7JaB
        s_i7JaC

-- RHS size: {terms: 9, types: 9, coercions: 0, joins: 0/0}
Data.Semigroup.$fShowMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Show a => Show (Min a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(C1(C(U))),A,A)>m,
 Unf=DFun: \ (@ a_afwMg) (v_Xpd :: Show a_afwMg) ->
       GHC.Show.C:Show TYPE: Min a_afwMg
                       Data.Semigroup.$fShowMin_$cshowsPrec @ a_afwMg v_Xpd
                       Data.Semigroup.$fShowMin_$cshow @ a_afwMg v_Xpd
                       Data.Semigroup.$fShowMin_$cshowList @ a_afwMg v_Xpd]
Data.Semigroup.$fShowMin
  = \ (@ a_afxx8) ($dShow_afxx9 :: Show a_afxx8) ->
      GHC.Show.C:Show
        @ (Min a_afxx8)
        (Data.Semigroup.$fShowMin_$cshowsPrec @ a_afxx8 $dShow_afxx9)
        (Data.Semigroup.$fShowMin_$cshow @ a_afxx8 $dShow_afxx9)
        (Data.Semigroup.$fShowMin_$cshowList @ a_afxx8 $dShow_afxx9)

-- RHS size: {terms: 7, types: 8, coercions: 18, joins: 0/0}
Data.Semigroup.$fEqMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Eq a => Eq (Min a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_afwMg) (v_Xpp :: Eq a_afwMg) ->
       GHC.Classes.C:Eq TYPE: Min a_afwMg
                        (== @ a_afwMg v_Xpp)
                        `cast` (Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                ->_R Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                ->_R <Bool>_R
                                :: (a_afwMg -> a_afwMg -> Bool :: *)
                                   ~R# (Min a_afwMg -> Min a_afwMg -> Bool :: *))
                        (/= @ a_afwMg v_Xpp)
                        `cast` (Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                ->_R Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                ->_R <Bool>_R
                                :: (a_afwMg -> a_afwMg -> Bool :: *)
                                   ~R# (Min a_afwMg -> Min a_afwMg -> Bool :: *))]
Data.Semigroup.$fEqMin
  = \ (@ a_afxuL) ($dEq_afxuM :: Eq a_afxuL) ->
      GHC.Classes.C:Eq
        @ (Min a_afxuL)
        ((== @ a_afxuL $dEq_afxuM)
         `cast` (Sym (Data.Semigroup.N:Min[0] <a_afxuL>_R)
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afxuL>_R)
                 ->_R <Bool>_R
                 :: (a_afxuL -> a_afxuL -> Bool :: *)
                    ~R# (Min a_afxuL -> Min a_afxuL -> Bool :: *)))
        ((/= @ a_afxuL $dEq_afxuM)
         `cast` (Sym (Data.Semigroup.N:Min[0] <a_afxuL>_R)
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afxuL>_R)
                 ->_R <Bool>_R
                 :: (a_afxuL -> a_afxuL -> Bool :: *)
                    ~R# (Min a_afxuL -> Min a_afxuL -> Bool :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Semigroup.$fOrdMin_$cp1Ord :: forall a. Ord a => Eq (Min a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afxvj) ($dOrd_afxvk [Occ=Once] :: Ord a_afxvj) ->
                 Data.Semigroup.$fEqMin
                   @ a_afxvj (GHC.Classes.$p1Ord @ a_afxvj $dOrd_afxvk)}]
Data.Semigroup.$fOrdMin_$cp1Ord
  = \ (@ a_afxvj) ($dOrd_afxvk :: Ord a_afxvj) ->
      Data.Semigroup.$fEqMin
        @ a_afxvj (GHC.Classes.$p1Ord @ a_afxvj $dOrd_afxvk)

-- RHS size: {terms: 19, types: 14, coercions: 67, joins: 0/0}
Data.Semigroup.$fOrdMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Ord a => Ord (Min a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
 Unf=DFun: \ (@ a_afwMg) (v_Xpr :: Ord a_afwMg) ->
       GHC.Classes.C:Ord TYPE: Min a_afwMg
                         Data.Semigroup.$fOrdMin_$cp1Ord @ a_afwMg v_Xpr
                         (compare @ a_afwMg v_Xpr)
                         `cast` (Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                 ->_R <Ordering>_R
                                 :: (a_afwMg -> a_afwMg -> Ordering :: *)
                                    ~R# (Min a_afwMg -> Min a_afwMg -> Ordering :: *))
                         (< @ a_afwMg v_Xpr)
                         `cast` (Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                 ->_R <Bool>_R
                                 :: (a_afwMg -> a_afwMg -> Bool :: *)
                                    ~R# (Min a_afwMg -> Min a_afwMg -> Bool :: *))
                         (<= @ a_afwMg v_Xpr)
                         `cast` (Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                 ->_R <Bool>_R
                                 :: (a_afwMg -> a_afwMg -> Bool :: *)
                                    ~R# (Min a_afwMg -> Min a_afwMg -> Bool :: *))
                         (> @ a_afwMg v_Xpr)
                         `cast` (Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                 ->_R <Bool>_R
                                 :: (a_afwMg -> a_afwMg -> Bool :: *)
                                    ~R# (Min a_afwMg -> Min a_afwMg -> Bool :: *))
                         (>= @ a_afwMg v_Xpr)
                         `cast` (Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                 ->_R <Bool>_R
                                 :: (a_afwMg -> a_afwMg -> Bool :: *)
                                    ~R# (Min a_afwMg -> Min a_afwMg -> Bool :: *))
                         (max @ a_afwMg v_Xpr)
                         `cast` (Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                 :: (a_afwMg -> a_afwMg -> a_afwMg :: *)
                                    ~R# (Min a_afwMg -> Min a_afwMg -> Min a_afwMg :: *))
                         (min @ a_afwMg v_Xpr)
                         `cast` (Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                 :: (a_afwMg -> a_afwMg -> a_afwMg :: *)
                                    ~R# (Min a_afwMg -> Min a_afwMg -> Min a_afwMg :: *))]
Data.Semigroup.$fOrdMin
  = \ (@ a_afxvj) ($dOrd_afxvk :: Ord a_afxvj) ->
      GHC.Classes.C:Ord
        @ (Min a_afxvj)
        (Data.Semigroup.$fOrdMin_$cp1Ord @ a_afxvj $dOrd_afxvk)
        ((compare @ a_afxvj $dOrd_afxvk)
         `cast` (Sym (Data.Semigroup.N:Min[0] <a_afxvj>_R)
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afxvj>_R)
                 ->_R <Ordering>_R
                 :: (a_afxvj -> a_afxvj -> Ordering :: *)
                    ~R# (Min a_afxvj -> Min a_afxvj -> Ordering :: *)))
        ((< @ a_afxvj $dOrd_afxvk)
         `cast` (Sym (Data.Semigroup.N:Min[0] <a_afxvj>_R)
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afxvj>_R)
                 ->_R <Bool>_R
                 :: (a_afxvj -> a_afxvj -> Bool :: *)
                    ~R# (Min a_afxvj -> Min a_afxvj -> Bool :: *)))
        ((<= @ a_afxvj $dOrd_afxvk)
         `cast` (Sym (Data.Semigroup.N:Min[0] <a_afxvj>_R)
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afxvj>_R)
                 ->_R <Bool>_R
                 :: (a_afxvj -> a_afxvj -> Bool :: *)
                    ~R# (Min a_afxvj -> Min a_afxvj -> Bool :: *)))
        ((> @ a_afxvj $dOrd_afxvk)
         `cast` (Sym (Data.Semigroup.N:Min[0] <a_afxvj>_R)
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afxvj>_R)
                 ->_R <Bool>_R
                 :: (a_afxvj -> a_afxvj -> Bool :: *)
                    ~R# (Min a_afxvj -> Min a_afxvj -> Bool :: *)))
        ((>= @ a_afxvj $dOrd_afxvk)
         `cast` (Sym (Data.Semigroup.N:Min[0] <a_afxvj>_R)
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afxvj>_R)
                 ->_R <Bool>_R
                 :: (a_afxvj -> a_afxvj -> Bool :: *)
                    ~R# (Min a_afxvj -> Min a_afxvj -> Bool :: *)))
        ((max @ a_afxvj $dOrd_afxvk)
         `cast` (Sym (Data.Semigroup.N:Min[0] <a_afxvj>_R)
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afxvj>_R)
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afxvj>_R)
                 :: (a_afxvj -> a_afxvj -> a_afxvj :: *)
                    ~R# (Min a_afxvj -> Min a_afxvj -> Min a_afxvj :: *)))
        ((min @ a_afxvj $dOrd_afxvk)
         `cast` (Sym (Data.Semigroup.N:Min[0] <a_afxvj>_R)
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afxvj>_R)
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afxvj>_R)
                 :: (a_afxvj -> a_afxvj -> a_afxvj :: *)
                    ~R# (Min a_afxvj -> Min a_afxvj -> Min a_afxvj :: *)))

-- RHS size: {terms: 7, types: 8, coercions: 6, joins: 0/0}
Data.Semigroup.$fBoundedMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Bounded a => Bounded (Min a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=DFun: \ (@ a_afwMg) (v_Xpu :: Bounded a_afwMg) ->
       GHC.Enum.C:Bounded TYPE: Min a_afwMg
                          (minBound @ a_afwMg v_Xpu)
                          `cast` (Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                  :: (a_afwMg :: *) ~R# (Min a_afwMg :: *))
                          (maxBound @ a_afwMg v_Xpu)
                          `cast` (Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                  :: (a_afwMg :: *) ~R# (Min a_afwMg :: *))]
Data.Semigroup.$fBoundedMin
  = \ (@ a_afxut) ($dBounded_afxuu :: Bounded a_afxut) ->
      GHC.Enum.C:Bounded
        @ (Min a_afxut)
        ((minBound @ a_afxut $dBounded_afxuu)
         `cast` (Sym (Data.Semigroup.N:Min[0] <a_afxut>_R)
                 :: (a_afxut :: *) ~R# (Min a_afxut :: *)))
        ((maxBound @ a_afxut $dBounded_afxuu)
         `cast` (Sym (Data.Semigroup.N:Min[0] <a_afxut>_R)
                 :: (a_afxut :: *) ~R# (Min a_afxut :: *)))

-- RHS size: {terms: 21, types: 28, coercions: 10, joins: 0/2}
Data.Semigroup.$fMonoidMin_$cmconcat
  :: forall a. (Ord a, Bounded a) => [Min a] -> Min a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,A,A,C(C1(U)))><L,1*U(A,1*U)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30 0] 150 0}]
Data.Semigroup.$fMonoidMin_$cmconcat
  = \ (@ a_XfzEk)
      ($dOrd_XfzEm :: Ord a_XfzEk)
      ($dBounded_XfzEo :: Bounded a_XfzEk)
      (eta_B1 :: [Min a_XfzEk]) ->
      let {
        z_sfAYz :: a_XfzEk
        [LclId]
        z_sfAYz = maxBound @ a_XfzEk $dBounded_XfzEo } in
      letrec {
        go_i7Jcj [Occ=LoopBreaker] :: [Min a_XfzEk] -> Min a_XfzEk
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_i7Jcj
          = \ (ds_i7Jck :: [Min a_XfzEk]) ->
              case ds_i7Jck of {
                [] ->
                  z_sfAYz
                  `cast` (Sym (Data.Semigroup.N:Min[0] <a_XfzEk>_R)
                          :: (a_XfzEk :: *) ~R# (Min a_XfzEk :: *));
                : y_i7Jcp ys_i7Jcq ->
                  (min
                     @ a_XfzEk
                     $dOrd_XfzEm
                     (y_i7Jcp
                      `cast` (Data.Semigroup.N:Min[0] <a_XfzEk>_R
                              :: (Min a_XfzEk :: *) ~R# (a_XfzEk :: *)))
                     ((go_i7Jcj ys_i7Jcq)
                      `cast` (Data.Semigroup.N:Min[0] <a_XfzEk>_R
                              :: (Min a_XfzEk :: *) ~R# (a_XfzEk :: *))))
                  `cast` (Sym (Data.Semigroup.N:Min[0] <a_XfzEk>_R)
                          :: (a_XfzEk :: *) ~R# (Min a_XfzEk :: *))
              }; } in
      go_i7Jcj eta_B1

-- RHS size: {terms: 13, types: 12, coercions: 14, joins: 0/0}
Data.Semigroup.$fMonoidMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. (Ord a, Bounded a) => Monoid (Min a)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,A,A,A,A,A,U)><L,U(A,U)>m,
 Unf=DFun: \ (@ a_afwPa)
             (v_XpA :: Ord a_afwPa)
             (v1_XpC :: Bounded a_afwPa) ->
       GHC.Base.C:Monoid TYPE: Min a_afwPa
                         Data.Semigroup.$fSemigroupMin @ a_afwPa v_XpA
                         (maxBound @ a_afwPa v1_XpC)
                         `cast` (Sym (Data.Semigroup.N:Min[0] <a_afwPa>_R)
                                 :: (a_afwPa :: *) ~R# (Min a_afwPa :: *))
                         (min @ a_afwPa v_XpA)
                         `cast` (Sym (Data.Semigroup.N:Min[0] <a_afwPa>_R)
                                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afwPa>_R)
                                 ->_R Sym (Data.Semigroup.N:Min[0] <a_afwPa>_R)
                                 :: (a_afwPa -> a_afwPa -> a_afwPa :: *)
                                    ~R# (Min a_afwPa -> Min a_afwPa -> Min a_afwPa :: *))
                         Data.Semigroup.$fMonoidMin_$cmconcat @ a_afwPa v_XpA v1_XpC]
Data.Semigroup.$fMonoidMin
  = \ (@ a_XfzEe)
      ($dOrd_XfzEg :: Ord a_XfzEe)
      ($dBounded_XfzEi :: Bounded a_XfzEe) ->
      GHC.Base.C:Monoid
        @ (Min a_XfzEe)
        (Data.Semigroup.$fSemigroupMin @ a_XfzEe $dOrd_XfzEg)
        ((maxBound @ a_XfzEe $dBounded_XfzEi)
         `cast` (Sym (Data.Semigroup.N:Min[0] <a_XfzEe>_R)
                 :: (a_XfzEe :: *) ~R# (Min a_XfzEe :: *)))
        ((min @ a_XfzEe $dOrd_XfzEg)
         `cast` (Sym (Data.Semigroup.N:Min[0] <a_XfzEe>_R)
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_XfzEe>_R)
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_XfzEe>_R)
                 :: (a_XfzEe -> a_XfzEe -> a_XfzEe :: *)
                    ~R# (Min a_XfzEe -> Min a_XfzEe -> Min a_XfzEe :: *)))
        (Data.Semigroup.$fMonoidMin_$cmconcat
           @ a_XfzEe $dOrd_XfzEg $dBounded_XfzEi)

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
getMin :: forall a. Min a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Semigroup.$fGeneric1Min2
               `cast` (forall (a :: <*>_N).
                       <Min a>_R ->_R Data.Semigroup.N:Min[0] <a>_R
                       :: (forall a. Min a -> Min a :: *)
                          ~R# (forall a. Min a -> a :: *))}]
getMin
  = Data.Semigroup.$fGeneric1Min2
    `cast` (forall (a :: <*>_N).
            <Min a>_R ->_R Data.Semigroup.N:Min[0] <a>_R
            :: (forall a. Min a -> Min a :: *) ~R# (forall a. Min a -> a :: *))

-- RHS size: {terms: 6, types: 7, coercions: 2, joins: 0/1}
Data.Semigroup.$fMonadFixMin_$cmfix
  :: forall a. (a -> Min a) -> Min a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<C(S),C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afz9s)
                 (f_afwOZ [Occ=Once!] :: a_afz9s -> Min a_afz9s) ->
                 letrec {
                   x_sfAfi [Occ=LoopBreaker] :: Min a_afz9s
                   [LclId]
                   x_sfAfi
                     = f_afwOZ
                         (x_sfAfi
                          `cast` (Data.Semigroup.N:Min[0] <a_afz9s>_R
                                  :: (Min a_afz9s :: *) ~R# (a_afz9s :: *))); } in
                 x_sfAfi}]
Data.Semigroup.$fMonadFixMin_$cmfix
  = \ (@ a_afz9s) (f_afwOZ :: a_afz9s -> Min a_afz9s) ->
      letrec {
        x_sfAfi [Occ=LoopBreaker] :: Min a_afz9s
        [LclId]
        x_sfAfi
          = f_afwOZ
              (x_sfAfi
               `cast` (Data.Semigroup.N:Min[0] <a_afz9s>_R
                       :: (Min a_afz9s :: *) ~R# (a_afz9s :: *))); } in
      x_sfAfi

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Semigroup.$fMonadFixMin [InlPrag=NOUSERINLINE CONLIKE]
  :: MonadFix Min
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Control.Monad.Fix.C:MonadFix TYPE: Min
                                    Data.Semigroup.$fMonadMin
                                    Data.Semigroup.$fMonadFixMin_$cmfix]
Data.Semigroup.$fMonadFixMin
  = Control.Monad.Fix.C:MonadFix
      @ Min Data.Semigroup.$fMonadMin Data.Semigroup.$fMonadFixMin_$cmfix

-- RHS size: {terms: 43, types: 37, coercions: 79, joins: 0/0}
Data.Semigroup.$fEnumMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Enum a => Enum (Min a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m,
 Unf=DFun: \ (@ a_afwPc) (v_XpO :: Enum a_afwPc) ->
       GHC.Enum.C:Enum TYPE: Min a_afwPc
                       (\ (ds_XfAfk [Occ=Once] :: Min a_afwPc) ->
                          succ
                            @ a_afwPc
                            v_XpO
                            (ds_XfAfk
                             `cast` (Data.Semigroup.N:Min[0] <a_afwPc>_R
                                     :: (Min a_afwPc :: *) ~R# (a_afwPc :: *))))
                       `cast` (<Min a_afwPc>_R
                               ->_R Sym (Data.Semigroup.N:Min[0] <a_afwPc>_R)
                               :: (Min a_afwPc -> a_afwPc :: *)
                                  ~R# (Min a_afwPc -> Min a_afwPc :: *))
                       (\ (ds_XfAfo [Occ=Once] :: Min a_afwPc) ->
                          pred
                            @ a_afwPc
                            v_XpO
                            (ds_XfAfo
                             `cast` (Data.Semigroup.N:Min[0] <a_afwPc>_R
                                     :: (Min a_afwPc :: *) ~R# (a_afwPc :: *))))
                       `cast` (<Min a_afwPc>_R
                               ->_R Sym (Data.Semigroup.N:Min[0] <a_afwPc>_R)
                               :: (Min a_afwPc -> a_afwPc :: *)
                                  ~R# (Min a_afwPc -> Min a_afwPc :: *))
                       (\ (eta_XkH [Occ=Once] :: Int) -> toEnum @ a_afwPc v_XpO eta_XkH)
                       `cast` (<Int>_R ->_R Sym (Data.Semigroup.N:Min[0] <a_afwPc>_R)
                               :: (Int -> a_afwPc :: *) ~R# (Int -> Min a_afwPc :: *))
                       \ (eta_XkF [Occ=Once] :: Min a_afwPc) ->
                         fromEnum
                           @ a_afwPc
                           v_XpO
                           (eta_XkF
                            `cast` (Data.Semigroup.N:Min[0] <a_afwPc>_R
                                    :: (Min a_afwPc :: *) ~R# (a_afwPc :: *)))
                       (\ (ds_XfAeE [Occ=Once] :: Min a_afwPc) ->
                          enumFrom
                            @ a_afwPc
                            v_XpO
                            (ds_XfAeE
                             `cast` (Data.Semigroup.N:Min[0] <a_afwPc>_R
                                     :: (Min a_afwPc :: *) ~R# (a_afwPc :: *))))
                       `cast` (<Min a_afwPc>_R
                               ->_R ([Sym (Data.Semigroup.N:Min[0] <a_afwPc>_R)])_R
                               :: (Min a_afwPc -> [a_afwPc] :: *)
                                  ~R# (Min a_afwPc -> [Min a_afwPc] :: *))
                       (\ (ds_XfAeI [Occ=Once] :: Min a_afwPc)
                          (ds1_XfAeK [Occ=Once] :: Min a_afwPc) ->
                          enumFromThen
                            @ a_afwPc
                            v_XpO
                            (ds_XfAeI
                             `cast` (Data.Semigroup.N:Min[0] <a_afwPc>_R
                                     :: (Min a_afwPc :: *) ~R# (a_afwPc :: *)))
                            (ds1_XfAeK
                             `cast` (Data.Semigroup.N:Min[0] <a_afwPc>_R
                                     :: (Min a_afwPc :: *) ~R# (a_afwPc :: *))))
                       `cast` (<Min a_afwPc>_R
                               ->_R <Min a_afwPc>_R
                               ->_R ([Sym (Data.Semigroup.N:Min[0] <a_afwPc>_R)])_R
                               :: (Min a_afwPc -> Min a_afwPc -> [a_afwPc] :: *)
                                  ~R# (Min a_afwPc -> Min a_afwPc -> [Min a_afwPc] :: *))
                       (\ (ds_XfAeP [Occ=Once] :: Min a_afwPc)
                          (ds1_XfAeR [Occ=Once] :: Min a_afwPc) ->
                          enumFromTo
                            @ a_afwPc
                            v_XpO
                            (ds_XfAeP
                             `cast` (Data.Semigroup.N:Min[0] <a_afwPc>_R
                                     :: (Min a_afwPc :: *) ~R# (a_afwPc :: *)))
                            (ds1_XfAeR
                             `cast` (Data.Semigroup.N:Min[0] <a_afwPc>_R
                                     :: (Min a_afwPc :: *) ~R# (a_afwPc :: *))))
                       `cast` (<Min a_afwPc>_R
                               ->_R <Min a_afwPc>_R
                               ->_R ([Sym (Data.Semigroup.N:Min[0] <a_afwPc>_R)])_R
                               :: (Min a_afwPc -> Min a_afwPc -> [a_afwPc] :: *)
                                  ~R# (Min a_afwPc -> Min a_afwPc -> [Min a_afwPc] :: *))
                       (\ (ds_XfAeW [Occ=Once] :: Min a_afwPc)
                          (ds1_XfAeY [Occ=Once] :: Min a_afwPc)
                          (ds2_XfAf0 [Occ=Once] :: Min a_afwPc) ->
                          enumFromThenTo
                            @ a_afwPc
                            v_XpO
                            (ds_XfAeW
                             `cast` (Data.Semigroup.N:Min[0] <a_afwPc>_R
                                     :: (Min a_afwPc :: *) ~R# (a_afwPc :: *)))
                            (ds1_XfAeY
                             `cast` (Data.Semigroup.N:Min[0] <a_afwPc>_R
                                     :: (Min a_afwPc :: *) ~R# (a_afwPc :: *)))
                            (ds2_XfAf0
                             `cast` (Data.Semigroup.N:Min[0] <a_afwPc>_R
                                     :: (Min a_afwPc :: *) ~R# (a_afwPc :: *))))
                       `cast` (<Min a_afwPc>_R
                               ->_R <Min a_afwPc>_R
                               ->_R <Min a_afwPc>_R
                               ->_R ([Sym (Data.Semigroup.N:Min[0] <a_afwPc>_R)])_R
                               :: (Min a_afwPc -> Min a_afwPc -> Min a_afwPc -> [a_afwPc] :: *)
                                  ~R# (Min a_afwPc
                                       -> Min a_afwPc -> Min a_afwPc -> [Min a_afwPc] :: *))]
Data.Semigroup.$fEnumMin
  = \ (@ a_XfzFs) ($dEnum_XfzFu :: Enum a_XfzFs) ->
      GHC.Enum.C:Enum
        @ (Min a_XfzFs)
        ((\ (ds_XfAfk :: Min a_XfzFs) ->
            succ
              @ a_XfzFs
              $dEnum_XfzFu
              (ds_XfAfk
               `cast` (Data.Semigroup.N:Min[0] <a_XfzFs>_R
                       :: (Min a_XfzFs :: *) ~R# (a_XfzFs :: *))))
         `cast` (<Min a_XfzFs>_R
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_XfzFs>_R)
                 :: (Min a_XfzFs -> a_XfzFs :: *)
                    ~R# (Min a_XfzFs -> Min a_XfzFs :: *)))
        ((\ (ds_XfAfo :: Min a_XfzFs) ->
            pred
              @ a_XfzFs
              $dEnum_XfzFu
              (ds_XfAfo
               `cast` (Data.Semigroup.N:Min[0] <a_XfzFs>_R
                       :: (Min a_XfzFs :: *) ~R# (a_XfzFs :: *))))
         `cast` (<Min a_XfzFs>_R
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_XfzFs>_R)
                 :: (Min a_XfzFs -> a_XfzFs :: *)
                    ~R# (Min a_XfzFs -> Min a_XfzFs :: *)))
        ((\ (eta_XkH :: Int) -> toEnum @ a_XfzFs $dEnum_XfzFu eta_XkH)
         `cast` (<Int>_R ->_R Sym (Data.Semigroup.N:Min[0] <a_XfzFs>_R)
                 :: (Int -> a_XfzFs :: *) ~R# (Int -> Min a_XfzFs :: *)))
        (\ (eta_XkF :: Min a_XfzFs) ->
           fromEnum
             @ a_XfzFs
             $dEnum_XfzFu
             (eta_XkF
              `cast` (Data.Semigroup.N:Min[0] <a_XfzFs>_R
                      :: (Min a_XfzFs :: *) ~R# (a_XfzFs :: *))))
        ((\ (ds_XfAeE :: Min a_XfzFs) ->
            enumFrom
              @ a_XfzFs
              $dEnum_XfzFu
              (ds_XfAeE
               `cast` (Data.Semigroup.N:Min[0] <a_XfzFs>_R
                       :: (Min a_XfzFs :: *) ~R# (a_XfzFs :: *))))
         `cast` (<Min a_XfzFs>_R
                 ->_R ([Sym (Data.Semigroup.N:Min[0] <a_XfzFs>_R)])_R
                 :: (Min a_XfzFs -> [a_XfzFs] :: *)
                    ~R# (Min a_XfzFs -> [Min a_XfzFs] :: *)))
        ((\ (ds_XfAeI :: Min a_XfzFs) (ds1_XfAeK :: Min a_XfzFs) ->
            enumFromThen
              @ a_XfzFs
              $dEnum_XfzFu
              (ds_XfAeI
               `cast` (Data.Semigroup.N:Min[0] <a_XfzFs>_R
                       :: (Min a_XfzFs :: *) ~R# (a_XfzFs :: *)))
              (ds1_XfAeK
               `cast` (Data.Semigroup.N:Min[0] <a_XfzFs>_R
                       :: (Min a_XfzFs :: *) ~R# (a_XfzFs :: *))))
         `cast` (<Min a_XfzFs>_R
                 ->_R <Min a_XfzFs>_R
                 ->_R ([Sym (Data.Semigroup.N:Min[0] <a_XfzFs>_R)])_R
                 :: (Min a_XfzFs -> Min a_XfzFs -> [a_XfzFs] :: *)
                    ~R# (Min a_XfzFs -> Min a_XfzFs -> [Min a_XfzFs] :: *)))
        ((\ (ds_XfAeP :: Min a_XfzFs) (ds1_XfAeR :: Min a_XfzFs) ->
            enumFromTo
              @ a_XfzFs
              $dEnum_XfzFu
              (ds_XfAeP
               `cast` (Data.Semigroup.N:Min[0] <a_XfzFs>_R
                       :: (Min a_XfzFs :: *) ~R# (a_XfzFs :: *)))
              (ds1_XfAeR
               `cast` (Data.Semigroup.N:Min[0] <a_XfzFs>_R
                       :: (Min a_XfzFs :: *) ~R# (a_XfzFs :: *))))
         `cast` (<Min a_XfzFs>_R
                 ->_R <Min a_XfzFs>_R
                 ->_R ([Sym (Data.Semigroup.N:Min[0] <a_XfzFs>_R)])_R
                 :: (Min a_XfzFs -> Min a_XfzFs -> [a_XfzFs] :: *)
                    ~R# (Min a_XfzFs -> Min a_XfzFs -> [Min a_XfzFs] :: *)))
        ((\ (ds_XfAeW :: Min a_XfzFs)
            (ds1_XfAeY :: Min a_XfzFs)
            (ds2_XfAf0 :: Min a_XfzFs) ->
            enumFromThenTo
              @ a_XfzFs
              $dEnum_XfzFu
              (ds_XfAeW
               `cast` (Data.Semigroup.N:Min[0] <a_XfzFs>_R
                       :: (Min a_XfzFs :: *) ~R# (a_XfzFs :: *)))
              (ds1_XfAeY
               `cast` (Data.Semigroup.N:Min[0] <a_XfzFs>_R
                       :: (Min a_XfzFs :: *) ~R# (a_XfzFs :: *)))
              (ds2_XfAf0
               `cast` (Data.Semigroup.N:Min[0] <a_XfzFs>_R
                       :: (Min a_XfzFs :: *) ~R# (a_XfzFs :: *))))
         `cast` (<Min a_XfzFs>_R
                 ->_R <Min a_XfzFs>_R
                 ->_R <Min a_XfzFs>_R
                 ->_R ([Sym (Data.Semigroup.N:Min[0] <a_XfzFs>_R)])_R
                 :: (Min a_XfzFs -> Min a_XfzFs -> Min a_XfzFs -> [a_XfzFs] :: *)
                    ~R# (Min a_XfzFs
                         -> Min a_XfzFs -> Min a_XfzFs -> [Min a_XfzFs] :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
getMax :: forall a. Max a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Semigroup.$fGeneric1Max2
               `cast` (forall (a :: <*>_N).
                       <Max a>_R ->_R Data.Semigroup.N:Max[0] <a>_R
                       :: (forall a. Max a -> Max a :: *)
                          ~R# (forall a. Max a -> a :: *))}]
getMax
  = Data.Semigroup.$fGeneric1Max2
    `cast` (forall (a :: <*>_N).
            <Max a>_R ->_R Data.Semigroup.N:Max[0] <a>_R
            :: (forall a. Max a -> Max a :: *) ~R# (forall a. Max a -> a :: *))

-- RHS size: {terms: 6, types: 7, coercions: 2, joins: 0/1}
Data.Semigroup.$fMonadFixMax_$cmfix
  :: forall a. (a -> Max a) -> Max a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<C(S),C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afz0T)
                 (f_afwOr [Occ=Once!] :: a_afz0T -> Max a_afz0T) ->
                 letrec {
                   x_sfAfg [Occ=LoopBreaker] :: Max a_afz0T
                   [LclId]
                   x_sfAfg
                     = f_afwOr
                         (x_sfAfg
                          `cast` (Data.Semigroup.N:Max[0] <a_afz0T>_R
                                  :: (Max a_afz0T :: *) ~R# (a_afz0T :: *))); } in
                 x_sfAfg}]
Data.Semigroup.$fMonadFixMax_$cmfix
  = \ (@ a_afz0T) (f_afwOr :: a_afz0T -> Max a_afz0T) ->
      letrec {
        x_sfAfg [Occ=LoopBreaker] :: Max a_afz0T
        [LclId]
        x_sfAfg
          = f_afwOr
              (x_sfAfg
               `cast` (Data.Semigroup.N:Max[0] <a_afz0T>_R
                       :: (Max a_afz0T :: *) ~R# (a_afz0T :: *))); } in
      x_sfAfg

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Semigroup.$fMonadFixMax [InlPrag=NOUSERINLINE CONLIKE]
  :: MonadFix Max
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Control.Monad.Fix.C:MonadFix TYPE: Max
                                    Data.Semigroup.$fMonadMax
                                    Data.Semigroup.$fMonadFixMax_$cmfix]
Data.Semigroup.$fMonadFixMax
  = Control.Monad.Fix.C:MonadFix
      @ Max Data.Semigroup.$fMonadMax Data.Semigroup.$fMonadFixMax_$cmfix

-- RHS size: {terms: 43, types: 37, coercions: 79, joins: 0/0}
Data.Semigroup.$fEnumMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Enum a => Enum (Max a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m,
 Unf=DFun: \ (@ a_afwOE) (v_XpW :: Enum a_afwOE) ->
       GHC.Enum.C:Enum TYPE: Max a_afwOE
                       (\ (ds_XfAdE [Occ=Once] :: Max a_afwOE) ->
                          succ
                            @ a_afwOE
                            v_XpW
                            (ds_XfAdE
                             `cast` (Data.Semigroup.N:Max[0] <a_afwOE>_R
                                     :: (Max a_afwOE :: *) ~R# (a_afwOE :: *))))
                       `cast` (<Max a_afwOE>_R
                               ->_R Sym (Data.Semigroup.N:Max[0] <a_afwOE>_R)
                               :: (Max a_afwOE -> a_afwOE :: *)
                                  ~R# (Max a_afwOE -> Max a_afwOE :: *))
                       (\ (ds_XfAdI [Occ=Once] :: Max a_afwOE) ->
                          pred
                            @ a_afwOE
                            v_XpW
                            (ds_XfAdI
                             `cast` (Data.Semigroup.N:Max[0] <a_afwOE>_R
                                     :: (Max a_afwOE :: *) ~R# (a_afwOE :: *))))
                       `cast` (<Max a_afwOE>_R
                               ->_R Sym (Data.Semigroup.N:Max[0] <a_afwOE>_R)
                               :: (Max a_afwOE -> a_afwOE :: *)
                                  ~R# (Max a_afwOE -> Max a_afwOE :: *))
                       (\ (eta_Xxe [Occ=Once] :: Int) -> toEnum @ a_afwOE v_XpW eta_Xxe)
                       `cast` (<Int>_R ->_R Sym (Data.Semigroup.N:Max[0] <a_afwOE>_R)
                               :: (Int -> a_afwOE :: *) ~R# (Int -> Max a_afwOE :: *))
                       \ (eta_XkL [Occ=Once] :: Max a_afwOE) ->
                         fromEnum
                           @ a_afwOE
                           v_XpW
                           (eta_XkL
                            `cast` (Data.Semigroup.N:Max[0] <a_afwOE>_R
                                    :: (Max a_afwOE :: *) ~R# (a_afwOE :: *)))
                       (\ (ds_XfAcV [Occ=Once] :: Max a_afwOE) ->
                          enumFrom
                            @ a_afwOE
                            v_XpW
                            (ds_XfAcV
                             `cast` (Data.Semigroup.N:Max[0] <a_afwOE>_R
                                     :: (Max a_afwOE :: *) ~R# (a_afwOE :: *))))
                       `cast` (<Max a_afwOE>_R
                               ->_R ([Sym (Data.Semigroup.N:Max[0] <a_afwOE>_R)])_R
                               :: (Max a_afwOE -> [a_afwOE] :: *)
                                  ~R# (Max a_afwOE -> [Max a_afwOE] :: *))
                       (\ (ds_XfAcZ [Occ=Once] :: Max a_afwOE)
                          (ds1_XfAd1 [Occ=Once] :: Max a_afwOE) ->
                          enumFromThen
                            @ a_afwOE
                            v_XpW
                            (ds_XfAcZ
                             `cast` (Data.Semigroup.N:Max[0] <a_afwOE>_R
                                     :: (Max a_afwOE :: *) ~R# (a_afwOE :: *)))
                            (ds1_XfAd1
                             `cast` (Data.Semigroup.N:Max[0] <a_afwOE>_R
                                     :: (Max a_afwOE :: *) ~R# (a_afwOE :: *))))
                       `cast` (<Max a_afwOE>_R
                               ->_R <Max a_afwOE>_R
                               ->_R ([Sym (Data.Semigroup.N:Max[0] <a_afwOE>_R)])_R
                               :: (Max a_afwOE -> Max a_afwOE -> [a_afwOE] :: *)
                                  ~R# (Max a_afwOE -> Max a_afwOE -> [Max a_afwOE] :: *))
                       (\ (ds_XfAd6 [Occ=Once] :: Max a_afwOE)
                          (ds1_XfAd8 [Occ=Once] :: Max a_afwOE) ->
                          enumFromTo
                            @ a_afwOE
                            v_XpW
                            (ds_XfAd6
                             `cast` (Data.Semigroup.N:Max[0] <a_afwOE>_R
                                     :: (Max a_afwOE :: *) ~R# (a_afwOE :: *)))
                            (ds1_XfAd8
                             `cast` (Data.Semigroup.N:Max[0] <a_afwOE>_R
                                     :: (Max a_afwOE :: *) ~R# (a_afwOE :: *))))
                       `cast` (<Max a_afwOE>_R
                               ->_R <Max a_afwOE>_R
                               ->_R ([Sym (Data.Semigroup.N:Max[0] <a_afwOE>_R)])_R
                               :: (Max a_afwOE -> Max a_afwOE -> [a_afwOE] :: *)
                                  ~R# (Max a_afwOE -> Max a_afwOE -> [Max a_afwOE] :: *))
                       (\ (ds_XfAdd [Occ=Once] :: Max a_afwOE)
                          (ds1_XfAdf [Occ=Once] :: Max a_afwOE)
                          (ds2_XfAdh [Occ=Once] :: Max a_afwOE) ->
                          enumFromThenTo
                            @ a_afwOE
                            v_XpW
                            (ds_XfAdd
                             `cast` (Data.Semigroup.N:Max[0] <a_afwOE>_R
                                     :: (Max a_afwOE :: *) ~R# (a_afwOE :: *)))
                            (ds1_XfAdf
                             `cast` (Data.Semigroup.N:Max[0] <a_afwOE>_R
                                     :: (Max a_afwOE :: *) ~R# (a_afwOE :: *)))
                            (ds2_XfAdh
                             `cast` (Data.Semigroup.N:Max[0] <a_afwOE>_R
                                     :: (Max a_afwOE :: *) ~R# (a_afwOE :: *))))
                       `cast` (<Max a_afwOE>_R
                               ->_R <Max a_afwOE>_R
                               ->_R <Max a_afwOE>_R
                               ->_R ([Sym (Data.Semigroup.N:Max[0] <a_afwOE>_R)])_R
                               :: (Max a_afwOE -> Max a_afwOE -> Max a_afwOE -> [a_afwOE] :: *)
                                  ~R# (Max a_afwOE
                                       -> Max a_afwOE -> Max a_afwOE -> [Max a_afwOE] :: *))]
Data.Semigroup.$fEnumMax
  = \ (@ a_Xfzx1) ($dEnum_Xfzx3 :: Enum a_Xfzx1) ->
      GHC.Enum.C:Enum
        @ (Max a_Xfzx1)
        ((\ (ds_XfAdE :: Max a_Xfzx1) ->
            succ
              @ a_Xfzx1
              $dEnum_Xfzx3
              (ds_XfAdE
               `cast` (Data.Semigroup.N:Max[0] <a_Xfzx1>_R
                       :: (Max a_Xfzx1 :: *) ~R# (a_Xfzx1 :: *))))
         `cast` (<Max a_Xfzx1>_R
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_Xfzx1>_R)
                 :: (Max a_Xfzx1 -> a_Xfzx1 :: *)
                    ~R# (Max a_Xfzx1 -> Max a_Xfzx1 :: *)))
        ((\ (ds_XfAdI :: Max a_Xfzx1) ->
            pred
              @ a_Xfzx1
              $dEnum_Xfzx3
              (ds_XfAdI
               `cast` (Data.Semigroup.N:Max[0] <a_Xfzx1>_R
                       :: (Max a_Xfzx1 :: *) ~R# (a_Xfzx1 :: *))))
         `cast` (<Max a_Xfzx1>_R
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_Xfzx1>_R)
                 :: (Max a_Xfzx1 -> a_Xfzx1 :: *)
                    ~R# (Max a_Xfzx1 -> Max a_Xfzx1 :: *)))
        ((\ (eta_Xxe :: Int) -> toEnum @ a_Xfzx1 $dEnum_Xfzx3 eta_Xxe)
         `cast` (<Int>_R ->_R Sym (Data.Semigroup.N:Max[0] <a_Xfzx1>_R)
                 :: (Int -> a_Xfzx1 :: *) ~R# (Int -> Max a_Xfzx1 :: *)))
        (\ (eta_XkL :: Max a_Xfzx1) ->
           fromEnum
             @ a_Xfzx1
             $dEnum_Xfzx3
             (eta_XkL
              `cast` (Data.Semigroup.N:Max[0] <a_Xfzx1>_R
                      :: (Max a_Xfzx1 :: *) ~R# (a_Xfzx1 :: *))))
        ((\ (ds_XfAcV :: Max a_Xfzx1) ->
            enumFrom
              @ a_Xfzx1
              $dEnum_Xfzx3
              (ds_XfAcV
               `cast` (Data.Semigroup.N:Max[0] <a_Xfzx1>_R
                       :: (Max a_Xfzx1 :: *) ~R# (a_Xfzx1 :: *))))
         `cast` (<Max a_Xfzx1>_R
                 ->_R ([Sym (Data.Semigroup.N:Max[0] <a_Xfzx1>_R)])_R
                 :: (Max a_Xfzx1 -> [a_Xfzx1] :: *)
                    ~R# (Max a_Xfzx1 -> [Max a_Xfzx1] :: *)))
        ((\ (ds_XfAcZ :: Max a_Xfzx1) (ds1_XfAd1 :: Max a_Xfzx1) ->
            enumFromThen
              @ a_Xfzx1
              $dEnum_Xfzx3
              (ds_XfAcZ
               `cast` (Data.Semigroup.N:Max[0] <a_Xfzx1>_R
                       :: (Max a_Xfzx1 :: *) ~R# (a_Xfzx1 :: *)))
              (ds1_XfAd1
               `cast` (Data.Semigroup.N:Max[0] <a_Xfzx1>_R
                       :: (Max a_Xfzx1 :: *) ~R# (a_Xfzx1 :: *))))
         `cast` (<Max a_Xfzx1>_R
                 ->_R <Max a_Xfzx1>_R
                 ->_R ([Sym (Data.Semigroup.N:Max[0] <a_Xfzx1>_R)])_R
                 :: (Max a_Xfzx1 -> Max a_Xfzx1 -> [a_Xfzx1] :: *)
                    ~R# (Max a_Xfzx1 -> Max a_Xfzx1 -> [Max a_Xfzx1] :: *)))
        ((\ (ds_XfAd6 :: Max a_Xfzx1) (ds1_XfAd8 :: Max a_Xfzx1) ->
            enumFromTo
              @ a_Xfzx1
              $dEnum_Xfzx3
              (ds_XfAd6
               `cast` (Data.Semigroup.N:Max[0] <a_Xfzx1>_R
                       :: (Max a_Xfzx1 :: *) ~R# (a_Xfzx1 :: *)))
              (ds1_XfAd8
               `cast` (Data.Semigroup.N:Max[0] <a_Xfzx1>_R
                       :: (Max a_Xfzx1 :: *) ~R# (a_Xfzx1 :: *))))
         `cast` (<Max a_Xfzx1>_R
                 ->_R <Max a_Xfzx1>_R
                 ->_R ([Sym (Data.Semigroup.N:Max[0] <a_Xfzx1>_R)])_R
                 :: (Max a_Xfzx1 -> Max a_Xfzx1 -> [a_Xfzx1] :: *)
                    ~R# (Max a_Xfzx1 -> Max a_Xfzx1 -> [Max a_Xfzx1] :: *)))
        ((\ (ds_XfAdd :: Max a_Xfzx1)
            (ds1_XfAdf :: Max a_Xfzx1)
            (ds2_XfAdh :: Max a_Xfzx1) ->
            enumFromThenTo
              @ a_Xfzx1
              $dEnum_Xfzx3
              (ds_XfAdd
               `cast` (Data.Semigroup.N:Max[0] <a_Xfzx1>_R
                       :: (Max a_Xfzx1 :: *) ~R# (a_Xfzx1 :: *)))
              (ds1_XfAdf
               `cast` (Data.Semigroup.N:Max[0] <a_Xfzx1>_R
                       :: (Max a_Xfzx1 :: *) ~R# (a_Xfzx1 :: *)))
              (ds2_XfAdh
               `cast` (Data.Semigroup.N:Max[0] <a_Xfzx1>_R
                       :: (Max a_Xfzx1 :: *) ~R# (a_Xfzx1 :: *))))
         `cast` (<Max a_Xfzx1>_R
                 ->_R <Max a_Xfzx1>_R
                 ->_R <Max a_Xfzx1>_R
                 ->_R ([Sym (Data.Semigroup.N:Max[0] <a_Xfzx1>_R)])_R
                 :: (Max a_Xfzx1 -> Max a_Xfzx1 -> Max a_Xfzx1 -> [a_Xfzx1] :: *)
                    ~R# (Max a_Xfzx1
                         -> Max a_Xfzx1 -> Max a_Xfzx1 -> [Max a_Xfzx1] :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
getFirst :: forall a. First a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Semigroup.$fGeneric1First2
               `cast` (forall (a :: <*>_N).
                       <First a>_R ->_R Data.Semigroup.N:First[0] <a>_R
                       :: (forall a. First a -> First a :: *)
                          ~R# (forall a. First a -> a :: *))}]
getFirst
  = Data.Semigroup.$fGeneric1First2
    `cast` (forall (a :: <*>_N).
            <First a>_R ->_R Data.Semigroup.N:First[0] <a>_R
            :: (forall a. First a -> First a :: *)
               ~R# (forall a. First a -> a :: *))

-- RHS size: {terms: 6, types: 7, coercions: 2, joins: 0/1}
Data.Semigroup.$fMonadFixFirst_$cmfix
  :: forall a. (a -> First a) -> First a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<C(S),C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyMj)
                 (f_afwNf [Occ=Once!] :: a_afyMj -> First a_afyMj) ->
                 letrec {
                   x_sfAfe [Occ=LoopBreaker] :: First a_afyMj
                   [LclId]
                   x_sfAfe
                     = f_afwNf
                         (x_sfAfe
                          `cast` (Data.Semigroup.N:First[0] <a_afyMj>_R
                                  :: (First a_afyMj :: *) ~R# (a_afyMj :: *))); } in
                 x_sfAfe}]
Data.Semigroup.$fMonadFixFirst_$cmfix
  = \ (@ a_afyMj) (f_afwNf :: a_afyMj -> First a_afyMj) ->
      letrec {
        x_sfAfe [Occ=LoopBreaker] :: First a_afyMj
        [LclId]
        x_sfAfe
          = f_afwNf
              (x_sfAfe
               `cast` (Data.Semigroup.N:First[0] <a_afyMj>_R
                       :: (First a_afyMj :: *) ~R# (a_afyMj :: *))); } in
      x_sfAfe

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Semigroup.$fMonadFixFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: MonadFix First
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Control.Monad.Fix.C:MonadFix TYPE: First
                                    Data.Semigroup.$fMonadFirst
                                    Data.Semigroup.$fMonadFixFirst_$cmfix]
Data.Semigroup.$fMonadFixFirst
  = Control.Monad.Fix.C:MonadFix
      @ First
      Data.Semigroup.$fMonadFirst
      Data.Semigroup.$fMonadFixFirst_$cmfix

-- RHS size: {terms: 43, types: 37, coercions: 79, joins: 0/0}
Data.Semigroup.$fEnumFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Enum a => Enum (First a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m,
 Unf=DFun: \ (@ a_afwNt) (v_Xq4 :: Enum a_afwNt) ->
       GHC.Enum.C:Enum TYPE: First a_afwNt
                       (\ (ds_XfAar [Occ=Once] :: First a_afwNt) ->
                          succ
                            @ a_afwNt
                            v_Xq4
                            (ds_XfAar
                             `cast` (Data.Semigroup.N:First[0] <a_afwNt>_R
                                     :: (First a_afwNt :: *) ~R# (a_afwNt :: *))))
                       `cast` (<First a_afwNt>_R
                               ->_R Sym (Data.Semigroup.N:First[0] <a_afwNt>_R)
                               :: (First a_afwNt -> a_afwNt :: *)
                                  ~R# (First a_afwNt -> First a_afwNt :: *))
                       (\ (ds_XfAav [Occ=Once] :: First a_afwNt) ->
                          pred
                            @ a_afwNt
                            v_Xq4
                            (ds_XfAav
                             `cast` (Data.Semigroup.N:First[0] <a_afwNt>_R
                                     :: (First a_afwNt :: *) ~R# (a_afwNt :: *))))
                       `cast` (<First a_afwNt>_R
                               ->_R Sym (Data.Semigroup.N:First[0] <a_afwNt>_R)
                               :: (First a_afwNt -> a_afwNt :: *)
                                  ~R# (First a_afwNt -> First a_afwNt :: *))
                       (\ (eta_XzA [Occ=Once] :: Int) -> toEnum @ a_afwNt v_Xq4 eta_XzA)
                       `cast` (<Int>_R ->_R Sym (Data.Semigroup.N:First[0] <a_afwNt>_R)
                               :: (Int -> a_afwNt :: *) ~R# (Int -> First a_afwNt :: *))
                       \ (eta_XkR [Occ=Once] :: First a_afwNt) ->
                         fromEnum
                           @ a_afwNt
                           v_Xq4
                           (eta_XkR
                            `cast` (Data.Semigroup.N:First[0] <a_afwNt>_R
                                    :: (First a_afwNt :: *) ~R# (a_afwNt :: *)))
                       (\ (ds_XfA9F [Occ=Once] :: First a_afwNt) ->
                          enumFrom
                            @ a_afwNt
                            v_Xq4
                            (ds_XfA9F
                             `cast` (Data.Semigroup.N:First[0] <a_afwNt>_R
                                     :: (First a_afwNt :: *) ~R# (a_afwNt :: *))))
                       `cast` (<First a_afwNt>_R
                               ->_R ([Sym (Data.Semigroup.N:First[0] <a_afwNt>_R)])_R
                               :: (First a_afwNt -> [a_afwNt] :: *)
                                  ~R# (First a_afwNt -> [First a_afwNt] :: *))
                       (\ (ds_XfA9J [Occ=Once] :: First a_afwNt)
                          (ds1_XfA9L [Occ=Once] :: First a_afwNt) ->
                          enumFromThen
                            @ a_afwNt
                            v_Xq4
                            (ds_XfA9J
                             `cast` (Data.Semigroup.N:First[0] <a_afwNt>_R
                                     :: (First a_afwNt :: *) ~R# (a_afwNt :: *)))
                            (ds1_XfA9L
                             `cast` (Data.Semigroup.N:First[0] <a_afwNt>_R
                                     :: (First a_afwNt :: *) ~R# (a_afwNt :: *))))
                       `cast` (<First a_afwNt>_R
                               ->_R <First a_afwNt>_R
                               ->_R ([Sym (Data.Semigroup.N:First[0] <a_afwNt>_R)])_R
                               :: (First a_afwNt -> First a_afwNt -> [a_afwNt] :: *)
                                  ~R# (First a_afwNt -> First a_afwNt -> [First a_afwNt] :: *))
                       (\ (ds_XfA9Q [Occ=Once] :: First a_afwNt)
                          (ds1_XfA9S [Occ=Once] :: First a_afwNt) ->
                          enumFromTo
                            @ a_afwNt
                            v_Xq4
                            (ds_XfA9Q
                             `cast` (Data.Semigroup.N:First[0] <a_afwNt>_R
                                     :: (First a_afwNt :: *) ~R# (a_afwNt :: *)))
                            (ds1_XfA9S
                             `cast` (Data.Semigroup.N:First[0] <a_afwNt>_R
                                     :: (First a_afwNt :: *) ~R# (a_afwNt :: *))))
                       `cast` (<First a_afwNt>_R
                               ->_R <First a_afwNt>_R
                               ->_R ([Sym (Data.Semigroup.N:First[0] <a_afwNt>_R)])_R
                               :: (First a_afwNt -> First a_afwNt -> [a_afwNt] :: *)
                                  ~R# (First a_afwNt -> First a_afwNt -> [First a_afwNt] :: *))
                       (\ (ds_XfA9X [Occ=Once] :: First a_afwNt)
                          (ds1_XfA9Z [Occ=Once] :: First a_afwNt)
                          (ds2_XfAa1 [Occ=Once] :: First a_afwNt) ->
                          enumFromThenTo
                            @ a_afwNt
                            v_Xq4
                            (ds_XfA9X
                             `cast` (Data.Semigroup.N:First[0] <a_afwNt>_R
                                     :: (First a_afwNt :: *) ~R# (a_afwNt :: *)))
                            (ds1_XfA9Z
                             `cast` (Data.Semigroup.N:First[0] <a_afwNt>_R
                                     :: (First a_afwNt :: *) ~R# (a_afwNt :: *)))
                            (ds2_XfAa1
                             `cast` (Data.Semigroup.N:First[0] <a_afwNt>_R
                                     :: (First a_afwNt :: *) ~R# (a_afwNt :: *))))
                       `cast` (<First a_afwNt>_R
                               ->_R <First a_afwNt>_R
                               ->_R <First a_afwNt>_R
                               ->_R ([Sym (Data.Semigroup.N:First[0] <a_afwNt>_R)])_R
                               :: (First a_afwNt
                                   -> First a_afwNt -> First a_afwNt -> [a_afwNt] :: *)
                                  ~R# (First a_afwNt
                                       -> First a_afwNt -> First a_afwNt -> [First a_afwNt] :: *))]
Data.Semigroup.$fEnumFirst
  = \ (@ a_XfzhV) ($dEnum_XfzhX :: Enum a_XfzhV) ->
      GHC.Enum.C:Enum
        @ (First a_XfzhV)
        ((\ (ds_XfAar :: First a_XfzhV) ->
            succ
              @ a_XfzhV
              $dEnum_XfzhX
              (ds_XfAar
               `cast` (Data.Semigroup.N:First[0] <a_XfzhV>_R
                       :: (First a_XfzhV :: *) ~R# (a_XfzhV :: *))))
         `cast` (<First a_XfzhV>_R
                 ->_R Sym (Data.Semigroup.N:First[0] <a_XfzhV>_R)
                 :: (First a_XfzhV -> a_XfzhV :: *)
                    ~R# (First a_XfzhV -> First a_XfzhV :: *)))
        ((\ (ds_XfAav :: First a_XfzhV) ->
            pred
              @ a_XfzhV
              $dEnum_XfzhX
              (ds_XfAav
               `cast` (Data.Semigroup.N:First[0] <a_XfzhV>_R
                       :: (First a_XfzhV :: *) ~R# (a_XfzhV :: *))))
         `cast` (<First a_XfzhV>_R
                 ->_R Sym (Data.Semigroup.N:First[0] <a_XfzhV>_R)
                 :: (First a_XfzhV -> a_XfzhV :: *)
                    ~R# (First a_XfzhV -> First a_XfzhV :: *)))
        ((\ (eta_XzA :: Int) -> toEnum @ a_XfzhV $dEnum_XfzhX eta_XzA)
         `cast` (<Int>_R ->_R Sym (Data.Semigroup.N:First[0] <a_XfzhV>_R)
                 :: (Int -> a_XfzhV :: *) ~R# (Int -> First a_XfzhV :: *)))
        (\ (eta_XkR :: First a_XfzhV) ->
           fromEnum
             @ a_XfzhV
             $dEnum_XfzhX
             (eta_XkR
              `cast` (Data.Semigroup.N:First[0] <a_XfzhV>_R
                      :: (First a_XfzhV :: *) ~R# (a_XfzhV :: *))))
        ((\ (ds_XfA9F :: First a_XfzhV) ->
            enumFrom
              @ a_XfzhV
              $dEnum_XfzhX
              (ds_XfA9F
               `cast` (Data.Semigroup.N:First[0] <a_XfzhV>_R
                       :: (First a_XfzhV :: *) ~R# (a_XfzhV :: *))))
         `cast` (<First a_XfzhV>_R
                 ->_R ([Sym (Data.Semigroup.N:First[0] <a_XfzhV>_R)])_R
                 :: (First a_XfzhV -> [a_XfzhV] :: *)
                    ~R# (First a_XfzhV -> [First a_XfzhV] :: *)))
        ((\ (ds_XfA9J :: First a_XfzhV) (ds1_XfA9L :: First a_XfzhV) ->
            enumFromThen
              @ a_XfzhV
              $dEnum_XfzhX
              (ds_XfA9J
               `cast` (Data.Semigroup.N:First[0] <a_XfzhV>_R
                       :: (First a_XfzhV :: *) ~R# (a_XfzhV :: *)))
              (ds1_XfA9L
               `cast` (Data.Semigroup.N:First[0] <a_XfzhV>_R
                       :: (First a_XfzhV :: *) ~R# (a_XfzhV :: *))))
         `cast` (<First a_XfzhV>_R
                 ->_R <First a_XfzhV>_R
                 ->_R ([Sym (Data.Semigroup.N:First[0] <a_XfzhV>_R)])_R
                 :: (First a_XfzhV -> First a_XfzhV -> [a_XfzhV] :: *)
                    ~R# (First a_XfzhV -> First a_XfzhV -> [First a_XfzhV] :: *)))
        ((\ (ds_XfA9Q :: First a_XfzhV) (ds1_XfA9S :: First a_XfzhV) ->
            enumFromTo
              @ a_XfzhV
              $dEnum_XfzhX
              (ds_XfA9Q
               `cast` (Data.Semigroup.N:First[0] <a_XfzhV>_R
                       :: (First a_XfzhV :: *) ~R# (a_XfzhV :: *)))
              (ds1_XfA9S
               `cast` (Data.Semigroup.N:First[0] <a_XfzhV>_R
                       :: (First a_XfzhV :: *) ~R# (a_XfzhV :: *))))
         `cast` (<First a_XfzhV>_R
                 ->_R <First a_XfzhV>_R
                 ->_R ([Sym (Data.Semigroup.N:First[0] <a_XfzhV>_R)])_R
                 :: (First a_XfzhV -> First a_XfzhV -> [a_XfzhV] :: *)
                    ~R# (First a_XfzhV -> First a_XfzhV -> [First a_XfzhV] :: *)))
        ((\ (ds_XfA9X :: First a_XfzhV)
            (ds1_XfA9Z :: First a_XfzhV)
            (ds2_XfAa1 :: First a_XfzhV) ->
            enumFromThenTo
              @ a_XfzhV
              $dEnum_XfzhX
              (ds_XfA9X
               `cast` (Data.Semigroup.N:First[0] <a_XfzhV>_R
                       :: (First a_XfzhV :: *) ~R# (a_XfzhV :: *)))
              (ds1_XfA9Z
               `cast` (Data.Semigroup.N:First[0] <a_XfzhV>_R
                       :: (First a_XfzhV :: *) ~R# (a_XfzhV :: *)))
              (ds2_XfAa1
               `cast` (Data.Semigroup.N:First[0] <a_XfzhV>_R
                       :: (First a_XfzhV :: *) ~R# (a_XfzhV :: *))))
         `cast` (<First a_XfzhV>_R
                 ->_R <First a_XfzhV>_R
                 ->_R <First a_XfzhV>_R
                 ->_R ([Sym (Data.Semigroup.N:First[0] <a_XfzhV>_R)])_R
                 :: (First a_XfzhV
                     -> First a_XfzhV -> First a_XfzhV -> [a_XfzhV] :: *)
                    ~R# (First a_XfzhV
                         -> First a_XfzhV -> First a_XfzhV -> [First a_XfzhV] :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
getLast :: forall a. Last a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Semigroup.$fGeneric1Last2
               `cast` (forall (a :: <*>_N).
                       <Last a>_R ->_R Data.Semigroup.N:Last[0] <a>_R
                       :: (forall a. Last a -> Last a :: *)
                          ~R# (forall a. Last a -> a :: *))}]
getLast
  = Data.Semigroup.$fGeneric1Last2
    `cast` (forall (a :: <*>_N).
            <Last a>_R ->_R Data.Semigroup.N:Last[0] <a>_R
            :: (forall a. Last a -> Last a :: *)
               ~R# (forall a. Last a -> a :: *))

-- RHS size: {terms: 6, types: 7, coercions: 2, joins: 0/1}
Data.Semigroup.$fMonadFixLast_$cmfix
  :: forall a. (a -> Last a) -> Last a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<C(S),C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyFi)
                 (f_afwMQ [Occ=Once!] :: a_afyFi -> Last a_afyFi) ->
                 letrec {
                   x_sfAfc [Occ=LoopBreaker] :: Last a_afyFi
                   [LclId]
                   x_sfAfc
                     = f_afwMQ
                         (x_sfAfc
                          `cast` (Data.Semigroup.N:Last[0] <a_afyFi>_R
                                  :: (Last a_afyFi :: *) ~R# (a_afyFi :: *))); } in
                 x_sfAfc}]
Data.Semigroup.$fMonadFixLast_$cmfix
  = \ (@ a_afyFi) (f_afwMQ :: a_afyFi -> Last a_afyFi) ->
      letrec {
        x_sfAfc [Occ=LoopBreaker] :: Last a_afyFi
        [LclId]
        x_sfAfc
          = f_afwMQ
              (x_sfAfc
               `cast` (Data.Semigroup.N:Last[0] <a_afyFi>_R
                       :: (Last a_afyFi :: *) ~R# (a_afyFi :: *))); } in
      x_sfAfc

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Semigroup.$fMonadFixLast [InlPrag=NOUSERINLINE CONLIKE]
  :: MonadFix Last
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Control.Monad.Fix.C:MonadFix TYPE: Last
                                    Data.Semigroup.$fMonadLast
                                    Data.Semigroup.$fMonadFixLast_$cmfix]
Data.Semigroup.$fMonadFixLast
  = Control.Monad.Fix.C:MonadFix
      @ Last
      Data.Semigroup.$fMonadLast
      Data.Semigroup.$fMonadFixLast_$cmfix

-- RHS size: {terms: 43, types: 37, coercions: 79, joins: 0/0}
Data.Semigroup.$fEnumLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Enum a => Enum (Last a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m,
 Unf=DFun: \ (@ a_afwN4) (v_Xqc :: Enum a_afwN4) ->
       GHC.Enum.C:Enum TYPE: Last a_afwN4
                       (\ (ds_XfA9l [Occ=Once] :: Last a_afwN4) ->
                          succ
                            @ a_afwN4
                            v_Xqc
                            (ds_XfA9l
                             `cast` (Data.Semigroup.N:Last[0] <a_afwN4>_R
                                     :: (Last a_afwN4 :: *) ~R# (a_afwN4 :: *))))
                       `cast` (<Last a_afwN4>_R
                               ->_R Sym (Data.Semigroup.N:Last[0] <a_afwN4>_R)
                               :: (Last a_afwN4 -> a_afwN4 :: *)
                                  ~R# (Last a_afwN4 -> Last a_afwN4 :: *))
                       (\ (ds_XfA9p [Occ=Once] :: Last a_afwN4) ->
                          pred
                            @ a_afwN4
                            v_Xqc
                            (ds_XfA9p
                             `cast` (Data.Semigroup.N:Last[0] <a_afwN4>_R
                                     :: (Last a_afwN4 :: *) ~R# (a_afwN4 :: *))))
                       `cast` (<Last a_afwN4>_R
                               ->_R Sym (Data.Semigroup.N:Last[0] <a_afwN4>_R)
                               :: (Last a_afwN4 -> a_afwN4 :: *)
                                  ~R# (Last a_afwN4 -> Last a_afwN4 :: *))
                       (\ (eta_XAT [Occ=Once] :: Int) -> toEnum @ a_afwN4 v_Xqc eta_XAT)
                       `cast` (<Int>_R ->_R Sym (Data.Semigroup.N:Last[0] <a_afwN4>_R)
                               :: (Int -> a_afwN4 :: *) ~R# (Int -> Last a_afwN4 :: *))
                       \ (eta_XkX [Occ=Once] :: Last a_afwN4) ->
                         fromEnum
                           @ a_afwN4
                           v_Xqc
                           (eta_XkX
                            `cast` (Data.Semigroup.N:Last[0] <a_afwN4>_R
                                    :: (Last a_afwN4 :: *) ~R# (a_afwN4 :: *)))
                       (\ (ds_XfA8w [Occ=Once] :: Last a_afwN4) ->
                          enumFrom
                            @ a_afwN4
                            v_Xqc
                            (ds_XfA8w
                             `cast` (Data.Semigroup.N:Last[0] <a_afwN4>_R
                                     :: (Last a_afwN4 :: *) ~R# (a_afwN4 :: *))))
                       `cast` (<Last a_afwN4>_R
                               ->_R ([Sym (Data.Semigroup.N:Last[0] <a_afwN4>_R)])_R
                               :: (Last a_afwN4 -> [a_afwN4] :: *)
                                  ~R# (Last a_afwN4 -> [Last a_afwN4] :: *))
                       (\ (ds_XfA8A [Occ=Once] :: Last a_afwN4)
                          (ds1_XfA8C [Occ=Once] :: Last a_afwN4) ->
                          enumFromThen
                            @ a_afwN4
                            v_Xqc
                            (ds_XfA8A
                             `cast` (Data.Semigroup.N:Last[0] <a_afwN4>_R
                                     :: (Last a_afwN4 :: *) ~R# (a_afwN4 :: *)))
                            (ds1_XfA8C
                             `cast` (Data.Semigroup.N:Last[0] <a_afwN4>_R
                                     :: (Last a_afwN4 :: *) ~R# (a_afwN4 :: *))))
                       `cast` (<Last a_afwN4>_R
                               ->_R <Last a_afwN4>_R
                               ->_R ([Sym (Data.Semigroup.N:Last[0] <a_afwN4>_R)])_R
                               :: (Last a_afwN4 -> Last a_afwN4 -> [a_afwN4] :: *)
                                  ~R# (Last a_afwN4 -> Last a_afwN4 -> [Last a_afwN4] :: *))
                       (\ (ds_XfA8H [Occ=Once] :: Last a_afwN4)
                          (ds1_XfA8J [Occ=Once] :: Last a_afwN4) ->
                          enumFromTo
                            @ a_afwN4
                            v_Xqc
                            (ds_XfA8H
                             `cast` (Data.Semigroup.N:Last[0] <a_afwN4>_R
                                     :: (Last a_afwN4 :: *) ~R# (a_afwN4 :: *)))
                            (ds1_XfA8J
                             `cast` (Data.Semigroup.N:Last[0] <a_afwN4>_R
                                     :: (Last a_afwN4 :: *) ~R# (a_afwN4 :: *))))
                       `cast` (<Last a_afwN4>_R
                               ->_R <Last a_afwN4>_R
                               ->_R ([Sym (Data.Semigroup.N:Last[0] <a_afwN4>_R)])_R
                               :: (Last a_afwN4 -> Last a_afwN4 -> [a_afwN4] :: *)
                                  ~R# (Last a_afwN4 -> Last a_afwN4 -> [Last a_afwN4] :: *))
                       (\ (ds_XfA8O [Occ=Once] :: Last a_afwN4)
                          (ds1_XfA8Q [Occ=Once] :: Last a_afwN4)
                          (ds2_XfA8S [Occ=Once] :: Last a_afwN4) ->
                          enumFromThenTo
                            @ a_afwN4
                            v_Xqc
                            (ds_XfA8O
                             `cast` (Data.Semigroup.N:Last[0] <a_afwN4>_R
                                     :: (Last a_afwN4 :: *) ~R# (a_afwN4 :: *)))
                            (ds1_XfA8Q
                             `cast` (Data.Semigroup.N:Last[0] <a_afwN4>_R
                                     :: (Last a_afwN4 :: *) ~R# (a_afwN4 :: *)))
                            (ds2_XfA8S
                             `cast` (Data.Semigroup.N:Last[0] <a_afwN4>_R
                                     :: (Last a_afwN4 :: *) ~R# (a_afwN4 :: *))))
                       `cast` (<Last a_afwN4>_R
                               ->_R <Last a_afwN4>_R
                               ->_R <Last a_afwN4>_R
                               ->_R ([Sym (Data.Semigroup.N:Last[0] <a_afwN4>_R)])_R
                               :: (Last a_afwN4 -> Last a_afwN4 -> Last a_afwN4 -> [a_afwN4] :: *)
                                  ~R# (Last a_afwN4
                                       -> Last a_afwN4 -> Last a_afwN4 -> [Last a_afwN4] :: *))]
Data.Semigroup.$fEnumLast
  = \ (@ a_Xfzb2) ($dEnum_Xfzb4 :: Enum a_Xfzb2) ->
      GHC.Enum.C:Enum
        @ (Last a_Xfzb2)
        ((\ (ds_XfA9l :: Last a_Xfzb2) ->
            succ
              @ a_Xfzb2
              $dEnum_Xfzb4
              (ds_XfA9l
               `cast` (Data.Semigroup.N:Last[0] <a_Xfzb2>_R
                       :: (Last a_Xfzb2 :: *) ~R# (a_Xfzb2 :: *))))
         `cast` (<Last a_Xfzb2>_R
                 ->_R Sym (Data.Semigroup.N:Last[0] <a_Xfzb2>_R)
                 :: (Last a_Xfzb2 -> a_Xfzb2 :: *)
                    ~R# (Last a_Xfzb2 -> Last a_Xfzb2 :: *)))
        ((\ (ds_XfA9p :: Last a_Xfzb2) ->
            pred
              @ a_Xfzb2
              $dEnum_Xfzb4
              (ds_XfA9p
               `cast` (Data.Semigroup.N:Last[0] <a_Xfzb2>_R
                       :: (Last a_Xfzb2 :: *) ~R# (a_Xfzb2 :: *))))
         `cast` (<Last a_Xfzb2>_R
                 ->_R Sym (Data.Semigroup.N:Last[0] <a_Xfzb2>_R)
                 :: (Last a_Xfzb2 -> a_Xfzb2 :: *)
                    ~R# (Last a_Xfzb2 -> Last a_Xfzb2 :: *)))
        ((\ (eta_XAT :: Int) -> toEnum @ a_Xfzb2 $dEnum_Xfzb4 eta_XAT)
         `cast` (<Int>_R ->_R Sym (Data.Semigroup.N:Last[0] <a_Xfzb2>_R)
                 :: (Int -> a_Xfzb2 :: *) ~R# (Int -> Last a_Xfzb2 :: *)))
        (\ (eta_XkX :: Last a_Xfzb2) ->
           fromEnum
             @ a_Xfzb2
             $dEnum_Xfzb4
             (eta_XkX
              `cast` (Data.Semigroup.N:Last[0] <a_Xfzb2>_R
                      :: (Last a_Xfzb2 :: *) ~R# (a_Xfzb2 :: *))))
        ((\ (ds_XfA8w :: Last a_Xfzb2) ->
            enumFrom
              @ a_Xfzb2
              $dEnum_Xfzb4
              (ds_XfA8w
               `cast` (Data.Semigroup.N:Last[0] <a_Xfzb2>_R
                       :: (Last a_Xfzb2 :: *) ~R# (a_Xfzb2 :: *))))
         `cast` (<Last a_Xfzb2>_R
                 ->_R ([Sym (Data.Semigroup.N:Last[0] <a_Xfzb2>_R)])_R
                 :: (Last a_Xfzb2 -> [a_Xfzb2] :: *)
                    ~R# (Last a_Xfzb2 -> [Last a_Xfzb2] :: *)))
        ((\ (ds_XfA8A :: Last a_Xfzb2) (ds1_XfA8C :: Last a_Xfzb2) ->
            enumFromThen
              @ a_Xfzb2
              $dEnum_Xfzb4
              (ds_XfA8A
               `cast` (Data.Semigroup.N:Last[0] <a_Xfzb2>_R
                       :: (Last a_Xfzb2 :: *) ~R# (a_Xfzb2 :: *)))
              (ds1_XfA8C
               `cast` (Data.Semigroup.N:Last[0] <a_Xfzb2>_R
                       :: (Last a_Xfzb2 :: *) ~R# (a_Xfzb2 :: *))))
         `cast` (<Last a_Xfzb2>_R
                 ->_R <Last a_Xfzb2>_R
                 ->_R ([Sym (Data.Semigroup.N:Last[0] <a_Xfzb2>_R)])_R
                 :: (Last a_Xfzb2 -> Last a_Xfzb2 -> [a_Xfzb2] :: *)
                    ~R# (Last a_Xfzb2 -> Last a_Xfzb2 -> [Last a_Xfzb2] :: *)))
        ((\ (ds_XfA8H :: Last a_Xfzb2) (ds1_XfA8J :: Last a_Xfzb2) ->
            enumFromTo
              @ a_Xfzb2
              $dEnum_Xfzb4
              (ds_XfA8H
               `cast` (Data.Semigroup.N:Last[0] <a_Xfzb2>_R
                       :: (Last a_Xfzb2 :: *) ~R# (a_Xfzb2 :: *)))
              (ds1_XfA8J
               `cast` (Data.Semigroup.N:Last[0] <a_Xfzb2>_R
                       :: (Last a_Xfzb2 :: *) ~R# (a_Xfzb2 :: *))))
         `cast` (<Last a_Xfzb2>_R
                 ->_R <Last a_Xfzb2>_R
                 ->_R ([Sym (Data.Semigroup.N:Last[0] <a_Xfzb2>_R)])_R
                 :: (Last a_Xfzb2 -> Last a_Xfzb2 -> [a_Xfzb2] :: *)
                    ~R# (Last a_Xfzb2 -> Last a_Xfzb2 -> [Last a_Xfzb2] :: *)))
        ((\ (ds_XfA8O :: Last a_Xfzb2)
            (ds1_XfA8Q :: Last a_Xfzb2)
            (ds2_XfA8S :: Last a_Xfzb2) ->
            enumFromThenTo
              @ a_Xfzb2
              $dEnum_Xfzb4
              (ds_XfA8O
               `cast` (Data.Semigroup.N:Last[0] <a_Xfzb2>_R
                       :: (Last a_Xfzb2 :: *) ~R# (a_Xfzb2 :: *)))
              (ds1_XfA8Q
               `cast` (Data.Semigroup.N:Last[0] <a_Xfzb2>_R
                       :: (Last a_Xfzb2 :: *) ~R# (a_Xfzb2 :: *)))
              (ds2_XfA8S
               `cast` (Data.Semigroup.N:Last[0] <a_Xfzb2>_R
                       :: (Last a_Xfzb2 :: *) ~R# (a_Xfzb2 :: *))))
         `cast` (<Last a_Xfzb2>_R
                 ->_R <Last a_Xfzb2>_R
                 ->_R <Last a_Xfzb2>_R
                 ->_R ([Sym (Data.Semigroup.N:Last[0] <a_Xfzb2>_R)])_R
                 :: (Last a_Xfzb2 -> Last a_Xfzb2 -> Last a_Xfzb2 -> [a_Xfzb2] :: *)
                    ~R# (Last a_Xfzb2
                         -> Last a_Xfzb2 -> Last a_Xfzb2 -> [Last a_Xfzb2] :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
unwrapMonoid :: forall m. WrappedMonoid m -> m
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Semigroup.$fGeneric1WrappedMonoid2
               `cast` (forall (m :: <*>_N).
                       <WrappedMonoid m>_R ->_R Data.Semigroup.N:WrappedMonoid[0] <m>_R
                       :: (forall m. WrappedMonoid m -> WrappedMonoid m :: *)
                          ~R# (forall m. WrappedMonoid m -> m :: *))}]
unwrapMonoid
  = Data.Semigroup.$fGeneric1WrappedMonoid2
    `cast` (forall (m :: <*>_N).
            <WrappedMonoid m>_R ->_R Data.Semigroup.N:WrappedMonoid[0] <m>_R
            :: (forall m. WrappedMonoid m -> WrappedMonoid m :: *)
               ~R# (forall m. WrappedMonoid m -> m :: *))

-- RHS size: {terms: 43, types: 37, coercions: 79, joins: 0/0}
Data.Semigroup.$fEnumWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Enum a => Enum (WrappedMonoid a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(U),C(U),C(U),C(U),C(U),C(C1(U)),C(C1(U)),C(C1(C1(U))))>m,
 Unf=DFun: \ (@ a_afwMD) (v_Xqi :: Enum a_afwMD) ->
       GHC.Enum.C:Enum TYPE: WrappedMonoid a_afwMD
                       (\ (ds_XfA7U [Occ=Once] :: WrappedMonoid a_afwMD) ->
                          succ
                            @ a_afwMD
                            v_Xqi
                            (ds_XfA7U
                             `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_afwMD>_R
                                     :: (WrappedMonoid a_afwMD :: *) ~R# (a_afwMD :: *))))
                       `cast` (<WrappedMonoid a_afwMD>_R
                               ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <a_afwMD>_R)
                               :: (WrappedMonoid a_afwMD -> a_afwMD :: *)
                                  ~R# (WrappedMonoid a_afwMD -> WrappedMonoid a_afwMD :: *))
                       (\ (ds_XfA7Y [Occ=Once] :: WrappedMonoid a_afwMD) ->
                          pred
                            @ a_afwMD
                            v_Xqi
                            (ds_XfA7Y
                             `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_afwMD>_R
                                     :: (WrappedMonoid a_afwMD :: *) ~R# (a_afwMD :: *))))
                       `cast` (<WrappedMonoid a_afwMD>_R
                               ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <a_afwMD>_R)
                               :: (WrappedMonoid a_afwMD -> a_afwMD :: *)
                                  ~R# (WrappedMonoid a_afwMD -> WrappedMonoid a_afwMD :: *))
                       (\ (eta_XCf [Occ=Once] :: Int) -> toEnum @ a_afwMD v_Xqi eta_XCf)
                       `cast` (<Int>_R
                               ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <a_afwMD>_R)
                               :: (Int -> a_afwMD :: *) ~R# (Int -> WrappedMonoid a_afwMD :: *))
                       \ (eta_Xl1 [Occ=Once] :: WrappedMonoid a_afwMD) ->
                         fromEnum
                           @ a_afwMD
                           v_Xqi
                           (eta_Xl1
                            `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_afwMD>_R
                                    :: (WrappedMonoid a_afwMD :: *) ~R# (a_afwMD :: *)))
                       (\ (ds_XfA72 [Occ=Once] :: WrappedMonoid a_afwMD) ->
                          enumFrom
                            @ a_afwMD
                            v_Xqi
                            (ds_XfA72
                             `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_afwMD>_R
                                     :: (WrappedMonoid a_afwMD :: *) ~R# (a_afwMD :: *))))
                       `cast` (<WrappedMonoid a_afwMD>_R
                               ->_R ([Sym (Data.Semigroup.N:WrappedMonoid[0] <a_afwMD>_R)])_R
                               :: (WrappedMonoid a_afwMD -> [a_afwMD] :: *)
                                  ~R# (WrappedMonoid a_afwMD -> [WrappedMonoid a_afwMD] :: *))
                       (\ (ds_XfA76 [Occ=Once] :: WrappedMonoid a_afwMD)
                          (ds1_XfA78 [Occ=Once] :: WrappedMonoid a_afwMD) ->
                          enumFromThen
                            @ a_afwMD
                            v_Xqi
                            (ds_XfA76
                             `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_afwMD>_R
                                     :: (WrappedMonoid a_afwMD :: *) ~R# (a_afwMD :: *)))
                            (ds1_XfA78
                             `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_afwMD>_R
                                     :: (WrappedMonoid a_afwMD :: *) ~R# (a_afwMD :: *))))
                       `cast` (<WrappedMonoid a_afwMD>_R
                               ->_R <WrappedMonoid a_afwMD>_R
                               ->_R ([Sym (Data.Semigroup.N:WrappedMonoid[0] <a_afwMD>_R)])_R
                               :: (WrappedMonoid a_afwMD
                                   -> WrappedMonoid a_afwMD -> [a_afwMD] :: *)
                                  ~R# (WrappedMonoid a_afwMD
                                       -> WrappedMonoid a_afwMD -> [WrappedMonoid a_afwMD] :: *))
                       (\ (ds_XfA7d [Occ=Once] :: WrappedMonoid a_afwMD)
                          (ds1_XfA7f [Occ=Once] :: WrappedMonoid a_afwMD) ->
                          enumFromTo
                            @ a_afwMD
                            v_Xqi
                            (ds_XfA7d
                             `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_afwMD>_R
                                     :: (WrappedMonoid a_afwMD :: *) ~R# (a_afwMD :: *)))
                            (ds1_XfA7f
                             `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_afwMD>_R
                                     :: (WrappedMonoid a_afwMD :: *) ~R# (a_afwMD :: *))))
                       `cast` (<WrappedMonoid a_afwMD>_R
                               ->_R <WrappedMonoid a_afwMD>_R
                               ->_R ([Sym (Data.Semigroup.N:WrappedMonoid[0] <a_afwMD>_R)])_R
                               :: (WrappedMonoid a_afwMD
                                   -> WrappedMonoid a_afwMD -> [a_afwMD] :: *)
                                  ~R# (WrappedMonoid a_afwMD
                                       -> WrappedMonoid a_afwMD -> [WrappedMonoid a_afwMD] :: *))
                       (\ (ds_XfA7k [Occ=Once] :: WrappedMonoid a_afwMD)
                          (ds1_XfA7m [Occ=Once] :: WrappedMonoid a_afwMD)
                          (ds2_XfA7o [Occ=Once] :: WrappedMonoid a_afwMD) ->
                          enumFromThenTo
                            @ a_afwMD
                            v_Xqi
                            (ds_XfA7k
                             `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_afwMD>_R
                                     :: (WrappedMonoid a_afwMD :: *) ~R# (a_afwMD :: *)))
                            (ds1_XfA7m
                             `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_afwMD>_R
                                     :: (WrappedMonoid a_afwMD :: *) ~R# (a_afwMD :: *)))
                            (ds2_XfA7o
                             `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_afwMD>_R
                                     :: (WrappedMonoid a_afwMD :: *) ~R# (a_afwMD :: *))))
                       `cast` (<WrappedMonoid a_afwMD>_R
                               ->_R <WrappedMonoid a_afwMD>_R
                               ->_R <WrappedMonoid a_afwMD>_R
                               ->_R ([Sym (Data.Semigroup.N:WrappedMonoid[0] <a_afwMD>_R)])_R
                               :: (WrappedMonoid a_afwMD
                                   -> WrappedMonoid a_afwMD
                                   -> WrappedMonoid a_afwMD
                                   -> [a_afwMD] :: *)
                                  ~R# (WrappedMonoid a_afwMD
                                       -> WrappedMonoid a_afwMD
                                       -> WrappedMonoid a_afwMD
                                       -> [WrappedMonoid a_afwMD] :: *))]
Data.Semigroup.$fEnumWrappedMonoid
  = \ (@ a_Xfz37) ($dEnum_Xfz39 :: Enum a_Xfz37) ->
      GHC.Enum.C:Enum
        @ (WrappedMonoid a_Xfz37)
        ((\ (ds_XfA7U :: WrappedMonoid a_Xfz37) ->
            succ
              @ a_Xfz37
              $dEnum_Xfz39
              (ds_XfA7U
               `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_Xfz37>_R
                       :: (WrappedMonoid a_Xfz37 :: *) ~R# (a_Xfz37 :: *))))
         `cast` (<WrappedMonoid a_Xfz37>_R
                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <a_Xfz37>_R)
                 :: (WrappedMonoid a_Xfz37 -> a_Xfz37 :: *)
                    ~R# (WrappedMonoid a_Xfz37 -> WrappedMonoid a_Xfz37 :: *)))
        ((\ (ds_XfA7Y :: WrappedMonoid a_Xfz37) ->
            pred
              @ a_Xfz37
              $dEnum_Xfz39
              (ds_XfA7Y
               `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_Xfz37>_R
                       :: (WrappedMonoid a_Xfz37 :: *) ~R# (a_Xfz37 :: *))))
         `cast` (<WrappedMonoid a_Xfz37>_R
                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <a_Xfz37>_R)
                 :: (WrappedMonoid a_Xfz37 -> a_Xfz37 :: *)
                    ~R# (WrappedMonoid a_Xfz37 -> WrappedMonoid a_Xfz37 :: *)))
        ((\ (eta_XCf :: Int) -> toEnum @ a_Xfz37 $dEnum_Xfz39 eta_XCf)
         `cast` (<Int>_R
                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <a_Xfz37>_R)
                 :: (Int -> a_Xfz37 :: *) ~R# (Int -> WrappedMonoid a_Xfz37 :: *)))
        (\ (eta_Xl1 :: WrappedMonoid a_Xfz37) ->
           fromEnum
             @ a_Xfz37
             $dEnum_Xfz39
             (eta_Xl1
              `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_Xfz37>_R
                      :: (WrappedMonoid a_Xfz37 :: *) ~R# (a_Xfz37 :: *))))
        ((\ (ds_XfA72 :: WrappedMonoid a_Xfz37) ->
            enumFrom
              @ a_Xfz37
              $dEnum_Xfz39
              (ds_XfA72
               `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_Xfz37>_R
                       :: (WrappedMonoid a_Xfz37 :: *) ~R# (a_Xfz37 :: *))))
         `cast` (<WrappedMonoid a_Xfz37>_R
                 ->_R ([Sym (Data.Semigroup.N:WrappedMonoid[0] <a_Xfz37>_R)])_R
                 :: (WrappedMonoid a_Xfz37 -> [a_Xfz37] :: *)
                    ~R# (WrappedMonoid a_Xfz37 -> [WrappedMonoid a_Xfz37] :: *)))
        ((\ (ds_XfA76 :: WrappedMonoid a_Xfz37)
            (ds1_XfA78 :: WrappedMonoid a_Xfz37) ->
            enumFromThen
              @ a_Xfz37
              $dEnum_Xfz39
              (ds_XfA76
               `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_Xfz37>_R
                       :: (WrappedMonoid a_Xfz37 :: *) ~R# (a_Xfz37 :: *)))
              (ds1_XfA78
               `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_Xfz37>_R
                       :: (WrappedMonoid a_Xfz37 :: *) ~R# (a_Xfz37 :: *))))
         `cast` (<WrappedMonoid a_Xfz37>_R
                 ->_R <WrappedMonoid a_Xfz37>_R
                 ->_R ([Sym (Data.Semigroup.N:WrappedMonoid[0] <a_Xfz37>_R)])_R
                 :: (WrappedMonoid a_Xfz37
                     -> WrappedMonoid a_Xfz37 -> [a_Xfz37] :: *)
                    ~R# (WrappedMonoid a_Xfz37
                         -> WrappedMonoid a_Xfz37 -> [WrappedMonoid a_Xfz37] :: *)))
        ((\ (ds_XfA7d :: WrappedMonoid a_Xfz37)
            (ds1_XfA7f :: WrappedMonoid a_Xfz37) ->
            enumFromTo
              @ a_Xfz37
              $dEnum_Xfz39
              (ds_XfA7d
               `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_Xfz37>_R
                       :: (WrappedMonoid a_Xfz37 :: *) ~R# (a_Xfz37 :: *)))
              (ds1_XfA7f
               `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_Xfz37>_R
                       :: (WrappedMonoid a_Xfz37 :: *) ~R# (a_Xfz37 :: *))))
         `cast` (<WrappedMonoid a_Xfz37>_R
                 ->_R <WrappedMonoid a_Xfz37>_R
                 ->_R ([Sym (Data.Semigroup.N:WrappedMonoid[0] <a_Xfz37>_R)])_R
                 :: (WrappedMonoid a_Xfz37
                     -> WrappedMonoid a_Xfz37 -> [a_Xfz37] :: *)
                    ~R# (WrappedMonoid a_Xfz37
                         -> WrappedMonoid a_Xfz37 -> [WrappedMonoid a_Xfz37] :: *)))
        ((\ (ds_XfA7k :: WrappedMonoid a_Xfz37)
            (ds1_XfA7m :: WrappedMonoid a_Xfz37)
            (ds2_XfA7o :: WrappedMonoid a_Xfz37) ->
            enumFromThenTo
              @ a_Xfz37
              $dEnum_Xfz39
              (ds_XfA7k
               `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_Xfz37>_R
                       :: (WrappedMonoid a_Xfz37 :: *) ~R# (a_Xfz37 :: *)))
              (ds1_XfA7m
               `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_Xfz37>_R
                       :: (WrappedMonoid a_Xfz37 :: *) ~R# (a_Xfz37 :: *)))
              (ds2_XfA7o
               `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_Xfz37>_R
                       :: (WrappedMonoid a_Xfz37 :: *) ~R# (a_Xfz37 :: *))))
         `cast` (<WrappedMonoid a_Xfz37>_R
                 ->_R <WrappedMonoid a_Xfz37>_R
                 ->_R <WrappedMonoid a_Xfz37>_R
                 ->_R ([Sym (Data.Semigroup.N:WrappedMonoid[0] <a_Xfz37>_R)])_R
                 :: (WrappedMonoid a_Xfz37
                     -> WrappedMonoid a_Xfz37
                     -> WrappedMonoid a_Xfz37
                     -> [a_Xfz37] :: *)
                    ~R# (WrappedMonoid a_Xfz37
                         -> WrappedMonoid a_Xfz37
                         -> WrappedMonoid a_Xfz37
                         -> [WrappedMonoid a_Xfz37] :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
getOption :: forall a. Option a -> Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Semigroup.$fGeneric1Option2
               `cast` (forall (a :: <*>_N).
                       <Option a>_R ->_R Data.Semigroup.N:Option[0] <a>_N
                       :: (forall a. Option a -> Option a :: *)
                          ~R# (forall a. Option a -> Maybe a :: *))}]
getOption
  = Data.Semigroup.$fGeneric1Option2
    `cast` (forall (a :: <*>_N).
            <Option a>_R ->_R Data.Semigroup.N:Option[0] <a>_N
            :: (forall a. Option a -> Option a :: *)
               ~R# (forall a. Option a -> Maybe a :: *))

-- RHS size: {terms: 11, types: 11, coercions: 2, joins: 0/1}
Data.Semigroup.$fMonadFixOption_$cmfix
  :: forall a. (a -> Option a) -> Option a
[GblId,
 Arity=1,
 Str=<C(S),C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyzI)
                 (f_afwMp [Occ=Once!] :: a_afyzI -> Option a_afyzI) ->
                 letrec {
                   a1_sfAfa [Occ=LoopBreaker] :: Option a_afyzI
                   [LclId]
                   a1_sfAfa
                     = f_afwMp
                         (case a1_sfAfa
                               `cast` (Data.Semigroup.N:Option[0] <a_afyzI>_N
                                       :: (Option a_afyzI :: *) ~R# (Maybe a_afyzI :: *))
                          of {
                            Nothing -> Control.Monad.Fix.$fMonadFixFirst1 @ a_afyzI;
                            Just x_abGgh [Occ=Once] -> x_abGgh
                          }); } in
                 a1_sfAfa}]
Data.Semigroup.$fMonadFixOption_$cmfix
  = \ (@ a_afyzI) (f_afwMp :: a_afyzI -> Option a_afyzI) ->
      letrec {
        a1_sfAfa [Occ=LoopBreaker] :: Option a_afyzI
        [LclId]
        a1_sfAfa
          = f_afwMp
              (case a1_sfAfa
                    `cast` (Data.Semigroup.N:Option[0] <a_afyzI>_N
                            :: (Option a_afyzI :: *) ~R# (Maybe a_afyzI :: *))
               of {
                 Nothing -> Control.Monad.Fix.$fMonadFixFirst1 @ a_afyzI;
                 Just x_abGgh -> x_abGgh
               }); } in
      a1_sfAfa

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Semigroup.$fMonadFixOption [InlPrag=NOUSERINLINE CONLIKE]
  :: MonadFix Option
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       Control.Monad.Fix.C:MonadFix TYPE: Option
                                    Data.Semigroup.$fMonadOption
                                    Data.Semigroup.$fMonadFixOption_$cmfix]
Data.Semigroup.$fMonadFixOption
  = Control.Monad.Fix.C:MonadFix
      @ Option
      Data.Semigroup.$fMonadOption
      Data.Semigroup.$fMonadFixOption_$cmfix

-- RHS size: {terms: 9, types: 7, coercions: 0, joins: 0/1}
cycle1 :: forall m. Semigroup m => m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LL),U(C(C1(U)),A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_afxsV)
                 ($dSemigroup_afxsX [Occ=Once] :: Semigroup m_afxsV)
                 (xs_afwPt [Occ=Once] :: m_afxsV) ->
                 letrec {
                   xs'_sfAf8 [Occ=LoopBreaker] :: m_afxsV
                   [LclId]
                   xs'_sfAf8 = <> @ m_afxsV $dSemigroup_afxsX xs_afwPt xs'_sfAf8; } in
                 xs'_sfAf8}]
cycle1
  = \ (@ m_afxsV)
      ($dSemigroup_afxsX :: Semigroup m_afxsV)
      (xs_afwPt :: m_afxsV) ->
      letrec {
        xs'_sfAf8 [Occ=LoopBreaker] :: m_afxsV
        [LclId]
        xs'_sfAf8 = <> @ m_afxsV $dSemigroup_afxsX xs_afwPt xs'_sfAf8; } in
      xs'_sfAf8

-- RHS size: {terms: 6, types: 6, coercions: 0, joins: 0/0}
Data.Semigroup.diff1 :: forall m. Semigroup m => m -> m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)LL),1*U(1*C1(U),A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ m_afxsL)
                 ($dSemigroup_afxsN [Occ=Once] :: Semigroup m_afxsL)
                 (eta_Xl8 [Occ=Once] :: m_afxsL) ->
                 <> @ m_afxsL $dSemigroup_afxsN eta_Xl8}]
Data.Semigroup.diff1
  = \ (@ m_afxsL)
      ($dSemigroup_afxsN :: Semigroup m_afxsL)
      (eta_Xl8 :: m_afxsL) ->
      <> @ m_afxsL $dSemigroup_afxsN eta_Xl8

-- RHS size: {terms: 1, types: 0, coercions: 11, joins: 0/0}
diff :: forall m. Semigroup m => m -> Endo m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)LL),1*U(1*C1(U),A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Semigroup.diff1
               `cast` (forall (m :: <*>_N).
                       <Semigroup m>_R
                       ->_R <m>_R
                       ->_R Sym (Data.Semigroup.Internal.N:Endo[0] <m>_R)
                       :: (forall m. Semigroup m => m -> m -> m :: *)
                          ~R# (forall m. Semigroup m => m -> Endo m :: *))}]
diff
  = Data.Semigroup.diff1
    `cast` (forall (m :: <*>_N).
            <Semigroup m>_R
            ->_R <m>_R
            ->_R Sym (Data.Semigroup.Internal.N:Endo[0] <m>_R)
            :: (forall m. Semigroup m => m -> m -> m :: *)
               ~R# (forall m. Semigroup m => m -> Endo m :: *))

-- RHS size: {terms: 28, types: 22, coercions: 5, joins: 0/1}
mtimesDefault :: forall b a. (Integral b, Monoid a) => b -> a -> a
[GblId,
 Arity=4,
 Str=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLLLL),U(U(U(U,U,U,U,U,U,U),U(U(U,U),U,U,U,U,U,U,U),U),U,U,U,U,U,U,U,U)><L,U(A,1*U,U,A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 0] 250 0}]
mtimesDefault
  = \ (@ b_afxst)
      (@ a_afxsu)
      ($dIntegral_afxsw :: Integral b_afxst)
      ($dMonoid_afxsx :: Monoid a_afxsu)
      (eta_B2 :: b_afxst)
      (eta1_B1 :: a_afxsu) ->
      let {
        $dReal_sfAf6 [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
          :: Real b_afxst
        [LclId]
        $dReal_sfAf6 = GHC.Real.$p1Integral @ b_afxst $dIntegral_afxsw } in
      case ==
             @ b_afxst
             (GHC.Classes.$p1Ord
                @ b_afxst (GHC.Real.$p2Real @ b_afxst $dReal_sfAf6))
             eta_B2
             (fromInteger
                @ b_afxst
                (GHC.Real.$p1Real @ b_afxst $dReal_sfAf6)
                Data.Semigroup.$fSemigroupOption2)
      of {
        False ->
          (Data.Semigroup.$fSemigroupWrappedMonoid_$cstimes
             @ a_afxsu
             $dMonoid_afxsx
             @ b_afxst
             $dIntegral_afxsw
             eta_B2
             (eta1_B1
              `cast` (Sym (Data.Semigroup.N:WrappedMonoid[0] <a_afxsu>_R)
                      :: (a_afxsu :: *) ~R# (WrappedMonoid a_afxsu :: *))))
          `cast` (Data.Semigroup.N:WrappedMonoid[0] <a_afxsu>_R
                  :: (WrappedMonoid a_afxsu :: *) ~R# (a_afxsu :: *));
        True -> mempty @ a_afxsu $dMonoid_afxsx
      }

-- RHS size: {terms: 1, types: 0, coercions: 16, joins: 0/0}
option :: forall b a. b -> (a -> b) -> Option a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U><L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= maybe
               `cast` (forall (b :: <*>_N) (a :: <*>_N).
                       <b>_R
                       ->_R <a -> b>_R
                       ->_R Sym (Data.Semigroup.N:Option[0]) <a>_N
                       ->_R <b>_R
                       :: (forall b a. b -> (a -> b) -> Maybe a -> b :: *)
                          ~R# (forall b a. b -> (a -> b) -> Option a -> b :: *))}]
option
  = maybe
    `cast` (forall (b :: <*>_N) (a :: <*>_N).
            <b>_R
            ->_R <a -> b>_R
            ->_R Sym (Data.Semigroup.N:Option[0]) <a>_N
            ->_R <b>_R
            :: (forall b a. b -> (a -> b) -> Maybe a -> b :: *)
               ~R# (forall b a. b -> (a -> b) -> Option a -> b :: *))

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$cMin1_rfC6i :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cMin1_rfC6i
  = GHC.Types.:
      @ String Data.Semigroup.$fReadMin2 (GHC.Types.[] @ String)

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go61_rfC6j :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go61_rfC6j
  = \ (ds2_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds2_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Data.Data.Constr ds3_de7m3 ds4_de7m4 ds5_de7m5 ds6_de7m6
                                 ds7_de7m7 ->
              case GHC.Base.eqString ds4_de7m4 Data.Semigroup.$fDataMin7 of {
                False -> go61_rfC6j ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cMin2_rfC6k :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cMin2_rfC6k = Data.Data.AlgConstr $cMin3_rfC6l

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataMin6 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Semigroup.$fDataMin6
  = GHC.Types.: @ Constr Data.Semigroup.$cMin (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataMin5 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fDataMin5
  = Data.Data.AlgRep Data.Semigroup.$fDataMin6

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tMin :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Semigroup.$tMin
  = Data.Data.DataType
      Data.Semigroup.$fDataMin7 Data.Semigroup.$fDataMin5

-- RHS size: {terms: 6, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$cMin [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Semigroup.$cMin
  = Data.Data.Constr
      $cMin2_rfC6k
      Data.Semigroup.$fDataMin7
      $cMin1_rfC6i
      Data.Data.Prefix
      Data.Semigroup.$tMin

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cMin3_rfC6l :: ConIndex
[GblId]
$cMin3_rfC6l
  = go61_rfC6j Data.Semigroup.$fDataMin6 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$cMax1_rfC6m :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cMax1_rfC6m
  = GHC.Types.:
      @ String Data.Semigroup.$fReadMax2 (GHC.Types.[] @ String)

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go1_rfC6n :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go1_rfC6n
  = \ (ds2_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds2_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Data.Data.Constr ds3_de7m3 ds4_de7m4 ds5_de7m5 ds6_de7m6
                                 ds7_de7m7 ->
              case GHC.Base.eqString ds4_de7m4 Data.Semigroup.$fDataMax7 of {
                False -> go1_rfC6n ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cMax2_rfC6o :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cMax2_rfC6o = Data.Data.AlgConstr $cMax3_rfC6p

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataMax6 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Semigroup.$fDataMax6
  = GHC.Types.: @ Constr Data.Semigroup.$cMax (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataMax5 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fDataMax5
  = Data.Data.AlgRep Data.Semigroup.$fDataMax6

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tMax :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Semigroup.$tMax
  = Data.Data.DataType
      Data.Semigroup.$fDataMax7 Data.Semigroup.$fDataMax5

-- RHS size: {terms: 6, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$cMax [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Semigroup.$cMax
  = Data.Data.Constr
      $cMax2_rfC6o
      Data.Semigroup.$fDataMax7
      $cMax1_rfC6m
      Data.Data.Prefix
      Data.Semigroup.$tMax

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cMax3_rfC6p :: ConIndex
[GblId]
$cMax3_rfC6p
  = go1_rfC6n Data.Semigroup.$fDataMax6 Data.Data.mkConstr1
end Rec }

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go2_rfC6q :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go2_rfC6q
  = \ (ds2_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds2_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Data.Data.Constr ds3_de7m3 ds4_de7m4 ds5_de7m5 ds6_de7m6
                                 ds7_de7m7 ->
              case GHC.Base.eqString ds4_de7m4 Data.Semigroup.$fDataArg9 of {
                False -> go2_rfC6q ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cArg1_rfC6r :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cArg1_rfC6r = Data.Data.AlgConstr $cArg2_rfC6s

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataArg8 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Semigroup.$fDataArg8
  = GHC.Types.: @ Constr Data.Semigroup.$cArg (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataArg7 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fDataArg7
  = Data.Data.AlgRep Data.Semigroup.$fDataArg8

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tArg :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Semigroup.$tArg
  = Data.Data.DataType
      Data.Semigroup.$fDataArg9 Data.Semigroup.$fDataArg7

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
Data.Semigroup.$cArg [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Semigroup.$cArg
  = Data.Data.Constr
      $cArg1_rfC6r
      Data.Semigroup.$fDataArg9
      (GHC.Types.[] @ String)
      Data.Data.Prefix
      Data.Semigroup.$tArg

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cArg2_rfC6s :: ConIndex
[GblId]
$cArg2_rfC6s
  = go2_rfC6q Data.Semigroup.$fDataArg8 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$cFirst1_rfC6t :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cFirst1_rfC6t
  = GHC.Types.:
      @ String Data.Semigroup.$fReadFirst5 (GHC.Types.[] @ String)

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go3_rfC6u :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go3_rfC6u
  = \ (ds2_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds2_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Data.Data.Constr ds3_de7m3 ds4_de7m4 ds5_de7m5 ds6_de7m6
                                 ds7_de7m7 ->
              case GHC.Base.eqString ds4_de7m4 Data.Semigroup.$fDataFirst7 of {
                False -> go3_rfC6u ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cFirst2_rfC6v :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cFirst2_rfC6v = Data.Data.AlgConstr $cFirst3_rfC6w

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataFirst6 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Semigroup.$fDataFirst6
  = GHC.Types.:
      @ Constr Data.Semigroup.$cFirst (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataFirst5 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fDataFirst5
  = Data.Data.AlgRep Data.Semigroup.$fDataFirst6

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tFirst :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Semigroup.$tFirst
  = Data.Data.DataType
      Data.Semigroup.$fDataFirst7 Data.Semigroup.$fDataFirst5

-- RHS size: {terms: 6, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$cFirst [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Semigroup.$cFirst
  = Data.Data.Constr
      $cFirst2_rfC6v
      Data.Semigroup.$fDataFirst7
      $cFirst1_rfC6t
      Data.Data.Prefix
      Data.Semigroup.$tFirst

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cFirst3_rfC6w :: ConIndex
[GblId]
$cFirst3_rfC6w
  = go3_rfC6u Data.Semigroup.$fDataFirst6 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$cLast1_rfC6x :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cLast1_rfC6x
  = GHC.Types.:
      @ String Data.Semigroup.$fReadLast2 (GHC.Types.[] @ String)

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go4_rfC6y :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go4_rfC6y
  = \ (ds2_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds2_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Data.Data.Constr ds3_de7m3 ds4_de7m4 ds5_de7m5 ds6_de7m6
                                 ds7_de7m7 ->
              case GHC.Base.eqString ds4_de7m4 Data.Semigroup.$fDataLast7 of {
                False -> go4_rfC6y ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cLast2_rfC6z :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cLast2_rfC6z = Data.Data.AlgConstr $cLast3_rfC6A

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataLast6 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Semigroup.$fDataLast6
  = GHC.Types.:
      @ Constr Data.Semigroup.$cLast (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataLast5 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fDataLast5
  = Data.Data.AlgRep Data.Semigroup.$fDataLast6

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tLast :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Semigroup.$tLast
  = Data.Data.DataType
      Data.Semigroup.$fDataLast7 Data.Semigroup.$fDataLast5

-- RHS size: {terms: 6, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$cLast [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Semigroup.$cLast
  = Data.Data.Constr
      $cLast2_rfC6z
      Data.Semigroup.$fDataLast7
      $cLast1_rfC6x
      Data.Data.Prefix
      Data.Semigroup.$tLast

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cLast3_rfC6A :: ConIndex
[GblId]
$cLast3_rfC6A
  = go4_rfC6y Data.Semigroup.$fDataLast6 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataWrappedMonoid4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Semigroup.$fDataWrappedMonoid4 = "WrappedMonoid"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataWrappedMonoid7 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$fDataWrappedMonoid7
  = GHC.CString.unpackCString# Data.Semigroup.$fDataWrappedMonoid4

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$cWrapMonoid1_rfC6B :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cWrapMonoid1_rfC6B
  = GHC.Types.:
      @ String
      Data.Semigroup.$fReadWrappedMonoid2
      (GHC.Types.[] @ String)

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go5_rfC6C :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go5_rfC6C
  = \ (ds2_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds2_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Data.Data.Constr ds3_de7m3 ds4_de7m4 ds5_de7m5 ds6_de7m6
                                 ds7_de7m7 ->
              case GHC.Base.eqString
                     ds4_de7m4 Data.Semigroup.$fReadWrappedMonoid4
              of {
                False -> go5_rfC6C ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cWrapMonoid2_rfC6D :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cWrapMonoid2_rfC6D = Data.Data.AlgConstr $cWrapMonoid3_rfC6E

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataWrappedMonoid6 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Semigroup.$fDataWrappedMonoid6
  = GHC.Types.:
      @ Constr Data.Semigroup.$cWrapMonoid (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataWrappedMonoid5 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fDataWrappedMonoid5
  = Data.Data.AlgRep Data.Semigroup.$fDataWrappedMonoid6

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tWrappedMonoid :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Semigroup.$tWrappedMonoid
  = Data.Data.DataType
      Data.Semigroup.$fDataWrappedMonoid7
      Data.Semigroup.$fDataWrappedMonoid5

-- RHS size: {terms: 6, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$cWrapMonoid [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Semigroup.$cWrapMonoid
  = Data.Data.Constr
      $cWrapMonoid2_rfC6D
      Data.Semigroup.$fReadWrappedMonoid4
      $cWrapMonoid1_rfC6B
      Data.Data.Prefix
      Data.Semigroup.$tWrappedMonoid

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cWrapMonoid3_rfC6E :: ConIndex
[GblId]
$cWrapMonoid3_rfC6E
  = go5_rfC6C Data.Semigroup.$fDataWrappedMonoid6 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$cOption1_rfC6F :: [String]
[GblId, Str=m2, Unf=OtherCon []]
$cOption1_rfC6F
  = GHC.Types.:
      @ String Data.Semigroup.$fReadOption2 (GHC.Types.[] @ String)

Rec {
-- RHS size: {terms: 25, types: 24, coercions: 0, joins: 0/0}
go6_rfC6G :: [Constr] -> [Int] -> ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
go6_rfC6G
  = \ (ds2_iaIB3 :: [Constr]) (_ys_iaIB4 :: [Int]) ->
      case ds2_iaIB3 of {
        [] -> GHC.List.badHead @ Int;
        : ipv_iaIB9 ipv1_iaIBa ->
          case _ys_iaIB4 of {
            [] -> GHC.List.badHead @ Int;
            : ipv2_iaIBg ipv3_iaIBh ->
              case ipv_iaIB9 of
              { Data.Data.Constr ds3_de7m3 ds4_de7m4 ds5_de7m5 ds6_de7m6
                                 ds7_de7m7 ->
              case GHC.Base.eqString ds4_de7m4 Data.Semigroup.$fDataOption9 of {
                False -> go6_rfC6G ipv1_iaIBa ipv3_iaIBh;
                True -> ipv2_iaIBg
              }
              }
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$cOption2_rfC6H :: ConstrRep
[GblId, Str=m1, Unf=OtherCon []]
$cOption2_rfC6H = Data.Data.AlgConstr $cOption3_rfC6I

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataOption8 :: [Constr]
[GblId,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Semigroup.$fDataOption8
  = GHC.Types.:
      @ Constr Data.Semigroup.$cOption (GHC.Types.[] @ Constr)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataOption7 :: DataRep
[GblId,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fDataOption7
  = Data.Data.AlgRep Data.Semigroup.$fDataOption8

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tOption :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Semigroup.$tOption
  = Data.Data.DataType
      Data.Semigroup.$fDataOption9 Data.Semigroup.$fDataOption7

-- RHS size: {terms: 6, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$cOption [Occ=LoopBreaker] :: Constr
[GblId, Str=m, Unf=OtherCon []]
Data.Semigroup.$cOption
  = Data.Data.Constr
      $cOption2_rfC6H
      Data.Semigroup.$fDataOption9
      $cOption1_rfC6F
      Data.Data.Prefix
      Data.Semigroup.$tOption

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$cOption3_rfC6I :: ConIndex
[GblId]
$cOption3_rfC6I
  = go6_rfC6G Data.Semigroup.$fDataOption8 Data.Data.mkConstr1
end Rec }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$trModule3
  = GHC.Types.TrNameS Data.Semigroup.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Semigroup.$trModule2 = "Data.Semigroup"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$trModule1
  = GHC.Types.TrNameS Data.Semigroup.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Semigroup.$trModule
  = GHC.Types.Module
      Data.Semigroup.$trModule3 Data.Semigroup.$trModule1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep_rfC6J :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep_rfC6J = GHC.Types.KindRepVar 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep1_rfC6K :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep1_rfC6K = GHC.Types.KindRepVar 0#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep2_rfC6L :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep2_rfC6L
  = GHC.Types.:
      @ GHC.Types.KindRep $krep1_rfC6K (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep3_rfC6M :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep3_rfC6M
  = GHC.Types.KindRepTyConApp GHC.Base.$tcMaybe $krep2_rfC6L

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataMin3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fDataMin3
  = GHC.Types.TrNameS Data.Semigroup.$fDataMin4

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tcMin :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Semigroup.$tcMin
  = GHC.Types.TyCon
      2898124504153588682##
      15185633012309158566##
      Data.Semigroup.$trModule
      Data.Semigroup.$fDataMin3
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep4_rfC6N :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep4_rfC6N
  = GHC.Types.KindRepTyConApp Data.Semigroup.$tcMin $krep2_rfC6L

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'Min1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Semigroup.$tc'Min1
  = GHC.Types.KindRepFun $krep1_rfC6K $krep4_rfC6N

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'Min3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$tc'Min3 = "'Min"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'Min2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$tc'Min2 = GHC.Types.TrNameS Data.Semigroup.$tc'Min3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'Min :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Semigroup.$tc'Min
  = GHC.Types.TyCon
      7769702422559516318##
      9758175179672887730##
      Data.Semigroup.$trModule
      Data.Semigroup.$tc'Min2
      1#
      Data.Semigroup.$tc'Min1

-- RHS size: {terms: 16, types: 41, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataMin2 :: Data.Typeable.Internal.TypeRep Min
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Semigroup.$fDataMin2
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ Min
           2898124504153588682##
           15185633012309158566##
           Data.Semigroup.$trModule
           Data.Semigroup.$fDataMin3
           0#
           GHC.Types.krep$*Arr*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ Min
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 6, types: 11, coercions: 4, joins: 0/0}
Data.Semigroup.$fDataMin8
  :: forall a. Data a => Data.Typeable.Internal.TypeRep (Min a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afxys) ($dData_afxyt [Occ=Once] :: Data a_afxys) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Min
                   @ a_afxys
                   Data.Semigroup.$fDataMin2
                   ((Data.Data.$p1Data @ a_afxys $dData_afxyt)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_afxys>_N
                            :: (Typeable a_afxys :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep a_afxys :: *)))}]
Data.Semigroup.$fDataMin8
  = \ (@ a_afxys) ($dData_afxyt :: Data a_afxys) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ Min
        @ a_afxys
        Data.Semigroup.$fDataMin2
        ((Data.Data.$p1Data @ a_afxys $dData_afxyt)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_afxys>_N
                 :: (Typeable a_afxys :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep a_afxys :: *)))

-- RHS size: {terms: 18, types: 44, coercions: 12, joins: 0/1}
Data.Semigroup.$fDataMin_$cdataCast1
  :: forall a.
     Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Min a))
[GblId,
 Arity=2,
 Str=<L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 100 60}]
Data.Semigroup.$fDataMin_$cdataCast1
  = \ (@ a_Xfy02)
      ($dData_Xfy04 :: Data a_Xfy02)
      (@ (t_afxz5 :: * -> *))
      (@ (c_afxz6 :: * -> *))
      ($dTypeable_afxz8 :: Typeable t_afxz5) ->
      let {
        lvl33_sfApV :: Bool
        [LclId]
        lvl33_sfApV
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_afxz5
              @ Min
              ($dTypeable_afxz8
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_afxz5>_N
                       :: (Typeable t_afxz5 :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_afxz5 :: *)))
              Data.Semigroup.$fDataMin2 } in
      \ (f_afxpe :: forall d. Data d => c_afxz6 (t_afxz5 d)) ->
        case lvl33_sfApV of {
          False -> GHC.Base.Nothing @ (c_afxz6 (Min a_Xfy02));
          True ->
            GHC.Base.Just
              @ (c_afxz6 (Min a_Xfy02))
              ((f_afxpe @ a_Xfy02 $dData_Xfy04)
               `cast` (<c_afxz6>_R (UnsafeCo nominal t_afxz5 Min <a_Xfy02>_N)
                       :: (c_afxz6 (t_afxz5 a_Xfy02) :: *)
                          ~R# (c_afxz6 (Min a_Xfy02) :: *)))
        }

-- RHS size: {terms: 4, types: 7, coercions: 5, joins: 0/0}
Data.Semigroup.$fDataMin1 :: forall a. (a -> Min a, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Semigroup.$fDataMin1
  = \ (@ a_Xfy0b) ->
      ((Data.Semigroup.$fApplicativeFirst3 @ a_Xfy0b)
       `cast` (<a_Xfy0b>_R ->_R Sym (Data.Semigroup.N:Min[0] <a_Xfy0b>_R)
               :: (a_Xfy0b -> a_Xfy0b :: *) ~R# (a_Xfy0b -> Min a_Xfy0b :: *)),
       GHC.Types.False)

-- RHS size: {terms: 57, types: 112, coercions: 4, joins: 0/3}
Data.Semigroup.$fDataMin_$cgmapMp
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Min a -> m (Min a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 510 0}]
Data.Semigroup.$fDataMin_$cgmapMp
  = \ (@ a_Xfy0b)
      ($dData_Xfy0d :: Data a_Xfy0b)
      (@ (m_afxBb :: * -> *))
      ($dMonadPlus_afxBd :: MonadPlus m_afxBb)
      (ds_dfzzZ :: forall d. Data d => d -> m_afxBb d)
      (eta_Xmc :: Min a_Xfy0b) ->
      let {
        lvl33_sfApZ :: m_afxBb (Min a_Xfy0b)
        [LclId]
        lvl33_sfApZ
          = mzero @ m_afxBb $dMonadPlus_afxBd @ (Min a_Xfy0b) } in
      let {
        $dMonad_sfAf2 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_afxBb
        [LclId]
        $dMonad_sfAf2
          = GHC.Base.$p2MonadPlus @ m_afxBb $dMonadPlus_afxBd } in
      >>=
        @ m_afxBb
        $dMonad_sfAf2
        @ (Min a_Xfy0b, Bool)
        @ (Min a_Xfy0b)
        (let {
           lvl34_sfApY :: m_afxBb a_Xfy0b
           [LclId]
           lvl34_sfApY
             = ds_dfzzZ
                 @ a_Xfy0b
                 $dData_Xfy0d
                 (eta_Xmc
                  `cast` (Data.Semigroup.N:Min[0] <a_Xfy0b>_R
                          :: (Min a_Xfy0b :: *) ~R# (a_Xfy0b :: *))) } in
         >>=
           @ m_afxBb
           $dMonad_sfAf2
           @ (a_Xfy0b -> Min a_Xfy0b, Bool)
           @ (Min a_Xfy0b, Bool)
           (return
              @ m_afxBb
              $dMonad_sfAf2
              @ (a_Xfy0b -> Min a_Xfy0b, Bool)
              (Data.Semigroup.$fDataMin1 @ a_Xfy0b))
           (\ (ds1_de7oD :: (a_Xfy0b -> Min a_Xfy0b, Bool)) ->
              case ds1_de7oD of { (h_ae1TA, b1_ae1TB) ->
              mplus
                @ m_afxBb
                $dMonadPlus_afxBd
                @ (Min a_Xfy0b, Bool)
                (>>=
                   @ m_afxBb
                   $dMonad_sfAf2
                   @ a_Xfy0b
                   @ (Min a_Xfy0b, Bool)
                   lvl34_sfApY
                   (\ (y'_ae1TC :: a_Xfy0b) ->
                      return
                        @ m_afxBb
                        $dMonad_sfAf2
                        @ (Min a_Xfy0b, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_afxBb
                   $dMonad_sfAf2
                   @ (Min a_Xfy0b, Bool)
                   (h_ae1TA
                      (eta_Xmc
                       `cast` (Data.Semigroup.N:Min[0] <a_Xfy0b>_R
                               :: (Min a_Xfy0b :: *) ~R# (a_Xfy0b :: *))),
                    b1_ae1TB))
              }))
        (\ (ds1_de7oa :: (Min a_Xfy0b, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl33_sfApZ;
             True -> return @ m_afxBb $dMonad_sfAf2 @ (Min a_Xfy0b) x'_ae1TD
           }
           })

-- RHS size: {terms: 24, types: 44, coercions: 7, joins: 0/1}
Data.Semigroup.$fDataMin_$cgmapM
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Min a -> m (Min a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120 60 0] 220 0}]
Data.Semigroup.$fDataMin_$cgmapM
  = \ (@ a_Xfy0a)
      ($dData_Xfy0c :: Data a_Xfy0a)
      (@ (m_afxAV :: * -> *))
      ($dMonad_afxAX :: Monad m_afxAV)
      (ds_dfzzY :: forall d. Data d => d -> m_afxAV d)
      (eta_Xmd :: Min a_Xfy0a) ->
      let {
        lvl33_sfAq1 :: m_afxAV a_Xfy0a
        [LclId]
        lvl33_sfAq1
          = ds_dfzzY
              @ a_Xfy0a
              $dData_Xfy0c
              (eta_Xmd
               `cast` (Data.Semigroup.N:Min[0] <a_Xfy0a>_R
                       :: (Min a_Xfy0a :: *) ~R# (a_Xfy0a :: *))) } in
      >>=
        @ m_afxAV
        $dMonad_afxAX
        @ (a_Xfy0a -> Min a_Xfy0a)
        @ (Min a_Xfy0a)
        (return
           @ m_afxAV
           $dMonad_afxAX
           @ (a_Xfy0a -> Min a_Xfy0a)
           ((Data.Semigroup.$fApplicativeFirst3 @ a_Xfy0a)
            `cast` (<a_Xfy0a>_R ->_R Sym (Data.Semigroup.N:Min[0] <a_Xfy0a>_R)
                    :: (a_Xfy0a -> a_Xfy0a :: *) ~R# (a_Xfy0a -> Min a_Xfy0a :: *))))
        (\ (c'_ae1To :: a_Xfy0a -> Min a_Xfy0a) ->
           >>=
             @ m_afxAV
             $dMonad_afxAX
             @ a_Xfy0a
             @ (Min a_Xfy0a)
             lvl33_sfAq1
             (\ (x'_ae1Tp :: a_Xfy0a) ->
                return
                  @ m_afxAV $dMonad_afxAX @ (Min a_Xfy0a) (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 17, types: 20, coercions: 2, joins: 0/0}
Data.Semigroup.$fDataMin_$cgmapQi
  :: forall a.
     Data a =>
     forall u. Int -> (forall d. Data d => d -> u) -> Min a -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xfy09)
                 ($dData_Xfy0b [Occ=Once] :: Data a_Xfy09)
                 (@ u_afxAH)
                 (ds_dfzzW [Occ=Once!] :: Int)
                 (ds1_dfzzX [Occ=Once!] :: forall d. Data d => d -> u_afxAH)
                 (x_ae1T7 [Occ=Once] :: Min a_Xfy09) ->
                 case ds_dfzzW of { GHC.Types.I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_afxAH;
                   0# ->
                     ds1_dfzzX
                       @ a_Xfy09
                       $dData_Xfy0b
                       (x_ae1T7
                        `cast` (Data.Semigroup.N:Min[0] <a_Xfy09>_R
                                :: (Min a_Xfy09 :: *) ~R# (a_Xfy09 :: *)))
                 }
                 }}]
Data.Semigroup.$fDataMin_$cgmapQi
  = \ (@ a_Xfy09)
      ($dData_Xfy0b :: Data a_Xfy09)
      (@ u_afxAH)
      (ds_dfzzW :: Int)
      (ds1_dfzzX :: forall d. Data d => d -> u_afxAH)
      (x_ae1T7 :: Min a_Xfy09) ->
      case ds_dfzzW of { GHC.Types.I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_afxAH;
        0# ->
          ds1_dfzzX
            @ a_Xfy09
            $dData_Xfy0b
            (x_ae1T7
             `cast` (Data.Semigroup.N:Min[0] <a_Xfy09>_R
                     :: (Min a_Xfy09 :: *) ~R# (a_Xfy09 :: *)))
      }
      }

-- RHS size: {terms: 67, types: 121, coercions: 6, joins: 0/3}
Data.Semigroup.$fDataMin_$cgmapMo
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Min a -> m (Min a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 590 0}]
Data.Semigroup.$fDataMin_$cgmapMo
  = \ (@ a_Xfy04)
      ($dData_Xfy06 :: Data a_Xfy04)
      (@ (m_afxBr :: * -> *))
      ($dMonadPlus_afxBt :: MonadPlus m_afxBr)
      (ds_dfzA0 :: forall d. Data d => d -> m_afxBr d)
      (eta_Xmm :: Min a_Xfy04) ->
      let {
        lvl33_sfAq6 :: m_afxBr (Min a_Xfy04)
        [LclId]
        lvl33_sfAq6
          = mzero @ m_afxBr $dMonadPlus_afxBt @ (Min a_Xfy04) } in
      let {
        $dMonad_sfAf0 [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_afxBr
        [LclId]
        $dMonad_sfAf0
          = GHC.Base.$p2MonadPlus @ m_afxBr $dMonadPlus_afxBt } in
      >>=
        @ m_afxBr
        $dMonad_sfAf0
        @ (Min a_Xfy04, Bool)
        @ (Min a_Xfy04)
        (let {
           lvl34_sfAq5 :: m_afxBr a_Xfy04
           [LclId]
           lvl34_sfAq5
             = ds_dfzA0
                 @ a_Xfy04
                 $dData_Xfy06
                 (eta_Xmm
                  `cast` (Data.Semigroup.N:Min[0] <a_Xfy04>_R
                          :: (Min a_Xfy04 :: *) ~R# (a_Xfy04 :: *))) } in
         >>=
           @ m_afxBr
           $dMonad_sfAf0
           @ (a_Xfy04 -> Min a_Xfy04, Bool)
           @ (Min a_Xfy04, Bool)
           (return
              @ m_afxBr
              $dMonad_sfAf0
              @ (a_Xfy04 -> Min a_Xfy04, Bool)
              (Data.Semigroup.$fDataMin1 @ a_Xfy04))
           (\ (ds1_de7pD :: (a_Xfy04 -> Min a_Xfy04, Bool)) ->
              case ds1_de7pD of { (h_ae1TP, b1_ae1TQ) ->
              case b1_ae1TQ of {
                False ->
                  mplus
                    @ m_afxBr
                    $dMonadPlus_afxBt
                    @ (Min a_Xfy04, Bool)
                    (>>=
                       @ m_afxBr
                       $dMonad_sfAf0
                       @ a_Xfy04
                       @ (Min a_Xfy04, Bool)
                       lvl34_sfAq5
                       (\ (y'_ae1TR :: a_Xfy04) ->
                          return
                            @ m_afxBr
                            $dMonad_sfAf0
                            @ (Min a_Xfy04, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_afxBr
                       $dMonad_sfAf0
                       @ (Min a_Xfy04, Bool)
                       (h_ae1TP
                          (eta_Xmm
                           `cast` (Data.Semigroup.N:Min[0] <a_Xfy04>_R
                                   :: (Min a_Xfy04 :: *) ~R# (a_Xfy04 :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_afxBr
                    $dMonad_sfAf0
                    @ (Min a_Xfy04, Bool)
                    (h_ae1TP
                       (eta_Xmm
                        `cast` (Data.Semigroup.N:Min[0] <a_Xfy04>_R
                                :: (Min a_Xfy04 :: *) ~R# (a_Xfy04 :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds1_de7pa :: (Min a_Xfy04, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl33_sfAq6;
             True -> return @ m_afxBr $dMonad_sfAf0 @ (Min a_Xfy04) x'_ae1TS
           }
           })

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl12_rfC6O :: forall a. Min a -> Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl12_rfC6O = \ (@ a_Xfy03) _ [Occ=Dead] -> Data.Semigroup.$cMin

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl13_rfC6P :: forall a. Min a -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl13_rfC6P = \ (@ a_Xfy03) _ [Occ=Dead] -> Data.Semigroup.$tMin

-- RHS size: {terms: 6, types: 35, coercions: 0, joins: 0/0}
lvl14_rfC6Q
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c (Min a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl14_rfC6Q
  = \ (@ a_Xfy03)
      (@ (t_afxzn :: * -> * -> *))
      (@ (c_afxzo :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_afxzo (Min a_Xfy03))

-- RHS size: {terms: 63, types: 100, coercions: 32, joins: 0/0}
Data.Semigroup.$fDataMin [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data a => Data (Min a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_afwMg) (v_XrD :: Data a_afwMg) ->
       Data.Data.C:Data TYPE: Min a_afwMg
                        (Data.Semigroup.$fDataMin8 @ a_afwMg v_XrD)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Min
                                                                                    a_afwMg>_N
                                :: (Data.Typeable.Internal.TypeRep (Min a_afwMg) :: *)
                                   ~R# (Typeable (Min a_afwMg) :: Constraint))
                        Data.Semigroup.$fDataMin_$cgfoldl @ a_afwMg v_XrD
                        \ (@ (c_afxyM :: * -> *))
                          (k_afxpc [Occ=Once!]
                             :: forall b r. Data b => c_afxyM (b -> r) -> c_afxyM r)
                          (z_afxpd [Occ=Once!] :: forall r. r -> c_afxyM r)
                          _ [Occ=Dead] ->
                          k_afxpc
                            @ a_afwMg
                            @ (Min a_afwMg)
                            v_XrD
                            (z_afxpd
                               @ (a_afwMg -> Min a_afwMg)
                               ((Data.Semigroup.$fApplicativeFirst3 @ a_afwMg)
                                `cast` (<a_afwMg>_R ->_R Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                        :: (a_afwMg -> a_afwMg :: *)
                                           ~R# (a_afwMg -> Min a_afwMg :: *))))
                        \ _ [Occ=Dead] -> Data.Semigroup.$cMin
                        \ _ [Occ=Dead] -> Data.Semigroup.$tMin
                        Data.Semigroup.$fDataMin_$cdataCast1 @ a_afwMg v_XrD
                        \ (@ (t_afxzn :: * -> * -> *))
                          (@ (c_afxzo :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_afxzo (Min a_afwMg))
                        (\ (ds_dfzzO [Occ=Once!] :: forall b. Data b => b -> b)
                           (x0_Xe2jm [Occ=Once] :: Min a_afwMg) ->
                           ds_dfzzO
                             @ a_afwMg
                             v_XrD
                             (x0_Xe2jm
                              `cast` (Data.Semigroup.N:Min[0] <a_afwMg>_R
                                      :: (Min a_afwMg :: *) ~R# (a_afwMg :: *))))
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <Min a_afwMg>_R
                                ->_R Sym (Data.Semigroup.N:Min[0] <a_afwMg>_R)
                                :: ((forall b. Data b => b -> b) -> Min a_afwMg -> a_afwMg :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> Min a_afwMg -> Min a_afwMg :: *))
                        \ (@ r_afxzV)
                          (@ r'_afxzW)
                          (ds_dfzzP [Occ=Once!] :: r_afxzV -> r'_afxzW -> r_afxzV)
                          (ds1_dfzzQ [Occ=Once] :: r_afxzV)
                          (ds2_dfzzR [Occ=Once!] :: forall d. Data d => d -> r'_afxzW)
                          (eta_Xmj [Occ=Once] :: Min a_afwMg) ->
                          ds_dfzzP
                            ds1_dfzzQ
                            (ds2_dfzzR
                               @ a_afwMg
                               v_XrD
                               (eta_Xmj
                                `cast` (Data.Semigroup.N:Min[0] <a_afwMg>_R
                                        :: (Min a_afwMg :: *) ~R# (a_afwMg :: *))))
                        \ (@ r_afxAc)
                          (@ r'_afxAd)
                          (ds_dfzzS [Occ=Once!] :: r'_afxAd -> r_afxAc -> r_afxAc)
                          (ds1_dfzzT [Occ=Once] :: r_afxAc)
                          (ds2_dfzzU [Occ=Once!] :: forall d. Data d => d -> r'_afxAd)
                          (x0_ae1SX [Occ=Once] :: Min a_afwMg) ->
                          ds_dfzzS
                            (ds2_dfzzU
                               @ a_afwMg
                               v_XrD
                               (x0_ae1SX
                                `cast` (Data.Semigroup.N:Min[0] <a_afwMg>_R
                                        :: (Min a_afwMg :: *) ~R# (a_afwMg :: *))))
                            ds1_dfzzT
                        \ (@ u_afxAt)
                          (ds_dfzzV [Occ=Once!] :: forall d. Data d => d -> u_afxAt)
                          (x0_ae1SX [Occ=Once] :: Min a_afwMg) ->
                          GHC.Types.:
                            @ u_afxAt
                            (ds_dfzzV
                               @ a_afwMg
                               v_XrD
                               (x0_ae1SX
                                `cast` (Data.Semigroup.N:Min[0] <a_afwMg>_R
                                        :: (Min a_afwMg :: *) ~R# (a_afwMg :: *))))
                            (GHC.Types.[] @ u_afxAt)
                        Data.Semigroup.$fDataMin_$cgmapQi @ a_afwMg v_XrD
                        Data.Semigroup.$fDataMin_$cgmapM @ a_afwMg v_XrD
                        Data.Semigroup.$fDataMin_$cgmapMp @ a_afwMg v_XrD
                        Data.Semigroup.$fDataMin_$cgmapMo @ a_afwMg v_XrD]
Data.Semigroup.$fDataMin
  = \ (@ a_Xfy03) ($dData_Xfymn :: Data a_Xfy03) ->
      Data.Data.C:Data
        @ (Min a_Xfy03)
        ((Data.Semigroup.$fDataMin8 @ a_Xfy03 $dData_Xfymn)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Min
                                                                     a_Xfy03>_N
                 :: (Data.Typeable.Internal.TypeRep (Min a_Xfy03) :: *)
                    ~R# (Typeable (Min a_Xfy03) :: Constraint)))
        (Data.Semigroup.$fDataMin_$cgfoldl @ a_Xfy03 $dData_Xfymn)
        (\ (@ (c_afxyM :: * -> *))
           (k_afxpc :: forall b r. Data b => c_afxyM (b -> r) -> c_afxyM r)
           (z_afxpd :: forall r. r -> c_afxyM r)
           _ [Occ=Dead] ->
           k_afxpc
             @ a_Xfy03
             @ (Min a_Xfy03)
             $dData_Xfymn
             (z_afxpd
                @ (a_Xfy03 -> Min a_Xfy03)
                ((Data.Semigroup.$fApplicativeFirst3 @ a_Xfy03)
                 `cast` (<a_Xfy03>_R ->_R Sym (Data.Semigroup.N:Min[0] <a_Xfy03>_R)
                         :: (a_Xfy03 -> a_Xfy03 :: *) ~R# (a_Xfy03 -> Min a_Xfy03 :: *)))))
        (lvl12_rfC6O @ a_Xfy03)
        (lvl13_rfC6P @ a_Xfy03)
        (Data.Semigroup.$fDataMin_$cdataCast1 @ a_Xfy03 $dData_Xfymn)
        (lvl14_rfC6Q @ a_Xfy03)
        ((\ (ds_dfzzO :: forall b. Data b => b -> b)
            (x0_Xe2jm :: Min a_Xfy03) ->
            ds_dfzzO
              @ a_Xfy03
              $dData_Xfymn
              (x0_Xe2jm
               `cast` (Data.Semigroup.N:Min[0] <a_Xfy03>_R
                       :: (Min a_Xfy03 :: *) ~R# (a_Xfy03 :: *))))
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <Min a_Xfy03>_R
                 ->_R Sym (Data.Semigroup.N:Min[0] <a_Xfy03>_R)
                 :: ((forall b. Data b => b -> b) -> Min a_Xfy03 -> a_Xfy03 :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> Min a_Xfy03 -> Min a_Xfy03 :: *)))
        (\ (@ r_afxzV)
           (@ r'_afxzW)
           (ds_dfzzP :: r_afxzV -> r'_afxzW -> r_afxzV)
           (ds1_dfzzQ :: r_afxzV)
           (ds2_dfzzR :: forall d. Data d => d -> r'_afxzW)
           (eta_Xmj :: Min a_Xfy03) ->
           ds_dfzzP
             ds1_dfzzQ
             (ds2_dfzzR
                @ a_Xfy03
                $dData_Xfymn
                (eta_Xmj
                 `cast` (Data.Semigroup.N:Min[0] <a_Xfy03>_R
                         :: (Min a_Xfy03 :: *) ~R# (a_Xfy03 :: *)))))
        (\ (@ r_afxAc)
           (@ r'_afxAd)
           (ds_dfzzS :: r'_afxAd -> r_afxAc -> r_afxAc)
           (ds1_dfzzT :: r_afxAc)
           (ds2_dfzzU :: forall d. Data d => d -> r'_afxAd)
           (x0_ae1SX :: Min a_Xfy03) ->
           ds_dfzzS
             (ds2_dfzzU
                @ a_Xfy03
                $dData_Xfymn
                (x0_ae1SX
                 `cast` (Data.Semigroup.N:Min[0] <a_Xfy03>_R
                         :: (Min a_Xfy03 :: *) ~R# (a_Xfy03 :: *))))
             ds1_dfzzT)
        (\ (@ u_afxAt)
           (ds_dfzzV :: forall d. Data d => d -> u_afxAt)
           (x0_ae1SX :: Min a_Xfy03) ->
           GHC.Types.:
             @ u_afxAt
             (ds_dfzzV
                @ a_Xfy03
                $dData_Xfymn
                (x0_ae1SX
                 `cast` (Data.Semigroup.N:Min[0] <a_Xfy03>_R
                         :: (Min a_Xfy03 :: *) ~R# (a_Xfy03 :: *))))
             (GHC.Types.[] @ u_afxAt))
        (Data.Semigroup.$fDataMin_$cgmapQi @ a_Xfy03 $dData_Xfymn)
        (Data.Semigroup.$fDataMin_$cgmapM @ a_Xfy03 $dData_Xfymn)
        (Data.Semigroup.$fDataMin_$cgmapMp @ a_Xfy03 $dData_Xfymn)
        (Data.Semigroup.$fDataMin_$cgmapMo @ a_Xfy03 $dData_Xfymn)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataMax3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fDataMax3
  = GHC.Types.TrNameS Data.Semigroup.$fDataMax4

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tcMax :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Semigroup.$tcMax
  = GHC.Types.TyCon
      10813679156066679206##
      10491840004411982061##
      Data.Semigroup.$trModule
      Data.Semigroup.$fDataMax3
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep5_rfC6R :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep5_rfC6R
  = GHC.Types.KindRepTyConApp Data.Semigroup.$tcMax $krep2_rfC6L

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'Max1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Semigroup.$tc'Max1
  = GHC.Types.KindRepFun $krep1_rfC6K $krep5_rfC6R

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'Max3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$tc'Max3 = "'Max"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'Max2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$tc'Max2 = GHC.Types.TrNameS Data.Semigroup.$tc'Max3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'Max :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Semigroup.$tc'Max
  = GHC.Types.TyCon
      9964620667386625613##
      8300955803911017019##
      Data.Semigroup.$trModule
      Data.Semigroup.$tc'Max2
      1#
      Data.Semigroup.$tc'Max1

-- RHS size: {terms: 16, types: 41, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataMax2 :: Data.Typeable.Internal.TypeRep Max
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Semigroup.$fDataMax2
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ Max
           10813679156066679206##
           10491840004411982061##
           Data.Semigroup.$trModule
           Data.Semigroup.$fDataMax3
           0#
           GHC.Types.krep$*Arr*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ Max
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 6, types: 11, coercions: 4, joins: 0/0}
Data.Semigroup.$fDataMax8
  :: forall a. Data a => Data.Typeable.Internal.TypeRep (Max a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afxHu) ($dData_afxHv [Occ=Once] :: Data a_afxHu) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Max
                   @ a_afxHu
                   Data.Semigroup.$fDataMax2
                   ((Data.Data.$p1Data @ a_afxHu $dData_afxHv)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_afxHu>_N
                            :: (Typeable a_afxHu :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep a_afxHu :: *)))}]
Data.Semigroup.$fDataMax8
  = \ (@ a_afxHu) ($dData_afxHv :: Data a_afxHu) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ Max
        @ a_afxHu
        Data.Semigroup.$fDataMax2
        ((Data.Data.$p1Data @ a_afxHu $dData_afxHv)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_afxHu>_N
                 :: (Typeable a_afxHu :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep a_afxHu :: *)))

-- RHS size: {terms: 18, types: 44, coercions: 12, joins: 0/1}
Data.Semigroup.$fDataMax_$cdataCast1
  :: forall a.
     Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Max a))
[GblId,
 Arity=2,
 Str=<L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 100 60}]
Data.Semigroup.$fDataMax_$cdataCast1
  = \ (@ a_Xfy9s)
      ($dData_Xfy9u :: Data a_Xfy9s)
      (@ (t_afxI7 :: * -> *))
      (@ (c_afxI8 :: * -> *))
      ($dTypeable_afxIa :: Typeable t_afxI7) ->
      let {
        lvl33_sfAqd :: Bool
        [LclId]
        lvl33_sfAqd
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_afxI7
              @ Max
              ($dTypeable_afxIa
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_afxI7>_N
                       :: (Typeable t_afxI7 :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_afxI7 :: *)))
              Data.Semigroup.$fDataMax2 } in
      \ (f_afxpv :: forall d. Data d => c_afxI8 (t_afxI7 d)) ->
        case lvl33_sfAqd of {
          False -> GHC.Base.Nothing @ (c_afxI8 (Max a_Xfy9s));
          True ->
            GHC.Base.Just
              @ (c_afxI8 (Max a_Xfy9s))
              ((f_afxpv @ a_Xfy9s $dData_Xfy9u)
               `cast` (<c_afxI8>_R (UnsafeCo nominal t_afxI7 Max <a_Xfy9s>_N)
                       :: (c_afxI8 (t_afxI7 a_Xfy9s) :: *)
                          ~R# (c_afxI8 (Max a_Xfy9s) :: *)))
        }

-- RHS size: {terms: 4, types: 7, coercions: 5, joins: 0/0}
Data.Semigroup.$fDataMax1 :: forall a. (a -> Max a, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Semigroup.$fDataMax1
  = \ (@ a_Xfy9B) ->
      ((Data.Semigroup.$fApplicativeFirst3 @ a_Xfy9B)
       `cast` (<a_Xfy9B>_R ->_R Sym (Data.Semigroup.N:Max[0] <a_Xfy9B>_R)
               :: (a_Xfy9B -> a_Xfy9B :: *) ~R# (a_Xfy9B -> Max a_Xfy9B :: *)),
       GHC.Types.False)

-- RHS size: {terms: 57, types: 112, coercions: 4, joins: 0/3}
Data.Semigroup.$fDataMax_$cgmapMp
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Max a -> m (Max a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 510 0}]
Data.Semigroup.$fDataMax_$cgmapMp
  = \ (@ a_Xfy9B)
      ($dData_Xfy9D :: Data a_Xfy9B)
      (@ (m_afxKd :: * -> *))
      ($dMonadPlus_afxKf :: MonadPlus m_afxKd)
      (ds_dfzAv :: forall d. Data d => d -> m_afxKd d)
      (eta_XmA :: Max a_Xfy9B) ->
      let {
        lvl33_sfAqh :: m_afxKd (Max a_Xfy9B)
        [LclId]
        lvl33_sfAqh
          = mzero @ m_afxKd $dMonadPlus_afxKf @ (Max a_Xfy9B) } in
      let {
        $dMonad_sfAeW [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_afxKd
        [LclId]
        $dMonad_sfAeW
          = GHC.Base.$p2MonadPlus @ m_afxKd $dMonadPlus_afxKf } in
      >>=
        @ m_afxKd
        $dMonad_sfAeW
        @ (Max a_Xfy9B, Bool)
        @ (Max a_Xfy9B)
        (let {
           lvl34_sfAqg :: m_afxKd a_Xfy9B
           [LclId]
           lvl34_sfAqg
             = ds_dfzAv
                 @ a_Xfy9B
                 $dData_Xfy9D
                 (eta_XmA
                  `cast` (Data.Semigroup.N:Max[0] <a_Xfy9B>_R
                          :: (Max a_Xfy9B :: *) ~R# (a_Xfy9B :: *))) } in
         >>=
           @ m_afxKd
           $dMonad_sfAeW
           @ (a_Xfy9B -> Max a_Xfy9B, Bool)
           @ (Max a_Xfy9B, Bool)
           (return
              @ m_afxKd
              $dMonad_sfAeW
              @ (a_Xfy9B -> Max a_Xfy9B, Bool)
              (Data.Semigroup.$fDataMax1 @ a_Xfy9B))
           (\ (ds1_de7oD :: (a_Xfy9B -> Max a_Xfy9B, Bool)) ->
              case ds1_de7oD of { (h_ae1TA, b1_ae1TB) ->
              mplus
                @ m_afxKd
                $dMonadPlus_afxKf
                @ (Max a_Xfy9B, Bool)
                (>>=
                   @ m_afxKd
                   $dMonad_sfAeW
                   @ a_Xfy9B
                   @ (Max a_Xfy9B, Bool)
                   lvl34_sfAqg
                   (\ (y'_ae1TC :: a_Xfy9B) ->
                      return
                        @ m_afxKd
                        $dMonad_sfAeW
                        @ (Max a_Xfy9B, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_afxKd
                   $dMonad_sfAeW
                   @ (Max a_Xfy9B, Bool)
                   (h_ae1TA
                      (eta_XmA
                       `cast` (Data.Semigroup.N:Max[0] <a_Xfy9B>_R
                               :: (Max a_Xfy9B :: *) ~R# (a_Xfy9B :: *))),
                    b1_ae1TB))
              }))
        (\ (ds1_de7oa :: (Max a_Xfy9B, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl33_sfAqh;
             True -> return @ m_afxKd $dMonad_sfAeW @ (Max a_Xfy9B) x'_ae1TD
           }
           })

-- RHS size: {terms: 24, types: 44, coercions: 7, joins: 0/1}
Data.Semigroup.$fDataMax_$cgmapM
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Max a -> m (Max a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120 60 0] 220 0}]
Data.Semigroup.$fDataMax_$cgmapM
  = \ (@ a_Xfy9A)
      ($dData_Xfy9C :: Data a_Xfy9A)
      (@ (m_afxJX :: * -> *))
      ($dMonad_afxJZ :: Monad m_afxJX)
      (ds_dfzAu :: forall d. Data d => d -> m_afxJX d)
      (eta_XmB :: Max a_Xfy9A) ->
      let {
        lvl33_sfAqj :: m_afxJX a_Xfy9A
        [LclId]
        lvl33_sfAqj
          = ds_dfzAu
              @ a_Xfy9A
              $dData_Xfy9C
              (eta_XmB
               `cast` (Data.Semigroup.N:Max[0] <a_Xfy9A>_R
                       :: (Max a_Xfy9A :: *) ~R# (a_Xfy9A :: *))) } in
      >>=
        @ m_afxJX
        $dMonad_afxJZ
        @ (a_Xfy9A -> Max a_Xfy9A)
        @ (Max a_Xfy9A)
        (return
           @ m_afxJX
           $dMonad_afxJZ
           @ (a_Xfy9A -> Max a_Xfy9A)
           ((Data.Semigroup.$fApplicativeFirst3 @ a_Xfy9A)
            `cast` (<a_Xfy9A>_R ->_R Sym (Data.Semigroup.N:Max[0] <a_Xfy9A>_R)
                    :: (a_Xfy9A -> a_Xfy9A :: *) ~R# (a_Xfy9A -> Max a_Xfy9A :: *))))
        (\ (c'_ae1To :: a_Xfy9A -> Max a_Xfy9A) ->
           >>=
             @ m_afxJX
             $dMonad_afxJZ
             @ a_Xfy9A
             @ (Max a_Xfy9A)
             lvl33_sfAqj
             (\ (x'_ae1Tp :: a_Xfy9A) ->
                return
                  @ m_afxJX $dMonad_afxJZ @ (Max a_Xfy9A) (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 17, types: 20, coercions: 2, joins: 0/0}
Data.Semigroup.$fDataMax_$cgmapQi
  :: forall a.
     Data a =>
     forall u. Int -> (forall d. Data d => d -> u) -> Max a -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xfy9z)
                 ($dData_Xfy9B [Occ=Once] :: Data a_Xfy9z)
                 (@ u_afxJJ)
                 (ds_dfzAs [Occ=Once!] :: Int)
                 (ds1_dfzAt [Occ=Once!] :: forall d. Data d => d -> u_afxJJ)
                 (x_ae1T7 [Occ=Once] :: Max a_Xfy9z) ->
                 case ds_dfzAs of { GHC.Types.I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_afxJJ;
                   0# ->
                     ds1_dfzAt
                       @ a_Xfy9z
                       $dData_Xfy9B
                       (x_ae1T7
                        `cast` (Data.Semigroup.N:Max[0] <a_Xfy9z>_R
                                :: (Max a_Xfy9z :: *) ~R# (a_Xfy9z :: *)))
                 }
                 }}]
Data.Semigroup.$fDataMax_$cgmapQi
  = \ (@ a_Xfy9z)
      ($dData_Xfy9B :: Data a_Xfy9z)
      (@ u_afxJJ)
      (ds_dfzAs :: Int)
      (ds1_dfzAt :: forall d. Data d => d -> u_afxJJ)
      (x_ae1T7 :: Max a_Xfy9z) ->
      case ds_dfzAs of { GHC.Types.I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_afxJJ;
        0# ->
          ds1_dfzAt
            @ a_Xfy9z
            $dData_Xfy9B
            (x_ae1T7
             `cast` (Data.Semigroup.N:Max[0] <a_Xfy9z>_R
                     :: (Max a_Xfy9z :: *) ~R# (a_Xfy9z :: *)))
      }
      }

-- RHS size: {terms: 67, types: 121, coercions: 6, joins: 0/3}
Data.Semigroup.$fDataMax_$cgmapMo
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Max a -> m (Max a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 590 0}]
Data.Semigroup.$fDataMax_$cgmapMo
  = \ (@ a_Xfy9u)
      ($dData_Xfy9w :: Data a_Xfy9u)
      (@ (m_afxKt :: * -> *))
      ($dMonadPlus_afxKv :: MonadPlus m_afxKt)
      (ds_dfzAw :: forall d. Data d => d -> m_afxKt d)
      (eta_XmK :: Max a_Xfy9u) ->
      let {
        lvl33_sfAqo :: m_afxKt (Max a_Xfy9u)
        [LclId]
        lvl33_sfAqo
          = mzero @ m_afxKt $dMonadPlus_afxKv @ (Max a_Xfy9u) } in
      let {
        $dMonad_sfAeU [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_afxKt
        [LclId]
        $dMonad_sfAeU
          = GHC.Base.$p2MonadPlus @ m_afxKt $dMonadPlus_afxKv } in
      >>=
        @ m_afxKt
        $dMonad_sfAeU
        @ (Max a_Xfy9u, Bool)
        @ (Max a_Xfy9u)
        (let {
           lvl34_sfAqn :: m_afxKt a_Xfy9u
           [LclId]
           lvl34_sfAqn
             = ds_dfzAw
                 @ a_Xfy9u
                 $dData_Xfy9w
                 (eta_XmK
                  `cast` (Data.Semigroup.N:Max[0] <a_Xfy9u>_R
                          :: (Max a_Xfy9u :: *) ~R# (a_Xfy9u :: *))) } in
         >>=
           @ m_afxKt
           $dMonad_sfAeU
           @ (a_Xfy9u -> Max a_Xfy9u, Bool)
           @ (Max a_Xfy9u, Bool)
           (return
              @ m_afxKt
              $dMonad_sfAeU
              @ (a_Xfy9u -> Max a_Xfy9u, Bool)
              (Data.Semigroup.$fDataMax1 @ a_Xfy9u))
           (\ (ds1_de7pD :: (a_Xfy9u -> Max a_Xfy9u, Bool)) ->
              case ds1_de7pD of { (h_ae1TP, b1_ae1TQ) ->
              case b1_ae1TQ of {
                False ->
                  mplus
                    @ m_afxKt
                    $dMonadPlus_afxKv
                    @ (Max a_Xfy9u, Bool)
                    (>>=
                       @ m_afxKt
                       $dMonad_sfAeU
                       @ a_Xfy9u
                       @ (Max a_Xfy9u, Bool)
                       lvl34_sfAqn
                       (\ (y'_ae1TR :: a_Xfy9u) ->
                          return
                            @ m_afxKt
                            $dMonad_sfAeU
                            @ (Max a_Xfy9u, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_afxKt
                       $dMonad_sfAeU
                       @ (Max a_Xfy9u, Bool)
                       (h_ae1TP
                          (eta_XmK
                           `cast` (Data.Semigroup.N:Max[0] <a_Xfy9u>_R
                                   :: (Max a_Xfy9u :: *) ~R# (a_Xfy9u :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_afxKt
                    $dMonad_sfAeU
                    @ (Max a_Xfy9u, Bool)
                    (h_ae1TP
                       (eta_XmK
                        `cast` (Data.Semigroup.N:Max[0] <a_Xfy9u>_R
                                :: (Max a_Xfy9u :: *) ~R# (a_Xfy9u :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds1_de7pa :: (Max a_Xfy9u, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl33_sfAqo;
             True -> return @ m_afxKt $dMonad_sfAeU @ (Max a_Xfy9u) x'_ae1TS
           }
           })

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl15_rfC6S :: forall a. Max a -> Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl15_rfC6S = \ (@ a_Xfy9t) _ [Occ=Dead] -> Data.Semigroup.$cMax

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl16_rfC6T :: forall a. Max a -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl16_rfC6T = \ (@ a_Xfy9t) _ [Occ=Dead] -> Data.Semigroup.$tMax

-- RHS size: {terms: 6, types: 35, coercions: 0, joins: 0/0}
lvl17_rfC6U
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c (Max a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl17_rfC6U
  = \ (@ a_Xfy9t)
      (@ (t_afxIp :: * -> * -> *))
      (@ (c_afxIq :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_afxIq (Max a_Xfy9t))

-- RHS size: {terms: 63, types: 100, coercions: 32, joins: 0/0}
Data.Semigroup.$fDataMax [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data a => Data (Max a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_afwMf) (v_Xs1 :: Data a_afwMf) ->
       Data.Data.C:Data TYPE: Max a_afwMf
                        (Data.Semigroup.$fDataMax8 @ a_afwMf v_Xs1)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Max
                                                                                    a_afwMf>_N
                                :: (Data.Typeable.Internal.TypeRep (Max a_afwMf) :: *)
                                   ~R# (Typeable (Max a_afwMf) :: Constraint))
                        Data.Semigroup.$fDataMax_$cgfoldl @ a_afwMf v_Xs1
                        \ (@ (c_afxHO :: * -> *))
                          (k_afxpt [Occ=Once!]
                             :: forall b r. Data b => c_afxHO (b -> r) -> c_afxHO r)
                          (z_afxpu [Occ=Once!] :: forall r. r -> c_afxHO r)
                          _ [Occ=Dead] ->
                          k_afxpt
                            @ a_afwMf
                            @ (Max a_afwMf)
                            v_Xs1
                            (z_afxpu
                               @ (a_afwMf -> Max a_afwMf)
                               ((Data.Semigroup.$fApplicativeFirst3 @ a_afwMf)
                                `cast` (<a_afwMf>_R ->_R Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                        :: (a_afwMf -> a_afwMf :: *)
                                           ~R# (a_afwMf -> Max a_afwMf :: *))))
                        \ _ [Occ=Dead] -> Data.Semigroup.$cMax
                        \ _ [Occ=Dead] -> Data.Semigroup.$tMax
                        Data.Semigroup.$fDataMax_$cdataCast1 @ a_afwMf v_Xs1
                        \ (@ (t_afxIp :: * -> * -> *))
                          (@ (c_afxIq :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_afxIq (Max a_afwMf))
                        (\ (ds_dfzAk [Occ=Once!] :: forall b. Data b => b -> b)
                           (x0_Xe2jm [Occ=Once] :: Max a_afwMf) ->
                           ds_dfzAk
                             @ a_afwMf
                             v_Xs1
                             (x0_Xe2jm
                              `cast` (Data.Semigroup.N:Max[0] <a_afwMf>_R
                                      :: (Max a_afwMf :: *) ~R# (a_afwMf :: *))))
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <Max a_afwMf>_R
                                ->_R Sym (Data.Semigroup.N:Max[0] <a_afwMf>_R)
                                :: ((forall b. Data b => b -> b) -> Max a_afwMf -> a_afwMf :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> Max a_afwMf -> Max a_afwMf :: *))
                        \ (@ r_afxIX)
                          (@ r'_afxIY)
                          (ds_dfzAl [Occ=Once!] :: r_afxIX -> r'_afxIY -> r_afxIX)
                          (ds1_dfzAm [Occ=Once] :: r_afxIX)
                          (ds2_dfzAn [Occ=Once!] :: forall d. Data d => d -> r'_afxIY)
                          (eta_XmH [Occ=Once] :: Max a_afwMf) ->
                          ds_dfzAl
                            ds1_dfzAm
                            (ds2_dfzAn
                               @ a_afwMf
                               v_Xs1
                               (eta_XmH
                                `cast` (Data.Semigroup.N:Max[0] <a_afwMf>_R
                                        :: (Max a_afwMf :: *) ~R# (a_afwMf :: *))))
                        \ (@ r_afxJe)
                          (@ r'_afxJf)
                          (ds_dfzAo [Occ=Once!] :: r'_afxJf -> r_afxJe -> r_afxJe)
                          (ds1_dfzAp [Occ=Once] :: r_afxJe)
                          (ds2_dfzAq [Occ=Once!] :: forall d. Data d => d -> r'_afxJf)
                          (x0_ae1SX [Occ=Once] :: Max a_afwMf) ->
                          ds_dfzAo
                            (ds2_dfzAq
                               @ a_afwMf
                               v_Xs1
                               (x0_ae1SX
                                `cast` (Data.Semigroup.N:Max[0] <a_afwMf>_R
                                        :: (Max a_afwMf :: *) ~R# (a_afwMf :: *))))
                            ds1_dfzAp
                        \ (@ u_afxJv)
                          (ds_dfzAr [Occ=Once!] :: forall d. Data d => d -> u_afxJv)
                          (x0_ae1SX [Occ=Once] :: Max a_afwMf) ->
                          GHC.Types.:
                            @ u_afxJv
                            (ds_dfzAr
                               @ a_afwMf
                               v_Xs1
                               (x0_ae1SX
                                `cast` (Data.Semigroup.N:Max[0] <a_afwMf>_R
                                        :: (Max a_afwMf :: *) ~R# (a_afwMf :: *))))
                            (GHC.Types.[] @ u_afxJv)
                        Data.Semigroup.$fDataMax_$cgmapQi @ a_afwMf v_Xs1
                        Data.Semigroup.$fDataMax_$cgmapM @ a_afwMf v_Xs1
                        Data.Semigroup.$fDataMax_$cgmapMp @ a_afwMf v_Xs1
                        Data.Semigroup.$fDataMax_$cgmapMo @ a_afwMf v_Xs1]
Data.Semigroup.$fDataMax
  = \ (@ a_Xfy9t) ($dData_Xfywb :: Data a_Xfy9t) ->
      Data.Data.C:Data
        @ (Max a_Xfy9t)
        ((Data.Semigroup.$fDataMax8 @ a_Xfy9t $dData_Xfywb)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Max
                                                                     a_Xfy9t>_N
                 :: (Data.Typeable.Internal.TypeRep (Max a_Xfy9t) :: *)
                    ~R# (Typeable (Max a_Xfy9t) :: Constraint)))
        (Data.Semigroup.$fDataMax_$cgfoldl @ a_Xfy9t $dData_Xfywb)
        (\ (@ (c_afxHO :: * -> *))
           (k_afxpt :: forall b r. Data b => c_afxHO (b -> r) -> c_afxHO r)
           (z_afxpu :: forall r. r -> c_afxHO r)
           _ [Occ=Dead] ->
           k_afxpt
             @ a_Xfy9t
             @ (Max a_Xfy9t)
             $dData_Xfywb
             (z_afxpu
                @ (a_Xfy9t -> Max a_Xfy9t)
                ((Data.Semigroup.$fApplicativeFirst3 @ a_Xfy9t)
                 `cast` (<a_Xfy9t>_R ->_R Sym (Data.Semigroup.N:Max[0] <a_Xfy9t>_R)
                         :: (a_Xfy9t -> a_Xfy9t :: *) ~R# (a_Xfy9t -> Max a_Xfy9t :: *)))))
        (lvl15_rfC6S @ a_Xfy9t)
        (lvl16_rfC6T @ a_Xfy9t)
        (Data.Semigroup.$fDataMax_$cdataCast1 @ a_Xfy9t $dData_Xfywb)
        (lvl17_rfC6U @ a_Xfy9t)
        ((\ (ds_dfzAk :: forall b. Data b => b -> b)
            (x0_Xe2jm :: Max a_Xfy9t) ->
            ds_dfzAk
              @ a_Xfy9t
              $dData_Xfywb
              (x0_Xe2jm
               `cast` (Data.Semigroup.N:Max[0] <a_Xfy9t>_R
                       :: (Max a_Xfy9t :: *) ~R# (a_Xfy9t :: *))))
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <Max a_Xfy9t>_R
                 ->_R Sym (Data.Semigroup.N:Max[0] <a_Xfy9t>_R)
                 :: ((forall b. Data b => b -> b) -> Max a_Xfy9t -> a_Xfy9t :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> Max a_Xfy9t -> Max a_Xfy9t :: *)))
        (\ (@ r_afxIX)
           (@ r'_afxIY)
           (ds_dfzAl :: r_afxIX -> r'_afxIY -> r_afxIX)
           (ds1_dfzAm :: r_afxIX)
           (ds2_dfzAn :: forall d. Data d => d -> r'_afxIY)
           (eta_XmH :: Max a_Xfy9t) ->
           ds_dfzAl
             ds1_dfzAm
             (ds2_dfzAn
                @ a_Xfy9t
                $dData_Xfywb
                (eta_XmH
                 `cast` (Data.Semigroup.N:Max[0] <a_Xfy9t>_R
                         :: (Max a_Xfy9t :: *) ~R# (a_Xfy9t :: *)))))
        (\ (@ r_afxJe)
           (@ r'_afxJf)
           (ds_dfzAo :: r'_afxJf -> r_afxJe -> r_afxJe)
           (ds1_dfzAp :: r_afxJe)
           (ds2_dfzAq :: forall d. Data d => d -> r'_afxJf)
           (x0_ae1SX :: Max a_Xfy9t) ->
           ds_dfzAo
             (ds2_dfzAq
                @ a_Xfy9t
                $dData_Xfywb
                (x0_ae1SX
                 `cast` (Data.Semigroup.N:Max[0] <a_Xfy9t>_R
                         :: (Max a_Xfy9t :: *) ~R# (a_Xfy9t :: *))))
             ds1_dfzAp)
        (\ (@ u_afxJv)
           (ds_dfzAr :: forall d. Data d => d -> u_afxJv)
           (x0_ae1SX :: Max a_Xfy9t) ->
           GHC.Types.:
             @ u_afxJv
             (ds_dfzAr
                @ a_Xfy9t
                $dData_Xfywb
                (x0_ae1SX
                 `cast` (Data.Semigroup.N:Max[0] <a_Xfy9t>_R
                         :: (Max a_Xfy9t :: *) ~R# (a_Xfy9t :: *))))
             (GHC.Types.[] @ u_afxJv))
        (Data.Semigroup.$fDataMax_$cgmapQi @ a_Xfy9t $dData_Xfywb)
        (Data.Semigroup.$fDataMax_$cgmapM @ a_Xfy9t $dData_Xfywb)
        (Data.Semigroup.$fDataMax_$cgmapMp @ a_Xfy9t $dData_Xfywb)
        (Data.Semigroup.$fDataMax_$cgmapMo @ a_Xfy9t $dData_Xfywb)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataArg5 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fDataArg5
  = GHC.Types.TrNameS Data.Semigroup.$fDataArg6

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tcArg :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Semigroup.$tcArg
  = GHC.Types.TyCon
      12181131229304595757##
      13964868205162960136##
      Data.Semigroup.$trModule
      Data.Semigroup.$fDataArg5
      0#
      GHC.Types.krep$*->*->*

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep6_rfC6V :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep6_rfC6V
  = GHC.Types.:
      @ GHC.Types.KindRep $krep_rfC6J (GHC.Types.[] @ GHC.Types.KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep7_rfC6W :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep7_rfC6W
  = GHC.Types.: @ GHC.Types.KindRep $krep1_rfC6K $krep6_rfC6V

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep8_rfC6X :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep8_rfC6X
  = GHC.Types.KindRepTyConApp Data.Semigroup.$tcArg $krep7_rfC6W

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep9_rfC6Y :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep9_rfC6Y = GHC.Types.KindRepFun $krep_rfC6J $krep8_rfC6X

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'Arg1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Semigroup.$tc'Arg1
  = GHC.Types.KindRepFun $krep1_rfC6K $krep9_rfC6Y

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'Arg3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Semigroup.$tc'Arg3 = "'Arg"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'Arg2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$tc'Arg2 = GHC.Types.TrNameS Data.Semigroup.$tc'Arg3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'Arg :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Semigroup.$tc'Arg
  = GHC.Types.TyCon
      1079323530693211499##
      7260223244427450599##
      Data.Semigroup.$trModule
      Data.Semigroup.$tc'Arg2
      2#
      Data.Semigroup.$tc'Arg1

-- RHS size: {terms: 16, types: 49, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataArg4 :: Data.Typeable.Internal.TypeRep Arg
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Semigroup.$fDataArg4
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> * -> *)
           @ Arg
           12181131229304595757##
           13964868205162960136##
           Data.Semigroup.$trModule
           Data.Semigroup.$fDataArg5
           0#
           GHC.Types.krep$*->*->*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> * -> *)
      @ Arg
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 11, types: 25, coercions: 8, joins: 0/0}
Data.Semigroup.$fDataArg10
  :: forall a b.
     (Data a, Data b) =>
     Data.Typeable.Internal.TypeRep (Arg a b)
[GblId,
 Arity=2,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30] 100 0}]
Data.Semigroup.$fDataArg10
  = \ (@ a_afxNW)
      (@ b_afxNX)
      ($dData_afxNY :: Data a_afxNW)
      ($dData1_afxNZ :: Data b_afxNX) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ (Arg a_afxNW)
        @ b_afxNX
        (Data.Typeable.Internal.mkTrApp
           @ *
           @ (* -> *)
           @ Arg
           @ a_afxNW
           Data.Semigroup.$fDataArg4
           ((Data.Data.$p1Data @ a_afxNW $dData_afxNY)
            `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_afxNW>_N
                    :: (Typeable a_afxNW :: Constraint)
                       ~R# (Data.Typeable.Internal.TypeRep a_afxNW :: *))))
        ((Data.Data.$p1Data @ b_afxNX $dData1_afxNZ)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <b_afxNX>_N
                 :: (Typeable b_afxNX :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep b_afxNX :: *)))

-- RHS size: {terms: 21, types: 64, coercions: 15, joins: 0/1}
Data.Semigroup.$fDataArg_$cdataCast2
  :: forall a b.
     (Data a, Data b) =>
     forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c (Arg a b))
[GblId,
 Arity=3,
 Str=<L,U><L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 110 60}]
Data.Semigroup.$fDataArg_$cdataCast2
  = \ (@ a_Xfygm)
      (@ b_Xfygo)
      ($dData_Xfygq :: Data a_Xfygm)
      ($dData1_Xfygs :: Data b_Xfygo)
      (@ (t_afxP2 :: * -> * -> *))
      (@ (c_afxP3 :: * -> *))
      ($dTypeable_afxP5 :: Typeable t_afxP2) ->
      let {
        lvl33_sfAqv :: Bool
        [LclId]
        lvl33_sfAqv
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> * -> *)
              @ (* -> * -> *)
              @ t_afxP2
              @ Arg
              ($dTypeable_afxP5
               `cast` (Data.Typeable.Internal.N:Typeable[0] <*
                                                             -> * -> *>_N <t_afxP2>_N
                       :: (Typeable t_afxP2 :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_afxP2 :: *)))
              Data.Semigroup.$fDataArg4 } in
      \ (f_afxpP
           :: forall d e. (Data d, Data e) => c_afxP3 (t_afxP2 d e)) ->
        case lvl33_sfAqv of {
          False -> GHC.Base.Nothing @ (c_afxP3 (Arg a_Xfygm b_Xfygo));
          True ->
            GHC.Base.Just
              @ (c_afxP3 (Arg a_Xfygm b_Xfygo))
              ((f_afxpP @ a_Xfygm @ b_Xfygo $dData_Xfygq $dData1_Xfygs)
               `cast` (<c_afxP3>_R (UnsafeCo nominal t_afxP2 Arg <a_Xfygm>_N <b_Xfygo>_N)
                       :: (c_afxP3 (t_afxP2 a_Xfygm b_Xfygo) :: *)
                          ~R# (c_afxP3 (Arg a_Xfygm b_Xfygo) :: *)))
        }

-- RHS size: {terms: 5, types: 12, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataArg1 :: forall b a. (a -> b -> Arg a b, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Semigroup.$fDataArg1
  = \ (@ b_Xfygx) (@ a_Xfygv) ->
      (Data.Semigroup.Arg @ a_Xfygv @ b_Xfygx, GHC.Types.False)

-- RHS size: {terms: 75, types: 157, coercions: 19, joins: 0/4}
Data.Semigroup.$fDataArg_$cgmapMp
  :: forall a b.
     (Data a, Data b) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Arg a b -> m (Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 90 60 20] 640 0}]
Data.Semigroup.$fDataArg_$cgmapMp
  = \ (@ a_Xfygv)
      (@ b_Xfygx)
      ($dData_Xfygz :: Data a_Xfygv)
      ($dData1_XfygB :: Data b_Xfygx)
      (@ (m_afxQP :: * -> *))
      ($dMonadPlus_afxQR :: MonadPlus m_afxQP)
      (ds_dfzB3 :: forall d. Data d => d -> m_afxQP d)
      (eta_Xn2 :: Arg a_Xfygv b_Xfygx) ->
      let {
        lvl33_sfAqy :: m_afxQP (Arg a_Xfygv b_Xfygx)
        [LclId]
        lvl33_sfAqy
          = mzero @ m_afxQP $dMonadPlus_afxQR @ (Arg a_Xfygv b_Xfygx) } in
      let {
        $dMonad_sfAeQ [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_afxQP
        [LclId]
        $dMonad_sfAeQ
          = GHC.Base.$p2MonadPlus @ m_afxQP $dMonadPlus_afxQR } in
      >>=
        @ m_afxQP
        $dMonad_sfAeQ
        @ (Arg a_Xfygv b_Xfygx, Bool)
        @ (Arg a_Xfygv b_Xfygx)
        (case eta_Xn2 of { Arg a1_afxpL a2_afxpM ->
         let {
           k_sfAeP [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
             :: forall d b1.
                Data d =>
                Data.Data.Mp m_afxQP (d -> b1) -> d -> m_afxQP (b1, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_sfAeP
             = \ (@ d_ae2Ws)
                 (@ b1_ae2Wt)
                 ($dData2_ae2Wv :: Data d_ae2Ws)
                 (ds1_de7oC [OS=OneShot]
                    :: Data.Data.Mp m_afxQP (d_ae2Ws -> b1_ae2Wt))
                 (y_ae1Tz [OS=OneShot] :: d_ae2Ws) ->
                 let {
                   lvl34_sfAqw :: m_afxQP d_ae2Ws
                   [LclId]
                   lvl34_sfAqw = ds_dfzB3 @ d_ae2Ws $dData2_ae2Wv y_ae1Tz } in
                 >>=
                   @ m_afxQP
                   $dMonad_sfAeQ
                   @ (d_ae2Ws -> b1_ae2Wt, Bool)
                   @ (b1_ae2Wt, Bool)
                   (ds1_de7oC
                    `cast` (Data.Data.N:Mp[0] <m_afxQP>_R <d_ae2Ws -> b1_ae2Wt>_N
                            :: (Data.Data.Mp m_afxQP (d_ae2Ws -> b1_ae2Wt) :: *)
                               ~R# (m_afxQP (d_ae2Ws -> b1_ae2Wt, Bool) :: *)))
                   (\ (ds2_de7oD :: (d_ae2Ws -> b1_ae2Wt, Bool)) ->
                      case ds2_de7oD of { (h_ae1TA, b2_ae1TB) ->
                      mplus
                        @ m_afxQP
                        $dMonadPlus_afxQR
                        @ (b1_ae2Wt, Bool)
                        (>>=
                           @ m_afxQP
                           $dMonad_sfAeQ
                           @ d_ae2Ws
                           @ (b1_ae2Wt, Bool)
                           lvl34_sfAqw
                           (\ (y'_ae1TC :: d_ae2Ws) ->
                              return
                                @ m_afxQP
                                $dMonad_sfAeQ
                                @ (b1_ae2Wt, Bool)
                                (h_ae1TA y'_ae1TC, GHC.Types.True)))
                        (return
                           @ m_afxQP
                           $dMonad_sfAeQ
                           @ (b1_ae2Wt, Bool)
                           (h_ae1TA y_ae1Tz, b2_ae1TB))
                      }) } in
         k_sfAeP
           @ b_Xfygx
           @ (Arg a_Xfygv b_Xfygx)
           $dData1_XfygB
           ((k_sfAeP
               @ a_Xfygv
               @ (b_Xfygx -> Arg a_Xfygv b_Xfygx)
               $dData_Xfygz
               ((return
                   @ m_afxQP
                   $dMonad_sfAeQ
                   @ (a_Xfygv -> b_Xfygx -> Arg a_Xfygv b_Xfygx, Bool)
                   (Data.Semigroup.$fDataArg1 @ b_Xfygx @ a_Xfygv))
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_afxQP>_R <a_Xfygv -> b_Xfygx -> Arg a_Xfygv b_Xfygx>_N)
                        :: (m_afxQP (a_Xfygv -> b_Xfygx -> Arg a_Xfygv b_Xfygx, Bool) :: *)
                           ~R# (Data.Data.Mp
                                  m_afxQP (a_Xfygv -> b_Xfygx -> Arg a_Xfygv b_Xfygx) :: *)))
               a1_afxpL)
            `cast` (Sym (Data.Data.N:Mp[0]
                             <m_afxQP>_R <b_Xfygx -> Arg a_Xfygv b_Xfygx>_N)
                    :: (m_afxQP (b_Xfygx -> Arg a_Xfygv b_Xfygx, Bool) :: *)
                       ~R# (Data.Data.Mp m_afxQP (b_Xfygx -> Arg a_Xfygv b_Xfygx) :: *)))
           a2_afxpM
         })
        (\ (ds1_de7oa :: (Arg a_Xfygv b_Xfygx, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b1_ae1TE) ->
           case b1_ae1TE of {
             False -> lvl33_sfAqy;
             True ->
               return @ m_afxQP $dMonad_sfAeQ @ (Arg a_Xfygv b_Xfygx) x'_ae1TD
           }
           })

-- RHS size: {terms: 40, types: 77, coercions: 0, joins: 0/2}
Data.Semigroup.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data a, Data b) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> a -> b -> m (Arg a b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 120 60 0 0] 340 0}]
Data.Semigroup.$w$cgmapM
  = \ (@ a_sfBu4)
      (@ b_sfBu5)
      (w_sfBu6 :: Data a_sfBu4)
      (w1_sfBu7 :: Data b_sfBu5)
      (@ (m_sfBu8 :: * -> *))
      (w2_sfBu9 :: Monad m_sfBu8)
      (w3_sfBua :: forall d. Data d => d -> m_sfBu8 d)
      (ww_sfBue :: a_sfBu4)
      (ww1_sfBuf :: b_sfBu5) ->
      let {
        k_sfAeM [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
          :: forall d b1. Data d => m_sfBu8 (d -> b1) -> d -> m_sfBu8 b1
        [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
        k_sfAeM
          = \ (@ d_ae2Vh)
              (@ b1_ae2Vi)
              ($dData1_ae2Vk :: Data d_ae2Vh)
              (c_ae1Tm [OS=OneShot] :: m_sfBu8 (d_ae2Vh -> b1_ae2Vi))
              (x_ae1Tn [OS=OneShot] :: d_ae2Vh) ->
              let {
                lvl33_sfAqz :: m_sfBu8 d_ae2Vh
                [LclId]
                lvl33_sfAqz = w3_sfBua @ d_ae2Vh $dData1_ae2Vk x_ae1Tn } in
              >>=
                @ m_sfBu8
                w2_sfBu9
                @ (d_ae2Vh -> b1_ae2Vi)
                @ b1_ae2Vi
                c_ae1Tm
                (\ (c'_ae1To :: d_ae2Vh -> b1_ae2Vi) ->
                   >>=
                     @ m_sfBu8
                     w2_sfBu9
                     @ d_ae2Vh
                     @ b1_ae2Vi
                     lvl33_sfAqz
                     (\ (x'_ae1Tp :: d_ae2Vh) ->
                        return @ m_sfBu8 w2_sfBu9 @ b1_ae2Vi (c'_ae1To x'_ae1Tp))) } in
      k_sfAeM
        @ b_sfBu5
        @ (Arg a_sfBu4 b_sfBu5)
        w1_sfBu7
        (k_sfAeM
           @ a_sfBu4
           @ (b_sfBu5 -> Arg a_sfBu4 b_sfBu5)
           w_sfBu6
           (return
              @ m_sfBu8
              w2_sfBu9
              @ (a_sfBu4 -> b_sfBu5 -> Arg a_sfBu4 b_sfBu5)
              (Data.Semigroup.Arg @ a_sfBu4 @ b_sfBu5))
           ww_sfBue)
        ww1_sfBuf

-- RHS size: {terms: 18, types: 32, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataArg_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Data a, Data b) =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Arg a b -> m (Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_sfBu4)
                 (@ b_sfBu5)
                 (w_sfBu6 [Occ=Once] :: Data a_sfBu4)
                 (w1_sfBu7 [Occ=Once] :: Data b_sfBu5)
                 (@ (m_sfBu8 :: * -> *))
                 (w2_sfBu9 [Occ=Once] :: Monad m_sfBu8)
                 (w3_sfBua [Occ=Once] :: forall d. Data d => d -> m_sfBu8 d)
                 (w4_sfBub [Occ=Once!] :: Arg a_sfBu4 b_sfBu5) ->
                 case w4_sfBub of { Arg ww1_sfBue [Occ=Once] ww2_sfBuf [Occ=Once] ->
                 Data.Semigroup.$w$cgmapM
                   @ a_sfBu4
                   @ b_sfBu5
                   w_sfBu6
                   w1_sfBu7
                   @ m_sfBu8
                   w2_sfBu9
                   w3_sfBua
                   ww1_sfBue
                   ww2_sfBuf
                 }}]
Data.Semigroup.$fDataArg_$cgmapM
  = \ (@ a_sfBu4)
      (@ b_sfBu5)
      (w_sfBu6 :: Data a_sfBu4)
      (w1_sfBu7 :: Data b_sfBu5)
      (@ (m_sfBu8 :: * -> *))
      (w2_sfBu9 :: Monad m_sfBu8)
      (w3_sfBua :: forall d. Data d => d -> m_sfBu8 d)
      (w4_sfBub :: Arg a_sfBu4 b_sfBu5) ->
      case w4_sfBub of { Arg ww1_sfBue ww2_sfBuf ->
      Data.Semigroup.$w$cgmapM
        @ a_sfBu4
        @ b_sfBu5
        w_sfBu6
        w1_sfBu7
        @ m_sfBu8
        w2_sfBu9
        w3_sfBua
        ww1_sfBue
        ww2_sfBuf
      }

-- RHS size: {terms: 26, types: 31, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataArg_$cgmapQi
  :: forall a b.
     (Data a, Data b) =>
     forall u. Int -> (forall d. Data d => d -> u) -> Arg a b -> u
[GblId,
 Arity=5,
 Str=<L,U><L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xfygt)
                 (@ b_Xfygv)
                 ($dData_Xfygx [Occ=Once] :: Data a_Xfygt)
                 ($dData1_Xfygz [Occ=Once] :: Data b_Xfygv)
                 (@ u_afxQl)
                 (ds_dfzB0 [Occ=Once!] :: Int)
                 (ds1_dfzB1 [Occ=Once*!] :: forall d. Data d => d -> u_afxQl)
                 (x_ae1T7 [Occ=Once!] :: Arg a_Xfygt b_Xfygv) ->
                 case x_ae1T7 of { Arg a1_afxpL [Occ=Once] a2_afxpM [Occ=Once] ->
                 case ds_dfzB0 of { GHC.Types.I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_afxQl;
                   0# -> ds1_dfzB1 @ a_Xfygt $dData_Xfygx a1_afxpL;
                   1# -> ds1_dfzB1 @ b_Xfygv $dData1_Xfygz a2_afxpM
                 }
                 }
                 }}]
Data.Semigroup.$fDataArg_$cgmapQi
  = \ (@ a_Xfygt)
      (@ b_Xfygv)
      ($dData_Xfygx :: Data a_Xfygt)
      ($dData1_Xfygz :: Data b_Xfygv)
      (@ u_afxQl)
      (ds_dfzB0 :: Int)
      (ds1_dfzB1 :: forall d. Data d => d -> u_afxQl)
      (x_ae1T7 :: Arg a_Xfygt b_Xfygv) ->
      case x_ae1T7 of { Arg a1_afxpL a2_afxpM ->
      case ds_dfzB0 of { GHC.Types.I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_afxQl;
        0# -> ds1_dfzB1 @ a_Xfygt $dData_Xfygx a1_afxpL;
        1# -> ds1_dfzB1 @ b_Xfygv $dData1_Xfygz a2_afxpM
      }
      }
      }

-- RHS size: {terms: 22, types: 32, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataArg_$cgmapQr
  :: forall a b.
     (Data a, Data b) =>
     forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> Arg a b -> r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xfygr)
                 (@ b_Xfygt)
                 ($dData_Xfygv [Occ=Once] :: Data a_Xfygr)
                 ($dData1_Xfygx [Occ=Once] :: Data b_Xfygt)
                 (@ r_afxPQ)
                 (@ r'_afxPR)
                 (ds_dfzAW :: r'_afxPR -> r_afxPQ -> r_afxPQ)
                 (ds1_dfzAX [Occ=Once] :: r_afxPQ)
                 (ds2_dfzAY :: forall d. Data d => d -> r'_afxPR)
                 (x0_ae1SX [Occ=Once!] :: Arg a_Xfygr b_Xfygt) ->
                 case x0_ae1SX of { Arg a1_afxpL [Occ=Once] a2_afxpM [Occ=Once] ->
                 ds_dfzAW
                   (ds2_dfzAY @ a_Xfygr $dData_Xfygv a1_afxpL)
                   (ds_dfzAW (ds2_dfzAY @ b_Xfygt $dData1_Xfygx a2_afxpM) ds1_dfzAX)
                 }}]
Data.Semigroup.$fDataArg_$cgmapQr
  = \ (@ a_Xfygr)
      (@ b_Xfygt)
      ($dData_Xfygv :: Data a_Xfygr)
      ($dData1_Xfygx :: Data b_Xfygt)
      (@ r_afxPQ)
      (@ r'_afxPR)
      (ds_dfzAW :: r'_afxPR -> r_afxPQ -> r_afxPQ)
      (ds1_dfzAX :: r_afxPQ)
      (ds2_dfzAY :: forall d. Data d => d -> r'_afxPR)
      (x0_ae1SX :: Arg a_Xfygr b_Xfygt) ->
      case x0_ae1SX of { Arg a1_afxpL a2_afxpM ->
      ds_dfzAW
        (ds2_dfzAY @ a_Xfygr $dData_Xfygv a1_afxpL)
        (ds_dfzAW (ds2_dfzAY @ b_Xfygt $dData1_Xfygx a2_afxpM) ds1_dfzAX)
      }

-- RHS size: {terms: 19, types: 29, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataArg_$cgmapQ
  :: forall a b.
     (Data a, Data b) =>
     forall u. (forall d. Data d => d -> u) -> Arg a b -> [u]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,C(C1(U))><S,1*U(U,U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xfygs)
                 (@ b_Xfygu)
                 ($dData_Xfygw [Occ=Once] :: Data a_Xfygs)
                 ($dData1_Xfygy [Occ=Once] :: Data b_Xfygu)
                 (@ u_afxQ7)
                 (ds_dfzAZ :: forall d. Data d => d -> u_afxQ7)
                 (x0_ae1SX [Occ=Once!] :: Arg a_Xfygs b_Xfygu) ->
                 case x0_ae1SX of { Arg a1_afxpL [Occ=Once] a2_afxpM [Occ=Once] ->
                 GHC.Types.:
                   @ u_afxQ7
                   (ds_dfzAZ @ a_Xfygs $dData_Xfygw a1_afxpL)
                   (GHC.Types.:
                      @ u_afxQ7
                      (ds_dfzAZ @ b_Xfygu $dData1_Xfygy a2_afxpM)
                      (GHC.Types.[] @ u_afxQ7))
                 }}]
Data.Semigroup.$fDataArg_$cgmapQ
  = \ (@ a_Xfygs)
      (@ b_Xfygu)
      ($dData_Xfygw :: Data a_Xfygs)
      ($dData1_Xfygy :: Data b_Xfygu)
      (@ u_afxQ7)
      (ds_dfzAZ :: forall d. Data d => d -> u_afxQ7)
      (x0_ae1SX :: Arg a_Xfygs b_Xfygu) ->
      case x0_ae1SX of { Arg a1_afxpL a2_afxpM ->
      GHC.Types.:
        @ u_afxQ7
        (ds_dfzAZ @ a_Xfygs $dData_Xfygw a1_afxpL)
        (GHC.Types.:
           @ u_afxQ7
           (ds_dfzAZ @ b_Xfygu $dData1_Xfygy a2_afxpM)
           (GHC.Types.[] @ u_afxQ7))
      }

-- RHS size: {terms: 22, types: 32, coercions: 8, joins: 0/0}
Data.Semigroup.$fDataArg2
  :: forall a b.
     (Data a, Data b) =>
     forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data d => d -> r')
     -> Arg a b
     -> Const r (Arg a b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><C(C(S)),C(C1(U))><L,U><L,C(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xfygq)
                 (@ b_Xfygs)
                 ($dData_Xfygu [Occ=Once] :: Data a_Xfygq)
                 ($dData1_Xfygw [Occ=Once] :: Data b_Xfygs)
                 (@ r_afxPz)
                 (@ r'_afxPA)
                 (ds_dfzAT :: r_afxPz -> r'_afxPA -> r_afxPz)
                 (ds1_dfzAU [Occ=Once] :: r_afxPz)
                 (ds2_dfzAV :: forall d. Data d => d -> r'_afxPA)
                 (eta_Xn9 [Occ=Once!] :: Arg a_Xfygq b_Xfygs) ->
                 case eta_Xn9 of { Arg a1_afxpL [Occ=Once] a2_afxpM [Occ=Once] ->
                 (ds_dfzAT
                    (ds_dfzAT ds1_dfzAU (ds2_dfzAV @ a_Xfygq $dData_Xfygu a1_afxpL))
                    (ds2_dfzAV @ b_Xfygs $dData1_Xfygw a2_afxpM))
                 `cast` (Sym (Data.Functor.Const.N:Const[0]
                                  <*>_N <r_afxPz>_R <Arg a_Xfygq b_Xfygs>_P)
                         :: (r_afxPz :: *) ~R# (Const r_afxPz (Arg a_Xfygq b_Xfygs) :: *))
                 }}]
Data.Semigroup.$fDataArg2
  = \ (@ a_Xfygq)
      (@ b_Xfygs)
      ($dData_Xfygu :: Data a_Xfygq)
      ($dData1_Xfygw :: Data b_Xfygs)
      (@ r_afxPz)
      (@ r'_afxPA)
      (ds_dfzAT :: r_afxPz -> r'_afxPA -> r_afxPz)
      (ds1_dfzAU :: r_afxPz)
      (ds2_dfzAV :: forall d. Data d => d -> r'_afxPA)
      (eta_Xn9 :: Arg a_Xfygq b_Xfygs) ->
      case eta_Xn9 of { Arg a1_afxpL a2_afxpM ->
      (ds_dfzAT
         (ds_dfzAT ds1_dfzAU (ds2_dfzAV @ a_Xfygq $dData_Xfygu a1_afxpL))
         (ds2_dfzAV @ b_Xfygs $dData1_Xfygw a2_afxpM))
      `cast` (Sym (Data.Functor.Const.N:Const[0]
                       <*>_N <r_afxPz>_R <Arg a_Xfygq b_Xfygs>_P)
              :: (r_afxPz :: *) ~R# (Const r_afxPz (Arg a_Xfygq b_Xfygs) :: *))
      }

-- RHS size: {terms: 16, types: 26, coercions: 5, joins: 0/0}
Data.Semigroup.$fDataArg3
  :: forall a b.
     (Data a, Data b) =>
     (forall b1. Data b1 => b1 -> b1)
     -> Arg a b -> Data.Functor.Identity.Identity (Arg a b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,C(C1(U))><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xfygp)
                 (@ b_Xfygr)
                 ($dData_Xfygt [Occ=Once] :: Data a_Xfygp)
                 ($dData1_Xfygv [Occ=Once] :: Data b_Xfygr)
                 (ds_dfzAS :: forall b1. Data b1 => b1 -> b1)
                 (x0_Xe2jm [Occ=Once!] :: Arg a_Xfygp b_Xfygr) ->
                 case x0_Xe2jm of { Arg a1_afxpL [Occ=Once] a2_afxpM [Occ=Once] ->
                 (Data.Semigroup.Arg
                    @ a_Xfygp
                    @ b_Xfygr
                    (ds_dfzAS @ a_Xfygp $dData_Xfygt a1_afxpL)
                    (ds_dfzAS @ b_Xfygr $dData1_Xfygv a2_afxpM))
                 `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                                  <Arg a_Xfygp b_Xfygr>_R)
                         :: (Arg a_Xfygp b_Xfygr :: *)
                            ~R# (Data.Functor.Identity.Identity (Arg a_Xfygp b_Xfygr) :: *))
                 }}]
Data.Semigroup.$fDataArg3
  = \ (@ a_Xfygp)
      (@ b_Xfygr)
      ($dData_Xfygt :: Data a_Xfygp)
      ($dData1_Xfygv :: Data b_Xfygr)
      (ds_dfzAS :: forall b1. Data b1 => b1 -> b1)
      (x0_Xe2jm :: Arg a_Xfygp b_Xfygr) ->
      case x0_Xe2jm of { Arg a1_afxpL a2_afxpM ->
      (Data.Semigroup.Arg
         @ a_Xfygp
         @ b_Xfygr
         (ds_dfzAS @ a_Xfygp $dData_Xfygt a1_afxpL)
         (ds_dfzAS @ b_Xfygr $dData1_Xfygv a2_afxpM))
      `cast` (Sym (Data.Functor.Identity.N:Identity[0]
                       <Arg a_Xfygp b_Xfygr>_R)
              :: (Arg a_Xfygp b_Xfygr :: *)
                 ~R# (Data.Functor.Identity.Identity (Arg a_Xfygp b_Xfygr) :: *))
      }

-- RHS size: {terms: 85, types: 164, coercions: 19, joins: 0/4}
Data.Semigroup.$fDataArg_$cgmapMo
  :: forall a b.
     (Data a, Data b) =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Arg a b -> m (Arg a b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,C(C1(U))><L,1*U(U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 90 60 20] 720 0}]
Data.Semigroup.$fDataArg_$cgmapMo
  = \ (@ a_Xfygo)
      (@ b_XfyDI)
      ($dData_XfyDL :: Data a_Xfygo)
      ($dData1_XfyDO :: Data b_XfyDI)
      (@ (m_afxR5 :: * -> *))
      ($dMonadPlus_afxR7 :: MonadPlus m_afxR5)
      (ds_dfzB4 :: forall d. Data d => d -> m_afxR5 d)
      (eta_Xnp :: Arg a_Xfygo b_XfyDI) ->
      let {
        lvl33_sfAqF :: m_afxR5 (Arg a_Xfygo b_XfyDI)
        [LclId]
        lvl33_sfAqF
          = mzero @ m_afxR5 $dMonadPlus_afxR7 @ (Arg a_Xfygo b_XfyDI) } in
      let {
        $dMonad_sfAeK [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_afxR5
        [LclId]
        $dMonad_sfAeK
          = GHC.Base.$p2MonadPlus @ m_afxR5 $dMonadPlus_afxR7 } in
      >>=
        @ m_afxR5
        $dMonad_sfAeK
        @ (Arg a_Xfygo b_XfyDI, Bool)
        @ (Arg a_Xfygo b_XfyDI)
        (case eta_Xnp of { Arg a1_afxpL a2_afxpM ->
         let {
           k_sfAeJ [Dmd=<C(C(C(S))),C(C1(C1(U)))>]
             :: forall d b1.
                Data d =>
                Data.Data.Mp m_afxR5 (d -> b1) -> d -> m_afxR5 (b1, Bool)
           [LclId, Arity=3, Str=<L,U><L,U><L,U>, Unf=OtherCon []]
           k_sfAeJ
             = \ (@ d_ae2Ya)
                 (@ b1_ae2Yb)
                 ($dData2_ae2Yd :: Data d_ae2Ya)
                 (ds1_de7pC [OS=OneShot]
                    :: Data.Data.Mp m_afxR5 (d_ae2Ya -> b1_ae2Yb))
                 (y_ae1TO [OS=OneShot] :: d_ae2Ya) ->
                 let {
                   lvl34_sfAqD :: m_afxR5 d_ae2Ya
                   [LclId]
                   lvl34_sfAqD = ds_dfzB4 @ d_ae2Ya $dData2_ae2Yd y_ae1TO } in
                 >>=
                   @ m_afxR5
                   $dMonad_sfAeK
                   @ (d_ae2Ya -> b1_ae2Yb, Bool)
                   @ (b1_ae2Yb, Bool)
                   (ds1_de7pC
                    `cast` (Data.Data.N:Mp[0] <m_afxR5>_R <d_ae2Ya -> b1_ae2Yb>_N
                            :: (Data.Data.Mp m_afxR5 (d_ae2Ya -> b1_ae2Yb) :: *)
                               ~R# (m_afxR5 (d_ae2Ya -> b1_ae2Yb, Bool) :: *)))
                   (\ (ds2_de7pD :: (d_ae2Ya -> b1_ae2Yb, Bool)) ->
                      case ds2_de7pD of { (h_ae1TP, b2_ae1TQ) ->
                      case b2_ae1TQ of {
                        False ->
                          mplus
                            @ m_afxR5
                            $dMonadPlus_afxR7
                            @ (b1_ae2Yb, Bool)
                            (>>=
                               @ m_afxR5
                               $dMonad_sfAeK
                               @ d_ae2Ya
                               @ (b1_ae2Yb, Bool)
                               lvl34_sfAqD
                               (\ (y'_ae1TR :: d_ae2Ya) ->
                                  return
                                    @ m_afxR5
                                    $dMonad_sfAeK
                                    @ (b1_ae2Yb, Bool)
                                    (h_ae1TP y'_ae1TR, GHC.Types.True)))
                            (return
                               @ m_afxR5
                               $dMonad_sfAeK
                               @ (b1_ae2Yb, Bool)
                               (h_ae1TP y_ae1TO, GHC.Types.False));
                        True ->
                          return
                            @ m_afxR5
                            $dMonad_sfAeK
                            @ (b1_ae2Yb, Bool)
                            (h_ae1TP y_ae1TO, GHC.Types.True)
                      }
                      }) } in
         k_sfAeJ
           @ b_XfyDI
           @ (Arg a_Xfygo b_XfyDI)
           $dData1_XfyDO
           ((k_sfAeJ
               @ a_Xfygo
               @ (b_XfyDI -> Arg a_Xfygo b_XfyDI)
               $dData_XfyDL
               ((return
                   @ m_afxR5
                   $dMonad_sfAeK
                   @ (a_Xfygo -> b_XfyDI -> Arg a_Xfygo b_XfyDI, Bool)
                   (Data.Semigroup.$fDataArg1 @ b_XfyDI @ a_Xfygo))
                `cast` (Sym (Data.Data.N:Mp[0]
                                 <m_afxR5>_R <a_Xfygo -> b_XfyDI -> Arg a_Xfygo b_XfyDI>_N)
                        :: (m_afxR5 (a_Xfygo -> b_XfyDI -> Arg a_Xfygo b_XfyDI, Bool) :: *)
                           ~R# (Data.Data.Mp
                                  m_afxR5 (a_Xfygo -> b_XfyDI -> Arg a_Xfygo b_XfyDI) :: *)))
               a1_afxpL)
            `cast` (Sym (Data.Data.N:Mp[0]
                             <m_afxR5>_R <b_XfyDI -> Arg a_Xfygo b_XfyDI>_N)
                    :: (m_afxR5 (b_XfyDI -> Arg a_Xfygo b_XfyDI, Bool) :: *)
                       ~R# (Data.Data.Mp m_afxR5 (b_XfyDI -> Arg a_Xfygo b_XfyDI) :: *)))
           a2_afxpM
         })
        (\ (ds1_de7pa :: (Arg a_Xfygo b_XfyDI, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b1_ae1TT) ->
           case b1_ae1TT of {
             False -> lvl33_sfAqF;
             True ->
               return @ m_afxR5 $dMonad_sfAeK @ (Arg a_Xfygo b_XfyDI) x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 12, coercions: 0, joins: 0/0}
lvl18_rfC6Z :: forall b a. Arg a b -> Constr
[GblId, Arity=1, Str=<S,1*H>m, Unf=OtherCon []]
lvl18_rfC6Z
  = \ (@ b_XfyDI) (@ a_Xfygn) (ds_dfzAN :: Arg a_Xfygn b_XfyDI) ->
      case ds_dfzAN of { Arg ds1_dfzAO ds2_dfzAP ->
      Data.Semigroup.$cArg
      }

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
lvl19_rfC70 :: forall a b. Arg a b -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl19_rfC70
  = \ (@ a_Xfygn) (@ b_XfyDI) _ [Occ=Dead] -> Data.Semigroup.$tArg

-- RHS size: {terms: 7, types: 29, coercions: 0, joins: 0/0}
lvl20_rfC71
  :: forall a b (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Arg a b))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl20_rfC71
  = \ (@ a_Xfygn)
      (@ b_XfyDI)
      (@ (t_afxOJ :: * -> *))
      (@ (c_afxOK :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_afxOK (Arg a_Xfygn b_XfyDI))

-- RHS size: {terms: 44, types: 41, coercions: 52, joins: 0/0}
Data.Semigroup.$fDataArg [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. (Data a, Data b) => Data (Arg a b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_afwMd)
             (@ b_afwMe)
             (v_Xsu :: Data a_afwMd)
             (v1_Xsw :: Data b_afwMe) ->
       Data.Data.C:Data TYPE: Arg a_afwMd b_afwMe
                        (Data.Semigroup.$fDataArg10 @ a_afwMd @ b_afwMe v_Xsu v1_Xsw)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Arg
                                                                                    a_afwMd
                                                                                    b_afwMe>_N
                                :: (Data.Typeable.Internal.TypeRep (Arg a_afwMd b_afwMe) :: *)
                                   ~R# (Typeable (Arg a_afwMd b_afwMe) :: Constraint))
                        Data.Semigroup.$fDataArg_$cgfoldl @ a_afwMd @ b_afwMe v_Xsu v1_Xsw
                        Data.Semigroup.$fDataArg_$cgunfold @ a_afwMd @ b_afwMe v_Xsu v1_Xsw
                        \ (ds_dfzAN [Occ=Once!] :: Arg a_afwMd b_afwMe) ->
                          case ds_dfzAN of { Arg _ [Occ=Dead] _ [Occ=Dead] ->
                          Data.Semigroup.$cArg
                          }
                        \ _ [Occ=Dead] -> Data.Semigroup.$tArg
                        \ (@ (t_afxOJ :: * -> *))
                          (@ (c_afxOK :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_afxOK (Arg a_afwMd b_afwMe))
                        Data.Semigroup.$fDataArg_$cdataCast2
                          @ a_afwMd @ b_afwMe v_Xsu v1_Xsw
                        (Data.Semigroup.$fDataArg3 @ a_afwMd @ b_afwMe v_Xsu v1_Xsw)
                        `cast` (<forall b1. Data b1 => b1 -> b1>_R
                                ->_R <Arg a_afwMd b_afwMe>_R
                                ->_R Data.Functor.Identity.N:Identity[0] <Arg a_afwMd b_afwMe>_R
                                :: ((forall b1. Data b1 => b1 -> b1)
                                    -> Arg a_afwMd b_afwMe
                                    -> Data.Functor.Identity.Identity (Arg a_afwMd b_afwMe) :: *)
                                   ~R# ((forall b1. Data b1 => b1 -> b1)
                                        -> Arg a_afwMd b_afwMe -> Arg a_afwMd b_afwMe :: *))
                        (Data.Semigroup.$fDataArg2 @ a_afwMd @ b_afwMe v_Xsu v1_Xsw)
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <Arg a_afwMd b_afwMe>_R
                                ->_R Data.Functor.Const.N:Const[0]
                                         <*>_N <r>_R <Arg a_afwMd b_afwMe>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> Arg a_afwMd b_afwMe
                                    -> Const r (Arg a_afwMd b_afwMe) :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r
                                        -> (forall d. Data d => d -> r')
                                        -> Arg a_afwMd b_afwMe
                                        -> r :: *))
                        Data.Semigroup.$fDataArg_$cgmapQr @ a_afwMd @ b_afwMe v_Xsu v1_Xsw
                        Data.Semigroup.$fDataArg_$cgmapQ @ a_afwMd @ b_afwMe v_Xsu v1_Xsw
                        Data.Semigroup.$fDataArg_$cgmapQi @ a_afwMd @ b_afwMe v_Xsu v1_Xsw
                        Data.Semigroup.$fDataArg_$cgmapM @ a_afwMd @ b_afwMe v_Xsu v1_Xsw
                        Data.Semigroup.$fDataArg_$cgmapMp @ a_afwMd @ b_afwMe v_Xsu v1_Xsw
                        Data.Semigroup.$fDataArg_$cgmapMo @ a_afwMd @ b_afwMe v_Xsu v1_Xsw]
Data.Semigroup.$fDataArg
  = \ (@ a_Xfygn)
      (@ b_XfyDI)
      ($dData_XfyDL :: Data a_Xfygn)
      ($dData1_XfyDO :: Data b_XfyDI) ->
      Data.Data.C:Data
        @ (Arg a_Xfygn b_XfyDI)
        ((Data.Semigroup.$fDataArg10
            @ a_Xfygn @ b_XfyDI $dData_XfyDL $dData1_XfyDO)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Arg
                                                                     a_Xfygn b_XfyDI>_N
                 :: (Data.Typeable.Internal.TypeRep (Arg a_Xfygn b_XfyDI) :: *)
                    ~R# (Typeable (Arg a_Xfygn b_XfyDI) :: Constraint)))
        (Data.Semigroup.$fDataArg_$cgfoldl
           @ a_Xfygn @ b_XfyDI $dData_XfyDL $dData1_XfyDO)
        (Data.Semigroup.$fDataArg_$cgunfold
           @ a_Xfygn @ b_XfyDI $dData_XfyDL $dData1_XfyDO)
        (lvl18_rfC6Z @ b_XfyDI @ a_Xfygn)
        (lvl19_rfC70 @ a_Xfygn @ b_XfyDI)
        (lvl20_rfC71 @ a_Xfygn @ b_XfyDI)
        (Data.Semigroup.$fDataArg_$cdataCast2
           @ a_Xfygn @ b_XfyDI $dData_XfyDL $dData1_XfyDO)
        ((Data.Semigroup.$fDataArg3
            @ a_Xfygn @ b_XfyDI $dData_XfyDL $dData1_XfyDO)
         `cast` (<forall b1. Data b1 => b1 -> b1>_R
                 ->_R <Arg a_Xfygn b_XfyDI>_R
                 ->_R Data.Functor.Identity.N:Identity[0] <Arg a_Xfygn b_XfyDI>_R
                 :: ((forall b1. Data b1 => b1 -> b1)
                     -> Arg a_Xfygn b_XfyDI
                     -> Data.Functor.Identity.Identity (Arg a_Xfygn b_XfyDI) :: *)
                    ~R# ((forall b1. Data b1 => b1 -> b1)
                         -> Arg a_Xfygn b_XfyDI -> Arg a_Xfygn b_XfyDI :: *)))
        ((Data.Semigroup.$fDataArg2
            @ a_Xfygn @ b_XfyDI $dData_XfyDL $dData1_XfyDO)
         `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                 <r -> r' -> r>_R
                 ->_R <r>_R
                 ->_R <forall d. Data d => d -> r'>_R
                 ->_R <Arg a_Xfygn b_XfyDI>_R
                 ->_R Data.Functor.Const.N:Const[0]
                          <*>_N <r>_R <Arg a_Xfygn b_XfyDI>_P
                 :: (forall r r'.
                     (r -> r' -> r)
                     -> r
                     -> (forall d. Data d => d -> r')
                     -> Arg a_Xfygn b_XfyDI
                     -> Const r (Arg a_Xfygn b_XfyDI) :: *)
                    ~R# (forall r r'.
                         (r -> r' -> r)
                         -> r
                         -> (forall d. Data d => d -> r')
                         -> Arg a_Xfygn b_XfyDI
                         -> r :: *)))
        (Data.Semigroup.$fDataArg_$cgmapQr
           @ a_Xfygn @ b_XfyDI $dData_XfyDL $dData1_XfyDO)
        (Data.Semigroup.$fDataArg_$cgmapQ
           @ a_Xfygn @ b_XfyDI $dData_XfyDL $dData1_XfyDO)
        (Data.Semigroup.$fDataArg_$cgmapQi
           @ a_Xfygn @ b_XfyDI $dData_XfyDL $dData1_XfyDO)
        (Data.Semigroup.$fDataArg_$cgmapM
           @ a_Xfygn @ b_XfyDI $dData_XfyDL $dData1_XfyDO)
        (Data.Semigroup.$fDataArg_$cgmapMp
           @ a_Xfygn @ b_XfyDI $dData_XfyDL $dData1_XfyDO)
        (Data.Semigroup.$fDataArg_$cgmapMo
           @ a_Xfygn @ b_XfyDI $dData_XfyDL $dData1_XfyDO)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataFirst3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fDataFirst3
  = GHC.Types.TrNameS Data.Semigroup.$fDataFirst4

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tcFirst :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Semigroup.$tcFirst
  = GHC.Types.TyCon
      5289672677956055491##
      1507157566582617174##
      Data.Semigroup.$trModule
      Data.Semigroup.$fDataFirst3
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep10_rfC72 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep10_rfC72
  = GHC.Types.KindRepTyConApp Data.Semigroup.$tcFirst $krep2_rfC6L

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'First1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Semigroup.$tc'First1
  = GHC.Types.KindRepFun $krep1_rfC6K $krep10_rfC72

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'First3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Semigroup.$tc'First3 = "'First"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'First2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$tc'First2
  = GHC.Types.TrNameS Data.Semigroup.$tc'First3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'First :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Semigroup.$tc'First
  = GHC.Types.TyCon
      14746522314279732838##
      14022550265149674723##
      Data.Semigroup.$trModule
      Data.Semigroup.$tc'First2
      1#
      Data.Semigroup.$tc'First1

-- RHS size: {terms: 16, types: 41, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataFirst2 :: Data.Typeable.Internal.TypeRep First
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Semigroup.$fDataFirst2
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ First
           5289672677956055491##
           1507157566582617174##
           Data.Semigroup.$trModule
           Data.Semigroup.$fDataFirst3
           0#
           GHC.Types.krep$*Arr*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ First
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 6, types: 11, coercions: 4, joins: 0/0}
Data.Semigroup.$fDataFirst8
  :: forall a. Data a => Data.Typeable.Internal.TypeRep (First a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afxY7) ($dData_afxY8 [Occ=Once] :: Data a_afxY7) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ First
                   @ a_afxY7
                   Data.Semigroup.$fDataFirst2
                   ((Data.Data.$p1Data @ a_afxY7 $dData_afxY8)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_afxY7>_N
                            :: (Typeable a_afxY7 :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep a_afxY7 :: *)))}]
Data.Semigroup.$fDataFirst8
  = \ (@ a_afxY7) ($dData_afxY8 :: Data a_afxY7) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ First
        @ a_afxY7
        Data.Semigroup.$fDataFirst2
        ((Data.Data.$p1Data @ a_afxY7 $dData_afxY8)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_afxY7>_N
                 :: (Typeable a_afxY7 :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep a_afxY7 :: *)))

-- RHS size: {terms: 18, types: 44, coercions: 12, joins: 0/1}
Data.Semigroup.$fDataFirst_$cdataCast1
  :: forall a.
     Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (First a))
[GblId,
 Arity=2,
 Str=<L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 100 60}]
Data.Semigroup.$fDataFirst_$cdataCast1
  = \ (@ a_XfyqV)
      ($dData_XfyqX :: Data a_XfyqV)
      (@ (t_afxYK :: * -> *))
      (@ (c_afxYL :: * -> *))
      ($dTypeable_afxYN :: Typeable t_afxYK) ->
      let {
        lvl33_sfAqM :: Bool
        [LclId]
        lvl33_sfAqM
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_afxYK
              @ First
              ($dTypeable_afxYN
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_afxYK>_N
                       :: (Typeable t_afxYK :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_afxYK :: *)))
              Data.Semigroup.$fDataFirst2 } in
      \ (f_afxqa :: forall d. Data d => c_afxYL (t_afxYK d)) ->
        case lvl33_sfAqM of {
          False -> GHC.Base.Nothing @ (c_afxYL (First a_XfyqV));
          True ->
            GHC.Base.Just
              @ (c_afxYL (First a_XfyqV))
              ((f_afxqa @ a_XfyqV $dData_XfyqX)
               `cast` (<c_afxYL>_R (UnsafeCo nominal t_afxYK First <a_XfyqV>_N)
                       :: (c_afxYL (t_afxYK a_XfyqV) :: *)
                          ~R# (c_afxYL (First a_XfyqV) :: *)))
        }

-- RHS size: {terms: 4, types: 7, coercions: 5, joins: 0/0}
Data.Semigroup.$fDataFirst1 :: forall a. (a -> First a, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Semigroup.$fDataFirst1
  = \ (@ a_Xfyr4) ->
      ((Data.Semigroup.$fApplicativeFirst3 @ a_Xfyr4)
       `cast` (<a_Xfyr4>_R
               ->_R Sym (Data.Semigroup.N:First[0] <a_Xfyr4>_R)
               :: (a_Xfyr4 -> a_Xfyr4 :: *) ~R# (a_Xfyr4 -> First a_Xfyr4 :: *)),
       GHC.Types.False)

-- RHS size: {terms: 57, types: 112, coercions: 4, joins: 0/3}
Data.Semigroup.$fDataFirst_$cgmapMp
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> First a -> m (First a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 510 0}]
Data.Semigroup.$fDataFirst_$cgmapMp
  = \ (@ a_Xfyr4)
      ($dData_Xfyr6 :: Data a_Xfyr4)
      (@ (m_afy0Q :: * -> *))
      ($dMonadPlus_afy0S :: MonadPlus m_afy0Q)
      (ds_dfzBN :: forall d. Data d => d -> m_afy0Q d)
      (eta_XnB :: First a_Xfyr4) ->
      let {
        lvl33_sfAqQ :: m_afy0Q (First a_Xfyr4)
        [LclId]
        lvl33_sfAqQ
          = mzero @ m_afy0Q $dMonadPlus_afy0S @ (First a_Xfyr4) } in
      let {
        $dMonad_sfAeE [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_afy0Q
        [LclId]
        $dMonad_sfAeE
          = GHC.Base.$p2MonadPlus @ m_afy0Q $dMonadPlus_afy0S } in
      >>=
        @ m_afy0Q
        $dMonad_sfAeE
        @ (First a_Xfyr4, Bool)
        @ (First a_Xfyr4)
        (let {
           lvl34_sfAqP :: m_afy0Q a_Xfyr4
           [LclId]
           lvl34_sfAqP
             = ds_dfzBN
                 @ a_Xfyr4
                 $dData_Xfyr6
                 (eta_XnB
                  `cast` (Data.Semigroup.N:First[0] <a_Xfyr4>_R
                          :: (First a_Xfyr4 :: *) ~R# (a_Xfyr4 :: *))) } in
         >>=
           @ m_afy0Q
           $dMonad_sfAeE
           @ (a_Xfyr4 -> First a_Xfyr4, Bool)
           @ (First a_Xfyr4, Bool)
           (return
              @ m_afy0Q
              $dMonad_sfAeE
              @ (a_Xfyr4 -> First a_Xfyr4, Bool)
              (Data.Semigroup.$fDataFirst1 @ a_Xfyr4))
           (\ (ds1_de7oD :: (a_Xfyr4 -> First a_Xfyr4, Bool)) ->
              case ds1_de7oD of { (h_ae1TA, b1_ae1TB) ->
              mplus
                @ m_afy0Q
                $dMonadPlus_afy0S
                @ (First a_Xfyr4, Bool)
                (>>=
                   @ m_afy0Q
                   $dMonad_sfAeE
                   @ a_Xfyr4
                   @ (First a_Xfyr4, Bool)
                   lvl34_sfAqP
                   (\ (y'_ae1TC :: a_Xfyr4) ->
                      return
                        @ m_afy0Q
                        $dMonad_sfAeE
                        @ (First a_Xfyr4, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_afy0Q
                   $dMonad_sfAeE
                   @ (First a_Xfyr4, Bool)
                   (h_ae1TA
                      (eta_XnB
                       `cast` (Data.Semigroup.N:First[0] <a_Xfyr4>_R
                               :: (First a_Xfyr4 :: *) ~R# (a_Xfyr4 :: *))),
                    b1_ae1TB))
              }))
        (\ (ds1_de7oa :: (First a_Xfyr4, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl33_sfAqQ;
             True -> return @ m_afy0Q $dMonad_sfAeE @ (First a_Xfyr4) x'_ae1TD
           }
           })

-- RHS size: {terms: 24, types: 44, coercions: 7, joins: 0/1}
Data.Semigroup.$fDataFirst_$cgmapM
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> First a -> m (First a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120 60 0] 220 0}]
Data.Semigroup.$fDataFirst_$cgmapM
  = \ (@ a_Xfyr3)
      ($dData_Xfyr5 :: Data a_Xfyr3)
      (@ (m_afy0A :: * -> *))
      ($dMonad_afy0C :: Monad m_afy0A)
      (ds_dfzBM :: forall d. Data d => d -> m_afy0A d)
      (eta_XnC :: First a_Xfyr3) ->
      let {
        lvl33_sfAqS :: m_afy0A a_Xfyr3
        [LclId]
        lvl33_sfAqS
          = ds_dfzBM
              @ a_Xfyr3
              $dData_Xfyr5
              (eta_XnC
               `cast` (Data.Semigroup.N:First[0] <a_Xfyr3>_R
                       :: (First a_Xfyr3 :: *) ~R# (a_Xfyr3 :: *))) } in
      >>=
        @ m_afy0A
        $dMonad_afy0C
        @ (a_Xfyr3 -> First a_Xfyr3)
        @ (First a_Xfyr3)
        (return
           @ m_afy0A
           $dMonad_afy0C
           @ (a_Xfyr3 -> First a_Xfyr3)
           ((Data.Semigroup.$fApplicativeFirst3 @ a_Xfyr3)
            `cast` (<a_Xfyr3>_R
                    ->_R Sym (Data.Semigroup.N:First[0] <a_Xfyr3>_R)
                    :: (a_Xfyr3 -> a_Xfyr3 :: *) ~R# (a_Xfyr3 -> First a_Xfyr3 :: *))))
        (\ (c'_ae1To :: a_Xfyr3 -> First a_Xfyr3) ->
           >>=
             @ m_afy0A
             $dMonad_afy0C
             @ a_Xfyr3
             @ (First a_Xfyr3)
             lvl33_sfAqS
             (\ (x'_ae1Tp :: a_Xfyr3) ->
                return
                  @ m_afy0A $dMonad_afy0C @ (First a_Xfyr3) (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 17, types: 20, coercions: 2, joins: 0/0}
Data.Semigroup.$fDataFirst_$cgmapQi
  :: forall a.
     Data a =>
     forall u. Int -> (forall d. Data d => d -> u) -> First a -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_Xfyr2)
                 ($dData_Xfyr4 [Occ=Once] :: Data a_Xfyr2)
                 (@ u_afy0m)
                 (ds_dfzBK [Occ=Once!] :: Int)
                 (ds1_dfzBL [Occ=Once!] :: forall d. Data d => d -> u_afy0m)
                 (x_ae1T7 [Occ=Once] :: First a_Xfyr2) ->
                 case ds_dfzBK of { GHC.Types.I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_afy0m;
                   0# ->
                     ds1_dfzBL
                       @ a_Xfyr2
                       $dData_Xfyr4
                       (x_ae1T7
                        `cast` (Data.Semigroup.N:First[0] <a_Xfyr2>_R
                                :: (First a_Xfyr2 :: *) ~R# (a_Xfyr2 :: *)))
                 }
                 }}]
Data.Semigroup.$fDataFirst_$cgmapQi
  = \ (@ a_Xfyr2)
      ($dData_Xfyr4 :: Data a_Xfyr2)
      (@ u_afy0m)
      (ds_dfzBK :: Int)
      (ds1_dfzBL :: forall d. Data d => d -> u_afy0m)
      (x_ae1T7 :: First a_Xfyr2) ->
      case ds_dfzBK of { GHC.Types.I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_afy0m;
        0# ->
          ds1_dfzBL
            @ a_Xfyr2
            $dData_Xfyr4
            (x_ae1T7
             `cast` (Data.Semigroup.N:First[0] <a_Xfyr2>_R
                     :: (First a_Xfyr2 :: *) ~R# (a_Xfyr2 :: *)))
      }
      }

-- RHS size: {terms: 67, types: 121, coercions: 6, joins: 0/3}
Data.Semigroup.$fDataFirst_$cgmapMo
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> First a -> m (First a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 590 0}]
Data.Semigroup.$fDataFirst_$cgmapMo
  = \ (@ a_XfyqX)
      ($dData_XfyqZ :: Data a_XfyqX)
      (@ (m_afy16 :: * -> *))
      ($dMonadPlus_afy18 :: MonadPlus m_afy16)
      (ds_dfzBO :: forall d. Data d => d -> m_afy16 d)
      (eta_XnL :: First a_XfyqX) ->
      let {
        lvl33_sfAqX :: m_afy16 (First a_XfyqX)
        [LclId]
        lvl33_sfAqX
          = mzero @ m_afy16 $dMonadPlus_afy18 @ (First a_XfyqX) } in
      let {
        $dMonad_sfAeC [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_afy16
        [LclId]
        $dMonad_sfAeC
          = GHC.Base.$p2MonadPlus @ m_afy16 $dMonadPlus_afy18 } in
      >>=
        @ m_afy16
        $dMonad_sfAeC
        @ (First a_XfyqX, Bool)
        @ (First a_XfyqX)
        (let {
           lvl34_sfAqW :: m_afy16 a_XfyqX
           [LclId]
           lvl34_sfAqW
             = ds_dfzBO
                 @ a_XfyqX
                 $dData_XfyqZ
                 (eta_XnL
                  `cast` (Data.Semigroup.N:First[0] <a_XfyqX>_R
                          :: (First a_XfyqX :: *) ~R# (a_XfyqX :: *))) } in
         >>=
           @ m_afy16
           $dMonad_sfAeC
           @ (a_XfyqX -> First a_XfyqX, Bool)
           @ (First a_XfyqX, Bool)
           (return
              @ m_afy16
              $dMonad_sfAeC
              @ (a_XfyqX -> First a_XfyqX, Bool)
              (Data.Semigroup.$fDataFirst1 @ a_XfyqX))
           (\ (ds1_de7pD :: (a_XfyqX -> First a_XfyqX, Bool)) ->
              case ds1_de7pD of { (h_ae1TP, b1_ae1TQ) ->
              case b1_ae1TQ of {
                False ->
                  mplus
                    @ m_afy16
                    $dMonadPlus_afy18
                    @ (First a_XfyqX, Bool)
                    (>>=
                       @ m_afy16
                       $dMonad_sfAeC
                       @ a_XfyqX
                       @ (First a_XfyqX, Bool)
                       lvl34_sfAqW
                       (\ (y'_ae1TR :: a_XfyqX) ->
                          return
                            @ m_afy16
                            $dMonad_sfAeC
                            @ (First a_XfyqX, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_afy16
                       $dMonad_sfAeC
                       @ (First a_XfyqX, Bool)
                       (h_ae1TP
                          (eta_XnL
                           `cast` (Data.Semigroup.N:First[0] <a_XfyqX>_R
                                   :: (First a_XfyqX :: *) ~R# (a_XfyqX :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_afy16
                    $dMonad_sfAeC
                    @ (First a_XfyqX, Bool)
                    (h_ae1TP
                       (eta_XnL
                        `cast` (Data.Semigroup.N:First[0] <a_XfyqX>_R
                                :: (First a_XfyqX :: *) ~R# (a_XfyqX :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds1_de7pa :: (First a_XfyqX, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl33_sfAqX;
             True -> return @ m_afy16 $dMonad_sfAeC @ (First a_XfyqX) x'_ae1TS
           }
           })

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl21_rfC73 :: forall a. First a -> Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl21_rfC73 = \ (@ a_XfyqW) _ [Occ=Dead] -> Data.Semigroup.$cFirst

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl22_rfC74 :: forall a. First a -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl22_rfC74 = \ (@ a_XfyqW) _ [Occ=Dead] -> Data.Semigroup.$tFirst

-- RHS size: {terms: 6, types: 35, coercions: 0, joins: 0/0}
lvl23_rfC75
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c (First a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl23_rfC75
  = \ (@ a_XfyqW)
      (@ (t_afxZ2 :: * -> * -> *))
      (@ (c_afxZ3 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_afxZ3 (First a_XfyqW))

-- RHS size: {terms: 63, types: 100, coercions: 32, joins: 0/0}
Data.Semigroup.$fDataFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data a => Data (First a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_afwM8) (v_XsR :: Data a_afwM8) ->
       Data.Data.C:Data TYPE: First a_afwM8
                        (Data.Semigroup.$fDataFirst8 @ a_afwM8 v_XsR)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <First
                                                                                    a_afwM8>_N
                                :: (Data.Typeable.Internal.TypeRep (First a_afwM8) :: *)
                                   ~R# (Typeable (First a_afwM8) :: Constraint))
                        Data.Semigroup.$fDataFirst_$cgfoldl @ a_afwM8 v_XsR
                        \ (@ (c_afxYr :: * -> *))
                          (k_afxq8 [Occ=Once!]
                             :: forall b r. Data b => c_afxYr (b -> r) -> c_afxYr r)
                          (z_afxq9 [Occ=Once!] :: forall r. r -> c_afxYr r)
                          _ [Occ=Dead] ->
                          k_afxq8
                            @ a_afwM8
                            @ (First a_afwM8)
                            v_XsR
                            (z_afxq9
                               @ (a_afwM8 -> First a_afwM8)
                               ((Data.Semigroup.$fApplicativeFirst3 @ a_afwM8)
                                `cast` (<a_afwM8>_R
                                        ->_R Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                        :: (a_afwM8 -> a_afwM8 :: *)
                                           ~R# (a_afwM8 -> First a_afwM8 :: *))))
                        \ _ [Occ=Dead] -> Data.Semigroup.$cFirst
                        \ _ [Occ=Dead] -> Data.Semigroup.$tFirst
                        Data.Semigroup.$fDataFirst_$cdataCast1 @ a_afwM8 v_XsR
                        \ (@ (t_afxZ2 :: * -> * -> *))
                          (@ (c_afxZ3 :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_afxZ3 (First a_afwM8))
                        (\ (ds_dfzBC [Occ=Once!] :: forall b. Data b => b -> b)
                           (x0_Xe2jm [Occ=Once] :: First a_afwM8) ->
                           ds_dfzBC
                             @ a_afwM8
                             v_XsR
                             (x0_Xe2jm
                              `cast` (Data.Semigroup.N:First[0] <a_afwM8>_R
                                      :: (First a_afwM8 :: *) ~R# (a_afwM8 :: *))))
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <First a_afwM8>_R
                                ->_R Sym (Data.Semigroup.N:First[0] <a_afwM8>_R)
                                :: ((forall b. Data b => b -> b) -> First a_afwM8 -> a_afwM8 :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> First a_afwM8 -> First a_afwM8 :: *))
                        \ (@ r_afxZA)
                          (@ r'_afxZB)
                          (ds_dfzBD [Occ=Once!] :: r_afxZA -> r'_afxZB -> r_afxZA)
                          (ds1_dfzBE [Occ=Once] :: r_afxZA)
                          (ds2_dfzBF [Occ=Once!] :: forall d. Data d => d -> r'_afxZB)
                          (eta_XnI [Occ=Once] :: First a_afwM8) ->
                          ds_dfzBD
                            ds1_dfzBE
                            (ds2_dfzBF
                               @ a_afwM8
                               v_XsR
                               (eta_XnI
                                `cast` (Data.Semigroup.N:First[0] <a_afwM8>_R
                                        :: (First a_afwM8 :: *) ~R# (a_afwM8 :: *))))
                        \ (@ r_afxZR)
                          (@ r'_afxZS)
                          (ds_dfzBG [Occ=Once!] :: r'_afxZS -> r_afxZR -> r_afxZR)
                          (ds1_dfzBH [Occ=Once] :: r_afxZR)
                          (ds2_dfzBI [Occ=Once!] :: forall d. Data d => d -> r'_afxZS)
                          (x0_ae1SX [Occ=Once] :: First a_afwM8) ->
                          ds_dfzBG
                            (ds2_dfzBI
                               @ a_afwM8
                               v_XsR
                               (x0_ae1SX
                                `cast` (Data.Semigroup.N:First[0] <a_afwM8>_R
                                        :: (First a_afwM8 :: *) ~R# (a_afwM8 :: *))))
                            ds1_dfzBH
                        \ (@ u_afy08)
                          (ds_dfzBJ [Occ=Once!] :: forall d. Data d => d -> u_afy08)
                          (x0_ae1SX [Occ=Once] :: First a_afwM8) ->
                          GHC.Types.:
                            @ u_afy08
                            (ds_dfzBJ
                               @ a_afwM8
                               v_XsR
                               (x0_ae1SX
                                `cast` (Data.Semigroup.N:First[0] <a_afwM8>_R
                                        :: (First a_afwM8 :: *) ~R# (a_afwM8 :: *))))
                            (GHC.Types.[] @ u_afy08)
                        Data.Semigroup.$fDataFirst_$cgmapQi @ a_afwM8 v_XsR
                        Data.Semigroup.$fDataFirst_$cgmapM @ a_afwM8 v_XsR
                        Data.Semigroup.$fDataFirst_$cgmapMp @ a_afwM8 v_XsR
                        Data.Semigroup.$fDataFirst_$cgmapMo @ a_afwM8 v_XsR]
Data.Semigroup.$fDataFirst
  = \ (@ a_XfyqW) ($dData_XfyOF :: Data a_XfyqW) ->
      Data.Data.C:Data
        @ (First a_XfyqW)
        ((Data.Semigroup.$fDataFirst8 @ a_XfyqW $dData_XfyOF)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <First
                                                                     a_XfyqW>_N
                 :: (Data.Typeable.Internal.TypeRep (First a_XfyqW) :: *)
                    ~R# (Typeable (First a_XfyqW) :: Constraint)))
        (Data.Semigroup.$fDataFirst_$cgfoldl @ a_XfyqW $dData_XfyOF)
        (\ (@ (c_afxYr :: * -> *))
           (k_afxq8 :: forall b r. Data b => c_afxYr (b -> r) -> c_afxYr r)
           (z_afxq9 :: forall r. r -> c_afxYr r)
           _ [Occ=Dead] ->
           k_afxq8
             @ a_XfyqW
             @ (First a_XfyqW)
             $dData_XfyOF
             (z_afxq9
                @ (a_XfyqW -> First a_XfyqW)
                ((Data.Semigroup.$fApplicativeFirst3 @ a_XfyqW)
                 `cast` (<a_XfyqW>_R
                         ->_R Sym (Data.Semigroup.N:First[0] <a_XfyqW>_R)
                         :: (a_XfyqW -> a_XfyqW :: *)
                            ~R# (a_XfyqW -> First a_XfyqW :: *)))))
        (lvl21_rfC73 @ a_XfyqW)
        (lvl22_rfC74 @ a_XfyqW)
        (Data.Semigroup.$fDataFirst_$cdataCast1 @ a_XfyqW $dData_XfyOF)
        (lvl23_rfC75 @ a_XfyqW)
        ((\ (ds_dfzBC :: forall b. Data b => b -> b)
            (x0_Xe2jm :: First a_XfyqW) ->
            ds_dfzBC
              @ a_XfyqW
              $dData_XfyOF
              (x0_Xe2jm
               `cast` (Data.Semigroup.N:First[0] <a_XfyqW>_R
                       :: (First a_XfyqW :: *) ~R# (a_XfyqW :: *))))
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <First a_XfyqW>_R
                 ->_R Sym (Data.Semigroup.N:First[0] <a_XfyqW>_R)
                 :: ((forall b. Data b => b -> b) -> First a_XfyqW -> a_XfyqW :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> First a_XfyqW -> First a_XfyqW :: *)))
        (\ (@ r_afxZA)
           (@ r'_afxZB)
           (ds_dfzBD :: r_afxZA -> r'_afxZB -> r_afxZA)
           (ds1_dfzBE :: r_afxZA)
           (ds2_dfzBF :: forall d. Data d => d -> r'_afxZB)
           (eta_XnI :: First a_XfyqW) ->
           ds_dfzBD
             ds1_dfzBE
             (ds2_dfzBF
                @ a_XfyqW
                $dData_XfyOF
                (eta_XnI
                 `cast` (Data.Semigroup.N:First[0] <a_XfyqW>_R
                         :: (First a_XfyqW :: *) ~R# (a_XfyqW :: *)))))
        (\ (@ r_afxZR)
           (@ r'_afxZS)
           (ds_dfzBG :: r'_afxZS -> r_afxZR -> r_afxZR)
           (ds1_dfzBH :: r_afxZR)
           (ds2_dfzBI :: forall d. Data d => d -> r'_afxZS)
           (x0_ae1SX :: First a_XfyqW) ->
           ds_dfzBG
             (ds2_dfzBI
                @ a_XfyqW
                $dData_XfyOF
                (x0_ae1SX
                 `cast` (Data.Semigroup.N:First[0] <a_XfyqW>_R
                         :: (First a_XfyqW :: *) ~R# (a_XfyqW :: *))))
             ds1_dfzBH)
        (\ (@ u_afy08)
           (ds_dfzBJ :: forall d. Data d => d -> u_afy08)
           (x0_ae1SX :: First a_XfyqW) ->
           GHC.Types.:
             @ u_afy08
             (ds_dfzBJ
                @ a_XfyqW
                $dData_XfyOF
                (x0_ae1SX
                 `cast` (Data.Semigroup.N:First[0] <a_XfyqW>_R
                         :: (First a_XfyqW :: *) ~R# (a_XfyqW :: *))))
             (GHC.Types.[] @ u_afy08))
        (Data.Semigroup.$fDataFirst_$cgmapQi @ a_XfyqW $dData_XfyOF)
        (Data.Semigroup.$fDataFirst_$cgmapM @ a_XfyqW $dData_XfyOF)
        (Data.Semigroup.$fDataFirst_$cgmapMp @ a_XfyqW $dData_XfyOF)
        (Data.Semigroup.$fDataFirst_$cgmapMo @ a_XfyqW $dData_XfyOF)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataLast3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fDataLast3
  = GHC.Types.TrNameS Data.Semigroup.$fDataLast4

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tcLast :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Semigroup.$tcLast
  = GHC.Types.TyCon
      11434676963974803827##
      15911814017027463598##
      Data.Semigroup.$trModule
      Data.Semigroup.$fDataLast3
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep11_rfC76 :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep11_rfC76
  = GHC.Types.KindRepTyConApp Data.Semigroup.$tcLast $krep2_rfC6L

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'Last1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Semigroup.$tc'Last1
  = GHC.Types.KindRepFun $krep1_rfC6K $krep11_rfC76

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'Last3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Semigroup.$tc'Last3 = "'Last"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'Last2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$tc'Last2
  = GHC.Types.TrNameS Data.Semigroup.$tc'Last3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'Last :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Semigroup.$tc'Last
  = GHC.Types.TyCon
      3320600960953447003##
      12383530634546204472##
      Data.Semigroup.$trModule
      Data.Semigroup.$tc'Last2
      1#
      Data.Semigroup.$tc'Last1

-- RHS size: {terms: 16, types: 41, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataLast2 :: Data.Typeable.Internal.TypeRep Last
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Semigroup.$fDataLast2
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ Last
           11434676963974803827##
           15911814017027463598##
           Data.Semigroup.$trModule
           Data.Semigroup.$fDataLast3
           0#
           GHC.Types.krep$*Arr*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ Last
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 6, types: 11, coercions: 4, joins: 0/0}
Data.Semigroup.$fDataLast8
  :: forall a. Data a => Data.Typeable.Internal.TypeRep (Last a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afy79) ($dData_afy7a [Occ=Once] :: Data a_afy79) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Last
                   @ a_afy79
                   Data.Semigroup.$fDataLast2
                   ((Data.Data.$p1Data @ a_afy79 $dData_afy7a)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_afy79>_N
                            :: (Typeable a_afy79 :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep a_afy79 :: *)))}]
Data.Semigroup.$fDataLast8
  = \ (@ a_afy79) ($dData_afy7a :: Data a_afy79) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ Last
        @ a_afy79
        Data.Semigroup.$fDataLast2
        ((Data.Data.$p1Data @ a_afy79 $dData_afy7a)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_afy79>_N
                 :: (Typeable a_afy79 :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep a_afy79 :: *)))

-- RHS size: {terms: 18, types: 44, coercions: 12, joins: 0/1}
Data.Semigroup.$fDataLast_$cdataCast1
  :: forall a.
     Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Last a))
[GblId,
 Arity=2,
 Str=<L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 100 60}]
Data.Semigroup.$fDataLast_$cdataCast1
  = \ (@ a_XfyAl)
      ($dData_XfyAn :: Data a_XfyAl)
      (@ (t_afy7M :: * -> *))
      (@ (c_afy7N :: * -> *))
      ($dTypeable_afy7P :: Typeable t_afy7M) ->
      let {
        lvl33_sfAr4 :: Bool
        [LclId]
        lvl33_sfAr4
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_afy7M
              @ Last
              ($dTypeable_afy7P
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_afy7M>_N
                       :: (Typeable t_afy7M :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_afy7M :: *)))
              Data.Semigroup.$fDataLast2 } in
      \ (f_afxqr :: forall d. Data d => c_afy7N (t_afy7M d)) ->
        case lvl33_sfAr4 of {
          False -> GHC.Base.Nothing @ (c_afy7N (Last a_XfyAl));
          True ->
            GHC.Base.Just
              @ (c_afy7N (Last a_XfyAl))
              ((f_afxqr @ a_XfyAl $dData_XfyAn)
               `cast` (<c_afy7N>_R (UnsafeCo nominal t_afy7M Last <a_XfyAl>_N)
                       :: (c_afy7N (t_afy7M a_XfyAl) :: *)
                          ~R# (c_afy7N (Last a_XfyAl) :: *)))
        }

-- RHS size: {terms: 4, types: 7, coercions: 5, joins: 0/0}
Data.Semigroup.$fDataLast1 :: forall a. (a -> Last a, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Semigroup.$fDataLast1
  = \ (@ a_XfyAu) ->
      ((Data.Semigroup.$fApplicativeFirst3 @ a_XfyAu)
       `cast` (<a_XfyAu>_R ->_R Sym (Data.Semigroup.N:Last[0] <a_XfyAu>_R)
               :: (a_XfyAu -> a_XfyAu :: *) ~R# (a_XfyAu -> Last a_XfyAu :: *)),
       GHC.Types.False)

-- RHS size: {terms: 57, types: 112, coercions: 4, joins: 0/3}
Data.Semigroup.$fDataLast_$cgmapMp
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Last a -> m (Last a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 510 0}]
Data.Semigroup.$fDataLast_$cgmapMp
  = \ (@ a_XfyAu)
      ($dData_XfyAw :: Data a_XfyAu)
      (@ (m_afy9S :: * -> *))
      ($dMonadPlus_afy9U :: MonadPlus m_afy9S)
      (ds_dfzCj :: forall d. Data d => d -> m_afy9S d)
      (eta_XnZ :: Last a_XfyAu) ->
      let {
        lvl33_sfAr8 :: m_afy9S (Last a_XfyAu)
        [LclId]
        lvl33_sfAr8
          = mzero @ m_afy9S $dMonadPlus_afy9U @ (Last a_XfyAu) } in
      let {
        $dMonad_sfAey [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_afy9S
        [LclId]
        $dMonad_sfAey
          = GHC.Base.$p2MonadPlus @ m_afy9S $dMonadPlus_afy9U } in
      >>=
        @ m_afy9S
        $dMonad_sfAey
        @ (Last a_XfyAu, Bool)
        @ (Last a_XfyAu)
        (let {
           lvl34_sfAr7 :: m_afy9S a_XfyAu
           [LclId]
           lvl34_sfAr7
             = ds_dfzCj
                 @ a_XfyAu
                 $dData_XfyAw
                 (eta_XnZ
                  `cast` (Data.Semigroup.N:Last[0] <a_XfyAu>_R
                          :: (Last a_XfyAu :: *) ~R# (a_XfyAu :: *))) } in
         >>=
           @ m_afy9S
           $dMonad_sfAey
           @ (a_XfyAu -> Last a_XfyAu, Bool)
           @ (Last a_XfyAu, Bool)
           (return
              @ m_afy9S
              $dMonad_sfAey
              @ (a_XfyAu -> Last a_XfyAu, Bool)
              (Data.Semigroup.$fDataLast1 @ a_XfyAu))
           (\ (ds1_de7oD :: (a_XfyAu -> Last a_XfyAu, Bool)) ->
              case ds1_de7oD of { (h_ae1TA, b1_ae1TB) ->
              mplus
                @ m_afy9S
                $dMonadPlus_afy9U
                @ (Last a_XfyAu, Bool)
                (>>=
                   @ m_afy9S
                   $dMonad_sfAey
                   @ a_XfyAu
                   @ (Last a_XfyAu, Bool)
                   lvl34_sfAr7
                   (\ (y'_ae1TC :: a_XfyAu) ->
                      return
                        @ m_afy9S
                        $dMonad_sfAey
                        @ (Last a_XfyAu, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_afy9S
                   $dMonad_sfAey
                   @ (Last a_XfyAu, Bool)
                   (h_ae1TA
                      (eta_XnZ
                       `cast` (Data.Semigroup.N:Last[0] <a_XfyAu>_R
                               :: (Last a_XfyAu :: *) ~R# (a_XfyAu :: *))),
                    b1_ae1TB))
              }))
        (\ (ds1_de7oa :: (Last a_XfyAu, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl33_sfAr8;
             True -> return @ m_afy9S $dMonad_sfAey @ (Last a_XfyAu) x'_ae1TD
           }
           })

-- RHS size: {terms: 24, types: 44, coercions: 7, joins: 0/1}
Data.Semigroup.$fDataLast_$cgmapM
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Last a -> m (Last a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120 60 0] 220 0}]
Data.Semigroup.$fDataLast_$cgmapM
  = \ (@ a_XfyAt)
      ($dData_XfyAv :: Data a_XfyAt)
      (@ (m_afy9C :: * -> *))
      ($dMonad_afy9E :: Monad m_afy9C)
      (ds_dfzCi :: forall d. Data d => d -> m_afy9C d)
      (eta_Xo0 :: Last a_XfyAt) ->
      let {
        lvl33_sfAra :: m_afy9C a_XfyAt
        [LclId]
        lvl33_sfAra
          = ds_dfzCi
              @ a_XfyAt
              $dData_XfyAv
              (eta_Xo0
               `cast` (Data.Semigroup.N:Last[0] <a_XfyAt>_R
                       :: (Last a_XfyAt :: *) ~R# (a_XfyAt :: *))) } in
      >>=
        @ m_afy9C
        $dMonad_afy9E
        @ (a_XfyAt -> Last a_XfyAt)
        @ (Last a_XfyAt)
        (return
           @ m_afy9C
           $dMonad_afy9E
           @ (a_XfyAt -> Last a_XfyAt)
           ((Data.Semigroup.$fApplicativeFirst3 @ a_XfyAt)
            `cast` (<a_XfyAt>_R ->_R Sym (Data.Semigroup.N:Last[0] <a_XfyAt>_R)
                    :: (a_XfyAt -> a_XfyAt :: *) ~R# (a_XfyAt -> Last a_XfyAt :: *))))
        (\ (c'_ae1To :: a_XfyAt -> Last a_XfyAt) ->
           >>=
             @ m_afy9C
             $dMonad_afy9E
             @ a_XfyAt
             @ (Last a_XfyAt)
             lvl33_sfAra
             (\ (x'_ae1Tp :: a_XfyAt) ->
                return
                  @ m_afy9C $dMonad_afy9E @ (Last a_XfyAt) (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 17, types: 20, coercions: 2, joins: 0/0}
Data.Semigroup.$fDataLast_$cgmapQi
  :: forall a.
     Data a =>
     forall u. Int -> (forall d. Data d => d -> u) -> Last a -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XfyAs)
                 ($dData_XfyAu [Occ=Once] :: Data a_XfyAs)
                 (@ u_afy9o)
                 (ds_dfzCg [Occ=Once!] :: Int)
                 (ds1_dfzCh [Occ=Once!] :: forall d. Data d => d -> u_afy9o)
                 (x_ae1T7 [Occ=Once] :: Last a_XfyAs) ->
                 case ds_dfzCg of { GHC.Types.I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_afy9o;
                   0# ->
                     ds1_dfzCh
                       @ a_XfyAs
                       $dData_XfyAu
                       (x_ae1T7
                        `cast` (Data.Semigroup.N:Last[0] <a_XfyAs>_R
                                :: (Last a_XfyAs :: *) ~R# (a_XfyAs :: *)))
                 }
                 }}]
Data.Semigroup.$fDataLast_$cgmapQi
  = \ (@ a_XfyAs)
      ($dData_XfyAu :: Data a_XfyAs)
      (@ u_afy9o)
      (ds_dfzCg :: Int)
      (ds1_dfzCh :: forall d. Data d => d -> u_afy9o)
      (x_ae1T7 :: Last a_XfyAs) ->
      case ds_dfzCg of { GHC.Types.I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_afy9o;
        0# ->
          ds1_dfzCh
            @ a_XfyAs
            $dData_XfyAu
            (x_ae1T7
             `cast` (Data.Semigroup.N:Last[0] <a_XfyAs>_R
                     :: (Last a_XfyAs :: *) ~R# (a_XfyAs :: *)))
      }
      }

-- RHS size: {terms: 67, types: 121, coercions: 6, joins: 0/3}
Data.Semigroup.$fDataLast_$cgmapMo
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Last a -> m (Last a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 590 0}]
Data.Semigroup.$fDataLast_$cgmapMo
  = \ (@ a_XfyAn)
      ($dData_XfyAp :: Data a_XfyAn)
      (@ (m_afya8 :: * -> *))
      ($dMonadPlus_afyaa :: MonadPlus m_afya8)
      (ds_dfzCk :: forall d. Data d => d -> m_afya8 d)
      (eta_Xo9 :: Last a_XfyAn) ->
      let {
        lvl33_sfArf :: m_afya8 (Last a_XfyAn)
        [LclId]
        lvl33_sfArf
          = mzero @ m_afya8 $dMonadPlus_afyaa @ (Last a_XfyAn) } in
      let {
        $dMonad_sfAew [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_afya8
        [LclId]
        $dMonad_sfAew
          = GHC.Base.$p2MonadPlus @ m_afya8 $dMonadPlus_afyaa } in
      >>=
        @ m_afya8
        $dMonad_sfAew
        @ (Last a_XfyAn, Bool)
        @ (Last a_XfyAn)
        (let {
           lvl34_sfAre :: m_afya8 a_XfyAn
           [LclId]
           lvl34_sfAre
             = ds_dfzCk
                 @ a_XfyAn
                 $dData_XfyAp
                 (eta_Xo9
                  `cast` (Data.Semigroup.N:Last[0] <a_XfyAn>_R
                          :: (Last a_XfyAn :: *) ~R# (a_XfyAn :: *))) } in
         >>=
           @ m_afya8
           $dMonad_sfAew
           @ (a_XfyAn -> Last a_XfyAn, Bool)
           @ (Last a_XfyAn, Bool)
           (return
              @ m_afya8
              $dMonad_sfAew
              @ (a_XfyAn -> Last a_XfyAn, Bool)
              (Data.Semigroup.$fDataLast1 @ a_XfyAn))
           (\ (ds1_de7pD :: (a_XfyAn -> Last a_XfyAn, Bool)) ->
              case ds1_de7pD of { (h_ae1TP, b1_ae1TQ) ->
              case b1_ae1TQ of {
                False ->
                  mplus
                    @ m_afya8
                    $dMonadPlus_afyaa
                    @ (Last a_XfyAn, Bool)
                    (>>=
                       @ m_afya8
                       $dMonad_sfAew
                       @ a_XfyAn
                       @ (Last a_XfyAn, Bool)
                       lvl34_sfAre
                       (\ (y'_ae1TR :: a_XfyAn) ->
                          return
                            @ m_afya8
                            $dMonad_sfAew
                            @ (Last a_XfyAn, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_afya8
                       $dMonad_sfAew
                       @ (Last a_XfyAn, Bool)
                       (h_ae1TP
                          (eta_Xo9
                           `cast` (Data.Semigroup.N:Last[0] <a_XfyAn>_R
                                   :: (Last a_XfyAn :: *) ~R# (a_XfyAn :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_afya8
                    $dMonad_sfAew
                    @ (Last a_XfyAn, Bool)
                    (h_ae1TP
                       (eta_Xo9
                        `cast` (Data.Semigroup.N:Last[0] <a_XfyAn>_R
                                :: (Last a_XfyAn :: *) ~R# (a_XfyAn :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds1_de7pa :: (Last a_XfyAn, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl33_sfArf;
             True -> return @ m_afya8 $dMonad_sfAew @ (Last a_XfyAn) x'_ae1TS
           }
           })

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl24_rfC77 :: forall a. Last a -> Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl24_rfC77 = \ (@ a_XfyAm) _ [Occ=Dead] -> Data.Semigroup.$cLast

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl25_rfC78 :: forall a. Last a -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl25_rfC78 = \ (@ a_XfyAm) _ [Occ=Dead] -> Data.Semigroup.$tLast

-- RHS size: {terms: 6, types: 35, coercions: 0, joins: 0/0}
lvl26_rfC79
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c (Last a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl26_rfC79
  = \ (@ a_XfyAm)
      (@ (t_afy84 :: * -> * -> *))
      (@ (c_afy85 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_afy85 (Last a_XfyAm))

-- RHS size: {terms: 63, types: 100, coercions: 32, joins: 0/0}
Data.Semigroup.$fDataLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data a => Data (Last a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_afwM7) (v_Xtf :: Data a_afwM7) ->
       Data.Data.C:Data TYPE: Last a_afwM7
                        (Data.Semigroup.$fDataLast8 @ a_afwM7 v_Xtf)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Last
                                                                                    a_afwM7>_N
                                :: (Data.Typeable.Internal.TypeRep (Last a_afwM7) :: *)
                                   ~R# (Typeable (Last a_afwM7) :: Constraint))
                        Data.Semigroup.$fDataLast_$cgfoldl @ a_afwM7 v_Xtf
                        \ (@ (c_afy7t :: * -> *))
                          (k_afxqp [Occ=Once!]
                             :: forall b r. Data b => c_afy7t (b -> r) -> c_afy7t r)
                          (z_afxqq [Occ=Once!] :: forall r. r -> c_afy7t r)
                          _ [Occ=Dead] ->
                          k_afxqp
                            @ a_afwM7
                            @ (Last a_afwM7)
                            v_Xtf
                            (z_afxqq
                               @ (a_afwM7 -> Last a_afwM7)
                               ((Data.Semigroup.$fApplicativeFirst3 @ a_afwM7)
                                `cast` (<a_afwM7>_R ->_R Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                        :: (a_afwM7 -> a_afwM7 :: *)
                                           ~R# (a_afwM7 -> Last a_afwM7 :: *))))
                        \ _ [Occ=Dead] -> Data.Semigroup.$cLast
                        \ _ [Occ=Dead] -> Data.Semigroup.$tLast
                        Data.Semigroup.$fDataLast_$cdataCast1 @ a_afwM7 v_Xtf
                        \ (@ (t_afy84 :: * -> * -> *))
                          (@ (c_afy85 :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_afy85 (Last a_afwM7))
                        (\ (ds_dfzC8 [Occ=Once!] :: forall b. Data b => b -> b)
                           (x0_Xe2jm [Occ=Once] :: Last a_afwM7) ->
                           ds_dfzC8
                             @ a_afwM7
                             v_Xtf
                             (x0_Xe2jm
                              `cast` (Data.Semigroup.N:Last[0] <a_afwM7>_R
                                      :: (Last a_afwM7 :: *) ~R# (a_afwM7 :: *))))
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <Last a_afwM7>_R
                                ->_R Sym (Data.Semigroup.N:Last[0] <a_afwM7>_R)
                                :: ((forall b. Data b => b -> b) -> Last a_afwM7 -> a_afwM7 :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> Last a_afwM7 -> Last a_afwM7 :: *))
                        \ (@ r_afy8C)
                          (@ r'_afy8D)
                          (ds_dfzC9 [Occ=Once!] :: r_afy8C -> r'_afy8D -> r_afy8C)
                          (ds1_dfzCa [Occ=Once] :: r_afy8C)
                          (ds2_dfzCb [Occ=Once!] :: forall d. Data d => d -> r'_afy8D)
                          (eta_Xo6 [Occ=Once] :: Last a_afwM7) ->
                          ds_dfzC9
                            ds1_dfzCa
                            (ds2_dfzCb
                               @ a_afwM7
                               v_Xtf
                               (eta_Xo6
                                `cast` (Data.Semigroup.N:Last[0] <a_afwM7>_R
                                        :: (Last a_afwM7 :: *) ~R# (a_afwM7 :: *))))
                        \ (@ r_afy8T)
                          (@ r'_afy8U)
                          (ds_dfzCc [Occ=Once!] :: r'_afy8U -> r_afy8T -> r_afy8T)
                          (ds1_dfzCd [Occ=Once] :: r_afy8T)
                          (ds2_dfzCe [Occ=Once!] :: forall d. Data d => d -> r'_afy8U)
                          (x0_ae1SX [Occ=Once] :: Last a_afwM7) ->
                          ds_dfzCc
                            (ds2_dfzCe
                               @ a_afwM7
                               v_Xtf
                               (x0_ae1SX
                                `cast` (Data.Semigroup.N:Last[0] <a_afwM7>_R
                                        :: (Last a_afwM7 :: *) ~R# (a_afwM7 :: *))))
                            ds1_dfzCd
                        \ (@ u_afy9a)
                          (ds_dfzCf [Occ=Once!] :: forall d. Data d => d -> u_afy9a)
                          (x0_ae1SX [Occ=Once] :: Last a_afwM7) ->
                          GHC.Types.:
                            @ u_afy9a
                            (ds_dfzCf
                               @ a_afwM7
                               v_Xtf
                               (x0_ae1SX
                                `cast` (Data.Semigroup.N:Last[0] <a_afwM7>_R
                                        :: (Last a_afwM7 :: *) ~R# (a_afwM7 :: *))))
                            (GHC.Types.[] @ u_afy9a)
                        Data.Semigroup.$fDataLast_$cgmapQi @ a_afwM7 v_Xtf
                        Data.Semigroup.$fDataLast_$cgmapM @ a_afwM7 v_Xtf
                        Data.Semigroup.$fDataLast_$cgmapMp @ a_afwM7 v_Xtf
                        Data.Semigroup.$fDataLast_$cgmapMo @ a_afwM7 v_Xtf]
Data.Semigroup.$fDataLast
  = \ (@ a_XfyAm) ($dData_XfyYt :: Data a_XfyAm) ->
      Data.Data.C:Data
        @ (Last a_XfyAm)
        ((Data.Semigroup.$fDataLast8 @ a_XfyAm $dData_XfyYt)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Last
                                                                     a_XfyAm>_N
                 :: (Data.Typeable.Internal.TypeRep (Last a_XfyAm) :: *)
                    ~R# (Typeable (Last a_XfyAm) :: Constraint)))
        (Data.Semigroup.$fDataLast_$cgfoldl @ a_XfyAm $dData_XfyYt)
        (\ (@ (c_afy7t :: * -> *))
           (k_afxqp :: forall b r. Data b => c_afy7t (b -> r) -> c_afy7t r)
           (z_afxqq :: forall r. r -> c_afy7t r)
           _ [Occ=Dead] ->
           k_afxqp
             @ a_XfyAm
             @ (Last a_XfyAm)
             $dData_XfyYt
             (z_afxqq
                @ (a_XfyAm -> Last a_XfyAm)
                ((Data.Semigroup.$fApplicativeFirst3 @ a_XfyAm)
                 `cast` (<a_XfyAm>_R ->_R Sym (Data.Semigroup.N:Last[0] <a_XfyAm>_R)
                         :: (a_XfyAm -> a_XfyAm :: *) ~R# (a_XfyAm -> Last a_XfyAm :: *)))))
        (lvl24_rfC77 @ a_XfyAm)
        (lvl25_rfC78 @ a_XfyAm)
        (Data.Semigroup.$fDataLast_$cdataCast1 @ a_XfyAm $dData_XfyYt)
        (lvl26_rfC79 @ a_XfyAm)
        ((\ (ds_dfzC8 :: forall b. Data b => b -> b)
            (x0_Xe2jm :: Last a_XfyAm) ->
            ds_dfzC8
              @ a_XfyAm
              $dData_XfyYt
              (x0_Xe2jm
               `cast` (Data.Semigroup.N:Last[0] <a_XfyAm>_R
                       :: (Last a_XfyAm :: *) ~R# (a_XfyAm :: *))))
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <Last a_XfyAm>_R
                 ->_R Sym (Data.Semigroup.N:Last[0] <a_XfyAm>_R)
                 :: ((forall b. Data b => b -> b) -> Last a_XfyAm -> a_XfyAm :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> Last a_XfyAm -> Last a_XfyAm :: *)))
        (\ (@ r_afy8C)
           (@ r'_afy8D)
           (ds_dfzC9 :: r_afy8C -> r'_afy8D -> r_afy8C)
           (ds1_dfzCa :: r_afy8C)
           (ds2_dfzCb :: forall d. Data d => d -> r'_afy8D)
           (eta_Xo6 :: Last a_XfyAm) ->
           ds_dfzC9
             ds1_dfzCa
             (ds2_dfzCb
                @ a_XfyAm
                $dData_XfyYt
                (eta_Xo6
                 `cast` (Data.Semigroup.N:Last[0] <a_XfyAm>_R
                         :: (Last a_XfyAm :: *) ~R# (a_XfyAm :: *)))))
        (\ (@ r_afy8T)
           (@ r'_afy8U)
           (ds_dfzCc :: r'_afy8U -> r_afy8T -> r_afy8T)
           (ds1_dfzCd :: r_afy8T)
           (ds2_dfzCe :: forall d. Data d => d -> r'_afy8U)
           (x0_ae1SX :: Last a_XfyAm) ->
           ds_dfzCc
             (ds2_dfzCe
                @ a_XfyAm
                $dData_XfyYt
                (x0_ae1SX
                 `cast` (Data.Semigroup.N:Last[0] <a_XfyAm>_R
                         :: (Last a_XfyAm :: *) ~R# (a_XfyAm :: *))))
             ds1_dfzCd)
        (\ (@ u_afy9a)
           (ds_dfzCf :: forall d. Data d => d -> u_afy9a)
           (x0_ae1SX :: Last a_XfyAm) ->
           GHC.Types.:
             @ u_afy9a
             (ds_dfzCf
                @ a_XfyAm
                $dData_XfyYt
                (x0_ae1SX
                 `cast` (Data.Semigroup.N:Last[0] <a_XfyAm>_R
                         :: (Last a_XfyAm :: *) ~R# (a_XfyAm :: *))))
             (GHC.Types.[] @ u_afy9a))
        (Data.Semigroup.$fDataLast_$cgmapQi @ a_XfyAm $dData_XfyYt)
        (Data.Semigroup.$fDataLast_$cgmapM @ a_XfyAm $dData_XfyYt)
        (Data.Semigroup.$fDataLast_$cgmapMp @ a_XfyAm $dData_XfyYt)
        (Data.Semigroup.$fDataLast_$cgmapMo @ a_XfyAm $dData_XfyYt)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataWrappedMonoid3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fDataWrappedMonoid3
  = GHC.Types.TrNameS Data.Semigroup.$fDataWrappedMonoid4

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tcWrappedMonoid :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Semigroup.$tcWrappedMonoid
  = GHC.Types.TyCon
      3715640179151546043##
      2823802549020348832##
      Data.Semigroup.$trModule
      Data.Semigroup.$fDataWrappedMonoid3
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep12_rfC7a :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep12_rfC7a
  = GHC.Types.KindRepTyConApp
      Data.Semigroup.$tcWrappedMonoid $krep2_rfC6L

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'WrapMonoid1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Semigroup.$tc'WrapMonoid1
  = GHC.Types.KindRepFun $krep1_rfC6K $krep12_rfC7a

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'WrapMonoid3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Semigroup.$tc'WrapMonoid3 = "'WrapMonoid"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'WrapMonoid2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$tc'WrapMonoid2
  = GHC.Types.TrNameS Data.Semigroup.$tc'WrapMonoid3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'WrapMonoid :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Semigroup.$tc'WrapMonoid
  = GHC.Types.TyCon
      4283841874858276090##
      3445460813926951313##
      Data.Semigroup.$trModule
      Data.Semigroup.$tc'WrapMonoid2
      1#
      Data.Semigroup.$tc'WrapMonoid1

-- RHS size: {terms: 16, types: 41, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataWrappedMonoid2
  :: Data.Typeable.Internal.TypeRep WrappedMonoid
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Semigroup.$fDataWrappedMonoid2
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ WrappedMonoid
           3715640179151546043##
           2823802549020348832##
           Data.Semigroup.$trModule
           Data.Semigroup.$fDataWrappedMonoid3
           0#
           GHC.Types.krep$*Arr*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ WrappedMonoid
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 6, types: 11, coercions: 4, joins: 0/0}
Data.Semigroup.$fDataWrappedMonoid8
  :: forall m.
     Data m =>
     Data.Typeable.Internal.TypeRep (WrappedMonoid m)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_afygb) ($dData_afygc [Occ=Once] :: Data m_afygb) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ WrappedMonoid
                   @ m_afygb
                   Data.Semigroup.$fDataWrappedMonoid2
                   ((Data.Data.$p1Data @ m_afygb $dData_afygc)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <m_afygb>_N
                            :: (Typeable m_afygb :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep m_afygb :: *)))}]
Data.Semigroup.$fDataWrappedMonoid8
  = \ (@ m_afygb) ($dData_afygc :: Data m_afygb) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ WrappedMonoid
        @ m_afygb
        Data.Semigroup.$fDataWrappedMonoid2
        ((Data.Data.$p1Data @ m_afygb $dData_afygc)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <m_afygb>_N
                 :: (Typeable m_afygb :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep m_afygb :: *)))

-- RHS size: {terms: 18, types: 44, coercions: 12, joins: 0/1}
Data.Semigroup.$fDataWrappedMonoid_$cdataCast1
  :: forall m.
     Data m =>
     forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (WrappedMonoid m))
[GblId,
 Arity=2,
 Str=<L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 100 60}]
Data.Semigroup.$fDataWrappedMonoid_$cdataCast1
  = \ (@ m_XfyJL)
      ($dData_XfyJN :: Data m_XfyJL)
      (@ (t_afygO :: * -> *))
      (@ (c_afygP :: * -> *))
      ($dTypeable_afygR :: Typeable t_afygO) ->
      let {
        lvl33_sfArm :: Bool
        [LclId]
        lvl33_sfArm
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_afygO
              @ WrappedMonoid
              ($dTypeable_afygR
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_afygO>_N
                       :: (Typeable t_afygO :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_afygO :: *)))
              Data.Semigroup.$fDataWrappedMonoid2 } in
      \ (f_afxqI :: forall d. Data d => c_afygP (t_afygO d)) ->
        case lvl33_sfArm of {
          False -> GHC.Base.Nothing @ (c_afygP (WrappedMonoid m_XfyJL));
          True ->
            GHC.Base.Just
              @ (c_afygP (WrappedMonoid m_XfyJL))
              ((f_afxqI @ m_XfyJL $dData_XfyJN)
               `cast` (<c_afygP>_R (UnsafeCo nominal t_afygO WrappedMonoid <m_XfyJL>_N)
                       :: (c_afygP (t_afygO m_XfyJL) :: *)
                          ~R# (c_afygP (WrappedMonoid m_XfyJL) :: *)))
        }

-- RHS size: {terms: 4, types: 7, coercions: 5, joins: 0/0}
Data.Semigroup.$fDataWrappedMonoid1
  :: forall m. (m -> WrappedMonoid m, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Semigroup.$fDataWrappedMonoid1
  = \ (@ m_XfyJU) ->
      ((Data.Semigroup.$fApplicativeFirst3 @ m_XfyJU)
       `cast` (<m_XfyJU>_R
               ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_XfyJU>_R)
               :: (m_XfyJU -> m_XfyJU :: *)
                  ~R# (m_XfyJU -> WrappedMonoid m_XfyJU :: *)),
       GHC.Types.False)

-- RHS size: {terms: 57, types: 112, coercions: 4, joins: 0/3}
Data.Semigroup.$fDataWrappedMonoid_$cgmapMp
  :: forall m.
     Data m =>
     forall (m1 :: * -> *).
     MonadPlus m1 =>
     (forall d. Data d => d -> m1 d)
     -> WrappedMonoid m -> m1 (WrappedMonoid m)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 510 0}]
Data.Semigroup.$fDataWrappedMonoid_$cgmapMp
  = \ (@ m_XfyJU)
      ($dData_XfyJW :: Data m_XfyJU)
      (@ (m1_afyiU :: * -> *))
      ($dMonadPlus_afyiW :: MonadPlus m1_afyiU)
      (ds_dfzCP :: forall d. Data d => d -> m1_afyiU d)
      (eta_Xon :: WrappedMonoid m_XfyJU) ->
      let {
        lvl33_sfArq :: m1_afyiU (WrappedMonoid m_XfyJU)
        [LclId]
        lvl33_sfArq
          = mzero @ m1_afyiU $dMonadPlus_afyiW @ (WrappedMonoid m_XfyJU) } in
      let {
        $dMonad_sfAes [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m1_afyiU
        [LclId]
        $dMonad_sfAes
          = GHC.Base.$p2MonadPlus @ m1_afyiU $dMonadPlus_afyiW } in
      >>=
        @ m1_afyiU
        $dMonad_sfAes
        @ (WrappedMonoid m_XfyJU, Bool)
        @ (WrappedMonoid m_XfyJU)
        (let {
           lvl34_sfArp :: m1_afyiU m_XfyJU
           [LclId]
           lvl34_sfArp
             = ds_dfzCP
                 @ m_XfyJU
                 $dData_XfyJW
                 (eta_Xon
                  `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_XfyJU>_R
                          :: (WrappedMonoid m_XfyJU :: *) ~R# (m_XfyJU :: *))) } in
         >>=
           @ m1_afyiU
           $dMonad_sfAes
           @ (m_XfyJU -> WrappedMonoid m_XfyJU, Bool)
           @ (WrappedMonoid m_XfyJU, Bool)
           (return
              @ m1_afyiU
              $dMonad_sfAes
              @ (m_XfyJU -> WrappedMonoid m_XfyJU, Bool)
              (Data.Semigroup.$fDataWrappedMonoid1 @ m_XfyJU))
           (\ (ds1_de7oD :: (m_XfyJU -> WrappedMonoid m_XfyJU, Bool)) ->
              case ds1_de7oD of { (h_ae1TA, b1_ae1TB) ->
              mplus
                @ m1_afyiU
                $dMonadPlus_afyiW
                @ (WrappedMonoid m_XfyJU, Bool)
                (>>=
                   @ m1_afyiU
                   $dMonad_sfAes
                   @ m_XfyJU
                   @ (WrappedMonoid m_XfyJU, Bool)
                   lvl34_sfArp
                   (\ (y'_ae1TC :: m_XfyJU) ->
                      return
                        @ m1_afyiU
                        $dMonad_sfAes
                        @ (WrappedMonoid m_XfyJU, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m1_afyiU
                   $dMonad_sfAes
                   @ (WrappedMonoid m_XfyJU, Bool)
                   (h_ae1TA
                      (eta_Xon
                       `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_XfyJU>_R
                               :: (WrappedMonoid m_XfyJU :: *) ~R# (m_XfyJU :: *))),
                    b1_ae1TB))
              }))
        (\ (ds1_de7oa :: (WrappedMonoid m_XfyJU, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl33_sfArq;
             True ->
               return @ m1_afyiU $dMonad_sfAes @ (WrappedMonoid m_XfyJU) x'_ae1TD
           }
           })

-- RHS size: {terms: 24, types: 44, coercions: 7, joins: 0/1}
Data.Semigroup.$fDataWrappedMonoid_$cgmapM
  :: forall m.
     Data m =>
     forall (m1 :: * -> *).
     Monad m1 =>
     (forall d. Data d => d -> m1 d)
     -> WrappedMonoid m -> m1 (WrappedMonoid m)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120 60 0] 220 0}]
Data.Semigroup.$fDataWrappedMonoid_$cgmapM
  = \ (@ m_XfyJT)
      ($dData_XfyJV :: Data m_XfyJT)
      (@ (m1_afyiE :: * -> *))
      ($dMonad_afyiG :: Monad m1_afyiE)
      (ds_dfzCO :: forall d. Data d => d -> m1_afyiE d)
      (eta_Xoo :: WrappedMonoid m_XfyJT) ->
      let {
        lvl33_sfArs :: m1_afyiE m_XfyJT
        [LclId]
        lvl33_sfArs
          = ds_dfzCO
              @ m_XfyJT
              $dData_XfyJV
              (eta_Xoo
               `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_XfyJT>_R
                       :: (WrappedMonoid m_XfyJT :: *) ~R# (m_XfyJT :: *))) } in
      >>=
        @ m1_afyiE
        $dMonad_afyiG
        @ (m_XfyJT -> WrappedMonoid m_XfyJT)
        @ (WrappedMonoid m_XfyJT)
        (return
           @ m1_afyiE
           $dMonad_afyiG
           @ (m_XfyJT -> WrappedMonoid m_XfyJT)
           ((Data.Semigroup.$fApplicativeFirst3 @ m_XfyJT)
            `cast` (<m_XfyJT>_R
                    ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_XfyJT>_R)
                    :: (m_XfyJT -> m_XfyJT :: *)
                       ~R# (m_XfyJT -> WrappedMonoid m_XfyJT :: *))))
        (\ (c'_ae1To :: m_XfyJT -> WrappedMonoid m_XfyJT) ->
           >>=
             @ m1_afyiE
             $dMonad_afyiG
             @ m_XfyJT
             @ (WrappedMonoid m_XfyJT)
             lvl33_sfArs
             (\ (x'_ae1Tp :: m_XfyJT) ->
                return
                  @ m1_afyiE
                  $dMonad_afyiG
                  @ (WrappedMonoid m_XfyJT)
                  (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 17, types: 20, coercions: 2, joins: 0/0}
Data.Semigroup.$fDataWrappedMonoid_$cgmapQi
  :: forall m.
     Data m =>
     forall u.
     Int -> (forall d. Data d => d -> u) -> WrappedMonoid m -> u
[GblId,
 Arity=4,
 Str=<L,U><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_XfyJS)
                 ($dData_XfyJU [Occ=Once] :: Data m_XfyJS)
                 (@ u_afyiq)
                 (ds_dfzCM [Occ=Once!] :: Int)
                 (ds1_dfzCN [Occ=Once!] :: forall d. Data d => d -> u_afyiq)
                 (x_ae1T7 [Occ=Once] :: WrappedMonoid m_XfyJS) ->
                 case ds_dfzCM of { GHC.Types.I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_afyiq;
                   0# ->
                     ds1_dfzCN
                       @ m_XfyJS
                       $dData_XfyJU
                       (x_ae1T7
                        `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_XfyJS>_R
                                :: (WrappedMonoid m_XfyJS :: *) ~R# (m_XfyJS :: *)))
                 }
                 }}]
Data.Semigroup.$fDataWrappedMonoid_$cgmapQi
  = \ (@ m_XfyJS)
      ($dData_XfyJU :: Data m_XfyJS)
      (@ u_afyiq)
      (ds_dfzCM :: Int)
      (ds1_dfzCN :: forall d. Data d => d -> u_afyiq)
      (x_ae1T7 :: WrappedMonoid m_XfyJS) ->
      case ds_dfzCM of { GHC.Types.I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_afyiq;
        0# ->
          ds1_dfzCN
            @ m_XfyJS
            $dData_XfyJU
            (x_ae1T7
             `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_XfyJS>_R
                     :: (WrappedMonoid m_XfyJS :: *) ~R# (m_XfyJS :: *)))
      }
      }

-- RHS size: {terms: 67, types: 121, coercions: 6, joins: 0/3}
Data.Semigroup.$fDataWrappedMonoid_$cgmapMo
  :: forall m.
     Data m =>
     forall (m1 :: * -> *).
     MonadPlus m1 =>
     (forall d. Data d => d -> m1 d)
     -> WrappedMonoid m -> m1 (WrappedMonoid m)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 590 0}]
Data.Semigroup.$fDataWrappedMonoid_$cgmapMo
  = \ (@ m_XfyJN)
      ($dData_XfyJP :: Data m_XfyJN)
      (@ (m1_afyja :: * -> *))
      ($dMonadPlus_afyjc :: MonadPlus m1_afyja)
      (ds_dfzCQ :: forall d. Data d => d -> m1_afyja d)
      (eta_Xox :: WrappedMonoid m_XfyJN) ->
      let {
        lvl33_sfArx :: m1_afyja (WrappedMonoid m_XfyJN)
        [LclId]
        lvl33_sfArx
          = mzero @ m1_afyja $dMonadPlus_afyjc @ (WrappedMonoid m_XfyJN) } in
      let {
        $dMonad_sfAeq [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m1_afyja
        [LclId]
        $dMonad_sfAeq
          = GHC.Base.$p2MonadPlus @ m1_afyja $dMonadPlus_afyjc } in
      >>=
        @ m1_afyja
        $dMonad_sfAeq
        @ (WrappedMonoid m_XfyJN, Bool)
        @ (WrappedMonoid m_XfyJN)
        (let {
           lvl34_sfArw :: m1_afyja m_XfyJN
           [LclId]
           lvl34_sfArw
             = ds_dfzCQ
                 @ m_XfyJN
                 $dData_XfyJP
                 (eta_Xox
                  `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_XfyJN>_R
                          :: (WrappedMonoid m_XfyJN :: *) ~R# (m_XfyJN :: *))) } in
         >>=
           @ m1_afyja
           $dMonad_sfAeq
           @ (m_XfyJN -> WrappedMonoid m_XfyJN, Bool)
           @ (WrappedMonoid m_XfyJN, Bool)
           (return
              @ m1_afyja
              $dMonad_sfAeq
              @ (m_XfyJN -> WrappedMonoid m_XfyJN, Bool)
              (Data.Semigroup.$fDataWrappedMonoid1 @ m_XfyJN))
           (\ (ds1_de7pD :: (m_XfyJN -> WrappedMonoid m_XfyJN, Bool)) ->
              case ds1_de7pD of { (h_ae1TP, b1_ae1TQ) ->
              case b1_ae1TQ of {
                False ->
                  mplus
                    @ m1_afyja
                    $dMonadPlus_afyjc
                    @ (WrappedMonoid m_XfyJN, Bool)
                    (>>=
                       @ m1_afyja
                       $dMonad_sfAeq
                       @ m_XfyJN
                       @ (WrappedMonoid m_XfyJN, Bool)
                       lvl34_sfArw
                       (\ (y'_ae1TR :: m_XfyJN) ->
                          return
                            @ m1_afyja
                            $dMonad_sfAeq
                            @ (WrappedMonoid m_XfyJN, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m1_afyja
                       $dMonad_sfAeq
                       @ (WrappedMonoid m_XfyJN, Bool)
                       (h_ae1TP
                          (eta_Xox
                           `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_XfyJN>_R
                                   :: (WrappedMonoid m_XfyJN :: *) ~R# (m_XfyJN :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m1_afyja
                    $dMonad_sfAeq
                    @ (WrappedMonoid m_XfyJN, Bool)
                    (h_ae1TP
                       (eta_Xox
                        `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_XfyJN>_R
                                :: (WrappedMonoid m_XfyJN :: *) ~R# (m_XfyJN :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds1_de7pa :: (WrappedMonoid m_XfyJN, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl33_sfArx;
             True ->
               return @ m1_afyja $dMonad_sfAeq @ (WrappedMonoid m_XfyJN) x'_ae1TS
           }
           })

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl27_rfC7b :: forall m. WrappedMonoid m -> Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl27_rfC7b
  = \ (@ m_XfyJM) _ [Occ=Dead] -> Data.Semigroup.$cWrapMonoid

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl28_rfC7c :: forall m. WrappedMonoid m -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl28_rfC7c
  = \ (@ m_XfyJM) _ [Occ=Dead] -> Data.Semigroup.$tWrappedMonoid

-- RHS size: {terms: 6, types: 35, coercions: 0, joins: 0/0}
lvl29_rfC7d
  :: forall m (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e))
     -> Maybe (c (WrappedMonoid m))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl29_rfC7d
  = \ (@ m_XfyJM)
      (@ (t_afyh6 :: * -> * -> *))
      (@ (c_afyh7 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_afyh7 (WrappedMonoid m_XfyJM))

-- RHS size: {terms: 63, types: 100, coercions: 32, joins: 0/0}
Data.Semigroup.$fDataWrappedMonoid [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m. Data m => Data (WrappedMonoid m)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ m_afwM6) (v_XtD :: Data m_afwM6) ->
       Data.Data.C:Data TYPE: WrappedMonoid m_afwM6
                        (Data.Semigroup.$fDataWrappedMonoid8 @ m_afwM6 v_XtD)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <WrappedMonoid
                                                                                    m_afwM6>_N
                                :: (Data.Typeable.Internal.TypeRep (WrappedMonoid m_afwM6) :: *)
                                   ~R# (Typeable (WrappedMonoid m_afwM6) :: Constraint))
                        Data.Semigroup.$fDataWrappedMonoid_$cgfoldl @ m_afwM6 v_XtD
                        \ (@ (c_afygv :: * -> *))
                          (k_afxqG [Occ=Once!]
                             :: forall b r. Data b => c_afygv (b -> r) -> c_afygv r)
                          (z_afxqH [Occ=Once!] :: forall r. r -> c_afygv r)
                          _ [Occ=Dead] ->
                          k_afxqG
                            @ m_afwM6
                            @ (WrappedMonoid m_afwM6)
                            v_XtD
                            (z_afxqH
                               @ (m_afwM6 -> WrappedMonoid m_afwM6)
                               ((Data.Semigroup.$fApplicativeFirst3 @ m_afwM6)
                                `cast` (<m_afwM6>_R
                                        ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                        :: (m_afwM6 -> m_afwM6 :: *)
                                           ~R# (m_afwM6 -> WrappedMonoid m_afwM6 :: *))))
                        \ _ [Occ=Dead] -> Data.Semigroup.$cWrapMonoid
                        \ _ [Occ=Dead] -> Data.Semigroup.$tWrappedMonoid
                        Data.Semigroup.$fDataWrappedMonoid_$cdataCast1 @ m_afwM6 v_XtD
                        \ (@ (t_afyh6 :: * -> * -> *))
                          (@ (c_afyh7 :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_afyh7 (WrappedMonoid m_afwM6))
                        (\ (ds_dfzCE [Occ=Once!] :: forall b. Data b => b -> b)
                           (x0_Xe2jm [Occ=Once] :: WrappedMonoid m_afwM6) ->
                           ds_dfzCE
                             @ m_afwM6
                             v_XtD
                             (x0_Xe2jm
                              `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R
                                      :: (WrappedMonoid m_afwM6 :: *) ~R# (m_afwM6 :: *))))
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <WrappedMonoid m_afwM6>_R
                                ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R)
                                :: ((forall b. Data b => b -> b)
                                    -> WrappedMonoid m_afwM6 -> m_afwM6 :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> WrappedMonoid m_afwM6 -> WrappedMonoid m_afwM6 :: *))
                        \ (@ r_afyhE)
                          (@ r'_afyhF)
                          (ds_dfzCF [Occ=Once!] :: r_afyhE -> r'_afyhF -> r_afyhE)
                          (ds1_dfzCG [Occ=Once] :: r_afyhE)
                          (ds2_dfzCH [Occ=Once!] :: forall d. Data d => d -> r'_afyhF)
                          (eta_Xou [Occ=Once] :: WrappedMonoid m_afwM6) ->
                          ds_dfzCF
                            ds1_dfzCG
                            (ds2_dfzCH
                               @ m_afwM6
                               v_XtD
                               (eta_Xou
                                `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R
                                        :: (WrappedMonoid m_afwM6 :: *) ~R# (m_afwM6 :: *))))
                        \ (@ r_afyhV)
                          (@ r'_afyhW)
                          (ds_dfzCI [Occ=Once!] :: r'_afyhW -> r_afyhV -> r_afyhV)
                          (ds1_dfzCJ [Occ=Once] :: r_afyhV)
                          (ds2_dfzCK [Occ=Once!] :: forall d. Data d => d -> r'_afyhW)
                          (x0_ae1SX [Occ=Once] :: WrappedMonoid m_afwM6) ->
                          ds_dfzCI
                            (ds2_dfzCK
                               @ m_afwM6
                               v_XtD
                               (x0_ae1SX
                                `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R
                                        :: (WrappedMonoid m_afwM6 :: *) ~R# (m_afwM6 :: *))))
                            ds1_dfzCJ
                        \ (@ u_afyic)
                          (ds_dfzCL [Occ=Once!] :: forall d. Data d => d -> u_afyic)
                          (x0_ae1SX [Occ=Once] :: WrappedMonoid m_afwM6) ->
                          GHC.Types.:
                            @ u_afyic
                            (ds_dfzCL
                               @ m_afwM6
                               v_XtD
                               (x0_ae1SX
                                `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_afwM6>_R
                                        :: (WrappedMonoid m_afwM6 :: *) ~R# (m_afwM6 :: *))))
                            (GHC.Types.[] @ u_afyic)
                        Data.Semigroup.$fDataWrappedMonoid_$cgmapQi @ m_afwM6 v_XtD
                        Data.Semigroup.$fDataWrappedMonoid_$cgmapM @ m_afwM6 v_XtD
                        Data.Semigroup.$fDataWrappedMonoid_$cgmapMp @ m_afwM6 v_XtD
                        Data.Semigroup.$fDataWrappedMonoid_$cgmapMo @ m_afwM6 v_XtD]
Data.Semigroup.$fDataWrappedMonoid
  = \ (@ m_XfyJM) ($dData_Xfz8h :: Data m_XfyJM) ->
      Data.Data.C:Data
        @ (WrappedMonoid m_XfyJM)
        ((Data.Semigroup.$fDataWrappedMonoid8 @ m_XfyJM $dData_Xfz8h)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <WrappedMonoid
                                                                     m_XfyJM>_N
                 :: (Data.Typeable.Internal.TypeRep (WrappedMonoid m_XfyJM) :: *)
                    ~R# (Typeable (WrappedMonoid m_XfyJM) :: Constraint)))
        (Data.Semigroup.$fDataWrappedMonoid_$cgfoldl
           @ m_XfyJM $dData_Xfz8h)
        (\ (@ (c_afygv :: * -> *))
           (k_afxqG :: forall b r. Data b => c_afygv (b -> r) -> c_afygv r)
           (z_afxqH :: forall r. r -> c_afygv r)
           _ [Occ=Dead] ->
           k_afxqG
             @ m_XfyJM
             @ (WrappedMonoid m_XfyJM)
             $dData_Xfz8h
             (z_afxqH
                @ (m_XfyJM -> WrappedMonoid m_XfyJM)
                ((Data.Semigroup.$fApplicativeFirst3 @ m_XfyJM)
                 `cast` (<m_XfyJM>_R
                         ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_XfyJM>_R)
                         :: (m_XfyJM -> m_XfyJM :: *)
                            ~R# (m_XfyJM -> WrappedMonoid m_XfyJM :: *)))))
        (lvl27_rfC7b @ m_XfyJM)
        (lvl28_rfC7c @ m_XfyJM)
        (Data.Semigroup.$fDataWrappedMonoid_$cdataCast1
           @ m_XfyJM $dData_Xfz8h)
        (lvl29_rfC7d @ m_XfyJM)
        ((\ (ds_dfzCE :: forall b. Data b => b -> b)
            (x0_Xe2jm :: WrappedMonoid m_XfyJM) ->
            ds_dfzCE
              @ m_XfyJM
              $dData_Xfz8h
              (x0_Xe2jm
               `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_XfyJM>_R
                       :: (WrappedMonoid m_XfyJM :: *) ~R# (m_XfyJM :: *))))
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <WrappedMonoid m_XfyJM>_R
                 ->_R Sym (Data.Semigroup.N:WrappedMonoid[0] <m_XfyJM>_R)
                 :: ((forall b. Data b => b -> b)
                     -> WrappedMonoid m_XfyJM -> m_XfyJM :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> WrappedMonoid m_XfyJM -> WrappedMonoid m_XfyJM :: *)))
        (\ (@ r_afyhE)
           (@ r'_afyhF)
           (ds_dfzCF :: r_afyhE -> r'_afyhF -> r_afyhE)
           (ds1_dfzCG :: r_afyhE)
           (ds2_dfzCH :: forall d. Data d => d -> r'_afyhF)
           (eta_Xou :: WrappedMonoid m_XfyJM) ->
           ds_dfzCF
             ds1_dfzCG
             (ds2_dfzCH
                @ m_XfyJM
                $dData_Xfz8h
                (eta_Xou
                 `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_XfyJM>_R
                         :: (WrappedMonoid m_XfyJM :: *) ~R# (m_XfyJM :: *)))))
        (\ (@ r_afyhV)
           (@ r'_afyhW)
           (ds_dfzCI :: r'_afyhW -> r_afyhV -> r_afyhV)
           (ds1_dfzCJ :: r_afyhV)
           (ds2_dfzCK :: forall d. Data d => d -> r'_afyhW)
           (x0_ae1SX :: WrappedMonoid m_XfyJM) ->
           ds_dfzCI
             (ds2_dfzCK
                @ m_XfyJM
                $dData_Xfz8h
                (x0_ae1SX
                 `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_XfyJM>_R
                         :: (WrappedMonoid m_XfyJM :: *) ~R# (m_XfyJM :: *))))
             ds1_dfzCJ)
        (\ (@ u_afyic)
           (ds_dfzCL :: forall d. Data d => d -> u_afyic)
           (x0_ae1SX :: WrappedMonoid m_XfyJM) ->
           GHC.Types.:
             @ u_afyic
             (ds_dfzCL
                @ m_XfyJM
                $dData_Xfz8h
                (x0_ae1SX
                 `cast` (Data.Semigroup.N:WrappedMonoid[0] <m_XfyJM>_R
                         :: (WrappedMonoid m_XfyJM :: *) ~R# (m_XfyJM :: *))))
             (GHC.Types.[] @ u_afyic))
        (Data.Semigroup.$fDataWrappedMonoid_$cgmapQi
           @ m_XfyJM $dData_Xfz8h)
        (Data.Semigroup.$fDataWrappedMonoid_$cgmapM @ m_XfyJM $dData_Xfz8h)
        (Data.Semigroup.$fDataWrappedMonoid_$cgmapMp
           @ m_XfyJM $dData_Xfz8h)
        (Data.Semigroup.$fDataWrappedMonoid_$cgmapMo
           @ m_XfyJM $dData_Xfz8h)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataOption5 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$fDataOption5
  = GHC.Types.TrNameS Data.Semigroup.$fDataOption6

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tcOption :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Semigroup.$tcOption
  = GHC.Types.TyCon
      10723619047615802556##
      16447525423442151350##
      Data.Semigroup.$trModule
      Data.Semigroup.$fDataOption5
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep13_rfC7e :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep13_rfC7e
  = GHC.Types.KindRepTyConApp Data.Semigroup.$tcOption $krep2_rfC6L

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'Option1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Semigroup.$tc'Option1
  = GHC.Types.KindRepFun $krep3_rfC6M $krep13_rfC7e

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'Option3 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Semigroup.$tc'Option3 = "'Option"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'Option2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Semigroup.$tc'Option2
  = GHC.Types.TrNameS Data.Semigroup.$tc'Option3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Semigroup.$tc'Option :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Semigroup.$tc'Option
  = GHC.Types.TyCon
      10684524870560962689##
      6198254930115905464##
      Data.Semigroup.$trModule
      Data.Semigroup.$tc'Option2
      1#
      Data.Semigroup.$tc'Option1

-- RHS size: {terms: 16, types: 41, coercions: 0, joins: 0/0}
Data.Semigroup.$fDataOption4
  :: Data.Typeable.Internal.TypeRep Option
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Semigroup.$fDataOption4
  = case Data.Typeable.Internal.$wmkTrCon
           @ (* -> *)
           @ Option
           10723619047615802556##
           16447525423442151350##
           Data.Semigroup.$trModule
           Data.Semigroup.$fDataOption5
           0#
           GHC.Types.krep$*Arr*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ (* -> *)
      @ Option
      ww8_idPJm
      ww9_idPJn
      ww10_idPJo
      ww11_idPJp
      ww12_idPJq
    }

-- RHS size: {terms: 6, types: 11, coercions: 4, joins: 0/0}
Data.Semigroup.$fDataOption10
  :: forall a. Data a => Data.Typeable.Internal.TypeRep (Option a)
[GblId,
 Arity=1,
 Str=<S(SLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afyoV) ($dData_afyoW [Occ=Once] :: Data a_afyoV) ->
                 Data.Typeable.Internal.mkTrApp
                   @ *
                   @ *
                   @ Option
                   @ a_afyoV
                   Data.Semigroup.$fDataOption4
                   ((Data.Data.$p1Data @ a_afyoV $dData_afyoW)
                    `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_afyoV>_N
                            :: (Typeable a_afyoV :: Constraint)
                               ~R# (Data.Typeable.Internal.TypeRep a_afyoV :: *)))}]
Data.Semigroup.$fDataOption10
  = \ (@ a_afyoV) ($dData_afyoW :: Data a_afyoV) ->
      Data.Typeable.Internal.mkTrApp
        @ *
        @ *
        @ Option
        @ a_afyoV
        Data.Semigroup.$fDataOption4
        ((Data.Data.$p1Data @ a_afyoV $dData_afyoW)
         `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <a_afyoV>_N
                 :: (Typeable a_afyoV :: Constraint)
                    ~R# (Data.Typeable.Internal.TypeRep a_afyoV :: *)))

-- RHS size: {terms: 18, types: 44, coercions: 12, joins: 0/1}
Data.Semigroup.$fDataOption_$cdataCast1
  :: forall a.
     Data a =>
     forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c (Option a))
[GblId,
 Arity=2,
 Str=<L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 100 60}]
Data.Semigroup.$fDataOption_$cdataCast1
  = \ (@ a_XfyST)
      ($dData_XfySV :: Data a_XfyST)
      (@ (t_afypy :: * -> *))
      (@ (c_afypz :: * -> *))
      ($dTypeable_afypB :: Typeable t_afypy) ->
      let {
        lvl33_sfArE :: Bool
        [LclId]
        lvl33_sfArE
          = Data.Typeable.Internal.sameTypeRep
              @ (* -> *)
              @ (* -> *)
              @ t_afypy
              @ Option
              ($dTypeable_afypB
               `cast` (Data.Typeable.Internal.N:Typeable[0] <* -> *>_N <t_afypy>_N
                       :: (Typeable t_afypy :: Constraint)
                          ~R# (Data.Typeable.Internal.TypeRep t_afypy :: *)))
              Data.Semigroup.$fDataOption4 } in
      \ (f_afxqZ :: forall d. Data d => c_afypz (t_afypy d)) ->
        case lvl33_sfArE of {
          False -> GHC.Base.Nothing @ (c_afypz (Option a_XfyST));
          True ->
            GHC.Base.Just
              @ (c_afypz (Option a_XfyST))
              ((f_afxqZ @ a_XfyST $dData_XfySV)
               `cast` (<c_afypz>_R (UnsafeCo nominal t_afypy Option <a_XfyST>_N)
                       :: (c_afypz (t_afypy a_XfyST) :: *)
                          ~R# (c_afypz (Option a_XfyST) :: *)))
        }

-- RHS size: {terms: 4, types: 8, coercions: 6, joins: 0/0}
Data.Semigroup.$fDataOption1
  :: forall a. (Maybe a -> Option a, Bool)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Semigroup.$fDataOption1
  = \ (@ a_XfyT2) ->
      ((Data.Semigroup.$fDataOption2 @ a_XfyT2)
       `cast` (<Maybe a_XfyT2>_R
               ->_R Sym (Data.Semigroup.N:Option[0]) <a_XfyT2>_N
               :: (Maybe a_XfyT2 -> Maybe a_XfyT2 :: *)
                  ~R# (Maybe a_XfyT2 -> Option a_XfyT2 :: *)),
       GHC.Types.False)

-- RHS size: {terms: 58, types: 122, coercions: 4, joins: 0/3}
Data.Semigroup.$fDataOption_$cgmapMp
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Option a -> m (Option a)
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 530 0}]
Data.Semigroup.$fDataOption_$cgmapMp
  = \ (@ a_XfyT2)
      ($dData_XfyT4 :: Data a_XfyT2)
      (@ (m_afyrE :: * -> *))
      ($dMonadPlus_afyrG :: MonadPlus m_afyrE)
      (ds_dfzDl :: forall d. Data d => d -> m_afyrE d)
      (eta_XoL :: Option a_XfyT2) ->
      let {
        lvl33_sfArI :: m_afyrE (Option a_XfyT2)
        [LclId]
        lvl33_sfArI
          = mzero @ m_afyrE $dMonadPlus_afyrG @ (Option a_XfyT2) } in
      let {
        $dMonad_sfAem [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_afyrE
        [LclId]
        $dMonad_sfAem
          = GHC.Base.$p2MonadPlus @ m_afyrE $dMonadPlus_afyrG } in
      >>=
        @ m_afyrE
        $dMonad_sfAem
        @ (Option a_XfyT2, Bool)
        @ (Option a_XfyT2)
        (let {
           lvl34_sfArH :: m_afyrE (Maybe a_XfyT2)
           [LclId]
           lvl34_sfArH
             = ds_dfzDl
                 @ (Maybe a_XfyT2)
                 (Data.Data.$fDataMaybe @ a_XfyT2 $dData_XfyT4)
                 (eta_XoL
                  `cast` (Data.Semigroup.N:Option[0] <a_XfyT2>_N
                          :: (Option a_XfyT2 :: *) ~R# (Maybe a_XfyT2 :: *))) } in
         >>=
           @ m_afyrE
           $dMonad_sfAem
           @ (Maybe a_XfyT2 -> Option a_XfyT2, Bool)
           @ (Option a_XfyT2, Bool)
           (return
              @ m_afyrE
              $dMonad_sfAem
              @ (Maybe a_XfyT2 -> Option a_XfyT2, Bool)
              (Data.Semigroup.$fDataOption1 @ a_XfyT2))
           (\ (ds1_de7oD :: (Maybe a_XfyT2 -> Option a_XfyT2, Bool)) ->
              case ds1_de7oD of { (h_ae1TA, b1_ae1TB) ->
              mplus
                @ m_afyrE
                $dMonadPlus_afyrG
                @ (Option a_XfyT2, Bool)
                (>>=
                   @ m_afyrE
                   $dMonad_sfAem
                   @ (Maybe a_XfyT2)
                   @ (Option a_XfyT2, Bool)
                   lvl34_sfArH
                   (\ (y'_ae1TC :: Maybe a_XfyT2) ->
                      return
                        @ m_afyrE
                        $dMonad_sfAem
                        @ (Option a_XfyT2, Bool)
                        (h_ae1TA y'_ae1TC, GHC.Types.True)))
                (return
                   @ m_afyrE
                   $dMonad_sfAem
                   @ (Option a_XfyT2, Bool)
                   (h_ae1TA
                      (eta_XoL
                       `cast` (Data.Semigroup.N:Option[0] <a_XfyT2>_N
                               :: (Option a_XfyT2 :: *) ~R# (Maybe a_XfyT2 :: *))),
                    b1_ae1TB))
              }))
        (\ (ds1_de7oa :: (Option a_XfyT2, Bool)) ->
           case ds1_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl33_sfArI;
             True -> return @ m_afyrE $dMonad_sfAem @ (Option a_XfyT2) x'_ae1TD
           }
           })

-- RHS size: {terms: 29, types: 60, coercions: 8, joins: 0/3}
Data.Semigroup.$fDataOption_$cgmapM
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Option a -> m (Option a)
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 120 60] 270 60}]
Data.Semigroup.$fDataOption_$cgmapM
  = \ (@ a_XfyT1)
      ($dData_XfyT3 :: Data a_XfyT1)
      (@ (m_afyro :: * -> *))
      ($dMonad_afyrq :: Monad m_afyro)
      (ds_dfzDk :: forall d. Data d => d -> m_afyro d) ->
      let {
        $dData1_sfAei :: Data (Maybe a_XfyT1)
        [LclId]
        $dData1_sfAei = Data.Data.$fDataMaybe @ a_XfyT1 $dData_XfyT3 } in
      let {
        lvl33_sfArK :: m_afyro (Maybe a_XfyT1 -> Option a_XfyT1)
        [LclId]
        lvl33_sfArK
          = return
              @ m_afyro
              $dMonad_afyrq
              @ (Maybe a_XfyT1 -> Option a_XfyT1)
              ((Data.Semigroup.$fDataOption2 @ a_XfyT1)
               `cast` (<Maybe a_XfyT1>_R
                       ->_R Sym (Data.Semigroup.N:Option[0]) <a_XfyT1>_N
                       :: (Maybe a_XfyT1 -> Maybe a_XfyT1 :: *)
                          ~R# (Maybe a_XfyT1 -> Option a_XfyT1 :: *))) } in
      \ (ds1_dfzD4 :: Option a_XfyT1) ->
        let {
          lvl34_sfArL :: m_afyro (Maybe a_XfyT1)
          [LclId]
          lvl34_sfArL
            = ds_dfzDk
                @ (Maybe a_XfyT1)
                $dData1_sfAei
                (ds1_dfzD4
                 `cast` (Data.Semigroup.N:Option[0] <a_XfyT1>_N
                         :: (Option a_XfyT1 :: *) ~R# (Maybe a_XfyT1 :: *))) } in
        >>=
          @ m_afyro
          $dMonad_afyrq
          @ (Maybe a_XfyT1 -> Option a_XfyT1)
          @ (Option a_XfyT1)
          lvl33_sfArK
          (\ (c'_ae1To :: Maybe a_XfyT1 -> Option a_XfyT1) ->
             >>=
               @ m_afyro
               $dMonad_afyrq
               @ (Maybe a_XfyT1)
               @ (Option a_XfyT1)
               lvl34_sfArL
               (\ (x'_ae1Tp :: Maybe a_XfyT1) ->
                  return
                    @ m_afyro $dMonad_afyrq @ (Option a_XfyT1) (c'_ae1To x'_ae1Tp)))

-- RHS size: {terms: 18, types: 22, coercions: 2, joins: 0/0}
Data.Semigroup.$fDataOption_$cgmapQi
  :: forall a.
     Data a =>
     forall u. Int -> (forall d. Data d => d -> u) -> Option a -> u
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XfyT0)
                 ($dData_XfyT2 [Occ=Once] :: Data a_XfyT0)
                 (@ u_afyra)
                 (ds_dfzDi [Occ=Once!] :: Int)
                 (ds1_dfzDj [Occ=Once!] :: forall d. Data d => d -> u_afyra)
                 (x_ae1T7 [Occ=Once] :: Option a_XfyT0) ->
                 case ds_dfzDi of { GHC.Types.I# x1_a22G [Occ=Once!] ->
                 case x1_a22G of {
                   __DEFAULT -> Data.Maybe.fromJust1 @ u_afyra;
                   0# ->
                     ds1_dfzDj
                       @ (Maybe a_XfyT0)
                       (Data.Data.$fDataMaybe @ a_XfyT0 $dData_XfyT2)
                       (x_ae1T7
                        `cast` (Data.Semigroup.N:Option[0] <a_XfyT0>_N
                                :: (Option a_XfyT0 :: *) ~R# (Maybe a_XfyT0 :: *)))
                 }
                 }}]
Data.Semigroup.$fDataOption_$cgmapQi
  = \ (@ a_XfyT0)
      ($dData_XfyT2 :: Data a_XfyT0)
      (@ u_afyra)
      (ds_dfzDi :: Int)
      (ds1_dfzDj :: forall d. Data d => d -> u_afyra)
      (x_ae1T7 :: Option a_XfyT0) ->
      case ds_dfzDi of { GHC.Types.I# x1_a22G ->
      case x1_a22G of {
        __DEFAULT -> Data.Maybe.fromJust1 @ u_afyra;
        0# ->
          ds1_dfzDj
            @ (Maybe a_XfyT0)
            (Data.Data.$fDataMaybe @ a_XfyT0 $dData_XfyT2)
            (x_ae1T7
             `cast` (Data.Semigroup.N:Option[0] <a_XfyT0>_N
                     :: (Option a_XfyT0 :: *) ~R# (Maybe a_XfyT0 :: *)))
      }
      }

-- RHS size: {terms: 14, types: 23, coercions: 2, joins: 0/0}
Data.Semigroup.$fDataOption_$cgmapQr
  :: forall a.
     Data a =>
     forall r r'.
     (r' -> r -> r)
     -> r -> (forall d. Data d => d -> r') -> Option a -> r
[GblId,
 Arity=5,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XfySY)
                 ($dData_XfyT0 [Occ=Once] :: Data a_XfySY)
                 (@ r_afyqF)
                 (@ r'_afyqG)
                 (ds_dfzDe [Occ=Once!] :: r'_afyqG -> r_afyqF -> r_afyqF)
                 (ds1_dfzDf [Occ=Once] :: r_afyqF)
                 (ds2_dfzDg [Occ=Once!] :: forall d. Data d => d -> r'_afyqG)
                 (x0_ae1SX [Occ=Once] :: Option a_XfySY) ->
                 ds_dfzDe
                   (ds2_dfzDg
                      @ (Maybe a_XfySY)
                      (Data.Data.$fDataMaybe @ a_XfySY $dData_XfyT0)
                      (x0_ae1SX
                       `cast` (Data.Semigroup.N:Option[0] <a_XfySY>_N
                               :: (Option a_XfySY :: *) ~R# (Maybe a_XfySY :: *))))
                   ds1_dfzDf}]
Data.Semigroup.$fDataOption_$cgmapQr
  = \ (@ a_XfySY)
      ($dData_XfyT0 :: Data a_XfySY)
      (@ r_afyqF)
      (@ r'_afyqG)
      (ds_dfzDe :: r'_afyqG -> r_afyqF -> r_afyqF)
      (ds1_dfzDf :: r_afyqF)
      (ds2_dfzDg :: forall d. Data d => d -> r'_afyqG)
      (x0_ae1SX :: Option a_XfySY) ->
      ds_dfzDe
        (ds2_dfzDg
           @ (Maybe a_XfySY)
           (Data.Data.$fDataMaybe @ a_XfySY $dData_XfyT0)
           (x0_ae1SX
            `cast` (Data.Semigroup.N:Option[0] <a_XfySY>_N
                    :: (Option a_XfySY :: *) ~R# (Maybe a_XfySY :: *))))
        ds1_dfzDf

-- RHS size: {terms: 11, types: 19, coercions: 2, joins: 0/0}
Data.Semigroup.$fDataOption_$cgmapQ
  :: forall a.
     Data a =>
     forall u. (forall d. Data d => d -> u) -> Option a -> [u]
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,1*C1(C1(U))><L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XfySZ)
                 ($dData_XfyT1 [Occ=Once] :: Data a_XfySZ)
                 (@ u_afyqW)
                 (ds_dfzDh [Occ=Once!] :: forall d. Data d => d -> u_afyqW)
                 (x0_ae1SX [Occ=Once] :: Option a_XfySZ) ->
                 GHC.Types.:
                   @ u_afyqW
                   (ds_dfzDh
                      @ (Maybe a_XfySZ)
                      (Data.Data.$fDataMaybe @ a_XfySZ $dData_XfyT1)
                      (x0_ae1SX
                       `cast` (Data.Semigroup.N:Option[0] <a_XfySZ>_N
                               :: (Option a_XfySZ :: *) ~R# (Maybe a_XfySZ :: *))))
                   (GHC.Types.[] @ u_afyqW)}]
Data.Semigroup.$fDataOption_$cgmapQ
  = \ (@ a_XfySZ)
      ($dData_XfyT1 :: Data a_XfySZ)
      (@ u_afyqW)
      (ds_dfzDh :: forall d. Data d => d -> u_afyqW)
      (x0_ae1SX :: Option a_XfySZ) ->
      GHC.Types.:
        @ u_afyqW
        (ds_dfzDh
           @ (Maybe a_XfySZ)
           (Data.Data.$fDataMaybe @ a_XfySZ $dData_XfyT1)
           (x0_ae1SX
            `cast` (Data.Semigroup.N:Option[0] <a_XfySZ>_N
                    :: (Option a_XfySZ :: *) ~R# (Maybe a_XfySZ :: *))))
        (GHC.Types.[] @ u_afyqW)

-- RHS size: {terms: 16, types: 26, coercions: 2, joins: 0/1}
Data.Semigroup.$fDataOption_$cgmapQl
  :: forall a.
     Data a =>
     forall r r'.
     (r -> r' -> r)
     -> r -> (forall d. Data d => d -> r') -> Option a -> r
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,C(C1(U))><L,U><L,C(C1(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XfySX)
                 ($dData_XfySZ [Occ=OnceL] :: Data a_XfySX)
                 (@ r_afyqo)
                 (@ r'_afyqp)
                 (ds_dfzDb [Occ=OnceL!] :: r_afyqo -> r'_afyqp -> r_afyqo)
                 (ds1_dfzDc [Occ=OnceL] :: r_afyqo)
                 (ds2_dfzDd [Occ=OnceL!] :: forall d. Data d => d -> r'_afyqp) ->
                 let {
                   $dData1_sfAee [Occ=OnceL] :: Data (Maybe a_XfySX)
                   [LclId]
                   $dData1_sfAee = Data.Data.$fDataMaybe @ a_XfySX $dData_XfySZ } in
                 \ (x_i7Rxi [Occ=Once] :: Option a_XfySX) ->
                   ds_dfzDb
                     ds1_dfzDc
                     (ds2_dfzDd
                        @ (Maybe a_XfySX)
                        $dData1_sfAee
                        (x_i7Rxi
                         `cast` (Data.Semigroup.N:Option[0] <a_XfySX>_N
                                 :: (Option a_XfySX :: *) ~R# (Maybe a_XfySX :: *))))}]
Data.Semigroup.$fDataOption_$cgmapQl
  = \ (@ a_XfySX)
      ($dData_XfySZ :: Data a_XfySX)
      (@ r_afyqo)
      (@ r'_afyqp)
      (ds_dfzDb :: r_afyqo -> r'_afyqp -> r_afyqo)
      (ds1_dfzDc :: r_afyqo)
      (ds2_dfzDd :: forall d. Data d => d -> r'_afyqp) ->
      let {
        $dData1_sfAee :: Data (Maybe a_XfySX)
        [LclId]
        $dData1_sfAee = Data.Data.$fDataMaybe @ a_XfySX $dData_XfySZ } in
      \ (x_i7Rxi :: Option a_XfySX) ->
        ds_dfzDb
          ds1_dfzDc
          (ds2_dfzDd
             @ (Maybe a_XfySX)
             $dData1_sfAee
             (x_i7Rxi
              `cast` (Data.Semigroup.N:Option[0] <a_XfySX>_N
                      :: (Option a_XfySX :: *) ~R# (Maybe a_XfySX :: *))))

-- RHS size: {terms: 8, types: 15, coercions: 2, joins: 0/0}
Data.Semigroup.$fDataOption3
  :: forall a.
     Data a =>
     (forall b. Data b => b -> b) -> Option a -> Maybe a
[GblId,
 Arity=3,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_XfySW)
                 ($dData_XfySY [Occ=Once] :: Data a_XfySW)
                 (ds_dfzDa [Occ=Once!] :: forall b. Data b => b -> b)
                 (x0_Xe2jm [Occ=Once] :: Option a_XfySW) ->
                 ds_dfzDa
                   @ (Maybe a_XfySW)
                   (Data.Data.$fDataMaybe @ a_XfySW $dData_XfySY)
                   (x0_Xe2jm
                    `cast` (Data.Semigroup.N:Option[0] <a_XfySW>_N
                            :: (Option a_XfySW :: *) ~R# (Maybe a_XfySW :: *)))}]
Data.Semigroup.$fDataOption3
  = \ (@ a_XfySW)
      ($dData_XfySY :: Data a_XfySW)
      (ds_dfzDa :: forall b. Data b => b -> b)
      (x0_Xe2jm :: Option a_XfySW) ->
      ds_dfzDa
        @ (Maybe a_XfySW)
        (Data.Data.$fDataMaybe @ a_XfySW $dData_XfySY)
        (x0_Xe2jm
         `cast` (Data.Semigroup.N:Option[0] <a_XfySW>_N
                 :: (Option a_XfySW :: *) ~R# (Maybe a_XfySW :: *)))

-- RHS size: {terms: 68, types: 131, coercions: 6, joins: 0/3}
Data.Semigroup.$fDataOption_$cgmapMo
  :: forall a.
     Data a =>
     forall (m :: * -> *).
     MonadPlus m =>
     (forall d. Data d => d -> m d) -> Option a -> m (Option a)
[GblId,
 Arity=4,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 90 60 0] 610 0}]
Data.Semigroup.$fDataOption_$cgmapMo
  = \ (@ a_XfySV)
      ($dData_XfySX :: Data a_XfySV)
      (@ (m_afyrU :: * -> *))
      ($dMonadPlus_afyrW :: MonadPlus m_afyrU)
      (ds_dfzDm :: forall d. Data d => d -> m_afyrU d)
      (eta_XoV :: Option a_XfySV) ->
      let {
        lvl33_sfArQ :: m_afyrU (Option a_XfySV)
        [LclId]
        lvl33_sfArQ
          = mzero @ m_afyrU $dMonadPlus_afyrW @ (Option a_XfySV) } in
      let {
        $dMonad_sfAec [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          :: Monad m_afyrU
        [LclId]
        $dMonad_sfAec
          = GHC.Base.$p2MonadPlus @ m_afyrU $dMonadPlus_afyrW } in
      >>=
        @ m_afyrU
        $dMonad_sfAec
        @ (Option a_XfySV, Bool)
        @ (Option a_XfySV)
        (let {
           lvl34_sfArP :: m_afyrU (Maybe a_XfySV)
           [LclId]
           lvl34_sfArP
             = ds_dfzDm
                 @ (Maybe a_XfySV)
                 (Data.Data.$fDataMaybe @ a_XfySV $dData_XfySX)
                 (eta_XoV
                  `cast` (Data.Semigroup.N:Option[0] <a_XfySV>_N
                          :: (Option a_XfySV :: *) ~R# (Maybe a_XfySV :: *))) } in
         >>=
           @ m_afyrU
           $dMonad_sfAec
           @ (Maybe a_XfySV -> Option a_XfySV, Bool)
           @ (Option a_XfySV, Bool)
           (return
              @ m_afyrU
              $dMonad_sfAec
              @ (Maybe a_XfySV -> Option a_XfySV, Bool)
              (Data.Semigroup.$fDataOption1 @ a_XfySV))
           (\ (ds1_de7pD :: (Maybe a_XfySV -> Option a_XfySV, Bool)) ->
              case ds1_de7pD of { (h_ae1TP, b1_ae1TQ) ->
              case b1_ae1TQ of {
                False ->
                  mplus
                    @ m_afyrU
                    $dMonadPlus_afyrW
                    @ (Option a_XfySV, Bool)
                    (>>=
                       @ m_afyrU
                       $dMonad_sfAec
                       @ (Maybe a_XfySV)
                       @ (Option a_XfySV, Bool)
                       lvl34_sfArP
                       (\ (y'_ae1TR :: Maybe a_XfySV) ->
                          return
                            @ m_afyrU
                            $dMonad_sfAec
                            @ (Option a_XfySV, Bool)
                            (h_ae1TP y'_ae1TR, GHC.Types.True)))
                    (return
                       @ m_afyrU
                       $dMonad_sfAec
                       @ (Option a_XfySV, Bool)
                       (h_ae1TP
                          (eta_XoV
                           `cast` (Data.Semigroup.N:Option[0] <a_XfySV>_N
                                   :: (Option a_XfySV :: *) ~R# (Maybe a_XfySV :: *))),
                        GHC.Types.False));
                True ->
                  return
                    @ m_afyrU
                    $dMonad_sfAec
                    @ (Option a_XfySV, Bool)
                    (h_ae1TP
                       (eta_XoV
                        `cast` (Data.Semigroup.N:Option[0] <a_XfySV>_N
                                :: (Option a_XfySV :: *) ~R# (Maybe a_XfySV :: *))),
                     GHC.Types.True)
              }
              }))
        (\ (ds1_de7pa :: (Option a_XfySV, Bool)) ->
           case ds1_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl33_sfArQ;
             True -> return @ m_afyrU $dMonad_sfAec @ (Option a_XfySV) x'_ae1TS
           }
           })

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl30_rfC7f :: forall a. Option a -> Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl30_rfC7f = \ (@ a_XfySU) _ [Occ=Dead] -> Data.Semigroup.$cOption

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl31_rfC7g :: forall a. Option a -> DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []]
lvl31_rfC7g = \ (@ a_XfySU) _ [Occ=Dead] -> Data.Semigroup.$tOption

-- RHS size: {terms: 6, types: 35, coercions: 0, joins: 0/0}
lvl32_rfC7h
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c (Option a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl32_rfC7h
  = \ (@ a_XfySU)
      (@ (t_afypQ :: * -> * -> *))
      (@ (c_afypR :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_afypR (Option a_XfySU))

-- RHS size: {terms: 30, types: 21, coercions: 19, joins: 0/0}
Data.Semigroup.$fDataOption [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data a => Data (Option a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
 Unf=DFun: \ (@ a_afwM5) (v_Xu1 :: Data a_afwM5) ->
       Data.Data.C:Data TYPE: Option a_afwM5
                        (Data.Semigroup.$fDataOption10 @ a_afwM5 v_Xu1)
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Option
                                                                                    a_afwM5>_N
                                :: (Data.Typeable.Internal.TypeRep (Option a_afwM5) :: *)
                                   ~R# (Typeable (Option a_afwM5) :: Constraint))
                        Data.Semigroup.$fDataOption_$cgfoldl @ a_afwM5 v_Xu1
                        Data.Semigroup.$fDataOption_$cgunfold @ a_afwM5 v_Xu1
                        \ _ [Occ=Dead] -> Data.Semigroup.$cOption
                        \ _ [Occ=Dead] -> Data.Semigroup.$tOption
                        Data.Semigroup.$fDataOption_$cdataCast1 @ a_afwM5 v_Xu1
                        \ (@ (t_afypQ :: * -> * -> *))
                          (@ (c_afypR :: * -> *))
                          _ [Occ=Dead]
                          _ [Occ=Dead] ->
                          GHC.Base.Nothing @ (c_afypR (Option a_afwM5))
                        (Data.Semigroup.$fDataOption3 @ a_afwM5 v_Xu1)
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <Option a_afwM5>_R
                                ->_R Sym (Data.Semigroup.N:Option[0]) <a_afwM5>_N
                                :: ((forall b. Data b => b -> b)
                                    -> Option a_afwM5 -> Maybe a_afwM5 :: *)
                                   ~R# ((forall b. Data b => b -> b)
                                        -> Option a_afwM5 -> Option a_afwM5 :: *))
                        Data.Semigroup.$fDataOption_$cgmapQl @ a_afwM5 v_Xu1
                        Data.Semigroup.$fDataOption_$cgmapQr @ a_afwM5 v_Xu1
                        Data.Semigroup.$fDataOption_$cgmapQ @ a_afwM5 v_Xu1
                        Data.Semigroup.$fDataOption_$cgmapQi @ a_afwM5 v_Xu1
                        Data.Semigroup.$fDataOption_$cgmapM @ a_afwM5 v_Xu1
                        Data.Semigroup.$fDataOption_$cgmapMp @ a_afwM5 v_Xu1
                        Data.Semigroup.$fDataOption_$cgmapMo @ a_afwM5 v_Xu1]
Data.Semigroup.$fDataOption
  = \ (@ a_XfySU) ($dData_XfzhN :: Data a_XfySU) ->
      Data.Data.C:Data
        @ (Option a_XfySU)
        ((Data.Semigroup.$fDataOption10 @ a_XfySU $dData_XfzhN)
         `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Option
                                                                     a_XfySU>_N
                 :: (Data.Typeable.Internal.TypeRep (Option a_XfySU) :: *)
                    ~R# (Typeable (Option a_XfySU) :: Constraint)))
        (Data.Semigroup.$fDataOption_$cgfoldl @ a_XfySU $dData_XfzhN)
        (Data.Semigroup.$fDataOption_$cgunfold @ a_XfySU $dData_XfzhN)
        (lvl30_rfC7f @ a_XfySU)
        (lvl31_rfC7g @ a_XfySU)
        (Data.Semigroup.$fDataOption_$cdataCast1 @ a_XfySU $dData_XfzhN)
        (lvl32_rfC7h @ a_XfySU)
        ((Data.Semigroup.$fDataOption3 @ a_XfySU $dData_XfzhN)
         `cast` (<forall b. Data b => b -> b>_R
                 ->_R <Option a_XfySU>_R
                 ->_R Sym (Data.Semigroup.N:Option[0]) <a_XfySU>_N
                 :: ((forall b. Data b => b -> b)
                     -> Option a_XfySU -> Maybe a_XfySU :: *)
                    ~R# ((forall b. Data b => b -> b)
                         -> Option a_XfySU -> Option a_XfySU :: *)))
        (Data.Semigroup.$fDataOption_$cgmapQl @ a_XfySU $dData_XfzhN)
        (Data.Semigroup.$fDataOption_$cgmapQr @ a_XfySU $dData_XfzhN)
        (Data.Semigroup.$fDataOption_$cgmapQ @ a_XfySU $dData_XfzhN)
        (Data.Semigroup.$fDataOption_$cgmapQi @ a_XfySU $dData_XfzhN)
        (Data.Semigroup.$fDataOption_$cgmapM @ a_XfySU $dData_XfzhN)
        (Data.Semigroup.$fDataOption_$cgmapMp @ a_XfySU $dData_XfzhN)
        (Data.Semigroup.$fDataOption_$cgmapMo @ a_XfySU $dData_XfzhN)


