
==================== Raw Cmm ====================
2018-03-16 16:07:34.162021965 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:07:34.164368197 UTC

[section ""data" . Data.STRef.Lazy.newSTRef1_closure" {
     Data.STRef.Lazy.newSTRef1_closure:
         const Data.STRef.Lazy.newSTRef1_info;
 },
 Data.STRef.Lazy.newSTRef1_entry() //  [R2, R3]
         { []
         }
     {offset
       ccELm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccELu; else goto ccELv;
       ccELu: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.newSTRef1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccELv: // global
           I64[Sp - 16] = block_ccELj_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucELA; else goto ccELk;
       ucELA: // global
           call _ccELj() args: 0, res: 0, upd: 0;
       ccELk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Data.STRef.Lazy.newSTRef1_info" {
     Data.STRef.Lazy.newSTRef1_info:
         const Data.STRef.Lazy.newSTRef1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ccELj() //  []
         { []
         }
     {offset
       ccELj: // global
           _scEGj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccELp_info;
           R1 = _scEGj::P64;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccELj_info" {
     block_ccELj_info:
         const _ccELj;
         const 1;
         const 30;
 },
 _ccELp() //  [R1]
         { []
         }
     {offset
       ccELp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccELz; else goto ccELy;
       ccELz: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccELy: // global
           I64[Hp - 48] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 32] = GHC.STRef.STRef_con_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccELp_info" {
     block_ccELp_info:
         const _ccELp;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.172760214 UTC

[section ""data" . Data.STRef.Lazy.newSTRef_closure" {
     Data.STRef.Lazy.newSTRef_closure:
         const Data.STRef.Lazy.newSTRef_info;
 },
 Data.STRef.Lazy.newSTRef_entry() //  [R2, R3]
         { []
         }
     {offset
       ccELU: // global
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.newSTRef1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Data.STRef.Lazy.newSTRef_info" {
     Data.STRef.Lazy.newSTRef_info:
         const Data.STRef.Lazy.newSTRef_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.17704538 UTC

[section ""data" . Data.STRef.Lazy.readSTRef1_closure" {
     Data.STRef.Lazy.readSTRef1_closure:
         const Data.STRef.Lazy.readSTRef1_info;
 },
 Data.STRef.Lazy.readSTRef1_entry() //  [R2, R3]
         { []
         }
     {offset
       ccEM8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEMi; else goto ccEMj;
       ccEMi: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.readSTRef1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEMj: // global
           I64[Sp - 16] = block_ccEM5_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucEMp; else goto ccEM6;
       ucEMp: // global
           call _ccEM5() args: 0, res: 0, upd: 0;
       ccEM6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Data.STRef.Lazy.readSTRef1_info" {
     Data.STRef.Lazy.readSTRef1_info:
         const Data.STRef.Lazy.readSTRef1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ccEM5() //  []
         { []
         }
     {offset
       ccEM5: // global
           _scEGs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEMb_info;
           R1 = _scEGs::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucEMo; else goto ccEMc;
       ucEMo: // global
           call _ccEMb(R1) args: 0, res: 0, upd: 0;
       ccEMc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEM5_info" {
     block_ccEM5_info:
         const _ccEM5;
         const 1;
         const 30;
 },
 _ccEMb() //  [R1]
         { []
         }
     {offset
       ccEMb: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccEMn; else goto ccEMm;
       ccEMn: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEMm: // global
           _scEGA::P64 = P64[P64[R1 + 7] + 8];
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _scEGA::P64;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEMb_info" {
     block_ccEMb_info:
         const _ccEMb;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.184307198 UTC

[section ""data" . Data.STRef.Lazy.readSTRef_closure" {
     Data.STRef.Lazy.readSTRef_closure:
         const Data.STRef.Lazy.readSTRef_info;
 },
 Data.STRef.Lazy.readSTRef_entry() //  [R2, R3]
         { []
         }
     {offset
       ccEMK: // global
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.readSTRef1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Data.STRef.Lazy.readSTRef_info" {
     Data.STRef.Lazy.readSTRef_info:
         const Data.STRef.Lazy.readSTRef_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.188746126 UTC

[section ""data" . Data.STRef.Lazy.writeSTRef1_closure" {
     Data.STRef.Lazy.writeSTRef1_closure:
         const Data.STRef.Lazy.writeSTRef1_info;
 },
 Data.STRef.Lazy.writeSTRef1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccEMY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccENb; else goto ccENc;
       ccENb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.writeSTRef1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccENc: // global
           I64[Sp - 24] = block_ccEMV_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucENi; else goto ccEMW;
       ucENi: // global
           call _ccEMV() args: 0, res: 0, upd: 0;
       ccEMW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Data.STRef.Lazy.writeSTRef1_info" {
     Data.STRef.Lazy.writeSTRef1_info:
         const Data.STRef.Lazy.writeSTRef1_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ccEMV() //  []
         { []
         }
     {offset
       ccEMV: // global
           _scEGC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEN1_info;
           R1 = _scEGC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucENh; else goto ccEN2;
       ucENh: // global
           call _ccEN1(R1) args: 0, res: 0, upd: 0;
       ccEN2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEMV_info" {
     block_ccEMV_info:
         const _ccEMV;
         const 2;
         const 30;
 },
 _ccEN1() //  [R1]
         { []
         }
     {offset
       ccEN1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccENg; else goto ccENf;
       ccENg: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccENf: // global
           _scEGD::P64 = P64[Sp + 8];
           _scEGI::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_scEGI::P64 + 8] = _scEGD::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _scEGI::P64);
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Tuple.()_closure+1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEN1_info" {
     block_ccEN1_info:
         const _ccEN1;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.196337919 UTC

[section ""data" . Data.STRef.Lazy.writeSTRef_closure" {
     Data.STRef.Lazy.writeSTRef_closure:
         const Data.STRef.Lazy.writeSTRef_info;
 },
 Data.STRef.Lazy.writeSTRef_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccEND: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.writeSTRef1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Data.STRef.Lazy.writeSTRef_info" {
     Data.STRef.Lazy.writeSTRef_info:
         const Data.STRef.Lazy.writeSTRef_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.200845804 UTC

[section ""data" . Data.STRef.Lazy.modifySTRef1_closure" {
     Data.STRef.Lazy.modifySTRef1_closure:
         const Data.STRef.Lazy.modifySTRef1_info;
 },
 Data.STRef.Lazy.modifySTRef1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccENR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccEO5; else goto ccEO6;
       ccEO5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.modifySTRef1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEO6: // global
           I64[Sp - 24] = block_ccENO_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucEOc; else goto ccENP;
       ucEOc: // global
           call _ccENO() args: 0, res: 0, upd: 0;
       ccENP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Data.STRef.Lazy.modifySTRef1_info" {
     Data.STRef.Lazy.modifySTRef1_info:
         const Data.STRef.Lazy.modifySTRef1_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ccENO() //  []
         { []
         }
     {offset
       ccENO: // global
           _scEGL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccENU_info;
           R1 = _scEGL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucEOb; else goto ccENV;
       ucEOb: // global
           call _ccENU(R1) args: 0, res: 0, upd: 0;
       ccENV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccENO_info" {
     block_ccENO_info:
         const _ccENO;
         const 2;
         const 30;
 },
 _ccENU() //  [R1]
         { []
         }
     {offset
       ccENU: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccEOa; else goto ccEO9;
       ccEOa: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEO9: // global
           _scEGR::P64 = P64[R1 + 7];
           _scEGU::P64 = P64[_scEGR::P64 + 8];
           I64[Hp - 64] = stg_ap_2_upd_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _scEGU::P64;
           call MO_WriteBarrier();
           P64[_scEGR::P64 + 8] = Hp - 64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _scEGR::P64);
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Tuple.()_closure+1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccENU_info" {
     block_ccENU_info:
         const _ccENU;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.209382158 UTC

[section ""data" . Data.STRef.Lazy.modifySTRef_closure" {
     Data.STRef.Lazy.modifySTRef_closure:
         const Data.STRef.Lazy.modifySTRef_info;
 },
 Data.STRef.Lazy.modifySTRef_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccEOz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.modifySTRef1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Data.STRef.Lazy.modifySTRef_info" {
     Data.STRef.Lazy.modifySTRef_info:
         const Data.STRef.Lazy.modifySTRef_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.212464649 UTC

[section ""cstring" . Data.STRef.Lazy.$trModule4_bytes" {
     Data.STRef.Lazy.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.214215819 UTC

[section ""data" . Data.STRef.Lazy.$trModule3_closure" {
     Data.STRef.Lazy.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.STRef.Lazy.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.215947897 UTC

[section ""cstring" . Data.STRef.Lazy.$trModule2_bytes" {
     Data.STRef.Lazy.$trModule2_bytes:
         I8[] [68,97,116,97,46,83,84,82,101,102,46,76,97,122,121]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.21807108 UTC

[section ""data" . Data.STRef.Lazy.$trModule1_closure" {
     Data.STRef.Lazy.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.STRef.Lazy.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.219790785 UTC

[section ""data" . Data.STRef.Lazy.$trModule_closure" {
     Data.STRef.Lazy.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.STRef.Lazy.$trModule3_closure+1;
         const Data.STRef.Lazy.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.2215947 UTC

[section ""relreadonly" . ScEJ6_srt" { ScEJ6_srt:
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.307803206 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:07:34.310186472 UTC

[section ""data" . Data.STRef.Lazy.newSTRef1_closure" {
     Data.STRef.Lazy.newSTRef1_closure:
         const Data.STRef.Lazy.newSTRef1_info;
 },
 Data.STRef.Lazy.newSTRef1_entry() //  [R2, R3]
         { []
         }
     {offset
       ccEPy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEPG; else goto ccEPH;
       ccEPG: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.newSTRef1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEPH: // global
           I64[Sp - 16] = block_ccEPv_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucEPM; else goto ccEPw;
       ucEPM: // global
           call _ccEPv() args: 0, res: 0, upd: 0;
       ccEPw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Data.STRef.Lazy.newSTRef1_info" {
     Data.STRef.Lazy.newSTRef1_info:
         const Data.STRef.Lazy.newSTRef1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ccEPv() //  []
         { []
         }
     {offset
       ccEPv: // global
           _scEOM::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEPB_info;
           R1 = _scEOM::P64;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEPv_info" {
     block_ccEPv_info:
         const _ccEPv;
         const 1;
         const 30;
 },
 _ccEPB() //  [R1]
         { []
         }
     {offset
       ccEPB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccEPL; else goto ccEPK;
       ccEPL: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEPK: // global
           I64[Hp - 48] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 32] = GHC.STRef.STRef_con_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEPB_info" {
     block_ccEPB_info:
         const _ccEPB;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.317490907 UTC

[section ""data" . Data.STRef.Lazy.newSTRef_closure" {
     Data.STRef.Lazy.newSTRef_closure:
         const Data.STRef.Lazy.newSTRef_info;
 },
 Data.STRef.Lazy.newSTRef_entry() //  [R2, R3]
         { []
         }
     {offset
       ccEQb: // global
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.newSTRef1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Data.STRef.Lazy.newSTRef_info" {
     Data.STRef.Lazy.newSTRef_info:
         const Data.STRef.Lazy.newSTRef_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.322047824 UTC

[section ""data" . Data.STRef.Lazy.readSTRef1_closure" {
     Data.STRef.Lazy.readSTRef1_closure:
         const Data.STRef.Lazy.readSTRef1_info;
 },
 Data.STRef.Lazy.readSTRef1_entry() //  [R2, R3]
         { []
         }
     {offset
       ccEQp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEQz; else goto ccEQA;
       ccEQz: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.readSTRef1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEQA: // global
           I64[Sp - 16] = block_ccEQm_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucEQG; else goto ccEQn;
       ucEQG: // global
           call _ccEQm() args: 0, res: 0, upd: 0;
       ccEQn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Data.STRef.Lazy.readSTRef1_info" {
     Data.STRef.Lazy.readSTRef1_info:
         const Data.STRef.Lazy.readSTRef1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ccEQm() //  []
         { []
         }
     {offset
       ccEQm: // global
           _scEOV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEQs_info;
           R1 = _scEOV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucEQF; else goto ccEQt;
       ucEQF: // global
           call _ccEQs(R1) args: 0, res: 0, upd: 0;
       ccEQt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEQm_info" {
     block_ccEQm_info:
         const _ccEQm;
         const 1;
         const 30;
 },
 _ccEQs() //  [R1]
         { []
         }
     {offset
       ccEQs: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccEQE; else goto ccEQD;
       ccEQE: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEQD: // global
           _scEP3::P64 = P64[P64[R1 + 7] + 8];
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _scEP3::P64;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccEQs_info" {
     block_ccEQs_info:
         const _ccEQs;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.329967366 UTC

[section ""data" . Data.STRef.Lazy.readSTRef_closure" {
     Data.STRef.Lazy.readSTRef_closure:
         const Data.STRef.Lazy.readSTRef_info;
 },
 Data.STRef.Lazy.readSTRef_entry() //  [R2, R3]
         { []
         }
     {offset
       ccER5: // global
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.readSTRef1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Data.STRef.Lazy.readSTRef_info" {
     Data.STRef.Lazy.readSTRef_info:
         const Data.STRef.Lazy.readSTRef_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.334352047 UTC

[section ""data" . Data.STRef.Lazy.writeSTRef1_closure" {
     Data.STRef.Lazy.writeSTRef1_closure:
         const Data.STRef.Lazy.writeSTRef1_info;
 },
 Data.STRef.Lazy.writeSTRef1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccERj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccERw; else goto ccERx;
       ccERw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.writeSTRef1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccERx: // global
           I64[Sp - 24] = block_ccERg_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucERD; else goto ccERh;
       ucERD: // global
           call _ccERg() args: 0, res: 0, upd: 0;
       ccERh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Data.STRef.Lazy.writeSTRef1_info" {
     Data.STRef.Lazy.writeSTRef1_info:
         const Data.STRef.Lazy.writeSTRef1_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ccERg() //  []
         { []
         }
     {offset
       ccERg: // global
           _scEP5::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccERm_info;
           R1 = _scEP5::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucERC; else goto ccERn;
       ucERC: // global
           call _ccERm(R1) args: 0, res: 0, upd: 0;
       ccERn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccERg_info" {
     block_ccERg_info:
         const _ccERg;
         const 2;
         const 30;
 },
 _ccERm() //  [R1]
         { []
         }
     {offset
       ccERm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccERB; else goto ccERA;
       ccERB: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccERA: // global
           _scEP6::P64 = P64[Sp + 8];
           _scEPb::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_scEPb::P64 + 8] = _scEP6::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _scEPb::P64);
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Tuple.()_closure+1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccERm_info" {
     block_ccERm_info:
         const _ccERm;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.342015604 UTC

[section ""data" . Data.STRef.Lazy.writeSTRef_closure" {
     Data.STRef.Lazy.writeSTRef_closure:
         const Data.STRef.Lazy.writeSTRef_info;
 },
 Data.STRef.Lazy.writeSTRef_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccES4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.writeSTRef1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Data.STRef.Lazy.writeSTRef_info" {
     Data.STRef.Lazy.writeSTRef_info:
         const Data.STRef.Lazy.writeSTRef_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.346580516 UTC

[section ""data" . Data.STRef.Lazy.modifySTRef1_closure" {
     Data.STRef.Lazy.modifySTRef1_closure:
         const Data.STRef.Lazy.modifySTRef1_info;
 },
 Data.STRef.Lazy.modifySTRef1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccESi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccESw; else goto ccESx;
       ccESw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.modifySTRef1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccESx: // global
           I64[Sp - 24] = block_ccESf_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucESD; else goto ccESg;
       ucESD: // global
           call _ccESf() args: 0, res: 0, upd: 0;
       ccESg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . Data.STRef.Lazy.modifySTRef1_info" {
     Data.STRef.Lazy.modifySTRef1_info:
         const Data.STRef.Lazy.modifySTRef1_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ccESf() //  []
         { []
         }
     {offset
       ccESf: // global
           _scEPe::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccESl_info;
           R1 = _scEPe::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucESC; else goto ccESm;
       ucESC: // global
           call _ccESl(R1) args: 0, res: 0, upd: 0;
       ccESm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccESf_info" {
     block_ccESf_info:
         const _ccESf;
         const 2;
         const 30;
 },
 _ccESl() //  [R1]
         { []
         }
     {offset
       ccESl: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccESB; else goto ccESA;
       ccESB: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccESA: // global
           _scEPk::P64 = P64[R1 + 7];
           _scEPn::P64 = P64[_scEPk::P64 + 8];
           I64[Hp - 64] = stg_ap_2_upd_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _scEPn::P64;
           call MO_WriteBarrier();
           P64[_scEPk::P64 + 8] = Hp - 64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _scEPk::P64);
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Tuple.()_closure+1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccESl_info" {
     block_ccESl_info:
         const _ccESl;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.354117406 UTC

[section ""data" . Data.STRef.Lazy.modifySTRef_closure" {
     Data.STRef.Lazy.modifySTRef_closure:
         const Data.STRef.Lazy.modifySTRef_info;
 },
 Data.STRef.Lazy.modifySTRef_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccET7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.modifySTRef1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . Data.STRef.Lazy.modifySTRef_info" {
     Data.STRef.Lazy.modifySTRef_info:
         const Data.STRef.Lazy.modifySTRef_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.35728964 UTC

[section ""cstring" . Data.STRef.Lazy.$trModule4_bytes" {
     Data.STRef.Lazy.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.359499976 UTC

[section ""data" . Data.STRef.Lazy.$trModule3_closure" {
     Data.STRef.Lazy.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.STRef.Lazy.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.361273862 UTC

[section ""cstring" . Data.STRef.Lazy.$trModule2_bytes" {
     Data.STRef.Lazy.$trModule2_bytes:
         I8[] [68,97,116,97,46,83,84,82,101,102,46,76,97,122,121]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.362953929 UTC

[section ""data" . Data.STRef.Lazy.$trModule1_closure" {
     Data.STRef.Lazy.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.STRef.Lazy.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.364686248 UTC

[section ""data" . Data.STRef.Lazy.$trModule_closure" {
     Data.STRef.Lazy.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.STRef.Lazy.$trModule3_closure+1;
         const Data.STRef.Lazy.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:34.366411953 UTC

[section ""relreadonly" . ScETj_srt" { ScETj_srt:
 }]

