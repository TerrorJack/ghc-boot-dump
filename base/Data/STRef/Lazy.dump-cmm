
==================== Output Cmm ====================
2018-03-16 16:07:34.131134646 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:34.13221497 UTC

[section ""data" . Data.STRef.Lazy.newSTRef1_closure" {
     Data.STRef.Lazy.newSTRef1_closure:
         const Data.STRef.Lazy.newSTRef1_info;
 },
 Data.STRef.Lazy.newSTRef1_entry() //  [R2, R3]
         { info_tbl: [(ccEH5,
                       label: Data.STRef.Lazy.newSTRef1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEH5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEHd; else goto ccEHe;
       ccEHd: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.newSTRef1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEHe: // global
           I64[Sp - 16] = block_ccEH2_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucEHj; else goto ccEH3;
       ucEHj: // global
           call _ccEH2() args: 0, res: 0, upd: 0;
       ccEH3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEH2() //  []
         { info_tbl: [(ccEH2,
                       label: block_ccEH2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEH2: // global
           _scEGj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEH8_info;
           R1 = _scEGj::P64;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEH8() //  [R1]
         { info_tbl: [(ccEH8,
                       label: block_ccEH8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEH8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccEHi; else goto ccEHh;
       ccEHi: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEHh: // global
           I64[Hp - 48] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 32] = GHC.STRef.STRef_con_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.133708476 UTC

[section ""data" . Data.STRef.Lazy.newSTRef_closure" {
     Data.STRef.Lazy.newSTRef_closure:
         const Data.STRef.Lazy.newSTRef_info;
 },
 Data.STRef.Lazy.newSTRef_entry() //  [R2, R3]
         { info_tbl: [(ccEHo,
                       label: Data.STRef.Lazy.newSTRef_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEHo: // global
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.newSTRef1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.134796389 UTC

[section ""data" . Data.STRef.Lazy.readSTRef1_closure" {
     Data.STRef.Lazy.readSTRef1_closure:
         const Data.STRef.Lazy.readSTRef1_info;
 },
 Data.STRef.Lazy.readSTRef1_entry() //  [R2, R3]
         { info_tbl: [(ccEHy,
                       label: Data.STRef.Lazy.readSTRef1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEHy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEHI; else goto ccEHJ;
       ccEHI: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.readSTRef1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEHJ: // global
           I64[Sp - 16] = block_ccEHv_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucEHP; else goto ccEHw;
       ucEHP: // global
           call _ccEHv() args: 0, res: 0, upd: 0;
       ccEHw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEHv() //  []
         { info_tbl: [(ccEHv,
                       label: block_ccEHv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEHv: // global
           _scEGs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEHB_info;
           R1 = _scEGs::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucEHO; else goto ccEHC;
       ucEHO: // global
           call _ccEHB(R1) args: 0, res: 0, upd: 0;
       ccEHC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEHB() //  [R1]
         { info_tbl: [(ccEHB,
                       label: block_ccEHB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEHB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccEHN; else goto ccEHM;
       ccEHN: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEHM: // global
           _scEGA::P64 = P64[P64[R1 + 7] + 8];
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _scEGA::P64;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.136260228 UTC

[section ""data" . Data.STRef.Lazy.readSTRef_closure" {
     Data.STRef.Lazy.readSTRef_closure:
         const Data.STRef.Lazy.readSTRef_info;
 },
 Data.STRef.Lazy.readSTRef_entry() //  [R2, R3]
         { info_tbl: [(ccEHU,
                       label: Data.STRef.Lazy.readSTRef_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEHU: // global
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.readSTRef1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.137429037 UTC

[section ""data" . Data.STRef.Lazy.writeSTRef1_closure" {
     Data.STRef.Lazy.writeSTRef1_closure:
         const Data.STRef.Lazy.writeSTRef1_info;
 },
 Data.STRef.Lazy.writeSTRef1_entry() //  [R2, R3, R4]
         { info_tbl: [(ccEI4,
                       label: Data.STRef.Lazy.writeSTRef1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEI4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccEIh; else goto ccEIi;
       ccEIh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.writeSTRef1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEIi: // global
           I64[Sp - 24] = block_ccEI1_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucEIo; else goto ccEI2;
       ucEIo: // global
           call _ccEI1() args: 0, res: 0, upd: 0;
       ccEI2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEI1() //  []
         { info_tbl: [(ccEI1,
                       label: block_ccEI1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEI1: // global
           _scEGC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEI7_info;
           R1 = _scEGC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucEIn; else goto ccEI8;
       ucEIn: // global
           call _ccEI7(R1) args: 0, res: 0, upd: 0;
       ccEI8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEI7() //  [R1]
         { info_tbl: [(ccEI7,
                       label: block_ccEI7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEI7: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccEIm; else goto ccEIl;
       ccEIm: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEIl: // global
           _scEGD::P64 = P64[Sp + 8];
           _scEGI::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_scEGI::P64 + 8] = _scEGD::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _scEGI::P64);
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Tuple.()_closure+1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.139002083 UTC

[section ""data" . Data.STRef.Lazy.writeSTRef_closure" {
     Data.STRef.Lazy.writeSTRef_closure:
         const Data.STRef.Lazy.writeSTRef_info;
 },
 Data.STRef.Lazy.writeSTRef_entry() //  [R2, R3, R4]
         { info_tbl: [(ccEIt,
                       label: Data.STRef.Lazy.writeSTRef_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEIt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.writeSTRef1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.140187375 UTC

[section ""data" . Data.STRef.Lazy.modifySTRef1_closure" {
     Data.STRef.Lazy.modifySTRef1_closure:
         const Data.STRef.Lazy.modifySTRef1_info;
 },
 Data.STRef.Lazy.modifySTRef1_entry() //  [R2, R3, R4]
         { info_tbl: [(ccEID,
                       label: Data.STRef.Lazy.modifySTRef1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEID: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccEIR; else goto ccEIS;
       ccEIR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.modifySTRef1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEIS: // global
           I64[Sp - 24] = block_ccEIA_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucEIY; else goto ccEIB;
       ucEIY: // global
           call _ccEIA() args: 0, res: 0, upd: 0;
       ccEIB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEIA() //  []
         { info_tbl: [(ccEIA,
                       label: block_ccEIA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEIA: // global
           _scEGL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEIG_info;
           R1 = _scEGL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucEIX; else goto ccEIH;
       ucEIX: // global
           call _ccEIG(R1) args: 0, res: 0, upd: 0;
       ccEIH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEIG() //  [R1]
         { info_tbl: [(ccEIG,
                       label: block_ccEIG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEIG: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccEIW; else goto ccEIV;
       ccEIW: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEIV: // global
           _scEGR::P64 = P64[R1 + 7];
           _scEGU::P64 = P64[_scEGR::P64 + 8];
           I64[Hp - 64] = stg_ap_2_upd_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _scEGU::P64;
           call MO_WriteBarrier();
           P64[_scEGR::P64 + 8] = Hp - 64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _scEGR::P64);
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Tuple.()_closure+1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.141792237 UTC

[section ""data" . Data.STRef.Lazy.modifySTRef_closure" {
     Data.STRef.Lazy.modifySTRef_closure:
         const Data.STRef.Lazy.modifySTRef_info;
 },
 Data.STRef.Lazy.modifySTRef_entry() //  [R2, R3, R4]
         { info_tbl: [(ccEJ3,
                       label: Data.STRef.Lazy.modifySTRef_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEJ3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.modifySTRef1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.142555172 UTC

[section ""cstring" . Data.STRef.Lazy.$trModule4_bytes" {
     Data.STRef.Lazy.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.143127424 UTC

[section ""data" . Data.STRef.Lazy.$trModule3_closure" {
     Data.STRef.Lazy.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.STRef.Lazy.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.143647982 UTC

[section ""cstring" . Data.STRef.Lazy.$trModule2_bytes" {
     Data.STRef.Lazy.$trModule2_bytes:
         I8[] [68,97,116,97,46,83,84,82,101,102,46,76,97,122,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.144177791 UTC

[section ""data" . Data.STRef.Lazy.$trModule1_closure" {
     Data.STRef.Lazy.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.STRef.Lazy.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.144766624 UTC

[section ""data" . Data.STRef.Lazy.$trModule_closure" {
     Data.STRef.Lazy.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.STRef.Lazy.$trModule3_closure+1;
         const Data.STRef.Lazy.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.145504033 UTC

[section ""relreadonly" . ScEJ6_srt" { ScEJ6_srt:
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.146086423 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:34.146946401 UTC

[section ""data" . Data.STRef.Lazy.newSTRef1_closure" {
     Data.STRef.Lazy.newSTRef1_closure:
         const Data.STRef.Lazy.newSTRef1_info;
 },
 Data.STRef.Lazy.newSTRef1_entry() //  [R2, R3]
         { info_tbl: [(ccEJe,
                       label: Data.STRef.Lazy.newSTRef1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEJe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEJm; else goto ccEJn;
       ccEJm: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.newSTRef1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEJn: // global
           I64[Sp - 16] = block_ccEJb_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucEJs; else goto ccEJc;
       ucEJs: // global
           call _ccEJb() args: 0, res: 0, upd: 0;
       ccEJc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEJb() //  []
         { info_tbl: [(ccEJb,
                       label: block_ccEJb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEJb: // global
           _scEGj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEJh_info;
           R1 = _scEGj::P64;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEJh() //  [R1]
         { info_tbl: [(ccEJh,
                       label: block_ccEJh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEJh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccEJr; else goto ccEJq;
       ccEJr: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEJq: // global
           I64[Hp - 48] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 32] = GHC.STRef.STRef_con_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.148354231 UTC

[section ""data" . Data.STRef.Lazy.newSTRef_closure" {
     Data.STRef.Lazy.newSTRef_closure:
         const Data.STRef.Lazy.newSTRef_info;
 },
 Data.STRef.Lazy.newSTRef_entry() //  [R2, R3]
         { info_tbl: [(ccEJx,
                       label: Data.STRef.Lazy.newSTRef_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEJx: // global
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.newSTRef1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.149509086 UTC

[section ""data" . Data.STRef.Lazy.readSTRef1_closure" {
     Data.STRef.Lazy.readSTRef1_closure:
         const Data.STRef.Lazy.readSTRef1_info;
 },
 Data.STRef.Lazy.readSTRef1_entry() //  [R2, R3]
         { info_tbl: [(ccEJH,
                       label: Data.STRef.Lazy.readSTRef1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEJH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEJR; else goto ccEJS;
       ccEJR: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.readSTRef1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEJS: // global
           I64[Sp - 16] = block_ccEJE_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucEJY; else goto ccEJF;
       ucEJY: // global
           call _ccEJE() args: 0, res: 0, upd: 0;
       ccEJF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEJE() //  []
         { info_tbl: [(ccEJE,
                       label: block_ccEJE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEJE: // global
           _scEGs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEJK_info;
           R1 = _scEGs::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucEJX; else goto ccEJL;
       ucEJX: // global
           call _ccEJK(R1) args: 0, res: 0, upd: 0;
       ccEJL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEJK() //  [R1]
         { info_tbl: [(ccEJK,
                       label: block_ccEJK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEJK: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccEJW; else goto ccEJV;
       ccEJW: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEJV: // global
           _scEGA::P64 = P64[P64[R1 + 7] + 8];
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _scEGA::P64;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.150995099 UTC

[section ""data" . Data.STRef.Lazy.readSTRef_closure" {
     Data.STRef.Lazy.readSTRef_closure:
         const Data.STRef.Lazy.readSTRef_info;
 },
 Data.STRef.Lazy.readSTRef_entry() //  [R2, R3]
         { info_tbl: [(ccEK3,
                       label: Data.STRef.Lazy.readSTRef_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEK3: // global
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.readSTRef1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.152141402 UTC

[section ""data" . Data.STRef.Lazy.writeSTRef1_closure" {
     Data.STRef.Lazy.writeSTRef1_closure:
         const Data.STRef.Lazy.writeSTRef1_info;
 },
 Data.STRef.Lazy.writeSTRef1_entry() //  [R2, R3, R4]
         { info_tbl: [(ccEKd,
                       label: Data.STRef.Lazy.writeSTRef1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEKd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccEKq; else goto ccEKr;
       ccEKq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.writeSTRef1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEKr: // global
           I64[Sp - 24] = block_ccEKa_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucEKx; else goto ccEKb;
       ucEKx: // global
           call _ccEKa() args: 0, res: 0, upd: 0;
       ccEKb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEKa() //  []
         { info_tbl: [(ccEKa,
                       label: block_ccEKa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEKa: // global
           _scEGC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEKg_info;
           R1 = _scEGC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucEKw; else goto ccEKh;
       ucEKw: // global
           call _ccEKg(R1) args: 0, res: 0, upd: 0;
       ccEKh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEKg() //  [R1]
         { info_tbl: [(ccEKg,
                       label: block_ccEKg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEKg: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccEKv; else goto ccEKu;
       ccEKv: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEKu: // global
           _scEGD::P64 = P64[Sp + 8];
           _scEGI::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_scEGI::P64 + 8] = _scEGD::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _scEGI::P64);
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Tuple.()_closure+1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.15381317 UTC

[section ""data" . Data.STRef.Lazy.writeSTRef_closure" {
     Data.STRef.Lazy.writeSTRef_closure:
         const Data.STRef.Lazy.writeSTRef_info;
 },
 Data.STRef.Lazy.writeSTRef_entry() //  [R2, R3, R4]
         { info_tbl: [(ccEKC,
                       label: Data.STRef.Lazy.writeSTRef_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEKC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.writeSTRef1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.154951782 UTC

[section ""data" . Data.STRef.Lazy.modifySTRef1_closure" {
     Data.STRef.Lazy.modifySTRef1_closure:
         const Data.STRef.Lazy.modifySTRef1_info;
 },
 Data.STRef.Lazy.modifySTRef1_entry() //  [R2, R3, R4]
         { info_tbl: [(ccEKM,
                       label: Data.STRef.Lazy.modifySTRef1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEKM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccEL0; else goto ccEL1;
       ccEL0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.modifySTRef1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEL1: // global
           I64[Sp - 24] = block_ccEKJ_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucEL7; else goto ccEKK;
       ucEL7: // global
           call _ccEKJ() args: 0, res: 0, upd: 0;
       ccEKK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEKJ() //  []
         { info_tbl: [(ccEKJ,
                       label: block_ccEKJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEKJ: // global
           _scEGL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEKP_info;
           R1 = _scEGL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucEL6; else goto ccEKQ;
       ucEL6: // global
           call _ccEKP(R1) args: 0, res: 0, upd: 0;
       ccEKQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEKP() //  [R1]
         { info_tbl: [(ccEKP,
                       label: block_ccEKP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEKP: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccEL5; else goto ccEL4;
       ccEL5: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEL4: // global
           _scEGR::P64 = P64[R1 + 7];
           _scEGU::P64 = P64[_scEGR::P64 + 8];
           I64[Hp - 64] = stg_ap_2_upd_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _scEGU::P64;
           call MO_WriteBarrier();
           P64[_scEGR::P64 + 8] = Hp - 64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _scEGR::P64);
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Tuple.()_closure+1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.156563016 UTC

[section ""data" . Data.STRef.Lazy.modifySTRef_closure" {
     Data.STRef.Lazy.modifySTRef_closure:
         const Data.STRef.Lazy.modifySTRef_info;
 },
 Data.STRef.Lazy.modifySTRef_entry() //  [R2, R3, R4]
         { info_tbl: [(ccELc,
                       label: Data.STRef.Lazy.modifySTRef_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccELc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.modifySTRef1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.157577869 UTC

[section ""cstring" . Data.STRef.Lazy.$trModule4_bytes" {
     Data.STRef.Lazy.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.158176802 UTC

[section ""data" . Data.STRef.Lazy.$trModule3_closure" {
     Data.STRef.Lazy.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.STRef.Lazy.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.158786795 UTC

[section ""cstring" . Data.STRef.Lazy.$trModule2_bytes" {
     Data.STRef.Lazy.$trModule2_bytes:
         I8[] [68,97,116,97,46,83,84,82,101,102,46,76,97,122,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.159356524 UTC

[section ""data" . Data.STRef.Lazy.$trModule1_closure" {
     Data.STRef.Lazy.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.STRef.Lazy.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.159948754 UTC

[section ""data" . Data.STRef.Lazy.$trModule_closure" {
     Data.STRef.Lazy.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.STRef.Lazy.$trModule3_closure+1;
         const Data.STRef.Lazy.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.160565561 UTC

[section ""relreadonly" . ScEJ6_srt" { ScEJ6_srt:
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.161439604 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:34.163025526 UTC

[section ""data" . Data.STRef.Lazy.newSTRef1_closure" {
     Data.STRef.Lazy.newSTRef1_closure:
         const Data.STRef.Lazy.newSTRef1_info;
 },
 Data.STRef.Lazy.newSTRef1_entry() //  [R2, R3]
         { info_tbl: [(ccELm,
                       label: Data.STRef.Lazy.newSTRef1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccELm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccELu; else goto ccELv;
       ccELu: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.newSTRef1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccELv: // global
           I64[Sp - 16] = block_ccELj_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucELA; else goto ccELk;
       ucELA: // global
           call _ccELj() args: 0, res: 0, upd: 0;
       ccELk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccELj() //  []
         { info_tbl: [(ccELj,
                       label: block_ccELj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccELj: // global
           _scEGj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccELp_info;
           R1 = _scEGj::P64;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccELp() //  [R1]
         { info_tbl: [(ccELp,
                       label: block_ccELp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccELp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccELz; else goto ccELy;
       ccELz: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccELy: // global
           I64[Hp - 48] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 32] = GHC.STRef.STRef_con_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.172007994 UTC

[section ""data" . Data.STRef.Lazy.newSTRef_closure" {
     Data.STRef.Lazy.newSTRef_closure:
         const Data.STRef.Lazy.newSTRef_info;
 },
 Data.STRef.Lazy.newSTRef_entry() //  [R2, R3]
         { info_tbl: [(ccELU,
                       label: Data.STRef.Lazy.newSTRef_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccELU: // global
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.newSTRef1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.175717541 UTC

[section ""data" . Data.STRef.Lazy.readSTRef1_closure" {
     Data.STRef.Lazy.readSTRef1_closure:
         const Data.STRef.Lazy.readSTRef1_info;
 },
 Data.STRef.Lazy.readSTRef1_entry() //  [R2, R3]
         { info_tbl: [(ccEM8,
                       label: Data.STRef.Lazy.readSTRef1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEM8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEMi; else goto ccEMj;
       ccEMi: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.readSTRef1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEMj: // global
           I64[Sp - 16] = block_ccEM5_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucEMp; else goto ccEM6;
       ucEMp: // global
           call _ccEM5() args: 0, res: 0, upd: 0;
       ccEM6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEM5() //  []
         { info_tbl: [(ccEM5,
                       label: block_ccEM5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEM5: // global
           _scEGs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEMb_info;
           R1 = _scEGs::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucEMo; else goto ccEMc;
       ucEMo: // global
           call _ccEMb(R1) args: 0, res: 0, upd: 0;
       ccEMc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEMb() //  [R1]
         { info_tbl: [(ccEMb,
                       label: block_ccEMb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEMb: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccEMn; else goto ccEMm;
       ccEMn: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEMm: // global
           _scEGA::P64 = P64[P64[R1 + 7] + 8];
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _scEGA::P64;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.183527859 UTC

[section ""data" . Data.STRef.Lazy.readSTRef_closure" {
     Data.STRef.Lazy.readSTRef_closure:
         const Data.STRef.Lazy.readSTRef_info;
 },
 Data.STRef.Lazy.readSTRef_entry() //  [R2, R3]
         { info_tbl: [(ccEMK,
                       label: Data.STRef.Lazy.readSTRef_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEMK: // global
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.readSTRef1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.187338411 UTC

[section ""data" . Data.STRef.Lazy.writeSTRef1_closure" {
     Data.STRef.Lazy.writeSTRef1_closure:
         const Data.STRef.Lazy.writeSTRef1_info;
 },
 Data.STRef.Lazy.writeSTRef1_entry() //  [R2, R3, R4]
         { info_tbl: [(ccEMY,
                       label: Data.STRef.Lazy.writeSTRef1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEMY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccENb; else goto ccENc;
       ccENb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.writeSTRef1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccENc: // global
           I64[Sp - 24] = block_ccEMV_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucENi; else goto ccEMW;
       ucENi: // global
           call _ccEMV() args: 0, res: 0, upd: 0;
       ccEMW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEMV() //  []
         { info_tbl: [(ccEMV,
                       label: block_ccEMV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEMV: // global
           _scEGC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEN1_info;
           R1 = _scEGC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucENh; else goto ccEN2;
       ucENh: // global
           call _ccEN1(R1) args: 0, res: 0, upd: 0;
       ccEN2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEN1() //  [R1]
         { info_tbl: [(ccEN1,
                       label: block_ccEN1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEN1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccENg; else goto ccENf;
       ccENg: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccENf: // global
           _scEGD::P64 = P64[Sp + 8];
           _scEGI::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_scEGI::P64 + 8] = _scEGD::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _scEGI::P64);
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Tuple.()_closure+1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.19558721 UTC

[section ""data" . Data.STRef.Lazy.writeSTRef_closure" {
     Data.STRef.Lazy.writeSTRef_closure:
         const Data.STRef.Lazy.writeSTRef_info;
 },
 Data.STRef.Lazy.writeSTRef_entry() //  [R2, R3, R4]
         { info_tbl: [(ccEND,
                       label: Data.STRef.Lazy.writeSTRef_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEND: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.writeSTRef1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.199410065 UTC

[section ""data" . Data.STRef.Lazy.modifySTRef1_closure" {
     Data.STRef.Lazy.modifySTRef1_closure:
         const Data.STRef.Lazy.modifySTRef1_info;
 },
 Data.STRef.Lazy.modifySTRef1_entry() //  [R2, R3, R4]
         { info_tbl: [(ccENR,
                       label: Data.STRef.Lazy.modifySTRef1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccENR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccEO5; else goto ccEO6;
       ccEO5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.modifySTRef1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEO6: // global
           I64[Sp - 24] = block_ccENO_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucEOc; else goto ccENP;
       ucEOc: // global
           call _ccENO() args: 0, res: 0, upd: 0;
       ccENP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccENO() //  []
         { info_tbl: [(ccENO,
                       label: block_ccENO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccENO: // global
           _scEGL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccENU_info;
           R1 = _scEGL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucEOb; else goto ccENV;
       ucEOb: // global
           call _ccENU(R1) args: 0, res: 0, upd: 0;
       ccENV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccENU() //  [R1]
         { info_tbl: [(ccENU,
                       label: block_ccENU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccENU: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccEOa; else goto ccEO9;
       ccEOa: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEO9: // global
           _scEGR::P64 = P64[R1 + 7];
           _scEGU::P64 = P64[_scEGR::P64 + 8];
           I64[Hp - 64] = stg_ap_2_upd_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _scEGU::P64;
           call MO_WriteBarrier();
           P64[_scEGR::P64 + 8] = Hp - 64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _scEGR::P64);
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Tuple.()_closure+1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.208512373 UTC

[section ""data" . Data.STRef.Lazy.modifySTRef_closure" {
     Data.STRef.Lazy.modifySTRef_closure:
         const Data.STRef.Lazy.modifySTRef_info;
 },
 Data.STRef.Lazy.modifySTRef_entry() //  [R2, R3, R4]
         { info_tbl: [(ccEOz,
                       label: Data.STRef.Lazy.modifySTRef_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEOz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.modifySTRef1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.211893573 UTC

[section ""cstring" . Data.STRef.Lazy.$trModule4_bytes" {
     Data.STRef.Lazy.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.213628675 UTC

[section ""data" . Data.STRef.Lazy.$trModule3_closure" {
     Data.STRef.Lazy.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.STRef.Lazy.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.21537377 UTC

[section ""cstring" . Data.STRef.Lazy.$trModule2_bytes" {
     Data.STRef.Lazy.$trModule2_bytes:
         I8[] [68,97,116,97,46,83,84,82,101,102,46,76,97,122,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.217153793 UTC

[section ""data" . Data.STRef.Lazy.$trModule1_closure" {
     Data.STRef.Lazy.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.STRef.Lazy.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.219194369 UTC

[section ""data" . Data.STRef.Lazy.$trModule_closure" {
     Data.STRef.Lazy.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.STRef.Lazy.$trModule3_closure+1;
         const Data.STRef.Lazy.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.220979042 UTC

[section ""relreadonly" . ScEJ6_srt" { ScEJ6_srt:
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.307244908 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:34.308833414 UTC

[section ""data" . Data.STRef.Lazy.newSTRef1_closure" {
     Data.STRef.Lazy.newSTRef1_closure:
         const Data.STRef.Lazy.newSTRef1_info;
 },
 Data.STRef.Lazy.newSTRef1_entry() //  [R2, R3]
         { info_tbl: [(ccEPy,
                       label: Data.STRef.Lazy.newSTRef1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEPy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEPG; else goto ccEPH;
       ccEPG: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.newSTRef1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEPH: // global
           I64[Sp - 16] = block_ccEPv_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucEPM; else goto ccEPw;
       ucEPM: // global
           call _ccEPv() args: 0, res: 0, upd: 0;
       ccEPw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEPv() //  []
         { info_tbl: [(ccEPv,
                       label: block_ccEPv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEPv: // global
           _scEOM::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEPB_info;
           R1 = _scEOM::P64;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEPB() //  [R1]
         { info_tbl: [(ccEPB,
                       label: block_ccEPB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEPB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccEPL; else goto ccEPK;
       ccEPL: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEPK: // global
           I64[Hp - 48] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 32] = GHC.STRef.STRef_con_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.31670602 UTC

[section ""data" . Data.STRef.Lazy.newSTRef_closure" {
     Data.STRef.Lazy.newSTRef_closure:
         const Data.STRef.Lazy.newSTRef_info;
 },
 Data.STRef.Lazy.newSTRef_entry() //  [R2, R3]
         { info_tbl: [(ccEQb,
                       label: Data.STRef.Lazy.newSTRef_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEQb: // global
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.newSTRef1_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.320583646 UTC

[section ""data" . Data.STRef.Lazy.readSTRef1_closure" {
     Data.STRef.Lazy.readSTRef1_closure:
         const Data.STRef.Lazy.readSTRef1_info;
 },
 Data.STRef.Lazy.readSTRef1_entry() //  [R2, R3]
         { info_tbl: [(ccEQp,
                       label: Data.STRef.Lazy.readSTRef1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEQp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccEQz; else goto ccEQA;
       ccEQz: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.readSTRef1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccEQA: // global
           I64[Sp - 16] = block_ccEQm_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucEQG; else goto ccEQn;
       ucEQG: // global
           call _ccEQm() args: 0, res: 0, upd: 0;
       ccEQn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEQm() //  []
         { info_tbl: [(ccEQm,
                       label: block_ccEQm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEQm: // global
           _scEOV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccEQs_info;
           R1 = _scEOV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucEQF; else goto ccEQt;
       ucEQF: // global
           call _ccEQs(R1) args: 0, res: 0, upd: 0;
       ccEQt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccEQs() //  [R1]
         { info_tbl: [(ccEQs,
                       label: block_ccEQs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccEQs: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccEQE; else goto ccEQD;
       ccEQE: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccEQD: // global
           _scEP3::P64 = P64[P64[R1 + 7] + 8];
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _scEP3::P64;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.328961626 UTC

[section ""data" . Data.STRef.Lazy.readSTRef_closure" {
     Data.STRef.Lazy.readSTRef_closure:
         const Data.STRef.Lazy.readSTRef_info;
 },
 Data.STRef.Lazy.readSTRef_entry() //  [R2, R3]
         { info_tbl: [(ccER5,
                       label: Data.STRef.Lazy.readSTRef_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccER5: // global
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.readSTRef1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.332869898 UTC

[section ""data" . Data.STRef.Lazy.writeSTRef1_closure" {
     Data.STRef.Lazy.writeSTRef1_closure:
         const Data.STRef.Lazy.writeSTRef1_info;
 },
 Data.STRef.Lazy.writeSTRef1_entry() //  [R2, R3, R4]
         { info_tbl: [(ccERj,
                       label: Data.STRef.Lazy.writeSTRef1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccERj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccERw; else goto ccERx;
       ccERw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.writeSTRef1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccERx: // global
           I64[Sp - 24] = block_ccERg_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucERD; else goto ccERh;
       ucERD: // global
           call _ccERg() args: 0, res: 0, upd: 0;
       ccERh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccERg() //  []
         { info_tbl: [(ccERg,
                       label: block_ccERg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccERg: // global
           _scEP5::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccERm_info;
           R1 = _scEP5::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucERC; else goto ccERn;
       ucERC: // global
           call _ccERm(R1) args: 0, res: 0, upd: 0;
       ccERn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccERm() //  [R1]
         { info_tbl: [(ccERm,
                       label: block_ccERm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccERm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccERB; else goto ccERA;
       ccERB: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccERA: // global
           _scEP6::P64 = P64[Sp + 8];
           _scEPb::P64 = P64[R1 + 7];
           call MO_WriteBarrier();
           P64[_scEPb::P64 + 8] = _scEP6::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _scEPb::P64);
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Tuple.()_closure+1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.340815339 UTC

[section ""data" . Data.STRef.Lazy.writeSTRef_closure" {
     Data.STRef.Lazy.writeSTRef_closure:
         const Data.STRef.Lazy.writeSTRef_info;
 },
 Data.STRef.Lazy.writeSTRef_entry() //  [R2, R3, R4]
         { info_tbl: [(ccES4,
                       label: Data.STRef.Lazy.writeSTRef_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccES4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.writeSTRef1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.345055266 UTC

[section ""data" . Data.STRef.Lazy.modifySTRef1_closure" {
     Data.STRef.Lazy.modifySTRef1_closure:
         const Data.STRef.Lazy.modifySTRef1_info;
 },
 Data.STRef.Lazy.modifySTRef1_entry() //  [R2, R3, R4]
         { info_tbl: [(ccESi,
                       label: Data.STRef.Lazy.modifySTRef1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccESi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccESw; else goto ccESx;
       ccESw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.STRef.Lazy.modifySTRef1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccESx: // global
           I64[Sp - 24] = block_ccESf_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucESD; else goto ccESg;
       ucESD: // global
           call _ccESf() args: 0, res: 0, upd: 0;
       ccESg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccESf() //  []
         { info_tbl: [(ccESf,
                       label: block_ccESf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccESf: // global
           _scEPe::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccESl_info;
           R1 = _scEPe::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucESC; else goto ccESm;
       ucESC: // global
           call _ccESl(R1) args: 0, res: 0, upd: 0;
       ccESm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccESl() //  [R1]
         { info_tbl: [(ccESl,
                       label: block_ccESl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccESl: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccESB; else goto ccESA;
       ccESB: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccESA: // global
           _scEPk::P64 = P64[R1 + 7];
           _scEPn::P64 = P64[_scEPk::P64 + 8];
           I64[Hp - 64] = stg_ap_2_upd_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _scEPn::P64;
           call MO_WriteBarrier();
           P64[_scEPk::P64 + 8] = Hp - 64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _scEPk::P64);
           I64[Hp - 32] = Control.Monad.ST.Lazy.Imp.S#_con_info;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Tuple.()_closure+1;
           P64[Hp] = Hp - 31;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.353339461 UTC

[section ""data" . Data.STRef.Lazy.modifySTRef_closure" {
     Data.STRef.Lazy.modifySTRef_closure:
         const Data.STRef.Lazy.modifySTRef_info;
 },
 Data.STRef.Lazy.modifySTRef_entry() //  [R2, R3, R4]
         { info_tbl: [(ccET7,
                       label: Data.STRef.Lazy.modifySTRef_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccET7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.STRef.Lazy.modifySTRef1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.356679192 UTC

[section ""cstring" . Data.STRef.Lazy.$trModule4_bytes" {
     Data.STRef.Lazy.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.358935202 UTC

[section ""data" . Data.STRef.Lazy.$trModule3_closure" {
     Data.STRef.Lazy.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.STRef.Lazy.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.360669609 UTC

[section ""cstring" . Data.STRef.Lazy.$trModule2_bytes" {
     Data.STRef.Lazy.$trModule2_bytes:
         I8[] [68,97,116,97,46,83,84,82,101,102,46,76,97,122,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.36238193 UTC

[section ""data" . Data.STRef.Lazy.$trModule1_closure" {
     Data.STRef.Lazy.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.STRef.Lazy.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.364101303 UTC

[section ""data" . Data.STRef.Lazy.$trModule_closure" {
     Data.STRef.Lazy.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.STRef.Lazy.$trModule3_closure+1;
         const Data.STRef.Lazy.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:34.365867436 UTC

[section ""relreadonly" . ScETj_srt" { ScETj_srt:
 }]

