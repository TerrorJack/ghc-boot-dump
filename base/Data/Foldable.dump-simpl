
==================== Tidy Core ====================
2018-03-16 16:02:01.317943194 UTC

Result size of Tidy Core
  = {terms: 6,473, types: 16,482, coercions: 2,586, joins: 7/83}

-- RHS size: {terms: 6, types: 138, coercions: 0, joins: 0/0}
fold
  :: forall (t :: * -> *).
     Foldable t =>
     forall m. Monoid m => t m -> m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLLLLLLLLLL),U(U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for fold: "Class op fold"]
fold
  = \ (@ (t_a6K72 :: * -> *)) (v_B1 :: Foldable t_a6K72) ->
      case v_B1 of v_B1
      { Data.Foldable.C:Foldable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                                 v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_B2
      }

-- RHS size: {terms: 6, types: 138, coercions: 0, joins: 0/0}
foldMap
  :: forall (t :: * -> *).
     Foldable t =>
     forall m a. Monoid m => (a -> m) -> t a -> m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLLLLLLLLLL),U(A,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for foldMap: "Class op foldMap"]
foldMap
  = \ (@ (t_a6K72 :: * -> *)) (v_B1 :: Foldable t_a6K72) ->
      case v_B1 of v_B1
      { Data.Foldable.C:Foldable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                                 v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_B3
      }

-- RHS size: {terms: 6, types: 138, coercions: 0, joins: 0/0}
foldr
  :: forall (t :: * -> *).
     Foldable t =>
     forall a b. (a -> b -> b) -> b -> t a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLLLLLLLLLL),U(A,A,U,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for foldr: "Class op foldr"]
foldr
  = \ (@ (t_a6K72 :: * -> *)) (v_B1 :: Foldable t_a6K72) ->
      case v_B1 of v_B1
      { Data.Foldable.C:Foldable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                                 v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_B4
      }

-- RHS size: {terms: 6, types: 138, coercions: 0, joins: 0/0}
foldr'
  :: forall (t :: * -> *).
     Foldable t =>
     forall a b. (a -> b -> b) -> b -> t a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLLLLLLLLLL),U(A,A,A,U,A,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for foldr': "Class op foldr'"]
foldr'
  = \ (@ (t_a6K72 :: * -> *)) (v_B1 :: Foldable t_a6K72) ->
      case v_B1 of v_B1
      { Data.Foldable.C:Foldable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                                 v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_B5
      }

-- RHS size: {terms: 6, types: 138, coercions: 0, joins: 0/0}
foldl
  :: forall (t :: * -> *).
     Foldable t =>
     forall b a. (b -> a -> b) -> b -> t a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLLLLLLLLLL),U(A,A,A,A,U,A,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for foldl: "Class op foldl"]
foldl
  = \ (@ (t_a6K72 :: * -> *)) (v_B1 :: Foldable t_a6K72) ->
      case v_B1 of v_B1
      { Data.Foldable.C:Foldable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                                 v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_B6
      }

-- RHS size: {terms: 6, types: 138, coercions: 0, joins: 0/0}
foldl'
  :: forall (t :: * -> *).
     Foldable t =>
     forall b a. (b -> a -> b) -> b -> t a -> b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLLLLLLLLLL),U(A,A,A,A,A,U,A,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for foldl': "Class op foldl'"]
foldl'
  = \ (@ (t_a6K72 :: * -> *)) (v_B1 :: Foldable t_a6K72) ->
      case v_B1 of v_B1
      { Data.Foldable.C:Foldable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                                 v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_B7
      }

-- RHS size: {terms: 6, types: 138, coercions: 0, joins: 0/0}
foldr1
  :: forall (t :: * -> *).
     Foldable t =>
     forall a. (a -> a -> a) -> t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSLLLLLLLLL),U(A,A,A,A,A,A,U,A,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for foldr1: "Class op foldr1"]
foldr1
  = \ (@ (t_a6K72 :: * -> *)) (v_B1 :: Foldable t_a6K72) ->
      case v_B1 of v_B1
      { Data.Foldable.C:Foldable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                                 v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_B8
      }

-- RHS size: {terms: 6, types: 138, coercions: 0, joins: 0/0}
foldl1
  :: forall (t :: * -> *).
     Foldable t =>
     forall a. (a -> a -> a) -> t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLSLLLLLLLL),U(A,A,A,A,A,A,A,U,A,A,A,A,A,A,A,A)>,
 RULES: Built in rule for foldl1: "Class op foldl1"]
foldl1
  = \ (@ (t_a6K72 :: * -> *)) (v_B1 :: Foldable t_a6K72) ->
      case v_B1 of v_B1
      { Data.Foldable.C:Foldable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                                 v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_B9
      }

-- RHS size: {terms: 6, types: 138, coercions: 0, joins: 0/0}
toList :: forall (t :: * -> *). Foldable t => forall a. t a -> [a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLSLLLLLLL),U(A,A,A,A,A,A,A,A,U,A,A,A,A,A,A,A)>,
 RULES: Built in rule for toList: "Class op toList"]
toList
  = \ (@ (t_a6K72 :: * -> *)) (v_B1 :: Foldable t_a6K72) ->
      case v_B1 of v_B1
      { Data.Foldable.C:Foldable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                                 v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_Ba
      }

-- RHS size: {terms: 6, types: 138, coercions: 0, joins: 0/0}
null :: forall (t :: * -> *). Foldable t => forall a. t a -> Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLSLLLLLL),U(A,A,A,A,A,A,A,A,A,U,A,A,A,A,A,A)>,
 RULES: Built in rule for null: "Class op null"]
null
  = \ (@ (t_a6K72 :: * -> *)) (v_B1 :: Foldable t_a6K72) ->
      case v_B1 of v_B1
      { Data.Foldable.C:Foldable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                                 v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_Bb
      }

-- RHS size: {terms: 6, types: 138, coercions: 0, joins: 0/0}
length :: forall (t :: * -> *). Foldable t => forall a. t a -> Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLSLLLLL),U(A,A,A,A,A,A,A,A,A,A,U,A,A,A,A,A)>,
 RULES: Built in rule for length: "Class op length"]
length
  = \ (@ (t_a6K72 :: * -> *)) (v_B1 :: Foldable t_a6K72) ->
      case v_B1 of v_B1
      { Data.Foldable.C:Foldable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                                 v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_Bc
      }

-- RHS size: {terms: 6, types: 138, coercions: 0, joins: 0/0}
elem
  :: forall (t :: * -> *).
     Foldable t =>
     forall a. Eq a => a -> t a -> Bool
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLSLLLL),U(A,A,A,A,A,A,A,A,A,A,A,U,A,A,A,A)>,
 RULES: Built in rule for elem: "Class op elem"]
elem
  = \ (@ (t_a6K72 :: * -> *)) (v_B1 :: Foldable t_a6K72) ->
      case v_B1 of v_B1
      { Data.Foldable.C:Foldable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                                 v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_Bd
      }

-- RHS size: {terms: 6, types: 138, coercions: 0, joins: 0/0}
maximum
  :: forall (t :: * -> *). Foldable t => forall a. Ord a => t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLSLLL),U(A,A,A,A,A,A,A,A,A,A,A,A,U,A,A,A)>,
 RULES: Built in rule for maximum: "Class op maximum"]
maximum
  = \ (@ (t_a6K72 :: * -> *)) (v_B1 :: Foldable t_a6K72) ->
      case v_B1 of v_B1
      { Data.Foldable.C:Foldable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                                 v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_Be
      }

-- RHS size: {terms: 6, types: 138, coercions: 0, joins: 0/0}
minimum
  :: forall (t :: * -> *). Foldable t => forall a. Ord a => t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLSLL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,U,A,A)>,
 RULES: Built in rule for minimum: "Class op minimum"]
minimum
  = \ (@ (t_a6K72 :: * -> *)) (v_B1 :: Foldable t_a6K72) ->
      case v_B1 of v_B1
      { Data.Foldable.C:Foldable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                                 v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_Bf
      }

-- RHS size: {terms: 6, types: 138, coercions: 0, joins: 0/0}
sum
  :: forall (t :: * -> *). Foldable t => forall a. Num a => t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLSL),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,A)>,
 RULES: Built in rule for sum: "Class op sum"]
sum
  = \ (@ (t_a6K72 :: * -> *)) (v_B1 :: Foldable t_a6K72) ->
      case v_B1 of v_B1
      { Data.Foldable.C:Foldable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                                 v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_Bg
      }

-- RHS size: {terms: 6, types: 138, coercions: 0, joins: 0/0}
product
  :: forall (t :: * -> *). Foldable t => forall a. Num a => t a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLLLLLLLS),U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U)>,
 RULES: Built in rule for product: "Class op product"]
product
  = \ (@ (t_a6K72 :: * -> *)) (v_B1 :: Foldable t_a6K72) ->
      case v_B1 of v_B1
      { Data.Foldable.C:Foldable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8 v_B9
                                 v_Ba v_Bb v_Bc v_Bd v_Be v_Bf v_Bg v_Bh ->
      v_Bh
      }

-- RHS size: {terms: 13, types: 13, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableMaybe_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Maybe a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a6LUa)
                 (@ a_a6LUb)
                 (ds_d6McW [Occ=Once!] :: b_a6LUa -> a_a6LUb -> b_a6LUa)
                 (z_a6K8T [Occ=Once*] :: b_a6LUa)
                 (ds1_d6McX [Occ=Once!] :: Maybe a_a6LUb) ->
                 case ds1_d6McX of {
                   Nothing -> z_a6K8T;
                   Just x_a6K8W [Occ=Once] -> ds_d6McW z_a6K8T x_a6K8W
                 }}]
Data.Foldable.$fFoldableMaybe_$cfoldl
  = \ (@ b_a6LUa)
      (@ a_a6LUb)
      (ds_d6McW :: b_a6LUa -> a_a6LUb -> b_a6LUa)
      (z_a6K8T :: b_a6LUa)
      (ds1_d6McX :: Maybe a_a6LUb) ->
      case ds1_d6McX of {
        Nothing -> z_a6K8T;
        Just x_a6K8W -> ds_d6McW z_a6K8T x_a6K8W
      }

-- RHS size: {terms: 13, types: 13, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableMaybe_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> Maybe a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LTU)
                 (@ b_a6LTV)
                 (ds_d6McP [Occ=Once!] :: a_a6LTU -> b_a6LTV -> b_a6LTV)
                 (z_a6K8P [Occ=Once*] :: b_a6LTV)
                 (ds1_d6McQ [Occ=Once!] :: Maybe a_a6LTU) ->
                 case ds1_d6McQ of {
                   Nothing -> z_a6K8P;
                   Just x_a6K8S [Occ=Once] -> ds_d6McP x_a6K8S z_a6K8P
                 }}]
Data.Foldable.$fFoldableMaybe_$cfoldr
  = \ (@ a_a6LTU)
      (@ b_a6LTV)
      (ds_d6McP :: a_a6LTU -> b_a6LTV -> b_a6LTV)
      (z_a6K8P :: b_a6LTV)
      (ds1_d6McQ :: Maybe a_a6LTU) ->
      case ds1_d6McQ of {
        Nothing -> z_a6K8P;
        Just x_a6K8S -> ds_d6McP x_a6K8S z_a6K8P
      }

-- RHS size: {terms: 13, types: 14, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableMaybe_$cfoldMap
  :: forall m a. Monoid m => (a -> m) -> Maybe a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_a6LTF)
                 (@ a_a6LTG)
                 ($dMonoid_a6LTI [Occ=Once] :: Monoid m_a6LTF)
                 (eta_B2 [Occ=Once!] :: a_a6LTG -> m_a6LTF)
                 (eta1_B1 [Occ=Once!] :: Maybe a_a6LTG) ->
                 case eta1_B1 of {
                   Nothing -> mempty @ m_a6LTF $dMonoid_a6LTI;
                   Just x_i6McL [Occ=Once] -> eta_B2 x_i6McL
                 }}]
Data.Foldable.$fFoldableMaybe_$cfoldMap
  = \ (@ m_a6LTF)
      (@ a_a6LTG)
      ($dMonoid_a6LTI :: Monoid m_a6LTF)
      (eta_B2 :: a_a6LTG -> m_a6LTF)
      (eta1_B1 :: Maybe a_a6LTG) ->
      case eta1_B1 of {
        Nothing -> mempty @ m_a6LTF $dMonoid_a6LTI;
        Just x_i6McL -> eta_B2 x_i6McL
      }

-- RHS size: {terms: 14, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableNonEmpty_$clength
  :: forall a. NonEmpty a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LQ1) (ds_d6Mb0 [Occ=Once!] :: NonEmpty a_a6LQ1) ->
                 case ds_d6Mb0 of { :| _ [Occ=Dead] as_a6K8M [Occ=Once] ->
                 case GHC.List.$wlenAcc @ a_a6LQ1 as_a6K8M 0# of ww2_i6N7c
                 { __DEFAULT ->
                 GHC.Types.I# (+# 1# ww2_i6N7c)
                 }
                 }}]
Data.Foldable.$fFoldableNonEmpty_$clength
  = \ (@ a_a6LQ1) (ds_d6Mb0 :: NonEmpty a_a6LQ1) ->
      case ds_d6Mb0 of { :| ds1_d6Mba as_a6K8M ->
      case GHC.List.$wlenAcc @ a_a6LQ1 as_a6K8M 0# of ww2_i6N7c
      { __DEFAULT ->
      GHC.Types.I# (+# 1# ww2_i6N7c)
      }
      }

-- RHS size: {terms: 11, types: 15, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableNonEmpty_$ctoList
  :: forall a. NonEmpty a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LPN) (ds_d6MaO :: NonEmpty a_a6LPN) ->
                 GHC.Types.:
                   @ a_a6LPN
                   (case ds_d6MaO of { :| a1_a6K8N [Occ=Once] _ [Occ=Dead] ->
                    a1_a6K8N
                    })
                   (case ds_d6MaO of { :| _ [Occ=Dead] as_a6K8O [Occ=Once] ->
                    as_a6K8O
                    })}]
Data.Foldable.$fFoldableNonEmpty_$ctoList
  = \ (@ a_a6LPN) (ds_d6MaO :: NonEmpty a_a6LPN) ->
      GHC.Types.:
        @ a_a6LPN
        (case ds_d6MaO of { :| a1_a6K8N as_a6K8O -> a1_a6K8N })
        (case ds_d6MaO of { :| a1_a6K8N as_a6K8O -> as_a6K8O })

-- RHS size: {terms: 22, types: 24, coercions: 0, joins: 1/1}
Data.Foldable.$fFoldableNonEmpty_$cfoldl1
  :: forall a. (a -> a -> a) -> NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S(LS),1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LPG)
                 (f_a6K8E [Occ=OnceL!] :: a_a6LPG -> a_a6LPG -> a_a6LPG)
                 (ds_d6MaC [Occ=Once!] :: NonEmpty a_a6LPG) ->
                 case ds_d6MaC of { :| a1_a6K8F [Occ=Once] as_a6K8G [Occ=Once] ->
                 joinrec {
                   go_i6HCY [Occ=LoopBreakerT[2]] :: [a_a6LPG] -> a_a6LPG -> a_a6LPG
                   [LclId[JoinId(2)], Arity=2, Unf=OtherCon []]
                   go_i6HCY (ds1_i6HCZ [Occ=Once!] :: [a_a6LPG])
                            (eta_B1 [Occ=Once*] :: a_a6LPG)
                     = case ds1_i6HCZ of {
                         [] -> eta_B1;
                         : y_i6HD4 [Occ=Once] ys_i6HD5 [Occ=Once] ->
                           jump go_i6HCY ys_i6HD5 (f_a6K8E eta_B1 y_i6HD4)
                       }; } in
                 jump go_i6HCY as_a6K8G a1_a6K8F
                 }}]
Data.Foldable.$fFoldableNonEmpty_$cfoldl1
  = \ (@ a_a6LPG)
      (f_a6K8E :: a_a6LPG -> a_a6LPG -> a_a6LPG)
      (ds_d6MaC :: NonEmpty a_a6LPG) ->
      case ds_d6MaC of { :| a1_a6K8F as_a6K8G ->
      joinrec {
        go_i6HCY [Occ=LoopBreaker] :: [a_a6LPG] -> a_a6LPG -> a_a6LPG
        [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
        go_i6HCY (ds1_i6HCZ :: [a_a6LPG]) (eta_B1 :: a_a6LPG)
          = case ds1_i6HCZ of {
              [] -> eta_B1;
              : y_i6HD4 ys_i6HD5 ->
                jump go_i6HCY ys_i6HD5 (f_a6K8E eta_B1 y_i6HD4)
            }; } in
      jump go_i6HCY as_a6K8G a1_a6K8F
      }

-- RHS size: {terms: 24, types: 23, coercions: 0, joins: 1/1}
Data.Foldable.$w$cfoldl2 [InlPrag=NOUSERINLINE[0]]
  :: forall b a. (b -> a -> b) -> b -> a -> [a] -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0 0] 92 0}]
Data.Foldable.$w$cfoldl2
  = \ (@ b_s6NRS)
      (@ a_s6NRT)
      (w_s6NRU :: b_s6NRS -> a_s6NRT -> b_s6NRS)
      (w1_s6NRV :: b_s6NRS)
      (ww_s6NRZ :: a_s6NRT)
      (ww1_s6NS0 :: [a_s6NRT]) ->
      joinrec {
        go_i6HCY [Occ=LoopBreaker] :: [a_s6NRT] -> b_s6NRS -> b_s6NRS
        [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
        go_i6HCY (ds_i6HCZ :: [a_s6NRT]) (eta_B1 :: b_s6NRS)
          = case ds_i6HCZ of {
              [] -> eta_B1;
              : y_i6HD4 ys_i6HD5 ->
                jump go_i6HCY ys_i6HD5 (w_s6NRU eta_B1 y_i6HD4)
            }; } in
      jump go_i6HCY ww1_s6NS0 (w_s6NRU w1_s6NRV ww_s6NRZ)

-- RHS size: {terms: 13, types: 17, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableNonEmpty_$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall b a. (b -> a -> b) -> b -> NonEmpty a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S(LS),1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_s6NRS)
                 (@ a_s6NRT)
                 (w_s6NRU [Occ=Once] :: b_s6NRS -> a_s6NRT -> b_s6NRS)
                 (w1_s6NRV [Occ=Once] :: b_s6NRS)
                 (w2_s6NRW [Occ=Once!] :: NonEmpty a_s6NRT) ->
                 case w2_s6NRW of { :| ww1_s6NRZ [Occ=Once] ww2_s6NS0 [Occ=Once] ->
                 Data.Foldable.$w$cfoldl2
                   @ b_s6NRS @ a_s6NRT w_s6NRU w1_s6NRV ww1_s6NRZ ww2_s6NS0
                 }}]
Data.Foldable.$fFoldableNonEmpty_$cfoldl
  = \ (@ b_s6NRS)
      (@ a_s6NRT)
      (w_s6NRU :: b_s6NRS -> a_s6NRT -> b_s6NRS)
      (w1_s6NRV :: b_s6NRS)
      (w2_s6NRW :: NonEmpty a_s6NRT) ->
      case w2_s6NRW of { :| ww1_s6NRZ ww2_s6NS0 ->
      Data.Foldable.$w$cfoldl2
        @ b_s6NRS @ a_s6NRT w_s6NRU w1_s6NRV ww1_s6NRZ ww2_s6NS0
      }

-- RHS size: {terms: 26, types: 30, coercions: 0, joins: 0/1}
Data.Foldable.$fFoldableNonEmpty_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> NonEmpty a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,U(1*U,1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 40] 160 0}]
Data.Foldable.$fFoldableNonEmpty_$cfoldr
  = \ (@ a_a6LOV)
      (@ b_a6LOW)
      (f_a6K8w :: a_a6LOV -> b_a6LOW -> b_a6LOW)
      (z_a6K8x :: b_a6LOW)
      (ds_d6Ma6 :: NonEmpty a_a6LOV) ->
      f_a6K8w
        (case ds_d6Ma6 of { :| a1_a6K8y as_a6K8z -> a1_a6K8y })
        (case ds_d6Ma6 of { :| a1_a6K8y as_a6K8z ->
         letrec {
           go_i6HCY [Occ=LoopBreaker] :: [a_a6LOV] -> b_a6LOW
           [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
           go_i6HCY
             = \ (ds1_i6HCZ :: [a_a6LOV]) ->
                 case ds1_i6HCZ of {
                   [] -> z_a6K8x;
                   : y_i6HD4 ys_i6HD5 -> f_a6K8w y_i6HD4 (go_i6HCY ys_i6HD5)
                 }; } in
         go_i6HCY as_a6K8z
         })

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:*:4 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Foldable.$fFoldable:*:4 = GHC.Types.I# 0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableDual3 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Foldable.$fFoldableDual3 = GHC.Types.I# 1#

-- RHS size: {terms: 9, types: 12, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableEither_$clength
  :: forall a1 a2. Either a1 a2 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LM0)
                 (@ a1_a6LNy)
                 (ds_d6M9s [Occ=Once!] :: Either a_a6LM0 a1_a6LNy) ->
                 case ds_d6M9s of {
                   Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4;
                   Right _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3
                 }}]
Data.Foldable.$fFoldableEither_$clength
  = \ (@ a_a6LM0)
      (@ a1_a6LNy)
      (ds_d6M9s :: Either a_a6LM0 a1_a6LNy) ->
      case ds_d6M9s of {
        Left ds1_d6M9A -> Data.Foldable.$fFoldable:*:4;
        Right ds1_d6M9B -> Data.Foldable.$fFoldableDual3
      }

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableEither_$cfoldr
  :: forall a1 a2 b. (a2 -> b -> b) -> b -> Either a1 a2 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LM0)
                 (@ a1_a6LMq)
                 (@ b_a6LMr)
                 (ds_d6M9b [Occ=Once!] :: a1_a6LMq -> b_a6LMr -> b_a6LMr)
                 (z_a6K8s [Occ=Once*] :: b_a6LMr)
                 (ds1_d6M9c [Occ=Once!] :: Either a_a6LM0 a1_a6LMq) ->
                 case ds1_d6M9c of {
                   Left _ [Occ=Dead] -> z_a6K8s;
                   Right y_a6K8v [Occ=Once] -> ds_d6M9b y_a6K8v z_a6K8s
                 }}]
Data.Foldable.$fFoldableEither_$cfoldr
  = \ (@ a_a6LM0)
      (@ a1_a6LMq)
      (@ b_a6LMr)
      (ds_d6M9b :: a1_a6LMq -> b_a6LMr -> b_a6LMr)
      (z_a6K8s :: b_a6LMr)
      (ds1_d6M9c :: Either a_a6LM0 a1_a6LMq) ->
      case ds1_d6M9c of {
        Left ds2_d6M9k -> z_a6K8s;
        Right y_a6K8v -> ds_d6M9b y_a6K8v z_a6K8s
      }

-- RHS size: {terms: 14, types: 19, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableEither_$cfoldMap
  :: forall a1 m a2. Monoid m => (a2 -> m) -> Either a1 a2 -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LM0)
                 (@ m_a6LMe)
                 (@ a1_a6LMf)
                 ($dMonoid_a6LMh [Occ=Once] :: Monoid m_a6LMe)
                 (ds_d6M90 [Occ=Once!] :: a1_a6LMf -> m_a6LMe)
                 (ds1_d6M91 [Occ=Once!] :: Either a_a6LM0 a1_a6LMf) ->
                 case ds1_d6M91 of {
                   Left _ [Occ=Dead] -> mempty @ m_a6LMe $dMonoid_a6LMh;
                   Right y_a6K8r [Occ=Once] -> ds_d6M90 y_a6K8r
                 }}]
Data.Foldable.$fFoldableEither_$cfoldMap
  = \ (@ a_a6LM0)
      (@ m_a6LMe)
      (@ a1_a6LMf)
      ($dMonoid_a6LMh :: Monoid m_a6LMe)
      (ds_d6M90 :: a1_a6LMf -> m_a6LMe)
      (ds1_d6M91 :: Either a_a6LM0 a1_a6LMf) ->
      case ds1_d6M91 of {
        Left ds2_d6M9a -> mempty @ m_a6LMe $dMonoid_a6LMh;
        Right y_a6K8r -> ds_d6M90 y_a6K8r
      }

-- RHS size: {terms: 12, types: 18, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable(,)_$cfoldr
  :: forall a1 a2 b. (a2 -> b -> b) -> b -> (a1, a2) -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LJD)
                 (@ a1_a6LJZ)
                 (@ b_a6LK0)
                 (f_a6K8m [Occ=Once!] :: a1_a6LJZ -> b_a6LK0 -> b_a6LK0)
                 (z_a6K8n [Occ=Once] :: b_a6LK0)
                 (ds_d6M8T [Occ=Once!] :: (a_a6LJD, a1_a6LJZ)) ->
                 case ds_d6M8T of { (_ [Occ=Dead], y_a6K8o [Occ=Once]) ->
                 f_a6K8m y_a6K8o z_a6K8n
                 }}]
Data.Foldable.$fFoldable(,)_$cfoldr
  = \ (@ a_a6LJD)
      (@ a1_a6LJZ)
      (@ b_a6LK0)
      (f_a6K8m :: a1_a6LJZ -> b_a6LK0 -> b_a6LK0)
      (z_a6K8n :: b_a6LK0)
      (ds_d6M8T :: (a_a6LJD, a1_a6LJZ)) ->
      case ds_d6M8T of { (ds1_d6M8Z, y_a6K8o) ->
      f_a6K8m y_a6K8o z_a6K8n
      }

-- RHS size: {terms: 11, types: 18, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable(,)_$cfoldMap
  :: forall a1 m a2. Monoid m => (a2 -> m) -> (a1, a2) -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*U(A,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LJD)
                 (@ m_a6LJR)
                 (@ a1_a6LJS)
                 _ [Occ=Dead]
                 (f_a6K8k [Occ=Once!] :: a1_a6LJS -> m_a6LJR)
                 (ds_d6M8L [Occ=Once!] :: (a_a6LJD, a1_a6LJS)) ->
                 case ds_d6M8L of { (_ [Occ=Dead], y_a6K8l [Occ=Once]) ->
                 f_a6K8k y_a6K8l
                 }}]
Data.Foldable.$fFoldable(,)_$cfoldMap
  = \ (@ a_a6LJD)
      (@ m_a6LJR)
      (@ a1_a6LJS)
      _ [Occ=Dead]
      (f_a6K8k :: a1_a6LJS -> m_a6LJR)
      (ds_d6M8L :: (a_a6LJD, a1_a6LJS)) ->
      case ds_d6M8L of { (ds1_d6M8S, y_a6K8l) -> f_a6K8k y_a6K8l }

-- RHS size: {terms: 12, types: 16, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableArray_$cnull
  :: forall i a. Array i a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),1*U(A,A,1*U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ i_a6LGK)
                 (@ a_a6LIu)
                 (a1_a6K8i [Occ=Once!] :: Array i_a6LGK a_a6LIu) ->
                 case a1_a6K8i of
                 { Array _ [Occ=Dead] _ [Occ=Dead] dt_i6M8G [Occ=Once!]
                         _ [Occ=Dead] ->
                 case dt_i6M8G of {
                   __DEFAULT -> GHC.Types.False;
                   0# -> GHC.Types.True
                 }
                 }}]
Data.Foldable.$fFoldableArray_$cnull
  = \ (@ i_a6LGK) (@ a_a6LIu) (a1_a6K8i :: Array i_a6LGK a_a6LIu) ->
      case a1_a6K8i of { Array ds1_i6M8E ds2_i6M8F dt_i6M8G ds3_i6M8H ->
      case dt_i6M8G of {
        __DEFAULT -> GHC.Types.False;
        0# -> GHC.Types.True
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy1
  :: integer-simple-0.1.1.1:GHC.Integer.Type.Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Data.Foldable.$fFoldableProxy1 = 1

-- RHS size: {terms: 6, types: 9, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy_$cproduct
  :: forall a. Num a => Proxy a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LGC)
                 ($dNum_a6LGE [Occ=Once] :: Num a_a6LGC)
                 _ [Occ=Dead] ->
                 fromInteger @ a_a6LGC $dNum_a6LGE Data.Foldable.$fFoldableProxy1}]
Data.Foldable.$fFoldableProxy_$cproduct
  = \ (@ a_a6LGC) ($dNum_a6LGE :: Num a_a6LGC) _ [Occ=Dead] ->
      fromInteger @ a_a6LGC $dNum_a6LGE Data.Foldable.$fFoldableProxy1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy2
  :: integer-simple-0.1.1.1:GHC.Integer.Type.Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Data.Foldable.$fFoldableProxy2 = 0

-- RHS size: {terms: 6, types: 9, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy_$csum
  :: forall a. Num a => Proxy a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LGt)
                 ($dNum_a6LGv [Occ=Once] :: Num a_a6LGt)
                 _ [Occ=Dead] ->
                 fromInteger @ a_a6LGt $dNum_a6LGv Data.Foldable.$fFoldableProxy2}]
Data.Foldable.$fFoldableProxy_$csum
  = \ (@ a_a6LGt) ($dNum_a6LGv :: Num a_a6LGt) _ [Occ=Dead] ->
      fromInteger @ a_a6LGt $dNum_a6LGv Data.Foldable.$fFoldableProxy2

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy_$celem
  :: forall a. Eq a => a -> Proxy a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LG2) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.False}]
Data.Foldable.$fFoldableProxy_$celem
  = \ (@ a_a6LG2) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
      GHC.Types.False

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy_$clength :: forall a. Proxy a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LFX) _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4}]
Data.Foldable.$fFoldableProxy_$clength
  = \ (@ a_a6LFX) _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy_$cnull :: forall a. Proxy a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LFS) _ [Occ=Dead] -> GHC.Types.True}]
Data.Foldable.$fFoldableProxy_$cnull
  = \ (@ a_a6LFS) _ [Occ=Dead] -> GHC.Types.True

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Foldable.$fFoldableProxy4 = "foldl1: Proxy"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy3 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Foldable.$fFoldableProxy3
  = unpackCString# Data.Foldable.$fFoldableProxy4

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy_$cfoldl1
  :: forall a. (a -> a -> a) -> Proxy a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LFD) _ [Occ=Dead] _ [Occ=Dead] ->
                 errorWithoutStackTrace
                   @ 'LiftedRep @ a_a6LFD Data.Foldable.$fFoldableProxy3}]
Data.Foldable.$fFoldableProxy_$cfoldl1
  = \ (@ a_a6LFD) _ [Occ=Dead] _ [Occ=Dead] ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6LFD Data.Foldable.$fFoldableProxy3

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Foldable.$fFoldableProxy6 = "foldr1: Proxy"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Foldable.$fFoldableProxy5
  = unpackCString# Data.Foldable.$fFoldableProxy6

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy_$cfoldr1
  :: forall a. (a -> a -> a) -> Proxy a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LFw) _ [Occ=Dead] _ [Occ=Dead] ->
                 errorWithoutStackTrace
                   @ 'LiftedRep @ a_a6LFw Data.Foldable.$fFoldableProxy5}]
Data.Foldable.$fFoldableProxy_$cfoldr1
  = \ (@ a_a6LFw) _ [Occ=Dead] _ [Occ=Dead] ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6LFw Data.Foldable.$fFoldableProxy5

-- RHS size: {terms: 6, types: 12, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy_$cfoldl [InlPrag=INLINE (sat-args=3)]
  :: forall b a. (b -> a -> b) -> b -> Proxy a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ b_a6LFg)
                 (@ a_a6LFh)
                 _ [Occ=Dead]
                 (z_a6K8g [Occ=Once] :: b_a6LFg)
                 _ [Occ=Dead] ->
                 z_a6K8g}]
Data.Foldable.$fFoldableProxy_$cfoldl
  = \ (@ b_a6LFg)
      (@ a_a6LFh)
      _ [Occ=Dead]
      (z_a6K8g :: b_a6LFg)
      _ [Occ=Dead] ->
      z_a6K8g

-- RHS size: {terms: 6, types: 12, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy_$cfoldr [InlPrag=INLINE (sat-args=3)]
  :: forall a b. (a -> b -> b) -> b -> Proxy a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ a_a6LF0)
                 (@ b_a6LF1)
                 _ [Occ=Dead]
                 (z_a6K8f [Occ=Once] :: b_a6LF1)
                 _ [Occ=Dead] ->
                 z_a6K8f}]
Data.Foldable.$fFoldableProxy_$cfoldr
  = \ (@ a_a6LF0)
      (@ b_a6LF1)
      _ [Occ=Dead]
      (z_a6K8f :: b_a6LF1)
      _ [Occ=Dead] ->
      z_a6K8f

-- RHS size: {terms: 7, types: 13, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy_$cfoldMap [InlPrag=INLINE (sat-args=2)]
  :: forall m a. Monoid m => (a -> m) -> Proxy a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ m_a6LEQ)
                 (@ a_a6LER)
                 ($dMonoid_a6LET [Occ=Once] :: Monoid m_a6LEQ)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 mempty @ m_a6LEQ $dMonoid_a6LET}]
Data.Foldable.$fFoldableProxy_$cfoldMap
  = \ (@ m_a6LEQ)
      (@ a_a6LER)
      ($dMonoid_a6LET :: Monoid m_a6LEQ)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      mempty @ m_a6LEQ $dMonoid_a6LET

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy_$cfold [InlPrag=INLINE (sat-args=1)]
  :: forall m. Monoid m => Proxy m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ m_a6LEH)
                 ($dMonoid_a6LEJ [Occ=Once] :: Monoid m_a6LEH)
                 _ [Occ=Dead] ->
                 mempty @ m_a6LEH $dMonoid_a6LEJ}]
Data.Foldable.$fFoldableProxy_$cfold
  = \ (@ m_a6LEH) ($dMonoid_a6LEJ :: Monoid m_a6LEH) _ [Occ=Dead] ->
      mempty @ m_a6LEH $dMonoid_a6LEJ

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableDual1
  :: forall a. Num a => Dual a -> Dual a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LEx) _ [Occ=Dead] ->
                 Data.Semigroup.Internal.$fGeneric1Dual2 @ a_a6LEx}]
Data.Foldable.$fFoldableDual1
  = \ (@ a_a6LEx) _ [Occ=Dead] ->
      Data.Semigroup.Internal.$fGeneric1Dual2 @ a_a6LEx

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableDual2
  :: forall a. Ord a => Dual a -> Dual a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LEh) _ [Occ=Dead] ->
                 Data.Semigroup.Internal.$fGeneric1Dual2 @ a_a6LEh}]
Data.Foldable.$fFoldableDual2
  = \ (@ a_a6LEh) _ [Occ=Dead] ->
      Data.Semigroup.Internal.$fGeneric1Dual2 @ a_a6LEh

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableDual_$clength :: forall a. Dual a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LDN) _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3}]
Data.Foldable.$fFoldableDual_$clength
  = \ (@ a_a6LDN) _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableDual_$cnull :: forall a. Dual a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LDI) _ [Occ=Dead] -> GHC.Types.False}]
Data.Foldable.$fFoldableDual_$cnull
  = \ (@ a_a6LDI) _ [Occ=Dead] -> GHC.Types.False

-- RHS size: {terms: 5, types: 6, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableDual_$ctoList :: forall a. Dual a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LDD) (ds_d6M5h [Occ=Once] :: Dual a_a6LDD) ->
                 GHC.Types.:
                   @ a_a6LDD
                   (ds_d6M5h
                    `cast` (Data.Semigroup.Internal.N:Dual[0] <a_a6LDD>_R
                            :: (Dual a_a6LDD :: *) ~R# (a_a6LDD :: *)))
                   (GHC.Types.[] @ a_a6LDD)}]
Data.Foldable.$fFoldableDual_$ctoList
  = \ (@ a_a6LDD) (ds_d6M5h :: Dual a_a6LDD) ->
      GHC.Types.:
        @ a_a6LDD
        (ds_d6M5h
         `cast` (Data.Semigroup.Internal.N:Dual[0] <a_a6LDD>_R
                 :: (Dual a_a6LDD :: *) ~R# (a_a6LDD :: *)))
        (GHC.Types.[] @ a_a6LDD)

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableDual4
  :: forall a. (a -> a -> a) -> Dual a -> Dual a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LDx) _ [Occ=Dead] ->
                 Data.Semigroup.Internal.$fGeneric1Dual2 @ a_a6LDx}]
Data.Foldable.$fFoldableDual4
  = \ (@ a_a6LDx) _ [Occ=Dead] ->
      Data.Semigroup.Internal.$fGeneric1Dual2 @ a_a6LDx

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableDual5
  :: forall b a. (b -> a -> b) -> b -> a -> b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_a6LDh)
                 (@ a_a6LDi)
                 (v_B2 [Occ=Once] :: b_a6LDh -> a_a6LDi -> b_a6LDh) ->
                 v_B2}]
Data.Foldable.$fFoldableDual5
  = \ (@ b_a6LDh)
      (@ a_a6LDi)
      (v_B2 :: b_a6LDh -> a_a6LDi -> b_a6LDh) ->
      v_B2

-- RHS size: {terms: 8, types: 10, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableDual_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> Dual a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LCQ)
                 (@ b_a6LCR)
                 (f_a6K8b [Occ=Once!] :: a_a6LCQ -> b_a6LCR -> b_a6LCR)
                 (z_a6K8c [Occ=Once] :: b_a6LCR)
                 (ds_d6M54 [Occ=Once] :: Dual a_a6LCQ) ->
                 f_a6K8b
                   (ds_d6M54
                    `cast` (Data.Semigroup.Internal.N:Dual[0] <a_a6LCQ>_R
                            :: (Dual a_a6LCQ :: *) ~R# (a_a6LCQ :: *)))
                   z_a6K8c}]
Data.Foldable.$fFoldableDual_$cfoldr
  = \ (@ a_a6LCQ)
      (@ b_a6LCR)
      (f_a6K8b :: a_a6LCQ -> b_a6LCR -> b_a6LCR)
      (z_a6K8c :: b_a6LCR)
      (ds_d6M54 :: Dual a_a6LCQ) ->
      f_a6K8b
        (ds_d6M54
         `cast` (Data.Semigroup.Internal.N:Dual[0] <a_a6LCQ>_R
                 :: (Dual a_a6LCQ :: *) ~R# (a_a6LCQ :: *)))
        z_a6K8c

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableDual6
  :: forall m a. Monoid m => (a -> m) -> a -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ m_a6LCF)
                 (@ a_a6LCG)
                 _ [Occ=Dead]
                 (v_X8P [Occ=Once] :: a_a6LCG -> m_a6LCF) ->
                 v_X8P}]
Data.Foldable.$fFoldableDual6
  = \ (@ m_a6LCF)
      (@ a_a6LCG)
      _ [Occ=Dead]
      (v_X8P :: a_a6LCG -> m_a6LCF) ->
      v_X8P

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableSum1 :: forall a. Num a => Sum a -> Sum a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LCl) _ [Occ=Dead] ->
                 Data.Semigroup.Internal.$fGeneric1Sum2 @ a_a6LCl}]
Data.Foldable.$fFoldableSum1
  = \ (@ a_a6LCl) _ [Occ=Dead] ->
      Data.Semigroup.Internal.$fGeneric1Sum2 @ a_a6LCl

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableSum2 :: forall a. Ord a => Sum a -> Sum a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LC5) _ [Occ=Dead] ->
                 Data.Semigroup.Internal.$fGeneric1Sum2 @ a_a6LC5}]
Data.Foldable.$fFoldableSum2
  = \ (@ a_a6LC5) _ [Occ=Dead] ->
      Data.Semigroup.Internal.$fGeneric1Sum2 @ a_a6LC5

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableSum_$clength :: forall a. Sum a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LBB) _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3}]
Data.Foldable.$fFoldableSum_$clength
  = \ (@ a_a6LBB) _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableSum_$cnull :: forall a. Sum a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LBw) _ [Occ=Dead] -> GHC.Types.False}]
Data.Foldable.$fFoldableSum_$cnull
  = \ (@ a_a6LBw) _ [Occ=Dead] -> GHC.Types.False

-- RHS size: {terms: 5, types: 6, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableSum_$ctoList :: forall a. Sum a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LBr) (ds_d6M4F [Occ=Once] :: Sum a_a6LBr) ->
                 GHC.Types.:
                   @ a_a6LBr
                   (ds_d6M4F
                    `cast` (Data.Semigroup.Internal.N:Sum[0] <a_a6LBr>_R
                            :: (Sum a_a6LBr :: *) ~R# (a_a6LBr :: *)))
                   (GHC.Types.[] @ a_a6LBr)}]
Data.Foldable.$fFoldableSum_$ctoList
  = \ (@ a_a6LBr) (ds_d6M4F :: Sum a_a6LBr) ->
      GHC.Types.:
        @ a_a6LBr
        (ds_d6M4F
         `cast` (Data.Semigroup.Internal.N:Sum[0] <a_a6LBr>_R
                 :: (Sum a_a6LBr :: *) ~R# (a_a6LBr :: *)))
        (GHC.Types.[] @ a_a6LBr)

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableSum3
  :: forall a. (a -> a -> a) -> Sum a -> Sum a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LBl) _ [Occ=Dead] ->
                 Data.Semigroup.Internal.$fGeneric1Sum2 @ a_a6LBl}]
Data.Foldable.$fFoldableSum3
  = \ (@ a_a6LBl) _ [Occ=Dead] ->
      Data.Semigroup.Internal.$fGeneric1Sum2 @ a_a6LBl

-- RHS size: {terms: 8, types: 10, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableSum_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> Sum a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LAE)
                 (@ b_a6LAF)
                 (f_a6K87 [Occ=Once!] :: a_a6LAE -> b_a6LAF -> b_a6LAF)
                 (z_a6K88 [Occ=Once] :: b_a6LAF)
                 (ds_d6M4s [Occ=Once] :: Sum a_a6LAE) ->
                 f_a6K87
                   (ds_d6M4s
                    `cast` (Data.Semigroup.Internal.N:Sum[0] <a_a6LAE>_R
                            :: (Sum a_a6LAE :: *) ~R# (a_a6LAE :: *)))
                   z_a6K88}]
Data.Foldable.$fFoldableSum_$cfoldr
  = \ (@ a_a6LAE)
      (@ b_a6LAF)
      (f_a6K87 :: a_a6LAE -> b_a6LAF -> b_a6LAF)
      (z_a6K88 :: b_a6LAF)
      (ds_d6M4s :: Sum a_a6LAE) ->
      f_a6K87
        (ds_d6M4s
         `cast` (Data.Semigroup.Internal.N:Sum[0] <a_a6LAE>_R
                 :: (Sum a_a6LAE :: *) ~R# (a_a6LAE :: *)))
        z_a6K88

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProduct1
  :: forall a. Num a => Product a -> Product a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LA9) _ [Occ=Dead] ->
                 Data.Semigroup.Internal.$fGeneric1Product2 @ a_a6LA9}]
Data.Foldable.$fFoldableProduct1
  = \ (@ a_a6LA9) _ [Occ=Dead] ->
      Data.Semigroup.Internal.$fGeneric1Product2 @ a_a6LA9

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProduct2
  :: forall a. Ord a => Product a -> Product a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LzT) _ [Occ=Dead] ->
                 Data.Semigroup.Internal.$fGeneric1Product2 @ a_a6LzT}]
Data.Foldable.$fFoldableProduct2
  = \ (@ a_a6LzT) _ [Occ=Dead] ->
      Data.Semigroup.Internal.$fGeneric1Product2 @ a_a6LzT

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProduct_$clength
  :: forall a. Product a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Lzp) _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3}]
Data.Foldable.$fFoldableProduct_$clength
  = \ (@ a_a6Lzp) _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProduct_$cnull
  :: forall a. Product a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Lzk) _ [Occ=Dead] -> GHC.Types.False}]
Data.Foldable.$fFoldableProduct_$cnull
  = \ (@ a_a6Lzk) _ [Occ=Dead] -> GHC.Types.False

-- RHS size: {terms: 5, types: 6, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableProduct_$ctoList
  :: forall a. Product a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6Lzf) (ds_d6M43 [Occ=Once] :: Product a_a6Lzf) ->
                 GHC.Types.:
                   @ a_a6Lzf
                   (ds_d6M43
                    `cast` (Data.Semigroup.Internal.N:Product[0] <a_a6Lzf>_R
                            :: (Product a_a6Lzf :: *) ~R# (a_a6Lzf :: *)))
                   (GHC.Types.[] @ a_a6Lzf)}]
Data.Foldable.$fFoldableProduct_$ctoList
  = \ (@ a_a6Lzf) (ds_d6M43 :: Product a_a6Lzf) ->
      GHC.Types.:
        @ a_a6Lzf
        (ds_d6M43
         `cast` (Data.Semigroup.Internal.N:Product[0] <a_a6Lzf>_R
                 :: (Product a_a6Lzf :: *) ~R# (a_a6Lzf :: *)))
        (GHC.Types.[] @ a_a6Lzf)

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProduct3
  :: forall a. (a -> a -> a) -> Product a -> Product a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Lz9) _ [Occ=Dead] ->
                 Data.Semigroup.Internal.$fGeneric1Product2 @ a_a6Lz9}]
Data.Foldable.$fFoldableProduct3
  = \ (@ a_a6Lz9) _ [Occ=Dead] ->
      Data.Semigroup.Internal.$fGeneric1Product2 @ a_a6Lz9

-- RHS size: {terms: 8, types: 10, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableProduct_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> Product a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Lys)
                 (@ b_a6Lyt)
                 (f_a6K83 [Occ=Once!] :: a_a6Lys -> b_a6Lyt -> b_a6Lyt)
                 (z_a6K84 [Occ=Once] :: b_a6Lyt)
                 (ds_d6M3Q [Occ=Once] :: Product a_a6Lys) ->
                 f_a6K83
                   (ds_d6M3Q
                    `cast` (Data.Semigroup.Internal.N:Product[0] <a_a6Lys>_R
                            :: (Product a_a6Lys :: *) ~R# (a_a6Lys :: *)))
                   z_a6K84}]
Data.Foldable.$fFoldableProduct_$cfoldr
  = \ (@ a_a6Lys)
      (@ b_a6Lyt)
      (f_a6K83 :: a_a6Lys -> b_a6Lyt -> b_a6Lyt)
      (z_a6K84 :: b_a6Lyt)
      (ds_d6M3Q :: Product a_a6Lys) ->
      f_a6K83
        (ds_d6M3Q
         `cast` (Data.Semigroup.Internal.N:Product[0] <a_a6Lys>_R
                 :: (Product a_a6Lys :: *) ~R# (a_a6Lys :: *)))
        z_a6K84

-- RHS size: {terms: 6, types: 9, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableU1_$cproduct
  :: forall a. Num a => U1 a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LsO)
                 ($dNum_a6LsQ [Occ=Once] :: Num a_a6LsO)
                 _ [Occ=Dead] ->
                 fromInteger @ a_a6LsO $dNum_a6LsQ Data.Foldable.$fFoldableProxy1}]
Data.Foldable.$fFoldableU1_$cproduct
  = \ (@ a_a6LsO) ($dNum_a6LsQ :: Num a_a6LsO) _ [Occ=Dead] ->
      fromInteger @ a_a6LsO $dNum_a6LsQ Data.Foldable.$fFoldableProxy1

-- RHS size: {terms: 6, types: 9, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableU1_$csum :: forall a. Num a => U1 a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LsF)
                 ($dNum_a6LsH [Occ=Once] :: Num a_a6LsF)
                 _ [Occ=Dead] ->
                 fromInteger @ a_a6LsF $dNum_a6LsH Data.Foldable.$fFoldableProxy2}]
Data.Foldable.$fFoldableU1_$csum
  = \ (@ a_a6LsF) ($dNum_a6LsH :: Num a_a6LsF) _ [Occ=Dead] ->
      fromInteger @ a_a6LsF $dNum_a6LsH Data.Foldable.$fFoldableProxy2

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableU1_$celem
  :: forall a. Eq a => a -> U1 a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Lse) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.False}]
Data.Foldable.$fFoldableU1_$celem
  = \ (@ a_a6Lse) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
      GHC.Types.False

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableU1_$clength :: forall a. U1 a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Ls9) _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4}]
Data.Foldable.$fFoldableU1_$clength
  = \ (@ a_a6Ls9) _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableU1_$cnull :: forall a. U1 a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Ls4) _ [Occ=Dead] -> GHC.Types.True}]
Data.Foldable.$fFoldableU1_$cnull
  = \ (@ a_a6Ls4) _ [Occ=Dead] -> GHC.Types.True

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableU3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Foldable.$fFoldableU3 = "foldl1: U1"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableU2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Foldable.$fFoldableU2
  = unpackCString# Data.Foldable.$fFoldableU3

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableU1_$cfoldl1
  :: forall a. (a -> a -> a) -> U1 a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LrP) _ [Occ=Dead] _ [Occ=Dead] ->
                 errorWithoutStackTrace
                   @ 'LiftedRep @ a_a6LrP Data.Foldable.$fFoldableU2}]
Data.Foldable.$fFoldableU1_$cfoldl1
  = \ (@ a_a6LrP) _ [Occ=Dead] _ [Occ=Dead] ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6LrP Data.Foldable.$fFoldableU2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableU5 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Foldable.$fFoldableU5 = "foldr1: U1"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableU4 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Foldable.$fFoldableU4
  = unpackCString# Data.Foldable.$fFoldableU5

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableU1_$cfoldr1
  :: forall a. (a -> a -> a) -> U1 a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LrI) _ [Occ=Dead] _ [Occ=Dead] ->
                 errorWithoutStackTrace
                   @ 'LiftedRep @ a_a6LrI Data.Foldable.$fFoldableU4}]
Data.Foldable.$fFoldableU1_$cfoldr1
  = \ (@ a_a6LrI) _ [Occ=Dead] _ [Occ=Dead] ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6LrI Data.Foldable.$fFoldableU4

-- RHS size: {terms: 6, types: 12, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableU1_$cfoldl [InlPrag=INLINE (sat-args=3)]
  :: forall b a. (b -> a -> b) -> b -> U1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ b_a6Lrs)
                 (@ a_a6Lrt)
                 _ [Occ=Dead]
                 (z_a6K80 [Occ=Once] :: b_a6Lrs)
                 _ [Occ=Dead] ->
                 z_a6K80}]
Data.Foldable.$fFoldableU1_$cfoldl
  = \ (@ b_a6Lrs)
      (@ a_a6Lrt)
      _ [Occ=Dead]
      (z_a6K80 :: b_a6Lrs)
      _ [Occ=Dead] ->
      z_a6K80

-- RHS size: {terms: 6, types: 12, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableU1_$cfoldr [InlPrag=INLINE (sat-args=3)]
  :: forall a b. (a -> b -> b) -> b -> U1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ a_a6Lrc)
                 (@ b_a6Lrd)
                 _ [Occ=Dead]
                 (z_a6K7Z [Occ=Once] :: b_a6Lrd)
                 _ [Occ=Dead] ->
                 z_a6K7Z}]
Data.Foldable.$fFoldableU1_$cfoldr
  = \ (@ a_a6Lrc)
      (@ b_a6Lrd)
      _ [Occ=Dead]
      (z_a6K7Z :: b_a6Lrd)
      _ [Occ=Dead] ->
      z_a6K7Z

-- RHS size: {terms: 7, types: 13, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableU1_$cfoldMap [InlPrag=INLINE (sat-args=2)]
  :: forall m a. Monoid m => (a -> m) -> U1 a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ m_a6Lr2)
                 (@ a_a6Lr3)
                 ($dMonoid_a6Lr5 [Occ=Once] :: Monoid m_a6Lr2)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 mempty @ m_a6Lr2 $dMonoid_a6Lr5}]
Data.Foldable.$fFoldableU1_$cfoldMap
  = \ (@ m_a6Lr2)
      (@ a_a6Lr3)
      ($dMonoid_a6Lr5 :: Monoid m_a6Lr2)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      mempty @ m_a6Lr2 $dMonoid_a6Lr5

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableU1_$cfold [InlPrag=INLINE (sat-args=1)]
  :: forall m. Monoid m => U1 m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ m_a6LqT)
                 ($dMonoid_a6LqV [Occ=Once] :: Monoid m_a6LqT)
                 _ [Occ=Dead] ->
                 mempty @ m_a6LqT $dMonoid_a6LqV}]
Data.Foldable.$fFoldableU1_$cfold
  = \ (@ m_a6LqT) ($dMonoid_a6LqV :: Monoid m_a6LqT) _ [Occ=Dead] ->
      mempty @ m_a6LqT $dMonoid_a6LqV

-- RHS size: {terms: 7, types: 13, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableV1_$cfoldMap
  :: forall m a. Monoid m => (a -> m) -> V1 a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ m_a6LoB)
                 (@ a_a6LoC)
                 ($dMonoid_a6LoE [Occ=Once] :: Monoid m_a6LoB)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 mempty @ m_a6LoB $dMonoid_a6LoE}]
Data.Foldable.$fFoldableV1_$cfoldMap
  = \ (@ m_a6LoB)
      (@ a_a6LoC)
      ($dMonoid_a6LoE :: Monoid m_a6LoB)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      mempty @ m_a6LoB $dMonoid_a6LoE

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldablePar1_$cnull :: forall a. Par1 a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Lno) _ [Occ=Dead] -> GHC.Types.False}]
Data.Foldable.$fFoldablePar1_$cnull
  = \ (@ a_a6Lno) _ [Occ=Dead] -> GHC.Types.False

-- RHS size: {terms: 8, types: 10, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldablePar1_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> Par1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Lmq)
                 (@ b_a6Lmr)
                 (f_a6Kqr [Occ=Once!] :: a_a6Lmq -> b_a6Lmr -> b_a6Lmr)
                 (z_a6Kqs [Occ=Once] :: b_a6Lmr)
                 (ds_d6M2U [Occ=Once] :: Par1 a_a6Lmq) ->
                 f_a6Kqr
                   (ds_d6M2U
                    `cast` (GHC.Generics.N:Par1[0] <a_a6Lmq>_R
                            :: (Par1 a_a6Lmq :: *) ~R# (a_a6Lmq :: *)))
                   z_a6Kqs}]
Data.Foldable.$fFoldablePar1_$cfoldr
  = \ (@ a_a6Lmq)
      (@ b_a6Lmr)
      (f_a6Kqr :: a_a6Lmq -> b_a6Lmr -> b_a6Lmr)
      (z_a6Kqs :: b_a6Lmr)
      (ds_d6M2U :: Par1 a_a6Lmq) ->
      f_a6Kqr
        (ds_d6M2U
         `cast` (GHC.Generics.N:Par1[0] <a_a6Lmq>_R
                 :: (Par1 a_a6Lmq :: *) ~R# (a_a6Lmq :: *)))
        z_a6Kqs

-- RHS size: {terms: 7, types: 10, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldablePar1_$cfoldMap
  :: forall m a. Monoid m => (a -> m) -> Par1 a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ m_a6Lmi)
                 (@ a_a6Lmj)
                 _ [Occ=Dead]
                 (f_a6Kqu [Occ=Once!] :: a_a6Lmj -> m_a6Lmi)
                 (ds_d6M2T [Occ=Once] :: Par1 a_a6Lmj) ->
                 f_a6Kqu
                   (ds_d6M2T
                    `cast` (GHC.Generics.N:Par1[0] <a_a6Lmj>_R
                            :: (Par1 a_a6Lmj :: *) ~R# (a_a6Lmj :: *)))}]
Data.Foldable.$fFoldablePar1_$cfoldMap
  = \ (@ m_a6Lmi)
      (@ a_a6Lmj)
      _ [Occ=Dead]
      (f_a6Kqu :: a_a6Lmj -> m_a6Lmi)
      (ds_d6M2T :: Par1 a_a6Lmj) ->
      f_a6Kqu
        (ds_d6M2T
         `cast` (GHC.Generics.N:Par1[0] <a_a6Lmj>_R
                 :: (Par1 a_a6Lmj :: *) ~R# (a_a6Lmj :: *)))

-- RHS size: {terms: 9, types: 18, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK1_$cfoldMap
  :: forall i c m a. Monoid m => (a -> m) -> K1 i c a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ i_a6LgS)
                 (@ c_a6LgT)
                 (@ m_a6Lh7)
                 (@ a_a6Lh8)
                 ($dMonoid_a6Lha [Occ=Once] :: Monoid m_a6Lh7)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 mempty @ m_a6Lh7 $dMonoid_a6Lha}]
Data.Foldable.$fFoldableK1_$cfoldMap
  = \ (@ i_a6LgS)
      (@ c_a6LgT)
      (@ m_a6Lh7)
      (@ a_a6Lh8)
      ($dMonoid_a6Lha :: Monoid m_a6Lh7)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      mempty @ m_a6Lh7 $dMonoid_a6Lha

-- RHS size: {terms: 16, types: 34, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:+:_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. (:+:) f g a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6Lb0 :: * -> *))
                 (@ (g_a6Lb1 :: * -> *))
                 ($dFoldable_a6Lb2 [Occ=Once] :: Foldable f_a6Lb0)
                 ($dFoldable1_a6Lb3 [Occ=Once] :: Foldable g_a6Lb1)
                 (@ a_a6Ld0)
                 (ds_d6M2K [Occ=Once!] :: (:+:) f_a6Lb0 g_a6Lb1 a_a6Ld0) ->
                 case ds_d6M2K of {
                   L1 a1_a6Kq9 [Occ=Once] ->
                     null @ f_a6Lb0 $dFoldable_a6Lb2 @ a_a6Ld0 a1_a6Kq9;
                   R1 a1_a6Kqa [Occ=Once] ->
                     null @ g_a6Lb1 $dFoldable1_a6Lb3 @ a_a6Ld0 a1_a6Kqa
                 }}]
Data.Foldable.$fFoldable:+:_$cnull
  = \ (@ (f_a6Lb0 :: * -> *))
      (@ (g_a6Lb1 :: * -> *))
      ($dFoldable_a6Lb2 :: Foldable f_a6Lb0)
      ($dFoldable1_a6Lb3 :: Foldable g_a6Lb1)
      (@ a_a6Ld0)
      (ds_d6M2K :: (:+:) f_a6Lb0 g_a6Lb1 a_a6Ld0) ->
      case ds_d6M2K of {
        L1 a1_a6Kq9 -> null @ f_a6Lb0 $dFoldable_a6Lb2 @ a_a6Ld0 a1_a6Kq9;
        R1 a1_a6Kqa -> null @ g_a6Lb1 $dFoldable1_a6Lb3 @ a_a6Ld0 a1_a6Kqa
      }

-- RHS size: {terms: 23, types: 42, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:+:_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (:+:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6Lb0 :: * -> *))
                 (@ (g_a6Lb1 :: * -> *))
                 ($dFoldable_a6Lb2 [Occ=Once] :: Foldable f_a6Lb0)
                 ($dFoldable1_a6Lb3 [Occ=Once] :: Foldable g_a6Lb1)
                 (@ a_a6Lbz)
                 (@ b_a6LbA)
                 (f1_a6KpV [Occ=Once*] :: a_a6Lbz -> b_a6LbA -> b_a6LbA)
                 (z_a6KpW [Occ=Once*] :: b_a6LbA)
                 (ds_d6M2J [Occ=Once!] :: (:+:) f_a6Lb0 g_a6Lb1 a_a6Lbz) ->
                 case ds_d6M2J of {
                   L1 a1_a6KpX [Occ=Once] ->
                     foldr
                       @ f_a6Lb0
                       $dFoldable_a6Lb2
                       @ a_a6Lbz
                       @ b_a6LbA
                       f1_a6KpV
                       z_a6KpW
                       a1_a6KpX;
                   R1 a1_a6Kq2 [Occ=Once] ->
                     foldr
                       @ g_a6Lb1
                       $dFoldable1_a6Lb3
                       @ a_a6Lbz
                       @ b_a6LbA
                       f1_a6KpV
                       z_a6KpW
                       a1_a6Kq2
                 }}]
Data.Foldable.$fFoldable:+:_$cfoldr
  = \ (@ (f_a6Lb0 :: * -> *))
      (@ (g_a6Lb1 :: * -> *))
      ($dFoldable_a6Lb2 :: Foldable f_a6Lb0)
      ($dFoldable1_a6Lb3 :: Foldable g_a6Lb1)
      (@ a_a6Lbz)
      (@ b_a6LbA)
      (f1_a6KpV :: a_a6Lbz -> b_a6LbA -> b_a6LbA)
      (z_a6KpW :: b_a6LbA)
      (ds_d6M2J :: (:+:) f_a6Lb0 g_a6Lb1 a_a6Lbz) ->
      case ds_d6M2J of {
        L1 a1_a6KpX ->
          foldr
            @ f_a6Lb0
            $dFoldable_a6Lb2
            @ a_a6Lbz
            @ b_a6LbA
            f1_a6KpV
            z_a6KpW
            a1_a6KpX;
        R1 a1_a6Kq2 ->
          foldr
            @ g_a6Lb1
            $dFoldable1_a6Lb3
            @ a_a6Lbz
            @ b_a6LbA
            f1_a6KpV
            z_a6KpW
            a1_a6Kq2
      }

-- RHS size: {terms: 23, types: 42, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:+:_$cfoldMap
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall m a. Monoid m => (a -> m) -> (:+:) f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6Lb0 :: * -> *))
                 (@ (g_a6Lb1 :: * -> *))
                 ($dFoldable_a6Lb2 [Occ=Once] :: Foldable f_a6Lb0)
                 ($dFoldable1_a6Lb3 [Occ=Once] :: Foldable g_a6Lb1)
                 (@ m_a6Lbh)
                 (@ a_a6Lbi)
                 ($dMonoid_a6Lbk [Occ=Once*] :: Monoid m_a6Lbh)
                 (f1_a6Kq5 [Occ=Once*] :: a_a6Lbi -> m_a6Lbh)
                 (ds_d6M2I [Occ=Once!] :: (:+:) f_a6Lb0 g_a6Lb1 a_a6Lbi) ->
                 case ds_d6M2I of {
                   L1 a1_a6Kq6 [Occ=Once] ->
                     foldMap
                       @ f_a6Lb0
                       $dFoldable_a6Lb2
                       @ m_a6Lbh
                       @ a_a6Lbi
                       $dMonoid_a6Lbk
                       f1_a6Kq5
                       a1_a6Kq6;
                   R1 a1_a6Kq8 [Occ=Once] ->
                     foldMap
                       @ g_a6Lb1
                       $dFoldable1_a6Lb3
                       @ m_a6Lbh
                       @ a_a6Lbi
                       $dMonoid_a6Lbk
                       f1_a6Kq5
                       a1_a6Kq8
                 }}]
Data.Foldable.$fFoldable:+:_$cfoldMap
  = \ (@ (f_a6Lb0 :: * -> *))
      (@ (g_a6Lb1 :: * -> *))
      ($dFoldable_a6Lb2 :: Foldable f_a6Lb0)
      ($dFoldable1_a6Lb3 :: Foldable g_a6Lb1)
      (@ m_a6Lbh)
      (@ a_a6Lbi)
      ($dMonoid_a6Lbk :: Monoid m_a6Lbh)
      (f1_a6Kq5 :: a_a6Lbi -> m_a6Lbh)
      (ds_d6M2I :: (:+:) f_a6Lb0 g_a6Lb1 a_a6Lbi) ->
      case ds_d6M2I of {
        L1 a1_a6Kq6 ->
          foldMap
            @ f_a6Lb0
            $dFoldable_a6Lb2
            @ m_a6Lbh
            @ a_a6Lbi
            $dMonoid_a6Lbk
            f1_a6Kq5
            a1_a6Kq6;
        R1 a1_a6Kq8 ->
          foldMap
            @ g_a6Lb1
            $dFoldable1_a6Lb3
            @ m_a6Lbh
            @ a_a6Lbi
            $dMonoid_a6Lbk
            f1_a6Kq5
            a1_a6Kq8
      }

-- RHS size: {terms: 19, types: 35, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:*:_$cnull
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. (:*:) f g a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLLC(S)LLLLLL),1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6L7R :: * -> *))
                 (@ (g_a6L7S :: * -> *))
                 ($dFoldable_a6L7T [Occ=Once] :: Foldable f_a6L7R)
                 ($dFoldable1_a6L7U [Occ=Once] :: Foldable g_a6L7S)
                 (@ a_a6L9T)
                 (ds_d6M2H [Occ=Once!] :: (:*:) f_a6L7R g_a6L7S a_a6L9T) ->
                 case ds_d6M2H of { :*: a1_a6KpT [Occ=Once] a2_a6KpU [Occ=Once] ->
                 case null @ f_a6L7R $dFoldable_a6L7T @ a_a6L9T a1_a6KpT of {
                   False -> GHC.Types.False;
                   True -> null @ g_a6L7S $dFoldable1_a6L7U @ a_a6L9T a2_a6KpU
                 }
                 }}]
Data.Foldable.$fFoldable:*:_$cnull
  = \ (@ (f_a6L7R :: * -> *))
      (@ (g_a6L7S :: * -> *))
      ($dFoldable_a6L7T :: Foldable f_a6L7R)
      ($dFoldable1_a6L7U :: Foldable g_a6L7S)
      (@ a_a6L9T)
      (ds_d6M2H :: (:*:) f_a6L7R g_a6L7S a_a6L9T) ->
      case ds_d6M2H of { :*: a1_a6KpT a2_a6KpU ->
      case null @ f_a6L7R $dFoldable_a6L7T @ a_a6L9T a1_a6KpT of {
        False -> GHC.Types.False;
        True -> null @ g_a6L7S $dFoldable1_a6L7U @ a_a6L9T a2_a6KpU
      }
      }

-- RHS size: {terms: 21, types: 42, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:*:_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (:*:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6L7R :: * -> *))
                 (@ (g_a6L7S :: * -> *))
                 ($dFoldable_a6L7T [Occ=Once] :: Foldable f_a6L7R)
                 ($dFoldable1_a6L7U [Occ=Once] :: Foldable g_a6L7S)
                 (@ a_a6L8s)
                 (@ b_a6L8t)
                 (f1_a6KpI :: a_a6L8s -> b_a6L8t -> b_a6L8t)
                 (z_a6KpJ [Occ=Once] :: b_a6L8t)
                 (ds_d6M2G [Occ=Once!] :: (:*:) f_a6L7R g_a6L7S a_a6L8s) ->
                 case ds_d6M2G of { :*: a1_a6KpK [Occ=Once] a2_a6KpL [Occ=Once] ->
                 foldr
                   @ f_a6L7R
                   $dFoldable_a6L7T
                   @ a_a6L8s
                   @ b_a6L8t
                   f1_a6KpI
                   (foldr
                      @ g_a6L7S
                      $dFoldable1_a6L7U
                      @ a_a6L8s
                      @ b_a6L8t
                      f1_a6KpI
                      z_a6KpJ
                      a2_a6KpL)
                   a1_a6KpK
                 }}]
Data.Foldable.$fFoldable:*:_$cfoldr
  = \ (@ (f_a6L7R :: * -> *))
      (@ (g_a6L7S :: * -> *))
      ($dFoldable_a6L7T :: Foldable f_a6L7R)
      ($dFoldable1_a6L7U :: Foldable g_a6L7S)
      (@ a_a6L8s)
      (@ b_a6L8t)
      (f1_a6KpI :: a_a6L8s -> b_a6L8t -> b_a6L8t)
      (z_a6KpJ :: b_a6L8t)
      (ds_d6M2G :: (:*:) f_a6L7R g_a6L7S a_a6L8s) ->
      case ds_d6M2G of { :*: a1_a6KpK a2_a6KpL ->
      foldr
        @ f_a6L7R
        $dFoldable_a6L7T
        @ a_a6L8s
        @ b_a6L8t
        f1_a6KpI
        (foldr
           @ g_a6L7S
           $dFoldable1_a6L7U
           @ a_a6L8s
           @ b_a6L8t
           f1_a6KpI
           z_a6KpJ
           a2_a6KpL)
        a1_a6KpK
      }

-- RHS size: {terms: 22, types: 31, coercions: 0, joins: 0/0}
Data.Foldable.$w$cfoldMap [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall m a. Monoid m => (a -> m) -> f a -> g a -> m
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 0 0 0] 140 0}]
Data.Foldable.$w$cfoldMap
  = \ (@ (f_s6NS9 :: * -> *))
      (@ (g_s6NSa :: * -> *))
      (w_s6NSb :: Foldable f_s6NS9)
      (w1_s6NSc :: Foldable g_s6NSa)
      (@ m_s6NSd)
      (@ a_s6NSe)
      (w2_s6NSf :: Monoid m_s6NSd)
      (w3_s6NSg :: a_s6NSe -> m_s6NSd)
      (ww_s6NSk :: f_s6NS9 a_s6NSe)
      (ww1_s6NSl :: g_s6NSa a_s6NSe) ->
      mappend
        @ m_s6NSd
        w2_s6NSf
        (foldMap
           @ f_s6NS9 w_s6NSb @ m_s6NSd @ a_s6NSe w2_s6NSf w3_s6NSg ww_s6NSk)
        (foldMap
           @ g_s6NSa w1_s6NSc @ m_s6NSd @ a_s6NSe w2_s6NSf w3_s6NSg ww1_s6NSl)

-- RHS size: {terms: 19, types: 40, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:*:_$cfoldMap [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall m a. Monoid m => (a -> m) -> (:*:) f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><L,U><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_s6NS9 :: * -> *))
                 (@ (g_s6NSa :: * -> *))
                 (w_s6NSb [Occ=Once] :: Foldable f_s6NS9)
                 (w1_s6NSc [Occ=Once] :: Foldable g_s6NSa)
                 (@ m_s6NSd)
                 (@ a_s6NSe)
                 (w2_s6NSf [Occ=Once] :: Monoid m_s6NSd)
                 (w3_s6NSg [Occ=Once] :: a_s6NSe -> m_s6NSd)
                 (w4_s6NSh [Occ=Once!] :: (:*:) f_s6NS9 g_s6NSa a_s6NSe) ->
                 case w4_s6NSh of { :*: ww1_s6NSk [Occ=Once] ww2_s6NSl [Occ=Once] ->
                 Data.Foldable.$w$cfoldMap
                   @ f_s6NS9
                   @ g_s6NSa
                   w_s6NSb
                   w1_s6NSc
                   @ m_s6NSd
                   @ a_s6NSe
                   w2_s6NSf
                   w3_s6NSg
                   ww1_s6NSk
                   ww2_s6NSl
                 }}]
Data.Foldable.$fFoldable:*:_$cfoldMap
  = \ (@ (f_s6NS9 :: * -> *))
      (@ (g_s6NSa :: * -> *))
      (w_s6NSb :: Foldable f_s6NS9)
      (w1_s6NSc :: Foldable g_s6NSa)
      (@ m_s6NSd)
      (@ a_s6NSe)
      (w2_s6NSf :: Monoid m_s6NSd)
      (w3_s6NSg :: a_s6NSe -> m_s6NSd)
      (w4_s6NSh :: (:*:) f_s6NS9 g_s6NSa a_s6NSe) ->
      case w4_s6NSh of { :*: ww1_s6NSk ww2_s6NSl ->
      Data.Foldable.$w$cfoldMap
        @ f_s6NS9
        @ g_s6NSa
        w_s6NSb
        w1_s6NSc
        @ m_s6NSd
        @ a_s6NSe
        w2_s6NSf
        w3_s6NSg
        ww1_s6NSk
        ww2_s6NSl
      }

-- RHS size: {terms: 20, types: 38, coercions: 8, joins: 0/0}
Data.Foldable.$fFoldable:.:_$cfoldr
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (:.:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6L4U :: * -> *))
                 (@ (g_a6L4V :: * -> *))
                 ($dFoldable_a6L4W [Occ=Once] :: Foldable f_a6L4U)
                 ($dFoldable1_a6L4X [Occ=OnceL] :: Foldable g_a6L4V)
                 (@ a_a6L5t)
                 (@ b_a6L5u)
                 (f1_a6Kpy [Occ=OnceL] :: a_a6L5t -> b_a6L5u -> b_a6L5u)
                 (z_a6Kpz [Occ=Once] :: b_a6L5u)
                 (ds_d6M2D [Occ=Once] :: (:.:) f_a6L4U g_a6L4V a_a6L5t) ->
                 foldr
                   @ f_a6L4U
                   $dFoldable_a6L4W
                   @ (g_a6L4V a_a6L5t)
                   @ b_a6L5u
                   (\ (b1_a6KpD [Occ=Once] :: g_a6L4V a_a6L5t)
                      (b2_a6KpE [Occ=Once] :: b_a6L5u) ->
                      foldr
                        @ g_a6L4V
                        $dFoldable1_a6L4X
                        @ a_a6L5t
                        @ b_a6L5u
                        f1_a6Kpy
                        b2_a6KpE
                        b1_a6KpD)
                   z_a6Kpz
                   (ds_d6M2D
                    `cast` (GHC.Generics.N::.:[0]
                                <*>_N <*>_N <f_a6L4U>_R <g_a6L4V>_N <a_a6L5t>_N
                            :: ((:.:) f_a6L4U g_a6L4V a_a6L5t :: *)
                               ~R# (f_a6L4U (g_a6L4V a_a6L5t) :: *)))}]
Data.Foldable.$fFoldable:.:_$cfoldr
  = \ (@ (f_a6L4U :: * -> *))
      (@ (g_a6L4V :: * -> *))
      ($dFoldable_a6L4W :: Foldable f_a6L4U)
      ($dFoldable1_a6L4X :: Foldable g_a6L4V)
      (@ a_a6L5t)
      (@ b_a6L5u)
      (f1_a6Kpy :: a_a6L5t -> b_a6L5u -> b_a6L5u)
      (z_a6Kpz :: b_a6L5u)
      (ds_d6M2D :: (:.:) f_a6L4U g_a6L4V a_a6L5t) ->
      foldr
        @ f_a6L4U
        $dFoldable_a6L4W
        @ (g_a6L4V a_a6L5t)
        @ b_a6L5u
        (\ (b1_a6KpD :: g_a6L4V a_a6L5t) (b2_a6KpE :: b_a6L5u) ->
           foldr
             @ g_a6L4V
             $dFoldable1_a6L4X
             @ a_a6L5t
             @ b_a6L5u
             f1_a6Kpy
             b2_a6KpE
             b1_a6KpD)
        z_a6Kpz
        (ds_d6M2D
         `cast` (GHC.Generics.N::.:[0]
                     <*>_N <*>_N <f_a6L4U>_R <g_a6L4V>_N <a_a6L5t>_N
                 :: ((:.:) f_a6L4U g_a6L4V a_a6L5t :: *)
                    ~R# (f_a6L4U (g_a6L4V a_a6L5t) :: *)))

-- RHS size: {terms: 17, types: 35, coercions: 8, joins: 0/0}
Data.Foldable.$fFoldable:.:_$cfoldMap
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall m a. Monoid m => (a -> m) -> (:.:) f g a -> m
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6L4U :: * -> *))
                 (@ (g_a6L4V :: * -> *))
                 ($dFoldable_a6L4W [Occ=Once] :: Foldable f_a6L4U)
                 ($dFoldable1_a6L4X [Occ=Once] :: Foldable g_a6L4V)
                 (@ m_a6L5b)
                 (@ a_a6L5c)
                 ($dMonoid_a6L5e :: Monoid m_a6L5b)
                 (f1_a6KpF [Occ=Once] :: a_a6L5c -> m_a6L5b)
                 (ds_d6M2C [Occ=Once] :: (:.:) f_a6L4U g_a6L4V a_a6L5c) ->
                 foldMap
                   @ f_a6L4U
                   $dFoldable_a6L4W
                   @ m_a6L5b
                   @ (g_a6L4V a_a6L5c)
                   $dMonoid_a6L5e
                   (foldMap
                      @ g_a6L4V
                      $dFoldable1_a6L4X
                      @ m_a6L5b
                      @ a_a6L5c
                      $dMonoid_a6L5e
                      f1_a6KpF)
                   (ds_d6M2C
                    `cast` (GHC.Generics.N::.:[0]
                                <*>_N <*>_N <f_a6L4U>_R <g_a6L4V>_N <a_a6L5c>_N
                            :: ((:.:) f_a6L4U g_a6L4V a_a6L5c :: *)
                               ~R# (f_a6L4U (g_a6L4V a_a6L5c) :: *)))}]
Data.Foldable.$fFoldable:.:_$cfoldMap
  = \ (@ (f_a6L4U :: * -> *))
      (@ (g_a6L4V :: * -> *))
      ($dFoldable_a6L4W :: Foldable f_a6L4U)
      ($dFoldable1_a6L4X :: Foldable g_a6L4V)
      (@ m_a6L5b)
      (@ a_a6L5c)
      ($dMonoid_a6L5e :: Monoid m_a6L5b)
      (f1_a6KpF :: a_a6L5c -> m_a6L5b)
      (ds_d6M2C :: (:.:) f_a6L4U g_a6L4V a_a6L5c) ->
      foldMap
        @ f_a6L4U
        $dFoldable_a6L4W
        @ m_a6L5b
        @ (g_a6L4V a_a6L5c)
        $dMonoid_a6L5e
        (foldMap
           @ g_a6L4V
           $dFoldable1_a6L4X
           @ m_a6L5b
           @ a_a6L5c
           $dMonoid_a6L5e
           f1_a6KpF)
        (ds_d6M2C
         `cast` (GHC.Generics.N::.:[0]
                     <*>_N <*>_N <f_a6L4U>_R <g_a6L4V>_N <a_a6L5c>_N
                 :: ((:.:) f_a6L4U g_a6L4V a_a6L5c :: *)
                    ~R# (f_a6L4U (g_a6L4V a_a6L5c) :: *)))

-- RHS size: {terms: 6, types: 13, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec4_$cnull
  :: forall a. URec (GHC.Ptr.Ptr ()) a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6L3S)
                 (ds_d6M2z [Occ=Once] :: URec (GHC.Ptr.Ptr ()) a_a6L3S) ->
                 case ds_d6M2z
                      `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_a6L3S>_N
                              :: (URec (GHC.Ptr.Ptr ()) a_a6L3S :: *)
                                 ~R# (GHC.Generics.R:UReckPtrp * a_a6L3S :: *))
                 of
                 { UAddr _ [Occ=Dead] ->
                 GHC.Types.True
                 }}]
Data.Foldable.$fFoldableURec4_$cnull
  = \ (@ a_a6L3S) (ds_d6M2z :: URec (GHC.Ptr.Ptr ()) a_a6L3S) ->
      case ds_d6M2z
           `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_a6L3S>_N
                   :: (URec (GHC.Ptr.Ptr ()) a_a6L3S :: *)
                      ~R# (GHC.Generics.R:UReckPtrp * a_a6L3S :: *))
      of
      { UAddr a1_a6Kpx ->
      GHC.Types.True
      }

-- RHS size: {terms: 9, types: 19, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec4_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> URec (GHC.Ptr.Ptr ()) a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6L2S)
                 (@ b_a6L2T)
                 _ [Occ=Dead]
                 (z_a6Kpt [Occ=Once] :: b_a6L2T)
                 (ds_d6M2w [Occ=Once] :: URec (GHC.Ptr.Ptr ()) a_a6L2S) ->
                 case ds_d6M2w
                      `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_a6L2S>_N
                              :: (URec (GHC.Ptr.Ptr ()) a_a6L2S :: *)
                                 ~R# (GHC.Generics.R:UReckPtrp * a_a6L2S :: *))
                 of
                 { UAddr _ [Occ=Dead] ->
                 z_a6Kpt
                 }}]
Data.Foldable.$fFoldableURec4_$cfoldr
  = \ (@ a_a6L2S)
      (@ b_a6L2T)
      _ [Occ=Dead]
      (z_a6Kpt :: b_a6L2T)
      (ds_d6M2w :: URec (GHC.Ptr.Ptr ()) a_a6L2S) ->
      case ds_d6M2w
           `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_a6L2S>_N
                   :: (URec (GHC.Ptr.Ptr ()) a_a6L2S :: *)
                      ~R# (GHC.Generics.R:UReckPtrp * a_a6L2S :: *))
      of
      { UAddr a1_a6Kpu ->
      z_a6Kpt
      }

-- RHS size: {terms: 10, types: 20, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec4_$cfoldMap
  :: forall m a. Monoid m => (a -> m) -> URec (GHC.Ptr.Ptr ()) a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_a6L2F)
                 (@ a_a6L2G)
                 ($dMonoid_a6L2I [Occ=Once] :: Monoid m_a6L2F)
                 _ [Occ=Dead]
                 (ds_d6M2t [Occ=Once] :: URec (GHC.Ptr.Ptr ()) a_a6L2G) ->
                 case ds_d6M2t
                      `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_a6L2G>_N
                              :: (URec (GHC.Ptr.Ptr ()) a_a6L2G :: *)
                                 ~R# (GHC.Generics.R:UReckPtrp * a_a6L2G :: *))
                 of
                 { UAddr _ [Occ=Dead] ->
                 mempty @ m_a6L2F $dMonoid_a6L2I
                 }}]
Data.Foldable.$fFoldableURec4_$cfoldMap
  = \ (@ m_a6L2F)
      (@ a_a6L2G)
      ($dMonoid_a6L2I :: Monoid m_a6L2F)
      _ [Occ=Dead]
      (ds_d6M2t :: URec (GHC.Ptr.Ptr ()) a_a6L2G) ->
      case ds_d6M2t
           `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_a6L2G>_N
                   :: (URec (GHC.Ptr.Ptr ()) a_a6L2G :: *)
                      ~R# (GHC.Generics.R:UReckPtrp * a_a6L2G :: *))
      of
      { UAddr a1_a6Kpw ->
      mempty @ m_a6L2F $dMonoid_a6L2I
      }

-- RHS size: {terms: 6, types: 12, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec3_$cnull
  :: forall a. URec Char a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6L1q) (ds_d6M2q [Occ=Once] :: URec Char a_a6L1q) ->
                 case ds_d6M2q
                      `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_a6L1q>_N
                              :: (URec Char a_a6L1q :: *)
                                 ~R# (GHC.Generics.R:UReckCharp * a_a6L1q :: *))
                 of
                 { UChar _ [Occ=Dead] ->
                 GHC.Types.True
                 }}]
Data.Foldable.$fFoldableURec3_$cnull
  = \ (@ a_a6L1q) (ds_d6M2q :: URec Char a_a6L1q) ->
      case ds_d6M2q
           `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_a6L1q>_N
                   :: (URec Char a_a6L1q :: *)
                      ~R# (GHC.Generics.R:UReckCharp * a_a6L1q :: *))
      of
      { UChar a1_a6Kpr ->
      GHC.Types.True
      }

-- RHS size: {terms: 9, types: 18, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec3_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> URec Char a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6L0q)
                 (@ b_a6L0r)
                 _ [Occ=Dead]
                 (z_a6Kpn [Occ=Once] :: b_a6L0r)
                 (ds_d6M2n [Occ=Once] :: URec Char a_a6L0q) ->
                 case ds_d6M2n
                      `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_a6L0q>_N
                              :: (URec Char a_a6L0q :: *)
                                 ~R# (GHC.Generics.R:UReckCharp * a_a6L0q :: *))
                 of
                 { UChar _ [Occ=Dead] ->
                 z_a6Kpn
                 }}]
Data.Foldable.$fFoldableURec3_$cfoldr
  = \ (@ a_a6L0q)
      (@ b_a6L0r)
      _ [Occ=Dead]
      (z_a6Kpn :: b_a6L0r)
      (ds_d6M2n :: URec Char a_a6L0q) ->
      case ds_d6M2n
           `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_a6L0q>_N
                   :: (URec Char a_a6L0q :: *)
                      ~R# (GHC.Generics.R:UReckCharp * a_a6L0q :: *))
      of
      { UChar a1_a6Kpo ->
      z_a6Kpn
      }

-- RHS size: {terms: 10, types: 19, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec3_$cfoldMap
  :: forall m a. Monoid m => (a -> m) -> URec Char a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_a6L0d)
                 (@ a_a6L0e)
                 ($dMonoid_a6L0g [Occ=Once] :: Monoid m_a6L0d)
                 _ [Occ=Dead]
                 (ds_d6M2k [Occ=Once] :: URec Char a_a6L0e) ->
                 case ds_d6M2k
                      `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_a6L0e>_N
                              :: (URec Char a_a6L0e :: *)
                                 ~R# (GHC.Generics.R:UReckCharp * a_a6L0e :: *))
                 of
                 { UChar _ [Occ=Dead] ->
                 mempty @ m_a6L0d $dMonoid_a6L0g
                 }}]
Data.Foldable.$fFoldableURec3_$cfoldMap
  = \ (@ m_a6L0d)
      (@ a_a6L0e)
      ($dMonoid_a6L0g :: Monoid m_a6L0d)
      _ [Occ=Dead]
      (ds_d6M2k :: URec Char a_a6L0e) ->
      case ds_d6M2k
           `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_a6L0e>_N
                   :: (URec Char a_a6L0e :: *)
                      ~R# (GHC.Generics.R:UReckCharp * a_a6L0e :: *))
      of
      { UChar a1_a6Kpq ->
      mempty @ m_a6L0d $dMonoid_a6L0g
      }

-- RHS size: {terms: 6, types: 12, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec2_$cnull
  :: forall a. URec Double a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KYY) (ds_d6M2h [Occ=Once] :: URec Double a_a6KYY) ->
                 case ds_d6M2h
                      `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_a6KYY>_N
                              :: (URec Double a_a6KYY :: *)
                                 ~R# (GHC.Generics.R:UReckDoublep * a_a6KYY :: *))
                 of
                 { UDouble _ [Occ=Dead] ->
                 GHC.Types.True
                 }}]
Data.Foldable.$fFoldableURec2_$cnull
  = \ (@ a_a6KYY) (ds_d6M2h :: URec Double a_a6KYY) ->
      case ds_d6M2h
           `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_a6KYY>_N
                   :: (URec Double a_a6KYY :: *)
                      ~R# (GHC.Generics.R:UReckDoublep * a_a6KYY :: *))
      of
      { UDouble a1_a6Kpl ->
      GHC.Types.True
      }

-- RHS size: {terms: 9, types: 18, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec2_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> URec Double a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KXY)
                 (@ b_a6KXZ)
                 _ [Occ=Dead]
                 (z_a6Kph [Occ=Once] :: b_a6KXZ)
                 (ds_d6M2e [Occ=Once] :: URec Double a_a6KXY) ->
                 case ds_d6M2e
                      `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_a6KXY>_N
                              :: (URec Double a_a6KXY :: *)
                                 ~R# (GHC.Generics.R:UReckDoublep * a_a6KXY :: *))
                 of
                 { UDouble _ [Occ=Dead] ->
                 z_a6Kph
                 }}]
Data.Foldable.$fFoldableURec2_$cfoldr
  = \ (@ a_a6KXY)
      (@ b_a6KXZ)
      _ [Occ=Dead]
      (z_a6Kph :: b_a6KXZ)
      (ds_d6M2e :: URec Double a_a6KXY) ->
      case ds_d6M2e
           `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_a6KXY>_N
                   :: (URec Double a_a6KXY :: *)
                      ~R# (GHC.Generics.R:UReckDoublep * a_a6KXY :: *))
      of
      { UDouble a1_a6Kpi ->
      z_a6Kph
      }

-- RHS size: {terms: 10, types: 19, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec2_$cfoldMap
  :: forall m a. Monoid m => (a -> m) -> URec Double a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_a6KXL)
                 (@ a_a6KXM)
                 ($dMonoid_a6KXO [Occ=Once] :: Monoid m_a6KXL)
                 _ [Occ=Dead]
                 (ds_d6M2b [Occ=Once] :: URec Double a_a6KXM) ->
                 case ds_d6M2b
                      `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_a6KXM>_N
                              :: (URec Double a_a6KXM :: *)
                                 ~R# (GHC.Generics.R:UReckDoublep * a_a6KXM :: *))
                 of
                 { UDouble _ [Occ=Dead] ->
                 mempty @ m_a6KXL $dMonoid_a6KXO
                 }}]
Data.Foldable.$fFoldableURec2_$cfoldMap
  = \ (@ m_a6KXL)
      (@ a_a6KXM)
      ($dMonoid_a6KXO :: Monoid m_a6KXL)
      _ [Occ=Dead]
      (ds_d6M2b :: URec Double a_a6KXM) ->
      case ds_d6M2b
           `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_a6KXM>_N
                   :: (URec Double a_a6KXM :: *)
                      ~R# (GHC.Generics.R:UReckDoublep * a_a6KXM :: *))
      of
      { UDouble a1_a6Kpk ->
      mempty @ m_a6KXL $dMonoid_a6KXO
      }

-- RHS size: {terms: 6, types: 12, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec1_$cnull
  :: forall a. URec Float a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KWw) (ds_d6M28 [Occ=Once] :: URec Float a_a6KWw) ->
                 case ds_d6M28
                      `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_a6KWw>_N
                              :: (URec Float a_a6KWw :: *)
                                 ~R# (GHC.Generics.R:UReckFloatp * a_a6KWw :: *))
                 of
                 { UFloat _ [Occ=Dead] ->
                 GHC.Types.True
                 }}]
Data.Foldable.$fFoldableURec1_$cnull
  = \ (@ a_a6KWw) (ds_d6M28 :: URec Float a_a6KWw) ->
      case ds_d6M28
           `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_a6KWw>_N
                   :: (URec Float a_a6KWw :: *)
                      ~R# (GHC.Generics.R:UReckFloatp * a_a6KWw :: *))
      of
      { UFloat a1_a6Kpf ->
      GHC.Types.True
      }

-- RHS size: {terms: 9, types: 18, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec1_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> URec Float a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KVw)
                 (@ b_a6KVx)
                 _ [Occ=Dead]
                 (z_a6Kpb [Occ=Once] :: b_a6KVx)
                 (ds_d6M25 [Occ=Once] :: URec Float a_a6KVw) ->
                 case ds_d6M25
                      `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_a6KVw>_N
                              :: (URec Float a_a6KVw :: *)
                                 ~R# (GHC.Generics.R:UReckFloatp * a_a6KVw :: *))
                 of
                 { UFloat _ [Occ=Dead] ->
                 z_a6Kpb
                 }}]
Data.Foldable.$fFoldableURec1_$cfoldr
  = \ (@ a_a6KVw)
      (@ b_a6KVx)
      _ [Occ=Dead]
      (z_a6Kpb :: b_a6KVx)
      (ds_d6M25 :: URec Float a_a6KVw) ->
      case ds_d6M25
           `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_a6KVw>_N
                   :: (URec Float a_a6KVw :: *)
                      ~R# (GHC.Generics.R:UReckFloatp * a_a6KVw :: *))
      of
      { UFloat a1_a6Kpc ->
      z_a6Kpb
      }

-- RHS size: {terms: 10, types: 19, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec1_$cfoldMap
  :: forall m a. Monoid m => (a -> m) -> URec Float a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_a6KVj)
                 (@ a_a6KVk)
                 ($dMonoid_a6KVm [Occ=Once] :: Monoid m_a6KVj)
                 _ [Occ=Dead]
                 (ds_d6M22 [Occ=Once] :: URec Float a_a6KVk) ->
                 case ds_d6M22
                      `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_a6KVk>_N
                              :: (URec Float a_a6KVk :: *)
                                 ~R# (GHC.Generics.R:UReckFloatp * a_a6KVk :: *))
                 of
                 { UFloat _ [Occ=Dead] ->
                 mempty @ m_a6KVj $dMonoid_a6KVm
                 }}]
Data.Foldable.$fFoldableURec1_$cfoldMap
  = \ (@ m_a6KVj)
      (@ a_a6KVk)
      ($dMonoid_a6KVm :: Monoid m_a6KVj)
      _ [Occ=Dead]
      (ds_d6M22 :: URec Float a_a6KVk) ->
      case ds_d6M22
           `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_a6KVk>_N
                   :: (URec Float a_a6KVk :: *)
                      ~R# (GHC.Generics.R:UReckFloatp * a_a6KVk :: *))
      of
      { UFloat a1_a6Kpe ->
      mempty @ m_a6KVj $dMonoid_a6KVm
      }

-- RHS size: {terms: 6, types: 12, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec0_$cnull
  :: forall a. URec Int a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KU4) (ds_d6M1Z [Occ=Once] :: URec Int a_a6KU4) ->
                 case ds_d6M1Z
                      `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_a6KU4>_N
                              :: (URec Int a_a6KU4 :: *)
                                 ~R# (GHC.Generics.R:UReckIntp * a_a6KU4 :: *))
                 of
                 { UInt _ [Occ=Dead] ->
                 GHC.Types.True
                 }}]
Data.Foldable.$fFoldableURec0_$cnull
  = \ (@ a_a6KU4) (ds_d6M1Z :: URec Int a_a6KU4) ->
      case ds_d6M1Z
           `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_a6KU4>_N
                   :: (URec Int a_a6KU4 :: *)
                      ~R# (GHC.Generics.R:UReckIntp * a_a6KU4 :: *))
      of
      { UInt a1_a6Kp9 ->
      GHC.Types.True
      }

-- RHS size: {terms: 9, types: 18, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec0_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> URec Int a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KT4)
                 (@ b_a6KT5)
                 _ [Occ=Dead]
                 (z_a6Kp5 [Occ=Once] :: b_a6KT5)
                 (ds_d6M1W [Occ=Once] :: URec Int a_a6KT4) ->
                 case ds_d6M1W
                      `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_a6KT4>_N
                              :: (URec Int a_a6KT4 :: *)
                                 ~R# (GHC.Generics.R:UReckIntp * a_a6KT4 :: *))
                 of
                 { UInt _ [Occ=Dead] ->
                 z_a6Kp5
                 }}]
Data.Foldable.$fFoldableURec0_$cfoldr
  = \ (@ a_a6KT4)
      (@ b_a6KT5)
      _ [Occ=Dead]
      (z_a6Kp5 :: b_a6KT5)
      (ds_d6M1W :: URec Int a_a6KT4) ->
      case ds_d6M1W
           `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_a6KT4>_N
                   :: (URec Int a_a6KT4 :: *)
                      ~R# (GHC.Generics.R:UReckIntp * a_a6KT4 :: *))
      of
      { UInt a1_a6Kp6 ->
      z_a6Kp5
      }

-- RHS size: {terms: 10, types: 19, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec0_$cfoldMap
  :: forall m a. Monoid m => (a -> m) -> URec Int a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_a6KSR)
                 (@ a_a6KSS)
                 ($dMonoid_a6KSU [Occ=Once] :: Monoid m_a6KSR)
                 _ [Occ=Dead]
                 (ds_d6M1T [Occ=Once] :: URec Int a_a6KSS) ->
                 case ds_d6M1T
                      `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_a6KSS>_N
                              :: (URec Int a_a6KSS :: *)
                                 ~R# (GHC.Generics.R:UReckIntp * a_a6KSS :: *))
                 of
                 { UInt _ [Occ=Dead] ->
                 mempty @ m_a6KSR $dMonoid_a6KSU
                 }}]
Data.Foldable.$fFoldableURec0_$cfoldMap
  = \ (@ m_a6KSR)
      (@ a_a6KSS)
      ($dMonoid_a6KSU :: Monoid m_a6KSR)
      _ [Occ=Dead]
      (ds_d6M1T :: URec Int a_a6KSS) ->
      case ds_d6M1T
           `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_a6KSS>_N
                   :: (URec Int a_a6KSS :: *)
                      ~R# (GHC.Generics.R:UReckIntp * a_a6KSS :: *))
      of
      { UInt a1_a6Kp8 ->
      mempty @ m_a6KSR $dMonoid_a6KSU
      }

-- RHS size: {terms: 6, types: 12, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec_$cnull
  :: forall a. URec Word a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KRC) (ds_d6M1Q [Occ=Once] :: URec Word a_a6KRC) ->
                 case ds_d6M1Q
                      `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_a6KRC>_N
                              :: (URec Word a_a6KRC :: *)
                                 ~R# (GHC.Generics.R:UReckWordp * a_a6KRC :: *))
                 of
                 { UWord _ [Occ=Dead] ->
                 GHC.Types.True
                 }}]
Data.Foldable.$fFoldableURec_$cnull
  = \ (@ a_a6KRC) (ds_d6M1Q :: URec Word a_a6KRC) ->
      case ds_d6M1Q
           `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_a6KRC>_N
                   :: (URec Word a_a6KRC :: *)
                      ~R# (GHC.Generics.R:UReckWordp * a_a6KRC :: *))
      of
      { UWord a1_a6Kp3 ->
      GHC.Types.True
      }

-- RHS size: {terms: 9, types: 18, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec_$cfoldr
  :: forall a b. (a -> b -> b) -> b -> URec Word a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KQC)
                 (@ b_a6KQD)
                 _ [Occ=Dead]
                 (z_a6KoZ [Occ=Once] :: b_a6KQD)
                 (ds_d6M1N [Occ=Once] :: URec Word a_a6KQC) ->
                 case ds_d6M1N
                      `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_a6KQC>_N
                              :: (URec Word a_a6KQC :: *)
                                 ~R# (GHC.Generics.R:UReckWordp * a_a6KQC :: *))
                 of
                 { UWord _ [Occ=Dead] ->
                 z_a6KoZ
                 }}]
Data.Foldable.$fFoldableURec_$cfoldr
  = \ (@ a_a6KQC)
      (@ b_a6KQD)
      _ [Occ=Dead]
      (z_a6KoZ :: b_a6KQD)
      (ds_d6M1N :: URec Word a_a6KQC) ->
      case ds_d6M1N
           `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_a6KQC>_N
                   :: (URec Word a_a6KQC :: *)
                      ~R# (GHC.Generics.R:UReckWordp * a_a6KQC :: *))
      of
      { UWord a1_a6Kp0 ->
      z_a6KoZ
      }

-- RHS size: {terms: 10, types: 19, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec_$cfoldMap
  :: forall m a. Monoid m => (a -> m) -> URec Word a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_a6KQp)
                 (@ a_a6KQq)
                 ($dMonoid_a6KQs [Occ=Once] :: Monoid m_a6KQp)
                 _ [Occ=Dead]
                 (ds_d6M1K [Occ=Once] :: URec Word a_a6KQq) ->
                 case ds_d6M1K
                      `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_a6KQq>_N
                              :: (URec Word a_a6KQq :: *)
                                 ~R# (GHC.Generics.R:UReckWordp * a_a6KQq :: *))
                 of
                 { UWord _ [Occ=Dead] ->
                 mempty @ m_a6KQp $dMonoid_a6KQs
                 }}]
Data.Foldable.$fFoldableURec_$cfoldMap
  = \ (@ m_a6KQp)
      (@ a_a6KQq)
      ($dMonoid_a6KQs :: Monoid m_a6KQp)
      _ [Occ=Dead]
      (ds_d6M1K :: URec Word a_a6KQq) ->
      case ds_d6M1K
           `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_a6KQq>_N
                   :: (URec Word a_a6KQq :: *)
                      ~R# (GHC.Generics.R:UReckWordp * a_a6KQq :: *))
      of
      { UWord a1_a6Kp2 ->
      mempty @ m_a6KQp $dMonoid_a6KQs
      }

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:*:1 :: forall a. a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6KPT) (v_B1 [Occ=Once] :: a_a6KPT) -> v_B1}]
Data.Foldable.$fFoldable:*:1
  = \ (@ a_a6KPT) (v_B1 :: a_a6KPT) -> v_B1

-- RHS size: {terms: 9, types: 16, coercions: 5, joins: 0/0}
$dmproduct1_r6OSR
  :: forall (t :: * -> *).
     Foldable t =>
     forall a. Num a => t a -> Product a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []]
$dmproduct1_r6OSR
  = \ (@ (t_a6K72 :: * -> *))
      ($dFoldable_a6KK4 :: Foldable t_a6K72)
      (@ a_a6KPT)
      ($dNum_a6KPV :: Num a_a6KPT) ->
      foldMap
        @ t_a6K72
        $dFoldable_a6KK4
        @ (Product a_a6KPT)
        @ a_a6KPT
        (Data.Semigroup.Internal.$fMonoidProduct @ a_a6KPT $dNum_a6KPV)
        ((Data.Foldable.$fFoldable:*:1 @ a_a6KPT)
         `cast` (<a_a6KPT>_R
                 ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_a6KPT>_R)
                 :: (a_a6KPT -> a_a6KPT :: *)
                    ~R# (a_a6KPT -> Product a_a6KPT :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 19, joins: 0/0}
Data.Foldable.$dmproduct
  :: forall (t :: * -> *). Foldable t => forall a. Num a => t a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= (\ (@ (t_X6Kib :: * -> *))
                  ($dFoldable_X6KVe [Occ=Once] :: Foldable t_X6Kib)
                  (@ a_X6L14)
                  ($dNum_X6L17 [Occ=Once] :: Num a_X6L14) ->
                  foldMap
                    @ t_X6Kib
                    $dFoldable_X6KVe
                    @ (Product a_X6L14)
                    @ a_X6L14
                    (Data.Semigroup.Internal.$fMonoidProduct @ a_X6L14 $dNum_X6L17)
                    ((\ (v_B1 [Occ=Once] :: a_X6L14) -> v_B1)
                     `cast` (<a_X6L14>_R
                             ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_X6L14>_R)
                             :: (a_X6L14 -> a_X6L14 :: *)
                                ~R# (a_X6L14 -> Product a_X6L14 :: *))))
               `cast` (forall (t :: <* -> *>_N).
                       <Foldable t>_R
                       ->_R forall (a :: <*>_N).
                            <Num a>_R
                            ->_R <t a>_R
                            ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
                       :: (forall (t :: * -> *).
                           Foldable t =>
                           forall a. Num a => t a -> Product a :: *)
                          ~R# (forall (t :: * -> *).
                               Foldable t =>
                               forall a. Num a => t a -> a :: *))}]
Data.Foldable.$dmproduct
  = $dmproduct1_r6OSR
    `cast` (forall (t :: <* -> *>_N).
            <Foldable t>_R
            ->_R forall (a :: <*>_N).
                 <Num a>_R
                 ->_R <t a>_R
                 ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
            :: (forall (t :: * -> *).
                Foldable t =>
                forall a. Num a => t a -> Product a :: *)
               ~R# (forall (t :: * -> *).
                    Foldable t =>
                    forall a. Num a => t a -> a :: *))

-- RHS size: {terms: 9, types: 16, coercions: 5, joins: 0/0}
$dmsum1_r6OSS
  :: forall (t :: * -> *).
     Foldable t =>
     forall a. Num a => t a -> Sum a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []]
$dmsum1_r6OSS
  = \ (@ (t_X6Kic :: * -> *))
      ($dFoldable_X6KVf :: Foldable t_X6Kic)
      (@ a_a6KPz)
      ($dNum_a6KPB :: Num a_a6KPz) ->
      foldMap
        @ t_X6Kic
        $dFoldable_X6KVf
        @ (Sum a_a6KPz)
        @ a_a6KPz
        (Data.Semigroup.Internal.$fMonoidSum @ a_a6KPz $dNum_a6KPB)
        ((Data.Foldable.$fFoldable:*:1 @ a_a6KPz)
         `cast` (<a_a6KPz>_R
                 ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6KPz>_R)
                 :: (a_a6KPz -> a_a6KPz :: *) ~R# (a_a6KPz -> Sum a_a6KPz :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 19, joins: 0/0}
Data.Foldable.$dmsum
  :: forall (t :: * -> *). Foldable t => forall a. Num a => t a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= (\ (@ (t_X6Kih :: * -> *))
                  ($dFoldable_X6KVk [Occ=Once] :: Foldable t_X6Kih)
                  (@ a_X6L0Q)
                  ($dNum_X6L0T [Occ=Once] :: Num a_X6L0Q) ->
                  foldMap
                    @ t_X6Kih
                    $dFoldable_X6KVk
                    @ (Sum a_X6L0Q)
                    @ a_X6L0Q
                    (Data.Semigroup.Internal.$fMonoidSum @ a_X6L0Q $dNum_X6L0T)
                    ((\ (v_B1 [Occ=Once] :: a_X6L0Q) -> v_B1)
                     `cast` (<a_X6L0Q>_R
                             ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_X6L0Q>_R)
                             :: (a_X6L0Q -> a_X6L0Q :: *) ~R# (a_X6L0Q -> Sum a_X6L0Q :: *))))
               `cast` (forall (t :: <* -> *>_N).
                       <Foldable t>_R
                       ->_R forall (a :: <*>_N).
                            <Num a>_R ->_R <t a>_R ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
                       :: (forall (t :: * -> *).
                           Foldable t =>
                           forall a. Num a => t a -> Sum a :: *)
                          ~R# (forall (t :: * -> *).
                               Foldable t =>
                               forall a. Num a => t a -> a :: *))}]
Data.Foldable.$dmsum
  = $dmsum1_r6OSS
    `cast` (forall (t :: <* -> *>_N).
            <Foldable t>_R
            ->_R forall (a :: <*>_N).
                 <Num a>_R ->_R <t a>_R ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
            :: (forall (t :: * -> *).
                Foldable t =>
                forall a. Num a => t a -> Sum a :: *)
               ~R# (forall (t :: * -> *).
                    Foldable t =>
                    forall a. Num a => t a -> a :: *))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 0}]
Data.Foldable.$fFoldableK3 = "minimum: empty structure"#

-- RHS size: {terms: 4, types: 4, coercions: 0, joins: 0/0}
poly_d_r6OST :: forall a. a
[GblId, Str=x]
poly_d_r6OST
  = \ (@ a_a6KOY) ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6KOY (unpackCString# Data.Foldable.$fFoldableK3)

-- RHS size: {terms: 18, types: 26, coercions: 7, joins: 0/1}
Data.Foldable.$dmminimum
  :: forall (t :: * -> *). Foldable t => forall a. Ord a => t a -> a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_X6Kii :: * -> *))
                 ($dFoldable_X6KVl [Occ=Once] :: Foldable t_X6Kii)
                 (@ a_a6KOY)
                 ($dOrd_a6KP0 [Occ=Once] :: Ord a_a6KOY) ->
                 let {
                   d_i6M0T [Occ=OnceL] :: a_a6KOY
                   [LclId, Str=x]
                   d_i6M0T
                     = errorWithoutStackTrace
                         @ 'LiftedRep
                         @ a_a6KOY
                         (build
                            @ Char
                            (\ (@ b_i6HH2) ->
                               unpackFoldrCString# @ b_i6HH2 "minimum: empty structure"#)) } in
                 let {
                   g_X6HLL [Occ=OnceL!] :: t_X6Kii a_a6KOY -> Min a_a6KOY
                   [LclId]
                   g_X6HLL
                     = foldMap
                         @ t_X6Kii
                         $dFoldable_X6KVl
                         @ (Min a_a6KOY)
                         @ a_a6KOY
                         (Data.Functor.Utils.$fMonoidMin @ a_a6KOY $dOrd_a6KP0)
                         ((GHC.Base.Just @ a_a6KOY)
                          `cast` (<a_a6KOY>_R
                                  ->_R Sym (Data.Functor.Utils.N:Min[0]) <a_a6KOY>_N
                                  :: (a_a6KOY -> Maybe a_a6KOY :: *)
                                     ~R# (a_a6KOY -> Min a_a6KOY :: *))) } in
                 \ (x_X6HLQ [Occ=Once] :: t_X6Kii a_a6KOY) ->
                   case (g_X6HLL x_X6HLQ)
                        `cast` (Data.Functor.Utils.N:Min[0] <a_a6KOY>_N
                                :: (Min a_a6KOY :: *) ~R# (Maybe a_a6KOY :: *))
                   of {
                     Nothing -> d_i6M0T;
                     Just v_i6M0Z [Occ=Once] -> v_i6M0Z
                   }}]
Data.Foldable.$dmminimum
  = \ (@ (t_X6Kii :: * -> *))
      ($dFoldable_X6KVl :: Foldable t_X6Kii)
      (@ a_a6KOY)
      ($dOrd_a6KP0 :: Ord a_a6KOY) ->
      let {
        g_s6MKK [Dmd=<L,C(U)>] :: t_X6Kii a_a6KOY -> Min a_a6KOY
        [LclId]
        g_s6MKK
          = foldMap
              @ t_X6Kii
              $dFoldable_X6KVl
              @ (Min a_a6KOY)
              @ a_a6KOY
              (Data.Functor.Utils.$fMonoidMin @ a_a6KOY $dOrd_a6KP0)
              ((GHC.Base.Just @ a_a6KOY)
               `cast` (<a_a6KOY>_R
                       ->_R Sym (Data.Functor.Utils.N:Min[0]) <a_a6KOY>_N
                       :: (a_a6KOY -> Maybe a_a6KOY :: *)
                          ~R# (a_a6KOY -> Min a_a6KOY :: *))) } in
      \ (x_X6HLQ :: t_X6Kii a_a6KOY) ->
        case (g_s6MKK x_X6HLQ)
             `cast` (Data.Functor.Utils.N:Min[0] <a_a6KOY>_N
                     :: (Min a_a6KOY :: *) ~R# (Maybe a_a6KOY :: *))
        of {
          Nothing -> poly_d_r6OST @ a_a6KOY;
          Just v_i6M0Z -> v_i6M0Z
        }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK5 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 0}]
Data.Foldable.$fFoldableK5 = "maximum: empty structure"#

-- RHS size: {terms: 4, types: 4, coercions: 0, joins: 0/0}
poly_d1_r6OSU :: forall a. a
[GblId, Str=x]
poly_d1_r6OSU
  = \ (@ a_a6KOn) ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6KOn (unpackCString# Data.Foldable.$fFoldableK5)

-- RHS size: {terms: 18, types: 26, coercions: 7, joins: 0/1}
Data.Foldable.$dmmaximum
  :: forall (t :: * -> *). Foldable t => forall a. Ord a => t a -> a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_X6Kij :: * -> *))
                 ($dFoldable_X6KVm [Occ=Once] :: Foldable t_X6Kij)
                 (@ a_a6KOn)
                 ($dOrd_a6KOp [Occ=Once] :: Ord a_a6KOn) ->
                 let {
                   d_i6M0T [Occ=OnceL] :: a_a6KOn
                   [LclId, Str=x]
                   d_i6M0T
                     = errorWithoutStackTrace
                         @ 'LiftedRep
                         @ a_a6KOn
                         (build
                            @ Char
                            (\ (@ b_i6HH2) ->
                               unpackFoldrCString# @ b_i6HH2 "maximum: empty structure"#)) } in
                 let {
                   g_X6HLM [Occ=OnceL!] :: t_X6Kij a_a6KOn -> Max a_a6KOn
                   [LclId]
                   g_X6HLM
                     = foldMap
                         @ t_X6Kij
                         $dFoldable_X6KVm
                         @ (Max a_a6KOn)
                         @ a_a6KOn
                         (Data.Functor.Utils.$fMonoidMax @ a_a6KOn $dOrd_a6KOp)
                         ((GHC.Base.Just @ a_a6KOn)
                          `cast` (<a_a6KOn>_R
                                  ->_R Sym (Data.Functor.Utils.N:Max[0]) <a_a6KOn>_N
                                  :: (a_a6KOn -> Maybe a_a6KOn :: *)
                                     ~R# (a_a6KOn -> Max a_a6KOn :: *))) } in
                 \ (x_X6HLR [Occ=Once] :: t_X6Kij a_a6KOn) ->
                   case (g_X6HLM x_X6HLR)
                        `cast` (Data.Functor.Utils.N:Max[0] <a_a6KOn>_N
                                :: (Max a_a6KOn :: *) ~R# (Maybe a_a6KOn :: *))
                   of {
                     Nothing -> d_i6M0T;
                     Just v_i6M0Z [Occ=Once] -> v_i6M0Z
                   }}]
Data.Foldable.$dmmaximum
  = \ (@ (t_X6Kij :: * -> *))
      ($dFoldable_X6KVm :: Foldable t_X6Kij)
      (@ a_a6KOn)
      ($dOrd_a6KOp :: Ord a_a6KOn) ->
      let {
        g_s6MKG [Dmd=<L,C(U)>] :: t_X6Kij a_a6KOn -> Max a_a6KOn
        [LclId]
        g_s6MKG
          = foldMap
              @ t_X6Kij
              $dFoldable_X6KVm
              @ (Max a_a6KOn)
              @ a_a6KOn
              (Data.Functor.Utils.$fMonoidMax @ a_a6KOn $dOrd_a6KOp)
              ((GHC.Base.Just @ a_a6KOn)
               `cast` (<a_a6KOn>_R
                       ->_R Sym (Data.Functor.Utils.N:Max[0]) <a_a6KOn>_N
                       :: (a_a6KOn -> Maybe a_a6KOn :: *)
                          ~R# (a_a6KOn -> Max a_a6KOn :: *))) } in
      \ (x_X6HLR :: t_X6Kij a_a6KOn) ->
        case (g_s6MKG x_X6HLR)
             `cast` (Data.Functor.Utils.N:Max[0] <a_a6KOn>_N
                     :: (Max a_a6KOn :: *) ~R# (Maybe a_a6KOn :: *))
        of {
          Nothing -> poly_d1_r6OSU @ a_a6KOn;
          Just v_i6M0Z -> v_i6M0Z
        }

-- RHS size: {terms: 10, types: 6, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:*:5 :: forall a. Int -> a -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KNU) (c_a6K7Y [Occ=Once!] :: Int) _ [Occ=Dead] ->
                 case c_a6K7Y of { I# x_i6Me0 [Occ=Once] ->
                 GHC.Types.I# (+# x_i6Me0 1#)
                 }}]
Data.Foldable.$fFoldable:*:5
  = \ (@ a_a6KNU) (c_a6K7Y :: Int) _ [Occ=Dead] ->
      case c_a6K7Y of { I# x_i6Me0 -> GHC.Types.I# (+# x_i6Me0 1#) }

-- RHS size: {terms: 7, types: 12, coercions: 0, joins: 0/0}
Data.Foldable.$dmlength
  :: forall (t :: * -> *). Foldable t => forall a. t a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(S))LLLLLLLLLL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_X6Kik :: * -> *))
                 ($dFoldable_X6KVn [Occ=Once] :: Foldable t_X6Kik)
                 (@ a_a6KNU) ->
                 foldl'
                   @ t_X6Kik
                   $dFoldable_X6KVn
                   @ Int
                   @ a_a6KNU
                   (\ (c_a6K7Y [Occ=Once!] :: Int) _ [Occ=Dead] ->
                      case c_a6K7Y of { I# x_i6Me0 [Occ=Once] ->
                      GHC.Types.I# (+# x_i6Me0 1#)
                      })
                   (GHC.Types.I# 0#)}]
Data.Foldable.$dmlength
  = \ (@ (t_X6Kik :: * -> *))
      ($dFoldable_X6KVn :: Foldable t_X6Kik)
      (@ a_a6KNU) ->
      foldl'
        @ t_X6Kik
        $dFoldable_X6KVn
        @ Int
        @ a_a6KNU
        (Data.Foldable.$fFoldable:*:5 @ a_a6KNU)
        Data.Foldable.$fFoldable:*:4

-- RHS size: {terms: 4, types: 4, coercions: 0, joins: 0/0}
lvl_r6OSV :: forall a. a -> Bool -> Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []]
lvl_r6OSV
  = \ (@ a_a6KNL) _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False

-- RHS size: {terms: 7, types: 12, coercions: 0, joins: 0/0}
Data.Foldable.$dmnull
  :: forall (t :: * -> *). Foldable t => forall a. t a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_X6Kil :: * -> *))
                 ($dFoldable_X6KVo [Occ=Once] :: Foldable t_X6Kil)
                 (@ a_a6KNL) ->
                 foldr
                   @ t_X6Kil
                   $dFoldable_X6KVo
                   @ a_a6KNL
                   @ Bool
                   (\ _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False)
                   GHC.Types.True}]
Data.Foldable.$dmnull
  = \ (@ (t_X6Kil :: * -> *))
      ($dFoldable_X6KVo :: Foldable t_X6Kil)
      (@ a_a6KNL) ->
      foldr
        @ t_X6Kil
        $dFoldable_X6KVo
        @ a_a6KNL
        @ Bool
        (lvl_r6OSV @ a_a6KNL)
        GHC.Types.True

-- RHS size: {terms: 9, types: 16, coercions: 0, joins: 0/0}
Data.Foldable.$dmtoList [InlPrag=INLINE (sat-args=1)]
  :: forall (t :: * -> *). Foldable t => forall a. t a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_X6Kim :: * -> *))
                 ($dFoldable_X6KVp [Occ=Once] :: Foldable t_X6Kim)
                 (@ a_a6KNx)
                 (t1_a6K7V [Occ=Once] :: t_X6Kim a_a6KNx) ->
                 build
                   @ a_a6KNx
                   (\ (@ b_a6KNB)
                      (c_a6K7W [Occ=Once, OS=OneShot] :: a_a6KNx -> b_a6KNB -> b_a6KNB)
                      (n_a6K7X [Occ=Once, OS=OneShot] :: b_a6KNB) ->
                      foldr
                        @ t_X6Kim
                        $dFoldable_X6KVp
                        @ a_a6KNx
                        @ b_a6KNB
                        c_a6K7W
                        n_a6K7X
                        t1_a6K7V)}]
Data.Foldable.$dmtoList
  = \ (@ (t_X6Kim :: * -> *))
      ($dFoldable_X6KVp :: Foldable t_X6Kim)
      (@ a_a6KNx)
      (t1_a6K7V :: t_X6Kim a_a6KNx) ->
      foldr
        @ t_X6Kim
        $dFoldable_X6KVp
        @ a_a6KNx
        @ [a_a6KNx]
        (GHC.Types.: @ a_a6KNx)
        (GHC.Types.[] @ a_a6KNx)
        t1_a6K7V

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK7 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 0}]
Data.Foldable.$fFoldableK7 = "foldl1: empty structure"#

-- RHS size: {terms: 4, types: 4, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:*:6 :: forall a. a
[GblId, Str=x]
Data.Foldable.$fFoldable:*:6
  = \ (@ a_a6KN3) ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6KN3 (unpackCString# Data.Foldable.$fFoldableK7)

-- RHS size: {terms: 25, types: 29, coercions: 0, joins: 0/0}
Data.Foldable.$dmfoldl1
  :: forall (t :: * -> *).
     Foldable t =>
     forall a. (a -> a -> a) -> t a -> a
[GblId,
 Arity=3,
 Str=<S(LLLLC(C(C(S)))LLLLLLLLLLL),1*U(A,A,A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_X6Kin :: * -> *))
                 ($dFoldable_X6KVq [Occ=Once] :: Foldable t_X6Kin)
                 (@ a_a6KN3)
                 (f_a6K7P [Occ=OnceL!] :: a_a6KN3 -> a_a6KN3 -> a_a6KN3)
                 (xs_a6K7Q [Occ=Once] :: t_X6Kin a_a6KN3) ->
                 case foldl
                        @ t_X6Kin
                        $dFoldable_X6KVq
                        @ (Maybe a_a6KN3)
                        @ a_a6KN3
                        (\ (m_a6K7S [Occ=Once!] :: Maybe a_a6KN3)
                           (y_a6K7T [Occ=Once*] :: a_a6KN3) ->
                           GHC.Base.Just
                             @ a_a6KN3
                             (case m_a6K7S of {
                                Nothing -> y_a6K7T;
                                Just x_a6K7U [Occ=Once] -> f_a6K7P x_a6K7U y_a6K7T
                              }))
                        (GHC.Base.Nothing @ a_a6KN3)
                        xs_a6K7Q
                 of {
                   Nothing ->
                     errorWithoutStackTrace
                       @ 'LiftedRep
                       @ a_a6KN3
                       (build
                          @ Char
                          (\ (@ b_i6HH2) ->
                             unpackFoldrCString# @ b_i6HH2 "foldl1: empty structure"#));
                   Just v_i6M0Z [Occ=Once] -> v_i6M0Z
                 }}]
Data.Foldable.$dmfoldl1
  = \ (@ (t_X6Kin :: * -> *))
      ($dFoldable_X6KVq :: Foldable t_X6Kin)
      (@ a_a6KN3)
      (f_a6K7P :: a_a6KN3 -> a_a6KN3 -> a_a6KN3)
      (xs_a6K7Q :: t_X6Kin a_a6KN3) ->
      case foldl
             @ t_X6Kin
             $dFoldable_X6KVq
             @ (Maybe a_a6KN3)
             @ a_a6KN3
             (\ (m_a6K7S :: Maybe a_a6KN3) (y_a6K7T :: a_a6KN3) ->
                GHC.Base.Just
                  @ a_a6KN3
                  (case m_a6K7S of {
                     Nothing -> y_a6K7T;
                     Just x_a6K7U -> f_a6K7P x_a6K7U y_a6K7T
                   }))
             (GHC.Base.Nothing @ a_a6KN3)
             xs_a6K7Q
      of {
        Nothing -> Data.Foldable.$fFoldable:*:6 @ a_a6KN3;
        Just v_i6M0Z -> v_i6M0Z
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK9 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 0}]
Data.Foldable.$fFoldableK9 = "foldr1: empty structure"#

-- RHS size: {terms: 4, types: 4, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:*:8 :: forall a. a
[GblId, Str=x]
Data.Foldable.$fFoldable:*:8
  = \ (@ a_a6KMx) ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6KMx (unpackCString# Data.Foldable.$fFoldableK9)

-- RHS size: {terms: 25, types: 29, coercions: 0, joins: 0/0}
Data.Foldable.$dmfoldr1
  :: forall (t :: * -> *).
     Foldable t =>
     forall a. (a -> a -> a) -> t a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_X6Kio :: * -> *))
                 ($dFoldable_X6KVr [Occ=Once] :: Foldable t_X6Kio)
                 (@ a_a6KMx)
                 (f_a6K7J [Occ=OnceL!] :: a_a6KMx -> a_a6KMx -> a_a6KMx)
                 (xs_a6K7K [Occ=Once] :: t_X6Kio a_a6KMx) ->
                 case foldr
                        @ t_X6Kio
                        $dFoldable_X6KVr
                        @ a_a6KMx
                        @ (Maybe a_a6KMx)
                        (\ (x_a6K7M [Occ=Once*] :: a_a6KMx)
                           (m_a6K7N [Occ=Once!] :: Maybe a_a6KMx) ->
                           GHC.Base.Just
                             @ a_a6KMx
                             (case m_a6K7N of {
                                Nothing -> x_a6K7M;
                                Just y_a6K7O [Occ=Once] -> f_a6K7J x_a6K7M y_a6K7O
                              }))
                        (GHC.Base.Nothing @ a_a6KMx)
                        xs_a6K7K
                 of {
                   Nothing ->
                     errorWithoutStackTrace
                       @ 'LiftedRep
                       @ a_a6KMx
                       (build
                          @ Char
                          (\ (@ b_i6HH2) ->
                             unpackFoldrCString# @ b_i6HH2 "foldr1: empty structure"#));
                   Just v_i6M0Z [Occ=Once] -> v_i6M0Z
                 }}]
Data.Foldable.$dmfoldr1
  = \ (@ (t_X6Kio :: * -> *))
      ($dFoldable_X6KVr :: Foldable t_X6Kio)
      (@ a_a6KMx)
      (f_a6K7J :: a_a6KMx -> a_a6KMx -> a_a6KMx)
      (xs_a6K7K :: t_X6Kio a_a6KMx) ->
      case foldr
             @ t_X6Kio
             $dFoldable_X6KVr
             @ a_a6KMx
             @ (Maybe a_a6KMx)
             (\ (x_a6K7M :: a_a6KMx) (m_a6K7N :: Maybe a_a6KMx) ->
                GHC.Base.Just
                  @ a_a6KMx
                  (case m_a6K7N of {
                     Nothing -> x_a6K7M;
                     Just y_a6K7O -> f_a6K7J x_a6K7M y_a6K7O
                   }))
             (GHC.Base.Nothing @ a_a6KMx)
             xs_a6K7K
      of {
        Nothing -> Data.Foldable.$fFoldable:*:8 @ a_a6KMx;
        Just v_i6M0Z -> v_i6M0Z
      }

-- RHS size: {terms: 22, types: 26, coercions: 0, joins: 0/0}
Data.Foldable.$dmfoldl'
  :: forall (t :: * -> *).
     Foldable t =>
     forall b a. (b -> a -> b) -> b -> t a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_X6Kip :: * -> *))
                 ($dFoldable_X6KVs [Occ=Once] :: Foldable t_X6Kip)
                 (@ b_a6KLZ)
                 (@ a_a6KM0)
                 (f_a6K7C [Occ=OnceL!] :: b_a6KLZ -> a_a6KM0 -> b_a6KLZ)
                 (z0_a6K7D [Occ=Once] :: b_a6KLZ)
                 (xs_a6K7E [Occ=Once] :: t_X6Kip a_a6KM0) ->
                 foldr
                   @ t_X6Kip
                   $dFoldable_X6KVs
                   @ a_a6KM0
                   @ (b_a6KLZ -> b_a6KLZ)
                   (\ (x_a6K7G [Occ=Once] :: a_a6KM0)
                      (k_a6K7H [Occ=Once!] :: b_a6KLZ -> b_a6KLZ)
                      (z_a6K7I [Occ=Once] :: b_a6KLZ) ->
                      case f_a6K7C z_a6K7I x_a6K7G of vx_i6M0K { __DEFAULT ->
                      k_a6K7H vx_i6M0K
                      })
                   (id @ b_a6KLZ)
                   xs_a6K7E
                   z0_a6K7D}]
Data.Foldable.$dmfoldl'
  = \ (@ (t_X6Kip :: * -> *))
      ($dFoldable_X6KVs :: Foldable t_X6Kip)
      (@ b_a6KLZ)
      (@ a_a6KM0)
      (f_a6K7C :: b_a6KLZ -> a_a6KM0 -> b_a6KLZ)
      (z0_a6K7D :: b_a6KLZ)
      (xs_a6K7E :: t_X6Kip a_a6KM0) ->
      foldr
        @ t_X6Kip
        $dFoldable_X6KVs
        @ a_a6KM0
        @ (b_a6KLZ -> b_a6KLZ)
        (\ (x_a6K7G :: a_a6KM0)
           (k_a6K7H :: b_a6KLZ -> b_a6KLZ)
           (z_a6K7I :: b_a6KLZ) ->
           case f_a6K7C z_a6K7I x_a6K7G of vx_i6M0K { __DEFAULT ->
           k_a6K7H vx_i6M0K
           })
        (id @ b_a6KLZ)
        xs_a6K7E
        z0_a6K7D

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:*:7 :: forall b. Monoid (Dual (Endo b))
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Foldable.$fFoldable:*:7
  = \ (@ b_a6KLy) ->
      Data.Semigroup.Internal.$fMonoidDual
        @ (Endo b_a6KLy) (Data.Semigroup.Internal.$fMonoidEndo @ b_a6KLy)

-- RHS size: {terms: 17, types: 24, coercions: 9, joins: 0/0}
Data.Foldable.$dmfoldl
  :: forall (t :: * -> *).
     Foldable t =>
     forall b a. (b -> a -> b) -> b -> t a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_X6Kiq :: * -> *))
                 ($dFoldable_X6KVt [Occ=OnceL] :: Foldable t_X6Kiq)
                 (@ b_a6KLy)
                 (@ a_a6KLz) ->
                 let {
                   $dMonoid_a6KLJ [Occ=OnceL] :: Monoid (Dual (Endo b_a6KLy))
                   [LclId]
                   $dMonoid_a6KLJ
                     = Data.Semigroup.Internal.$fMonoidDual
                         @ (Endo b_a6KLy)
                         (Data.Semigroup.Internal.$fMonoidEndo @ b_a6KLy) } in
                 \ (f_a6K7z [Occ=OnceL!] :: b_a6KLy -> a_a6KLz -> b_a6KLy)
                   (z_a6K7A [Occ=Once] :: b_a6KLy)
                   (t1_a6K7B [Occ=Once] :: t_X6Kiq a_a6KLz) ->
                   ((foldMap
                       @ t_X6Kiq
                       $dFoldable_X6KVt
                       @ (Dual (Endo b_a6KLy))
                       @ a_a6KLz
                       $dMonoid_a6KLJ
                       ((\ (x_X6HLX [Occ=Once] :: a_a6KLz)
                           (y_i6M0a [Occ=Once] :: b_a6KLy) ->
                           f_a6K7z y_i6M0a x_X6HLX)
                        `cast` (<a_a6KLz>_R
                                ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                              (Data.Semigroup.Internal.N:Endo[0] <b_a6KLy>_R))
                                :: (a_a6KLz -> b_a6KLy -> b_a6KLy :: *)
                                   ~R# (a_a6KLz -> Dual (Endo b_a6KLy) :: *)))
                       t1_a6K7B)
                    `cast` (Data.Semigroup.Internal.N:Dual[0]
                                (Data.Semigroup.Internal.N:Endo[0] <b_a6KLy>_R)
                            :: (Dual (Endo b_a6KLy) :: *) ~R# (b_a6KLy -> b_a6KLy :: *)))
                     z_a6K7A}]
Data.Foldable.$dmfoldl
  = \ (@ (t_X6Kiq :: * -> *))
      ($dFoldable_X6KVt :: Foldable t_X6Kiq)
      (@ b_a6KLy)
      (@ a_a6KLz)
      (f_a6K7z :: b_a6KLy -> a_a6KLz -> b_a6KLy)
      (z_a6K7A :: b_a6KLy)
      (t1_a6K7B :: t_X6Kiq a_a6KLz) ->
      ((foldMap
          @ t_X6Kiq
          $dFoldable_X6KVt
          @ (Dual (Endo b_a6KLy))
          @ a_a6KLz
          (Data.Foldable.$fFoldable:*:7 @ b_a6KLy)
          ((\ (x_X6HLX :: a_a6KLz) (y_i6M0a :: b_a6KLy) ->
              f_a6K7z y_i6M0a x_X6HLX)
           `cast` (<a_a6KLz>_R
                   ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                 (Data.Semigroup.Internal.N:Endo[0] <b_a6KLy>_R))
                   :: (a_a6KLz -> b_a6KLy -> b_a6KLy :: *)
                      ~R# (a_a6KLz -> Dual (Endo b_a6KLy) :: *)))
          t1_a6K7B)
       `cast` (Data.Semigroup.Internal.N:Dual[0]
                   (Data.Semigroup.Internal.N:Endo[0] <b_a6KLy>_R)
               :: (Dual (Endo b_a6KLy) :: *) ~R# (b_a6KLy -> b_a6KLy :: *)))
        z_a6K7A

-- RHS size: {terms: 22, types: 26, coercions: 0, joins: 0/0}
Data.Foldable.$dmfoldr'
  :: forall (t :: * -> *).
     Foldable t =>
     forall a b. (a -> b -> b) -> b -> t a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLC(C(C(S)))LLLLLLLLLLL),1*U(A,A,A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_X6Kir :: * -> *))
                 ($dFoldable_X6KVu [Occ=Once] :: Foldable t_X6Kir)
                 (@ a_a6KKW)
                 (@ b_a6KKX)
                 (f_a6K7s [Occ=OnceL!] :: a_a6KKW -> b_a6KKX -> b_a6KKX)
                 (z0_a6K7t [Occ=Once] :: b_a6KKX)
                 (xs_a6K7u [Occ=Once] :: t_X6Kir a_a6KKW) ->
                 foldl
                   @ t_X6Kir
                   $dFoldable_X6KVu
                   @ (b_a6KKX -> b_a6KKX)
                   @ a_a6KKW
                   (\ (k_a6K7w [Occ=Once!] :: b_a6KKX -> b_a6KKX)
                      (x_a6K7x [Occ=Once] :: a_a6KKW)
                      (z_a6K7y [Occ=Once] :: b_a6KKX) ->
                      case f_a6K7s x_a6K7x z_a6K7y of vx_i6M0K { __DEFAULT ->
                      k_a6K7w vx_i6M0K
                      })
                   (id @ b_a6KKX)
                   xs_a6K7u
                   z0_a6K7t}]
Data.Foldable.$dmfoldr'
  = \ (@ (t_X6Kir :: * -> *))
      ($dFoldable_X6KVu :: Foldable t_X6Kir)
      (@ a_a6KKW)
      (@ b_a6KKX)
      (f_a6K7s :: a_a6KKW -> b_a6KKX -> b_a6KKX)
      (z0_a6K7t :: b_a6KKX)
      (xs_a6K7u :: t_X6Kir a_a6KKW) ->
      foldl
        @ t_X6Kir
        $dFoldable_X6KVu
        @ (b_a6KKX -> b_a6KKX)
        @ a_a6KKW
        (\ (k_a6K7w :: b_a6KKX -> b_a6KKX)
           (x_a6K7x :: a_a6KKW)
           (z_a6K7y :: b_a6KKX) ->
           case f_a6K7s x_a6K7x z_a6K7y of vx_i6M0K { __DEFAULT ->
           k_a6K7w vx_i6M0K
           })
        (id @ b_a6KKX)
        xs_a6K7u
        z0_a6K7t

-- RHS size: {terms: 6, types: 12, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableU1_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> U1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Lri)
                 (@ b_a6Lrj)
                 _ [Occ=Dead]
                 (z0_a6K7t [Occ=Once] :: b_a6Lrj)
                 _ [Occ=Dead] ->
                 z0_a6K7t}]
Data.Foldable.$fFoldableU1_$cfoldr'
  = \ (@ a_a6Lri)
      (@ b_a6Lrj)
      _ [Occ=Dead]
      (z0_a6K7t :: b_a6Lrj)
      _ [Occ=Dead] ->
      z0_a6K7t

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK4 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Foldable.$fFoldableK4
  = unpackCString# Data.Foldable.$fFoldableK5

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableU1_$cmaximum
  :: forall a. Ord a => U1 a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Lsl) _ [Occ=Dead] _ [Occ=Dead] ->
                 errorWithoutStackTrace
                   @ 'LiftedRep @ a_a6Lsl Data.Foldable.$fFoldableK4}]
Data.Foldable.$fFoldableU1_$cmaximum
  = \ (@ a_a6Lsl) _ [Occ=Dead] _ [Occ=Dead] ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6Lsl Data.Foldable.$fFoldableK4

-- RHS size: {terms: 6, types: 12, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableU1_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> U1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_a6Lry)
                 (@ a_a6Lrz)
                 _ [Occ=Dead]
                 (z0_a6K7D [Occ=Once] :: b_a6Lry)
                 _ [Occ=Dead] ->
                 z0_a6K7D}]
Data.Foldable.$fFoldableU1_$cfoldl'
  = \ (@ b_a6Lry)
      (@ a_a6Lrz)
      _ [Occ=Dead]
      (z0_a6K7D :: b_a6Lry)
      _ [Occ=Dead] ->
      z0_a6K7D

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Foldable.$fFoldableK2
  = unpackCString# Data.Foldable.$fFoldableK3

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableU1_$cminimum
  :: forall a. Ord a => U1 a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Lsv) _ [Occ=Dead] _ [Occ=Dead] ->
                 errorWithoutStackTrace
                   @ 'LiftedRep @ a_a6Lsv Data.Foldable.$fFoldableK2}]
Data.Foldable.$fFoldableU1_$cminimum
  = \ (@ a_a6Lsv) _ [Occ=Dead] _ [Occ=Dead] ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6Lsv Data.Foldable.$fFoldableK2

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableU1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. U1 a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a6LrW) _ [Occ=Dead] ->
                 build
                   @ a_a6LrW
                   (\ (@ b_a6KNB)
                      _ [Occ=Dead, OS=OneShot]
                      (n_a6K7X [Occ=Once, OS=OneShot] :: b_a6KNB) ->
                      n_a6K7X)}]
Data.Foldable.$fFoldableU1_$ctoList
  = \ (@ a_a6LrW) _ [Occ=Dead] -> GHC.Types.[] @ a_a6LrW

-- RHS size: {terms: 17, types: 3, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableU1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable U1
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: U1
                                Data.Foldable.$fFoldableU1_$cfold
                                Data.Foldable.$fFoldableU1_$cfoldMap
                                Data.Foldable.$fFoldableU1_$cfoldr
                                Data.Foldable.$fFoldableU1_$cfoldr'
                                Data.Foldable.$fFoldableU1_$cfoldl
                                Data.Foldable.$fFoldableU1_$cfoldl'
                                Data.Foldable.$fFoldableU1_$cfoldr1
                                Data.Foldable.$fFoldableU1_$cfoldl1
                                Data.Foldable.$fFoldableU1_$ctoList
                                Data.Foldable.$fFoldableU1_$cnull
                                Data.Foldable.$fFoldableU1_$clength
                                Data.Foldable.$fFoldableU1_$celem
                                Data.Foldable.$fFoldableU1_$cmaximum
                                Data.Foldable.$fFoldableU1_$cminimum
                                Data.Foldable.$fFoldableU1_$csum
                                Data.Foldable.$fFoldableU1_$cproduct]
Data.Foldable.$fFoldableU1
  = Data.Foldable.C:Foldable
      @ U1
      Data.Foldable.$fFoldableU1_$cfold
      Data.Foldable.$fFoldableU1_$cfoldMap
      Data.Foldable.$fFoldableU1_$cfoldr
      Data.Foldable.$fFoldableU1_$cfoldr'
      Data.Foldable.$fFoldableU1_$cfoldl
      Data.Foldable.$fFoldableU1_$cfoldl'
      Data.Foldable.$fFoldableU1_$cfoldr1
      Data.Foldable.$fFoldableU1_$cfoldl1
      Data.Foldable.$fFoldableU1_$ctoList
      Data.Foldable.$fFoldableU1_$cnull
      Data.Foldable.$fFoldableU1_$clength
      Data.Foldable.$fFoldableU1_$celem
      Data.Foldable.$fFoldableU1_$cmaximum
      Data.Foldable.$fFoldableU1_$cminimum
      Data.Foldable.$fFoldableU1_$csum
      Data.Foldable.$fFoldableU1_$cproduct

-- RHS size: {terms: 6, types: 12, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Proxy a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LF6)
                 (@ b_a6LF7)
                 _ [Occ=Dead]
                 (z0_a6K7t [Occ=Once] :: b_a6LF7)
                 _ [Occ=Dead] ->
                 z0_a6K7t}]
Data.Foldable.$fFoldableProxy_$cfoldr'
  = \ (@ a_a6LF6)
      (@ b_a6LF7)
      _ [Occ=Dead]
      (z0_a6K7t :: b_a6LF7)
      _ [Occ=Dead] ->
      z0_a6K7t

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy_$cmaximum
  :: forall a. Ord a => Proxy a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LG9) _ [Occ=Dead] _ [Occ=Dead] ->
                 errorWithoutStackTrace
                   @ 'LiftedRep @ a_a6LG9 Data.Foldable.$fFoldableK4}]
Data.Foldable.$fFoldableProxy_$cmaximum
  = \ (@ a_a6LG9) _ [Occ=Dead] _ [Occ=Dead] ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6LG9 Data.Foldable.$fFoldableK4

-- RHS size: {terms: 6, types: 12, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> Proxy a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_a6LFm)
                 (@ a_a6LFn)
                 _ [Occ=Dead]
                 (z0_a6K7D [Occ=Once] :: b_a6LFm)
                 _ [Occ=Dead] ->
                 z0_a6K7D}]
Data.Foldable.$fFoldableProxy_$cfoldl'
  = \ (@ b_a6LFm)
      (@ a_a6LFn)
      _ [Occ=Dead]
      (z0_a6K7D :: b_a6LFm)
      _ [Occ=Dead] ->
      z0_a6K7D

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy_$cminimum
  :: forall a. Ord a => Proxy a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LGj) _ [Occ=Dead] _ [Occ=Dead] ->
                 errorWithoutStackTrace
                   @ 'LiftedRep @ a_a6LGj Data.Foldable.$fFoldableK2}]
Data.Foldable.$fFoldableProxy_$cminimum
  = \ (@ a_a6LGj) _ [Occ=Dead] _ [Occ=Dead] ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6LGj Data.Foldable.$fFoldableK2

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Proxy a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a6LFK) _ [Occ=Dead] ->
                 build
                   @ a_a6LFK
                   (\ (@ b_a6KNB)
                      _ [Occ=Dead, OS=OneShot]
                      (n_a6K7X [Occ=Once, OS=OneShot] :: b_a6KNB) ->
                      n_a6K7X)}]
Data.Foldable.$fFoldableProxy_$ctoList
  = \ (@ a_a6LFK) _ [Occ=Dead] -> GHC.Types.[] @ a_a6LFK

-- RHS size: {terms: 17, types: 3, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableProxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable Proxy
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: Proxy
                                Data.Foldable.$fFoldableProxy_$cfold
                                Data.Foldable.$fFoldableProxy_$cfoldMap
                                Data.Foldable.$fFoldableProxy_$cfoldr
                                Data.Foldable.$fFoldableProxy_$cfoldr'
                                Data.Foldable.$fFoldableProxy_$cfoldl
                                Data.Foldable.$fFoldableProxy_$cfoldl'
                                Data.Foldable.$fFoldableProxy_$cfoldr1
                                Data.Foldable.$fFoldableProxy_$cfoldl1
                                Data.Foldable.$fFoldableProxy_$ctoList
                                Data.Foldable.$fFoldableProxy_$cnull
                                Data.Foldable.$fFoldableProxy_$clength
                                Data.Foldable.$fFoldableProxy_$celem
                                Data.Foldable.$fFoldableProxy_$cmaximum
                                Data.Foldable.$fFoldableProxy_$cminimum
                                Data.Foldable.$fFoldableProxy_$csum
                                Data.Foldable.$fFoldableProxy_$cproduct]
Data.Foldable.$fFoldableProxy
  = Data.Foldable.C:Foldable
      @ Proxy
      Data.Foldable.$fFoldableProxy_$cfold
      Data.Foldable.$fFoldableProxy_$cfoldMap
      Data.Foldable.$fFoldableProxy_$cfoldr
      Data.Foldable.$fFoldableProxy_$cfoldr'
      Data.Foldable.$fFoldableProxy_$cfoldl
      Data.Foldable.$fFoldableProxy_$cfoldl'
      Data.Foldable.$fFoldableProxy_$cfoldr1
      Data.Foldable.$fFoldableProxy_$cfoldl1
      Data.Foldable.$fFoldableProxy_$ctoList
      Data.Foldable.$fFoldableProxy_$cnull
      Data.Foldable.$fFoldableProxy_$clength
      Data.Foldable.$fFoldableProxy_$celem
      Data.Foldable.$fFoldableProxy_$cmaximum
      Data.Foldable.$fFoldableProxy_$cminimum
      Data.Foldable.$fFoldableProxy_$csum
      Data.Foldable.$fFoldableProxy_$cproduct

-- RHS size: {terms: 13, types: 21, coercions: 7, joins: 0/0}
Data.Foldable.$dmfoldr
  :: forall (t :: * -> *).
     Foldable t =>
     forall a b. (a -> b -> b) -> b -> t a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_X6KiE :: * -> *))
                 ($dFoldable_X6KVH [Occ=Once] :: Foldable t_X6KiE)
                 (@ a_a6KKC)
                 (@ b_a6KKD)
                 (f_a6K7p [Occ=Once] :: a_a6KKC -> b_a6KKD -> b_a6KKD)
                 (z_a6K7q [Occ=Once] :: b_a6KKD)
                 (t1_a6K7r [Occ=Once] :: t_X6KiE a_a6KKC) ->
                 ((foldMap
                     @ t_X6KiE
                     $dFoldable_X6KVH
                     @ (Endo b_a6KKD)
                     @ a_a6KKC
                     (Data.Semigroup.Internal.$fMonoidEndo @ b_a6KKD)
                     (f_a6K7p
                      `cast` (<a_a6KKC>_R
                              ->_R Sym (Data.Semigroup.Internal.N:Endo[0] <b_a6KKD>_R)
                              :: (a_a6KKC -> b_a6KKD -> b_a6KKD :: *)
                                 ~R# (a_a6KKC -> Endo b_a6KKD :: *)))
                     t1_a6K7r)
                  `cast` (Data.Semigroup.Internal.N:Endo[0] <b_a6KKD>_R
                          :: (Endo b_a6KKD :: *) ~R# (b_a6KKD -> b_a6KKD :: *)))
                   z_a6K7q}]
Data.Foldable.$dmfoldr
  = \ (@ (t_X6KiE :: * -> *))
      ($dFoldable_X6KVH :: Foldable t_X6KiE)
      (@ a_a6KKC)
      (@ b_a6KKD)
      (f_a6K7p :: a_a6KKC -> b_a6KKD -> b_a6KKD)
      (z_a6K7q :: b_a6KKD)
      (t1_a6K7r :: t_X6KiE a_a6KKC) ->
      ((foldMap
          @ t_X6KiE
          $dFoldable_X6KVH
          @ (Endo b_a6KKD)
          @ a_a6KKC
          (Data.Semigroup.Internal.$fMonoidEndo @ b_a6KKD)
          (f_a6K7p
           `cast` (<a_a6KKC>_R
                   ->_R Sym (Data.Semigroup.Internal.N:Endo[0] <b_a6KKD>_R)
                   :: (a_a6KKC -> b_a6KKD -> b_a6KKD :: *)
                      ~R# (a_a6KKC -> Endo b_a6KKD :: *)))
          t1_a6K7r)
       `cast` (Data.Semigroup.Internal.N:Endo[0] <b_a6KKD>_R
               :: (Endo b_a6KKD :: *) ~R# (b_a6KKD -> b_a6KKD :: *)))
        z_a6K7q

-- RHS size: {terms: 15, types: 20, coercions: 0, joins: 0/0}
Data.Foldable.$dmfoldMap [InlPrag=INLINE (sat-args=1)]
  :: forall (t :: * -> *).
     Foldable t =>
     forall m a. Monoid m => (a -> m) -> t a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,1*U,C(U),A)><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_X6KiF :: * -> *))
                 ($dFoldable_X6KVI [Occ=Once] :: Foldable t_X6KiF)
                 (@ m_a6KKk)
                 (@ a_a6KKl)
                 ($dMonoid_a6KKn :: Monoid m_a6KKk)
                 (f_a6K7o [Occ=OnceL!] :: a_a6KKl -> m_a6KKk) ->
                 foldr
                   @ t_X6KiF
                   $dFoldable_X6KVI
                   @ a_a6KKl
                   @ m_a6KKk
                   (let {
                      f1_i6HAj [Occ=OnceL!] :: m_a6KKk -> m_a6KKk -> m_a6KKk
                      [LclId]
                      f1_i6HAj = mappend @ m_a6KKk $dMonoid_a6KKn } in
                    \ (x_i6HAl [Occ=Once] :: a_a6KKl) -> f1_i6HAj (f_a6K7o x_i6HAl))
                   (mempty @ m_a6KKk $dMonoid_a6KKn)}]
Data.Foldable.$dmfoldMap
  = \ (@ (t_X6KiF :: * -> *))
      ($dFoldable_X6KVI :: Foldable t_X6KiF)
      (@ m_a6KKk)
      (@ a_a6KKl)
      ($dMonoid_a6KKn :: Monoid m_a6KKk)
      (f_a6K7o :: a_a6KKl -> m_a6KKk) ->
      foldr
        @ t_X6KiF
        $dFoldable_X6KVI
        @ a_a6KKl
        @ m_a6KKk
        (\ (x_i6HAl :: a_a6KKl) ->
           mappend @ m_a6KKk $dMonoid_a6KKn (f_a6K7o x_i6HAl))
        (mempty @ m_a6KKk $dMonoid_a6KKn)

-- RHS size: {terms: 8, types: 14, coercions: 0, joins: 0/0}
Data.Foldable.$dmfold
  :: forall (t :: * -> *).
     Foldable t =>
     forall m. Monoid m => t m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_X6KiG :: * -> *))
                 ($dFoldable_X6KVJ [Occ=Once] :: Foldable t_X6KiG)
                 (@ m_a6KK6)
                 ($dMonoid_a6KK8 [Occ=Once] :: Monoid m_a6KK6) ->
                 foldMap
                   @ t_X6KiG
                   $dFoldable_X6KVJ
                   @ m_a6KK6
                   @ m_a6KK6
                   $dMonoid_a6KK8
                   (id @ m_a6KK6)}]
Data.Foldable.$dmfold
  = \ (@ (t_X6KiG :: * -> *))
      ($dFoldable_X6KVJ :: Foldable t_X6KiG)
      (@ m_a6KK6)
      ($dMonoid_a6KK8 :: Monoid m_a6KK6) ->
      foldMap
        @ t_X6KiG
        $dFoldable_X6KVJ
        @ m_a6KK6
        @ m_a6KK6
        $dMonoid_a6KK8
        (id @ m_a6KK6)

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableDual7 :: forall m. Monoid m => m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ m_a6Ly7) _ [Occ=Dead] -> id @ m_a6Ly7}]
Data.Foldable.$fFoldableDual7
  = \ (@ m_a6Ly7) _ [Occ=Dead] -> id @ m_a6Ly7

-- RHS size: {terms: 17, types: 1, coercions: 143, joins: 0/0}
Data.Foldable.$fFoldableProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable Product
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: Product
                                Data.Foldable.$fFoldableDual7
                                `cast` (forall (m :: <*>_N).
                                        <Monoid m>_R
                                        ->_R Sym (Data.Semigroup.Internal.N:Product[0] <m>_R)
                                        ->_R <m>_R
                                        :: (forall m. Monoid m => m -> m :: *)
                                           ~R# (forall m. Monoid m => Product m -> m :: *))
                                Data.Foldable.$fFoldableDual6
                                `cast` (forall (m :: <*>_N) (a :: <*>_N).
                                        <Monoid m>_R
                                        ->_R <a -> m>_R
                                        ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a>_R)
                                        ->_R <m>_R
                                        :: (forall m a. Monoid m => (a -> m) -> a -> m :: *)
                                           ~R# (forall m a.
                                                Monoid m =>
                                                (a -> m) -> Product a -> m :: *))
                                Data.Foldable.$fFoldableProduct_$cfoldr
                                Data.Foldable.$fFoldableProduct_$cfoldr
                                Data.Foldable.$fFoldableDual5
                                `cast` (forall (b :: <*>_N) (a :: <*>_N).
                                        <b -> a -> b>_R
                                        ->_R <b>_R
                                        ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a>_R)
                                        ->_R <b>_R
                                        :: (forall b a. (b -> a -> b) -> b -> a -> b :: *)
                                           ~R# (forall b a.
                                                (b -> a -> b) -> b -> Product a -> b :: *))
                                Data.Foldable.$fFoldableDual5
                                `cast` (forall (b :: <*>_N) (a :: <*>_N).
                                        <b -> a -> b>_R
                                        ->_R <b>_R
                                        ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a>_R)
                                        ->_R <b>_R
                                        :: (forall b a. (b -> a -> b) -> b -> a -> b :: *)
                                           ~R# (forall b a.
                                                (b -> a -> b) -> b -> Product a -> b :: *))
                                Data.Foldable.$fFoldableProduct3
                                `cast` (forall (a :: <*>_N).
                                        <a -> a -> a>_R
                                        ->_R <Product a>_R
                                        ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
                                        :: (forall a. (a -> a -> a) -> Product a -> Product a :: *)
                                           ~R# (forall a. (a -> a -> a) -> Product a -> a :: *))
                                Data.Foldable.$fFoldableProduct3
                                `cast` (forall (a :: <*>_N).
                                        <a -> a -> a>_R
                                        ->_R <Product a>_R
                                        ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
                                        :: (forall a. (a -> a -> a) -> Product a -> Product a :: *)
                                           ~R# (forall a. (a -> a -> a) -> Product a -> a :: *))
                                Data.Foldable.$fFoldableProduct_$ctoList
                                Data.Foldable.$fFoldableProduct_$cnull
                                Data.Foldable.$fFoldableProduct_$clength
                                ==
                                `cast` (forall (a :: <*>_N).
                                        <Eq a>_R
                                        ->_R <a>_R
                                        ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a>_R)
                                        ->_R <Bool>_R
                                        :: (forall a. Eq a => a -> a -> Bool :: *)
                                           ~R# (forall a. Eq a => a -> Product a -> Bool :: *))
                                Data.Foldable.$fFoldableProduct2
                                `cast` (forall (a :: <*>_N).
                                        <Ord a>_R
                                        ->_R <Product a>_R
                                        ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
                                        :: (forall a. Ord a => Product a -> Product a :: *)
                                           ~R# (forall a. Ord a => Product a -> a :: *))
                                Data.Foldable.$fFoldableProduct2
                                `cast` (forall (a :: <*>_N).
                                        <Ord a>_R
                                        ->_R <Product a>_R
                                        ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
                                        :: (forall a. Ord a => Product a -> Product a :: *)
                                           ~R# (forall a. Ord a => Product a -> a :: *))
                                Data.Foldable.$fFoldableProduct1
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <Product a>_R
                                        ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
                                        :: (forall a. Num a => Product a -> Product a :: *)
                                           ~R# (forall a. Num a => Product a -> a :: *))
                                Data.Foldable.$fFoldableProduct1
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <Product a>_R
                                        ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
                                        :: (forall a. Num a => Product a -> Product a :: *)
                                           ~R# (forall a. Num a => Product a -> a :: *))]
Data.Foldable.$fFoldableProduct
  = Data.Foldable.C:Foldable
      @ Product
      (Data.Foldable.$fFoldableDual7
       `cast` (forall (m :: <*>_N).
               <Monoid m>_R
               ->_R Sym (Data.Semigroup.Internal.N:Product[0] <m>_R)
               ->_R <m>_R
               :: (forall m. Monoid m => m -> m :: *)
                  ~R# (forall m. Monoid m => Product m -> m :: *)))
      (Data.Foldable.$fFoldableDual6
       `cast` (forall (m :: <*>_N) (a :: <*>_N).
               <Monoid m>_R
               ->_R <a -> m>_R
               ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a>_R)
               ->_R <m>_R
               :: (forall m a. Monoid m => (a -> m) -> a -> m :: *)
                  ~R# (forall m a. Monoid m => (a -> m) -> Product a -> m :: *)))
      Data.Foldable.$fFoldableProduct_$cfoldr
      Data.Foldable.$fFoldableProduct_$cfoldr
      (Data.Foldable.$fFoldableDual5
       `cast` (forall (b :: <*>_N) (a :: <*>_N).
               <b -> a -> b>_R
               ->_R <b>_R
               ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a>_R)
               ->_R <b>_R
               :: (forall b a. (b -> a -> b) -> b -> a -> b :: *)
                  ~R# (forall b a. (b -> a -> b) -> b -> Product a -> b :: *)))
      (Data.Foldable.$fFoldableDual5
       `cast` (forall (b :: <*>_N) (a :: <*>_N).
               <b -> a -> b>_R
               ->_R <b>_R
               ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a>_R)
               ->_R <b>_R
               :: (forall b a. (b -> a -> b) -> b -> a -> b :: *)
                  ~R# (forall b a. (b -> a -> b) -> b -> Product a -> b :: *)))
      (Data.Foldable.$fFoldableProduct3
       `cast` (forall (a :: <*>_N).
               <a -> a -> a>_R
               ->_R <Product a>_R
               ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall a. (a -> a -> a) -> Product a -> Product a :: *)
                  ~R# (forall a. (a -> a -> a) -> Product a -> a :: *)))
      (Data.Foldable.$fFoldableProduct3
       `cast` (forall (a :: <*>_N).
               <a -> a -> a>_R
               ->_R <Product a>_R
               ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall a. (a -> a -> a) -> Product a -> Product a :: *)
                  ~R# (forall a. (a -> a -> a) -> Product a -> a :: *)))
      Data.Foldable.$fFoldableProduct_$ctoList
      Data.Foldable.$fFoldableProduct_$cnull
      Data.Foldable.$fFoldableProduct_$clength
      (==
       `cast` (forall (a :: <*>_N).
               <Eq a>_R
               ->_R <a>_R
               ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a>_R)
               ->_R <Bool>_R
               :: (forall a. Eq a => a -> a -> Bool :: *)
                  ~R# (forall a. Eq a => a -> Product a -> Bool :: *)))
      (Data.Foldable.$fFoldableProduct2
       `cast` (forall (a :: <*>_N).
               <Ord a>_R
               ->_R <Product a>_R
               ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall a. Ord a => Product a -> Product a :: *)
                  ~R# (forall a. Ord a => Product a -> a :: *)))
      (Data.Foldable.$fFoldableProduct2
       `cast` (forall (a :: <*>_N).
               <Ord a>_R
               ->_R <Product a>_R
               ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall a. Ord a => Product a -> Product a :: *)
                  ~R# (forall a. Ord a => Product a -> a :: *)))
      (Data.Foldable.$fFoldableProduct1
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <Product a>_R
               ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall a. Num a => Product a -> Product a :: *)
                  ~R# (forall a. Num a => Product a -> a :: *)))
      (Data.Foldable.$fFoldableProduct1
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <Product a>_R
               ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall a. Num a => Product a -> Product a :: *)
                  ~R# (forall a. Num a => Product a -> a :: *)))

-- RHS size: {terms: 17, types: 1, coercions: 143, joins: 0/0}
Data.Foldable.$fFoldableSum [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable Sum
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: Sum
                                Data.Foldable.$fFoldableDual7
                                `cast` (forall (m :: <*>_N).
                                        <Monoid m>_R
                                        ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <m>_R)
                                        ->_R <m>_R
                                        :: (forall m. Monoid m => m -> m :: *)
                                           ~R# (forall m. Monoid m => Sum m -> m :: *))
                                Data.Foldable.$fFoldableDual6
                                `cast` (forall (m :: <*>_N) (a :: <*>_N).
                                        <Monoid m>_R
                                        ->_R <a -> m>_R
                                        ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a>_R)
                                        ->_R <m>_R
                                        :: (forall m a. Monoid m => (a -> m) -> a -> m :: *)
                                           ~R# (forall m a.
                                                Monoid m =>
                                                (a -> m) -> Sum a -> m :: *))
                                Data.Foldable.$fFoldableSum_$cfoldr
                                Data.Foldable.$fFoldableSum_$cfoldr
                                Data.Foldable.$fFoldableDual5
                                `cast` (forall (b :: <*>_N) (a :: <*>_N).
                                        <b -> a -> b>_R
                                        ->_R <b>_R
                                        ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a>_R)
                                        ->_R <b>_R
                                        :: (forall b a. (b -> a -> b) -> b -> a -> b :: *)
                                           ~R# (forall b a. (b -> a -> b) -> b -> Sum a -> b :: *))
                                Data.Foldable.$fFoldableDual5
                                `cast` (forall (b :: <*>_N) (a :: <*>_N).
                                        <b -> a -> b>_R
                                        ->_R <b>_R
                                        ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a>_R)
                                        ->_R <b>_R
                                        :: (forall b a. (b -> a -> b) -> b -> a -> b :: *)
                                           ~R# (forall b a. (b -> a -> b) -> b -> Sum a -> b :: *))
                                Data.Foldable.$fFoldableSum3
                                `cast` (forall (a :: <*>_N).
                                        <a -> a -> a>_R
                                        ->_R <Sum a>_R
                                        ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
                                        :: (forall a. (a -> a -> a) -> Sum a -> Sum a :: *)
                                           ~R# (forall a. (a -> a -> a) -> Sum a -> a :: *))
                                Data.Foldable.$fFoldableSum3
                                `cast` (forall (a :: <*>_N).
                                        <a -> a -> a>_R
                                        ->_R <Sum a>_R
                                        ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
                                        :: (forall a. (a -> a -> a) -> Sum a -> Sum a :: *)
                                           ~R# (forall a. (a -> a -> a) -> Sum a -> a :: *))
                                Data.Foldable.$fFoldableSum_$ctoList
                                Data.Foldable.$fFoldableSum_$cnull
                                Data.Foldable.$fFoldableSum_$clength
                                ==
                                `cast` (forall (a :: <*>_N).
                                        <Eq a>_R
                                        ->_R <a>_R
                                        ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a>_R)
                                        ->_R <Bool>_R
                                        :: (forall a. Eq a => a -> a -> Bool :: *)
                                           ~R# (forall a. Eq a => a -> Sum a -> Bool :: *))
                                Data.Foldable.$fFoldableSum2
                                `cast` (forall (a :: <*>_N).
                                        <Ord a>_R
                                        ->_R <Sum a>_R
                                        ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
                                        :: (forall a. Ord a => Sum a -> Sum a :: *)
                                           ~R# (forall a. Ord a => Sum a -> a :: *))
                                Data.Foldable.$fFoldableSum2
                                `cast` (forall (a :: <*>_N).
                                        <Ord a>_R
                                        ->_R <Sum a>_R
                                        ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
                                        :: (forall a. Ord a => Sum a -> Sum a :: *)
                                           ~R# (forall a. Ord a => Sum a -> a :: *))
                                Data.Foldable.$fFoldableSum1
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <Sum a>_R
                                        ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
                                        :: (forall a. Num a => Sum a -> Sum a :: *)
                                           ~R# (forall a. Num a => Sum a -> a :: *))
                                Data.Foldable.$fFoldableSum1
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <Sum a>_R
                                        ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
                                        :: (forall a. Num a => Sum a -> Sum a :: *)
                                           ~R# (forall a. Num a => Sum a -> a :: *))]
Data.Foldable.$fFoldableSum
  = Data.Foldable.C:Foldable
      @ Sum
      (Data.Foldable.$fFoldableDual7
       `cast` (forall (m :: <*>_N).
               <Monoid m>_R
               ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <m>_R)
               ->_R <m>_R
               :: (forall m. Monoid m => m -> m :: *)
                  ~R# (forall m. Monoid m => Sum m -> m :: *)))
      (Data.Foldable.$fFoldableDual6
       `cast` (forall (m :: <*>_N) (a :: <*>_N).
               <Monoid m>_R
               ->_R <a -> m>_R
               ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a>_R)
               ->_R <m>_R
               :: (forall m a. Monoid m => (a -> m) -> a -> m :: *)
                  ~R# (forall m a. Monoid m => (a -> m) -> Sum a -> m :: *)))
      Data.Foldable.$fFoldableSum_$cfoldr
      Data.Foldable.$fFoldableSum_$cfoldr
      (Data.Foldable.$fFoldableDual5
       `cast` (forall (b :: <*>_N) (a :: <*>_N).
               <b -> a -> b>_R
               ->_R <b>_R
               ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a>_R)
               ->_R <b>_R
               :: (forall b a. (b -> a -> b) -> b -> a -> b :: *)
                  ~R# (forall b a. (b -> a -> b) -> b -> Sum a -> b :: *)))
      (Data.Foldable.$fFoldableDual5
       `cast` (forall (b :: <*>_N) (a :: <*>_N).
               <b -> a -> b>_R
               ->_R <b>_R
               ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a>_R)
               ->_R <b>_R
               :: (forall b a. (b -> a -> b) -> b -> a -> b :: *)
                  ~R# (forall b a. (b -> a -> b) -> b -> Sum a -> b :: *)))
      (Data.Foldable.$fFoldableSum3
       `cast` (forall (a :: <*>_N).
               <a -> a -> a>_R
               ->_R <Sum a>_R
               ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall a. (a -> a -> a) -> Sum a -> Sum a :: *)
                  ~R# (forall a. (a -> a -> a) -> Sum a -> a :: *)))
      (Data.Foldable.$fFoldableSum3
       `cast` (forall (a :: <*>_N).
               <a -> a -> a>_R
               ->_R <Sum a>_R
               ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall a. (a -> a -> a) -> Sum a -> Sum a :: *)
                  ~R# (forall a. (a -> a -> a) -> Sum a -> a :: *)))
      Data.Foldable.$fFoldableSum_$ctoList
      Data.Foldable.$fFoldableSum_$cnull
      Data.Foldable.$fFoldableSum_$clength
      (==
       `cast` (forall (a :: <*>_N).
               <Eq a>_R
               ->_R <a>_R
               ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a>_R)
               ->_R <Bool>_R
               :: (forall a. Eq a => a -> a -> Bool :: *)
                  ~R# (forall a. Eq a => a -> Sum a -> Bool :: *)))
      (Data.Foldable.$fFoldableSum2
       `cast` (forall (a :: <*>_N).
               <Ord a>_R
               ->_R <Sum a>_R
               ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall a. Ord a => Sum a -> Sum a :: *)
                  ~R# (forall a. Ord a => Sum a -> a :: *)))
      (Data.Foldable.$fFoldableSum2
       `cast` (forall (a :: <*>_N).
               <Ord a>_R
               ->_R <Sum a>_R
               ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall a. Ord a => Sum a -> Sum a :: *)
                  ~R# (forall a. Ord a => Sum a -> a :: *)))
      (Data.Foldable.$fFoldableSum1
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <Sum a>_R
               ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall a. Num a => Sum a -> Sum a :: *)
                  ~R# (forall a. Num a => Sum a -> a :: *)))
      (Data.Foldable.$fFoldableSum1
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <Sum a>_R
               ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall a. Num a => Sum a -> Sum a :: *)
                  ~R# (forall a. Num a => Sum a -> a :: *)))

-- RHS size: {terms: 17, types: 1, coercions: 143, joins: 0/0}
Data.Foldable.$fFoldableDual [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable Dual
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: Dual
                                Data.Foldable.$fFoldableDual7
                                `cast` (forall (m :: <*>_N).
                                        <Monoid m>_R
                                        ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <m>_R)
                                        ->_R <m>_R
                                        :: (forall m. Monoid m => m -> m :: *)
                                           ~R# (forall m. Monoid m => Dual m -> m :: *))
                                Data.Foldable.$fFoldableDual6
                                `cast` (forall (m :: <*>_N) (a :: <*>_N).
                                        <Monoid m>_R
                                        ->_R <a -> m>_R
                                        ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <a>_R)
                                        ->_R <m>_R
                                        :: (forall m a. Monoid m => (a -> m) -> a -> m :: *)
                                           ~R# (forall m a.
                                                Monoid m =>
                                                (a -> m) -> Dual a -> m :: *))
                                Data.Foldable.$fFoldableDual_$cfoldr
                                Data.Foldable.$fFoldableDual_$cfoldr
                                Data.Foldable.$fFoldableDual5
                                `cast` (forall (b :: <*>_N) (a :: <*>_N).
                                        <b -> a -> b>_R
                                        ->_R <b>_R
                                        ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <a>_R)
                                        ->_R <b>_R
                                        :: (forall b a. (b -> a -> b) -> b -> a -> b :: *)
                                           ~R# (forall b a. (b -> a -> b) -> b -> Dual a -> b :: *))
                                Data.Foldable.$fFoldableDual5
                                `cast` (forall (b :: <*>_N) (a :: <*>_N).
                                        <b -> a -> b>_R
                                        ->_R <b>_R
                                        ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <a>_R)
                                        ->_R <b>_R
                                        :: (forall b a. (b -> a -> b) -> b -> a -> b :: *)
                                           ~R# (forall b a. (b -> a -> b) -> b -> Dual a -> b :: *))
                                Data.Foldable.$fFoldableDual4
                                `cast` (forall (a :: <*>_N).
                                        <a -> a -> a>_R
                                        ->_R <Dual a>_R
                                        ->_R Data.Semigroup.Internal.N:Dual[0] <a>_R
                                        :: (forall a. (a -> a -> a) -> Dual a -> Dual a :: *)
                                           ~R# (forall a. (a -> a -> a) -> Dual a -> a :: *))
                                Data.Foldable.$fFoldableDual4
                                `cast` (forall (a :: <*>_N).
                                        <a -> a -> a>_R
                                        ->_R <Dual a>_R
                                        ->_R Data.Semigroup.Internal.N:Dual[0] <a>_R
                                        :: (forall a. (a -> a -> a) -> Dual a -> Dual a :: *)
                                           ~R# (forall a. (a -> a -> a) -> Dual a -> a :: *))
                                Data.Foldable.$fFoldableDual_$ctoList
                                Data.Foldable.$fFoldableDual_$cnull
                                Data.Foldable.$fFoldableDual_$clength
                                ==
                                `cast` (forall (a :: <*>_N).
                                        <Eq a>_R
                                        ->_R <a>_R
                                        ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <a>_R)
                                        ->_R <Bool>_R
                                        :: (forall a. Eq a => a -> a -> Bool :: *)
                                           ~R# (forall a. Eq a => a -> Dual a -> Bool :: *))
                                Data.Foldable.$fFoldableDual2
                                `cast` (forall (a :: <*>_N).
                                        <Ord a>_R
                                        ->_R <Dual a>_R
                                        ->_R Data.Semigroup.Internal.N:Dual[0] <a>_R
                                        :: (forall a. Ord a => Dual a -> Dual a :: *)
                                           ~R# (forall a. Ord a => Dual a -> a :: *))
                                Data.Foldable.$fFoldableDual2
                                `cast` (forall (a :: <*>_N).
                                        <Ord a>_R
                                        ->_R <Dual a>_R
                                        ->_R Data.Semigroup.Internal.N:Dual[0] <a>_R
                                        :: (forall a. Ord a => Dual a -> Dual a :: *)
                                           ~R# (forall a. Ord a => Dual a -> a :: *))
                                Data.Foldable.$fFoldableDual1
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <Dual a>_R
                                        ->_R Data.Semigroup.Internal.N:Dual[0] <a>_R
                                        :: (forall a. Num a => Dual a -> Dual a :: *)
                                           ~R# (forall a. Num a => Dual a -> a :: *))
                                Data.Foldable.$fFoldableDual1
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <Dual a>_R
                                        ->_R Data.Semigroup.Internal.N:Dual[0] <a>_R
                                        :: (forall a. Num a => Dual a -> Dual a :: *)
                                           ~R# (forall a. Num a => Dual a -> a :: *))]
Data.Foldable.$fFoldableDual
  = Data.Foldable.C:Foldable
      @ Dual
      (Data.Foldable.$fFoldableDual7
       `cast` (forall (m :: <*>_N).
               <Monoid m>_R
               ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <m>_R)
               ->_R <m>_R
               :: (forall m. Monoid m => m -> m :: *)
                  ~R# (forall m. Monoid m => Dual m -> m :: *)))
      (Data.Foldable.$fFoldableDual6
       `cast` (forall (m :: <*>_N) (a :: <*>_N).
               <Monoid m>_R
               ->_R <a -> m>_R
               ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <a>_R)
               ->_R <m>_R
               :: (forall m a. Monoid m => (a -> m) -> a -> m :: *)
                  ~R# (forall m a. Monoid m => (a -> m) -> Dual a -> m :: *)))
      Data.Foldable.$fFoldableDual_$cfoldr
      Data.Foldable.$fFoldableDual_$cfoldr
      (Data.Foldable.$fFoldableDual5
       `cast` (forall (b :: <*>_N) (a :: <*>_N).
               <b -> a -> b>_R
               ->_R <b>_R
               ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <a>_R)
               ->_R <b>_R
               :: (forall b a. (b -> a -> b) -> b -> a -> b :: *)
                  ~R# (forall b a. (b -> a -> b) -> b -> Dual a -> b :: *)))
      (Data.Foldable.$fFoldableDual5
       `cast` (forall (b :: <*>_N) (a :: <*>_N).
               <b -> a -> b>_R
               ->_R <b>_R
               ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <a>_R)
               ->_R <b>_R
               :: (forall b a. (b -> a -> b) -> b -> a -> b :: *)
                  ~R# (forall b a. (b -> a -> b) -> b -> Dual a -> b :: *)))
      (Data.Foldable.$fFoldableDual4
       `cast` (forall (a :: <*>_N).
               <a -> a -> a>_R
               ->_R <Dual a>_R
               ->_R Data.Semigroup.Internal.N:Dual[0] <a>_R
               :: (forall a. (a -> a -> a) -> Dual a -> Dual a :: *)
                  ~R# (forall a. (a -> a -> a) -> Dual a -> a :: *)))
      (Data.Foldable.$fFoldableDual4
       `cast` (forall (a :: <*>_N).
               <a -> a -> a>_R
               ->_R <Dual a>_R
               ->_R Data.Semigroup.Internal.N:Dual[0] <a>_R
               :: (forall a. (a -> a -> a) -> Dual a -> Dual a :: *)
                  ~R# (forall a. (a -> a -> a) -> Dual a -> a :: *)))
      Data.Foldable.$fFoldableDual_$ctoList
      Data.Foldable.$fFoldableDual_$cnull
      Data.Foldable.$fFoldableDual_$clength
      (==
       `cast` (forall (a :: <*>_N).
               <Eq a>_R
               ->_R <a>_R
               ->_R Sym (Data.Semigroup.Internal.N:Dual[0] <a>_R)
               ->_R <Bool>_R
               :: (forall a. Eq a => a -> a -> Bool :: *)
                  ~R# (forall a. Eq a => a -> Dual a -> Bool :: *)))
      (Data.Foldable.$fFoldableDual2
       `cast` (forall (a :: <*>_N).
               <Ord a>_R
               ->_R <Dual a>_R
               ->_R Data.Semigroup.Internal.N:Dual[0] <a>_R
               :: (forall a. Ord a => Dual a -> Dual a :: *)
                  ~R# (forall a. Ord a => Dual a -> a :: *)))
      (Data.Foldable.$fFoldableDual2
       `cast` (forall (a :: <*>_N).
               <Ord a>_R
               ->_R <Dual a>_R
               ->_R Data.Semigroup.Internal.N:Dual[0] <a>_R
               :: (forall a. Ord a => Dual a -> Dual a :: *)
                  ~R# (forall a. Ord a => Dual a -> a :: *)))
      (Data.Foldable.$fFoldableDual1
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <Dual a>_R
               ->_R Data.Semigroup.Internal.N:Dual[0] <a>_R
               :: (forall a. Num a => Dual a -> Dual a :: *)
                  ~R# (forall a. Num a => Dual a -> a :: *)))
      (Data.Foldable.$fFoldableDual1
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <Dual a>_R
               ->_R Data.Semigroup.Internal.N:Dual[0] <a>_R
               :: (forall a. Num a => Dual a -> Dual a :: *)
                  ~R# (forall a. Num a => Dual a -> a :: *)))

-- RHS size: {terms: 30, types: 29, coercions: 0, joins: 1/1}
Data.Foldable.$fFoldable[]_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> [a] -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 126 0}]
Data.Foldable.$fFoldable[]_$cfoldr'
  = \ (@ a_a6LRy)
      (@ b_a6LRz)
      (f_a6K7s :: a_a6LRy -> b_a6LRz -> b_a6LRz)
      (z0_a6K7t :: b_a6LRz)
      (xs_a6K7u :: [a_a6LRy]) ->
      joinrec {
        go_i6HCY [Occ=LoopBreaker]
          :: [a_a6LRy] -> (b_a6LRz -> b_a6LRz) -> b_a6LRz -> b_a6LRz
        [LclId[JoinId(3)],
         Arity=3,
         Str=<S,1*U><C(S),1*C1(U)><L,U>,
         Unf=OtherCon []]
        go_i6HCY (ds_i6HCZ :: [a_a6LRy])
                 (eta_B1 :: b_a6LRz -> b_a6LRz)
                 (eta1_X2 :: b_a6LRz)
          = case ds_i6HCZ of {
              [] -> eta_B1 eta1_X2;
              : y_i6HD4 ys_i6HD5 ->
                jump go_i6HCY
                  ys_i6HD5
                  (\ (z_a6K7y [OS=OneShot] :: b_a6LRz) ->
                     case f_a6K7s y_i6HD4 z_a6K7y of vx_i6M0K { __DEFAULT ->
                     eta_B1 vx_i6M0K
                     })
                  eta1_X2
            }; } in
      jump go_i6HCY xs_a6K7u (id @ b_a6LRz) z0_a6K7t

-- RHS size: {terms: 23, types: 23, coercions: 0, joins: 0/2}
Data.Foldable.$fFoldable[]_$cfoldMap [InlPrag=INLINE (sat-args=1)]
  :: forall m a. Monoid m => (a -> m) -> [a] -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><L,C(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ m_a6LRe)
                 (@ a_a6LRf)
                 ($dMonoid_a6LRh :: Monoid m_a6LRe)
                 (f_a6K7o [Occ=OnceL!] :: a_a6LRf -> m_a6LRe) ->
                 List.foldr
                   @ a_a6LRf
                   @ m_a6LRe
                   (let {
                      f1_i6HAj [Occ=OnceL!] :: m_a6LRe -> m_a6LRe -> m_a6LRe
                      [LclId]
                      f1_i6HAj = mappend @ m_a6LRe $dMonoid_a6LRh } in
                    \ (x_i6HAl [Occ=Once] :: a_a6LRf) -> f1_i6HAj (f_a6K7o x_i6HAl))
                   (mempty @ m_a6LRe $dMonoid_a6LRh)}]
Data.Foldable.$fFoldable[]_$cfoldMap
  = \ (@ m_a6LRe)
      (@ a_a6LRf)
      ($dMonoid_a6LRh :: Monoid m_a6LRe)
      (f_a6K7o :: a_a6LRf -> m_a6LRe)
      (eta_B1 :: [a_a6LRf]) ->
      let {
        z_i6HCX :: m_a6LRe
        [LclId]
        z_i6HCX = mempty @ m_a6LRe $dMonoid_a6LRh } in
      letrec {
        go_i6HCY [Occ=LoopBreaker] :: [a_a6LRf] -> m_a6LRe
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_i6HCY
          = \ (ds_i6HCZ :: [a_a6LRf]) ->
              case ds_i6HCZ of {
                [] -> z_i6HCX;
                : y_i6HD4 ys_i6HD5 ->
                  mappend
                    @ m_a6LRe $dMonoid_a6LRh (f_a6K7o y_i6HD4) (go_i6HCY ys_i6HD5)
              }; } in
      go_i6HCY eta_B1

-- RHS size: {terms: 20, types: 19, coercions: 0, joins: 0/2}
Data.Foldable.$fFoldableNonEmpty_$cfold1
  :: forall m. Monoid m => [m] -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 150 0}]
Data.Foldable.$fFoldableNonEmpty_$cfold1
  = \ (@ m_a6LR4)
      ($dMonoid_a6LR6 :: Monoid m_a6LR4)
      (eta_B1 :: [m_a6LR4]) ->
      let {
        z_i6HCX :: m_a6LR4
        [LclId]
        z_i6HCX = mempty @ m_a6LR4 $dMonoid_a6LR6 } in
      letrec {
        go_i6HCY [Occ=LoopBreaker] :: [m_a6LR4] -> m_a6LR4
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_i6HCY
          = \ (ds_i6HCZ :: [m_a6LR4]) ->
              case ds_i6HCZ of {
                [] -> z_i6HCX;
                : y_i6HD4 ys_i6HD5 ->
                  mappend @ m_a6LR4 $dMonoid_a6LR6 y_i6HD4 (go_i6HCY ys_i6HD5)
              }; } in
      go_i6HCY eta_B1

-- RHS size: {terms: 22, types: 17, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable []
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: []
                                Data.Foldable.$fFoldableNonEmpty_$cfold1
                                Data.Foldable.$fFoldable[]_$cfoldMap
                                List.foldr
                                Data.Foldable.$fFoldable[]_$cfoldr'
                                \ (@ b_a6LRI) (@ a_a6LRJ) -> List.foldl @ a_a6LRJ @ b_a6LRI
                                \ (@ b_a6LRQ) (@ a_a6LRR) -> List.foldl' @ a_a6LRR @ b_a6LRQ
                                List.foldr1
                                List.foldl1
                                \ (@ a_a6LSh) -> id @ [a_a6LSh]
                                List.null
                                List.length
                                List.elem
                                List.maximum
                                List.minimum
                                List.sum
                                List.product]
Data.Foldable.$fFoldable[]
  = Data.Foldable.C:Foldable
      @ []
      Data.Foldable.$fFoldableNonEmpty_$cfold1
      Data.Foldable.$fFoldable[]_$cfoldMap
      List.foldr
      Data.Foldable.$fFoldable[]_$cfoldr'
      (\ (@ b_a6LRI) (@ a_a6LRJ) -> List.foldl @ a_a6LRJ @ b_a6LRI)
      (\ (@ b_a6LRQ) (@ a_a6LRR) -> List.foldl' @ a_a6LRR @ b_a6LRQ)
      List.foldr1
      List.foldl1
      (\ (@ a_a6LSh) -> id @ [a_a6LSh])
      List.null
      List.length
      List.elem
      List.maximum
      List.minimum
      List.sum
      List.product

-- RHS size: {terms: 15, types: 18, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableNonEmpty_$cfold
  :: forall m. Monoid m => NonEmpty m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),U(A,U,C(C1(U)),A)><L,U(1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_a6LOt)
                 ($dMonoid_a6LOv :: Monoid m_a6LOt)
                 (ds_d6M9C :: NonEmpty m_a6LOt) ->
                 mappend
                   @ m_a6LOt
                   $dMonoid_a6LOv
                   (case ds_d6M9C of { :| m1_a6K8K [Occ=Once] _ [Occ=Dead] ->
                    m1_a6K8K
                    })
                   (case ds_d6M9C of { :| _ [Occ=Dead] ms_a6K8L [Occ=Once] ->
                    Data.Foldable.$fFoldableNonEmpty_$cfold1
                      @ m_a6LOt $dMonoid_a6LOv ms_a6K8L
                    })}]
Data.Foldable.$fFoldableNonEmpty_$cfold
  = \ (@ m_a6LOt)
      ($dMonoid_a6LOv :: Monoid m_a6LOt)
      (ds_d6M9C :: NonEmpty m_a6LOt) ->
      mappend
        @ m_a6LOt
        $dMonoid_a6LOv
        (case ds_d6M9C of { :| m1_a6K8K ms_a6K8L -> m1_a6K8K })
        (case ds_d6M9C of { :| m1_a6K8K ms_a6K8L ->
         Data.Foldable.$fFoldableNonEmpty_$cfold1
           @ m_a6LOt $dMonoid_a6LOv ms_a6K8L
         })

-- RHS size: {terms: 33, types: 34, coercions: 0, joins: 0/2}
Data.Foldable.$fFoldableNonEmpty_$cfoldMap
  :: forall m a. Monoid m => (a -> m) -> NonEmpty a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),U(A,1*U,C(C1(U)),A)><L,C(U)><L,U(1*U,1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 60 40] 250 0}]
Data.Foldable.$fFoldableNonEmpty_$cfoldMap
  = \ (@ m_a6LOG)
      (@ a_a6LOH)
      ($dMonoid_a6LOJ :: Monoid m_a6LOG)
      (f_a6K8H :: a_a6LOH -> m_a6LOG)
      (ds_d6M9R :: NonEmpty a_a6LOH) ->
      mappend
        @ m_a6LOG
        $dMonoid_a6LOJ
        (f_a6K8H (case ds_d6M9R of { :| a1_a6K8I as_a6K8J -> a1_a6K8I }))
        (case ds_d6M9R of { :| a1_a6K8I as_a6K8J ->
         let {
           z_i6HCX :: m_a6LOG
           [LclId]
           z_i6HCX = mempty @ m_a6LOG $dMonoid_a6LOJ } in
         letrec {
           go_i6HCY [Occ=LoopBreaker] :: [a_a6LOH] -> m_a6LOG
           [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
           go_i6HCY
             = \ (ds1_i6HCZ :: [a_a6LOH]) ->
                 case ds1_i6HCZ of {
                   [] -> z_i6HCX;
                   : y_i6HD4 ys_i6HD5 ->
                     mappend
                       @ m_a6LOG $dMonoid_a6LOJ (f_a6K8H y_i6HD4) (go_i6HCY ys_i6HD5)
                 }; } in
         go_i6HCY as_a6K8J
         })

-- RHS size: {terms: 24, types: 38, coercions: 0, joins: 0/0}
foldrM
  :: forall (t :: * -> *) (m :: * -> *) a b.
     (Foldable t, Monad m) =>
     (a -> b -> m b) -> b -> t a -> m b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLLC(C(C(S)))LLLLLLLLLLL),1*U(A,A,A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,1*U,A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 60 0 0] 180 0}]
foldrM
  = \ (@ (t_a6KJq :: * -> *))
      (@ (m_a6KJr :: * -> *))
      (@ a_a6KJs)
      (@ b_a6KJt)
      ($dFoldable_a6KJv :: Foldable t_a6KJq)
      ($dMonad_a6KJw :: Monad m_a6KJr)
      (f_a6K9Q :: a_a6KJs -> b_a6KJt -> m_a6KJr b_a6KJt)
      (z0_a6K9R :: b_a6KJt)
      (xs_a6K9S :: t_a6KJq a_a6KJs) ->
      foldl
        @ t_a6KJq
        $dFoldable_a6KJv
        @ (b_a6KJt -> m_a6KJr b_a6KJt)
        @ a_a6KJs
        (\ (k_a6K9U :: b_a6KJt -> m_a6KJr b_a6KJt)
           (x_a6K9V :: a_a6KJs)
           (z_a6K9W :: b_a6KJt) ->
           >>=
             @ m_a6KJr
             $dMonad_a6KJw
             @ b_a6KJt
             @ b_a6KJt
             (f_a6K9Q x_a6K9V z_a6K9W)
             k_a6K9U)
        (return @ m_a6KJr $dMonad_a6KJw @ b_a6KJt)
        xs_a6K9S
        z0_a6K9R

-- RHS size: {terms: 24, types: 38, coercions: 0, joins: 0/0}
foldlM
  :: forall (t :: * -> *) (m :: * -> *) b a.
     (Foldable t, Monad m) =>
     (b -> a -> m b) -> b -> t a -> m b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,1*U,A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 60 0 0] 180 0}]
foldlM
  = \ (@ (t_a6KHr :: * -> *))
      (@ (m_a6KHs :: * -> *))
      (@ b_a6KHt)
      (@ a_a6KHu)
      ($dFoldable_a6KHw :: Foldable t_a6KHr)
      ($dMonad_a6KHx :: Monad m_a6KHs)
      (f_a6K9X :: b_a6KHt -> a_a6KHu -> m_a6KHs b_a6KHt)
      (z0_a6K9Y :: b_a6KHt)
      (xs_a6K9Z :: t_a6KHr a_a6KHu) ->
      foldr
        @ t_a6KHr
        $dFoldable_a6KHw
        @ a_a6KHu
        @ (b_a6KHt -> m_a6KHs b_a6KHt)
        (\ (x_a6Ka1 :: a_a6KHu)
           (k_a6Ka2 :: b_a6KHt -> m_a6KHs b_a6KHt)
           (z_a6Ka3 :: b_a6KHt) ->
           >>=
             @ m_a6KHs
             $dMonad_a6KHx
             @ b_a6KHt
             @ b_a6KHt
             (f_a6K9X z_a6Ka3 x_a6Ka1)
             k_a6Ka2)
        (return @ m_a6KHs $dMonad_a6KHx @ b_a6KHt)
        xs_a6K9Z
        z0_a6K9Y

-- RHS size: {terms: 17, types: 29, coercions: 0, joins: 0/0}
traverse_
  :: forall (t :: * -> *) (f :: * -> *) a b.
     (Foldable t, Applicative f) =>
     (a -> f b) -> t a -> f ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,1*C1(U),A,A,C(U),A)><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 60 60] 130 0}]
traverse_
  = \ (@ (t_a6KGO :: * -> *))
      (@ (f_a6KGP :: * -> *))
      (@ a_a6KGQ)
      (@ b_a6KGR)
      ($dFoldable_a6KGT :: Foldable t_a6KGO)
      ($dApplicative_a6KGU :: Applicative f_a6KGP)
      (f1_a6Ka4 :: a_a6KGQ -> f_a6KGP b_a6KGR) ->
      foldr
        @ t_a6KGO
        $dFoldable_a6KGT
        @ a_a6KGQ
        @ (f_a6KGP ())
        (\ (x_i6HAl :: a_a6KGQ) ->
           *> @ f_a6KGP $dApplicative_a6KGU @ b_a6KGR @ () (f1_a6Ka4 x_i6HAl))
        (pure @ f_a6KGP $dApplicative_a6KGU @ () GHC.Tuple.())

-- RHS size: {terms: 13, types: 25, coercions: 0, joins: 0/0}
for_ [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (f :: * -> *) a b.
     (Foldable t, Applicative f) =>
     t a -> (a -> f b) -> f ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(U),A,A,C(U),A)><L,U><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ (t_a6KHa :: * -> *))
                 (@ (f_a6KHb :: * -> *))
                 (@ a_a6KHc)
                 (@ b_a6KHd)
                 ($dFoldable_a6KHf [Occ=Once] :: Foldable t_a6KHa)
                 ($dApplicative_a6KHg [Occ=Once] :: Applicative f_a6KHb)
                 (x_i6M09 [Occ=Once] :: t_a6KHa a_a6KHc)
                 (y_i6M0a [Occ=Once] :: a_a6KHc -> f_a6KHb b_a6KHd) ->
                 traverse_
                   @ t_a6KHa
                   @ f_a6KHb
                   @ a_a6KHc
                   @ b_a6KHd
                   $dFoldable_a6KHf
                   $dApplicative_a6KHg
                   y_i6M0a
                   x_i6M09}]
for_
  = \ (@ (t_a6KHa :: * -> *))
      (@ (f_a6KHb :: * -> *))
      (@ a_a6KHc)
      (@ b_a6KHd)
      ($dFoldable_a6KHf :: Foldable t_a6KHa)
      ($dApplicative_a6KHg :: Applicative f_a6KHb)
      (x_i6M09 :: t_a6KHa a_a6KHc)
      (y_i6M0a :: a_a6KHc -> f_a6KHb b_a6KHd) ->
      traverse_
        @ t_a6KHa
        @ f_a6KHb
        @ a_a6KHc
        @ b_a6KHd
        $dFoldable_a6KHf
        $dApplicative_a6KHg
        y_i6M0a
        x_i6M09

-- RHS size: {terms: 17, types: 29, coercions: 0, joins: 0/0}
mapM_
  :: forall (t :: * -> *) (m :: * -> *) a b.
     (Foldable t, Monad m) =>
     (a -> m b) -> t a -> m ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(U),1*C1(U),A)><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 60 60] 130 0}]
mapM_
  = \ (@ (t_a6KG7 :: * -> *))
      (@ (m_a6KG8 :: * -> *))
      (@ a_a6KG9)
      (@ b_a6KGa)
      ($dFoldable_a6KGc :: Foldable t_a6KG7)
      ($dMonad_a6KGd :: Monad m_a6KG8)
      (f_a6Ka5 :: a_a6KG9 -> m_a6KG8 b_a6KGa) ->
      foldr
        @ t_a6KG7
        $dFoldable_a6KGc
        @ a_a6KG9
        @ (m_a6KG8 ())
        (\ (x_i6HAl :: a_a6KG9) ->
           >> @ m_a6KG8 $dMonad_a6KGd @ b_a6KGa @ () (f_a6Ka5 x_i6HAl))
        (return @ m_a6KG8 $dMonad_a6KGd @ () GHC.Tuple.())

-- RHS size: {terms: 13, types: 25, coercions: 0, joins: 0/0}
forM_ [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (m :: * -> *) a b.
     (Foldable t, Monad m) =>
     t a -> (a -> m b) -> m ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(U),C(U),A)><L,U><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ (t_a6KGt :: * -> *))
                 (@ (m_a6KGu :: * -> *))
                 (@ a_a6KGv)
                 (@ b_a6KGw)
                 ($dFoldable_a6KGy [Occ=Once] :: Foldable t_a6KGt)
                 ($dMonad_a6KGz [Occ=Once] :: Monad m_a6KGu)
                 (x_i6M09 [Occ=Once] :: t_a6KGt a_a6KGv)
                 (y_i6M0a [Occ=Once] :: a_a6KGv -> m_a6KGu b_a6KGw) ->
                 mapM_
                   @ t_a6KGt
                   @ m_a6KGu
                   @ a_a6KGv
                   @ b_a6KGw
                   $dFoldable_a6KGy
                   $dMonad_a6KGz
                   y_i6M0a
                   x_i6M09}]
forM_
  = \ (@ (t_a6KGt :: * -> *))
      (@ (m_a6KGu :: * -> *))
      (@ a_a6KGv)
      (@ b_a6KGw)
      ($dFoldable_a6KGy :: Foldable t_a6KGt)
      ($dMonad_a6KGz :: Monad m_a6KGu)
      (x_i6M09 :: t_a6KGt a_a6KGv)
      (y_i6M0a :: a_a6KGv -> m_a6KGu b_a6KGw) ->
      mapM_
        @ t_a6KGt
        @ m_a6KGu
        @ a_a6KGv
        @ b_a6KGw
        $dFoldable_a6KGy
        $dMonad_a6KGz
        y_i6M0a
        x_i6M09

-- RHS size: {terms: 12, types: 24, coercions: 0, joins: 0/0}
sequenceA_
  :: forall (t :: * -> *) (f :: * -> *) a.
     (Foldable t, Applicative f) =>
     t (f a) -> f ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,1*C1(U),A,A,1*U,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_a6KFP :: * -> *))
                 (@ (f_a6KFQ :: * -> *))
                 (@ a_a6KFR)
                 ($dFoldable_a6KFT [Occ=Once] :: Foldable t_a6KFP)
                 ($dApplicative_a6KFU :: Applicative f_a6KFQ) ->
                 foldr
                   @ t_a6KFP
                   $dFoldable_a6KFT
                   @ (f_a6KFQ a_a6KFR)
                   @ (f_a6KFQ ())
                   (*> @ f_a6KFQ $dApplicative_a6KFU @ a_a6KFR @ ())
                   (pure @ f_a6KFQ $dApplicative_a6KFU @ () GHC.Tuple.())}]
sequenceA_
  = \ (@ (t_a6KFP :: * -> *))
      (@ (f_a6KFQ :: * -> *))
      (@ a_a6KFR)
      ($dFoldable_a6KFT :: Foldable t_a6KFP)
      ($dApplicative_a6KFU :: Applicative f_a6KFQ) ->
      foldr
        @ t_a6KFP
        $dFoldable_a6KFT
        @ (f_a6KFQ a_a6KFR)
        @ (f_a6KFQ ())
        (*> @ f_a6KFQ $dApplicative_a6KFU @ a_a6KFR @ ())
        (pure @ f_a6KFQ $dApplicative_a6KFU @ () GHC.Tuple.())

-- RHS size: {terms: 12, types: 24, coercions: 0, joins: 0/0}
sequence_
  :: forall (t :: * -> *) (m :: * -> *) a.
     (Foldable t, Monad m) =>
     t (m a) -> m ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,1*U,1*C1(U),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_a6KFx :: * -> *))
                 (@ (m_a6KFy :: * -> *))
                 (@ a_a6KFz)
                 ($dFoldable_a6KFB [Occ=Once] :: Foldable t_a6KFx)
                 ($dMonad_a6KFC :: Monad m_a6KFy) ->
                 foldr
                   @ t_a6KFx
                   $dFoldable_a6KFB
                   @ (m_a6KFy a_a6KFz)
                   @ (m_a6KFy ())
                   (>> @ m_a6KFy $dMonad_a6KFC @ a_a6KFz @ ())
                   (return @ m_a6KFy $dMonad_a6KFC @ () GHC.Tuple.())}]
sequence_
  = \ (@ (t_a6KFx :: * -> *))
      (@ (m_a6KFy :: * -> *))
      (@ a_a6KFz)
      ($dFoldable_a6KFB :: Foldable t_a6KFx)
      ($dMonad_a6KFC :: Monad m_a6KFy) ->
      foldr
        @ t_a6KFx
        $dFoldable_a6KFB
        @ (m_a6KFy a_a6KFz)
        @ (m_a6KFy ())
        (>> @ m_a6KFy $dMonad_a6KFC @ a_a6KFz @ ())
        (return @ m_a6KFy $dMonad_a6KFC @ () GHC.Tuple.())

-- RHS size: {terms: 11, types: 23, coercions: 0, joins: 0/0}
asum [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (f :: * -> *) a.
     (Foldable t, Alternative f) =>
     t (f a) -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,1*U,1*U,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (t_a6KF2 :: * -> *))
                 (@ (f_a6KF3 :: * -> *))
                 (@ a_a6KF4)
                 ($dFoldable_a6KF6 [Occ=Once] :: Foldable t_a6KF2)
                 ($dAlternative_a6KF7 :: Alternative f_a6KF3) ->
                 foldr
                   @ t_a6KF2
                   $dFoldable_a6KF6
                   @ (f_a6KF3 a_a6KF4)
                   @ (f_a6KF3 a_a6KF4)
                   (<|> @ f_a6KF3 $dAlternative_a6KF7 @ a_a6KF4)
                   (empty @ f_a6KF3 $dAlternative_a6KF7 @ a_a6KF4)}]
asum
  = \ (@ (t_a6KF2 :: * -> *))
      (@ (f_a6KF3 :: * -> *))
      (@ a_a6KF4)
      ($dFoldable_a6KF6 :: Foldable t_a6KF2)
      ($dAlternative_a6KF7 :: Alternative f_a6KF3) ->
      foldr
        @ t_a6KF2
        $dFoldable_a6KF6
        @ (f_a6KF3 a_a6KF4)
        @ (f_a6KF3 a_a6KF4)
        (<|> @ f_a6KF3 $dAlternative_a6KF7 @ a_a6KF4)
        (empty @ f_a6KF3 $dAlternative_a6KF7 @ a_a6KF4)

-- RHS size: {terms: 14, types: 26, coercions: 0, joins: 0/1}
msum [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (m :: * -> *) a.
     (Foldable t, MonadPlus m) =>
     t (m a) -> m a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*U(A,1*U,1*U,A,A),A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (t_a6KFl :: * -> *))
                 (@ (m_a6KFm :: * -> *))
                 (@ a_a6KFn)
                 ($dFoldable_a6KFp [Occ=Once] :: Foldable t_a6KFl)
                 ($dMonadPlus_a6KFq [Occ=OnceL] :: MonadPlus m_a6KFm) ->
                 let {
                   $dAlternative_a6KF7 :: Alternative m_a6KFm
                   [LclId]
                   $dAlternative_a6KF7
                     = GHC.Base.$p1MonadPlus @ m_a6KFm $dMonadPlus_a6KFq } in
                 foldr
                   @ t_a6KFl
                   $dFoldable_a6KFp
                   @ (m_a6KFm a_a6KFn)
                   @ (m_a6KFm a_a6KFn)
                   (<|> @ m_a6KFm $dAlternative_a6KF7 @ a_a6KFn)
                   (empty @ m_a6KFm $dAlternative_a6KF7 @ a_a6KFn)}]
msum
  = \ (@ (t_a6KFl :: * -> *))
      (@ (m_a6KFm :: * -> *))
      (@ a_a6KFn)
      ($dFoldable_a6KFp :: Foldable t_a6KFl)
      ($dMonadPlus_a6KFq :: MonadPlus m_a6KFm) ->
      let {
        $dAlternative_s6MKp [Dmd=<L,U(A,1*U,1*U,A,A)>]
          :: Alternative m_a6KFm
        [LclId]
        $dAlternative_s6MKp
          = GHC.Base.$p1MonadPlus @ m_a6KFm $dMonadPlus_a6KFq } in
      foldr
        @ t_a6KFl
        $dFoldable_a6KFp
        @ (m_a6KFm a_a6KFn)
        @ (m_a6KFm a_a6KFn)
        (<|> @ m_a6KFm $dAlternative_s6MKp @ a_a6KFn)
        (empty @ m_a6KFm $dAlternative_s6MKp @ a_a6KFn)

-- RHS size: {terms: 9, types: 18, coercions: 0, joins: 0/0}
concat [InlPrag=INLINE (sat-args=1)]
  :: forall (t :: * -> *) a. Foldable t => t [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (t_a6KEK :: * -> *))
                 (@ a_a6KEL)
                 ($dFoldable_a6KEN [Occ=Once] :: Foldable t_a6KEK)
                 (xs_a6Ka6 [Occ=Once] :: t_a6KEK [a_a6KEL]) ->
                 build
                   @ a_a6KEL
                   (\ (@ b_a6KEQ)
                      (c_a6Ka7 [Occ=OnceL, OS=OneShot] :: a_a6KEL -> b_a6KEQ -> b_a6KEQ)
                      (n_a6Ka8 [Occ=Once, OS=OneShot] :: b_a6KEQ) ->
                      foldr
                        @ t_a6KEK
                        $dFoldable_a6KEN
                        @ [a_a6KEL]
                        @ b_a6KEQ
                        (\ (x_a6Ka9 [Occ=Once] :: [a_a6KEL])
                           (y_a6Kaa [Occ=Once] :: b_a6KEQ) ->
                           List.foldr @ a_a6KEL @ b_a6KEQ c_a6Ka7 y_a6Kaa x_a6Ka9)
                        n_a6Ka8
                        xs_a6Ka6)}]
concat
  = \ (@ (t_a6KEK :: * -> *))
      (@ a_a6KEL)
      ($dFoldable_a6KEN :: Foldable t_a6KEK)
      (xs_a6Ka6 :: t_a6KEK [a_a6KEL]) ->
      foldr
        @ t_a6KEK
        $dFoldable_a6KEN
        @ [a_a6KEL]
        @ [a_a6KEL]
        (++ @ a_a6KEL)
        (GHC.Types.[] @ a_a6KEL)
        xs_a6Ka6

-- RHS size: {terms: 16, types: 24, coercions: 0, joins: 0/0}
concatMap [InlPrag=INLINE (sat-args=2)]
  :: forall (t :: * -> *) a b. Foldable t => (a -> [b]) -> t a -> [b]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (t_a6KEr :: * -> *))
                 (@ a_a6KEs)
                 (@ b_a6KEt)
                 ($dFoldable_a6KEv [Occ=Once] :: Foldable t_a6KEr)
                 (f_a6Kab [Occ=OnceL!] :: a_a6KEs -> [b_a6KEt])
                 (xs_a6Kac [Occ=Once] :: t_a6KEr a_a6KEs) ->
                 build
                   @ b_a6KEt
                   (\ (@ b1_a6KEy)
                      (c_a6Kad [Occ=OnceL, OS=OneShot]
                         :: b_a6KEt -> b1_a6KEy -> b1_a6KEy)
                      (n_a6Kae [Occ=Once, OS=OneShot] :: b1_a6KEy) ->
                      foldr
                        @ t_a6KEr
                        $dFoldable_a6KEv
                        @ a_a6KEs
                        @ b1_a6KEy
                        (\ (x_a6Kaf [Occ=Once] :: a_a6KEs)
                           (b2_a6Kag [Occ=Once] :: b1_a6KEy) ->
                           List.foldr @ b_a6KEt @ b1_a6KEy c_a6Kad b2_a6Kag (f_a6Kab x_a6Kaf))
                        n_a6Kae
                        xs_a6Kac)}]
concatMap
  = \ (@ (t_a6KEr :: * -> *))
      (@ a_a6KEs)
      (@ b_a6KEt)
      ($dFoldable_a6KEv :: Foldable t_a6KEr)
      (f_a6Kab :: a_a6KEs -> [b_a6KEt])
      (xs_a6Kac :: t_a6KEr a_a6KEs) ->
      foldr
        @ t_a6KEr
        $dFoldable_a6KEv
        @ a_a6KEs
        @ [b_a6KEt]
        (\ (x_a6Kaf :: a_a6KEs) (b1_a6Kag :: [b_a6KEt]) ->
           ++ @ b_a6KEt (f_a6Kab x_a6Kaf) b1_a6Kag)
        (GHC.Types.[] @ b_a6KEt)
        xs_a6Kac

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Foldable.and2 :: Bool -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (v_B1 [Occ=Once] :: Bool) -> v_B1}]
Data.Foldable.and2 = \ (v_B1 :: Bool) -> v_B1

-- RHS size: {terms: 6, types: 9, coercions: 4, joins: 0/0}
Data.Foldable.and1
  :: forall (t :: * -> *). Foldable t => t Bool -> All
[GblId,
 Arity=1,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_a6KEe :: * -> *))
                 ($dFoldable_a6KEg [Occ=Once] :: Foldable t_a6KEe) ->
                 foldMap
                   @ t_a6KEe
                   $dFoldable_a6KEg
                   @ All
                   @ Bool
                   Data.Semigroup.Internal.$fMonoidAll
                   (Data.Foldable.and2
                    `cast` (<Bool>_R ->_R Sym (Data.Semigroup.Internal.N:All[0])
                            :: (Bool -> Bool :: *) ~R# (Bool -> All :: *)))}]
Data.Foldable.and1
  = \ (@ (t_a6KEe :: * -> *))
      ($dFoldable_a6KEg :: Foldable t_a6KEe) ->
      foldMap
        @ t_a6KEe
        $dFoldable_a6KEg
        @ All
        @ Bool
        Data.Semigroup.Internal.$fMonoidAll
        (Data.Foldable.and2
         `cast` (<Bool>_R ->_R Sym (Data.Semigroup.Internal.N:All[0])
                 :: (Bool -> Bool :: *) ~R# (Bool -> All :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 12, joins: 0/0}
and :: forall (t :: * -> *). Foldable t => t Bool -> Bool
[GblId,
 Arity=1,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Foldable.and1
               `cast` (forall (t :: <* -> *>_N).
                       <Foldable t>_R
                       ->_R <t Bool>_R
                       ->_R Data.Semigroup.Internal.N:All[0]
                       :: (forall (t :: * -> *). Foldable t => t Bool -> All :: *)
                          ~R# (forall (t :: * -> *). Foldable t => t Bool -> Bool :: *))}]
and
  = Data.Foldable.and1
    `cast` (forall (t :: <* -> *>_N).
            <Foldable t>_R
            ->_R <t Bool>_R
            ->_R Data.Semigroup.Internal.N:All[0]
            :: (forall (t :: * -> *). Foldable t => t Bool -> All :: *)
               ~R# (forall (t :: * -> *). Foldable t => t Bool -> Bool :: *))

-- RHS size: {terms: 6, types: 9, coercions: 4, joins: 0/0}
Data.Foldable.or1
  :: forall (t :: * -> *). Foldable t => t Bool -> Data.Monoid.Any
[GblId,
 Arity=1,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_a6KE1 :: * -> *))
                 ($dFoldable_a6KE3 [Occ=Once] :: Foldable t_a6KE1) ->
                 foldMap
                   @ t_a6KE1
                   $dFoldable_a6KE3
                   @ Data.Monoid.Any
                   @ Bool
                   Data.Semigroup.Internal.$fMonoidAny
                   (Data.Foldable.and2
                    `cast` (<Bool>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                            :: (Bool -> Bool :: *) ~R# (Bool -> Data.Monoid.Any :: *)))}]
Data.Foldable.or1
  = \ (@ (t_a6KE1 :: * -> *))
      ($dFoldable_a6KE3 :: Foldable t_a6KE1) ->
      foldMap
        @ t_a6KE1
        $dFoldable_a6KE3
        @ Data.Monoid.Any
        @ Bool
        Data.Semigroup.Internal.$fMonoidAny
        (Data.Foldable.and2
         `cast` (<Bool>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                 :: (Bool -> Bool :: *) ~R# (Bool -> Data.Monoid.Any :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 12, joins: 0/0}
or :: forall (t :: * -> *). Foldable t => t Bool -> Bool
[GblId,
 Arity=1,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Foldable.or1
               `cast` (forall (t :: <* -> *>_N).
                       <Foldable t>_R
                       ->_R <t Bool>_R
                       ->_R Data.Semigroup.Internal.N:Any[0]
                       :: (forall (t :: * -> *).
                           Foldable t =>
                           t Bool -> Data.Monoid.Any :: *)
                          ~R# (forall (t :: * -> *). Foldable t => t Bool -> Bool :: *))}]
or
  = Data.Foldable.or1
    `cast` (forall (t :: <* -> *>_N).
            <Foldable t>_R
            ->_R <t Bool>_R
            ->_R Data.Semigroup.Internal.N:Any[0]
            :: (forall (t :: * -> *).
                Foldable t =>
                t Bool -> Data.Monoid.Any :: *)
               ~R# (forall (t :: * -> *). Foldable t => t Bool -> Bool :: *))

-- RHS size: {terms: 8, types: 13, coercions: 4, joins: 0/0}
Data.Foldable.any1
  :: forall (t :: * -> *) a.
     Foldable t =>
     (a -> Bool) -> t a -> Data.Monoid.Any
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_a6KDH :: * -> *))
                 (@ a_a6KDI)
                 ($dFoldable_a6KDK [Occ=Once] :: Foldable t_a6KDH)
                 (p_a6Kah [Occ=Once] :: a_a6KDI -> Bool) ->
                 foldMap
                   @ t_a6KDH
                   $dFoldable_a6KDK
                   @ Data.Monoid.Any
                   @ a_a6KDI
                   Data.Semigroup.Internal.$fMonoidAny
                   (p_a6Kah
                    `cast` (<a_a6KDI>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                            :: (a_a6KDI -> Bool :: *) ~R# (a_a6KDI -> Data.Monoid.Any :: *)))}]
Data.Foldable.any1
  = \ (@ (t_a6KDH :: * -> *))
      (@ a_a6KDI)
      ($dFoldable_a6KDK :: Foldable t_a6KDH)
      (p_a6Kah :: a_a6KDI -> Bool) ->
      foldMap
        @ t_a6KDH
        $dFoldable_a6KDK
        @ Data.Monoid.Any
        @ a_a6KDI
        Data.Semigroup.Internal.$fMonoidAny
        (p_a6Kah
         `cast` (<a_a6KDI>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                 :: (a_a6KDI -> Bool :: *) ~R# (a_a6KDI -> Data.Monoid.Any :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 18, joins: 0/0}
any
  :: forall (t :: * -> *) a. Foldable t => (a -> Bool) -> t a -> Bool
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Foldable.any1
               `cast` (forall (t :: <* -> *>_N) (a :: <*>_N).
                       <Foldable t>_R
                       ->_R <a -> Bool>_R
                       ->_R <t a>_R
                       ->_R Data.Semigroup.Internal.N:Any[0]
                       :: (forall (t :: * -> *) a.
                           Foldable t =>
                           (a -> Bool) -> t a -> Data.Monoid.Any :: *)
                          ~R# (forall (t :: * -> *) a.
                               Foldable t =>
                               (a -> Bool) -> t a -> Bool :: *))}]
any
  = Data.Foldable.any1
    `cast` (forall (t :: <* -> *>_N) (a :: <*>_N).
            <Foldable t>_R
            ->_R <a -> Bool>_R
            ->_R <t a>_R
            ->_R Data.Semigroup.Internal.N:Any[0]
            :: (forall (t :: * -> *) a.
                Foldable t =>
                (a -> Bool) -> t a -> Data.Monoid.Any :: *)
               ~R# (forall (t :: * -> *) a.
                    Foldable t =>
                    (a -> Bool) -> t a -> Bool :: *))

-- RHS size: {terms: 11, types: 15, coercions: 4, joins: 0/0}
$dmelem1_r6OSW
  :: forall (t :: * -> *).
     Foldable t =>
     forall a. Eq a => a -> t a -> Data.Monoid.Any
[GblId,
 Arity=3,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []]
$dmelem1_r6OSW
  = \ (@ (t_X6Kjv :: * -> *))
      ($dFoldable_X6KWy :: Foldable t_X6Kjv)
      (@ a_a6KO9)
      ($dEq_a6KOb :: Eq a_a6KO9)
      (eta_B1 :: a_a6KO9) ->
      foldMap
        @ t_X6Kjv
        $dFoldable_X6KWy
        @ Data.Monoid.Any
        @ a_a6KO9
        Data.Semigroup.Internal.$fMonoidAny
        ((== @ a_a6KO9 $dEq_a6KOb eta_B1)
         `cast` (<a_a6KO9>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                 :: (a_a6KO9 -> Bool :: *) ~R# (a_a6KO9 -> Data.Monoid.Any :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 20, joins: 0/0}
Data.Foldable.$dmelem
  :: forall (t :: * -> *).
     Foldable t =>
     forall a. Eq a => a -> t a -> Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_X6KuK :: * -> *))
                 ($dFoldable_X6L7O [Occ=OnceL] :: Foldable t_X6KuK)
                 (@ a_X6KZq)
                 ($dEq_X6KZt [Occ=OnceL] :: Eq a_X6KZq) ->
                 let {
                   g_i6HAk [Occ=OnceL!] :: a_X6KZq -> a_X6KZq -> Bool
                   [LclId]
                   g_i6HAk = == @ a_X6KZq $dEq_X6KZt } in
                 (\ (x_i6HAl [Occ=Once] :: a_X6KZq) ->
                    foldMap
                      @ t_X6KuK
                      $dFoldable_X6L7O
                      @ Data.Monoid.Any
                      @ a_X6KZq
                      Data.Semigroup.Internal.$fMonoidAny
                      ((g_i6HAk x_i6HAl)
                       `cast` (<a_X6KZq>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                               :: (a_X6KZq -> Bool :: *) ~R# (a_X6KZq -> Data.Monoid.Any :: *))))
                 `cast` (<a_X6KZq>_R
                         ->_R <t_X6KuK a_X6KZq>_R
                         ->_R Data.Semigroup.Internal.N:Any[0]
                         :: (a_X6KZq -> t_X6KuK a_X6KZq -> Data.Monoid.Any :: *)
                            ~R# (a_X6KZq -> t_X6KuK a_X6KZq -> Bool :: *))}]
Data.Foldable.$dmelem
  = $dmelem1_r6OSW
    `cast` (forall (t :: <* -> *>_N).
            <Foldable t>_R
            ->_R forall (a :: <*>_N).
                 <Eq a>_R
                 ->_R <a>_R
                 ->_R <t a>_R
                 ->_R Data.Semigroup.Internal.N:Any[0]
            :: (forall (t :: * -> *).
                Foldable t =>
                forall a. Eq a => a -> t a -> Data.Monoid.Any :: *)
               ~R# (forall (t :: * -> *).
                    Foldable t =>
                    forall a. Eq a => a -> t a -> Bool :: *))

-- RHS size: {terms: 8, types: 15, coercions: 6, joins: 0/0}
Data.Foldable.$fFoldableURec11
  :: forall a. Eq a => a -> URec Word a -> Data.Monoid.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KRR)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (eta1_Xbk [Occ=Once] :: URec Word a_a6KRR) ->
                 case eta1_Xbk
                      `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_a6KRR>_N
                              :: (URec Word a_a6KRR :: *)
                                 ~R# (GHC.Generics.R:UReckWordp * a_a6KRR :: *))
                 of
                 { UWord _ [Occ=Dead] ->
                 GHC.Types.False
                 `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                         :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
                 }}]
Data.Foldable.$fFoldableURec11
  = \ (@ a_a6KRR)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (eta1_Xbk :: URec Word a_a6KRR) ->
      case eta1_Xbk
           `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_a6KRR>_N
                   :: (URec Word a_a6KRR :: *)
                      ~R# (GHC.Generics.R:UReckWordp * a_a6KRR :: *))
      of
      { UWord a1_a6Kp2 ->
      GHC.Types.False
      `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
              :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
      }

-- RHS size: {terms: 8, types: 15, coercions: 7, joins: 0/0}
Data.Foldable.$fFoldableURec8
  :: forall a. Num a => URec Word a -> Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KSl)
                 ($dNum_a6KSn [Occ=Once] :: Num a_a6KSl)
                 (ds_d6M1K [Occ=Once] :: URec Word a_a6KSl) ->
                 case ds_d6M1K
                      `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_a6KSl>_N
                              :: (URec Word a_a6KSl :: *)
                                 ~R# (GHC.Generics.R:UReckWordp * a_a6KSl :: *))
                 of
                 { UWord _ [Occ=Dead] ->
                 (Data.Semigroup.Internal.$fMonoidSum2 @ a_a6KSl $dNum_a6KSn)
                 `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6KSl>_R)
                         :: (a_a6KSl :: *) ~R# (Sum a_a6KSl :: *))
                 }}]
Data.Foldable.$fFoldableURec8
  = \ (@ a_a6KSl)
      ($dNum_a6KSn :: Num a_a6KSl)
      (ds_d6M1K :: URec Word a_a6KSl) ->
      case ds_d6M1K
           `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_a6KSl>_N
                   :: (URec Word a_a6KSl :: *)
                      ~R# (GHC.Generics.R:UReckWordp * a_a6KSl :: *))
      of
      { UWord a1_a6Kp2 ->
      (Data.Semigroup.Internal.$fMonoidSum2 @ a_a6KSl $dNum_a6KSn)
      `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6KSl>_R)
              :: (a_a6KSl :: *) ~R# (Sum a_a6KSl :: *))
      }

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:*:2 :: forall a. a
[GblId, Str=x]
Data.Foldable.$fFoldable:*:2
  = \ (@ a_a6KSb) ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6KSb Data.Foldable.$fFoldableK2

-- RHS size: {terms: 3, types: 8, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec9 :: forall a. URec Word a -> a
[GblId,
 Arity=1,
 Str=<B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KSb) (x_X6HLQ [Occ=Once] :: URec Word a_a6KSb) ->
                 case x_X6HLQ
                      `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_a6KSb>_N
                              :: (URec Word a_a6KSb :: *)
                                 ~R# (GHC.Generics.R:UReckWordp * a_a6KSb :: *))
                 of
                 { UWord _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:2 @ a_a6KSb
                 }}]
Data.Foldable.$fFoldableURec9
  = \ (@ a_a6KSb) _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:2 @ a_a6KSb

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec_$cminimum
  :: forall a. Ord a => URec Word a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6KSb) _ [Occ=Dead] ->
                 Data.Foldable.$fFoldableURec9 @ a_a6KSb}]
Data.Foldable.$fFoldableURec_$cminimum
  = \ (@ a_a6KSb) _ [Occ=Dead] (eta_B1 :: URec Word a_a6KSb) ->
      Data.Foldable.$fFoldableURec9 @ a_a6KSb eta_B1

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:*:3 :: forall a. a
[GblId, Str=x]
Data.Foldable.$fFoldable:*:3
  = \ (@ a_a6KS1) ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6KS1 Data.Foldable.$fFoldableK4

-- RHS size: {terms: 3, types: 8, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec10 :: forall a. URec Word a -> a
[GblId,
 Arity=1,
 Str=<B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KS1) (x_X6HLR [Occ=Once] :: URec Word a_a6KS1) ->
                 case x_X6HLR
                      `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_a6KS1>_N
                              :: (URec Word a_a6KS1 :: *)
                                 ~R# (GHC.Generics.R:UReckWordp * a_a6KS1 :: *))
                 of
                 { UWord _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:3 @ a_a6KS1
                 }}]
Data.Foldable.$fFoldableURec10
  = \ (@ a_a6KS1) _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:3 @ a_a6KS1

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec_$cmaximum
  :: forall a. Ord a => URec Word a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6KS1) _ [Occ=Dead] ->
                 Data.Foldable.$fFoldableURec10 @ a_a6KS1}]
Data.Foldable.$fFoldableURec_$cmaximum
  = \ (@ a_a6KS1) _ [Occ=Dead] (eta_B1 :: URec Word a_a6KS1) ->
      Data.Foldable.$fFoldableURec10 @ a_a6KS1 eta_B1

-- RHS size: {terms: 4, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec_$cfoldr1
  :: forall a. (a -> a -> a) -> URec Word a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KRe)
                 _ [Occ=Dead]
                 (xs_a6K7K [Occ=Once] :: URec Word a_a6KRe) ->
                 case xs_a6K7K
                      `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_a6KRe>_N
                              :: (URec Word a_a6KRe :: *)
                                 ~R# (GHC.Generics.R:UReckWordp * a_a6KRe :: *))
                 of
                 { UWord _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:8 @ a_a6KRe
                 }}]
Data.Foldable.$fFoldableURec_$cfoldr1
  = \ (@ a_a6KRe) _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:8 @ a_a6KRe

-- RHS size: {terms: 9, types: 18, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> URec Word a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a6KR4)
                 (@ a_a6KR5)
                 _ [Occ=Dead]
                 (z0_a6K7D [Occ=Once] :: b_a6KR4)
                 (xs_a6K7E [Occ=Once] :: URec Word a_a6KR5) ->
                 case xs_a6K7E
                      `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_a6KR5>_N
                              :: (URec Word a_a6KR5 :: *)
                                 ~R# (GHC.Generics.R:UReckWordp * a_a6KR5 :: *))
                 of
                 { UWord _ [Occ=Dead] ->
                 z0_a6K7D
                 }}]
Data.Foldable.$fFoldableURec_$cfoldl'
  = \ (@ b_a6KR4)
      (@ a_a6KR5)
      _ [Occ=Dead]
      (z0_a6K7D :: b_a6KR4)
      (xs_a6K7E :: URec Word a_a6KR5) ->
      case xs_a6K7E
           `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_a6KR5>_N
                   :: (URec Word a_a6KR5 :: *)
                      ~R# (GHC.Generics.R:UReckWordp * a_a6KR5 :: *))
      of
      { UWord a1_a6Kp0 ->
      z0_a6K7D
      }

-- RHS size: {terms: 6, types: 12, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec_$clength
  :: forall a. URec Word a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KRJ) (xs_a6K7E [Occ=Once] :: URec Word a_a6KRJ) ->
                 case xs_a6K7E
                      `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_a6KRJ>_N
                              :: (URec Word a_a6KRJ :: *)
                                 ~R# (GHC.Generics.R:UReckWordp * a_a6KRJ :: *))
                 of
                 { UWord _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:4
                 }}]
Data.Foldable.$fFoldableURec_$clength
  = \ (@ a_a6KRJ) (xs_a6K7E :: URec Word a_a6KRJ) ->
      case xs_a6K7E
           `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_a6KRJ>_N
                   :: (URec Word a_a6KRJ :: *)
                      ~R# (GHC.Generics.R:UReckWordp * a_a6KRJ :: *))
      of
      { UWord a1_a6Kp0 ->
      Data.Foldable.$fFoldable:*:4
      }

-- RHS size: {terms: 4, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec_$cfoldl1
  :: forall a. (a -> a -> a) -> URec Word a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KRm)
                 _ [Occ=Dead]
                 (xs_a6K7Q [Occ=Once] :: URec Word a_a6KRm) ->
                 case xs_a6K7Q
                      `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_a6KRm>_N
                              :: (URec Word a_a6KRm :: *)
                                 ~R# (GHC.Generics.R:UReckWordp * a_a6KRm :: *))
                 of
                 { UWord _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:6 @ a_a6KRm
                 }}]
Data.Foldable.$fFoldableURec_$cfoldl1
  = \ (@ a_a6KRm) _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:6 @ a_a6KRm

-- RHS size: {terms: 8, types: 15, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec_$cfold
  :: forall m. Monoid m => URec Word m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_a6KQf)
                 ($dMonoid_a6KQh [Occ=Once] :: Monoid m_a6KQf)
                 (ds_d6M1K [Occ=Once] :: URec Word m_a6KQf) ->
                 case ds_d6M1K
                      `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <m_a6KQf>_N
                              :: (URec Word m_a6KQf :: *)
                                 ~R# (GHC.Generics.R:UReckWordp * m_a6KQf :: *))
                 of
                 { UWord _ [Occ=Dead] ->
                 mempty @ m_a6KQf $dMonoid_a6KQh
                 }}]
Data.Foldable.$fFoldableURec_$cfold
  = \ (@ m_a6KQf)
      ($dMonoid_a6KQh :: Monoid m_a6KQf)
      (ds_d6M1K :: URec Word m_a6KQf) ->
      case ds_d6M1K
           `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <m_a6KQf>_N
                   :: (URec Word m_a6KQf :: *)
                      ~R# (GHC.Generics.R:UReckWordp * m_a6KQf :: *))
      of
      { UWord a1_a6Kp2 ->
      mempty @ m_a6KQf $dMonoid_a6KQh
      }

-- RHS size: {terms: 8, types: 15, coercions: 7, joins: 0/0}
Data.Foldable.$fFoldableURec7
  :: forall a. Num a => URec Word a -> Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KSv)
                 ($dNum_a6KSx [Occ=Once] :: Num a_a6KSv)
                 (ds_d6M1K [Occ=Once] :: URec Word a_a6KSv) ->
                 case ds_d6M1K
                      `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_a6KSv>_N
                              :: (URec Word a_a6KSv :: *)
                                 ~R# (GHC.Generics.R:UReckWordp * a_a6KSv :: *))
                 of
                 { UWord _ [Occ=Dead] ->
                 (Data.Semigroup.Internal.$fMonoidProduct2 @ a_a6KSv $dNum_a6KSx)
                 `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6KSv>_R)
                         :: (a_a6KSv :: *) ~R# (Product a_a6KSv :: *))
                 }}]
Data.Foldable.$fFoldableURec7
  = \ (@ a_a6KSv)
      ($dNum_a6KSx :: Num a_a6KSv)
      (ds_d6M1K :: URec Word a_a6KSv) ->
      case ds_d6M1K
           `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_a6KSv>_N
                   :: (URec Word a_a6KSv :: *)
                      ~R# (GHC.Generics.R:UReckWordp * a_a6KSv :: *))
      of
      { UWord a1_a6Kp2 ->
      (Data.Semigroup.Internal.$fMonoidProduct2 @ a_a6KSv $dNum_a6KSx)
      `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6KSv>_R)
              :: (a_a6KSv :: *) ~R# (Product a_a6KSv :: *))
      }

-- RHS size: {terms: 6, types: 13, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. URec Word a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a6KRu) (t_a6K7V [Occ=Once] :: URec Word a_a6KRu) ->
                 build
                   @ a_a6KRu
                   (\ (@ b_a6KNB)
                      _ [Occ=Dead, OS=OneShot]
                      (n_a6K7X [Occ=Once, OS=OneShot] :: b_a6KNB) ->
                      case t_a6K7V
                           `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_a6KRu>_N
                                   :: (URec Word a_a6KRu :: *)
                                      ~R# (GHC.Generics.R:UReckWordp * a_a6KRu :: *))
                      of
                      { UWord _ [Occ=Dead] ->
                      n_a6K7X
                      })}]
Data.Foldable.$fFoldableURec_$ctoList
  = \ (@ a_a6KRu) (eta_XbH :: URec Word a_a6KRu) ->
      case eta_XbH
           `cast` (GHC.Generics.D:R:UReckWordp0[0] <*>_N <a_a6KRu>_N
                   :: (URec Word a_a6KRu :: *)
                      ~R# (GHC.Generics.R:UReckWordp * a_a6KRu :: *))
      of
      { UWord a1_a6Kp0 ->
      GHC.Types.[] @ a_a6KRu
      }

-- RHS size: {terms: 17, types: 4, coercions: 43, joins: 0/0}
Data.Foldable.$fFoldableURec [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable (URec Word)
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: URec Word
                                Data.Foldable.$fFoldableURec_$cfold
                                Data.Foldable.$fFoldableURec_$cfoldMap
                                Data.Foldable.$fFoldableURec_$cfoldr
                                Data.Foldable.$fFoldableURec_$cfoldr
                                Data.Foldable.$fFoldableURec_$cfoldl'
                                Data.Foldable.$fFoldableURec_$cfoldl'
                                Data.Foldable.$fFoldableURec_$cfoldr1
                                Data.Foldable.$fFoldableURec_$cfoldl1
                                Data.Foldable.$fFoldableURec_$ctoList
                                Data.Foldable.$fFoldableURec_$cnull
                                Data.Foldable.$fFoldableURec_$clength
                                Data.Foldable.$fFoldableURec11
                                `cast` (forall (a :: <*>_N).
                                        <Eq a>_R
                                        ->_R <a>_R
                                        ->_R <URec Word a>_R
                                        ->_R Data.Semigroup.Internal.N:Any[0]
                                        :: (forall a.
                                            Eq a =>
                                            a -> URec Word a -> Data.Monoid.Any :: *)
                                           ~R# (forall a. Eq a => a -> URec Word a -> Bool :: *))
                                Data.Foldable.$fFoldableURec_$cmaximum
                                Data.Foldable.$fFoldableURec_$cminimum
                                Data.Foldable.$fFoldableURec8
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <URec Word a>_R
                                        ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
                                        :: (forall a. Num a => URec Word a -> Sum a :: *)
                                           ~R# (forall a. Num a => URec Word a -> a :: *))
                                Data.Foldable.$fFoldableURec7
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <URec Word a>_R
                                        ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
                                        :: (forall a. Num a => URec Word a -> Product a :: *)
                                           ~R# (forall a. Num a => URec Word a -> a :: *))]
Data.Foldable.$fFoldableURec
  = Data.Foldable.C:Foldable
      @ (URec Word)
      Data.Foldable.$fFoldableURec_$cfold
      Data.Foldable.$fFoldableURec_$cfoldMap
      Data.Foldable.$fFoldableURec_$cfoldr
      Data.Foldable.$fFoldableURec_$cfoldr
      Data.Foldable.$fFoldableURec_$cfoldl'
      Data.Foldable.$fFoldableURec_$cfoldl'
      Data.Foldable.$fFoldableURec_$cfoldr1
      Data.Foldable.$fFoldableURec_$cfoldl1
      Data.Foldable.$fFoldableURec_$ctoList
      Data.Foldable.$fFoldableURec_$cnull
      Data.Foldable.$fFoldableURec_$clength
      (Data.Foldable.$fFoldableURec11
       `cast` (forall (a :: <*>_N).
               <Eq a>_R
               ->_R <a>_R
               ->_R <URec Word a>_R
               ->_R Data.Semigroup.Internal.N:Any[0]
               :: (forall a. Eq a => a -> URec Word a -> Data.Monoid.Any :: *)
                  ~R# (forall a. Eq a => a -> URec Word a -> Bool :: *)))
      Data.Foldable.$fFoldableURec_$cmaximum
      Data.Foldable.$fFoldableURec_$cminimum
      (Data.Foldable.$fFoldableURec8
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <URec Word a>_R
               ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall a. Num a => URec Word a -> Sum a :: *)
                  ~R# (forall a. Num a => URec Word a -> a :: *)))
      (Data.Foldable.$fFoldableURec7
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <URec Word a>_R
               ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall a. Num a => URec Word a -> Product a :: *)
                  ~R# (forall a. Num a => URec Word a -> a :: *)))

-- RHS size: {terms: 8, types: 15, coercions: 6, joins: 0/0}
Data.Foldable.$fFoldableURec16
  :: forall a. Eq a => a -> URec Int a -> Data.Monoid.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KUj)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (eta1_Xnv [Occ=Once] :: URec Int a_a6KUj) ->
                 case eta1_Xnv
                      `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_a6KUj>_N
                              :: (URec Int a_a6KUj :: *)
                                 ~R# (GHC.Generics.R:UReckIntp * a_a6KUj :: *))
                 of
                 { UInt _ [Occ=Dead] ->
                 GHC.Types.False
                 `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                         :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
                 }}]
Data.Foldable.$fFoldableURec16
  = \ (@ a_a6KUj)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (eta1_Xnv :: URec Int a_a6KUj) ->
      case eta1_Xnv
           `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_a6KUj>_N
                   :: (URec Int a_a6KUj :: *)
                      ~R# (GHC.Generics.R:UReckIntp * a_a6KUj :: *))
      of
      { UInt a1_a6Kp8 ->
      GHC.Types.False
      `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
              :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
      }

-- RHS size: {terms: 8, types: 15, coercions: 7, joins: 0/0}
Data.Foldable.$fFoldableURec13
  :: forall a. Num a => URec Int a -> Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KUN)
                 ($dNum_a6KUP [Occ=Once] :: Num a_a6KUN)
                 (ds_d6M1T [Occ=Once] :: URec Int a_a6KUN) ->
                 case ds_d6M1T
                      `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_a6KUN>_N
                              :: (URec Int a_a6KUN :: *)
                                 ~R# (GHC.Generics.R:UReckIntp * a_a6KUN :: *))
                 of
                 { UInt _ [Occ=Dead] ->
                 (Data.Semigroup.Internal.$fMonoidSum2 @ a_a6KUN $dNum_a6KUP)
                 `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6KUN>_R)
                         :: (a_a6KUN :: *) ~R# (Sum a_a6KUN :: *))
                 }}]
Data.Foldable.$fFoldableURec13
  = \ (@ a_a6KUN)
      ($dNum_a6KUP :: Num a_a6KUN)
      (ds_d6M1T :: URec Int a_a6KUN) ->
      case ds_d6M1T
           `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_a6KUN>_N
                   :: (URec Int a_a6KUN :: *)
                      ~R# (GHC.Generics.R:UReckIntp * a_a6KUN :: *))
      of
      { UInt a1_a6Kp8 ->
      (Data.Semigroup.Internal.$fMonoidSum2 @ a_a6KUN $dNum_a6KUP)
      `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6KUN>_R)
              :: (a_a6KUN :: *) ~R# (Sum a_a6KUN :: *))
      }

-- RHS size: {terms: 3, types: 8, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec14 :: forall a. URec Int a -> a
[GblId,
 Arity=1,
 Str=<B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KUD) (x_X6HLQ [Occ=Once] :: URec Int a_a6KUD) ->
                 case x_X6HLQ
                      `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_a6KUD>_N
                              :: (URec Int a_a6KUD :: *)
                                 ~R# (GHC.Generics.R:UReckIntp * a_a6KUD :: *))
                 of
                 { UInt _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:2 @ a_a6KUD
                 }}]
Data.Foldable.$fFoldableURec14
  = \ (@ a_a6KUD) _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:2 @ a_a6KUD

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec0_$cminimum
  :: forall a. Ord a => URec Int a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6KUD) _ [Occ=Dead] ->
                 Data.Foldable.$fFoldableURec14 @ a_a6KUD}]
Data.Foldable.$fFoldableURec0_$cminimum
  = \ (@ a_a6KUD) _ [Occ=Dead] (eta_B1 :: URec Int a_a6KUD) ->
      Data.Foldable.$fFoldableURec14 @ a_a6KUD eta_B1

-- RHS size: {terms: 3, types: 8, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec15 :: forall a. URec Int a -> a
[GblId,
 Arity=1,
 Str=<B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KUt) (x_X6HLR [Occ=Once] :: URec Int a_a6KUt) ->
                 case x_X6HLR
                      `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_a6KUt>_N
                              :: (URec Int a_a6KUt :: *)
                                 ~R# (GHC.Generics.R:UReckIntp * a_a6KUt :: *))
                 of
                 { UInt _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:3 @ a_a6KUt
                 }}]
Data.Foldable.$fFoldableURec15
  = \ (@ a_a6KUt) _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:3 @ a_a6KUt

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec0_$cmaximum
  :: forall a. Ord a => URec Int a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6KUt) _ [Occ=Dead] ->
                 Data.Foldable.$fFoldableURec15 @ a_a6KUt}]
Data.Foldable.$fFoldableURec0_$cmaximum
  = \ (@ a_a6KUt) _ [Occ=Dead] (eta_B1 :: URec Int a_a6KUt) ->
      Data.Foldable.$fFoldableURec15 @ a_a6KUt eta_B1

-- RHS size: {terms: 4, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec0_$cfoldr1
  :: forall a. (a -> a -> a) -> URec Int a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KTG)
                 _ [Occ=Dead]
                 (xs_a6K7K [Occ=Once] :: URec Int a_a6KTG) ->
                 case xs_a6K7K
                      `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_a6KTG>_N
                              :: (URec Int a_a6KTG :: *)
                                 ~R# (GHC.Generics.R:UReckIntp * a_a6KTG :: *))
                 of
                 { UInt _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:8 @ a_a6KTG
                 }}]
Data.Foldable.$fFoldableURec0_$cfoldr1
  = \ (@ a_a6KTG) _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:8 @ a_a6KTG

-- RHS size: {terms: 9, types: 18, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec0_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> URec Int a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a6KTw)
                 (@ a_a6KTx)
                 _ [Occ=Dead]
                 (z0_a6K7D [Occ=Once] :: b_a6KTw)
                 (xs_a6K7E [Occ=Once] :: URec Int a_a6KTx) ->
                 case xs_a6K7E
                      `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_a6KTx>_N
                              :: (URec Int a_a6KTx :: *)
                                 ~R# (GHC.Generics.R:UReckIntp * a_a6KTx :: *))
                 of
                 { UInt _ [Occ=Dead] ->
                 z0_a6K7D
                 }}]
Data.Foldable.$fFoldableURec0_$cfoldl'
  = \ (@ b_a6KTw)
      (@ a_a6KTx)
      _ [Occ=Dead]
      (z0_a6K7D :: b_a6KTw)
      (xs_a6K7E :: URec Int a_a6KTx) ->
      case xs_a6K7E
           `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_a6KTx>_N
                   :: (URec Int a_a6KTx :: *)
                      ~R# (GHC.Generics.R:UReckIntp * a_a6KTx :: *))
      of
      { UInt a1_a6Kp6 ->
      z0_a6K7D
      }

-- RHS size: {terms: 6, types: 12, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec0_$clength
  :: forall a. URec Int a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KUb) (xs_a6K7E [Occ=Once] :: URec Int a_a6KUb) ->
                 case xs_a6K7E
                      `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_a6KUb>_N
                              :: (URec Int a_a6KUb :: *)
                                 ~R# (GHC.Generics.R:UReckIntp * a_a6KUb :: *))
                 of
                 { UInt _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:4
                 }}]
Data.Foldable.$fFoldableURec0_$clength
  = \ (@ a_a6KUb) (xs_a6K7E :: URec Int a_a6KUb) ->
      case xs_a6K7E
           `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_a6KUb>_N
                   :: (URec Int a_a6KUb :: *)
                      ~R# (GHC.Generics.R:UReckIntp * a_a6KUb :: *))
      of
      { UInt a1_a6Kp6 ->
      Data.Foldable.$fFoldable:*:4
      }

-- RHS size: {terms: 4, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec0_$cfoldl1
  :: forall a. (a -> a -> a) -> URec Int a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KTO)
                 _ [Occ=Dead]
                 (xs_a6K7Q [Occ=Once] :: URec Int a_a6KTO) ->
                 case xs_a6K7Q
                      `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_a6KTO>_N
                              :: (URec Int a_a6KTO :: *)
                                 ~R# (GHC.Generics.R:UReckIntp * a_a6KTO :: *))
                 of
                 { UInt _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:6 @ a_a6KTO
                 }}]
Data.Foldable.$fFoldableURec0_$cfoldl1
  = \ (@ a_a6KTO) _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:6 @ a_a6KTO

-- RHS size: {terms: 8, types: 15, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec0_$cfold
  :: forall m. Monoid m => URec Int m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_a6KSH)
                 ($dMonoid_a6KSJ [Occ=Once] :: Monoid m_a6KSH)
                 (ds_d6M1T [Occ=Once] :: URec Int m_a6KSH) ->
                 case ds_d6M1T
                      `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <m_a6KSH>_N
                              :: (URec Int m_a6KSH :: *)
                                 ~R# (GHC.Generics.R:UReckIntp * m_a6KSH :: *))
                 of
                 { UInt _ [Occ=Dead] ->
                 mempty @ m_a6KSH $dMonoid_a6KSJ
                 }}]
Data.Foldable.$fFoldableURec0_$cfold
  = \ (@ m_a6KSH)
      ($dMonoid_a6KSJ :: Monoid m_a6KSH)
      (ds_d6M1T :: URec Int m_a6KSH) ->
      case ds_d6M1T
           `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <m_a6KSH>_N
                   :: (URec Int m_a6KSH :: *)
                      ~R# (GHC.Generics.R:UReckIntp * m_a6KSH :: *))
      of
      { UInt a1_a6Kp8 ->
      mempty @ m_a6KSH $dMonoid_a6KSJ
      }

-- RHS size: {terms: 8, types: 15, coercions: 7, joins: 0/0}
Data.Foldable.$fFoldableURec12
  :: forall a. Num a => URec Int a -> Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KUX)
                 ($dNum_a6KUZ [Occ=Once] :: Num a_a6KUX)
                 (ds_d6M1T [Occ=Once] :: URec Int a_a6KUX) ->
                 case ds_d6M1T
                      `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_a6KUX>_N
                              :: (URec Int a_a6KUX :: *)
                                 ~R# (GHC.Generics.R:UReckIntp * a_a6KUX :: *))
                 of
                 { UInt _ [Occ=Dead] ->
                 (Data.Semigroup.Internal.$fMonoidProduct2 @ a_a6KUX $dNum_a6KUZ)
                 `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6KUX>_R)
                         :: (a_a6KUX :: *) ~R# (Product a_a6KUX :: *))
                 }}]
Data.Foldable.$fFoldableURec12
  = \ (@ a_a6KUX)
      ($dNum_a6KUZ :: Num a_a6KUX)
      (ds_d6M1T :: URec Int a_a6KUX) ->
      case ds_d6M1T
           `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_a6KUX>_N
                   :: (URec Int a_a6KUX :: *)
                      ~R# (GHC.Generics.R:UReckIntp * a_a6KUX :: *))
      of
      { UInt a1_a6Kp8 ->
      (Data.Semigroup.Internal.$fMonoidProduct2 @ a_a6KUX $dNum_a6KUZ)
      `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6KUX>_R)
              :: (a_a6KUX :: *) ~R# (Product a_a6KUX :: *))
      }

-- RHS size: {terms: 6, types: 13, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec0_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. URec Int a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a6KTW) (t_a6K7V [Occ=Once] :: URec Int a_a6KTW) ->
                 build
                   @ a_a6KTW
                   (\ (@ b_a6KNB)
                      _ [Occ=Dead, OS=OneShot]
                      (n_a6K7X [Occ=Once, OS=OneShot] :: b_a6KNB) ->
                      case t_a6K7V
                           `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_a6KTW>_N
                                   :: (URec Int a_a6KTW :: *)
                                      ~R# (GHC.Generics.R:UReckIntp * a_a6KTW :: *))
                      of
                      { UInt _ [Occ=Dead] ->
                      n_a6K7X
                      })}]
Data.Foldable.$fFoldableURec0_$ctoList
  = \ (@ a_a6KTW) (eta_Xc8 :: URec Int a_a6KTW) ->
      case eta_Xc8
           `cast` (GHC.Generics.D:R:UReckIntp0[0] <*>_N <a_a6KTW>_N
                   :: (URec Int a_a6KTW :: *)
                      ~R# (GHC.Generics.R:UReckIntp * a_a6KTW :: *))
      of
      { UInt a1_a6Kp6 ->
      GHC.Types.[] @ a_a6KTW
      }

-- RHS size: {terms: 17, types: 4, coercions: 43, joins: 0/0}
Data.Foldable.$fFoldableURec0 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable (URec Int)
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: URec Int
                                Data.Foldable.$fFoldableURec0_$cfold
                                Data.Foldable.$fFoldableURec0_$cfoldMap
                                Data.Foldable.$fFoldableURec0_$cfoldr
                                Data.Foldable.$fFoldableURec0_$cfoldr
                                Data.Foldable.$fFoldableURec0_$cfoldl'
                                Data.Foldable.$fFoldableURec0_$cfoldl'
                                Data.Foldable.$fFoldableURec0_$cfoldr1
                                Data.Foldable.$fFoldableURec0_$cfoldl1
                                Data.Foldable.$fFoldableURec0_$ctoList
                                Data.Foldable.$fFoldableURec0_$cnull
                                Data.Foldable.$fFoldableURec0_$clength
                                Data.Foldable.$fFoldableURec16
                                `cast` (forall (a :: <*>_N).
                                        <Eq a>_R
                                        ->_R <a>_R
                                        ->_R <URec Int a>_R
                                        ->_R Data.Semigroup.Internal.N:Any[0]
                                        :: (forall a.
                                            Eq a =>
                                            a -> URec Int a -> Data.Monoid.Any :: *)
                                           ~R# (forall a. Eq a => a -> URec Int a -> Bool :: *))
                                Data.Foldable.$fFoldableURec0_$cmaximum
                                Data.Foldable.$fFoldableURec0_$cminimum
                                Data.Foldable.$fFoldableURec13
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <URec Int a>_R
                                        ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
                                        :: (forall a. Num a => URec Int a -> Sum a :: *)
                                           ~R# (forall a. Num a => URec Int a -> a :: *))
                                Data.Foldable.$fFoldableURec12
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <URec Int a>_R
                                        ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
                                        :: (forall a. Num a => URec Int a -> Product a :: *)
                                           ~R# (forall a. Num a => URec Int a -> a :: *))]
Data.Foldable.$fFoldableURec0
  = Data.Foldable.C:Foldable
      @ (URec Int)
      Data.Foldable.$fFoldableURec0_$cfold
      Data.Foldable.$fFoldableURec0_$cfoldMap
      Data.Foldable.$fFoldableURec0_$cfoldr
      Data.Foldable.$fFoldableURec0_$cfoldr
      Data.Foldable.$fFoldableURec0_$cfoldl'
      Data.Foldable.$fFoldableURec0_$cfoldl'
      Data.Foldable.$fFoldableURec0_$cfoldr1
      Data.Foldable.$fFoldableURec0_$cfoldl1
      Data.Foldable.$fFoldableURec0_$ctoList
      Data.Foldable.$fFoldableURec0_$cnull
      Data.Foldable.$fFoldableURec0_$clength
      (Data.Foldable.$fFoldableURec16
       `cast` (forall (a :: <*>_N).
               <Eq a>_R
               ->_R <a>_R
               ->_R <URec Int a>_R
               ->_R Data.Semigroup.Internal.N:Any[0]
               :: (forall a. Eq a => a -> URec Int a -> Data.Monoid.Any :: *)
                  ~R# (forall a. Eq a => a -> URec Int a -> Bool :: *)))
      Data.Foldable.$fFoldableURec0_$cmaximum
      Data.Foldable.$fFoldableURec0_$cminimum
      (Data.Foldable.$fFoldableURec13
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <URec Int a>_R
               ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall a. Num a => URec Int a -> Sum a :: *)
                  ~R# (forall a. Num a => URec Int a -> a :: *)))
      (Data.Foldable.$fFoldableURec12
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <URec Int a>_R
               ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall a. Num a => URec Int a -> Product a :: *)
                  ~R# (forall a. Num a => URec Int a -> a :: *)))

-- RHS size: {terms: 8, types: 15, coercions: 6, joins: 0/0}
Data.Foldable.$fFoldableURec21
  :: forall a. Eq a => a -> URec Float a -> Data.Monoid.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KWL)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (eta1_Xon [Occ=Once] :: URec Float a_a6KWL) ->
                 case eta1_Xon
                      `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_a6KWL>_N
                              :: (URec Float a_a6KWL :: *)
                                 ~R# (GHC.Generics.R:UReckFloatp * a_a6KWL :: *))
                 of
                 { UFloat _ [Occ=Dead] ->
                 GHC.Types.False
                 `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                         :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
                 }}]
Data.Foldable.$fFoldableURec21
  = \ (@ a_a6KWL)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (eta1_Xon :: URec Float a_a6KWL) ->
      case eta1_Xon
           `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_a6KWL>_N
                   :: (URec Float a_a6KWL :: *)
                      ~R# (GHC.Generics.R:UReckFloatp * a_a6KWL :: *))
      of
      { UFloat a1_a6Kpe ->
      GHC.Types.False
      `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
              :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
      }

-- RHS size: {terms: 8, types: 15, coercions: 7, joins: 0/0}
Data.Foldable.$fFoldableURec18
  :: forall a. Num a => URec Float a -> Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KXf)
                 ($dNum_a6KXh [Occ=Once] :: Num a_a6KXf)
                 (ds_d6M22 [Occ=Once] :: URec Float a_a6KXf) ->
                 case ds_d6M22
                      `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_a6KXf>_N
                              :: (URec Float a_a6KXf :: *)
                                 ~R# (GHC.Generics.R:UReckFloatp * a_a6KXf :: *))
                 of
                 { UFloat _ [Occ=Dead] ->
                 (Data.Semigroup.Internal.$fMonoidSum2 @ a_a6KXf $dNum_a6KXh)
                 `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6KXf>_R)
                         :: (a_a6KXf :: *) ~R# (Sum a_a6KXf :: *))
                 }}]
Data.Foldable.$fFoldableURec18
  = \ (@ a_a6KXf)
      ($dNum_a6KXh :: Num a_a6KXf)
      (ds_d6M22 :: URec Float a_a6KXf) ->
      case ds_d6M22
           `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_a6KXf>_N
                   :: (URec Float a_a6KXf :: *)
                      ~R# (GHC.Generics.R:UReckFloatp * a_a6KXf :: *))
      of
      { UFloat a1_a6Kpe ->
      (Data.Semigroup.Internal.$fMonoidSum2 @ a_a6KXf $dNum_a6KXh)
      `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6KXf>_R)
              :: (a_a6KXf :: *) ~R# (Sum a_a6KXf :: *))
      }

-- RHS size: {terms: 3, types: 8, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec19 :: forall a. URec Float a -> a
[GblId,
 Arity=1,
 Str=<B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KX5) (x_X6HLQ [Occ=Once] :: URec Float a_a6KX5) ->
                 case x_X6HLQ
                      `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_a6KX5>_N
                              :: (URec Float a_a6KX5 :: *)
                                 ~R# (GHC.Generics.R:UReckFloatp * a_a6KX5 :: *))
                 of
                 { UFloat _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:2 @ a_a6KX5
                 }}]
Data.Foldable.$fFoldableURec19
  = \ (@ a_a6KX5) _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:2 @ a_a6KX5

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec1_$cminimum
  :: forall a. Ord a => URec Float a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6KX5) _ [Occ=Dead] ->
                 Data.Foldable.$fFoldableURec19 @ a_a6KX5}]
Data.Foldable.$fFoldableURec1_$cminimum
  = \ (@ a_a6KX5) _ [Occ=Dead] (eta_B1 :: URec Float a_a6KX5) ->
      Data.Foldable.$fFoldableURec19 @ a_a6KX5 eta_B1

-- RHS size: {terms: 3, types: 8, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec20 :: forall a. URec Float a -> a
[GblId,
 Arity=1,
 Str=<B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KWV) (x_X6HLR [Occ=Once] :: URec Float a_a6KWV) ->
                 case x_X6HLR
                      `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_a6KWV>_N
                              :: (URec Float a_a6KWV :: *)
                                 ~R# (GHC.Generics.R:UReckFloatp * a_a6KWV :: *))
                 of
                 { UFloat _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:3 @ a_a6KWV
                 }}]
Data.Foldable.$fFoldableURec20
  = \ (@ a_a6KWV) _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:3 @ a_a6KWV

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec1_$cmaximum
  :: forall a. Ord a => URec Float a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6KWV) _ [Occ=Dead] ->
                 Data.Foldable.$fFoldableURec20 @ a_a6KWV}]
Data.Foldable.$fFoldableURec1_$cmaximum
  = \ (@ a_a6KWV) _ [Occ=Dead] (eta_B1 :: URec Float a_a6KWV) ->
      Data.Foldable.$fFoldableURec20 @ a_a6KWV eta_B1

-- RHS size: {terms: 4, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec1_$cfoldr1
  :: forall a. (a -> a -> a) -> URec Float a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KW8)
                 _ [Occ=Dead]
                 (xs_a6K7K [Occ=Once] :: URec Float a_a6KW8) ->
                 case xs_a6K7K
                      `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_a6KW8>_N
                              :: (URec Float a_a6KW8 :: *)
                                 ~R# (GHC.Generics.R:UReckFloatp * a_a6KW8 :: *))
                 of
                 { UFloat _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:8 @ a_a6KW8
                 }}]
Data.Foldable.$fFoldableURec1_$cfoldr1
  = \ (@ a_a6KW8) _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:8 @ a_a6KW8

-- RHS size: {terms: 9, types: 18, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec1_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> URec Float a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a6KVY)
                 (@ a_a6KVZ)
                 _ [Occ=Dead]
                 (z0_a6K7D [Occ=Once] :: b_a6KVY)
                 (xs_a6K7E [Occ=Once] :: URec Float a_a6KVZ) ->
                 case xs_a6K7E
                      `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_a6KVZ>_N
                              :: (URec Float a_a6KVZ :: *)
                                 ~R# (GHC.Generics.R:UReckFloatp * a_a6KVZ :: *))
                 of
                 { UFloat _ [Occ=Dead] ->
                 z0_a6K7D
                 }}]
Data.Foldable.$fFoldableURec1_$cfoldl'
  = \ (@ b_a6KVY)
      (@ a_a6KVZ)
      _ [Occ=Dead]
      (z0_a6K7D :: b_a6KVY)
      (xs_a6K7E :: URec Float a_a6KVZ) ->
      case xs_a6K7E
           `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_a6KVZ>_N
                   :: (URec Float a_a6KVZ :: *)
                      ~R# (GHC.Generics.R:UReckFloatp * a_a6KVZ :: *))
      of
      { UFloat a1_a6Kpc ->
      z0_a6K7D
      }

-- RHS size: {terms: 6, types: 12, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec1_$clength
  :: forall a. URec Float a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KWD) (xs_a6K7E [Occ=Once] :: URec Float a_a6KWD) ->
                 case xs_a6K7E
                      `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_a6KWD>_N
                              :: (URec Float a_a6KWD :: *)
                                 ~R# (GHC.Generics.R:UReckFloatp * a_a6KWD :: *))
                 of
                 { UFloat _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:4
                 }}]
Data.Foldable.$fFoldableURec1_$clength
  = \ (@ a_a6KWD) (xs_a6K7E :: URec Float a_a6KWD) ->
      case xs_a6K7E
           `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_a6KWD>_N
                   :: (URec Float a_a6KWD :: *)
                      ~R# (GHC.Generics.R:UReckFloatp * a_a6KWD :: *))
      of
      { UFloat a1_a6Kpc ->
      Data.Foldable.$fFoldable:*:4
      }

-- RHS size: {terms: 4, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec1_$cfoldl1
  :: forall a. (a -> a -> a) -> URec Float a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KWg)
                 _ [Occ=Dead]
                 (xs_a6K7Q [Occ=Once] :: URec Float a_a6KWg) ->
                 case xs_a6K7Q
                      `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_a6KWg>_N
                              :: (URec Float a_a6KWg :: *)
                                 ~R# (GHC.Generics.R:UReckFloatp * a_a6KWg :: *))
                 of
                 { UFloat _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:6 @ a_a6KWg
                 }}]
Data.Foldable.$fFoldableURec1_$cfoldl1
  = \ (@ a_a6KWg) _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:6 @ a_a6KWg

-- RHS size: {terms: 8, types: 15, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec1_$cfold
  :: forall m. Monoid m => URec Float m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_a6KV9)
                 ($dMonoid_a6KVb [Occ=Once] :: Monoid m_a6KV9)
                 (ds_d6M22 [Occ=Once] :: URec Float m_a6KV9) ->
                 case ds_d6M22
                      `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <m_a6KV9>_N
                              :: (URec Float m_a6KV9 :: *)
                                 ~R# (GHC.Generics.R:UReckFloatp * m_a6KV9 :: *))
                 of
                 { UFloat _ [Occ=Dead] ->
                 mempty @ m_a6KV9 $dMonoid_a6KVb
                 }}]
Data.Foldable.$fFoldableURec1_$cfold
  = \ (@ m_a6KV9)
      ($dMonoid_a6KVb :: Monoid m_a6KV9)
      (ds_d6M22 :: URec Float m_a6KV9) ->
      case ds_d6M22
           `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <m_a6KV9>_N
                   :: (URec Float m_a6KV9 :: *)
                      ~R# (GHC.Generics.R:UReckFloatp * m_a6KV9 :: *))
      of
      { UFloat a1_a6Kpe ->
      mempty @ m_a6KV9 $dMonoid_a6KVb
      }

-- RHS size: {terms: 8, types: 15, coercions: 7, joins: 0/0}
Data.Foldable.$fFoldableURec17
  :: forall a. Num a => URec Float a -> Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KXp)
                 ($dNum_a6KXr [Occ=Once] :: Num a_a6KXp)
                 (ds_d6M22 [Occ=Once] :: URec Float a_a6KXp) ->
                 case ds_d6M22
                      `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_a6KXp>_N
                              :: (URec Float a_a6KXp :: *)
                                 ~R# (GHC.Generics.R:UReckFloatp * a_a6KXp :: *))
                 of
                 { UFloat _ [Occ=Dead] ->
                 (Data.Semigroup.Internal.$fMonoidProduct2 @ a_a6KXp $dNum_a6KXr)
                 `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6KXp>_R)
                         :: (a_a6KXp :: *) ~R# (Product a_a6KXp :: *))
                 }}]
Data.Foldable.$fFoldableURec17
  = \ (@ a_a6KXp)
      ($dNum_a6KXr :: Num a_a6KXp)
      (ds_d6M22 :: URec Float a_a6KXp) ->
      case ds_d6M22
           `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_a6KXp>_N
                   :: (URec Float a_a6KXp :: *)
                      ~R# (GHC.Generics.R:UReckFloatp * a_a6KXp :: *))
      of
      { UFloat a1_a6Kpe ->
      (Data.Semigroup.Internal.$fMonoidProduct2 @ a_a6KXp $dNum_a6KXr)
      `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6KXp>_R)
              :: (a_a6KXp :: *) ~R# (Product a_a6KXp :: *))
      }

-- RHS size: {terms: 6, types: 13, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. URec Float a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a6KWo) (t_a6K7V [Occ=Once] :: URec Float a_a6KWo) ->
                 build
                   @ a_a6KWo
                   (\ (@ b_a6KNB)
                      _ [Occ=Dead, OS=OneShot]
                      (n_a6K7X [Occ=Once, OS=OneShot] :: b_a6KNB) ->
                      case t_a6K7V
                           `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_a6KWo>_N
                                   :: (URec Float a_a6KWo :: *)
                                      ~R# (GHC.Generics.R:UReckFloatp * a_a6KWo :: *))
                      of
                      { UFloat _ [Occ=Dead] ->
                      n_a6K7X
                      })}]
Data.Foldable.$fFoldableURec1_$ctoList
  = \ (@ a_a6KWo) (eta_Xcz :: URec Float a_a6KWo) ->
      case eta_Xcz
           `cast` (GHC.Generics.D:R:UReckFloatp0[0] <*>_N <a_a6KWo>_N
                   :: (URec Float a_a6KWo :: *)
                      ~R# (GHC.Generics.R:UReckFloatp * a_a6KWo :: *))
      of
      { UFloat a1_a6Kpc ->
      GHC.Types.[] @ a_a6KWo
      }

-- RHS size: {terms: 17, types: 4, coercions: 43, joins: 0/0}
Data.Foldable.$fFoldableURec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable (URec Float)
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: URec Float
                                Data.Foldable.$fFoldableURec1_$cfold
                                Data.Foldable.$fFoldableURec1_$cfoldMap
                                Data.Foldable.$fFoldableURec1_$cfoldr
                                Data.Foldable.$fFoldableURec1_$cfoldr
                                Data.Foldable.$fFoldableURec1_$cfoldl'
                                Data.Foldable.$fFoldableURec1_$cfoldl'
                                Data.Foldable.$fFoldableURec1_$cfoldr1
                                Data.Foldable.$fFoldableURec1_$cfoldl1
                                Data.Foldable.$fFoldableURec1_$ctoList
                                Data.Foldable.$fFoldableURec1_$cnull
                                Data.Foldable.$fFoldableURec1_$clength
                                Data.Foldable.$fFoldableURec21
                                `cast` (forall (a :: <*>_N).
                                        <Eq a>_R
                                        ->_R <a>_R
                                        ->_R <URec Float a>_R
                                        ->_R Data.Semigroup.Internal.N:Any[0]
                                        :: (forall a.
                                            Eq a =>
                                            a -> URec Float a -> Data.Monoid.Any :: *)
                                           ~R# (forall a. Eq a => a -> URec Float a -> Bool :: *))
                                Data.Foldable.$fFoldableURec1_$cmaximum
                                Data.Foldable.$fFoldableURec1_$cminimum
                                Data.Foldable.$fFoldableURec18
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <URec Float a>_R
                                        ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
                                        :: (forall a. Num a => URec Float a -> Sum a :: *)
                                           ~R# (forall a. Num a => URec Float a -> a :: *))
                                Data.Foldable.$fFoldableURec17
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <URec Float a>_R
                                        ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
                                        :: (forall a. Num a => URec Float a -> Product a :: *)
                                           ~R# (forall a. Num a => URec Float a -> a :: *))]
Data.Foldable.$fFoldableURec1
  = Data.Foldable.C:Foldable
      @ (URec Float)
      Data.Foldable.$fFoldableURec1_$cfold
      Data.Foldable.$fFoldableURec1_$cfoldMap
      Data.Foldable.$fFoldableURec1_$cfoldr
      Data.Foldable.$fFoldableURec1_$cfoldr
      Data.Foldable.$fFoldableURec1_$cfoldl'
      Data.Foldable.$fFoldableURec1_$cfoldl'
      Data.Foldable.$fFoldableURec1_$cfoldr1
      Data.Foldable.$fFoldableURec1_$cfoldl1
      Data.Foldable.$fFoldableURec1_$ctoList
      Data.Foldable.$fFoldableURec1_$cnull
      Data.Foldable.$fFoldableURec1_$clength
      (Data.Foldable.$fFoldableURec21
       `cast` (forall (a :: <*>_N).
               <Eq a>_R
               ->_R <a>_R
               ->_R <URec Float a>_R
               ->_R Data.Semigroup.Internal.N:Any[0]
               :: (forall a. Eq a => a -> URec Float a -> Data.Monoid.Any :: *)
                  ~R# (forall a. Eq a => a -> URec Float a -> Bool :: *)))
      Data.Foldable.$fFoldableURec1_$cmaximum
      Data.Foldable.$fFoldableURec1_$cminimum
      (Data.Foldable.$fFoldableURec18
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <URec Float a>_R
               ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall a. Num a => URec Float a -> Sum a :: *)
                  ~R# (forall a. Num a => URec Float a -> a :: *)))
      (Data.Foldable.$fFoldableURec17
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <URec Float a>_R
               ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall a. Num a => URec Float a -> Product a :: *)
                  ~R# (forall a. Num a => URec Float a -> a :: *)))

-- RHS size: {terms: 8, types: 15, coercions: 6, joins: 0/0}
Data.Foldable.$fFoldableURec26
  :: forall a. Eq a => a -> URec Double a -> Data.Monoid.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KZd)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (eta1_Xpf [Occ=Once] :: URec Double a_a6KZd) ->
                 case eta1_Xpf
                      `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_a6KZd>_N
                              :: (URec Double a_a6KZd :: *)
                                 ~R# (GHC.Generics.R:UReckDoublep * a_a6KZd :: *))
                 of
                 { UDouble _ [Occ=Dead] ->
                 GHC.Types.False
                 `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                         :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
                 }}]
Data.Foldable.$fFoldableURec26
  = \ (@ a_a6KZd)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (eta1_Xpf :: URec Double a_a6KZd) ->
      case eta1_Xpf
           `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_a6KZd>_N
                   :: (URec Double a_a6KZd :: *)
                      ~R# (GHC.Generics.R:UReckDoublep * a_a6KZd :: *))
      of
      { UDouble a1_a6Kpk ->
      GHC.Types.False
      `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
              :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
      }

-- RHS size: {terms: 8, types: 15, coercions: 7, joins: 0/0}
Data.Foldable.$fFoldableURec23
  :: forall a. Num a => URec Double a -> Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KZH)
                 ($dNum_a6KZJ [Occ=Once] :: Num a_a6KZH)
                 (ds_d6M2b [Occ=Once] :: URec Double a_a6KZH) ->
                 case ds_d6M2b
                      `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_a6KZH>_N
                              :: (URec Double a_a6KZH :: *)
                                 ~R# (GHC.Generics.R:UReckDoublep * a_a6KZH :: *))
                 of
                 { UDouble _ [Occ=Dead] ->
                 (Data.Semigroup.Internal.$fMonoidSum2 @ a_a6KZH $dNum_a6KZJ)
                 `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6KZH>_R)
                         :: (a_a6KZH :: *) ~R# (Sum a_a6KZH :: *))
                 }}]
Data.Foldable.$fFoldableURec23
  = \ (@ a_a6KZH)
      ($dNum_a6KZJ :: Num a_a6KZH)
      (ds_d6M2b :: URec Double a_a6KZH) ->
      case ds_d6M2b
           `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_a6KZH>_N
                   :: (URec Double a_a6KZH :: *)
                      ~R# (GHC.Generics.R:UReckDoublep * a_a6KZH :: *))
      of
      { UDouble a1_a6Kpk ->
      (Data.Semigroup.Internal.$fMonoidSum2 @ a_a6KZH $dNum_a6KZJ)
      `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6KZH>_R)
              :: (a_a6KZH :: *) ~R# (Sum a_a6KZH :: *))
      }

-- RHS size: {terms: 3, types: 8, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec24 :: forall a. URec Double a -> a
[GblId,
 Arity=1,
 Str=<B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KZx) (x_X6HLQ [Occ=Once] :: URec Double a_a6KZx) ->
                 case x_X6HLQ
                      `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_a6KZx>_N
                              :: (URec Double a_a6KZx :: *)
                                 ~R# (GHC.Generics.R:UReckDoublep * a_a6KZx :: *))
                 of
                 { UDouble _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:2 @ a_a6KZx
                 }}]
Data.Foldable.$fFoldableURec24
  = \ (@ a_a6KZx) _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:2 @ a_a6KZx

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec2_$cminimum
  :: forall a. Ord a => URec Double a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6KZx) _ [Occ=Dead] ->
                 Data.Foldable.$fFoldableURec24 @ a_a6KZx}]
Data.Foldable.$fFoldableURec2_$cminimum
  = \ (@ a_a6KZx) _ [Occ=Dead] (eta_B1 :: URec Double a_a6KZx) ->
      Data.Foldable.$fFoldableURec24 @ a_a6KZx eta_B1

-- RHS size: {terms: 3, types: 8, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec25 :: forall a. URec Double a -> a
[GblId,
 Arity=1,
 Str=<B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KZn) (x_X6HLR [Occ=Once] :: URec Double a_a6KZn) ->
                 case x_X6HLR
                      `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_a6KZn>_N
                              :: (URec Double a_a6KZn :: *)
                                 ~R# (GHC.Generics.R:UReckDoublep * a_a6KZn :: *))
                 of
                 { UDouble _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:3 @ a_a6KZn
                 }}]
Data.Foldable.$fFoldableURec25
  = \ (@ a_a6KZn) _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:3 @ a_a6KZn

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec2_$cmaximum
  :: forall a. Ord a => URec Double a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6KZn) _ [Occ=Dead] ->
                 Data.Foldable.$fFoldableURec25 @ a_a6KZn}]
Data.Foldable.$fFoldableURec2_$cmaximum
  = \ (@ a_a6KZn) _ [Occ=Dead] (eta_B1 :: URec Double a_a6KZn) ->
      Data.Foldable.$fFoldableURec25 @ a_a6KZn eta_B1

-- RHS size: {terms: 4, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec2_$cfoldr1
  :: forall a. (a -> a -> a) -> URec Double a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KYA)
                 _ [Occ=Dead]
                 (xs_a6K7K [Occ=Once] :: URec Double a_a6KYA) ->
                 case xs_a6K7K
                      `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_a6KYA>_N
                              :: (URec Double a_a6KYA :: *)
                                 ~R# (GHC.Generics.R:UReckDoublep * a_a6KYA :: *))
                 of
                 { UDouble _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:8 @ a_a6KYA
                 }}]
Data.Foldable.$fFoldableURec2_$cfoldr1
  = \ (@ a_a6KYA) _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:8 @ a_a6KYA

-- RHS size: {terms: 9, types: 18, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec2_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> URec Double a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a6KYq)
                 (@ a_a6KYr)
                 _ [Occ=Dead]
                 (z0_a6K7D [Occ=Once] :: b_a6KYq)
                 (xs_a6K7E [Occ=Once] :: URec Double a_a6KYr) ->
                 case xs_a6K7E
                      `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_a6KYr>_N
                              :: (URec Double a_a6KYr :: *)
                                 ~R# (GHC.Generics.R:UReckDoublep * a_a6KYr :: *))
                 of
                 { UDouble _ [Occ=Dead] ->
                 z0_a6K7D
                 }}]
Data.Foldable.$fFoldableURec2_$cfoldl'
  = \ (@ b_a6KYq)
      (@ a_a6KYr)
      _ [Occ=Dead]
      (z0_a6K7D :: b_a6KYq)
      (xs_a6K7E :: URec Double a_a6KYr) ->
      case xs_a6K7E
           `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_a6KYr>_N
                   :: (URec Double a_a6KYr :: *)
                      ~R# (GHC.Generics.R:UReckDoublep * a_a6KYr :: *))
      of
      { UDouble a1_a6Kpi ->
      z0_a6K7D
      }

-- RHS size: {terms: 6, types: 12, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec2_$clength
  :: forall a. URec Double a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KZ5) (xs_a6K7E [Occ=Once] :: URec Double a_a6KZ5) ->
                 case xs_a6K7E
                      `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_a6KZ5>_N
                              :: (URec Double a_a6KZ5 :: *)
                                 ~R# (GHC.Generics.R:UReckDoublep * a_a6KZ5 :: *))
                 of
                 { UDouble _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:4
                 }}]
Data.Foldable.$fFoldableURec2_$clength
  = \ (@ a_a6KZ5) (xs_a6K7E :: URec Double a_a6KZ5) ->
      case xs_a6K7E
           `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_a6KZ5>_N
                   :: (URec Double a_a6KZ5 :: *)
                      ~R# (GHC.Generics.R:UReckDoublep * a_a6KZ5 :: *))
      of
      { UDouble a1_a6Kpi ->
      Data.Foldable.$fFoldable:*:4
      }

-- RHS size: {terms: 4, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec2_$cfoldl1
  :: forall a. (a -> a -> a) -> URec Double a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KYI)
                 _ [Occ=Dead]
                 (xs_a6K7Q [Occ=Once] :: URec Double a_a6KYI) ->
                 case xs_a6K7Q
                      `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_a6KYI>_N
                              :: (URec Double a_a6KYI :: *)
                                 ~R# (GHC.Generics.R:UReckDoublep * a_a6KYI :: *))
                 of
                 { UDouble _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:6 @ a_a6KYI
                 }}]
Data.Foldable.$fFoldableURec2_$cfoldl1
  = \ (@ a_a6KYI) _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:6 @ a_a6KYI

-- RHS size: {terms: 8, types: 15, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec2_$cfold
  :: forall m. Monoid m => URec Double m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_a6KXB)
                 ($dMonoid_a6KXD [Occ=Once] :: Monoid m_a6KXB)
                 (ds_d6M2b [Occ=Once] :: URec Double m_a6KXB) ->
                 case ds_d6M2b
                      `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <m_a6KXB>_N
                              :: (URec Double m_a6KXB :: *)
                                 ~R# (GHC.Generics.R:UReckDoublep * m_a6KXB :: *))
                 of
                 { UDouble _ [Occ=Dead] ->
                 mempty @ m_a6KXB $dMonoid_a6KXD
                 }}]
Data.Foldable.$fFoldableURec2_$cfold
  = \ (@ m_a6KXB)
      ($dMonoid_a6KXD :: Monoid m_a6KXB)
      (ds_d6M2b :: URec Double m_a6KXB) ->
      case ds_d6M2b
           `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <m_a6KXB>_N
                   :: (URec Double m_a6KXB :: *)
                      ~R# (GHC.Generics.R:UReckDoublep * m_a6KXB :: *))
      of
      { UDouble a1_a6Kpk ->
      mempty @ m_a6KXB $dMonoid_a6KXD
      }

-- RHS size: {terms: 8, types: 15, coercions: 7, joins: 0/0}
Data.Foldable.$fFoldableURec22
  :: forall a. Num a => URec Double a -> Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6KZR)
                 ($dNum_a6KZT [Occ=Once] :: Num a_a6KZR)
                 (ds_d6M2b [Occ=Once] :: URec Double a_a6KZR) ->
                 case ds_d6M2b
                      `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_a6KZR>_N
                              :: (URec Double a_a6KZR :: *)
                                 ~R# (GHC.Generics.R:UReckDoublep * a_a6KZR :: *))
                 of
                 { UDouble _ [Occ=Dead] ->
                 (Data.Semigroup.Internal.$fMonoidProduct2 @ a_a6KZR $dNum_a6KZT)
                 `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6KZR>_R)
                         :: (a_a6KZR :: *) ~R# (Product a_a6KZR :: *))
                 }}]
Data.Foldable.$fFoldableURec22
  = \ (@ a_a6KZR)
      ($dNum_a6KZT :: Num a_a6KZR)
      (ds_d6M2b :: URec Double a_a6KZR) ->
      case ds_d6M2b
           `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_a6KZR>_N
                   :: (URec Double a_a6KZR :: *)
                      ~R# (GHC.Generics.R:UReckDoublep * a_a6KZR :: *))
      of
      { UDouble a1_a6Kpk ->
      (Data.Semigroup.Internal.$fMonoidProduct2 @ a_a6KZR $dNum_a6KZT)
      `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6KZR>_R)
              :: (a_a6KZR :: *) ~R# (Product a_a6KZR :: *))
      }

-- RHS size: {terms: 6, types: 13, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec2_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. URec Double a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a6KYQ) (t_a6K7V [Occ=Once] :: URec Double a_a6KYQ) ->
                 build
                   @ a_a6KYQ
                   (\ (@ b_a6KNB)
                      _ [Occ=Dead, OS=OneShot]
                      (n_a6K7X [Occ=Once, OS=OneShot] :: b_a6KNB) ->
                      case t_a6K7V
                           `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_a6KYQ>_N
                                   :: (URec Double a_a6KYQ :: *)
                                      ~R# (GHC.Generics.R:UReckDoublep * a_a6KYQ :: *))
                      of
                      { UDouble _ [Occ=Dead] ->
                      n_a6K7X
                      })}]
Data.Foldable.$fFoldableURec2_$ctoList
  = \ (@ a_a6KYQ) (eta_Xd0 :: URec Double a_a6KYQ) ->
      case eta_Xd0
           `cast` (GHC.Generics.D:R:UReckDoublep0[0] <*>_N <a_a6KYQ>_N
                   :: (URec Double a_a6KYQ :: *)
                      ~R# (GHC.Generics.R:UReckDoublep * a_a6KYQ :: *))
      of
      { UDouble a1_a6Kpi ->
      GHC.Types.[] @ a_a6KYQ
      }

-- RHS size: {terms: 17, types: 4, coercions: 43, joins: 0/0}
Data.Foldable.$fFoldableURec2 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable (URec Double)
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: URec Double
                                Data.Foldable.$fFoldableURec2_$cfold
                                Data.Foldable.$fFoldableURec2_$cfoldMap
                                Data.Foldable.$fFoldableURec2_$cfoldr
                                Data.Foldable.$fFoldableURec2_$cfoldr
                                Data.Foldable.$fFoldableURec2_$cfoldl'
                                Data.Foldable.$fFoldableURec2_$cfoldl'
                                Data.Foldable.$fFoldableURec2_$cfoldr1
                                Data.Foldable.$fFoldableURec2_$cfoldl1
                                Data.Foldable.$fFoldableURec2_$ctoList
                                Data.Foldable.$fFoldableURec2_$cnull
                                Data.Foldable.$fFoldableURec2_$clength
                                Data.Foldable.$fFoldableURec26
                                `cast` (forall (a :: <*>_N).
                                        <Eq a>_R
                                        ->_R <a>_R
                                        ->_R <URec Double a>_R
                                        ->_R Data.Semigroup.Internal.N:Any[0]
                                        :: (forall a.
                                            Eq a =>
                                            a -> URec Double a -> Data.Monoid.Any :: *)
                                           ~R# (forall a. Eq a => a -> URec Double a -> Bool :: *))
                                Data.Foldable.$fFoldableURec2_$cmaximum
                                Data.Foldable.$fFoldableURec2_$cminimum
                                Data.Foldable.$fFoldableURec23
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <URec Double a>_R
                                        ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
                                        :: (forall a. Num a => URec Double a -> Sum a :: *)
                                           ~R# (forall a. Num a => URec Double a -> a :: *))
                                Data.Foldable.$fFoldableURec22
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <URec Double a>_R
                                        ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
                                        :: (forall a. Num a => URec Double a -> Product a :: *)
                                           ~R# (forall a. Num a => URec Double a -> a :: *))]
Data.Foldable.$fFoldableURec2
  = Data.Foldable.C:Foldable
      @ (URec Double)
      Data.Foldable.$fFoldableURec2_$cfold
      Data.Foldable.$fFoldableURec2_$cfoldMap
      Data.Foldable.$fFoldableURec2_$cfoldr
      Data.Foldable.$fFoldableURec2_$cfoldr
      Data.Foldable.$fFoldableURec2_$cfoldl'
      Data.Foldable.$fFoldableURec2_$cfoldl'
      Data.Foldable.$fFoldableURec2_$cfoldr1
      Data.Foldable.$fFoldableURec2_$cfoldl1
      Data.Foldable.$fFoldableURec2_$ctoList
      Data.Foldable.$fFoldableURec2_$cnull
      Data.Foldable.$fFoldableURec2_$clength
      (Data.Foldable.$fFoldableURec26
       `cast` (forall (a :: <*>_N).
               <Eq a>_R
               ->_R <a>_R
               ->_R <URec Double a>_R
               ->_R Data.Semigroup.Internal.N:Any[0]
               :: (forall a. Eq a => a -> URec Double a -> Data.Monoid.Any :: *)
                  ~R# (forall a. Eq a => a -> URec Double a -> Bool :: *)))
      Data.Foldable.$fFoldableURec2_$cmaximum
      Data.Foldable.$fFoldableURec2_$cminimum
      (Data.Foldable.$fFoldableURec23
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <URec Double a>_R
               ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall a. Num a => URec Double a -> Sum a :: *)
                  ~R# (forall a. Num a => URec Double a -> a :: *)))
      (Data.Foldable.$fFoldableURec22
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <URec Double a>_R
               ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall a. Num a => URec Double a -> Product a :: *)
                  ~R# (forall a. Num a => URec Double a -> a :: *)))

-- RHS size: {terms: 8, types: 15, coercions: 6, joins: 0/0}
Data.Foldable.$fFoldableURec31
  :: forall a. Eq a => a -> URec Char a -> Data.Monoid.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6L1F)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (eta1_Xq7 [Occ=Once] :: URec Char a_a6L1F) ->
                 case eta1_Xq7
                      `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_a6L1F>_N
                              :: (URec Char a_a6L1F :: *)
                                 ~R# (GHC.Generics.R:UReckCharp * a_a6L1F :: *))
                 of
                 { UChar _ [Occ=Dead] ->
                 GHC.Types.False
                 `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                         :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
                 }}]
Data.Foldable.$fFoldableURec31
  = \ (@ a_a6L1F)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (eta1_Xq7 :: URec Char a_a6L1F) ->
      case eta1_Xq7
           `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_a6L1F>_N
                   :: (URec Char a_a6L1F :: *)
                      ~R# (GHC.Generics.R:UReckCharp * a_a6L1F :: *))
      of
      { UChar a1_a6Kpq ->
      GHC.Types.False
      `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
              :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
      }

-- RHS size: {terms: 8, types: 15, coercions: 7, joins: 0/0}
Data.Foldable.$fFoldableURec28
  :: forall a. Num a => URec Char a -> Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6L29)
                 ($dNum_a6L2b [Occ=Once] :: Num a_a6L29)
                 (ds_d6M2k [Occ=Once] :: URec Char a_a6L29) ->
                 case ds_d6M2k
                      `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_a6L29>_N
                              :: (URec Char a_a6L29 :: *)
                                 ~R# (GHC.Generics.R:UReckCharp * a_a6L29 :: *))
                 of
                 { UChar _ [Occ=Dead] ->
                 (Data.Semigroup.Internal.$fMonoidSum2 @ a_a6L29 $dNum_a6L2b)
                 `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6L29>_R)
                         :: (a_a6L29 :: *) ~R# (Sum a_a6L29 :: *))
                 }}]
Data.Foldable.$fFoldableURec28
  = \ (@ a_a6L29)
      ($dNum_a6L2b :: Num a_a6L29)
      (ds_d6M2k :: URec Char a_a6L29) ->
      case ds_d6M2k
           `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_a6L29>_N
                   :: (URec Char a_a6L29 :: *)
                      ~R# (GHC.Generics.R:UReckCharp * a_a6L29 :: *))
      of
      { UChar a1_a6Kpq ->
      (Data.Semigroup.Internal.$fMonoidSum2 @ a_a6L29 $dNum_a6L2b)
      `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6L29>_R)
              :: (a_a6L29 :: *) ~R# (Sum a_a6L29 :: *))
      }

-- RHS size: {terms: 3, types: 8, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec29 :: forall a. URec Char a -> a
[GblId,
 Arity=1,
 Str=<B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6L1Z) (x_X6HLQ [Occ=Once] :: URec Char a_a6L1Z) ->
                 case x_X6HLQ
                      `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_a6L1Z>_N
                              :: (URec Char a_a6L1Z :: *)
                                 ~R# (GHC.Generics.R:UReckCharp * a_a6L1Z :: *))
                 of
                 { UChar _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:2 @ a_a6L1Z
                 }}]
Data.Foldable.$fFoldableURec29
  = \ (@ a_a6L1Z) _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:2 @ a_a6L1Z

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec3_$cminimum
  :: forall a. Ord a => URec Char a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6L1Z) _ [Occ=Dead] ->
                 Data.Foldable.$fFoldableURec29 @ a_a6L1Z}]
Data.Foldable.$fFoldableURec3_$cminimum
  = \ (@ a_a6L1Z) _ [Occ=Dead] (eta_B1 :: URec Char a_a6L1Z) ->
      Data.Foldable.$fFoldableURec29 @ a_a6L1Z eta_B1

-- RHS size: {terms: 3, types: 8, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec30 :: forall a. URec Char a -> a
[GblId,
 Arity=1,
 Str=<B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6L1P) (x_X6HLR [Occ=Once] :: URec Char a_a6L1P) ->
                 case x_X6HLR
                      `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_a6L1P>_N
                              :: (URec Char a_a6L1P :: *)
                                 ~R# (GHC.Generics.R:UReckCharp * a_a6L1P :: *))
                 of
                 { UChar _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:3 @ a_a6L1P
                 }}]
Data.Foldable.$fFoldableURec30
  = \ (@ a_a6L1P) _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:3 @ a_a6L1P

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec3_$cmaximum
  :: forall a. Ord a => URec Char a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6L1P) _ [Occ=Dead] ->
                 Data.Foldable.$fFoldableURec30 @ a_a6L1P}]
Data.Foldable.$fFoldableURec3_$cmaximum
  = \ (@ a_a6L1P) _ [Occ=Dead] (eta_B1 :: URec Char a_a6L1P) ->
      Data.Foldable.$fFoldableURec30 @ a_a6L1P eta_B1

-- RHS size: {terms: 4, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec3_$cfoldr1
  :: forall a. (a -> a -> a) -> URec Char a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6L12)
                 _ [Occ=Dead]
                 (xs_a6K7K [Occ=Once] :: URec Char a_a6L12) ->
                 case xs_a6K7K
                      `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_a6L12>_N
                              :: (URec Char a_a6L12 :: *)
                                 ~R# (GHC.Generics.R:UReckCharp * a_a6L12 :: *))
                 of
                 { UChar _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:8 @ a_a6L12
                 }}]
Data.Foldable.$fFoldableURec3_$cfoldr1
  = \ (@ a_a6L12) _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:8 @ a_a6L12

-- RHS size: {terms: 9, types: 18, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec3_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> URec Char a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a6L0S)
                 (@ a_a6L0T)
                 _ [Occ=Dead]
                 (z0_a6K7D [Occ=Once] :: b_a6L0S)
                 (xs_a6K7E [Occ=Once] :: URec Char a_a6L0T) ->
                 case xs_a6K7E
                      `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_a6L0T>_N
                              :: (URec Char a_a6L0T :: *)
                                 ~R# (GHC.Generics.R:UReckCharp * a_a6L0T :: *))
                 of
                 { UChar _ [Occ=Dead] ->
                 z0_a6K7D
                 }}]
Data.Foldable.$fFoldableURec3_$cfoldl'
  = \ (@ b_a6L0S)
      (@ a_a6L0T)
      _ [Occ=Dead]
      (z0_a6K7D :: b_a6L0S)
      (xs_a6K7E :: URec Char a_a6L0T) ->
      case xs_a6K7E
           `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_a6L0T>_N
                   :: (URec Char a_a6L0T :: *)
                      ~R# (GHC.Generics.R:UReckCharp * a_a6L0T :: *))
      of
      { UChar a1_a6Kpo ->
      z0_a6K7D
      }

-- RHS size: {terms: 6, types: 12, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec3_$clength
  :: forall a. URec Char a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6L1x) (xs_a6K7E [Occ=Once] :: URec Char a_a6L1x) ->
                 case xs_a6K7E
                      `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_a6L1x>_N
                              :: (URec Char a_a6L1x :: *)
                                 ~R# (GHC.Generics.R:UReckCharp * a_a6L1x :: *))
                 of
                 { UChar _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:4
                 }}]
Data.Foldable.$fFoldableURec3_$clength
  = \ (@ a_a6L1x) (xs_a6K7E :: URec Char a_a6L1x) ->
      case xs_a6K7E
           `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_a6L1x>_N
                   :: (URec Char a_a6L1x :: *)
                      ~R# (GHC.Generics.R:UReckCharp * a_a6L1x :: *))
      of
      { UChar a1_a6Kpo ->
      Data.Foldable.$fFoldable:*:4
      }

-- RHS size: {terms: 4, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec3_$cfoldl1
  :: forall a. (a -> a -> a) -> URec Char a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6L1a)
                 _ [Occ=Dead]
                 (xs_a6K7Q [Occ=Once] :: URec Char a_a6L1a) ->
                 case xs_a6K7Q
                      `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_a6L1a>_N
                              :: (URec Char a_a6L1a :: *)
                                 ~R# (GHC.Generics.R:UReckCharp * a_a6L1a :: *))
                 of
                 { UChar _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:6 @ a_a6L1a
                 }}]
Data.Foldable.$fFoldableURec3_$cfoldl1
  = \ (@ a_a6L1a) _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:6 @ a_a6L1a

-- RHS size: {terms: 8, types: 15, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec3_$cfold
  :: forall m. Monoid m => URec Char m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_a6L03)
                 ($dMonoid_a6L05 [Occ=Once] :: Monoid m_a6L03)
                 (ds_d6M2k [Occ=Once] :: URec Char m_a6L03) ->
                 case ds_d6M2k
                      `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <m_a6L03>_N
                              :: (URec Char m_a6L03 :: *)
                                 ~R# (GHC.Generics.R:UReckCharp * m_a6L03 :: *))
                 of
                 { UChar _ [Occ=Dead] ->
                 mempty @ m_a6L03 $dMonoid_a6L05
                 }}]
Data.Foldable.$fFoldableURec3_$cfold
  = \ (@ m_a6L03)
      ($dMonoid_a6L05 :: Monoid m_a6L03)
      (ds_d6M2k :: URec Char m_a6L03) ->
      case ds_d6M2k
           `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <m_a6L03>_N
                   :: (URec Char m_a6L03 :: *)
                      ~R# (GHC.Generics.R:UReckCharp * m_a6L03 :: *))
      of
      { UChar a1_a6Kpq ->
      mempty @ m_a6L03 $dMonoid_a6L05
      }

-- RHS size: {terms: 8, types: 15, coercions: 7, joins: 0/0}
Data.Foldable.$fFoldableURec27
  :: forall a. Num a => URec Char a -> Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6L2j)
                 ($dNum_a6L2l [Occ=Once] :: Num a_a6L2j)
                 (ds_d6M2k [Occ=Once] :: URec Char a_a6L2j) ->
                 case ds_d6M2k
                      `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_a6L2j>_N
                              :: (URec Char a_a6L2j :: *)
                                 ~R# (GHC.Generics.R:UReckCharp * a_a6L2j :: *))
                 of
                 { UChar _ [Occ=Dead] ->
                 (Data.Semigroup.Internal.$fMonoidProduct2 @ a_a6L2j $dNum_a6L2l)
                 `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6L2j>_R)
                         :: (a_a6L2j :: *) ~R# (Product a_a6L2j :: *))
                 }}]
Data.Foldable.$fFoldableURec27
  = \ (@ a_a6L2j)
      ($dNum_a6L2l :: Num a_a6L2j)
      (ds_d6M2k :: URec Char a_a6L2j) ->
      case ds_d6M2k
           `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_a6L2j>_N
                   :: (URec Char a_a6L2j :: *)
                      ~R# (GHC.Generics.R:UReckCharp * a_a6L2j :: *))
      of
      { UChar a1_a6Kpq ->
      (Data.Semigroup.Internal.$fMonoidProduct2 @ a_a6L2j $dNum_a6L2l)
      `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6L2j>_R)
              :: (a_a6L2j :: *) ~R# (Product a_a6L2j :: *))
      }

-- RHS size: {terms: 6, types: 13, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec3_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. URec Char a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a6L1i) (t_a6K7V [Occ=Once] :: URec Char a_a6L1i) ->
                 build
                   @ a_a6L1i
                   (\ (@ b_a6KNB)
                      _ [Occ=Dead, OS=OneShot]
                      (n_a6K7X [Occ=Once, OS=OneShot] :: b_a6KNB) ->
                      case t_a6K7V
                           `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_a6L1i>_N
                                   :: (URec Char a_a6L1i :: *)
                                      ~R# (GHC.Generics.R:UReckCharp * a_a6L1i :: *))
                      of
                      { UChar _ [Occ=Dead] ->
                      n_a6K7X
                      })}]
Data.Foldable.$fFoldableURec3_$ctoList
  = \ (@ a_a6L1i) (eta_Xdr :: URec Char a_a6L1i) ->
      case eta_Xdr
           `cast` (GHC.Generics.D:R:UReckCharp0[0] <*>_N <a_a6L1i>_N
                   :: (URec Char a_a6L1i :: *)
                      ~R# (GHC.Generics.R:UReckCharp * a_a6L1i :: *))
      of
      { UChar a1_a6Kpo ->
      GHC.Types.[] @ a_a6L1i
      }

-- RHS size: {terms: 17, types: 4, coercions: 43, joins: 0/0}
Data.Foldable.$fFoldableURec3 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable (URec Char)
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: URec Char
                                Data.Foldable.$fFoldableURec3_$cfold
                                Data.Foldable.$fFoldableURec3_$cfoldMap
                                Data.Foldable.$fFoldableURec3_$cfoldr
                                Data.Foldable.$fFoldableURec3_$cfoldr
                                Data.Foldable.$fFoldableURec3_$cfoldl'
                                Data.Foldable.$fFoldableURec3_$cfoldl'
                                Data.Foldable.$fFoldableURec3_$cfoldr1
                                Data.Foldable.$fFoldableURec3_$cfoldl1
                                Data.Foldable.$fFoldableURec3_$ctoList
                                Data.Foldable.$fFoldableURec3_$cnull
                                Data.Foldable.$fFoldableURec3_$clength
                                Data.Foldable.$fFoldableURec31
                                `cast` (forall (a :: <*>_N).
                                        <Eq a>_R
                                        ->_R <a>_R
                                        ->_R <URec Char a>_R
                                        ->_R Data.Semigroup.Internal.N:Any[0]
                                        :: (forall a.
                                            Eq a =>
                                            a -> URec Char a -> Data.Monoid.Any :: *)
                                           ~R# (forall a. Eq a => a -> URec Char a -> Bool :: *))
                                Data.Foldable.$fFoldableURec3_$cmaximum
                                Data.Foldable.$fFoldableURec3_$cminimum
                                Data.Foldable.$fFoldableURec28
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <URec Char a>_R
                                        ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
                                        :: (forall a. Num a => URec Char a -> Sum a :: *)
                                           ~R# (forall a. Num a => URec Char a -> a :: *))
                                Data.Foldable.$fFoldableURec27
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <URec Char a>_R
                                        ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
                                        :: (forall a. Num a => URec Char a -> Product a :: *)
                                           ~R# (forall a. Num a => URec Char a -> a :: *))]
Data.Foldable.$fFoldableURec3
  = Data.Foldable.C:Foldable
      @ (URec Char)
      Data.Foldable.$fFoldableURec3_$cfold
      Data.Foldable.$fFoldableURec3_$cfoldMap
      Data.Foldable.$fFoldableURec3_$cfoldr
      Data.Foldable.$fFoldableURec3_$cfoldr
      Data.Foldable.$fFoldableURec3_$cfoldl'
      Data.Foldable.$fFoldableURec3_$cfoldl'
      Data.Foldable.$fFoldableURec3_$cfoldr1
      Data.Foldable.$fFoldableURec3_$cfoldl1
      Data.Foldable.$fFoldableURec3_$ctoList
      Data.Foldable.$fFoldableURec3_$cnull
      Data.Foldable.$fFoldableURec3_$clength
      (Data.Foldable.$fFoldableURec31
       `cast` (forall (a :: <*>_N).
               <Eq a>_R
               ->_R <a>_R
               ->_R <URec Char a>_R
               ->_R Data.Semigroup.Internal.N:Any[0]
               :: (forall a. Eq a => a -> URec Char a -> Data.Monoid.Any :: *)
                  ~R# (forall a. Eq a => a -> URec Char a -> Bool :: *)))
      Data.Foldable.$fFoldableURec3_$cmaximum
      Data.Foldable.$fFoldableURec3_$cminimum
      (Data.Foldable.$fFoldableURec28
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <URec Char a>_R
               ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall a. Num a => URec Char a -> Sum a :: *)
                  ~R# (forall a. Num a => URec Char a -> a :: *)))
      (Data.Foldable.$fFoldableURec27
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <URec Char a>_R
               ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall a. Num a => URec Char a -> Product a :: *)
                  ~R# (forall a. Num a => URec Char a -> a :: *)))

-- RHS size: {terms: 8, types: 16, coercions: 6, joins: 0/0}
Data.Foldable.$fFoldableURec36
  :: forall a.
     Eq a =>
     a -> URec (GHC.Ptr.Ptr ()) a -> Data.Monoid.Any
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6L47)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (eta1_XqZ [Occ=Once] :: URec (GHC.Ptr.Ptr ()) a_a6L47) ->
                 case eta1_XqZ
                      `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_a6L47>_N
                              :: (URec (GHC.Ptr.Ptr ()) a_a6L47 :: *)
                                 ~R# (GHC.Generics.R:UReckPtrp * a_a6L47 :: *))
                 of
                 { UAddr _ [Occ=Dead] ->
                 GHC.Types.False
                 `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                         :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
                 }}]
Data.Foldable.$fFoldableURec36
  = \ (@ a_a6L47)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (eta1_XqZ :: URec (GHC.Ptr.Ptr ()) a_a6L47) ->
      case eta1_XqZ
           `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_a6L47>_N
                   :: (URec (GHC.Ptr.Ptr ()) a_a6L47 :: *)
                      ~R# (GHC.Generics.R:UReckPtrp * a_a6L47 :: *))
      of
      { UAddr a1_a6Kpw ->
      GHC.Types.False
      `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
              :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
      }

-- RHS size: {terms: 8, types: 16, coercions: 7, joins: 0/0}
Data.Foldable.$fFoldableURec33
  :: forall a. Num a => URec (GHC.Ptr.Ptr ()) a -> Sum a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6L4B)
                 ($dNum_a6L4D [Occ=Once] :: Num a_a6L4B)
                 (ds_d6M2t [Occ=Once] :: URec (GHC.Ptr.Ptr ()) a_a6L4B) ->
                 case ds_d6M2t
                      `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_a6L4B>_N
                              :: (URec (GHC.Ptr.Ptr ()) a_a6L4B :: *)
                                 ~R# (GHC.Generics.R:UReckPtrp * a_a6L4B :: *))
                 of
                 { UAddr _ [Occ=Dead] ->
                 (Data.Semigroup.Internal.$fMonoidSum2 @ a_a6L4B $dNum_a6L4D)
                 `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6L4B>_R)
                         :: (a_a6L4B :: *) ~R# (Sum a_a6L4B :: *))
                 }}]
Data.Foldable.$fFoldableURec33
  = \ (@ a_a6L4B)
      ($dNum_a6L4D :: Num a_a6L4B)
      (ds_d6M2t :: URec (GHC.Ptr.Ptr ()) a_a6L4B) ->
      case ds_d6M2t
           `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_a6L4B>_N
                   :: (URec (GHC.Ptr.Ptr ()) a_a6L4B :: *)
                      ~R# (GHC.Generics.R:UReckPtrp * a_a6L4B :: *))
      of
      { UAddr a1_a6Kpw ->
      (Data.Semigroup.Internal.$fMonoidSum2 @ a_a6L4B $dNum_a6L4D)
      `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6L4B>_R)
              :: (a_a6L4B :: *) ~R# (Sum a_a6L4B :: *))
      }

-- RHS size: {terms: 3, types: 9, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec34
  :: forall a. URec (GHC.Ptr.Ptr ()) a -> a
[GblId,
 Arity=1,
 Str=<B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6L4r)
                 (x_X6HLQ [Occ=Once] :: URec (GHC.Ptr.Ptr ()) a_a6L4r) ->
                 case x_X6HLQ
                      `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_a6L4r>_N
                              :: (URec (GHC.Ptr.Ptr ()) a_a6L4r :: *)
                                 ~R# (GHC.Generics.R:UReckPtrp * a_a6L4r :: *))
                 of
                 { UAddr _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:2 @ a_a6L4r
                 }}]
Data.Foldable.$fFoldableURec34
  = \ (@ a_a6L4r) _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:2 @ a_a6L4r

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec4_$cminimum
  :: forall a. Ord a => URec (GHC.Ptr.Ptr ()) a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6L4r) _ [Occ=Dead] ->
                 Data.Foldable.$fFoldableURec34 @ a_a6L4r}]
Data.Foldable.$fFoldableURec4_$cminimum
  = \ (@ a_a6L4r)
      _ [Occ=Dead]
      (eta_B1 :: URec (GHC.Ptr.Ptr ()) a_a6L4r) ->
      Data.Foldable.$fFoldableURec34 @ a_a6L4r eta_B1

-- RHS size: {terms: 3, types: 9, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec35
  :: forall a. URec (GHC.Ptr.Ptr ()) a -> a
[GblId,
 Arity=1,
 Str=<B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6L4h)
                 (x_X6HLR [Occ=Once] :: URec (GHC.Ptr.Ptr ()) a_a6L4h) ->
                 case x_X6HLR
                      `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_a6L4h>_N
                              :: (URec (GHC.Ptr.Ptr ()) a_a6L4h :: *)
                                 ~R# (GHC.Generics.R:UReckPtrp * a_a6L4h :: *))
                 of
                 { UAddr _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:3 @ a_a6L4h
                 }}]
Data.Foldable.$fFoldableURec35
  = \ (@ a_a6L4h) _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:3 @ a_a6L4h

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec4_$cmaximum
  :: forall a. Ord a => URec (GHC.Ptr.Ptr ()) a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6L4h) _ [Occ=Dead] ->
                 Data.Foldable.$fFoldableURec35 @ a_a6L4h}]
Data.Foldable.$fFoldableURec4_$cmaximum
  = \ (@ a_a6L4h)
      _ [Occ=Dead]
      (eta_B1 :: URec (GHC.Ptr.Ptr ()) a_a6L4h) ->
      Data.Foldable.$fFoldableURec35 @ a_a6L4h eta_B1

-- RHS size: {terms: 4, types: 12, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec4_$cfoldr1
  :: forall a. (a -> a -> a) -> URec (GHC.Ptr.Ptr ()) a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6L3u)
                 _ [Occ=Dead]
                 (xs_a6K7K [Occ=Once] :: URec (GHC.Ptr.Ptr ()) a_a6L3u) ->
                 case xs_a6K7K
                      `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_a6L3u>_N
                              :: (URec (GHC.Ptr.Ptr ()) a_a6L3u :: *)
                                 ~R# (GHC.Generics.R:UReckPtrp * a_a6L3u :: *))
                 of
                 { UAddr _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:8 @ a_a6L3u
                 }}]
Data.Foldable.$fFoldableURec4_$cfoldr1
  = \ (@ a_a6L3u) _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:8 @ a_a6L3u

-- RHS size: {terms: 9, types: 19, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec4_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> URec (GHC.Ptr.Ptr ()) a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a6L3k)
                 (@ a_a6L3l)
                 _ [Occ=Dead]
                 (z0_a6K7D [Occ=Once] :: b_a6L3k)
                 (xs_a6K7E [Occ=Once] :: URec (GHC.Ptr.Ptr ()) a_a6L3l) ->
                 case xs_a6K7E
                      `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_a6L3l>_N
                              :: (URec (GHC.Ptr.Ptr ()) a_a6L3l :: *)
                                 ~R# (GHC.Generics.R:UReckPtrp * a_a6L3l :: *))
                 of
                 { UAddr _ [Occ=Dead] ->
                 z0_a6K7D
                 }}]
Data.Foldable.$fFoldableURec4_$cfoldl'
  = \ (@ b_a6L3k)
      (@ a_a6L3l)
      _ [Occ=Dead]
      (z0_a6K7D :: b_a6L3k)
      (xs_a6K7E :: URec (GHC.Ptr.Ptr ()) a_a6L3l) ->
      case xs_a6K7E
           `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_a6L3l>_N
                   :: (URec (GHC.Ptr.Ptr ()) a_a6L3l :: *)
                      ~R# (GHC.Generics.R:UReckPtrp * a_a6L3l :: *))
      of
      { UAddr a1_a6Kpu ->
      z0_a6K7D
      }

-- RHS size: {terms: 6, types: 13, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec4_$clength
  :: forall a. URec (GHC.Ptr.Ptr ()) a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6L3Z)
                 (xs_a6K7E [Occ=Once] :: URec (GHC.Ptr.Ptr ()) a_a6L3Z) ->
                 case xs_a6K7E
                      `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_a6L3Z>_N
                              :: (URec (GHC.Ptr.Ptr ()) a_a6L3Z :: *)
                                 ~R# (GHC.Generics.R:UReckPtrp * a_a6L3Z :: *))
                 of
                 { UAddr _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:4
                 }}]
Data.Foldable.$fFoldableURec4_$clength
  = \ (@ a_a6L3Z) (xs_a6K7E :: URec (GHC.Ptr.Ptr ()) a_a6L3Z) ->
      case xs_a6K7E
           `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_a6L3Z>_N
                   :: (URec (GHC.Ptr.Ptr ()) a_a6L3Z :: *)
                      ~R# (GHC.Generics.R:UReckPtrp * a_a6L3Z :: *))
      of
      { UAddr a1_a6Kpu ->
      Data.Foldable.$fFoldable:*:4
      }

-- RHS size: {terms: 4, types: 12, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableURec4_$cfoldl1
  :: forall a. (a -> a -> a) -> URec (GHC.Ptr.Ptr ()) a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6L3C)
                 _ [Occ=Dead]
                 (xs_a6K7Q [Occ=Once] :: URec (GHC.Ptr.Ptr ()) a_a6L3C) ->
                 case xs_a6K7Q
                      `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_a6L3C>_N
                              :: (URec (GHC.Ptr.Ptr ()) a_a6L3C :: *)
                                 ~R# (GHC.Generics.R:UReckPtrp * a_a6L3C :: *))
                 of
                 { UAddr _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:6 @ a_a6L3C
                 }}]
Data.Foldable.$fFoldableURec4_$cfoldl1
  = \ (@ a_a6L3C) _ [Occ=Dead] _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:6 @ a_a6L3C

-- RHS size: {terms: 8, types: 16, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec4_$cfold
  :: forall m. Monoid m => URec (GHC.Ptr.Ptr ()) m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_a6L2v)
                 ($dMonoid_a6L2x [Occ=Once] :: Monoid m_a6L2v)
                 (ds_d6M2t [Occ=Once] :: URec (GHC.Ptr.Ptr ()) m_a6L2v) ->
                 case ds_d6M2t
                      `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <m_a6L2v>_N
                              :: (URec (GHC.Ptr.Ptr ()) m_a6L2v :: *)
                                 ~R# (GHC.Generics.R:UReckPtrp * m_a6L2v :: *))
                 of
                 { UAddr _ [Occ=Dead] ->
                 mempty @ m_a6L2v $dMonoid_a6L2x
                 }}]
Data.Foldable.$fFoldableURec4_$cfold
  = \ (@ m_a6L2v)
      ($dMonoid_a6L2x :: Monoid m_a6L2v)
      (ds_d6M2t :: URec (GHC.Ptr.Ptr ()) m_a6L2v) ->
      case ds_d6M2t
           `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <m_a6L2v>_N
                   :: (URec (GHC.Ptr.Ptr ()) m_a6L2v :: *)
                      ~R# (GHC.Generics.R:UReckPtrp * m_a6L2v :: *))
      of
      { UAddr a1_a6Kpw ->
      mempty @ m_a6L2v $dMonoid_a6L2x
      }

-- RHS size: {terms: 8, types: 16, coercions: 7, joins: 0/0}
Data.Foldable.$fFoldableURec32
  :: forall a. Num a => URec (GHC.Ptr.Ptr ()) a -> Product a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6L4L)
                 ($dNum_a6L4N [Occ=Once] :: Num a_a6L4L)
                 (ds_d6M2t [Occ=Once] :: URec (GHC.Ptr.Ptr ()) a_a6L4L) ->
                 case ds_d6M2t
                      `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_a6L4L>_N
                              :: (URec (GHC.Ptr.Ptr ()) a_a6L4L :: *)
                                 ~R# (GHC.Generics.R:UReckPtrp * a_a6L4L :: *))
                 of
                 { UAddr _ [Occ=Dead] ->
                 (Data.Semigroup.Internal.$fMonoidProduct2 @ a_a6L4L $dNum_a6L4N)
                 `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6L4L>_R)
                         :: (a_a6L4L :: *) ~R# (Product a_a6L4L :: *))
                 }}]
Data.Foldable.$fFoldableURec32
  = \ (@ a_a6L4L)
      ($dNum_a6L4N :: Num a_a6L4L)
      (ds_d6M2t :: URec (GHC.Ptr.Ptr ()) a_a6L4L) ->
      case ds_d6M2t
           `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_a6L4L>_N
                   :: (URec (GHC.Ptr.Ptr ()) a_a6L4L :: *)
                      ~R# (GHC.Generics.R:UReckPtrp * a_a6L4L :: *))
      of
      { UAddr a1_a6Kpw ->
      (Data.Semigroup.Internal.$fMonoidProduct2 @ a_a6L4L $dNum_a6L4N)
      `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6L4L>_R)
              :: (a_a6L4L :: *) ~R# (Product a_a6L4L :: *))
      }

-- RHS size: {terms: 6, types: 14, coercions: 4, joins: 0/0}
Data.Foldable.$fFoldableURec4_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. URec (GHC.Ptr.Ptr ()) a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a6L3K)
                 (t_a6K7V [Occ=Once] :: URec (GHC.Ptr.Ptr ()) a_a6L3K) ->
                 build
                   @ a_a6L3K
                   (\ (@ b_a6KNB)
                      _ [Occ=Dead, OS=OneShot]
                      (n_a6K7X [Occ=Once, OS=OneShot] :: b_a6KNB) ->
                      case t_a6K7V
                           `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_a6L3K>_N
                                   :: (URec (GHC.Ptr.Ptr ()) a_a6L3K :: *)
                                      ~R# (GHC.Generics.R:UReckPtrp * a_a6L3K :: *))
                      of
                      { UAddr _ [Occ=Dead] ->
                      n_a6K7X
                      })}]
Data.Foldable.$fFoldableURec4_$ctoList
  = \ (@ a_a6L3K) (eta_XdS :: URec (GHC.Ptr.Ptr ()) a_a6L3K) ->
      case eta_XdS
           `cast` (GHC.Generics.D:R:UReckPtrp0[0] <*>_N <a_a6L3K>_N
                   :: (URec (GHC.Ptr.Ptr ()) a_a6L3K :: *)
                      ~R# (GHC.Generics.R:UReckPtrp * a_a6L3K :: *))
      of
      { UAddr a1_a6Kpu ->
      GHC.Types.[] @ a_a6L3K
      }

-- RHS size: {terms: 17, types: 5, coercions: 46, joins: 0/0}
Data.Foldable.$fFoldableURec4 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable (URec (GHC.Ptr.Ptr ()))
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: URec (GHC.Ptr.Ptr ())
                                Data.Foldable.$fFoldableURec4_$cfold
                                Data.Foldable.$fFoldableURec4_$cfoldMap
                                Data.Foldable.$fFoldableURec4_$cfoldr
                                Data.Foldable.$fFoldableURec4_$cfoldr
                                Data.Foldable.$fFoldableURec4_$cfoldl'
                                Data.Foldable.$fFoldableURec4_$cfoldl'
                                Data.Foldable.$fFoldableURec4_$cfoldr1
                                Data.Foldable.$fFoldableURec4_$cfoldl1
                                Data.Foldable.$fFoldableURec4_$ctoList
                                Data.Foldable.$fFoldableURec4_$cnull
                                Data.Foldable.$fFoldableURec4_$clength
                                Data.Foldable.$fFoldableURec36
                                `cast` (forall (a :: <*>_N).
                                        <Eq a>_R
                                        ->_R <a>_R
                                        ->_R <URec (GHC.Ptr.Ptr ()) a>_R
                                        ->_R Data.Semigroup.Internal.N:Any[0]
                                        :: (forall a.
                                            Eq a =>
                                            a -> URec (GHC.Ptr.Ptr ()) a -> Data.Monoid.Any :: *)
                                           ~R# (forall a.
                                                Eq a =>
                                                a -> URec (GHC.Ptr.Ptr ()) a -> Bool :: *))
                                Data.Foldable.$fFoldableURec4_$cmaximum
                                Data.Foldable.$fFoldableURec4_$cminimum
                                Data.Foldable.$fFoldableURec33
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <URec (GHC.Ptr.Ptr ()) a>_R
                                        ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
                                        :: (forall a.
                                            Num a =>
                                            URec (GHC.Ptr.Ptr ()) a -> Sum a :: *)
                                           ~R# (forall a.
                                                Num a =>
                                                URec (GHC.Ptr.Ptr ()) a -> a :: *))
                                Data.Foldable.$fFoldableURec32
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <URec (GHC.Ptr.Ptr ()) a>_R
                                        ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
                                        :: (forall a.
                                            Num a =>
                                            URec (GHC.Ptr.Ptr ()) a -> Product a :: *)
                                           ~R# (forall a.
                                                Num a =>
                                                URec (GHC.Ptr.Ptr ()) a -> a :: *))]
Data.Foldable.$fFoldableURec4
  = Data.Foldable.C:Foldable
      @ (URec (GHC.Ptr.Ptr ()))
      Data.Foldable.$fFoldableURec4_$cfold
      Data.Foldable.$fFoldableURec4_$cfoldMap
      Data.Foldable.$fFoldableURec4_$cfoldr
      Data.Foldable.$fFoldableURec4_$cfoldr
      Data.Foldable.$fFoldableURec4_$cfoldl'
      Data.Foldable.$fFoldableURec4_$cfoldl'
      Data.Foldable.$fFoldableURec4_$cfoldr1
      Data.Foldable.$fFoldableURec4_$cfoldl1
      Data.Foldable.$fFoldableURec4_$ctoList
      Data.Foldable.$fFoldableURec4_$cnull
      Data.Foldable.$fFoldableURec4_$clength
      (Data.Foldable.$fFoldableURec36
       `cast` (forall (a :: <*>_N).
               <Eq a>_R
               ->_R <a>_R
               ->_R <URec (GHC.Ptr.Ptr ()) a>_R
               ->_R Data.Semigroup.Internal.N:Any[0]
               :: (forall a.
                   Eq a =>
                   a -> URec (GHC.Ptr.Ptr ()) a -> Data.Monoid.Any :: *)
                  ~R# (forall a. Eq a => a -> URec (GHC.Ptr.Ptr ()) a -> Bool :: *)))
      Data.Foldable.$fFoldableURec4_$cmaximum
      Data.Foldable.$fFoldableURec4_$cminimum
      (Data.Foldable.$fFoldableURec33
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <URec (GHC.Ptr.Ptr ()) a>_R
               ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall a. Num a => URec (GHC.Ptr.Ptr ()) a -> Sum a :: *)
                  ~R# (forall a. Num a => URec (GHC.Ptr.Ptr ()) a -> a :: *)))
      (Data.Foldable.$fFoldableURec32
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <URec (GHC.Ptr.Ptr ()) a>_R
               ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall a. Num a => URec (GHC.Ptr.Ptr ()) a -> Product a :: *)
                  ~R# (forall a. Num a => URec (GHC.Ptr.Ptr ()) a -> a :: *)))

-- RHS size: {terms: 29, types: 43, coercions: 19, joins: 0/1}
Data.Foldable.$fFoldable:*:_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Eq a => a -> (:*:) f g a -> Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 0] 180 60}]
Data.Foldable.$fFoldable:*:_$celem
  = \ (@ (f_a6L7R :: * -> *))
      (@ (g_a6L7S :: * -> *))
      ($dFoldable_a6L7T :: Foldable f_a6L7R)
      ($dFoldable1_a6L7U :: Foldable g_a6L7S)
      (@ a_a6Lad)
      ($dEq_a6Laf :: Eq a_a6Lad)
      (eta_B1 :: a_a6Lad) ->
      let {
        f1_s6MJZ :: a_a6Lad -> Bool
        [LclId]
        f1_s6MJZ = == @ a_a6Lad $dEq_a6Laf eta_B1 } in
      (\ (ds_d6M2F :: (:*:) f_a6L7R g_a6L7S a_a6Lad) ->
         case ds_d6M2F of { :*: a1_a6KpR a2_a6KpS ->
         case (foldMap
                 @ f_a6L7R
                 $dFoldable_a6L7T
                 @ Data.Monoid.Any
                 @ a_a6Lad
                 Data.Semigroup.Internal.$fMonoidAny
                 (f1_s6MJZ
                  `cast` (<a_a6Lad>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                          :: (a_a6Lad -> Bool :: *) ~R# (a_a6Lad -> Data.Monoid.Any :: *)))
                 a1_a6KpR)
              `cast` (Data.Semigroup.Internal.N:Any[0]
                      :: (Data.Monoid.Any :: *) ~R# (Bool :: *))
         of {
           False ->
             foldMap
               @ g_a6L7S
               $dFoldable1_a6L7U
               @ Data.Monoid.Any
               @ a_a6Lad
               Data.Semigroup.Internal.$fMonoidAny
               (f1_s6MJZ
                `cast` (<a_a6Lad>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                        :: (a_a6Lad -> Bool :: *) ~R# (a_a6Lad -> Data.Monoid.Any :: *)))
               a2_a6KpS;
           True ->
             GHC.Types.True
             `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                     :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
         }
         })
      `cast` (<(:*:) f_a6L7R g_a6L7S a_a6Lad>_R
              ->_R Data.Semigroup.Internal.N:Any[0]
              :: ((:*:) f_a6L7R g_a6L7S a_a6Lad -> Data.Monoid.Any :: *)
                 ~R# ((:*:) f_a6L7R g_a6L7S a_a6Lad -> Bool :: *))

-- RHS size: {terms: 25, types: 47, coercions: 26, joins: 0/1}
Data.Foldable.$fFoldable:*:_$csum
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Num a => (:*:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30] 190 60}]
Data.Foldable.$fFoldable:*:_$csum
  = \ (@ (f_a6L7R :: * -> *))
      (@ (g_a6L7S :: * -> *))
      ($dFoldable_a6L7T :: Foldable f_a6L7R)
      ($dFoldable1_a6L7U :: Foldable g_a6L7S)
      (@ a_a6LaH)
      ($dNum_a6LaJ :: Num a_a6LaH) ->
      let {
        $dMonoid_s6MJX :: Monoid (Sum a_a6LaH)
        [LclId]
        $dMonoid_s6MJX
          = Data.Semigroup.Internal.$fMonoidSum @ a_a6LaH $dNum_a6LaJ } in
      (\ (ds_d6M2F :: (:*:) f_a6L7R g_a6L7S a_a6LaH) ->
         case ds_d6M2F of { :*: a1_a6KpR a2_a6KpS ->
         (+ @ a_a6LaH
            $dNum_a6LaJ
            ((foldMap
                @ f_a6L7R
                $dFoldable_a6L7T
                @ (Sum a_a6LaH)
                @ a_a6LaH
                $dMonoid_s6MJX
                ((Data.Foldable.$fFoldable:*:1 @ a_a6LaH)
                 `cast` (<a_a6LaH>_R
                         ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6LaH>_R)
                         :: (a_a6LaH -> a_a6LaH :: *) ~R# (a_a6LaH -> Sum a_a6LaH :: *)))
                a1_a6KpR)
             `cast` (Data.Semigroup.Internal.N:Sum[0] <a_a6LaH>_R
                     :: (Sum a_a6LaH :: *) ~R# (a_a6LaH :: *)))
            ((foldMap
                @ g_a6L7S
                $dFoldable1_a6L7U
                @ (Sum a_a6LaH)
                @ a_a6LaH
                $dMonoid_s6MJX
                ((Data.Foldable.$fFoldable:*:1 @ a_a6LaH)
                 `cast` (<a_a6LaH>_R
                         ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6LaH>_R)
                         :: (a_a6LaH -> a_a6LaH :: *) ~R# (a_a6LaH -> Sum a_a6LaH :: *)))
                a2_a6KpS)
             `cast` (Data.Semigroup.Internal.N:Sum[0] <a_a6LaH>_R
                     :: (Sum a_a6LaH :: *) ~R# (a_a6LaH :: *))))
         `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6LaH>_R)
                 :: (a_a6LaH :: *) ~R# (Sum a_a6LaH :: *))
         })
      `cast` (<(:*:) f_a6L7R g_a6L7S a_a6LaH>_R
              ->_R Data.Semigroup.Internal.N:Sum[0] <a_a6LaH>_R
              :: ((:*:) f_a6L7R g_a6L7S a_a6LaH -> Sum a_a6LaH :: *)
                 ~R# ((:*:) f_a6L7R g_a6L7S a_a6LaH -> a_a6LaH :: *))

-- RHS size: {terms: 49, types: 63, coercions: 21, joins: 0/1}
Data.Foldable.$fFoldable:*:_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Ord a => (:*:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 30 30] 320 60}]
Data.Foldable.$fFoldable:*:_$cminimum
  = \ (@ (f_a6L7R :: * -> *))
      (@ (g_a6L7S :: * -> *))
      ($dFoldable_a6L7T :: Foldable f_a6L7R)
      ($dFoldable1_a6L7U :: Foldable g_a6L7S)
      (@ a_a6Lax)
      ($dOrd_a6Laz :: Ord a_a6Lax) ->
      let {
        $dMonoid_s6MJS :: Monoid (Min a_a6Lax)
        [LclId]
        $dMonoid_s6MJS
          = Data.Functor.Utils.$fMonoidMin @ a_a6Lax $dOrd_a6Laz } in
      \ (x_X6HLQ :: (:*:) f_a6L7R g_a6L7S a_a6Lax) ->
        case x_X6HLQ of { :*: a1_a6KpR a2_a6KpS ->
        case (foldMap
                @ g_a6L7S
                $dFoldable1_a6L7U
                @ (Min a_a6Lax)
                @ a_a6Lax
                $dMonoid_s6MJS
                ((GHC.Base.Just @ a_a6Lax)
                 `cast` (<a_a6Lax>_R
                         ->_R Sym (Data.Functor.Utils.N:Min[0]) <a_a6Lax>_N
                         :: (a_a6Lax -> Maybe a_a6Lax :: *)
                            ~R# (a_a6Lax -> Min a_a6Lax :: *)))
                a2_a6KpS)
             `cast` (Data.Functor.Utils.N:Min[0] <a_a6Lax>_N
                     :: (Min a_a6Lax :: *) ~R# (Maybe a_a6Lax :: *))
        of {
          Nothing ->
            case (foldMap
                    @ f_a6L7R
                    $dFoldable_a6L7T
                    @ (Min a_a6Lax)
                    @ a_a6Lax
                    $dMonoid_s6MJS
                    ((GHC.Base.Just @ a_a6Lax)
                     `cast` (<a_a6Lax>_R
                             ->_R Sym (Data.Functor.Utils.N:Min[0]) <a_a6Lax>_N
                             :: (a_a6Lax -> Maybe a_a6Lax :: *)
                                ~R# (a_a6Lax -> Min a_a6Lax :: *)))
                    a1_a6KpR)
                 `cast` (Data.Functor.Utils.N:Min[0] <a_a6Lax>_N
                         :: (Min a_a6Lax :: *) ~R# (Maybe a_a6Lax :: *))
            of {
              Nothing -> Data.Foldable.$fFoldable:*:2 @ a_a6Lax;
              Just v_i6M0Z -> v_i6M0Z
            };
          Just ipv_i6MjP ->
            case (foldMap
                    @ f_a6L7R
                    $dFoldable_a6L7T
                    @ (Min a_a6Lax)
                    @ a_a6Lax
                    $dMonoid_s6MJS
                    ((GHC.Base.Just @ a_a6Lax)
                     `cast` (<a_a6Lax>_R
                             ->_R Sym (Data.Functor.Utils.N:Min[0]) <a_a6Lax>_N
                             :: (a_a6Lax -> Maybe a_a6Lax :: *)
                                ~R# (a_a6Lax -> Min a_a6Lax :: *)))
                    a1_a6KpR)
                 `cast` (Data.Functor.Utils.N:Min[0] <a_a6Lax>_N
                         :: (Min a_a6Lax :: *) ~R# (Maybe a_a6Lax :: *))
            of {
              Nothing -> ipv_i6MjP;
              Just x1_i6MjV ->
                case <= @ a_a6Lax $dOrd_a6Laz x1_i6MjV ipv_i6MjP of {
                  False -> ipv_i6MjP;
                  True -> x1_i6MjV
                }
            }
        }
        }

-- RHS size: {terms: 49, types: 63, coercions: 21, joins: 0/1}
Data.Foldable.$fFoldable:*:_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Ord a => (:*:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 30 30] 320 60}]
Data.Foldable.$fFoldable:*:_$cmaximum
  = \ (@ (f_a6L7R :: * -> *))
      (@ (g_a6L7S :: * -> *))
      ($dFoldable_a6L7T :: Foldable f_a6L7R)
      ($dFoldable1_a6L7U :: Foldable g_a6L7S)
      (@ a_a6Lan)
      ($dOrd_a6Lap :: Ord a_a6Lan) ->
      let {
        $dMonoid_s6MJO :: Monoid (Max a_a6Lan)
        [LclId]
        $dMonoid_s6MJO
          = Data.Functor.Utils.$fMonoidMax @ a_a6Lan $dOrd_a6Lap } in
      \ (x_X6HLR :: (:*:) f_a6L7R g_a6L7S a_a6Lan) ->
        case x_X6HLR of { :*: a1_a6KpR a2_a6KpS ->
        case (foldMap
                @ g_a6L7S
                $dFoldable1_a6L7U
                @ (Max a_a6Lan)
                @ a_a6Lan
                $dMonoid_s6MJO
                ((GHC.Base.Just @ a_a6Lan)
                 `cast` (<a_a6Lan>_R
                         ->_R Sym (Data.Functor.Utils.N:Max[0]) <a_a6Lan>_N
                         :: (a_a6Lan -> Maybe a_a6Lan :: *)
                            ~R# (a_a6Lan -> Max a_a6Lan :: *)))
                a2_a6KpS)
             `cast` (Data.Functor.Utils.N:Max[0] <a_a6Lan>_N
                     :: (Max a_a6Lan :: *) ~R# (Maybe a_a6Lan :: *))
        of {
          Nothing ->
            case (foldMap
                    @ f_a6L7R
                    $dFoldable_a6L7T
                    @ (Max a_a6Lan)
                    @ a_a6Lan
                    $dMonoid_s6MJO
                    ((GHC.Base.Just @ a_a6Lan)
                     `cast` (<a_a6Lan>_R
                             ->_R Sym (Data.Functor.Utils.N:Max[0]) <a_a6Lan>_N
                             :: (a_a6Lan -> Maybe a_a6Lan :: *)
                                ~R# (a_a6Lan -> Max a_a6Lan :: *)))
                    a1_a6KpR)
                 `cast` (Data.Functor.Utils.N:Max[0] <a_a6Lan>_N
                         :: (Max a_a6Lan :: *) ~R# (Maybe a_a6Lan :: *))
            of {
              Nothing -> Data.Foldable.$fFoldable:*:3 @ a_a6Lan;
              Just v_i6M0Z -> v_i6M0Z
            };
          Just ipv_i6Mjp ->
            case (foldMap
                    @ f_a6L7R
                    $dFoldable_a6L7T
                    @ (Max a_a6Lan)
                    @ a_a6Lan
                    $dMonoid_s6MJO
                    ((GHC.Base.Just @ a_a6Lan)
                     `cast` (<a_a6Lan>_R
                             ->_R Sym (Data.Functor.Utils.N:Max[0]) <a_a6Lan>_N
                             :: (a_a6Lan -> Maybe a_a6Lan :: *)
                                ~R# (a_a6Lan -> Max a_a6Lan :: *)))
                    a1_a6KpR)
                 `cast` (Data.Functor.Utils.N:Max[0] <a_a6Lan>_N
                         :: (Max a_a6Lan :: *) ~R# (Maybe a_a6Lan :: *))
            of {
              Nothing -> ipv_i6Mjp;
              Just x1_i6Mjv ->
                case >= @ a_a6Lan $dOrd_a6Lap x1_i6Mjv ipv_i6Mjp of {
                  False -> ipv_i6Mjp;
                  True -> x1_i6Mjv
                }
            }
        }
        }

-- RHS size: {terms: 34, types: 46, coercions: 0, joins: 0/1}
Data.Foldable.$w$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. (a -> a -> a) -> f a -> g a -> a
[GblId,
 Arity=5,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 0 0] 210 0}]
Data.Foldable.$w$cfoldr1
  = \ (@ (f_s6NTC :: * -> *))
      (@ (g_s6NTD :: * -> *))
      (w_s6NTE :: Foldable f_s6NTC)
      (w1_s6NTF :: Foldable g_s6NTD)
      (@ a_s6NTG)
      (w2_s6NTH :: a_s6NTG -> a_s6NTG -> a_s6NTG)
      (ww_s6NTL :: f_s6NTC a_s6NTG)
      (ww1_s6NTM :: g_s6NTD a_s6NTG) ->
      let {
        f1_s6MJL :: a_s6NTG -> Maybe a_s6NTG -> Maybe a_s6NTG
        [LclId,
         Arity=2,
         Str=<L,U><L,1*U>,
         Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True,
                 Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
                 Tmpl= \ (x_a6K7M [Occ=Once*] :: a_s6NTG)
                         (m_a6K7N [Occ=Once!] :: Maybe a_s6NTG) ->
                         GHC.Base.Just
                           @ a_s6NTG
                           (case m_a6K7N of {
                              Nothing -> x_a6K7M;
                              Just y_a6K7O [Occ=Once] -> w2_s6NTH x_a6K7M y_a6K7O
                            })}]
        f1_s6MJL
          = \ (x_a6K7M :: a_s6NTG) (m_a6K7N :: Maybe a_s6NTG) ->
              GHC.Base.Just
                @ a_s6NTG
                (case m_a6K7N of {
                   Nothing -> x_a6K7M;
                   Just y_a6K7O -> w2_s6NTH x_a6K7M y_a6K7O
                 }) } in
      case foldr
             @ f_s6NTC
             w_s6NTE
             @ a_s6NTG
             @ (Maybe a_s6NTG)
             f1_s6MJL
             (foldr
                @ g_s6NTD
                w1_s6NTF
                @ a_s6NTG
                @ (Maybe a_s6NTG)
                f1_s6MJL
                (GHC.Base.Nothing @ a_s6NTG)
                ww1_s6NTM)
             ww_s6NTL
      of {
        Nothing -> Data.Foldable.$fFoldable:*:8 @ a_s6NTG;
        Just v_i6M0Z -> v_i6M0Z
      }

-- RHS size: {terms: 16, types: 36, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:*:_$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. (a -> a -> a) -> (:*:) f g a -> a
[GblId,
 Arity=4,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_s6NTC :: * -> *))
                 (@ (g_s6NTD :: * -> *))
                 (w_s6NTE [Occ=Once] :: Foldable f_s6NTC)
                 (w1_s6NTF [Occ=Once] :: Foldable g_s6NTD)
                 (@ a_s6NTG)
                 (w2_s6NTH [Occ=Once] :: a_s6NTG -> a_s6NTG -> a_s6NTG)
                 (w3_s6NTI [Occ=Once!] :: (:*:) f_s6NTC g_s6NTD a_s6NTG) ->
                 case w3_s6NTI of { :*: ww1_s6NTL [Occ=Once] ww2_s6NTM [Occ=Once] ->
                 Data.Foldable.$w$cfoldr1
                   @ f_s6NTC
                   @ g_s6NTD
                   w_s6NTE
                   w1_s6NTF
                   @ a_s6NTG
                   w2_s6NTH
                   ww1_s6NTL
                   ww2_s6NTM
                 }}]
Data.Foldable.$fFoldable:*:_$cfoldr1
  = \ (@ (f_s6NTC :: * -> *))
      (@ (g_s6NTD :: * -> *))
      (w_s6NTE :: Foldable f_s6NTC)
      (w1_s6NTF :: Foldable g_s6NTD)
      (@ a_s6NTG)
      (w2_s6NTH :: a_s6NTG -> a_s6NTG -> a_s6NTG)
      (w3_s6NTI :: (:*:) f_s6NTC g_s6NTD a_s6NTG) ->
      case w3_s6NTI of { :*: ww1_s6NTL ww2_s6NTM ->
      Data.Foldable.$w$cfoldr1
        @ f_s6NTC
        @ g_s6NTD
        w_s6NTE
        w1_s6NTF
        @ a_s6NTG
        w2_s6NTH
        ww1_s6NTL
        ww2_s6NTM
      }

-- RHS size: {terms: 31, types: 43, coercions: 0, joins: 0/1}
Data.Foldable.$w$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall b a. (b -> a -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 0 0 0] 210 0}]
Data.Foldable.$w$cfoldl'
  = \ (@ (f_s6NTP :: * -> *))
      (@ (g_s6NTQ :: * -> *))
      (w_s6NTR :: Foldable f_s6NTP)
      (w1_s6NTS :: Foldable g_s6NTQ)
      (@ b_s6NTT)
      (@ a_s6NTU)
      (w2_s6NTV :: b_s6NTT -> a_s6NTU -> b_s6NTT)
      (w3_s6NTW :: b_s6NTT)
      (ww_s6NU0 :: f_s6NTP a_s6NTU)
      (ww1_s6NU1 :: g_s6NTQ a_s6NTU) ->
      let {
        f1_s6MJJ :: a_s6NTU -> (b_s6NTT -> b_s6NTT) -> b_s6NTT -> b_s6NTT
        [LclId,
         Arity=3,
         Str=<L,U><C(S),1*C1(U)><L,U>,
         Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True,
                 Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
                 Tmpl= \ (x_a6K7G [Occ=Once] :: a_s6NTU)
                         (k_a6K7H [Occ=Once!] :: b_s6NTT -> b_s6NTT)
                         (z_a6K7I [Occ=Once] :: b_s6NTT) ->
                         case w2_s6NTV z_a6K7I x_a6K7G of vx_i6M0K { __DEFAULT ->
                         k_a6K7H vx_i6M0K
                         }}]
        f1_s6MJJ
          = \ (x_a6K7G :: a_s6NTU)
              (k_a6K7H :: b_s6NTT -> b_s6NTT)
              (z_a6K7I :: b_s6NTT) ->
              case w2_s6NTV z_a6K7I x_a6K7G of vx_i6M0K { __DEFAULT ->
              k_a6K7H vx_i6M0K
              } } in
      foldr
        @ f_s6NTP
        w_s6NTR
        @ a_s6NTU
        @ (b_s6NTT -> b_s6NTT)
        f1_s6MJJ
        (foldr
           @ g_s6NTQ
           w1_s6NTS
           @ a_s6NTU
           @ (b_s6NTT -> b_s6NTT)
           f1_s6MJJ
           (id @ b_s6NTT)
           ww1_s6NU1)
        ww_s6NU0
        w3_s6NTW

-- RHS size: {terms: 19, types: 40, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:*:_$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (:*:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_s6NTP :: * -> *))
                 (@ (g_s6NTQ :: * -> *))
                 (w_s6NTR [Occ=Once] :: Foldable f_s6NTP)
                 (w1_s6NTS [Occ=Once] :: Foldable g_s6NTQ)
                 (@ b_s6NTT)
                 (@ a_s6NTU)
                 (w2_s6NTV [Occ=Once] :: b_s6NTT -> a_s6NTU -> b_s6NTT)
                 (w3_s6NTW [Occ=Once] :: b_s6NTT)
                 (w4_s6NTX [Occ=Once!] :: (:*:) f_s6NTP g_s6NTQ a_s6NTU) ->
                 case w4_s6NTX of { :*: ww1_s6NU0 [Occ=Once] ww2_s6NU1 [Occ=Once] ->
                 Data.Foldable.$w$cfoldl'
                   @ f_s6NTP
                   @ g_s6NTQ
                   w_s6NTR
                   w1_s6NTS
                   @ b_s6NTT
                   @ a_s6NTU
                   w2_s6NTV
                   w3_s6NTW
                   ww1_s6NU0
                   ww2_s6NU1
                 }}]
Data.Foldable.$fFoldable:*:_$cfoldl'
  = \ (@ (f_s6NTP :: * -> *))
      (@ (g_s6NTQ :: * -> *))
      (w_s6NTR :: Foldable f_s6NTP)
      (w1_s6NTS :: Foldable g_s6NTQ)
      (@ b_s6NTT)
      (@ a_s6NTU)
      (w2_s6NTV :: b_s6NTT -> a_s6NTU -> b_s6NTT)
      (w3_s6NTW :: b_s6NTT)
      (w4_s6NTX :: (:*:) f_s6NTP g_s6NTQ a_s6NTU) ->
      case w4_s6NTX of { :*: ww1_s6NU0 ww2_s6NU1 ->
      Data.Foldable.$w$cfoldl'
        @ f_s6NTP
        @ g_s6NTQ
        w_s6NTR
        w1_s6NTS
        @ b_s6NTT
        @ a_s6NTU
        w2_s6NTV
        w3_s6NTW
        ww1_s6NU0
        ww2_s6NU1
      }

-- RHS size: {terms: 12, types: 8, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableM2
  :: forall a. a -> (Int -> Int) -> Int -> Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U(U))><S,1*U(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 60 20] 41 0}]
Data.Foldable.$fFoldableM2
  = \ (@ a_a6La5)
      _ [Occ=Dead]
      (k_a6K7H :: Int -> Int)
      (z_a6K7I :: Int) ->
      case z_a6K7I of { I# x1_i6Me0 ->
      k_a6K7H (GHC.Types.I# (+# x1_i6Me0 1#))
      }

-- RHS size: {terms: 19, types: 41, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:*:_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. (:*:) f g a -> Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6L7R :: * -> *))
                 (@ (g_a6L7S :: * -> *))
                 ($dFoldable_a6L7T [Occ=Once] :: Foldable f_a6L7R)
                 ($dFoldable1_a6L7U [Occ=Once] :: Foldable g_a6L7S)
                 (@ a_a6La5)
                 (eta_B1 [Occ=Once] :: (:*:) f_a6L7R g_a6L7S a_a6La5) ->
                 Data.Foldable.$fFoldable:*:_$cfoldl'
                   @ f_a6L7R
                   @ g_a6L7S
                   $dFoldable_a6L7T
                   $dFoldable1_a6L7U
                   @ Int
                   @ a_a6La5
                   (Data.Foldable.$fFoldable:*:5 @ a_a6La5)
                   Data.Foldable.$fFoldable:*:4
                   eta_B1}]
Data.Foldable.$fFoldable:*:_$clength
  = \ (@ (f_a6L7R :: * -> *))
      (@ (g_a6L7S :: * -> *))
      ($dFoldable_a6L7T :: Foldable f_a6L7R)
      ($dFoldable1_a6L7U :: Foldable g_a6L7S)
      (@ a_a6La5)
      (eta_B1 :: (:*:) f_a6L7R g_a6L7S a_a6La5) ->
      case eta_B1 of { :*: ww1_s6NU0 ww2_s6NU1 ->
      foldr
        @ f_a6L7R
        $dFoldable_a6L7T
        @ a_a6La5
        @ (Int -> Int)
        (Data.Foldable.$fFoldableM2 @ a_a6La5)
        (foldr
           @ g_a6L7S
           $dFoldable1_a6L7U
           @ a_a6La5
           @ (Int -> Int)
           (Data.Foldable.$fFoldableM2 @ a_a6La5)
           (id @ Int)
           ww2_s6NU1)
        ww1_s6NU0
        Data.Foldable.$fFoldable:*:4
      }

-- RHS size: {terms: 27, types: 41, coercions: 18, joins: 0/1}
Data.Foldable.$w$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall b a. (b -> a -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 0 0 0] 180 0}]
Data.Foldable.$w$cfoldl
  = \ (@ (f_s6NU4 :: * -> *))
      (@ (g_s6NU5 :: * -> *))
      (w_s6NU6 :: Foldable f_s6NU4)
      (w1_s6NU7 :: Foldable g_s6NU5)
      (@ b_s6NU8)
      (@ a_s6NU9)
      (w2_s6NUa :: b_s6NU8 -> a_s6NU9 -> b_s6NU8)
      (w3_s6NUb :: b_s6NU8)
      (ww_s6NUf :: f_s6NU4 a_s6NU9)
      (ww1_s6NUg :: g_s6NU5 a_s6NU9) ->
      let {
        f1_s6MJH :: a_s6NU9 -> b_s6NU8 -> b_s6NU8
        [LclId,
         Arity=2,
         Str=<L,U><L,U>,
         Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True,
                 Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
                 Tmpl= \ (x_X6HLX [Occ=Once] :: a_s6NU9)
                         (y_i6M0a [Occ=Once] :: b_s6NU8) ->
                         w2_s6NUa y_i6M0a x_X6HLX}]
        f1_s6MJH
          = \ (x_X6HLX :: a_s6NU9) (y_i6M0a :: b_s6NU8) ->
              w2_s6NUa y_i6M0a x_X6HLX } in
      ((foldMap
          @ g_s6NU5
          w1_s6NU7
          @ (Dual (Endo b_s6NU8))
          @ a_s6NU9
          (Data.Foldable.$fFoldable:*:7 @ b_s6NU8)
          (f1_s6MJH
           `cast` (<a_s6NU9>_R
                   ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                 (Data.Semigroup.Internal.N:Endo[0] <b_s6NU8>_R))
                   :: (a_s6NU9 -> b_s6NU8 -> b_s6NU8 :: *)
                      ~R# (a_s6NU9 -> Dual (Endo b_s6NU8) :: *)))
          ww1_s6NUg)
       `cast` (Data.Semigroup.Internal.N:Dual[0]
                   (Data.Semigroup.Internal.N:Endo[0] <b_s6NU8>_R)
               :: (Dual (Endo b_s6NU8) :: *) ~R# (b_s6NU8 -> b_s6NU8 :: *)))
        (((foldMap
             @ f_s6NU4
             w_s6NU6
             @ (Dual (Endo b_s6NU8))
             @ a_s6NU9
             (Data.Foldable.$fFoldable:*:7 @ b_s6NU8)
             (f1_s6MJH
              `cast` (<a_s6NU9>_R
                      ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                    (Data.Semigroup.Internal.N:Endo[0] <b_s6NU8>_R))
                      :: (a_s6NU9 -> b_s6NU8 -> b_s6NU8 :: *)
                         ~R# (a_s6NU9 -> Dual (Endo b_s6NU8) :: *)))
             ww_s6NUf)
          `cast` (Data.Semigroup.Internal.N:Dual[0]
                      (Data.Semigroup.Internal.N:Endo[0] <b_s6NU8>_R)
                  :: (Dual (Endo b_s6NU8) :: *) ~R# (b_s6NU8 -> b_s6NU8 :: *)))
           w3_s6NUb)

-- RHS size: {terms: 19, types: 40, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:*:_$cfoldl [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (:*:) f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_s6NU4 :: * -> *))
                 (@ (g_s6NU5 :: * -> *))
                 (w_s6NU6 [Occ=Once] :: Foldable f_s6NU4)
                 (w1_s6NU7 [Occ=Once] :: Foldable g_s6NU5)
                 (@ b_s6NU8)
                 (@ a_s6NU9)
                 (w2_s6NUa [Occ=Once] :: b_s6NU8 -> a_s6NU9 -> b_s6NU8)
                 (w3_s6NUb [Occ=Once] :: b_s6NU8)
                 (w4_s6NUc [Occ=Once!] :: (:*:) f_s6NU4 g_s6NU5 a_s6NU9) ->
                 case w4_s6NUc of { :*: ww1_s6NUf [Occ=Once] ww2_s6NUg [Occ=Once] ->
                 Data.Foldable.$w$cfoldl
                   @ f_s6NU4
                   @ g_s6NU5
                   w_s6NU6
                   w1_s6NU7
                   @ b_s6NU8
                   @ a_s6NU9
                   w2_s6NUa
                   w3_s6NUb
                   ww1_s6NUf
                   ww2_s6NUg
                 }}]
Data.Foldable.$fFoldable:*:_$cfoldl
  = \ (@ (f_s6NU4 :: * -> *))
      (@ (g_s6NU5 :: * -> *))
      (w_s6NU6 :: Foldable f_s6NU4)
      (w1_s6NU7 :: Foldable g_s6NU5)
      (@ b_s6NU8)
      (@ a_s6NU9)
      (w2_s6NUa :: b_s6NU8 -> a_s6NU9 -> b_s6NU8)
      (w3_s6NUb :: b_s6NU8)
      (w4_s6NUc :: (:*:) f_s6NU4 g_s6NU5 a_s6NU9) ->
      case w4_s6NUc of { :*: ww1_s6NUf ww2_s6NUg ->
      Data.Foldable.$w$cfoldl
        @ f_s6NU4
        @ g_s6NU5
        w_s6NU6
        w1_s6NU7
        @ b_s6NU8
        @ a_s6NU9
        w2_s6NUa
        w3_s6NUb
        ww1_s6NUf
        ww2_s6NUg
      }

-- RHS size: {terms: 36, types: 54, coercions: 22, joins: 0/1}
Data.Foldable.$w$cfoldl1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. (a -> a -> a) -> f a -> g a -> a
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 0 0] 230 0}]
Data.Foldable.$w$cfoldl1
  = \ (@ (f_s6NUj :: * -> *))
      (@ (g_s6NUk :: * -> *))
      (w_s6NUl :: Foldable f_s6NUj)
      (w1_s6NUm :: Foldable g_s6NUk)
      (@ a_s6NUn)
      (w2_s6NUo :: a_s6NUn -> a_s6NUn -> a_s6NUn)
      (ww_s6NUs :: f_s6NUj a_s6NUn)
      (ww1_s6NUt :: g_s6NUk a_s6NUn) ->
      let {
        f1_s6MJH :: a_s6NUn -> Maybe a_s6NUn -> Maybe a_s6NUn
        [LclId,
         Arity=2,
         Str=<L,U><L,1*U>,
         Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True,
                 Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
                 Tmpl= \ (x_X6HLX [Occ=Once*] :: a_s6NUn)
                         (y_i6M0a [Occ=Once!] :: Maybe a_s6NUn) ->
                         GHC.Base.Just
                           @ a_s6NUn
                           (case y_i6M0a of {
                              Nothing -> x_X6HLX;
                              Just x1_a6K7U [Occ=Once] -> w2_s6NUo x1_a6K7U x_X6HLX
                            })}]
        f1_s6MJH
          = \ (x_X6HLX :: a_s6NUn) (y_i6M0a :: Maybe a_s6NUn) ->
              GHC.Base.Just
                @ a_s6NUn
                (case y_i6M0a of {
                   Nothing -> x_X6HLX;
                   Just x1_a6K7U -> w2_s6NUo x1_a6K7U x_X6HLX
                 }) } in
      case ((foldMap
               @ g_s6NUk
               w1_s6NUm
               @ (Dual (Endo (Maybe a_s6NUn)))
               @ a_s6NUn
               (Data.Foldable.$fFoldable:*:7 @ (Maybe a_s6NUn))
               (f1_s6MJH
                `cast` (<a_s6NUn>_R
                        ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                      (Data.Semigroup.Internal.N:Endo[0] <Maybe a_s6NUn>_R))
                        :: (a_s6NUn -> Maybe a_s6NUn -> Maybe a_s6NUn :: *)
                           ~R# (a_s6NUn -> Dual (Endo (Maybe a_s6NUn)) :: *)))
               ww1_s6NUt)
            `cast` (Data.Semigroup.Internal.N:Dual[0]
                        (Data.Semigroup.Internal.N:Endo[0] <Maybe a_s6NUn>_R)
                    :: (Dual (Endo (Maybe a_s6NUn)) :: *)
                       ~R# (Maybe a_s6NUn -> Maybe a_s6NUn :: *)))
             (((foldMap
                  @ f_s6NUj
                  w_s6NUl
                  @ (Dual (Endo (Maybe a_s6NUn)))
                  @ a_s6NUn
                  (Data.Foldable.$fFoldable:*:7 @ (Maybe a_s6NUn))
                  (f1_s6MJH
                   `cast` (<a_s6NUn>_R
                           ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                         (Data.Semigroup.Internal.N:Endo[0] <Maybe a_s6NUn>_R))
                           :: (a_s6NUn -> Maybe a_s6NUn -> Maybe a_s6NUn :: *)
                              ~R# (a_s6NUn -> Dual (Endo (Maybe a_s6NUn)) :: *)))
                  ww_s6NUs)
               `cast` (Data.Semigroup.Internal.N:Dual[0]
                           (Data.Semigroup.Internal.N:Endo[0] <Maybe a_s6NUn>_R)
                       :: (Dual (Endo (Maybe a_s6NUn)) :: *)
                          ~R# (Maybe a_s6NUn -> Maybe a_s6NUn :: *)))
                (GHC.Base.Nothing @ a_s6NUn))
      of {
        Nothing -> Data.Foldable.$fFoldable:*:6 @ a_s6NUn;
        Just v_i6M0Z -> v_i6M0Z
      }

-- RHS size: {terms: 16, types: 36, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:*:_$cfoldl1 [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. (a -> a -> a) -> (:*:) f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_s6NUj :: * -> *))
                 (@ (g_s6NUk :: * -> *))
                 (w_s6NUl [Occ=Once] :: Foldable f_s6NUj)
                 (w1_s6NUm [Occ=Once] :: Foldable g_s6NUk)
                 (@ a_s6NUn)
                 (w2_s6NUo [Occ=Once] :: a_s6NUn -> a_s6NUn -> a_s6NUn)
                 (w3_s6NUp [Occ=Once!] :: (:*:) f_s6NUj g_s6NUk a_s6NUn) ->
                 case w3_s6NUp of { :*: ww1_s6NUs [Occ=Once] ww2_s6NUt [Occ=Once] ->
                 Data.Foldable.$w$cfoldl1
                   @ f_s6NUj
                   @ g_s6NUk
                   w_s6NUl
                   w1_s6NUm
                   @ a_s6NUn
                   w2_s6NUo
                   ww1_s6NUs
                   ww2_s6NUt
                 }}]
Data.Foldable.$fFoldable:*:_$cfoldl1
  = \ (@ (f_s6NUj :: * -> *))
      (@ (g_s6NUk :: * -> *))
      (w_s6NUl :: Foldable f_s6NUj)
      (w1_s6NUm :: Foldable g_s6NUk)
      (@ a_s6NUn)
      (w2_s6NUo :: a_s6NUn -> a_s6NUn -> a_s6NUn)
      (w3_s6NUp :: (:*:) f_s6NUj g_s6NUk a_s6NUn) ->
      case w3_s6NUp of { :*: ww1_s6NUs ww2_s6NUt ->
      Data.Foldable.$w$cfoldl1
        @ f_s6NUj
        @ g_s6NUk
        w_s6NUl
        w1_s6NUm
        @ a_s6NUn
        w2_s6NUo
        ww1_s6NUs
        ww2_s6NUt
      }

-- RHS size: {terms: 33, types: 51, coercions: 22, joins: 0/1}
Data.Foldable.$w$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a b. (a -> b -> b) -> b -> f a -> g a -> b
[GblId,
 Arity=6,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 0 0 0] 230 0}]
Data.Foldable.$w$cfoldr'
  = \ (@ (f_s6NUw :: * -> *))
      (@ (g_s6NUx :: * -> *))
      (w_s6NUy :: Foldable f_s6NUw)
      (w1_s6NUz :: Foldable g_s6NUx)
      (@ a_s6NUA)
      (@ b_s6NUB)
      (w2_s6NUC :: a_s6NUA -> b_s6NUB -> b_s6NUB)
      (w3_s6NUD :: b_s6NUB)
      (ww_s6NUH :: f_s6NUw a_s6NUA)
      (ww1_s6NUI :: g_s6NUx a_s6NUA) ->
      let {
        f1_s6MJH :: a_s6NUA -> (b_s6NUB -> b_s6NUB) -> b_s6NUB -> b_s6NUB
        [LclId,
         Arity=3,
         Str=<L,U><C(S),1*C1(U)><L,U>,
         Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True,
                 Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
                 Tmpl= \ (x_X6HLX [Occ=Once] :: a_s6NUA)
                         (y_i6M0a [Occ=Once!] :: b_s6NUB -> b_s6NUB)
                         (z_a6K7y [Occ=Once] :: b_s6NUB) ->
                         case w2_s6NUC x_X6HLX z_a6K7y of vx_i6M0K { __DEFAULT ->
                         y_i6M0a vx_i6M0K
                         }}]
        f1_s6MJH
          = \ (x_X6HLX :: a_s6NUA)
              (y_i6M0a :: b_s6NUB -> b_s6NUB)
              (z_a6K7y :: b_s6NUB) ->
              case w2_s6NUC x_X6HLX z_a6K7y of vx_i6M0K { __DEFAULT ->
              y_i6M0a vx_i6M0K
              } } in
      ((foldMap
          @ g_s6NUx
          w1_s6NUz
          @ (Dual (Endo (b_s6NUB -> b_s6NUB)))
          @ a_s6NUA
          (Data.Foldable.$fFoldable:*:7 @ (b_s6NUB -> b_s6NUB))
          (f1_s6MJH
           `cast` (<a_s6NUA>_R
                   ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                 (Data.Semigroup.Internal.N:Endo[0] <b_s6NUB -> b_s6NUB>_R))
                   :: (a_s6NUA -> (b_s6NUB -> b_s6NUB) -> b_s6NUB -> b_s6NUB :: *)
                      ~R# (a_s6NUA -> Dual (Endo (b_s6NUB -> b_s6NUB)) :: *)))
          ww1_s6NUI)
       `cast` (Data.Semigroup.Internal.N:Dual[0]
                   (Data.Semigroup.Internal.N:Endo[0] <b_s6NUB -> b_s6NUB>_R)
               :: (Dual (Endo (b_s6NUB -> b_s6NUB)) :: *)
                  ~R# ((b_s6NUB -> b_s6NUB) -> b_s6NUB -> b_s6NUB :: *)))
        (((foldMap
             @ f_s6NUw
             w_s6NUy
             @ (Dual (Endo (b_s6NUB -> b_s6NUB)))
             @ a_s6NUA
             (Data.Foldable.$fFoldable:*:7 @ (b_s6NUB -> b_s6NUB))
             (f1_s6MJH
              `cast` (<a_s6NUA>_R
                      ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                    (Data.Semigroup.Internal.N:Endo[0] <b_s6NUB -> b_s6NUB>_R))
                      :: (a_s6NUA -> (b_s6NUB -> b_s6NUB) -> b_s6NUB -> b_s6NUB :: *)
                         ~R# (a_s6NUA -> Dual (Endo (b_s6NUB -> b_s6NUB)) :: *)))
             ww_s6NUH)
          `cast` (Data.Semigroup.Internal.N:Dual[0]
                      (Data.Semigroup.Internal.N:Endo[0] <b_s6NUB -> b_s6NUB>_R)
                  :: (Dual (Endo (b_s6NUB -> b_s6NUB)) :: *)
                     ~R# ((b_s6NUB -> b_s6NUB) -> b_s6NUB -> b_s6NUB :: *)))
           (id @ b_s6NUB))
        w3_s6NUD

-- RHS size: {terms: 19, types: 40, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:*:_$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (:*:) f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_s6NUw :: * -> *))
                 (@ (g_s6NUx :: * -> *))
                 (w_s6NUy [Occ=Once] :: Foldable f_s6NUw)
                 (w1_s6NUz [Occ=Once] :: Foldable g_s6NUx)
                 (@ a_s6NUA)
                 (@ b_s6NUB)
                 (w2_s6NUC [Occ=Once] :: a_s6NUA -> b_s6NUB -> b_s6NUB)
                 (w3_s6NUD [Occ=Once] :: b_s6NUB)
                 (w4_s6NUE [Occ=Once!] :: (:*:) f_s6NUw g_s6NUx a_s6NUA) ->
                 case w4_s6NUE of { :*: ww1_s6NUH [Occ=Once] ww2_s6NUI [Occ=Once] ->
                 Data.Foldable.$w$cfoldr'
                   @ f_s6NUw
                   @ g_s6NUx
                   w_s6NUy
                   w1_s6NUz
                   @ a_s6NUA
                   @ b_s6NUB
                   w2_s6NUC
                   w3_s6NUD
                   ww1_s6NUH
                   ww2_s6NUI
                 }}]
Data.Foldable.$fFoldable:*:_$cfoldr'
  = \ (@ (f_s6NUw :: * -> *))
      (@ (g_s6NUx :: * -> *))
      (w_s6NUy :: Foldable f_s6NUw)
      (w1_s6NUz :: Foldable g_s6NUx)
      (@ a_s6NUA)
      (@ b_s6NUB)
      (w2_s6NUC :: a_s6NUA -> b_s6NUB -> b_s6NUB)
      (w3_s6NUD :: b_s6NUB)
      (w4_s6NUE :: (:*:) f_s6NUw g_s6NUx a_s6NUA) ->
      case w4_s6NUE of { :*: ww1_s6NUH ww2_s6NUI ->
      Data.Foldable.$w$cfoldr'
        @ f_s6NUw
        @ g_s6NUx
        w_s6NUy
        w1_s6NUz
        @ a_s6NUA
        @ b_s6NUB
        w2_s6NUC
        w3_s6NUD
        ww1_s6NUH
        ww2_s6NUI
      }

-- RHS size: {terms: 17, types: 37, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:*:_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall m. Monoid m => (:*:) f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(S))L),U(U,U,U,U)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6L7R :: * -> *))
                 (@ (g_a6L7S :: * -> *))
                 ($dFoldable_a6L7T [Occ=Once] :: Foldable f_a6L7R)
                 ($dFoldable1_a6L7U [Occ=Once] :: Foldable g_a6L7S)
                 (@ m_a6L7Y)
                 ($dMonoid_a6L80 [Occ=Once] :: Monoid m_a6L7Y) ->
                 Data.Foldable.$fFoldable:*:_$cfoldMap
                   @ f_a6L7R
                   @ g_a6L7S
                   $dFoldable_a6L7T
                   $dFoldable1_a6L7U
                   @ m_a6L7Y
                   @ m_a6L7Y
                   $dMonoid_a6L80
                   (id @ m_a6L7Y)}]
Data.Foldable.$fFoldable:*:_$cfold
  = \ (@ (f_a6L7R :: * -> *))
      (@ (g_a6L7S :: * -> *))
      ($dFoldable_a6L7T :: Foldable f_a6L7R)
      ($dFoldable1_a6L7U :: Foldable g_a6L7S)
      (@ m_a6L7Y)
      ($dMonoid_a6L80 :: Monoid m_a6L7Y)
      (w_s6NSh :: (:*:) f_a6L7R g_a6L7S m_a6L7Y) ->
      case w_s6NSh of { :*: ww1_s6NSk ww2_s6NSl ->
      Data.Foldable.$w$cfoldMap
        @ f_a6L7R
        @ g_a6L7S
        $dFoldable_a6L7T
        $dFoldable1_a6L7U
        @ m_a6L7Y
        @ m_a6L7Y
        $dMonoid_a6L80
        (id @ m_a6L7Y)
        ww1_s6NSk
        ww2_s6NSl
      }

-- RHS size: {terms: 25, types: 47, coercions: 26, joins: 0/1}
Data.Foldable.$fFoldable:*:_$cproduct
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Num a => (:*:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30] 190 60}]
Data.Foldable.$fFoldable:*:_$cproduct
  = \ (@ (f_a6L7R :: * -> *))
      (@ (g_a6L7S :: * -> *))
      ($dFoldable_a6L7T :: Foldable f_a6L7R)
      ($dFoldable1_a6L7U :: Foldable g_a6L7S)
      (@ a_a6LaR)
      ($dNum_a6LaT :: Num a_a6LaR) ->
      let {
        $dMonoid_s6MJD :: Monoid (Product a_a6LaR)
        [LclId]
        $dMonoid_s6MJD
          = Data.Semigroup.Internal.$fMonoidProduct
              @ a_a6LaR $dNum_a6LaT } in
      (\ (ds_d6M2F :: (:*:) f_a6L7R g_a6L7S a_a6LaR) ->
         case ds_d6M2F of { :*: a1_a6KpR a2_a6KpS ->
         (* @ a_a6LaR
            $dNum_a6LaT
            ((foldMap
                @ f_a6L7R
                $dFoldable_a6L7T
                @ (Product a_a6LaR)
                @ a_a6LaR
                $dMonoid_s6MJD
                ((Data.Foldable.$fFoldable:*:1 @ a_a6LaR)
                 `cast` (<a_a6LaR>_R
                         ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LaR>_R)
                         :: (a_a6LaR -> a_a6LaR :: *)
                            ~R# (a_a6LaR -> Product a_a6LaR :: *)))
                a1_a6KpR)
             `cast` (Data.Semigroup.Internal.N:Product[0] <a_a6LaR>_R
                     :: (Product a_a6LaR :: *) ~R# (a_a6LaR :: *)))
            ((foldMap
                @ g_a6L7S
                $dFoldable1_a6L7U
                @ (Product a_a6LaR)
                @ a_a6LaR
                $dMonoid_s6MJD
                ((Data.Foldable.$fFoldable:*:1 @ a_a6LaR)
                 `cast` (<a_a6LaR>_R
                         ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LaR>_R)
                         :: (a_a6LaR -> a_a6LaR :: *)
                            ~R# (a_a6LaR -> Product a_a6LaR :: *)))
                a2_a6KpS)
             `cast` (Data.Semigroup.Internal.N:Product[0] <a_a6LaR>_R
                     :: (Product a_a6LaR :: *) ~R# (a_a6LaR :: *))))
         `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LaR>_R)
                 :: (a_a6LaR :: *) ~R# (Product a_a6LaR :: *))
         })
      `cast` (<(:*:) f_a6L7R g_a6L7S a_a6LaR>_R
              ->_R Data.Semigroup.Internal.N:Product[0] <a_a6LaR>_R
              :: ((:*:) f_a6L7R g_a6L7S a_a6LaR -> Product a_a6LaR :: *)
                 ~R# ((:*:) f_a6L7R g_a6L7S a_a6LaR -> a_a6LaR :: *))

-- RHS size: {terms: 18, types: 41, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:*:_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. (:*:) f g a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_a6L7R :: * -> *))
                 (@ (g_a6L7S :: * -> *))
                 ($dFoldable_a6L7T [Occ=Once] :: Foldable f_a6L7R)
                 ($dFoldable1_a6L7U [Occ=Once] :: Foldable g_a6L7S)
                 (@ a_a6L9L)
                 (t_a6K7V [Occ=Once] :: (:*:) f_a6L7R g_a6L7S a_a6L9L) ->
                 build
                   @ a_a6L9L
                   (\ (@ b_a6KNB)
                      (c_a6K7W [Occ=Once, OS=OneShot] :: a_a6L9L -> b_a6KNB -> b_a6KNB)
                      (n_a6K7X [Occ=Once, OS=OneShot] :: b_a6KNB) ->
                      Data.Foldable.$fFoldable:*:_$cfoldr
                        @ f_a6L7R
                        @ g_a6L7S
                        $dFoldable_a6L7T
                        $dFoldable1_a6L7U
                        @ a_a6L9L
                        @ b_a6KNB
                        c_a6K7W
                        n_a6K7X
                        t_a6K7V)}]
Data.Foldable.$fFoldable:*:_$ctoList
  = \ (@ (f_a6L7R :: * -> *))
      (@ (g_a6L7S :: * -> *))
      ($dFoldable_a6L7T :: Foldable f_a6L7R)
      ($dFoldable1_a6L7U :: Foldable g_a6L7S)
      (@ a_a6L9L)
      (eta_Xea :: (:*:) f_a6L7R g_a6L7S a_a6L9L) ->
      case eta_Xea of { :*: a1_a6KpK a2_a6KpL ->
      foldr
        @ f_a6L7R
        $dFoldable_a6L7T
        @ a_a6L9L
        @ [a_a6L9L]
        (GHC.Types.: @ a_a6L9L)
        (foldr
           @ g_a6L7S
           $dFoldable1_a6L7U
           @ a_a6L9L
           @ [a_a6L9L]
           (GHC.Types.: @ a_a6L9L)
           (GHC.Types.[] @ a_a6L9L)
           a2_a6KpL)
        a1_a6KpK
      }

-- RHS size: {terms: 53, types: 49, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:*: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     Foldable (f :*: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>,
 Unf=DFun: \ (@ (f_a6Kaw :: * -> *))
             (@ (g_a6Kax :: * -> *))
             (v_Xe8 :: Foldable f_a6Kaw)
             (v1_Xed :: Foldable g_a6Kax) ->
       Data.Foldable.C:Foldable TYPE: f_a6Kaw :*: g_a6Kax
                                Data.Foldable.$fFoldable:*:_$cfold @ f_a6Kaw @ g_a6Kax v_Xe8 v1_Xed
                                Data.Foldable.$fFoldable:*:_$cfoldMap
                                  @ f_a6Kaw @ g_a6Kax v_Xe8 v1_Xed
                                Data.Foldable.$fFoldable:*:_$cfoldr
                                  @ f_a6Kaw @ g_a6Kax v_Xe8 v1_Xed
                                Data.Foldable.$fFoldable:*:_$cfoldr'
                                  @ f_a6Kaw @ g_a6Kax v_Xe8 v1_Xed
                                Data.Foldable.$fFoldable:*:_$cfoldl
                                  @ f_a6Kaw @ g_a6Kax v_Xe8 v1_Xed
                                Data.Foldable.$fFoldable:*:_$cfoldl'
                                  @ f_a6Kaw @ g_a6Kax v_Xe8 v1_Xed
                                Data.Foldable.$fFoldable:*:_$cfoldr1
                                  @ f_a6Kaw @ g_a6Kax v_Xe8 v1_Xed
                                Data.Foldable.$fFoldable:*:_$cfoldl1
                                  @ f_a6Kaw @ g_a6Kax v_Xe8 v1_Xed
                                Data.Foldable.$fFoldable:*:_$ctoList
                                  @ f_a6Kaw @ g_a6Kax v_Xe8 v1_Xed
                                Data.Foldable.$fFoldable:*:_$cnull @ f_a6Kaw @ g_a6Kax v_Xe8 v1_Xed
                                Data.Foldable.$fFoldable:*:_$clength
                                  @ f_a6Kaw @ g_a6Kax v_Xe8 v1_Xed
                                Data.Foldable.$fFoldable:*:_$celem @ f_a6Kaw @ g_a6Kax v_Xe8 v1_Xed
                                Data.Foldable.$fFoldable:*:_$cmaximum
                                  @ f_a6Kaw @ g_a6Kax v_Xe8 v1_Xed
                                Data.Foldable.$fFoldable:*:_$cminimum
                                  @ f_a6Kaw @ g_a6Kax v_Xe8 v1_Xed
                                Data.Foldable.$fFoldable:*:_$csum @ f_a6Kaw @ g_a6Kax v_Xe8 v1_Xed
                                Data.Foldable.$fFoldable:*:_$cproduct
                                  @ f_a6Kaw @ g_a6Kax v_Xe8 v1_Xed]
Data.Foldable.$fFoldable:*:
  = \ (@ (f_a6L7R :: * -> *))
      (@ (g_a6L7S :: * -> *))
      ($dFoldable_a6L7T :: Foldable f_a6L7R)
      ($dFoldable1_a6L7U :: Foldable g_a6L7S) ->
      Data.Foldable.C:Foldable
        @ (f_a6L7R :*: g_a6L7S)
        (Data.Foldable.$fFoldable:*:_$cfold
           @ f_a6L7R @ g_a6L7S $dFoldable_a6L7T $dFoldable1_a6L7U)
        (Data.Foldable.$fFoldable:*:_$cfoldMap
           @ f_a6L7R @ g_a6L7S $dFoldable_a6L7T $dFoldable1_a6L7U)
        (Data.Foldable.$fFoldable:*:_$cfoldr
           @ f_a6L7R @ g_a6L7S $dFoldable_a6L7T $dFoldable1_a6L7U)
        (Data.Foldable.$fFoldable:*:_$cfoldr'
           @ f_a6L7R @ g_a6L7S $dFoldable_a6L7T $dFoldable1_a6L7U)
        (Data.Foldable.$fFoldable:*:_$cfoldl
           @ f_a6L7R @ g_a6L7S $dFoldable_a6L7T $dFoldable1_a6L7U)
        (Data.Foldable.$fFoldable:*:_$cfoldl'
           @ f_a6L7R @ g_a6L7S $dFoldable_a6L7T $dFoldable1_a6L7U)
        (Data.Foldable.$fFoldable:*:_$cfoldr1
           @ f_a6L7R @ g_a6L7S $dFoldable_a6L7T $dFoldable1_a6L7U)
        (Data.Foldable.$fFoldable:*:_$cfoldl1
           @ f_a6L7R @ g_a6L7S $dFoldable_a6L7T $dFoldable1_a6L7U)
        (Data.Foldable.$fFoldable:*:_$ctoList
           @ f_a6L7R @ g_a6L7S $dFoldable_a6L7T $dFoldable1_a6L7U)
        (Data.Foldable.$fFoldable:*:_$cnull
           @ f_a6L7R @ g_a6L7S $dFoldable_a6L7T $dFoldable1_a6L7U)
        (Data.Foldable.$fFoldable:*:_$clength
           @ f_a6L7R @ g_a6L7S $dFoldable_a6L7T $dFoldable1_a6L7U)
        (Data.Foldable.$fFoldable:*:_$celem
           @ f_a6L7R @ g_a6L7S $dFoldable_a6L7T $dFoldable1_a6L7U)
        (Data.Foldable.$fFoldable:*:_$cmaximum
           @ f_a6L7R @ g_a6L7S $dFoldable_a6L7T $dFoldable1_a6L7U)
        (Data.Foldable.$fFoldable:*:_$cminimum
           @ f_a6L7R @ g_a6L7S $dFoldable_a6L7T $dFoldable1_a6L7U)
        (Data.Foldable.$fFoldable:*:_$csum
           @ f_a6L7R @ g_a6L7S $dFoldable_a6L7T $dFoldable1_a6L7U)
        (Data.Foldable.$fFoldable:*:_$cproduct
           @ f_a6L7R @ g_a6L7S $dFoldable_a6L7T $dFoldable1_a6L7U)

-- RHS size: {terms: 26, types: 42, coercions: 16, joins: 0/1}
Data.Foldable.$fFoldable:+:_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Eq a => a -> (:+:) f g a -> Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 0] 170 60}]
Data.Foldable.$fFoldable:+:_$celem
  = \ (@ (f_X6LpN :: * -> *))
      (@ (g_X6LpP :: * -> *))
      ($dFoldable_X6LpR :: Foldable f_X6LpN)
      ($dFoldable1_X6LpT :: Foldable g_X6LpP)
      (@ a_a6Ldk)
      ($dEq_a6Ldm :: Eq a_a6Ldk)
      (eta_B1 :: a_a6Ldk) ->
      let {
        f1_s6MJz :: a_a6Ldk -> Bool
        [LclId]
        f1_s6MJz = == @ a_a6Ldk $dEq_a6Ldm eta_B1 } in
      (\ (ds_d6M2I :: (:+:) f_X6LpN g_X6LpP a_a6Ldk) ->
         case ds_d6M2I of {
           L1 a1_a6Kq6 ->
             foldMap
               @ f_X6LpN
               $dFoldable_X6LpR
               @ Data.Monoid.Any
               @ a_a6Ldk
               Data.Semigroup.Internal.$fMonoidAny
               (f1_s6MJz
                `cast` (<a_a6Ldk>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                        :: (a_a6Ldk -> Bool :: *) ~R# (a_a6Ldk -> Data.Monoid.Any :: *)))
               a1_a6Kq6;
           R1 a1_a6Kq8 ->
             foldMap
               @ g_X6LpP
               $dFoldable1_X6LpT
               @ Data.Monoid.Any
               @ a_a6Ldk
               Data.Semigroup.Internal.$fMonoidAny
               (f1_s6MJz
                `cast` (<a_a6Ldk>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                        :: (a_a6Ldk -> Bool :: *) ~R# (a_a6Ldk -> Data.Monoid.Any :: *)))
               a1_a6Kq8
         })
      `cast` (<(:+:) f_X6LpN g_X6LpP a_a6Ldk>_R
              ->_R Data.Semigroup.Internal.N:Any[0]
              :: ((:+:) f_X6LpN g_X6LpP a_a6Ldk -> Data.Monoid.Any :: *)
                 ~R# ((:+:) f_X6LpN g_X6LpP a_a6Ldk -> Bool :: *))

-- RHS size: {terms: 24, types: 46, coercions: 10, joins: 0/1}
Data.Foldable.$fFoldable:+:2
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Num a => (:+:) f g a -> Sum a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_X6LpF :: * -> *))
                 (@ (g_X6LpH :: * -> *))
                 ($dFoldable_X6LpJ [Occ=OnceL] :: Foldable f_X6LpF)
                 ($dFoldable1_X6LpL [Occ=OnceL] :: Foldable g_X6LpH)
                 (@ a_a6LdO)
                 ($dNum_a6LdQ [Occ=OnceL] :: Num a_a6LdO) ->
                 let {
                   $dMonoid_a6Lbk [Occ=OnceL*] :: Monoid (Sum a_a6LdO)
                   [LclId]
                   $dMonoid_a6Lbk
                     = Data.Semigroup.Internal.$fMonoidSum @ a_a6LdO $dNum_a6LdQ } in
                 \ (ds_d6M2I [Occ=Once!] :: (:+:) f_X6LpF g_X6LpH a_a6LdO) ->
                   case ds_d6M2I of {
                     L1 a1_a6Kq6 [Occ=Once] ->
                       foldMap
                         @ f_X6LpF
                         $dFoldable_X6LpJ
                         @ (Sum a_a6LdO)
                         @ a_a6LdO
                         $dMonoid_a6Lbk
                         ((Data.Foldable.$fFoldable:*:1 @ a_a6LdO)
                          `cast` (<a_a6LdO>_R
                                  ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6LdO>_R)
                                  :: (a_a6LdO -> a_a6LdO :: *) ~R# (a_a6LdO -> Sum a_a6LdO :: *)))
                         a1_a6Kq6;
                     R1 a1_a6Kq8 [Occ=Once] ->
                       foldMap
                         @ g_X6LpH
                         $dFoldable1_X6LpL
                         @ (Sum a_a6LdO)
                         @ a_a6LdO
                         $dMonoid_a6Lbk
                         ((Data.Foldable.$fFoldable:*:1 @ a_a6LdO)
                          `cast` (<a_a6LdO>_R
                                  ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6LdO>_R)
                                  :: (a_a6LdO -> a_a6LdO :: *) ~R# (a_a6LdO -> Sum a_a6LdO :: *)))
                         a1_a6Kq8
                   }}]
Data.Foldable.$fFoldable:+:2
  = \ (@ (f_X6LpF :: * -> *))
      (@ (g_X6LpH :: * -> *))
      ($dFoldable_X6LpJ :: Foldable f_X6LpF)
      ($dFoldable1_X6LpL :: Foldable g_X6LpH)
      (@ a_a6LdO)
      ($dNum_a6LdQ :: Num a_a6LdO) ->
      let {
        $dMonoid_a6Lbk :: Monoid (Sum a_a6LdO)
        [LclId]
        $dMonoid_a6Lbk
          = Data.Semigroup.Internal.$fMonoidSum @ a_a6LdO $dNum_a6LdQ } in
      \ (ds_d6M2I :: (:+:) f_X6LpF g_X6LpH a_a6LdO) ->
        case ds_d6M2I of {
          L1 a1_a6Kq6 ->
            foldMap
              @ f_X6LpF
              $dFoldable_X6LpJ
              @ (Sum a_a6LdO)
              @ a_a6LdO
              $dMonoid_a6Lbk
              ((Data.Foldable.$fFoldable:*:1 @ a_a6LdO)
               `cast` (<a_a6LdO>_R
                       ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6LdO>_R)
                       :: (a_a6LdO -> a_a6LdO :: *) ~R# (a_a6LdO -> Sum a_a6LdO :: *)))
              a1_a6Kq6;
          R1 a1_a6Kq8 ->
            foldMap
              @ g_X6LpH
              $dFoldable1_X6LpL
              @ (Sum a_a6LdO)
              @ a_a6LdO
              $dMonoid_a6Lbk
              ((Data.Foldable.$fFoldable:*:1 @ a_a6LdO)
               `cast` (<a_a6LdO>_R
                       ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6LdO>_R)
                       :: (a_a6LdO -> a_a6LdO :: *) ~R# (a_a6LdO -> Sum a_a6LdO :: *)))
              a1_a6Kq8
        }

-- RHS size: {terms: 34, types: 54, coercions: 14, joins: 0/1}
Data.Foldable.$fFoldable:+:_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Ord a => (:+:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30 0] 200 60}]
Data.Foldable.$fFoldable:+:_$cminimum
  = \ (@ (f_X6LpE :: * -> *))
      (@ (g_X6LpG :: * -> *))
      ($dFoldable_X6LpI :: Foldable f_X6LpE)
      ($dFoldable1_X6LpK :: Foldable g_X6LpG)
      (@ a_a6LdE)
      ($dOrd_a6LdG :: Ord a_a6LdE) ->
      let {
        g1_s6MJw :: Monoid (Min a_a6LdE)
        [LclId]
        g1_s6MJw
          = Data.Functor.Utils.$fMonoidMin @ a_a6LdE $dOrd_a6LdG } in
      \ (x_X6HLQ :: (:+:) f_X6LpE g_X6LpG a_a6LdE) ->
        case x_X6HLQ of {
          L1 a1_a6Kq6 ->
            case (foldMap
                    @ f_X6LpE
                    $dFoldable_X6LpI
                    @ (Min a_a6LdE)
                    @ a_a6LdE
                    g1_s6MJw
                    ((GHC.Base.Just @ a_a6LdE)
                     `cast` (<a_a6LdE>_R
                             ->_R Sym (Data.Functor.Utils.N:Min[0]) <a_a6LdE>_N
                             :: (a_a6LdE -> Maybe a_a6LdE :: *)
                                ~R# (a_a6LdE -> Min a_a6LdE :: *)))
                    a1_a6Kq6)
                 `cast` (Data.Functor.Utils.N:Min[0] <a_a6LdE>_N
                         :: (Min a_a6LdE :: *) ~R# (Maybe a_a6LdE :: *))
            of {
              Nothing -> Data.Foldable.$fFoldable:*:2 @ a_a6LdE;
              Just v_i6M0Z -> v_i6M0Z
            };
          R1 a1_a6Kq8 ->
            case (foldMap
                    @ g_X6LpG
                    $dFoldable1_X6LpK
                    @ (Min a_a6LdE)
                    @ a_a6LdE
                    g1_s6MJw
                    ((GHC.Base.Just @ a_a6LdE)
                     `cast` (<a_a6LdE>_R
                             ->_R Sym (Data.Functor.Utils.N:Min[0]) <a_a6LdE>_N
                             :: (a_a6LdE -> Maybe a_a6LdE :: *)
                                ~R# (a_a6LdE -> Min a_a6LdE :: *)))
                    a1_a6Kq8)
                 `cast` (Data.Functor.Utils.N:Min[0] <a_a6LdE>_N
                         :: (Min a_a6LdE :: *) ~R# (Maybe a_a6LdE :: *))
            of {
              Nothing -> Data.Foldable.$fFoldable:*:2 @ a_a6LdE;
              Just v_i6M0Z -> v_i6M0Z
            }
        }

-- RHS size: {terms: 34, types: 54, coercions: 14, joins: 0/1}
Data.Foldable.$fFoldable:+:_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Ord a => (:+:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30 0] 200 60}]
Data.Foldable.$fFoldable:+:_$cmaximum
  = \ (@ (f_X6LpD :: * -> *))
      (@ (g_X6LpF :: * -> *))
      ($dFoldable_X6LpH :: Foldable f_X6LpD)
      ($dFoldable1_X6LpJ :: Foldable g_X6LpF)
      (@ a_a6Ldu)
      ($dOrd_a6Ldw :: Ord a_a6Ldu) ->
      let {
        g1_s6MJs :: Monoid (Max a_a6Ldu)
        [LclId]
        g1_s6MJs
          = Data.Functor.Utils.$fMonoidMax @ a_a6Ldu $dOrd_a6Ldw } in
      \ (x_X6HLR :: (:+:) f_X6LpD g_X6LpF a_a6Ldu) ->
        case x_X6HLR of {
          L1 a1_a6Kq6 ->
            case (foldMap
                    @ f_X6LpD
                    $dFoldable_X6LpH
                    @ (Max a_a6Ldu)
                    @ a_a6Ldu
                    g1_s6MJs
                    ((GHC.Base.Just @ a_a6Ldu)
                     `cast` (<a_a6Ldu>_R
                             ->_R Sym (Data.Functor.Utils.N:Max[0]) <a_a6Ldu>_N
                             :: (a_a6Ldu -> Maybe a_a6Ldu :: *)
                                ~R# (a_a6Ldu -> Max a_a6Ldu :: *)))
                    a1_a6Kq6)
                 `cast` (Data.Functor.Utils.N:Max[0] <a_a6Ldu>_N
                         :: (Max a_a6Ldu :: *) ~R# (Maybe a_a6Ldu :: *))
            of {
              Nothing -> Data.Foldable.$fFoldable:*:3 @ a_a6Ldu;
              Just v_i6M0Z -> v_i6M0Z
            };
          R1 a1_a6Kq8 ->
            case (foldMap
                    @ g_X6LpF
                    $dFoldable1_X6LpJ
                    @ (Max a_a6Ldu)
                    @ a_a6Ldu
                    g1_s6MJs
                    ((GHC.Base.Just @ a_a6Ldu)
                     `cast` (<a_a6Ldu>_R
                             ->_R Sym (Data.Functor.Utils.N:Max[0]) <a_a6Ldu>_N
                             :: (a_a6Ldu -> Maybe a_a6Ldu :: *)
                                ~R# (a_a6Ldu -> Max a_a6Ldu :: *)))
                    a1_a6Kq8)
                 `cast` (Data.Functor.Utils.N:Max[0] <a_a6Ldu>_N
                         :: (Max a_a6Ldu :: *) ~R# (Maybe a_a6Ldu :: *))
            of {
              Nothing -> Data.Foldable.$fFoldable:*:3 @ a_a6Ldu;
              Just v_i6M0Z -> v_i6M0Z
            }
        }

-- RHS size: {terms: 51, types: 65, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:+:_$cfoldr1
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. (a -> a -> a) -> (:+:) f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 180] 320 0}]
Data.Foldable.$fFoldable:+:_$cfoldr1
  = \ (@ (f_X6LpA :: * -> *))
      (@ (g_X6LpC :: * -> *))
      ($dFoldable_X6LpE :: Foldable f_X6LpA)
      ($dFoldable1_X6LpG :: Foldable g_X6LpC)
      (@ a_a6LcC)
      (f1_a6K7J :: a_a6LcC -> a_a6LcC -> a_a6LcC)
      (xs_a6K7K :: (:+:) f_X6LpA g_X6LpC a_a6LcC) ->
      case xs_a6K7K of {
        L1 a1_a6KpX ->
          case foldr
                 @ f_X6LpA
                 $dFoldable_X6LpE
                 @ a_a6LcC
                 @ (Maybe a_a6LcC)
                 (\ (x_a6K7M :: a_a6LcC) (m_a6K7N :: Maybe a_a6LcC) ->
                    GHC.Base.Just
                      @ a_a6LcC
                      (case m_a6K7N of {
                         Nothing -> x_a6K7M;
                         Just y_a6K7O -> f1_a6K7J x_a6K7M y_a6K7O
                       }))
                 (GHC.Base.Nothing @ a_a6LcC)
                 a1_a6KpX
          of {
            Nothing -> Data.Foldable.$fFoldable:*:8 @ a_a6LcC;
            Just v_i6M0Z -> v_i6M0Z
          };
        R1 a1_a6Kq2 ->
          case foldr
                 @ g_X6LpC
                 $dFoldable1_X6LpG
                 @ a_a6LcC
                 @ (Maybe a_a6LcC)
                 (\ (x_a6K7M :: a_a6LcC) (m_a6K7N :: Maybe a_a6LcC) ->
                    GHC.Base.Just
                      @ a_a6LcC
                      (case m_a6K7N of {
                         Nothing -> x_a6K7M;
                         Just y_a6K7O -> f1_a6K7J x_a6K7M y_a6K7O
                       }))
                 (GHC.Base.Nothing @ a_a6LcC)
                 a1_a6Kq2
          of {
            Nothing -> Data.Foldable.$fFoldable:*:8 @ a_a6LcC;
            Just v_i6M0Z -> v_i6M0Z
          }
      }

-- RHS size: {terms: 43, types: 56, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:+:_$cfoldl'
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (:+:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 0 180] 320 0}]
Data.Foldable.$fFoldable:+:_$cfoldl'
  = \ (@ (f_X6Lpz :: * -> *))
      (@ (g_X6LpB :: * -> *))
      ($dFoldable_X6LpD :: Foldable f_X6Lpz)
      ($dFoldable1_X6LpF :: Foldable g_X6LpB)
      (@ b_a6Lcs)
      (@ a_a6Lct)
      (f1_a6K7C :: b_a6Lcs -> a_a6Lct -> b_a6Lcs)
      (z0_a6K7D :: b_a6Lcs)
      (xs_a6K7E :: (:+:) f_X6Lpz g_X6LpB a_a6Lct) ->
      case xs_a6K7E of {
        L1 a1_a6KpX ->
          foldr
            @ f_X6Lpz
            $dFoldable_X6LpD
            @ a_a6Lct
            @ (b_a6Lcs -> b_a6Lcs)
            (\ (x_a6K7G :: a_a6Lct)
               (k_a6K7H :: b_a6Lcs -> b_a6Lcs)
               (z_a6K7I :: b_a6Lcs) ->
               case f1_a6K7C z_a6K7I x_a6K7G of vx_i6M0K { __DEFAULT ->
               k_a6K7H vx_i6M0K
               })
            (id @ b_a6Lcs)
            a1_a6KpX
            z0_a6K7D;
        R1 a1_a6Kq2 ->
          foldr
            @ g_X6LpB
            $dFoldable1_X6LpF
            @ a_a6Lct
            @ (b_a6Lcs -> b_a6Lcs)
            (\ (x_a6K7G :: a_a6Lct)
               (k_a6K7H :: b_a6Lcs -> b_a6Lcs)
               (z_a6K7I :: b_a6Lcs) ->
               case f1_a6K7C z_a6K7I x_a6K7G of vx_i6M0K { __DEFAULT ->
               k_a6K7H vx_i6M0K
               })
            (id @ b_a6Lcs)
            a1_a6Kq2
            z0_a6K7D
      }

-- RHS size: {terms: 12, types: 25, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:+:_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. (:+:) f g a -> Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_X6LpC :: * -> *))
                 (@ (g_X6LpE :: * -> *))
                 ($dFoldable_X6LpG [Occ=Once] :: Foldable f_X6LpC)
                 ($dFoldable1_X6LpI [Occ=Once] :: Foldable g_X6LpE)
                 (@ a_a6Ldc)
                 (eta_B1 [Occ=Once] :: (:+:) f_X6LpC g_X6LpE a_a6Ldc) ->
                 Data.Foldable.$fFoldable:+:_$cfoldl'
                   @ f_X6LpC
                   @ g_X6LpE
                   $dFoldable_X6LpG
                   $dFoldable1_X6LpI
                   @ Int
                   @ a_a6Ldc
                   (Data.Foldable.$fFoldable:*:5 @ a_a6Ldc)
                   Data.Foldable.$fFoldable:*:4
                   eta_B1}]
Data.Foldable.$fFoldable:+:_$clength
  = \ (@ (f_X6LpC :: * -> *))
      (@ (g_X6LpE :: * -> *))
      ($dFoldable_X6LpG :: Foldable f_X6LpC)
      ($dFoldable1_X6LpI :: Foldable g_X6LpE)
      (@ a_a6Ldc)
      (eta_B1 :: (:+:) f_X6LpC g_X6LpE a_a6Ldc) ->
      Data.Foldable.$fFoldable:+:_$cfoldl'
        @ f_X6LpC
        @ g_X6LpE
        $dFoldable_X6LpG
        $dFoldable1_X6LpI
        @ Int
        @ a_a6Ldc
        (Data.Foldable.$fFoldable:*:5 @ a_a6Ldc)
        Data.Foldable.$fFoldable:*:4
        eta_B1

-- RHS size: {terms: 31, types: 53, coercions: 18, joins: 0/1}
Data.Foldable.$fFoldable:+:_$cfoldl
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (:+:) f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 0 90] 200 0}]
Data.Foldable.$fFoldable:+:_$cfoldl
  = \ (@ (f_X6Lpy :: * -> *))
      (@ (g_X6LpA :: * -> *))
      ($dFoldable_X6LpC :: Foldable f_X6Lpy)
      ($dFoldable1_X6LpE :: Foldable g_X6LpA)
      (@ b_a6Lci)
      (@ a_a6Lcj)
      (f1_a6K7z :: b_a6Lci -> a_a6Lcj -> b_a6Lci)
      (z_a6K7A :: b_a6Lci)
      (t_a6K7B :: (:+:) f_X6Lpy g_X6LpA a_a6Lcj) ->
      let {
        f2_s6MJp :: a_a6Lcj -> b_a6Lci -> b_a6Lci
        [LclId,
         Arity=2,
         Str=<L,U><L,U>,
         Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True,
                 Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
                 Tmpl= \ (x_X6HLX [Occ=Once] :: a_a6Lcj)
                         (y_i6M0a [Occ=Once] :: b_a6Lci) ->
                         f1_a6K7z y_i6M0a x_X6HLX}]
        f2_s6MJp
          = \ (x_X6HLX :: a_a6Lcj) (y_i6M0a :: b_a6Lci) ->
              f1_a6K7z y_i6M0a x_X6HLX } in
      case t_a6K7B of {
        L1 a1_a6Kq6 ->
          ((foldMap
              @ f_X6Lpy
              $dFoldable_X6LpC
              @ (Dual (Endo b_a6Lci))
              @ a_a6Lcj
              (Data.Foldable.$fFoldable:*:7 @ b_a6Lci)
              (f2_s6MJp
               `cast` (<a_a6Lcj>_R
                       ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                     (Data.Semigroup.Internal.N:Endo[0] <b_a6Lci>_R))
                       :: (a_a6Lcj -> b_a6Lci -> b_a6Lci :: *)
                          ~R# (a_a6Lcj -> Dual (Endo b_a6Lci) :: *)))
              a1_a6Kq6)
           `cast` (Data.Semigroup.Internal.N:Dual[0]
                       (Data.Semigroup.Internal.N:Endo[0] <b_a6Lci>_R)
                   :: (Dual (Endo b_a6Lci) :: *) ~R# (b_a6Lci -> b_a6Lci :: *)))
            z_a6K7A;
        R1 a1_a6Kq8 ->
          ((foldMap
              @ g_X6LpA
              $dFoldable1_X6LpE
              @ (Dual (Endo b_a6Lci))
              @ a_a6Lcj
              (Data.Foldable.$fFoldable:*:7 @ b_a6Lci)
              (f2_s6MJp
               `cast` (<a_a6Lcj>_R
                       ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                     (Data.Semigroup.Internal.N:Endo[0] <b_a6Lci>_R))
                       :: (a_a6Lcj -> b_a6Lci -> b_a6Lci :: *)
                          ~R# (a_a6Lcj -> Dual (Endo b_a6Lci) :: *)))
              a1_a6Kq8)
           `cast` (Data.Semigroup.Internal.N:Dual[0]
                       (Data.Semigroup.Internal.N:Endo[0] <b_a6Lci>_R)
                   :: (Dual (Endo b_a6Lci) :: *) ~R# (b_a6Lci -> b_a6Lci :: *)))
            z_a6K7A
      }

-- RHS size: {terms: 53, types: 73, coercions: 22, joins: 0/0}
Data.Foldable.$fFoldable:+:_$cfoldl1
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. (a -> a -> a) -> (:+:) f g a -> a
[GblId,
 Arity=4,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 190] 340 0}]
Data.Foldable.$fFoldable:+:_$cfoldl1
  = \ (@ (f_X6LpB :: * -> *))
      (@ (g_X6LpD :: * -> *))
      ($dFoldable_X6LpF :: Foldable f_X6LpB)
      ($dFoldable1_X6LpH :: Foldable g_X6LpD)
      (@ a_a6LcK)
      (f1_a6K7P :: a_a6LcK -> a_a6LcK -> a_a6LcK)
      (xs_a6K7Q :: (:+:) f_X6LpB g_X6LpD a_a6LcK) ->
      case xs_a6K7Q of {
        L1 a1_a6Kq6 ->
          case ((foldMap
                   @ f_X6LpB
                   $dFoldable_X6LpF
                   @ (Dual (Endo (Maybe a_a6LcK)))
                   @ a_a6LcK
                   (Data.Foldable.$fFoldable:*:7 @ (Maybe a_a6LcK))
                   ((\ (x_X6HLX :: a_a6LcK) (y_i6M0a :: Maybe a_a6LcK) ->
                       GHC.Base.Just
                         @ a_a6LcK
                         (case y_i6M0a of {
                            Nothing -> x_X6HLX;
                            Just x1_a6K7U -> f1_a6K7P x1_a6K7U x_X6HLX
                          }))
                    `cast` (<a_a6LcK>_R
                            ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                          (Data.Semigroup.Internal.N:Endo[0] <Maybe a_a6LcK>_R))
                            :: (a_a6LcK -> Maybe a_a6LcK -> Maybe a_a6LcK :: *)
                               ~R# (a_a6LcK -> Dual (Endo (Maybe a_a6LcK)) :: *)))
                   a1_a6Kq6)
                `cast` (Data.Semigroup.Internal.N:Dual[0]
                            (Data.Semigroup.Internal.N:Endo[0] <Maybe a_a6LcK>_R)
                        :: (Dual (Endo (Maybe a_a6LcK)) :: *)
                           ~R# (Maybe a_a6LcK -> Maybe a_a6LcK :: *)))
                 (GHC.Base.Nothing @ a_a6LcK)
          of {
            Nothing -> Data.Foldable.$fFoldable:*:6 @ a_a6LcK;
            Just v_i6M0Z -> v_i6M0Z
          };
        R1 a1_a6Kq8 ->
          case ((foldMap
                   @ g_X6LpD
                   $dFoldable1_X6LpH
                   @ (Dual (Endo (Maybe a_a6LcK)))
                   @ a_a6LcK
                   (Data.Foldable.$fFoldable:*:7 @ (Maybe a_a6LcK))
                   ((\ (x_X6HLX :: a_a6LcK) (y_i6M0a :: Maybe a_a6LcK) ->
                       GHC.Base.Just
                         @ a_a6LcK
                         (case y_i6M0a of {
                            Nothing -> x_X6HLX;
                            Just x1_a6K7U -> f1_a6K7P x1_a6K7U x_X6HLX
                          }))
                    `cast` (<a_a6LcK>_R
                            ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                          (Data.Semigroup.Internal.N:Endo[0] <Maybe a_a6LcK>_R))
                            :: (a_a6LcK -> Maybe a_a6LcK -> Maybe a_a6LcK :: *)
                               ~R# (a_a6LcK -> Dual (Endo (Maybe a_a6LcK)) :: *)))
                   a1_a6Kq8)
                `cast` (Data.Semigroup.Internal.N:Dual[0]
                            (Data.Semigroup.Internal.N:Endo[0] <Maybe a_a6LcK>_R)
                        :: (Dual (Endo (Maybe a_a6LcK)) :: *)
                           ~R# (Maybe a_a6LcK -> Maybe a_a6LcK :: *)))
                 (GHC.Base.Nothing @ a_a6LcK)
          of {
            Nothing -> Data.Foldable.$fFoldable:*:6 @ a_a6LcK;
            Just v_i6M0Z -> v_i6M0Z
          }
      }

-- RHS size: {terms: 45, types: 64, coercions: 22, joins: 0/0}
Data.Foldable.$fFoldable:+:_$cfoldr'
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (:+:) f g a -> b
[GblId,
 Arity=5,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 0 190] 340 0}]
Data.Foldable.$fFoldable:+:_$cfoldr'
  = \ (@ (f_X6Lpx :: * -> *))
      (@ (g_X6Lpz :: * -> *))
      ($dFoldable_X6LpB :: Foldable f_X6Lpx)
      ($dFoldable1_X6LpD :: Foldable g_X6Lpz)
      (@ a_a6Lc8)
      (@ b_a6Lc9)
      (f1_a6K7s :: a_a6Lc8 -> b_a6Lc9 -> b_a6Lc9)
      (z0_a6K7t :: b_a6Lc9)
      (xs_a6K7u :: (:+:) f_X6Lpx g_X6Lpz a_a6Lc8) ->
      case xs_a6K7u of {
        L1 a1_a6Kq6 ->
          ((foldMap
              @ f_X6Lpx
              $dFoldable_X6LpB
              @ (Dual (Endo (b_a6Lc9 -> b_a6Lc9)))
              @ a_a6Lc8
              (Data.Foldable.$fFoldable:*:7 @ (b_a6Lc9 -> b_a6Lc9))
              ((\ (x_X6HLX :: a_a6Lc8)
                  (y_i6M0a :: b_a6Lc9 -> b_a6Lc9)
                  (z_a6K7y :: b_a6Lc9) ->
                  case f1_a6K7s x_X6HLX z_a6K7y of vx_i6M0K { __DEFAULT ->
                  y_i6M0a vx_i6M0K
                  })
               `cast` (<a_a6Lc8>_R
                       ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                     (Data.Semigroup.Internal.N:Endo[0] <b_a6Lc9 -> b_a6Lc9>_R))
                       :: (a_a6Lc8 -> (b_a6Lc9 -> b_a6Lc9) -> b_a6Lc9 -> b_a6Lc9 :: *)
                          ~R# (a_a6Lc8 -> Dual (Endo (b_a6Lc9 -> b_a6Lc9)) :: *)))
              a1_a6Kq6)
           `cast` (Data.Semigroup.Internal.N:Dual[0]
                       (Data.Semigroup.Internal.N:Endo[0] <b_a6Lc9 -> b_a6Lc9>_R)
                   :: (Dual (Endo (b_a6Lc9 -> b_a6Lc9)) :: *)
                      ~R# ((b_a6Lc9 -> b_a6Lc9) -> b_a6Lc9 -> b_a6Lc9 :: *)))
            (id @ b_a6Lc9) z0_a6K7t;
        R1 a1_a6Kq8 ->
          ((foldMap
              @ g_X6Lpz
              $dFoldable1_X6LpD
              @ (Dual (Endo (b_a6Lc9 -> b_a6Lc9)))
              @ a_a6Lc8
              (Data.Foldable.$fFoldable:*:7 @ (b_a6Lc9 -> b_a6Lc9))
              ((\ (x_X6HLX :: a_a6Lc8)
                  (y_i6M0a :: b_a6Lc9 -> b_a6Lc9)
                  (z_a6K7y :: b_a6Lc9) ->
                  case f1_a6K7s x_X6HLX z_a6K7y of vx_i6M0K { __DEFAULT ->
                  y_i6M0a vx_i6M0K
                  })
               `cast` (<a_a6Lc8>_R
                       ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                     (Data.Semigroup.Internal.N:Endo[0] <b_a6Lc9 -> b_a6Lc9>_R))
                       :: (a_a6Lc8 -> (b_a6Lc9 -> b_a6Lc9) -> b_a6Lc9 -> b_a6Lc9 :: *)
                          ~R# (a_a6Lc8 -> Dual (Endo (b_a6Lc9 -> b_a6Lc9)) :: *)))
              a1_a6Kq8)
           `cast` (Data.Semigroup.Internal.N:Dual[0]
                       (Data.Semigroup.Internal.N:Endo[0] <b_a6Lc9 -> b_a6Lc9>_R)
                   :: (Dual (Endo (b_a6Lc9 -> b_a6Lc9)) :: *)
                      ~R# ((b_a6Lc9 -> b_a6Lc9) -> b_a6Lc9 -> b_a6Lc9 :: *)))
            (id @ b_a6Lc9) z0_a6K7t
      }

-- RHS size: {terms: 21, types: 40, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:+:_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall m. Monoid m => (:+:) f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_X6Lpw :: * -> *))
                 (@ (g_X6Lpy :: * -> *))
                 ($dFoldable_X6LpA [Occ=Once] :: Foldable f_X6Lpw)
                 ($dFoldable1_X6LpC [Occ=Once] :: Foldable g_X6Lpy)
                 (@ m_a6Lb7)
                 ($dMonoid_a6Lb9 [Occ=Once*] :: Monoid m_a6Lb7)
                 (ds_d6M2I [Occ=Once!] :: (:+:) f_X6Lpw g_X6Lpy m_a6Lb7) ->
                 case ds_d6M2I of {
                   L1 a1_a6Kq6 [Occ=Once] ->
                     foldMap
                       @ f_X6Lpw
                       $dFoldable_X6LpA
                       @ m_a6Lb7
                       @ m_a6Lb7
                       $dMonoid_a6Lb9
                       (id @ m_a6Lb7)
                       a1_a6Kq6;
                   R1 a1_a6Kq8 [Occ=Once] ->
                     foldMap
                       @ g_X6Lpy
                       $dFoldable1_X6LpC
                       @ m_a6Lb7
                       @ m_a6Lb7
                       $dMonoid_a6Lb9
                       (id @ m_a6Lb7)
                       a1_a6Kq8
                 }}]
Data.Foldable.$fFoldable:+:_$cfold
  = \ (@ (f_X6Lpw :: * -> *))
      (@ (g_X6Lpy :: * -> *))
      ($dFoldable_X6LpA :: Foldable f_X6Lpw)
      ($dFoldable1_X6LpC :: Foldable g_X6Lpy)
      (@ m_a6Lb7)
      ($dMonoid_a6Lb9 :: Monoid m_a6Lb7)
      (ds_d6M2I :: (:+:) f_X6Lpw g_X6Lpy m_a6Lb7) ->
      case ds_d6M2I of {
        L1 a1_a6Kq6 ->
          foldMap
            @ f_X6Lpw
            $dFoldable_X6LpA
            @ m_a6Lb7
            @ m_a6Lb7
            $dMonoid_a6Lb9
            (id @ m_a6Lb7)
            a1_a6Kq6;
        R1 a1_a6Kq8 ->
          foldMap
            @ g_X6Lpy
            $dFoldable1_X6LpC
            @ m_a6Lb7
            @ m_a6Lb7
            $dMonoid_a6Lb9
            (id @ m_a6Lb7)
            a1_a6Kq8
      }

-- RHS size: {terms: 24, types: 46, coercions: 10, joins: 0/1}
Data.Foldable.$fFoldable:+:1
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Num a => (:+:) f g a -> Product a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6Lb0 :: * -> *))
                 (@ (g_a6Lb1 :: * -> *))
                 ($dFoldable_a6Lb2 [Occ=OnceL] :: Foldable f_a6Lb0)
                 ($dFoldable1_a6Lb3 [Occ=OnceL] :: Foldable g_a6Lb1)
                 (@ a_a6LdY)
                 ($dNum_a6Le0 [Occ=OnceL] :: Num a_a6LdY) ->
                 let {
                   $dMonoid_a6Lbk [Occ=OnceL*] :: Monoid (Product a_a6LdY)
                   [LclId]
                   $dMonoid_a6Lbk
                     = Data.Semigroup.Internal.$fMonoidProduct
                         @ a_a6LdY $dNum_a6Le0 } in
                 \ (ds_d6M2I [Occ=Once!] :: (:+:) f_a6Lb0 g_a6Lb1 a_a6LdY) ->
                   case ds_d6M2I of {
                     L1 a1_a6Kq6 [Occ=Once] ->
                       foldMap
                         @ f_a6Lb0
                         $dFoldable_a6Lb2
                         @ (Product a_a6LdY)
                         @ a_a6LdY
                         $dMonoid_a6Lbk
                         ((Data.Foldable.$fFoldable:*:1 @ a_a6LdY)
                          `cast` (<a_a6LdY>_R
                                  ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LdY>_R)
                                  :: (a_a6LdY -> a_a6LdY :: *)
                                     ~R# (a_a6LdY -> Product a_a6LdY :: *)))
                         a1_a6Kq6;
                     R1 a1_a6Kq8 [Occ=Once] ->
                       foldMap
                         @ g_a6Lb1
                         $dFoldable1_a6Lb3
                         @ (Product a_a6LdY)
                         @ a_a6LdY
                         $dMonoid_a6Lbk
                         ((Data.Foldable.$fFoldable:*:1 @ a_a6LdY)
                          `cast` (<a_a6LdY>_R
                                  ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LdY>_R)
                                  :: (a_a6LdY -> a_a6LdY :: *)
                                     ~R# (a_a6LdY -> Product a_a6LdY :: *)))
                         a1_a6Kq8
                   }}]
Data.Foldable.$fFoldable:+:1
  = \ (@ (f_a6Lb0 :: * -> *))
      (@ (g_a6Lb1 :: * -> *))
      ($dFoldable_a6Lb2 :: Foldable f_a6Lb0)
      ($dFoldable1_a6Lb3 :: Foldable g_a6Lb1)
      (@ a_a6LdY)
      ($dNum_a6Le0 :: Num a_a6LdY) ->
      let {
        $dMonoid_a6Lbk :: Monoid (Product a_a6LdY)
        [LclId]
        $dMonoid_a6Lbk
          = Data.Semigroup.Internal.$fMonoidProduct
              @ a_a6LdY $dNum_a6Le0 } in
      \ (ds_d6M2I :: (:+:) f_a6Lb0 g_a6Lb1 a_a6LdY) ->
        case ds_d6M2I of {
          L1 a1_a6Kq6 ->
            foldMap
              @ f_a6Lb0
              $dFoldable_a6Lb2
              @ (Product a_a6LdY)
              @ a_a6LdY
              $dMonoid_a6Lbk
              ((Data.Foldable.$fFoldable:*:1 @ a_a6LdY)
               `cast` (<a_a6LdY>_R
                       ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LdY>_R)
                       :: (a_a6LdY -> a_a6LdY :: *)
                          ~R# (a_a6LdY -> Product a_a6LdY :: *)))
              a1_a6Kq6;
          R1 a1_a6Kq8 ->
            foldMap
              @ g_a6Lb1
              $dFoldable1_a6Lb3
              @ (Product a_a6LdY)
              @ a_a6LdY
              $dMonoid_a6Lbk
              ((Data.Foldable.$fFoldable:*:1 @ a_a6LdY)
               `cast` (<a_a6LdY>_R
                       ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LdY>_R)
                       :: (a_a6LdY -> a_a6LdY :: *)
                          ~R# (a_a6LdY -> Product a_a6LdY :: *)))
              a1_a6Kq8
        }

-- RHS size: {terms: 20, types: 42, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:+:_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. (:+:) f g a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_a6Lb0 :: * -> *))
                 (@ (g_a6Lb1 :: * -> *))
                 ($dFoldable_a6Lb2 [Occ=Once] :: Foldable f_a6Lb0)
                 ($dFoldable1_a6Lb3 [Occ=Once] :: Foldable g_a6Lb1)
                 (@ a_a6LcS)
                 (t_a6K7V [Occ=Once] :: (:+:) f_a6Lb0 g_a6Lb1 a_a6LcS) ->
                 build
                   @ a_a6LcS
                   (\ (@ b_a6KNB)
                      (c_a6K7W [Occ=Once, OS=OneShot] :: a_a6LcS -> b_a6KNB -> b_a6KNB)
                      (n_a6K7X [Occ=Once, OS=OneShot] :: b_a6KNB) ->
                      Data.Foldable.$fFoldable:+:_$cfoldr
                        @ f_a6Lb0
                        @ g_a6Lb1
                        $dFoldable_a6Lb2
                        $dFoldable1_a6Lb3
                        @ a_a6LcS
                        @ b_a6KNB
                        c_a6K7W
                        n_a6K7X
                        t_a6K7V)}]
Data.Foldable.$fFoldable:+:_$ctoList
  = \ (@ (f_a6Lb0 :: * -> *))
      (@ (g_a6Lb1 :: * -> *))
      ($dFoldable_a6Lb2 :: Foldable f_a6Lb0)
      ($dFoldable1_a6Lb3 :: Foldable g_a6Lb1)
      (@ a_a6LcS)
      (eta_Xeq :: (:+:) f_a6Lb0 g_a6Lb1 a_a6LcS) ->
      case eta_Xeq of {
        L1 a1_a6KpX ->
          foldr
            @ f_a6Lb0
            $dFoldable_a6Lb2
            @ a_a6LcS
            @ [a_a6LcS]
            (GHC.Types.: @ a_a6LcS)
            (GHC.Types.[] @ a_a6LcS)
            a1_a6KpX;
        R1 a1_a6Kq2 ->
          foldr
            @ g_a6Lb1
            $dFoldable1_a6Lb3
            @ a_a6LcS
            @ [a_a6LcS]
            (GHC.Types.: @ a_a6LcS)
            (GHC.Types.[] @ a_a6LcS)
            a1_a6Kq2
      }

-- RHS size: {terms: 53, types: 49, coercions: 30, joins: 0/0}
Data.Foldable.$fFoldable:+: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     Foldable (f :+: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)><L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>,
 Unf=DFun: \ (@ (f_a6Kay :: * -> *))
             (@ (g_a6Kaz :: * -> *))
             (v_Xeo :: Foldable f_a6Kay)
             (v1_Xer :: Foldable g_a6Kaz) ->
       Data.Foldable.C:Foldable TYPE: f_a6Kay :+: g_a6Kaz
                                Data.Foldable.$fFoldable:+:_$cfold @ f_a6Kay @ g_a6Kaz v_Xeo v1_Xer
                                Data.Foldable.$fFoldable:+:_$cfoldMap
                                  @ f_a6Kay @ g_a6Kaz v_Xeo v1_Xer
                                Data.Foldable.$fFoldable:+:_$cfoldr
                                  @ f_a6Kay @ g_a6Kaz v_Xeo v1_Xer
                                Data.Foldable.$fFoldable:+:_$cfoldr'
                                  @ f_a6Kay @ g_a6Kaz v_Xeo v1_Xer
                                Data.Foldable.$fFoldable:+:_$cfoldl
                                  @ f_a6Kay @ g_a6Kaz v_Xeo v1_Xer
                                Data.Foldable.$fFoldable:+:_$cfoldl'
                                  @ f_a6Kay @ g_a6Kaz v_Xeo v1_Xer
                                Data.Foldable.$fFoldable:+:_$cfoldr1
                                  @ f_a6Kay @ g_a6Kaz v_Xeo v1_Xer
                                Data.Foldable.$fFoldable:+:_$cfoldl1
                                  @ f_a6Kay @ g_a6Kaz v_Xeo v1_Xer
                                Data.Foldable.$fFoldable:+:_$ctoList
                                  @ f_a6Kay @ g_a6Kaz v_Xeo v1_Xer
                                Data.Foldable.$fFoldable:+:_$cnull @ f_a6Kay @ g_a6Kaz v_Xeo v1_Xer
                                Data.Foldable.$fFoldable:+:_$clength
                                  @ f_a6Kay @ g_a6Kaz v_Xeo v1_Xer
                                Data.Foldable.$fFoldable:+:_$celem @ f_a6Kay @ g_a6Kaz v_Xeo v1_Xer
                                Data.Foldable.$fFoldable:+:_$cmaximum
                                  @ f_a6Kay @ g_a6Kaz v_Xeo v1_Xer
                                Data.Foldable.$fFoldable:+:_$cminimum
                                  @ f_a6Kay @ g_a6Kaz v_Xeo v1_Xer
                                (Data.Foldable.$fFoldable:+:2 @ f_a6Kay @ g_a6Kaz v_Xeo v1_Xer)
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <(:+:) f_a6Kay g_a6Kaz a>_R
                                        ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
                                        :: (forall a.
                                            Num a =>
                                            (:+:) f_a6Kay g_a6Kaz a -> Sum a :: *)
                                           ~R# (forall a.
                                                Num a =>
                                                (:+:) f_a6Kay g_a6Kaz a -> a :: *))
                                (Data.Foldable.$fFoldable:+:1 @ f_a6Kay @ g_a6Kaz v_Xeo v1_Xer)
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <(:+:) f_a6Kay g_a6Kaz a>_R
                                        ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
                                        :: (forall a.
                                            Num a =>
                                            (:+:) f_a6Kay g_a6Kaz a -> Product a :: *)
                                           ~R# (forall a.
                                                Num a =>
                                                (:+:) f_a6Kay g_a6Kaz a -> a :: *))]
Data.Foldable.$fFoldable:+:
  = \ (@ (f_a6Lb0 :: * -> *))
      (@ (g_a6Lb1 :: * -> *))
      ($dFoldable_a6Lb2 :: Foldable f_a6Lb0)
      ($dFoldable1_a6Lb3 :: Foldable g_a6Lb1) ->
      Data.Foldable.C:Foldable
        @ (f_a6Lb0 :+: g_a6Lb1)
        (Data.Foldable.$fFoldable:+:_$cfold
           @ f_a6Lb0 @ g_a6Lb1 $dFoldable_a6Lb2 $dFoldable1_a6Lb3)
        (Data.Foldable.$fFoldable:+:_$cfoldMap
           @ f_a6Lb0 @ g_a6Lb1 $dFoldable_a6Lb2 $dFoldable1_a6Lb3)
        (Data.Foldable.$fFoldable:+:_$cfoldr
           @ f_a6Lb0 @ g_a6Lb1 $dFoldable_a6Lb2 $dFoldable1_a6Lb3)
        (Data.Foldable.$fFoldable:+:_$cfoldr'
           @ f_a6Lb0 @ g_a6Lb1 $dFoldable_a6Lb2 $dFoldable1_a6Lb3)
        (Data.Foldable.$fFoldable:+:_$cfoldl
           @ f_a6Lb0 @ g_a6Lb1 $dFoldable_a6Lb2 $dFoldable1_a6Lb3)
        (Data.Foldable.$fFoldable:+:_$cfoldl'
           @ f_a6Lb0 @ g_a6Lb1 $dFoldable_a6Lb2 $dFoldable1_a6Lb3)
        (Data.Foldable.$fFoldable:+:_$cfoldr1
           @ f_a6Lb0 @ g_a6Lb1 $dFoldable_a6Lb2 $dFoldable1_a6Lb3)
        (Data.Foldable.$fFoldable:+:_$cfoldl1
           @ f_a6Lb0 @ g_a6Lb1 $dFoldable_a6Lb2 $dFoldable1_a6Lb3)
        (Data.Foldable.$fFoldable:+:_$ctoList
           @ f_a6Lb0 @ g_a6Lb1 $dFoldable_a6Lb2 $dFoldable1_a6Lb3)
        (Data.Foldable.$fFoldable:+:_$cnull
           @ f_a6Lb0 @ g_a6Lb1 $dFoldable_a6Lb2 $dFoldable1_a6Lb3)
        (Data.Foldable.$fFoldable:+:_$clength
           @ f_a6Lb0 @ g_a6Lb1 $dFoldable_a6Lb2 $dFoldable1_a6Lb3)
        (Data.Foldable.$fFoldable:+:_$celem
           @ f_a6Lb0 @ g_a6Lb1 $dFoldable_a6Lb2 $dFoldable1_a6Lb3)
        (Data.Foldable.$fFoldable:+:_$cmaximum
           @ f_a6Lb0 @ g_a6Lb1 $dFoldable_a6Lb2 $dFoldable1_a6Lb3)
        (Data.Foldable.$fFoldable:+:_$cminimum
           @ f_a6Lb0 @ g_a6Lb1 $dFoldable_a6Lb2 $dFoldable1_a6Lb3)
        ((Data.Foldable.$fFoldable:+:2
            @ f_a6Lb0 @ g_a6Lb1 $dFoldable_a6Lb2 $dFoldable1_a6Lb3)
         `cast` (forall (a :: <*>_N).
                 <Num a>_R
                 ->_R <(:+:) f_a6Lb0 g_a6Lb1 a>_R
                 ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
                 :: (forall a. Num a => (:+:) f_a6Lb0 g_a6Lb1 a -> Sum a :: *)
                    ~R# (forall a. Num a => (:+:) f_a6Lb0 g_a6Lb1 a -> a :: *)))
        ((Data.Foldable.$fFoldable:+:1
            @ f_a6Lb0 @ g_a6Lb1 $dFoldable_a6Lb2 $dFoldable1_a6Lb3)
         `cast` (forall (a :: <*>_N).
                 <Num a>_R
                 ->_R <(:+:) f_a6Lb0 g_a6Lb1 a>_R
                 ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
                 :: (forall a. Num a => (:+:) f_a6Lb0 g_a6Lb1 a -> Product a :: *)
                    ~R# (forall a. Num a => (:+:) f_a6Lb0 g_a6Lb1 a -> a :: *)))

-- RHS size: {terms: 17, types: 26, coercions: 20, joins: 0/1}
Data.Foldable.$fFoldableM1_$celem
  :: forall (f :: * -> *) i (c :: Meta).
     Foldable f =>
     forall a. Eq a => a -> M1 i c f a -> Bool
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6Le7 :: * -> *))
                 (@ i_a6Le8)
                 (@ (c_a6Le9 :: Meta))
                 ($dFoldable_a6Lea [Occ=OnceL] :: Foldable f_a6Le7)
                 (@ a_a6Lg5)
                 ($dEq_a6Lg7 [Occ=Once] :: Eq a_a6Lg5)
                 (eta_B1 [Occ=Once] :: a_a6Lg5) ->
                 let {
                   f1_s6MJl [Occ=OnceL] :: a_a6Lg5 -> Bool
                   [LclId]
                   f1_s6MJl = == @ a_a6Lg5 $dEq_a6Lg7 eta_B1 } in
                 (\ (ds_d6M2L [Occ=Once] :: M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lg5) ->
                    foldMap
                      @ f_a6Le7
                      $dFoldable_a6Lea
                      @ Data.Monoid.Any
                      @ a_a6Lg5
                      Data.Semigroup.Internal.$fMonoidAny
                      (f1_s6MJl
                       `cast` (<a_a6Lg5>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                               :: (a_a6Lg5 -> Bool :: *) ~R# (a_a6Lg5 -> Data.Monoid.Any :: *)))
                      (ds_d6M2L
                       `cast` (GHC.Generics.N:M1[0]
                                   <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <a_a6Lg5>_N
                               :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lg5 :: *)
                                  ~R# (f_a6Le7 a_a6Lg5 :: *))))
                 `cast` (<M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lg5>_R
                         ->_R Data.Semigroup.Internal.N:Any[0]
                         :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lg5 -> Data.Monoid.Any :: *)
                            ~R# (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lg5 -> Bool :: *))}]
Data.Foldable.$fFoldableM1_$celem
  = \ (@ (f_a6Le7 :: * -> *))
      (@ i_a6Le8)
      (@ (c_a6Le9 :: Meta))
      ($dFoldable_a6Lea :: Foldable f_a6Le7)
      (@ a_a6Lg5)
      ($dEq_a6Lg7 :: Eq a_a6Lg5)
      (eta_B1 :: a_a6Lg5) ->
      let {
        f1_s6MJl :: a_a6Lg5 -> Bool
        [LclId]
        f1_s6MJl = == @ a_a6Lg5 $dEq_a6Lg7 eta_B1 } in
      (\ (ds_d6M2L :: M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lg5) ->
         foldMap
           @ f_a6Le7
           $dFoldable_a6Lea
           @ Data.Monoid.Any
           @ a_a6Lg5
           Data.Semigroup.Internal.$fMonoidAny
           (f1_s6MJl
            `cast` (<a_a6Lg5>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                    :: (a_a6Lg5 -> Bool :: *) ~R# (a_a6Lg5 -> Data.Monoid.Any :: *)))
           (ds_d6M2L
            `cast` (GHC.Generics.N:M1[0]
                        <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <a_a6Lg5>_N
                    :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lg5 :: *)
                       ~R# (f_a6Le7 a_a6Lg5 :: *))))
      `cast` (<M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lg5>_R
              ->_R Data.Semigroup.Internal.N:Any[0]
              :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lg5 -> Data.Monoid.Any :: *)
                 ~R# (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lg5 -> Bool :: *))

-- RHS size: {terms: 15, types: 28, coercions: 22, joins: 0/1}
Data.Foldable.$fFoldableM1_$csum
  :: forall (f :: * -> *) i (c :: Meta).
     Foldable f =>
     forall a. Num a => M1 i c f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6Le7 :: * -> *))
                 (@ i_a6Le8)
                 (@ (c_a6Le9 :: Meta))
                 ($dFoldable_a6Lea [Occ=OnceL] :: Foldable f_a6Le7)
                 (@ a_a6Lgz)
                 ($dNum_a6LgB [Occ=OnceL] :: Num a_a6Lgz) ->
                 let {
                   $dMonoid_s6MJj [Occ=OnceL] :: Monoid (Sum a_a6Lgz)
                   [LclId]
                   $dMonoid_s6MJj
                     = Data.Semigroup.Internal.$fMonoidSum @ a_a6Lgz $dNum_a6LgB } in
                 (\ (ds_d6M2L [Occ=Once] :: M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgz) ->
                    foldMap
                      @ f_a6Le7
                      $dFoldable_a6Lea
                      @ (Sum a_a6Lgz)
                      @ a_a6Lgz
                      $dMonoid_s6MJj
                      ((Data.Foldable.$fFoldable:*:1 @ a_a6Lgz)
                       `cast` (<a_a6Lgz>_R
                               ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6Lgz>_R)
                               :: (a_a6Lgz -> a_a6Lgz :: *) ~R# (a_a6Lgz -> Sum a_a6Lgz :: *)))
                      (ds_d6M2L
                       `cast` (GHC.Generics.N:M1[0]
                                   <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <a_a6Lgz>_N
                               :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgz :: *)
                                  ~R# (f_a6Le7 a_a6Lgz :: *))))
                 `cast` (<M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgz>_R
                         ->_R Data.Semigroup.Internal.N:Sum[0] <a_a6Lgz>_R
                         :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgz -> Sum a_a6Lgz :: *)
                            ~R# (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgz -> a_a6Lgz :: *))}]
Data.Foldable.$fFoldableM1_$csum
  = \ (@ (f_a6Le7 :: * -> *))
      (@ i_a6Le8)
      (@ (c_a6Le9 :: Meta))
      ($dFoldable_a6Lea :: Foldable f_a6Le7)
      (@ a_a6Lgz)
      ($dNum_a6LgB :: Num a_a6Lgz) ->
      let {
        $dMonoid_s6MJj :: Monoid (Sum a_a6Lgz)
        [LclId]
        $dMonoid_s6MJj
          = Data.Semigroup.Internal.$fMonoidSum @ a_a6Lgz $dNum_a6LgB } in
      (\ (ds_d6M2L :: M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgz) ->
         foldMap
           @ f_a6Le7
           $dFoldable_a6Lea
           @ (Sum a_a6Lgz)
           @ a_a6Lgz
           $dMonoid_s6MJj
           ((Data.Foldable.$fFoldable:*:1 @ a_a6Lgz)
            `cast` (<a_a6Lgz>_R
                    ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6Lgz>_R)
                    :: (a_a6Lgz -> a_a6Lgz :: *) ~R# (a_a6Lgz -> Sum a_a6Lgz :: *)))
           (ds_d6M2L
            `cast` (GHC.Generics.N:M1[0]
                        <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <a_a6Lgz>_N
                    :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgz :: *)
                       ~R# (f_a6Le7 a_a6Lgz :: *))))
      `cast` (<M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgz>_R
              ->_R Data.Semigroup.Internal.N:Sum[0] <a_a6Lgz>_R
              :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgz -> Sum a_a6Lgz :: *)
                 ~R# (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgz -> a_a6Lgz :: *))

-- RHS size: {terms: 20, types: 32, coercions: 14, joins: 0/1}
Data.Foldable.$fFoldableM1_$cminimum
  :: forall (f :: * -> *) i (c :: Meta).
     Foldable f =>
     forall a. Ord a => M1 i c f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 110 60}]
Data.Foldable.$fFoldableM1_$cminimum
  = \ (@ (f_a6Le7 :: * -> *))
      (@ i_a6Le8)
      (@ (c_a6Le9 :: Meta))
      ($dFoldable_a6Lea :: Foldable f_a6Le7)
      (@ a_a6Lgp)
      ($dOrd_a6Lgr :: Ord a_a6Lgp) ->
      let {
        $dMonoid_s6MJe :: Monoid (Min a_a6Lgp)
        [LclId]
        $dMonoid_s6MJe
          = Data.Functor.Utils.$fMonoidMin @ a_a6Lgp $dOrd_a6Lgr } in
      \ (x_X6HLQ :: M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgp) ->
        case (foldMap
                @ f_a6Le7
                $dFoldable_a6Lea
                @ (Min a_a6Lgp)
                @ a_a6Lgp
                $dMonoid_s6MJe
                ((GHC.Base.Just @ a_a6Lgp)
                 `cast` (<a_a6Lgp>_R
                         ->_R Sym (Data.Functor.Utils.N:Min[0]) <a_a6Lgp>_N
                         :: (a_a6Lgp -> Maybe a_a6Lgp :: *)
                            ~R# (a_a6Lgp -> Min a_a6Lgp :: *)))
                (x_X6HLQ
                 `cast` (GHC.Generics.N:M1[0]
                             <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <a_a6Lgp>_N
                         :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgp :: *)
                            ~R# (f_a6Le7 a_a6Lgp :: *))))
             `cast` (Data.Functor.Utils.N:Min[0] <a_a6Lgp>_N
                     :: (Min a_a6Lgp :: *) ~R# (Maybe a_a6Lgp :: *))
        of {
          Nothing -> Data.Foldable.$fFoldable:*:2 @ a_a6Lgp;
          Just v_i6M0Z -> v_i6M0Z
        }

-- RHS size: {terms: 20, types: 32, coercions: 14, joins: 0/1}
Data.Foldable.$fFoldableM1_$cmaximum
  :: forall (f :: * -> *) i (c :: Meta).
     Foldable f =>
     forall a. Ord a => M1 i c f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 110 60}]
Data.Foldable.$fFoldableM1_$cmaximum
  = \ (@ (f_a6Le7 :: * -> *))
      (@ i_a6Le8)
      (@ (c_a6Le9 :: Meta))
      ($dFoldable_a6Lea :: Foldable f_a6Le7)
      (@ a_a6Lgf)
      ($dOrd_a6Lgh :: Ord a_a6Lgf) ->
      let {
        $dMonoid_s6MJa :: Monoid (Max a_a6Lgf)
        [LclId]
        $dMonoid_s6MJa
          = Data.Functor.Utils.$fMonoidMax @ a_a6Lgf $dOrd_a6Lgh } in
      \ (x_X6HLR :: M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgf) ->
        case (foldMap
                @ f_a6Le7
                $dFoldable_a6Lea
                @ (Max a_a6Lgf)
                @ a_a6Lgf
                $dMonoid_s6MJa
                ((GHC.Base.Just @ a_a6Lgf)
                 `cast` (<a_a6Lgf>_R
                         ->_R Sym (Data.Functor.Utils.N:Max[0]) <a_a6Lgf>_N
                         :: (a_a6Lgf -> Maybe a_a6Lgf :: *)
                            ~R# (a_a6Lgf -> Max a_a6Lgf :: *)))
                (x_X6HLR
                 `cast` (GHC.Generics.N:M1[0]
                             <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <a_a6Lgf>_N
                         :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lgf :: *)
                            ~R# (f_a6Le7 a_a6Lgf :: *))))
             `cast` (Data.Functor.Utils.N:Max[0] <a_a6Lgf>_N
                     :: (Max a_a6Lgf :: *) ~R# (Maybe a_a6Lgf :: *))
        of {
          Nothing -> Data.Foldable.$fFoldable:*:3 @ a_a6Lgf;
          Just v_i6M0Z -> v_i6M0Z
        }

-- RHS size: {terms: 27, types: 36, coercions: 7, joins: 0/0}
Data.Foldable.$fFoldableM1_$cfoldr1
  :: forall (f :: * -> *) i (c :: Meta).
     Foldable f =>
     forall a. (a -> a -> a) -> M1 i c f a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 60 0] 150 0}]
Data.Foldable.$fFoldableM1_$cfoldr1
  = \ (@ (f_a6Le7 :: * -> *))
      (@ i_a6Le8)
      (@ (c_a6Le9 :: Meta))
      ($dFoldable_a6Lea :: Foldable f_a6Le7)
      (@ a_a6Lfq)
      (f1_a6K7J :: a_a6Lfq -> a_a6Lfq -> a_a6Lfq)
      (xs_a6K7K :: M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lfq) ->
      case foldr
             @ f_a6Le7
             $dFoldable_a6Lea
             @ a_a6Lfq
             @ (Maybe a_a6Lfq)
             (\ (x_a6K7M :: a_a6Lfq) (m_a6K7N :: Maybe a_a6Lfq) ->
                GHC.Base.Just
                  @ a_a6Lfq
                  (case m_a6K7N of {
                     Nothing -> x_a6K7M;
                     Just y_a6K7O -> f1_a6K7J x_a6K7M y_a6K7O
                   }))
             (GHC.Base.Nothing @ a_a6Lfq)
             (xs_a6K7K
              `cast` (GHC.Generics.N:M1[0]
                          <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <a_a6Lfq>_N
                      :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lfq :: *)
                         ~R# (f_a6Le7 a_a6Lfq :: *)))
      of {
        Nothing -> Data.Foldable.$fFoldable:*:8 @ a_a6Lfq;
        Just v_i6M0Z -> v_i6M0Z
      }

-- RHS size: {terms: 24, types: 33, coercions: 7, joins: 0/0}
Data.Foldable.$fFoldableM1_$cfoldl'
  :: forall (f :: * -> *) i (c :: Meta).
     Foldable f =>
     forall b a. (b -> a -> b) -> b -> M1 i c f a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 0 0] 150 0}]
Data.Foldable.$fFoldableM1_$cfoldl'
  = \ (@ (f_a6Le7 :: * -> *))
      (@ i_a6Le8)
      (@ (c_a6Le9 :: Meta))
      ($dFoldable_a6Lea :: Foldable f_a6Le7)
      (@ b_a6Lfg)
      (@ a_a6Lfh)
      (f1_a6K7C :: b_a6Lfg -> a_a6Lfh -> b_a6Lfg)
      (z0_a6K7D :: b_a6Lfg)
      (xs_a6K7E :: M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lfh) ->
      foldr
        @ f_a6Le7
        $dFoldable_a6Lea
        @ a_a6Lfh
        @ (b_a6Lfg -> b_a6Lfg)
        (\ (x_a6K7G :: a_a6Lfh)
           (k_a6K7H :: b_a6Lfg -> b_a6Lfg)
           (z_a6K7I :: b_a6Lfg) ->
           case f1_a6K7C z_a6K7I x_a6K7G of vx_i6M0K { __DEFAULT ->
           k_a6K7H vx_i6M0K
           })
        (id @ b_a6Lfg)
        (xs_a6K7E
         `cast` (GHC.Generics.N:M1[0]
                     <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <a_a6Lfh>_N
                 :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lfh :: *)
                    ~R# (f_a6Le7 a_a6Lfh :: *)))
        z0_a6K7D

-- RHS size: {terms: 12, types: 23, coercions: 7, joins: 0/0}
Data.Foldable.$fFoldableM1_$clength
  :: forall (f :: * -> *) i (c :: Meta).
     Foldable f =>
     forall a. M1 i c f a -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6Le7 :: * -> *))
                 (@ i_a6Le8)
                 (@ (c_a6Le9 :: Meta))
                 ($dFoldable_a6Lea [Occ=Once] :: Foldable f_a6Le7)
                 (@ a_a6LfX)
                 (eta_B1 [Occ=Once] :: M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LfX) ->
                 foldr
                   @ f_a6Le7
                   $dFoldable_a6Lea
                   @ a_a6LfX
                   @ (Int -> Int)
                   (Data.Foldable.$fFoldableM2 @ a_a6LfX)
                   (id @ Int)
                   (eta_B1
                    `cast` (GHC.Generics.N:M1[0]
                                <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <a_a6LfX>_N
                            :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LfX :: *)
                               ~R# (f_a6Le7 a_a6LfX :: *)))
                   Data.Foldable.$fFoldable:*:4}]
Data.Foldable.$fFoldableM1_$clength
  = \ (@ (f_a6Le7 :: * -> *))
      (@ i_a6Le8)
      (@ (c_a6Le9 :: Meta))
      ($dFoldable_a6Lea :: Foldable f_a6Le7)
      (@ a_a6LfX)
      (eta_B1 :: M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LfX) ->
      foldr
        @ f_a6Le7
        $dFoldable_a6Lea
        @ a_a6LfX
        @ (Int -> Int)
        (Data.Foldable.$fFoldableM2 @ a_a6LfX)
        (id @ Int)
        (eta_B1
         `cast` (GHC.Generics.N:M1[0]
                     <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <a_a6LfX>_N
                 :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LfX :: *)
                    ~R# (f_a6Le7 a_a6LfX :: *)))
        Data.Foldable.$fFoldable:*:4

-- RHS size: {terms: 19, types: 31, coercions: 16, joins: 0/0}
Data.Foldable.$fFoldableM1_$cfoldl
  :: forall (f :: * -> *) i (c :: Meta).
     Foldable f =>
     forall b a. (b -> a -> b) -> b -> M1 i c f a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6Le7 :: * -> *))
                 (@ i_a6Le8)
                 (@ (c_a6Le9 :: Meta))
                 ($dFoldable_a6Lea [Occ=Once] :: Foldable f_a6Le7)
                 (@ b_a6Lf6)
                 (@ a_a6Lf7)
                 (f1_a6K7z [Occ=OnceL!] :: b_a6Lf6 -> a_a6Lf7 -> b_a6Lf6)
                 (z_a6K7A [Occ=Once] :: b_a6Lf6)
                 (t_a6K7B [Occ=Once] :: M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lf7) ->
                 ((foldMap
                     @ f_a6Le7
                     $dFoldable_a6Lea
                     @ (Dual (Endo b_a6Lf6))
                     @ a_a6Lf7
                     (Data.Foldable.$fFoldable:*:7 @ b_a6Lf6)
                     ((\ (x_X6HLX [Occ=Once] :: a_a6Lf7)
                         (y_i6M0a [Occ=Once] :: b_a6Lf6) ->
                         f1_a6K7z y_i6M0a x_X6HLX)
                      `cast` (<a_a6Lf7>_R
                              ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                            (Data.Semigroup.Internal.N:Endo[0] <b_a6Lf6>_R))
                              :: (a_a6Lf7 -> b_a6Lf6 -> b_a6Lf6 :: *)
                                 ~R# (a_a6Lf7 -> Dual (Endo b_a6Lf6) :: *)))
                     (t_a6K7B
                      `cast` (GHC.Generics.N:M1[0]
                                  <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <a_a6Lf7>_N
                              :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lf7 :: *)
                                 ~R# (f_a6Le7 a_a6Lf7 :: *))))
                  `cast` (Data.Semigroup.Internal.N:Dual[0]
                              (Data.Semigroup.Internal.N:Endo[0] <b_a6Lf6>_R)
                          :: (Dual (Endo b_a6Lf6) :: *) ~R# (b_a6Lf6 -> b_a6Lf6 :: *)))
                   z_a6K7A}]
Data.Foldable.$fFoldableM1_$cfoldl
  = \ (@ (f_a6Le7 :: * -> *))
      (@ i_a6Le8)
      (@ (c_a6Le9 :: Meta))
      ($dFoldable_a6Lea :: Foldable f_a6Le7)
      (@ b_a6Lf6)
      (@ a_a6Lf7)
      (f1_a6K7z :: b_a6Lf6 -> a_a6Lf7 -> b_a6Lf6)
      (z_a6K7A :: b_a6Lf6)
      (t_a6K7B :: M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lf7) ->
      ((foldMap
          @ f_a6Le7
          $dFoldable_a6Lea
          @ (Dual (Endo b_a6Lf6))
          @ a_a6Lf7
          (Data.Foldable.$fFoldable:*:7 @ b_a6Lf6)
          ((\ (x_X6HLX :: a_a6Lf7) (y_i6M0a :: b_a6Lf6) ->
              f1_a6K7z y_i6M0a x_X6HLX)
           `cast` (<a_a6Lf7>_R
                   ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                 (Data.Semigroup.Internal.N:Endo[0] <b_a6Lf6>_R))
                   :: (a_a6Lf7 -> b_a6Lf6 -> b_a6Lf6 :: *)
                      ~R# (a_a6Lf7 -> Dual (Endo b_a6Lf6) :: *)))
          (t_a6K7B
           `cast` (GHC.Generics.N:M1[0]
                       <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <a_a6Lf7>_N
                   :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lf7 :: *)
                      ~R# (f_a6Le7 a_a6Lf7 :: *))))
       `cast` (Data.Semigroup.Internal.N:Dual[0]
                   (Data.Semigroup.Internal.N:Endo[0] <b_a6Lf6>_R)
               :: (Dual (Endo b_a6Lf6) :: *) ~R# (b_a6Lf6 -> b_a6Lf6 :: *)))
        z_a6K7A

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableM3
  :: forall a. Monoid (Dual (Endo (Maybe a)))
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Foldable.$fFoldableM3
  = \ (@ a_a6Lfy) ->
      Data.Semigroup.Internal.$fMonoidDual
        @ (Endo (Maybe a_a6Lfy))
        (Data.Semigroup.Internal.$fMonoidEndo @ (Maybe a_a6Lfy))

-- RHS size: {terms: 28, types: 39, coercions: 18, joins: 0/0}
Data.Foldable.$fFoldableM1_$cfoldl1
  :: forall (f :: * -> *) i (c :: Meta).
     Foldable f =>
     forall a. (a -> a -> a) -> M1 i c f a -> a
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 60 0] 160 0}]
Data.Foldable.$fFoldableM1_$cfoldl1
  = \ (@ (f_a6Le7 :: * -> *))
      (@ i_a6Le8)
      (@ (c_a6Le9 :: Meta))
      ($dFoldable_a6Lea :: Foldable f_a6Le7)
      (@ a_a6Lfy)
      (f1_a6K7P :: a_a6Lfy -> a_a6Lfy -> a_a6Lfy)
      (xs_a6K7Q :: M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lfy) ->
      case ((foldMap
               @ f_a6Le7
               $dFoldable_a6Lea
               @ (Dual (Endo (Maybe a_a6Lfy)))
               @ a_a6Lfy
               (Data.Foldable.$fFoldableM3 @ a_a6Lfy)
               ((\ (x_X6HLX :: a_a6Lfy) (y_i6M0a :: Maybe a_a6Lfy) ->
                   GHC.Base.Just
                     @ a_a6Lfy
                     (case y_i6M0a of {
                        Nothing -> x_X6HLX;
                        Just x1_a6K7U -> f1_a6K7P x1_a6K7U x_X6HLX
                      }))
                `cast` (<a_a6Lfy>_R
                        ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                      (Data.Semigroup.Internal.N:Endo[0] <Maybe a_a6Lfy>_R))
                        :: (a_a6Lfy -> Maybe a_a6Lfy -> Maybe a_a6Lfy :: *)
                           ~R# (a_a6Lfy -> Dual (Endo (Maybe a_a6Lfy)) :: *)))
               (xs_a6K7Q
                `cast` (GHC.Generics.N:M1[0]
                            <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <a_a6Lfy>_N
                        :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lfy :: *)
                           ~R# (f_a6Le7 a_a6Lfy :: *))))
            `cast` (Data.Semigroup.Internal.N:Dual[0]
                        (Data.Semigroup.Internal.N:Endo[0] <Maybe a_a6Lfy>_R)
                    :: (Dual (Endo (Maybe a_a6Lfy)) :: *)
                       ~R# (Maybe a_a6Lfy -> Maybe a_a6Lfy :: *)))
             (GHC.Base.Nothing @ a_a6Lfy)
      of {
        Nothing -> Data.Foldable.$fFoldable:*:6 @ a_a6Lfy;
        Just v_i6M0Z -> v_i6M0Z
      }

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableM4
  :: forall b. Monoid (Dual (Endo (b -> b)))
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Foldable.$fFoldableM4
  = \ (@ b_a6LeX) ->
      Data.Semigroup.Internal.$fMonoidDual
        @ (Endo (b_a6LeX -> b_a6LeX))
        (Data.Semigroup.Internal.$fMonoidEndo @ (b_a6LeX -> b_a6LeX))

-- RHS size: {terms: 25, types: 36, coercions: 18, joins: 0/0}
Data.Foldable.$fFoldableM1_$cfoldr'
  :: forall (f :: * -> *) i (c :: Meta).
     Foldable f =>
     forall a b. (a -> b -> b) -> b -> M1 i c f a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 0 0] 160 0}]
Data.Foldable.$fFoldableM1_$cfoldr'
  = \ (@ (f_a6Le7 :: * -> *))
      (@ i_a6Le8)
      (@ (c_a6Le9 :: Meta))
      ($dFoldable_a6Lea :: Foldable f_a6Le7)
      (@ a_a6LeW)
      (@ b_a6LeX)
      (f1_a6K7s :: a_a6LeW -> b_a6LeX -> b_a6LeX)
      (z0_a6K7t :: b_a6LeX)
      (xs_a6K7u :: M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LeW) ->
      ((foldMap
          @ f_a6Le7
          $dFoldable_a6Lea
          @ (Dual (Endo (b_a6LeX -> b_a6LeX)))
          @ a_a6LeW
          (Data.Foldable.$fFoldableM4 @ b_a6LeX)
          ((\ (x_X6HLX :: a_a6LeW)
              (y_i6M0a :: b_a6LeX -> b_a6LeX)
              (z_a6K7y :: b_a6LeX) ->
              case f1_a6K7s x_X6HLX z_a6K7y of vx_i6M0K { __DEFAULT ->
              y_i6M0a vx_i6M0K
              })
           `cast` (<a_a6LeW>_R
                   ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                 (Data.Semigroup.Internal.N:Endo[0] <b_a6LeX -> b_a6LeX>_R))
                   :: (a_a6LeW -> (b_a6LeX -> b_a6LeX) -> b_a6LeX -> b_a6LeX :: *)
                      ~R# (a_a6LeW -> Dual (Endo (b_a6LeX -> b_a6LeX)) :: *)))
          (xs_a6K7u
           `cast` (GHC.Generics.N:M1[0]
                       <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <a_a6LeW>_N
                   :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LeW :: *)
                      ~R# (f_a6Le7 a_a6LeW :: *))))
       `cast` (Data.Semigroup.Internal.N:Dual[0]
                   (Data.Semigroup.Internal.N:Endo[0] <b_a6LeX -> b_a6LeX>_R)
               :: (Dual (Endo (b_a6LeX -> b_a6LeX)) :: *)
                  ~R# ((b_a6LeX -> b_a6LeX) -> b_a6LeX -> b_a6LeX :: *)))
        (id @ b_a6LeX) z0_a6K7t

-- RHS size: {terms: 12, types: 23, coercions: 7, joins: 0/0}
Data.Foldable.$fFoldableM1_$cfold
  :: forall (f :: * -> *) i (c :: Meta).
     Foldable f =>
     forall m. Monoid m => M1 i c f m -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6Le7 :: * -> *))
                 (@ i_a6Le8)
                 (@ (c_a6Le9 :: Meta))
                 ($dFoldable_a6Lea [Occ=Once] :: Foldable f_a6Le7)
                 (@ m_a6Lee)
                 ($dMonoid_a6Leg [Occ=Once] :: Monoid m_a6Lee)
                 (ds_d6M2L [Occ=Once] :: M1 i_a6Le8 c_a6Le9 f_a6Le7 m_a6Lee) ->
                 foldMap
                   @ f_a6Le7
                   $dFoldable_a6Lea
                   @ m_a6Lee
                   @ m_a6Lee
                   $dMonoid_a6Leg
                   (id @ m_a6Lee)
                   (ds_d6M2L
                    `cast` (GHC.Generics.N:M1[0]
                                <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <m_a6Lee>_N
                            :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 m_a6Lee :: *)
                               ~R# (f_a6Le7 m_a6Lee :: *)))}]
Data.Foldable.$fFoldableM1_$cfold
  = \ (@ (f_a6Le7 :: * -> *))
      (@ i_a6Le8)
      (@ (c_a6Le9 :: Meta))
      ($dFoldable_a6Lea :: Foldable f_a6Le7)
      (@ m_a6Lee)
      ($dMonoid_a6Leg :: Monoid m_a6Lee)
      (ds_d6M2L :: M1 i_a6Le8 c_a6Le9 f_a6Le7 m_a6Lee) ->
      foldMap
        @ f_a6Le7
        $dFoldable_a6Lea
        @ m_a6Lee
        @ m_a6Lee
        $dMonoid_a6Leg
        (id @ m_a6Lee)
        (ds_d6M2L
         `cast` (GHC.Generics.N:M1[0]
                     <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <m_a6Lee>_N
                 :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 m_a6Lee :: *)
                    ~R# (f_a6Le7 m_a6Lee :: *)))

-- RHS size: {terms: 15, types: 28, coercions: 22, joins: 0/1}
Data.Foldable.$fFoldableM1_$cproduct
  :: forall (f :: * -> *) i (c :: Meta).
     Foldable f =>
     forall a. Num a => M1 i c f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6Le7 :: * -> *))
                 (@ i_a6Le8)
                 (@ (c_a6Le9 :: Meta))
                 ($dFoldable_a6Lea [Occ=OnceL] :: Foldable f_a6Le7)
                 (@ a_a6LgJ)
                 ($dNum_a6LgL [Occ=OnceL] :: Num a_a6LgJ) ->
                 let {
                   $dMonoid_s6MJ5 [Occ=OnceL] :: Monoid (Product a_a6LgJ)
                   [LclId]
                   $dMonoid_s6MJ5
                     = Data.Semigroup.Internal.$fMonoidProduct
                         @ a_a6LgJ $dNum_a6LgL } in
                 (\ (ds_d6M2L [Occ=Once] :: M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LgJ) ->
                    foldMap
                      @ f_a6Le7
                      $dFoldable_a6Lea
                      @ (Product a_a6LgJ)
                      @ a_a6LgJ
                      $dMonoid_s6MJ5
                      ((Data.Foldable.$fFoldable:*:1 @ a_a6LgJ)
                       `cast` (<a_a6LgJ>_R
                               ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LgJ>_R)
                               :: (a_a6LgJ -> a_a6LgJ :: *)
                                  ~R# (a_a6LgJ -> Product a_a6LgJ :: *)))
                      (ds_d6M2L
                       `cast` (GHC.Generics.N:M1[0]
                                   <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <a_a6LgJ>_N
                               :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LgJ :: *)
                                  ~R# (f_a6Le7 a_a6LgJ :: *))))
                 `cast` (<M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LgJ>_R
                         ->_R Data.Semigroup.Internal.N:Product[0] <a_a6LgJ>_R
                         :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LgJ -> Product a_a6LgJ :: *)
                            ~R# (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LgJ -> a_a6LgJ :: *))}]
Data.Foldable.$fFoldableM1_$cproduct
  = \ (@ (f_a6Le7 :: * -> *))
      (@ i_a6Le8)
      (@ (c_a6Le9 :: Meta))
      ($dFoldable_a6Lea :: Foldable f_a6Le7)
      (@ a_a6LgJ)
      ($dNum_a6LgL :: Num a_a6LgJ) ->
      let {
        $dMonoid_s6MJ5 :: Monoid (Product a_a6LgJ)
        [LclId]
        $dMonoid_s6MJ5
          = Data.Semigroup.Internal.$fMonoidProduct
              @ a_a6LgJ $dNum_a6LgL } in
      (\ (ds_d6M2L :: M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LgJ) ->
         foldMap
           @ f_a6Le7
           $dFoldable_a6Lea
           @ (Product a_a6LgJ)
           @ a_a6LgJ
           $dMonoid_s6MJ5
           ((Data.Foldable.$fFoldable:*:1 @ a_a6LgJ)
            `cast` (<a_a6LgJ>_R
                    ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LgJ>_R)
                    :: (a_a6LgJ -> a_a6LgJ :: *)
                       ~R# (a_a6LgJ -> Product a_a6LgJ :: *)))
           (ds_d6M2L
            `cast` (GHC.Generics.N:M1[0]
                        <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <a_a6LgJ>_N
                    :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LgJ :: *)
                       ~R# (f_a6Le7 a_a6LgJ :: *))))
      `cast` (<M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LgJ>_R
              ->_R Data.Semigroup.Internal.N:Product[0] <a_a6LgJ>_R
              :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LgJ -> Product a_a6LgJ :: *)
                 ~R# (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LgJ -> a_a6LgJ :: *))

-- RHS size: {terms: 11, types: 23, coercions: 7, joins: 0/0}
Data.Foldable.$fFoldableM1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) i (c :: Meta).
     Foldable f =>
     forall a. M1 i c f a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_a6Le7 :: * -> *))
                 (@ i_a6Le8)
                 (@ (c_a6Le9 :: Meta))
                 ($dFoldable_a6Lea [Occ=Once] :: Foldable f_a6Le7)
                 (@ a_a6LfG)
                 (t_a6K7V [Occ=Once] :: M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LfG) ->
                 build
                   @ a_a6LfG
                   (\ (@ b_a6KNB)
                      (c1_a6K7W [Occ=Once, OS=OneShot] :: a_a6LfG -> b_a6KNB -> b_a6KNB)
                      (n_a6K7X [Occ=Once, OS=OneShot] :: b_a6KNB) ->
                      foldr
                        @ f_a6Le7
                        $dFoldable_a6Lea
                        @ a_a6LfG
                        @ b_a6KNB
                        c1_a6K7W
                        n_a6K7X
                        (t_a6K7V
                         `cast` (GHC.Generics.N:M1[0]
                                     <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <a_a6LfG>_N
                                 :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LfG :: *)
                                    ~R# (f_a6Le7 a_a6LfG :: *))))}]
Data.Foldable.$fFoldableM1_$ctoList
  = \ (@ (f_a6Le7 :: * -> *))
      (@ i_a6Le8)
      (@ (c_a6Le9 :: Meta))
      ($dFoldable_a6Lea :: Foldable f_a6Le7)
      (@ a_a6LfG)
      (eta_XeE :: M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LfG) ->
      foldr
        @ f_a6Le7
        $dFoldable_a6Lea
        @ a_a6LfG
        @ [a_a6LfG]
        (GHC.Types.: @ a_a6LfG)
        (GHC.Types.[] @ a_a6LfG)
        (eta_XeE
         `cast` (GHC.Generics.N:M1[0]
                     <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <a_a6LfG>_N
                 :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LfG :: *)
                    ~R# (f_a6Le7 a_a6LfG :: *)))

-- RHS size: {terms: 56, types: 100, coercions: 21, joins: 0/0}
Data.Foldable.$fFoldableM1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) i (c :: Meta).
     Foldable f =>
     Foldable (M1 i c f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>,
 Unf=DFun: \ (@ (f_a6KaA :: * -> *))
             (@ i_a6KaB)
             (@ (c_a6KaC :: Meta))
             (v_XeD :: Foldable f_a6KaA) ->
       Data.Foldable.C:Foldable TYPE: M1 i_a6KaB c_a6KaC f_a6KaA
                                Data.Foldable.$fFoldableM1_$cfold
                                  @ f_a6KaA @ i_a6KaB @ c_a6KaC v_XeD
                                \ (@ m_a6Leo)
                                  (@ a_a6Lep)
                                  ($dMonoid_a6Ler [Occ=Once] :: Monoid m_a6Leo)
                                  (f1_a6Kqg [Occ=Once] :: a_a6Lep -> m_a6Leo)
                                  (ds_d6M2L [Occ=Once] :: M1 i_a6KaB c_a6KaC f_a6KaA a_a6Lep) ->
                                  foldMap
                                    @ f_a6KaA
                                    v_XeD
                                    @ m_a6Leo
                                    @ a_a6Lep
                                    $dMonoid_a6Ler
                                    f1_a6Kqg
                                    (ds_d6M2L
                                     `cast` (GHC.Generics.N:M1[0]
                                                 <*>_N
                                                 <i_a6KaB>_P
                                                 <c_a6KaC>_P
                                                 <f_a6KaA>_R <a_a6Lep>_N
                                             :: (M1 i_a6KaB c_a6KaC f_a6KaA a_a6Lep :: *)
                                                ~R# (f_a6KaA a_a6Lep :: *)))
                                \ (@ a_a6LeB)
                                  (@ b_a6LeC)
                                  (f1_a6Kqb [Occ=Once] :: a_a6LeB -> b_a6LeC -> b_a6LeC)
                                  (z_a6Kqc [Occ=Once] :: b_a6LeC)
                                  (ds_d6M2M [Occ=Once] :: M1 i_a6KaB c_a6KaC f_a6KaA a_a6LeB) ->
                                  foldr
                                    @ f_a6KaA
                                    v_XeD
                                    @ a_a6LeB
                                    @ b_a6LeC
                                    f1_a6Kqb
                                    z_a6Kqc
                                    (ds_d6M2M
                                     `cast` (GHC.Generics.N:M1[0]
                                                 <*>_N
                                                 <i_a6KaB>_P
                                                 <c_a6KaC>_P
                                                 <f_a6KaA>_R <a_a6LeB>_N
                                             :: (M1 i_a6KaB c_a6KaC f_a6KaA a_a6LeB :: *)
                                                ~R# (f_a6KaA a_a6LeB :: *)))
                                Data.Foldable.$fFoldableM1_$cfoldr'
                                  @ f_a6KaA @ i_a6KaB @ c_a6KaC v_XeD
                                Data.Foldable.$fFoldableM1_$cfoldl
                                  @ f_a6KaA @ i_a6KaB @ c_a6KaC v_XeD
                                Data.Foldable.$fFoldableM1_$cfoldl'
                                  @ f_a6KaA @ i_a6KaB @ c_a6KaC v_XeD
                                Data.Foldable.$fFoldableM1_$cfoldr1
                                  @ f_a6KaA @ i_a6KaB @ c_a6KaC v_XeD
                                Data.Foldable.$fFoldableM1_$cfoldl1
                                  @ f_a6KaA @ i_a6KaB @ c_a6KaC v_XeD
                                Data.Foldable.$fFoldableM1_$ctoList
                                  @ f_a6KaA @ i_a6KaB @ c_a6KaC v_XeD
                                \ (@ a_a6LfO)
                                  (ds_d6M2N [Occ=Once] :: M1 i_a6KaB c_a6KaC f_a6KaA a_a6LfO) ->
                                  null
                                    @ f_a6KaA
                                    v_XeD
                                    @ a_a6LfO
                                    (ds_d6M2N
                                     `cast` (GHC.Generics.N:M1[0]
                                                 <*>_N
                                                 <i_a6KaB>_P
                                                 <c_a6KaC>_P
                                                 <f_a6KaA>_R <a_a6LfO>_N
                                             :: (M1 i_a6KaB c_a6KaC f_a6KaA a_a6LfO :: *)
                                                ~R# (f_a6KaA a_a6LfO :: *)))
                                Data.Foldable.$fFoldableM1_$clength
                                  @ f_a6KaA @ i_a6KaB @ c_a6KaC v_XeD
                                Data.Foldable.$fFoldableM1_$celem
                                  @ f_a6KaA @ i_a6KaB @ c_a6KaC v_XeD
                                Data.Foldable.$fFoldableM1_$cmaximum
                                  @ f_a6KaA @ i_a6KaB @ c_a6KaC v_XeD
                                Data.Foldable.$fFoldableM1_$cminimum
                                  @ f_a6KaA @ i_a6KaB @ c_a6KaC v_XeD
                                Data.Foldable.$fFoldableM1_$csum
                                  @ f_a6KaA @ i_a6KaB @ c_a6KaC v_XeD
                                Data.Foldable.$fFoldableM1_$cproduct
                                  @ f_a6KaA @ i_a6KaB @ c_a6KaC v_XeD]
Data.Foldable.$fFoldableM1
  = \ (@ (f_a6Le7 :: * -> *))
      (@ i_a6Le8)
      (@ (c_a6Le9 :: Meta))
      ($dFoldable_a6Lea :: Foldable f_a6Le7) ->
      Data.Foldable.C:Foldable
        @ (M1 i_a6Le8 c_a6Le9 f_a6Le7)
        (Data.Foldable.$fFoldableM1_$cfold
           @ f_a6Le7 @ i_a6Le8 @ c_a6Le9 $dFoldable_a6Lea)
        (\ (@ m_a6Leo)
           (@ a_a6Lep)
           ($dMonoid_a6Ler :: Monoid m_a6Leo)
           (f1_a6Kqg :: a_a6Lep -> m_a6Leo)
           (ds_d6M2L :: M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lep) ->
           foldMap
             @ f_a6Le7
             $dFoldable_a6Lea
             @ m_a6Leo
             @ a_a6Lep
             $dMonoid_a6Ler
             f1_a6Kqg
             (ds_d6M2L
              `cast` (GHC.Generics.N:M1[0]
                          <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <a_a6Lep>_N
                      :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6Lep :: *)
                         ~R# (f_a6Le7 a_a6Lep :: *))))
        (\ (@ a_a6LeB)
           (@ b_a6LeC)
           (f1_a6Kqb :: a_a6LeB -> b_a6LeC -> b_a6LeC)
           (z_a6Kqc :: b_a6LeC)
           (ds_d6M2M :: M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LeB) ->
           foldr
             @ f_a6Le7
             $dFoldable_a6Lea
             @ a_a6LeB
             @ b_a6LeC
             f1_a6Kqb
             z_a6Kqc
             (ds_d6M2M
              `cast` (GHC.Generics.N:M1[0]
                          <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <a_a6LeB>_N
                      :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LeB :: *)
                         ~R# (f_a6Le7 a_a6LeB :: *))))
        (Data.Foldable.$fFoldableM1_$cfoldr'
           @ f_a6Le7 @ i_a6Le8 @ c_a6Le9 $dFoldable_a6Lea)
        (Data.Foldable.$fFoldableM1_$cfoldl
           @ f_a6Le7 @ i_a6Le8 @ c_a6Le9 $dFoldable_a6Lea)
        (Data.Foldable.$fFoldableM1_$cfoldl'
           @ f_a6Le7 @ i_a6Le8 @ c_a6Le9 $dFoldable_a6Lea)
        (Data.Foldable.$fFoldableM1_$cfoldr1
           @ f_a6Le7 @ i_a6Le8 @ c_a6Le9 $dFoldable_a6Lea)
        (Data.Foldable.$fFoldableM1_$cfoldl1
           @ f_a6Le7 @ i_a6Le8 @ c_a6Le9 $dFoldable_a6Lea)
        (Data.Foldable.$fFoldableM1_$ctoList
           @ f_a6Le7 @ i_a6Le8 @ c_a6Le9 $dFoldable_a6Lea)
        (\ (@ a_a6LfO) (ds_d6M2N :: M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LfO) ->
           null
             @ f_a6Le7
             $dFoldable_a6Lea
             @ a_a6LfO
             (ds_d6M2N
              `cast` (GHC.Generics.N:M1[0]
                          <*>_N <i_a6Le8>_P <c_a6Le9>_P <f_a6Le7>_R <a_a6LfO>_N
                      :: (M1 i_a6Le8 c_a6Le9 f_a6Le7 a_a6LfO :: *)
                         ~R# (f_a6Le7 a_a6LfO :: *))))
        (Data.Foldable.$fFoldableM1_$clength
           @ f_a6Le7 @ i_a6Le8 @ c_a6Le9 $dFoldable_a6Lea)
        (Data.Foldable.$fFoldableM1_$celem
           @ f_a6Le7 @ i_a6Le8 @ c_a6Le9 $dFoldable_a6Lea)
        (Data.Foldable.$fFoldableM1_$cmaximum
           @ f_a6Le7 @ i_a6Le8 @ c_a6Le9 $dFoldable_a6Lea)
        (Data.Foldable.$fFoldableM1_$cminimum
           @ f_a6Le7 @ i_a6Le8 @ c_a6Le9 $dFoldable_a6Lea)
        (Data.Foldable.$fFoldableM1_$csum
           @ f_a6Le7 @ i_a6Le8 @ c_a6Le9 $dFoldable_a6Lea)
        (Data.Foldable.$fFoldableM1_$cproduct
           @ f_a6Le7 @ i_a6Le8 @ c_a6Le9 $dFoldable_a6Lea)

-- RHS size: {terms: 7, types: 14, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK1_$celem
  :: forall i c a. Eq a => a -> K1 i c a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ i_a6LgS)
                 (@ c_a6LgT)
                 (@ a_a6Liz)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Types.False}]
Data.Foldable.$fFoldableK1_$celem
  = \ (@ i_a6LgS)
      (@ c_a6LgT)
      (@ a_a6Liz)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Types.False

-- RHS size: {terms: 7, types: 14, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK1_$csum
  :: forall i c a. Num a => K1 i c a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ i_a6LgS)
                 (@ c_a6LgT)
                 (@ a_a6Lj3)
                 ($dNum_a6Lj5 [Occ=Once] :: Num a_a6Lj3)
                 _ [Occ=Dead] ->
                 Data.Semigroup.Internal.$fMonoidSum2 @ a_a6Lj3 $dNum_a6Lj5}]
Data.Foldable.$fFoldableK1_$csum
  = \ (@ i_a6LgS)
      (@ c_a6LgT)
      (@ a_a6Lj3)
      ($dNum_a6Lj5 :: Num a_a6Lj3)
      _ [Occ=Dead] ->
      Data.Semigroup.Internal.$fMonoidSum2 @ a_a6Lj3 $dNum_a6Lj5

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK1_$cminimum
  :: forall i c a. Ord a => K1 i c a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ i_a6LgS)
                 (@ c_a6LgT)
                 (@ a_a6LiT)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 errorWithoutStackTrace
                   @ 'LiftedRep @ a_a6LiT Data.Foldable.$fFoldableK2}]
Data.Foldable.$fFoldableK1_$cminimum
  = \ (@ i_a6LgS)
      (@ c_a6LgT)
      (@ a_a6LiT)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6LiT Data.Foldable.$fFoldableK2

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK1_$cmaximum
  :: forall i c a. Ord a => K1 i c a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ i_a6LgS)
                 (@ c_a6LgT)
                 (@ a_a6LiJ)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 errorWithoutStackTrace
                   @ 'LiftedRep @ a_a6LiJ Data.Foldable.$fFoldableK4}]
Data.Foldable.$fFoldableK1_$cmaximum
  = \ (@ i_a6LgS)
      (@ c_a6LgT)
      (@ a_a6LiJ)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6LiJ Data.Foldable.$fFoldableK4

-- RHS size: {terms: 8, types: 17, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK1_$cfoldl
  :: forall i c b a. (b -> a -> b) -> b -> K1 i c a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ i_a6LgS)
                 (@ c_a6LgT)
                 (@ b_a6LhB)
                 (@ a_a6LhC)
                 _ [Occ=Dead]
                 (z_X6KmT [Occ=Once] :: b_a6LhB)
                 _ [Occ=Dead] ->
                 z_X6KmT}]
Data.Foldable.$fFoldableK1_$cfoldl
  = \ (@ i_a6LgS)
      (@ c_a6LgT)
      (@ b_a6LhB)
      (@ a_a6LhC)
      _ [Occ=Dead]
      (z_X6KmT :: b_a6LhB)
      _ [Occ=Dead] ->
      z_X6KmT

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK6 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Foldable.$fFoldableK6
  = unpackCString# Data.Foldable.$fFoldableK7

-- RHS size: {terms: 7, types: 16, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK1_$cfoldl1
  :: forall i c a. (a -> a -> a) -> K1 i c a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ i_a6LgS)
                 (@ c_a6LgT)
                 (@ a_a6Li3)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 errorWithoutStackTrace
                   @ 'LiftedRep @ a_a6Li3 Data.Foldable.$fFoldableK6}]
Data.Foldable.$fFoldableK1_$cfoldl1
  = \ (@ i_a6LgS)
      (@ c_a6LgT)
      (@ a_a6Li3)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6Li3 Data.Foldable.$fFoldableK6

-- RHS size: {terms: 8, types: 17, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK1_$cfoldr'
  :: forall i c a b. (a -> b -> b) -> b -> K1 i c a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ i_a6LgS)
                 (@ c_a6LgT)
                 (@ a_a6Lhr)
                 (@ b_a6Lhs)
                 _ [Occ=Dead]
                 (z0_a6K7t [Occ=Once] :: b_a6Lhs)
                 _ [Occ=Dead] ->
                 z0_a6K7t}]
Data.Foldable.$fFoldableK1_$cfoldr'
  = \ (@ i_a6LgS)
      (@ c_a6LgT)
      (@ a_a6Lhr)
      (@ b_a6Lhs)
      _ [Occ=Dead]
      (z0_a6K7t :: b_a6Lhs)
      _ [Occ=Dead] ->
      z0_a6K7t

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK1_$clength
  :: forall i c a. K1 i c a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ i_a6LgS) (@ c_a6LgT) (@ a_a6Lir) _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable:*:4}]
Data.Foldable.$fFoldableK1_$clength
  = \ (@ i_a6LgS) (@ c_a6LgT) (@ a_a6Lir) _ [Occ=Dead] ->
      Data.Foldable.$fFoldable:*:4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK8 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Foldable.$fFoldableK8
  = unpackCString# Data.Foldable.$fFoldableK9

-- RHS size: {terms: 7, types: 16, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK1_$cfoldr1
  :: forall i c a. (a -> a -> a) -> K1 i c a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ i_a6LgS)
                 (@ c_a6LgT)
                 (@ a_a6LhV)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 errorWithoutStackTrace
                   @ 'LiftedRep @ a_a6LhV Data.Foldable.$fFoldableK8}]
Data.Foldable.$fFoldableK1_$cfoldr1
  = \ (@ i_a6LgS)
      (@ c_a6LgT)
      (@ a_a6LhV)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6LhV Data.Foldable.$fFoldableK8

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK1_$cnull :: forall i c a. K1 i c a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ i_a6LgS) (@ c_a6LgT) (@ a_a6Lij) _ [Occ=Dead] ->
                 GHC.Types.True}]
Data.Foldable.$fFoldableK1_$cnull
  = \ (@ i_a6LgS) (@ c_a6LgT) (@ a_a6Lij) _ [Occ=Dead] ->
      GHC.Types.True

-- RHS size: {terms: 7, types: 14, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK1_$cfold
  :: forall i c m. Monoid m => K1 i c m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ i_a6LgS)
                 (@ c_a6LgT)
                 (@ m_a6LgX)
                 ($dMonoid_a6LgZ [Occ=Once] :: Monoid m_a6LgX)
                 _ [Occ=Dead] ->
                 mempty @ m_a6LgX $dMonoid_a6LgZ}]
Data.Foldable.$fFoldableK1_$cfold
  = \ (@ i_a6LgS)
      (@ c_a6LgT)
      (@ m_a6LgX)
      ($dMonoid_a6LgZ :: Monoid m_a6LgX)
      _ [Occ=Dead] ->
      mempty @ m_a6LgX $dMonoid_a6LgZ

-- RHS size: {terms: 7, types: 14, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK1_$cproduct
  :: forall i c a. Num a => K1 i c a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ i_a6LgS)
                 (@ c_a6LgT)
                 (@ a_a6Ljd)
                 ($dNum_a6Ljf [Occ=Once] :: Num a_a6Ljd)
                 _ [Occ=Dead] ->
                 Data.Semigroup.Internal.$fMonoidProduct2 @ a_a6Ljd $dNum_a6Ljf}]
Data.Foldable.$fFoldableK1_$cproduct
  = \ (@ i_a6LgS)
      (@ c_a6LgT)
      (@ a_a6Ljd)
      ($dNum_a6Ljf :: Num a_a6Ljd)
      _ [Occ=Dead] ->
      Data.Semigroup.Internal.$fMonoidProduct2 @ a_a6Ljd $dNum_a6Ljf

-- RHS size: {terms: 5, types: 12, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall i c a. K1 i c a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ i_a6LgS) (@ c_a6LgT) (@ a_a6Lib) _ [Occ=Dead] ->
                 build
                   @ a_a6Lib
                   (\ (@ b_a6KNB)
                      _ [Occ=Dead, OS=OneShot]
                      (n_a6K7X [Occ=Once, OS=OneShot] :: b_a6KNB) ->
                      n_a6K7X)}]
Data.Foldable.$fFoldableK1_$ctoList
  = \ (@ i_a6LgS) (@ c_a6LgT) (@ a_a6Lib) _ [Occ=Dead] ->
      GHC.Types.[] @ a_a6Lib

-- RHS size: {terms: 19, types: 40, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i c. Foldable (K1 i c)
[GblId[DFunId],
 Unf=DFun: \ (@ i_a6KaD) (@ c_a6KaE) ->
       Data.Foldable.C:Foldable TYPE: K1 i_a6KaD c_a6KaE
                                Data.Foldable.$fFoldableK1_$cfold @ i_a6KaD @ c_a6KaE
                                Data.Foldable.$fFoldableK1_$cfoldMap @ i_a6KaD @ c_a6KaE
                                Data.Foldable.$fFoldableK1_$cfoldr' @ i_a6KaD @ c_a6KaE
                                Data.Foldable.$fFoldableK1_$cfoldr' @ i_a6KaD @ c_a6KaE
                                Data.Foldable.$fFoldableK1_$cfoldl @ i_a6KaD @ c_a6KaE
                                Data.Foldable.$fFoldableK1_$cfoldl @ i_a6KaD @ c_a6KaE
                                Data.Foldable.$fFoldableK1_$cfoldr1 @ i_a6KaD @ c_a6KaE
                                Data.Foldable.$fFoldableK1_$cfoldl1 @ i_a6KaD @ c_a6KaE
                                Data.Foldable.$fFoldableK1_$ctoList @ i_a6KaD @ c_a6KaE
                                Data.Foldable.$fFoldableK1_$cnull @ i_a6KaD @ c_a6KaE
                                Data.Foldable.$fFoldableK1_$clength @ i_a6KaD @ c_a6KaE
                                Data.Foldable.$fFoldableK1_$celem @ i_a6KaD @ c_a6KaE
                                Data.Foldable.$fFoldableK1_$cmaximum @ i_a6KaD @ c_a6KaE
                                Data.Foldable.$fFoldableK1_$cminimum @ i_a6KaD @ c_a6KaE
                                Data.Foldable.$fFoldableK1_$csum @ i_a6KaD @ c_a6KaE
                                Data.Foldable.$fFoldableK1_$cproduct @ i_a6KaD @ c_a6KaE]
Data.Foldable.$fFoldableK1
  = \ (@ i_a6LgS) (@ c_a6LgT) ->
      Data.Foldable.C:Foldable
        @ (K1 i_a6LgS c_a6LgT)
        (Data.Foldable.$fFoldableK1_$cfold @ i_a6LgS @ c_a6LgT)
        (Data.Foldable.$fFoldableK1_$cfoldMap @ i_a6LgS @ c_a6LgT)
        (Data.Foldable.$fFoldableK1_$cfoldr' @ i_a6LgS @ c_a6LgT)
        (Data.Foldable.$fFoldableK1_$cfoldr' @ i_a6LgS @ c_a6LgT)
        (Data.Foldable.$fFoldableK1_$cfoldl @ i_a6LgS @ c_a6LgT)
        (Data.Foldable.$fFoldableK1_$cfoldl @ i_a6LgS @ c_a6LgT)
        (Data.Foldable.$fFoldableK1_$cfoldr1 @ i_a6LgS @ c_a6LgT)
        (Data.Foldable.$fFoldableK1_$cfoldl1 @ i_a6LgS @ c_a6LgT)
        (Data.Foldable.$fFoldableK1_$ctoList @ i_a6LgS @ c_a6LgT)
        (Data.Foldable.$fFoldableK1_$cnull @ i_a6LgS @ c_a6LgT)
        (Data.Foldable.$fFoldableK1_$clength @ i_a6LgS @ c_a6LgT)
        (Data.Foldable.$fFoldableK1_$celem @ i_a6LgS @ c_a6LgT)
        (Data.Foldable.$fFoldableK1_$cmaximum @ i_a6LgS @ c_a6LgT)
        (Data.Foldable.$fFoldableK1_$cminimum @ i_a6LgS @ c_a6LgT)
        (Data.Foldable.$fFoldableK1_$csum @ i_a6LgS @ c_a6LgT)
        (Data.Foldable.$fFoldableK1_$cproduct @ i_a6LgS @ c_a6LgT)

-- RHS size: {terms: 15, types: 22, coercions: 16, joins: 0/1}
Data.Foldable.$fFoldableRec1_$celem
  :: forall (f :: * -> *).
     Foldable f =>
     forall a. Eq a => a -> Rec1 f a -> Bool
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6Ljm :: * -> *))
                 ($dFoldable_a6Ljn [Occ=OnceL] :: Foldable f_a6Ljm)
                 (@ a_a6Lli)
                 ($dEq_a6Llk [Occ=Once] :: Eq a_a6Lli)
                 (eta_B1 [Occ=Once] :: a_a6Lli) ->
                 let {
                   f1_s6MJ1 [Occ=OnceL] :: a_a6Lli -> Bool
                   [LclId]
                   f1_s6MJ1 = == @ a_a6Lli $dEq_a6Llk eta_B1 } in
                 (\ (ds_d6M2Q [Occ=Once] :: Rec1 f_a6Ljm a_a6Lli) ->
                    foldMap
                      @ f_a6Ljm
                      $dFoldable_a6Ljn
                      @ Data.Monoid.Any
                      @ a_a6Lli
                      Data.Semigroup.Internal.$fMonoidAny
                      (f1_s6MJ1
                       `cast` (<a_a6Lli>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                               :: (a_a6Lli -> Bool :: *) ~R# (a_a6Lli -> Data.Monoid.Any :: *)))
                      (ds_d6M2Q
                       `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <a_a6Lli>_N
                               :: (Rec1 f_a6Ljm a_a6Lli :: *) ~R# (f_a6Ljm a_a6Lli :: *))))
                 `cast` (<Rec1 f_a6Ljm a_a6Lli>_R
                         ->_R Data.Semigroup.Internal.N:Any[0]
                         :: (Rec1 f_a6Ljm a_a6Lli -> Data.Monoid.Any :: *)
                            ~R# (Rec1 f_a6Ljm a_a6Lli -> Bool :: *))}]
Data.Foldable.$fFoldableRec1_$celem
  = \ (@ (f_a6Ljm :: * -> *))
      ($dFoldable_a6Ljn :: Foldable f_a6Ljm)
      (@ a_a6Lli)
      ($dEq_a6Llk :: Eq a_a6Lli)
      (eta_B1 :: a_a6Lli) ->
      let {
        f1_s6MJ1 :: a_a6Lli -> Bool
        [LclId]
        f1_s6MJ1 = == @ a_a6Lli $dEq_a6Llk eta_B1 } in
      (\ (ds_d6M2Q :: Rec1 f_a6Ljm a_a6Lli) ->
         foldMap
           @ f_a6Ljm
           $dFoldable_a6Ljn
           @ Data.Monoid.Any
           @ a_a6Lli
           Data.Semigroup.Internal.$fMonoidAny
           (f1_s6MJ1
            `cast` (<a_a6Lli>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                    :: (a_a6Lli -> Bool :: *) ~R# (a_a6Lli -> Data.Monoid.Any :: *)))
           (ds_d6M2Q
            `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <a_a6Lli>_N
                    :: (Rec1 f_a6Ljm a_a6Lli :: *) ~R# (f_a6Ljm a_a6Lli :: *))))
      `cast` (<Rec1 f_a6Ljm a_a6Lli>_R
              ->_R Data.Semigroup.Internal.N:Any[0]
              :: (Rec1 f_a6Ljm a_a6Lli -> Data.Monoid.Any :: *)
                 ~R# (Rec1 f_a6Ljm a_a6Lli -> Bool :: *))

-- RHS size: {terms: 13, types: 24, coercions: 18, joins: 0/1}
Data.Foldable.$fFoldableRec1_$csum
  :: forall (f :: * -> *).
     Foldable f =>
     forall a. Num a => Rec1 f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6Ljm :: * -> *))
                 ($dFoldable_a6Ljn [Occ=OnceL] :: Foldable f_a6Ljm)
                 (@ a_a6LlM)
                 ($dNum_a6LlO [Occ=OnceL] :: Num a_a6LlM) ->
                 let {
                   $dMonoid_s6MIZ [Occ=OnceL] :: Monoid (Sum a_a6LlM)
                   [LclId]
                   $dMonoid_s6MIZ
                     = Data.Semigroup.Internal.$fMonoidSum @ a_a6LlM $dNum_a6LlO } in
                 (\ (ds_d6M2Q [Occ=Once] :: Rec1 f_a6Ljm a_a6LlM) ->
                    foldMap
                      @ f_a6Ljm
                      $dFoldable_a6Ljn
                      @ (Sum a_a6LlM)
                      @ a_a6LlM
                      $dMonoid_s6MIZ
                      ((Data.Foldable.$fFoldable:*:1 @ a_a6LlM)
                       `cast` (<a_a6LlM>_R
                               ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6LlM>_R)
                               :: (a_a6LlM -> a_a6LlM :: *) ~R# (a_a6LlM -> Sum a_a6LlM :: *)))
                      (ds_d6M2Q
                       `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <a_a6LlM>_N
                               :: (Rec1 f_a6Ljm a_a6LlM :: *) ~R# (f_a6Ljm a_a6LlM :: *))))
                 `cast` (<Rec1 f_a6Ljm a_a6LlM>_R
                         ->_R Data.Semigroup.Internal.N:Sum[0] <a_a6LlM>_R
                         :: (Rec1 f_a6Ljm a_a6LlM -> Sum a_a6LlM :: *)
                            ~R# (Rec1 f_a6Ljm a_a6LlM -> a_a6LlM :: *))}]
Data.Foldable.$fFoldableRec1_$csum
  = \ (@ (f_a6Ljm :: * -> *))
      ($dFoldable_a6Ljn :: Foldable f_a6Ljm)
      (@ a_a6LlM)
      ($dNum_a6LlO :: Num a_a6LlM) ->
      let {
        $dMonoid_s6MIZ :: Monoid (Sum a_a6LlM)
        [LclId]
        $dMonoid_s6MIZ
          = Data.Semigroup.Internal.$fMonoidSum @ a_a6LlM $dNum_a6LlO } in
      (\ (ds_d6M2Q :: Rec1 f_a6Ljm a_a6LlM) ->
         foldMap
           @ f_a6Ljm
           $dFoldable_a6Ljn
           @ (Sum a_a6LlM)
           @ a_a6LlM
           $dMonoid_s6MIZ
           ((Data.Foldable.$fFoldable:*:1 @ a_a6LlM)
            `cast` (<a_a6LlM>_R
                    ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6LlM>_R)
                    :: (a_a6LlM -> a_a6LlM :: *) ~R# (a_a6LlM -> Sum a_a6LlM :: *)))
           (ds_d6M2Q
            `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <a_a6LlM>_N
                    :: (Rec1 f_a6Ljm a_a6LlM :: *) ~R# (f_a6Ljm a_a6LlM :: *))))
      `cast` (<Rec1 f_a6Ljm a_a6LlM>_R
              ->_R Data.Semigroup.Internal.N:Sum[0] <a_a6LlM>_R
              :: (Rec1 f_a6Ljm a_a6LlM -> Sum a_a6LlM :: *)
                 ~R# (Rec1 f_a6Ljm a_a6LlM -> a_a6LlM :: *))

-- RHS size: {terms: 18, types: 28, coercions: 12, joins: 0/1}
Data.Foldable.$fFoldableRec1_$cminimum
  :: forall (f :: * -> *).
     Foldable f =>
     forall a. Ord a => Rec1 f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 110 60}]
Data.Foldable.$fFoldableRec1_$cminimum
  = \ (@ (f_a6Ljm :: * -> *))
      ($dFoldable_a6Ljn :: Foldable f_a6Ljm)
      (@ a_a6LlC)
      ($dOrd_a6LlE :: Ord a_a6LlC) ->
      let {
        $dMonoid_s6MIU :: Monoid (Min a_a6LlC)
        [LclId]
        $dMonoid_s6MIU
          = Data.Functor.Utils.$fMonoidMin @ a_a6LlC $dOrd_a6LlE } in
      \ (x_X6HLQ :: Rec1 f_a6Ljm a_a6LlC) ->
        case (foldMap
                @ f_a6Ljm
                $dFoldable_a6Ljn
                @ (Min a_a6LlC)
                @ a_a6LlC
                $dMonoid_s6MIU
                ((GHC.Base.Just @ a_a6LlC)
                 `cast` (<a_a6LlC>_R
                         ->_R Sym (Data.Functor.Utils.N:Min[0]) <a_a6LlC>_N
                         :: (a_a6LlC -> Maybe a_a6LlC :: *)
                            ~R# (a_a6LlC -> Min a_a6LlC :: *)))
                (x_X6HLQ
                 `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <a_a6LlC>_N
                         :: (Rec1 f_a6Ljm a_a6LlC :: *) ~R# (f_a6Ljm a_a6LlC :: *))))
             `cast` (Data.Functor.Utils.N:Min[0] <a_a6LlC>_N
                     :: (Min a_a6LlC :: *) ~R# (Maybe a_a6LlC :: *))
        of {
          Nothing -> Data.Foldable.$fFoldable:*:2 @ a_a6LlC;
          Just v_i6M0Z -> v_i6M0Z
        }

-- RHS size: {terms: 18, types: 28, coercions: 12, joins: 0/1}
Data.Foldable.$fFoldableRec1_$cmaximum
  :: forall (f :: * -> *).
     Foldable f =>
     forall a. Ord a => Rec1 f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 110 60}]
Data.Foldable.$fFoldableRec1_$cmaximum
  = \ (@ (f_a6Ljm :: * -> *))
      ($dFoldable_a6Ljn :: Foldable f_a6Ljm)
      (@ a_a6Lls)
      ($dOrd_a6Llu :: Ord a_a6Lls) ->
      let {
        $dMonoid_s6MIQ :: Monoid (Max a_a6Lls)
        [LclId]
        $dMonoid_s6MIQ
          = Data.Functor.Utils.$fMonoidMax @ a_a6Lls $dOrd_a6Llu } in
      \ (x_X6HLR :: Rec1 f_a6Ljm a_a6Lls) ->
        case (foldMap
                @ f_a6Ljm
                $dFoldable_a6Ljn
                @ (Max a_a6Lls)
                @ a_a6Lls
                $dMonoid_s6MIQ
                ((GHC.Base.Just @ a_a6Lls)
                 `cast` (<a_a6Lls>_R
                         ->_R Sym (Data.Functor.Utils.N:Max[0]) <a_a6Lls>_N
                         :: (a_a6Lls -> Maybe a_a6Lls :: *)
                            ~R# (a_a6Lls -> Max a_a6Lls :: *)))
                (x_X6HLR
                 `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <a_a6Lls>_N
                         :: (Rec1 f_a6Ljm a_a6Lls :: *) ~R# (f_a6Ljm a_a6Lls :: *))))
             `cast` (Data.Functor.Utils.N:Max[0] <a_a6Lls>_N
                     :: (Max a_a6Lls :: *) ~R# (Maybe a_a6Lls :: *))
        of {
          Nothing -> Data.Foldable.$fFoldable:*:3 @ a_a6Lls;
          Just v_i6M0Z -> v_i6M0Z
        }

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:.:3 :: forall a. a
[GblId, Str=x]
Data.Foldable.$fFoldable:.:3
  = \ (@ a_a6LkD) ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6LkD Data.Foldable.$fFoldableK8

-- RHS size: {terms: 25, types: 32, coercions: 5, joins: 0/0}
Data.Foldable.$fFoldableRec1_$cfoldr1
  :: forall (f :: * -> *).
     Foldable f =>
     forall a. (a -> a -> a) -> Rec1 f a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 60 0] 150 0}]
Data.Foldable.$fFoldableRec1_$cfoldr1
  = \ (@ (f_a6Ljm :: * -> *))
      ($dFoldable_a6Ljn :: Foldable f_a6Ljm)
      (@ a_a6LkD)
      (f1_a6K7J :: a_a6LkD -> a_a6LkD -> a_a6LkD)
      (xs_a6K7K :: Rec1 f_a6Ljm a_a6LkD) ->
      case foldr
             @ f_a6Ljm
             $dFoldable_a6Ljn
             @ a_a6LkD
             @ (Maybe a_a6LkD)
             (\ (x_a6K7M :: a_a6LkD) (m_a6K7N :: Maybe a_a6LkD) ->
                GHC.Base.Just
                  @ a_a6LkD
                  (case m_a6K7N of {
                     Nothing -> x_a6K7M;
                     Just y_a6K7O -> f1_a6K7J x_a6K7M y_a6K7O
                   }))
             (GHC.Base.Nothing @ a_a6LkD)
             (xs_a6K7K
              `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <a_a6LkD>_N
                      :: (Rec1 f_a6Ljm a_a6LkD :: *) ~R# (f_a6Ljm a_a6LkD :: *)))
      of {
        Nothing -> Data.Foldable.$fFoldable:.:3 @ a_a6LkD;
        Just v_i6M0Z -> v_i6M0Z
      }

-- RHS size: {terms: 22, types: 29, coercions: 5, joins: 0/0}
Data.Foldable.$fFoldableRec1_$cfoldl'
  :: forall (f :: * -> *).
     Foldable f =>
     forall b a. (b -> a -> b) -> b -> Rec1 f a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 0 0] 150 0}]
Data.Foldable.$fFoldableRec1_$cfoldl'
  = \ (@ (f_a6Ljm :: * -> *))
      ($dFoldable_a6Ljn :: Foldable f_a6Ljm)
      (@ b_a6Lkt)
      (@ a_a6Lku)
      (f1_a6K7C :: b_a6Lkt -> a_a6Lku -> b_a6Lkt)
      (z0_a6K7D :: b_a6Lkt)
      (xs_a6K7E :: Rec1 f_a6Ljm a_a6Lku) ->
      foldr
        @ f_a6Ljm
        $dFoldable_a6Ljn
        @ a_a6Lku
        @ (b_a6Lkt -> b_a6Lkt)
        (\ (x_a6K7G :: a_a6Lku)
           (k_a6K7H :: b_a6Lkt -> b_a6Lkt)
           (z_a6K7I :: b_a6Lkt) ->
           case f1_a6K7C z_a6K7I x_a6K7G of vx_i6M0K { __DEFAULT ->
           k_a6K7H vx_i6M0K
           })
        (id @ b_a6Lkt)
        (xs_a6K7E
         `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <a_a6Lku>_N
                 :: (Rec1 f_a6Ljm a_a6Lku :: *) ~R# (f_a6Ljm a_a6Lku :: *)))
        z0_a6K7D

-- RHS size: {terms: 10, types: 19, coercions: 5, joins: 0/0}
Data.Foldable.$fFoldableRec1_$clength
  :: forall (f :: * -> *). Foldable f => forall a. Rec1 f a -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6Ljm :: * -> *))
                 ($dFoldable_a6Ljn [Occ=Once] :: Foldable f_a6Ljm)
                 (@ a_a6Lla)
                 (eta_B1 [Occ=Once] :: Rec1 f_a6Ljm a_a6Lla) ->
                 foldr
                   @ f_a6Ljm
                   $dFoldable_a6Ljn
                   @ a_a6Lla
                   @ (Int -> Int)
                   (Data.Foldable.$fFoldableM2 @ a_a6Lla)
                   (id @ Int)
                   (eta_B1
                    `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <a_a6Lla>_N
                            :: (Rec1 f_a6Ljm a_a6Lla :: *) ~R# (f_a6Ljm a_a6Lla :: *)))
                   Data.Foldable.$fFoldable:*:4}]
Data.Foldable.$fFoldableRec1_$clength
  = \ (@ (f_a6Ljm :: * -> *))
      ($dFoldable_a6Ljn :: Foldable f_a6Ljm)
      (@ a_a6Lla)
      (eta_B1 :: Rec1 f_a6Ljm a_a6Lla) ->
      foldr
        @ f_a6Ljm
        $dFoldable_a6Ljn
        @ a_a6Lla
        @ (Int -> Int)
        (Data.Foldable.$fFoldableM2 @ a_a6Lla)
        (id @ Int)
        (eta_B1
         `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <a_a6Lla>_N
                 :: (Rec1 f_a6Ljm a_a6Lla :: *) ~R# (f_a6Ljm a_a6Lla :: *)))
        Data.Foldable.$fFoldable:*:4

-- RHS size: {terms: 17, types: 27, coercions: 14, joins: 0/0}
Data.Foldable.$fFoldableRec1_$cfoldl
  :: forall (f :: * -> *).
     Foldable f =>
     forall b a. (b -> a -> b) -> b -> Rec1 f a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6Ljm :: * -> *))
                 ($dFoldable_a6Ljn [Occ=Once] :: Foldable f_a6Ljm)
                 (@ b_a6Lkj)
                 (@ a_a6Lkk)
                 (f1_a6K7z [Occ=OnceL!] :: b_a6Lkj -> a_a6Lkk -> b_a6Lkj)
                 (z_a6K7A [Occ=Once] :: b_a6Lkj)
                 (t_a6K7B [Occ=Once] :: Rec1 f_a6Ljm a_a6Lkk) ->
                 ((foldMap
                     @ f_a6Ljm
                     $dFoldable_a6Ljn
                     @ (Dual (Endo b_a6Lkj))
                     @ a_a6Lkk
                     (Data.Foldable.$fFoldable:*:7 @ b_a6Lkj)
                     ((\ (x_X6HLX [Occ=Once] :: a_a6Lkk)
                         (y_i6M0a [Occ=Once] :: b_a6Lkj) ->
                         f1_a6K7z y_i6M0a x_X6HLX)
                      `cast` (<a_a6Lkk>_R
                              ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                            (Data.Semigroup.Internal.N:Endo[0] <b_a6Lkj>_R))
                              :: (a_a6Lkk -> b_a6Lkj -> b_a6Lkj :: *)
                                 ~R# (a_a6Lkk -> Dual (Endo b_a6Lkj) :: *)))
                     (t_a6K7B
                      `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <a_a6Lkk>_N
                              :: (Rec1 f_a6Ljm a_a6Lkk :: *) ~R# (f_a6Ljm a_a6Lkk :: *))))
                  `cast` (Data.Semigroup.Internal.N:Dual[0]
                              (Data.Semigroup.Internal.N:Endo[0] <b_a6Lkj>_R)
                          :: (Dual (Endo b_a6Lkj) :: *) ~R# (b_a6Lkj -> b_a6Lkj :: *)))
                   z_a6K7A}]
Data.Foldable.$fFoldableRec1_$cfoldl
  = \ (@ (f_a6Ljm :: * -> *))
      ($dFoldable_a6Ljn :: Foldable f_a6Ljm)
      (@ b_a6Lkj)
      (@ a_a6Lkk)
      (f1_a6K7z :: b_a6Lkj -> a_a6Lkk -> b_a6Lkj)
      (z_a6K7A :: b_a6Lkj)
      (t_a6K7B :: Rec1 f_a6Ljm a_a6Lkk) ->
      ((foldMap
          @ f_a6Ljm
          $dFoldable_a6Ljn
          @ (Dual (Endo b_a6Lkj))
          @ a_a6Lkk
          (Data.Foldable.$fFoldable:*:7 @ b_a6Lkj)
          ((\ (x_X6HLX :: a_a6Lkk) (y_i6M0a :: b_a6Lkj) ->
              f1_a6K7z y_i6M0a x_X6HLX)
           `cast` (<a_a6Lkk>_R
                   ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                 (Data.Semigroup.Internal.N:Endo[0] <b_a6Lkj>_R))
                   :: (a_a6Lkk -> b_a6Lkj -> b_a6Lkj :: *)
                      ~R# (a_a6Lkk -> Dual (Endo b_a6Lkj) :: *)))
          (t_a6K7B
           `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <a_a6Lkk>_N
                   :: (Rec1 f_a6Ljm a_a6Lkk :: *) ~R# (f_a6Ljm a_a6Lkk :: *))))
       `cast` (Data.Semigroup.Internal.N:Dual[0]
                   (Data.Semigroup.Internal.N:Endo[0] <b_a6Lkj>_R)
               :: (Dual (Endo b_a6Lkj) :: *) ~R# (b_a6Lkj -> b_a6Lkj :: *)))
        z_a6K7A

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:.:2 :: forall a. a
[GblId, Str=x]
Data.Foldable.$fFoldable:.:2
  = \ (@ a_a6LkL) ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6LkL Data.Foldable.$fFoldableK6

-- RHS size: {terms: 26, types: 35, coercions: 16, joins: 0/0}
Data.Foldable.$fFoldableRec1_$cfoldl1
  :: forall (f :: * -> *).
     Foldable f =>
     forall a. (a -> a -> a) -> Rec1 f a -> a
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 60 0] 160 0}]
Data.Foldable.$fFoldableRec1_$cfoldl1
  = \ (@ (f_a6Ljm :: * -> *))
      ($dFoldable_a6Ljn :: Foldable f_a6Ljm)
      (@ a_a6LkL)
      (f1_a6K7P :: a_a6LkL -> a_a6LkL -> a_a6LkL)
      (xs_a6K7Q :: Rec1 f_a6Ljm a_a6LkL) ->
      case ((foldMap
               @ f_a6Ljm
               $dFoldable_a6Ljn
               @ (Dual (Endo (Maybe a_a6LkL)))
               @ a_a6LkL
               (Data.Foldable.$fFoldableM3 @ a_a6LkL)
               ((\ (x_X6HLX :: a_a6LkL) (y_i6M0a :: Maybe a_a6LkL) ->
                   GHC.Base.Just
                     @ a_a6LkL
                     (case y_i6M0a of {
                        Nothing -> x_X6HLX;
                        Just x1_a6K7U -> f1_a6K7P x1_a6K7U x_X6HLX
                      }))
                `cast` (<a_a6LkL>_R
                        ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                      (Data.Semigroup.Internal.N:Endo[0] <Maybe a_a6LkL>_R))
                        :: (a_a6LkL -> Maybe a_a6LkL -> Maybe a_a6LkL :: *)
                           ~R# (a_a6LkL -> Dual (Endo (Maybe a_a6LkL)) :: *)))
               (xs_a6K7Q
                `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <a_a6LkL>_N
                        :: (Rec1 f_a6Ljm a_a6LkL :: *) ~R# (f_a6Ljm a_a6LkL :: *))))
            `cast` (Data.Semigroup.Internal.N:Dual[0]
                        (Data.Semigroup.Internal.N:Endo[0] <Maybe a_a6LkL>_R)
                    :: (Dual (Endo (Maybe a_a6LkL)) :: *)
                       ~R# (Maybe a_a6LkL -> Maybe a_a6LkL :: *)))
             (GHC.Base.Nothing @ a_a6LkL)
      of {
        Nothing -> Data.Foldable.$fFoldable:.:2 @ a_a6LkL;
        Just v_i6M0Z -> v_i6M0Z
      }

-- RHS size: {terms: 23, types: 32, coercions: 16, joins: 0/0}
Data.Foldable.$fFoldableRec1_$cfoldr'
  :: forall (f :: * -> *).
     Foldable f =>
     forall a b. (a -> b -> b) -> b -> Rec1 f a -> b
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 0 0] 160 0}]
Data.Foldable.$fFoldableRec1_$cfoldr'
  = \ (@ (f_a6Ljm :: * -> *))
      ($dFoldable_a6Ljn :: Foldable f_a6Ljm)
      (@ a_a6Lk9)
      (@ b_a6Lka)
      (f1_a6K7s :: a_a6Lk9 -> b_a6Lka -> b_a6Lka)
      (z0_a6K7t :: b_a6Lka)
      (xs_a6K7u :: Rec1 f_a6Ljm a_a6Lk9) ->
      ((foldMap
          @ f_a6Ljm
          $dFoldable_a6Ljn
          @ (Dual (Endo (b_a6Lka -> b_a6Lka)))
          @ a_a6Lk9
          (Data.Foldable.$fFoldableM4 @ b_a6Lka)
          ((\ (x_X6HLX :: a_a6Lk9)
              (y_i6M0a :: b_a6Lka -> b_a6Lka)
              (z_a6K7y :: b_a6Lka) ->
              case f1_a6K7s x_X6HLX z_a6K7y of vx_i6M0K { __DEFAULT ->
              y_i6M0a vx_i6M0K
              })
           `cast` (<a_a6Lk9>_R
                   ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                 (Data.Semigroup.Internal.N:Endo[0] <b_a6Lka -> b_a6Lka>_R))
                   :: (a_a6Lk9 -> (b_a6Lka -> b_a6Lka) -> b_a6Lka -> b_a6Lka :: *)
                      ~R# (a_a6Lk9 -> Dual (Endo (b_a6Lka -> b_a6Lka)) :: *)))
          (xs_a6K7u
           `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <a_a6Lk9>_N
                   :: (Rec1 f_a6Ljm a_a6Lk9 :: *) ~R# (f_a6Ljm a_a6Lk9 :: *))))
       `cast` (Data.Semigroup.Internal.N:Dual[0]
                   (Data.Semigroup.Internal.N:Endo[0] <b_a6Lka -> b_a6Lka>_R)
               :: (Dual (Endo (b_a6Lka -> b_a6Lka)) :: *)
                  ~R# ((b_a6Lka -> b_a6Lka) -> b_a6Lka -> b_a6Lka :: *)))
        (id @ b_a6Lka) z0_a6K7t

-- RHS size: {terms: 10, types: 19, coercions: 5, joins: 0/0}
Data.Foldable.$fFoldableRec1_$cfold
  :: forall (f :: * -> *).
     Foldable f =>
     forall m. Monoid m => Rec1 f m -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6Ljm :: * -> *))
                 ($dFoldable_a6Ljn [Occ=Once] :: Foldable f_a6Ljm)
                 (@ m_a6Ljr)
                 ($dMonoid_a6Ljt [Occ=Once] :: Monoid m_a6Ljr)
                 (ds_d6M2Q [Occ=Once] :: Rec1 f_a6Ljm m_a6Ljr) ->
                 foldMap
                   @ f_a6Ljm
                   $dFoldable_a6Ljn
                   @ m_a6Ljr
                   @ m_a6Ljr
                   $dMonoid_a6Ljt
                   (id @ m_a6Ljr)
                   (ds_d6M2Q
                    `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <m_a6Ljr>_N
                            :: (Rec1 f_a6Ljm m_a6Ljr :: *) ~R# (f_a6Ljm m_a6Ljr :: *)))}]
Data.Foldable.$fFoldableRec1_$cfold
  = \ (@ (f_a6Ljm :: * -> *))
      ($dFoldable_a6Ljn :: Foldable f_a6Ljm)
      (@ m_a6Ljr)
      ($dMonoid_a6Ljt :: Monoid m_a6Ljr)
      (ds_d6M2Q :: Rec1 f_a6Ljm m_a6Ljr) ->
      foldMap
        @ f_a6Ljm
        $dFoldable_a6Ljn
        @ m_a6Ljr
        @ m_a6Ljr
        $dMonoid_a6Ljt
        (id @ m_a6Ljr)
        (ds_d6M2Q
         `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <m_a6Ljr>_N
                 :: (Rec1 f_a6Ljm m_a6Ljr :: *) ~R# (f_a6Ljm m_a6Ljr :: *)))

-- RHS size: {terms: 13, types: 24, coercions: 18, joins: 0/1}
Data.Foldable.$fFoldableRec1_$cproduct
  :: forall (f :: * -> *).
     Foldable f =>
     forall a. Num a => Rec1 f a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6Ljm :: * -> *))
                 ($dFoldable_a6Ljn [Occ=OnceL] :: Foldable f_a6Ljm)
                 (@ a_a6LlW)
                 ($dNum_a6LlY [Occ=OnceL] :: Num a_a6LlW) ->
                 let {
                   $dMonoid_s6MIL [Occ=OnceL] :: Monoid (Product a_a6LlW)
                   [LclId]
                   $dMonoid_s6MIL
                     = Data.Semigroup.Internal.$fMonoidProduct
                         @ a_a6LlW $dNum_a6LlY } in
                 (\ (ds_d6M2Q [Occ=Once] :: Rec1 f_a6Ljm a_a6LlW) ->
                    foldMap
                      @ f_a6Ljm
                      $dFoldable_a6Ljn
                      @ (Product a_a6LlW)
                      @ a_a6LlW
                      $dMonoid_s6MIL
                      ((Data.Foldable.$fFoldable:*:1 @ a_a6LlW)
                       `cast` (<a_a6LlW>_R
                               ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LlW>_R)
                               :: (a_a6LlW -> a_a6LlW :: *)
                                  ~R# (a_a6LlW -> Product a_a6LlW :: *)))
                      (ds_d6M2Q
                       `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <a_a6LlW>_N
                               :: (Rec1 f_a6Ljm a_a6LlW :: *) ~R# (f_a6Ljm a_a6LlW :: *))))
                 `cast` (<Rec1 f_a6Ljm a_a6LlW>_R
                         ->_R Data.Semigroup.Internal.N:Product[0] <a_a6LlW>_R
                         :: (Rec1 f_a6Ljm a_a6LlW -> Product a_a6LlW :: *)
                            ~R# (Rec1 f_a6Ljm a_a6LlW -> a_a6LlW :: *))}]
Data.Foldable.$fFoldableRec1_$cproduct
  = \ (@ (f_a6Ljm :: * -> *))
      ($dFoldable_a6Ljn :: Foldable f_a6Ljm)
      (@ a_a6LlW)
      ($dNum_a6LlY :: Num a_a6LlW) ->
      let {
        $dMonoid_s6MIL :: Monoid (Product a_a6LlW)
        [LclId]
        $dMonoid_s6MIL
          = Data.Semigroup.Internal.$fMonoidProduct
              @ a_a6LlW $dNum_a6LlY } in
      (\ (ds_d6M2Q :: Rec1 f_a6Ljm a_a6LlW) ->
         foldMap
           @ f_a6Ljm
           $dFoldable_a6Ljn
           @ (Product a_a6LlW)
           @ a_a6LlW
           $dMonoid_s6MIL
           ((Data.Foldable.$fFoldable:*:1 @ a_a6LlW)
            `cast` (<a_a6LlW>_R
                    ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LlW>_R)
                    :: (a_a6LlW -> a_a6LlW :: *)
                       ~R# (a_a6LlW -> Product a_a6LlW :: *)))
           (ds_d6M2Q
            `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <a_a6LlW>_N
                    :: (Rec1 f_a6Ljm a_a6LlW :: *) ~R# (f_a6Ljm a_a6LlW :: *))))
      `cast` (<Rec1 f_a6Ljm a_a6LlW>_R
              ->_R Data.Semigroup.Internal.N:Product[0] <a_a6LlW>_R
              :: (Rec1 f_a6Ljm a_a6LlW -> Product a_a6LlW :: *)
                 ~R# (Rec1 f_a6Ljm a_a6LlW -> a_a6LlW :: *))

-- RHS size: {terms: 9, types: 19, coercions: 5, joins: 0/0}
Data.Foldable.$fFoldableRec1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *). Foldable f => forall a. Rec1 f a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_a6Ljm :: * -> *))
                 ($dFoldable_a6Ljn [Occ=Once] :: Foldable f_a6Ljm)
                 (@ a_a6LkT)
                 (t_a6K7V [Occ=Once] :: Rec1 f_a6Ljm a_a6LkT) ->
                 build
                   @ a_a6LkT
                   (\ (@ b_a6KNB)
                      (c_a6K7W [Occ=Once, OS=OneShot] :: a_a6LkT -> b_a6KNB -> b_a6KNB)
                      (n_a6K7X [Occ=Once, OS=OneShot] :: b_a6KNB) ->
                      foldr
                        @ f_a6Ljm
                        $dFoldable_a6Ljn
                        @ a_a6LkT
                        @ b_a6KNB
                        c_a6K7W
                        n_a6K7X
                        (t_a6K7V
                         `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <a_a6LkT>_N
                                 :: (Rec1 f_a6Ljm a_a6LkT :: *) ~R# (f_a6Ljm a_a6LkT :: *))))}]
Data.Foldable.$fFoldableRec1_$ctoList
  = \ (@ (f_a6Ljm :: * -> *))
      ($dFoldable_a6Ljn :: Foldable f_a6Ljm)
      (@ a_a6LkT)
      (eta_Xf9 :: Rec1 f_a6Ljm a_a6LkT) ->
      foldr
        @ f_a6Ljm
        $dFoldable_a6Ljn
        @ a_a6LkT
        @ [a_a6LkT]
        (GHC.Types.: @ a_a6LkT)
        (GHC.Types.[] @ a_a6LkT)
        (eta_Xf9
         `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <a_a6LkT>_N
                 :: (Rec1 f_a6Ljm a_a6LkT :: *) ~R# (f_a6Ljm a_a6LkT :: *)))

-- RHS size: {terms: 54, types: 64, coercions: 15, joins: 0/0}
Data.Foldable.$fFoldableRec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *). Foldable f => Foldable (Rec1 f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>,
 Unf=DFun: \ (@ (f_a6KaF :: * -> *)) (v_Xf8 :: Foldable f_a6KaF) ->
       Data.Foldable.C:Foldable TYPE: Rec1 f_a6KaF
                                Data.Foldable.$fFoldableRec1_$cfold @ f_a6KaF v_Xf8
                                \ (@ m_a6LjB)
                                  (@ a_a6LjC)
                                  ($dMonoid_a6LjE [Occ=Once] :: Monoid m_a6LjB)
                                  (f1_a6Kqo [Occ=Once] :: a_a6LjC -> m_a6LjB)
                                  (ds_d6M2Q [Occ=Once] :: Rec1 f_a6KaF a_a6LjC) ->
                                  foldMap
                                    @ f_a6KaF
                                    v_Xf8
                                    @ m_a6LjB
                                    @ a_a6LjC
                                    $dMonoid_a6LjE
                                    f1_a6Kqo
                                    (ds_d6M2Q
                                     `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6KaF>_R <a_a6LjC>_N
                                             :: (Rec1 f_a6KaF a_a6LjC :: *)
                                                ~R# (f_a6KaF a_a6LjC :: *)))
                                \ (@ a_a6LjO)
                                  (@ b_a6LjP)
                                  (f1_a6Kqj [Occ=Once] :: a_a6LjO -> b_a6LjP -> b_a6LjP)
                                  (z_a6Kqk [Occ=Once] :: b_a6LjP)
                                  (ds_d6M2R [Occ=Once] :: Rec1 f_a6KaF a_a6LjO) ->
                                  foldr
                                    @ f_a6KaF
                                    v_Xf8
                                    @ a_a6LjO
                                    @ b_a6LjP
                                    f1_a6Kqj
                                    z_a6Kqk
                                    (ds_d6M2R
                                     `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6KaF>_R <a_a6LjO>_N
                                             :: (Rec1 f_a6KaF a_a6LjO :: *)
                                                ~R# (f_a6KaF a_a6LjO :: *)))
                                Data.Foldable.$fFoldableRec1_$cfoldr' @ f_a6KaF v_Xf8
                                Data.Foldable.$fFoldableRec1_$cfoldl @ f_a6KaF v_Xf8
                                Data.Foldable.$fFoldableRec1_$cfoldl' @ f_a6KaF v_Xf8
                                Data.Foldable.$fFoldableRec1_$cfoldr1 @ f_a6KaF v_Xf8
                                Data.Foldable.$fFoldableRec1_$cfoldl1 @ f_a6KaF v_Xf8
                                Data.Foldable.$fFoldableRec1_$ctoList @ f_a6KaF v_Xf8
                                \ (@ a_a6Ll1) (ds_d6M2S [Occ=Once] :: Rec1 f_a6KaF a_a6Ll1) ->
                                  null
                                    @ f_a6KaF
                                    v_Xf8
                                    @ a_a6Ll1
                                    (ds_d6M2S
                                     `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6KaF>_R <a_a6Ll1>_N
                                             :: (Rec1 f_a6KaF a_a6Ll1 :: *)
                                                ~R# (f_a6KaF a_a6Ll1 :: *)))
                                Data.Foldable.$fFoldableRec1_$clength @ f_a6KaF v_Xf8
                                Data.Foldable.$fFoldableRec1_$celem @ f_a6KaF v_Xf8
                                Data.Foldable.$fFoldableRec1_$cmaximum @ f_a6KaF v_Xf8
                                Data.Foldable.$fFoldableRec1_$cminimum @ f_a6KaF v_Xf8
                                Data.Foldable.$fFoldableRec1_$csum @ f_a6KaF v_Xf8
                                Data.Foldable.$fFoldableRec1_$cproduct @ f_a6KaF v_Xf8]
Data.Foldable.$fFoldableRec1
  = \ (@ (f_a6Ljm :: * -> *))
      ($dFoldable_a6Ljn :: Foldable f_a6Ljm) ->
      Data.Foldable.C:Foldable
        @ (Rec1 f_a6Ljm)
        (Data.Foldable.$fFoldableRec1_$cfold @ f_a6Ljm $dFoldable_a6Ljn)
        (\ (@ m_a6LjB)
           (@ a_a6LjC)
           ($dMonoid_a6LjE :: Monoid m_a6LjB)
           (f1_a6Kqo :: a_a6LjC -> m_a6LjB)
           (ds_d6M2Q :: Rec1 f_a6Ljm a_a6LjC) ->
           foldMap
             @ f_a6Ljm
             $dFoldable_a6Ljn
             @ m_a6LjB
             @ a_a6LjC
             $dMonoid_a6LjE
             f1_a6Kqo
             (ds_d6M2Q
              `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <a_a6LjC>_N
                      :: (Rec1 f_a6Ljm a_a6LjC :: *) ~R# (f_a6Ljm a_a6LjC :: *))))
        (\ (@ a_a6LjO)
           (@ b_a6LjP)
           (f1_a6Kqj :: a_a6LjO -> b_a6LjP -> b_a6LjP)
           (z_a6Kqk :: b_a6LjP)
           (ds_d6M2R :: Rec1 f_a6Ljm a_a6LjO) ->
           foldr
             @ f_a6Ljm
             $dFoldable_a6Ljn
             @ a_a6LjO
             @ b_a6LjP
             f1_a6Kqj
             z_a6Kqk
             (ds_d6M2R
              `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <a_a6LjO>_N
                      :: (Rec1 f_a6Ljm a_a6LjO :: *) ~R# (f_a6Ljm a_a6LjO :: *))))
        (Data.Foldable.$fFoldableRec1_$cfoldr' @ f_a6Ljm $dFoldable_a6Ljn)
        (Data.Foldable.$fFoldableRec1_$cfoldl @ f_a6Ljm $dFoldable_a6Ljn)
        (Data.Foldable.$fFoldableRec1_$cfoldl' @ f_a6Ljm $dFoldable_a6Ljn)
        (Data.Foldable.$fFoldableRec1_$cfoldr1 @ f_a6Ljm $dFoldable_a6Ljn)
        (Data.Foldable.$fFoldableRec1_$cfoldl1 @ f_a6Ljm $dFoldable_a6Ljn)
        (Data.Foldable.$fFoldableRec1_$ctoList @ f_a6Ljm $dFoldable_a6Ljn)
        (\ (@ a_a6Ll1) (ds_d6M2S :: Rec1 f_a6Ljm a_a6Ll1) ->
           null
             @ f_a6Ljm
             $dFoldable_a6Ljn
             @ a_a6Ll1
             (ds_d6M2S
              `cast` (GHC.Generics.N:Rec1[0] <*>_N <f_a6Ljm>_R <a_a6Ll1>_N
                      :: (Rec1 f_a6Ljm a_a6Ll1 :: *) ~R# (f_a6Ljm a_a6Ll1 :: *))))
        (Data.Foldable.$fFoldableRec1_$clength @ f_a6Ljm $dFoldable_a6Ljn)
        (Data.Foldable.$fFoldableRec1_$celem @ f_a6Ljm $dFoldable_a6Ljn)
        (Data.Foldable.$fFoldableRec1_$cmaximum @ f_a6Ljm $dFoldable_a6Ljn)
        (Data.Foldable.$fFoldableRec1_$cminimum @ f_a6Ljm $dFoldable_a6Ljn)
        (Data.Foldable.$fFoldableRec1_$csum @ f_a6Ljm $dFoldable_a6Ljn)
        (Data.Foldable.$fFoldableRec1_$cproduct @ f_a6Ljm $dFoldable_a6Ljn)

-- RHS size: {terms: 10, types: 10, coercions: 2, joins: 0/1}
Data.Foldable.$fFoldablePar1_$celem
  :: forall a. Eq a => a -> Par1 a -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LnB)
                 ($dEq_a6LnD [Occ=Once] :: Eq a_a6LnB)
                 (eta_Xfa [Occ=Once] :: a_a6LnB) ->
                 let {
                   f_s6MIH [Occ=OnceL!] :: a_a6LnB -> Bool
                   [LclId]
                   f_s6MIH = == @ a_a6LnB $dEq_a6LnD eta_Xfa } in
                 \ (ds_d6M2T [Occ=Once] :: Par1 a_a6LnB) ->
                   f_s6MIH
                     (ds_d6M2T
                      `cast` (GHC.Generics.N:Par1[0] <a_a6LnB>_R
                              :: (Par1 a_a6LnB :: *) ~R# (a_a6LnB :: *)))}]
Data.Foldable.$fFoldablePar1_$celem
  = \ (@ a_a6LnB) ($dEq_a6LnD :: Eq a_a6LnB) (eta_Xfa :: a_a6LnB) ->
      let {
        f_s6MIH [Dmd=<L,C(U)>] :: a_a6LnB -> Bool
        [LclId]
        f_s6MIH = == @ a_a6LnB $dEq_a6LnD eta_Xfa } in
      \ (ds_d6M2T :: Par1 a_a6LnB) ->
        f_s6MIH
          (ds_d6M2T
           `cast` (GHC.Generics.N:Par1[0] <a_a6LnB>_R
                   :: (Par1 a_a6LnB :: *) ~R# (a_a6LnB :: *)))

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldablePar2 :: forall a. Num a => Par1 a -> Par1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Lo5)
                 _ [Occ=Dead]
                 (eta_Xfb [Occ=Once] :: Par1 a_a6Lo5) ->
                 eta_Xfb}]
Data.Foldable.$fFoldablePar2
  = \ (@ a_a6Lo5) _ [Occ=Dead] (eta_Xfb :: Par1 a_a6Lo5) -> eta_Xfb

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldablePar3 :: forall a. Ord a => Par1 a -> Par1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LnV)
                 _ [Occ=Dead]
                 (x_X6HLQ [Occ=Once] :: Par1 a_a6LnV) ->
                 x_X6HLQ}]
Data.Foldable.$fFoldablePar3
  = \ (@ a_a6LnV) _ [Occ=Dead] (x_X6HLQ :: Par1 a_a6LnV) -> x_X6HLQ

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldablePar4
  :: forall a. (a -> a -> a) -> Par1 a -> Par1 a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Ln0)
                 _ [Occ=Dead]
                 (xs_X6KnB [Occ=Once] :: Par1 a_a6Ln0) ->
                 xs_X6KnB}]
Data.Foldable.$fFoldablePar4
  = \ (@ a_a6Ln0) _ [Occ=Dead] (xs_X6KnB :: Par1 a_a6Ln0) -> xs_X6KnB

-- RHS size: {terms: 8, types: 10, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldablePar1_$cfoldl'
  :: forall b a. (b -> a -> b) -> b -> Par1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_a6LmQ)
                 (@ a_a6LmR)
                 (f_a6K7C [Occ=Once!] :: b_a6LmQ -> a_a6LmR -> b_a6LmQ)
                 (z0_a6K7D [Occ=Once] :: b_a6LmQ)
                 (xs_a6K7E [Occ=Once] :: Par1 a_a6LmR) ->
                 f_a6K7C
                   z0_a6K7D
                   (xs_a6K7E
                    `cast` (GHC.Generics.N:Par1[0] <a_a6LmR>_R
                            :: (Par1 a_a6LmR :: *) ~R# (a_a6LmR :: *)))}]
Data.Foldable.$fFoldablePar1_$cfoldl'
  = \ (@ b_a6LmQ)
      (@ a_a6LmR)
      (f_a6K7C :: b_a6LmQ -> a_a6LmR -> b_a6LmQ)
      (z0_a6K7D :: b_a6LmQ)
      (xs_a6K7E :: Par1 a_a6LmR) ->
      f_a6K7C
        z0_a6K7D
        (xs_a6K7E
         `cast` (GHC.Generics.N:Par1[0] <a_a6LmR>_R
                 :: (Par1 a_a6LmR :: *) ~R# (a_a6LmR :: *)))

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldablePar1_$clength :: forall a. Par1 a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Lnt) _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3}]
Data.Foldable.$fFoldablePar1_$clength
  = \ (@ a_a6Lnt) _ [Occ=Dead] -> Data.Foldable.$fFoldableDual3

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldablePar5
  :: forall m. Monoid m => Par1 m -> Par1 m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ m_a6Lm8)
                 _ [Occ=Dead]
                 (ds_d6M2T [Occ=Once] :: Par1 m_a6Lm8) ->
                 ds_d6M2T}]
Data.Foldable.$fFoldablePar5
  = \ (@ m_a6Lm8) _ [Occ=Dead] (ds_d6M2T :: Par1 m_a6Lm8) -> ds_d6M2T

-- RHS size: {terms: 5, types: 6, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldablePar1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Par1 a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a6Lng) (t_a6K7V [Occ=Once] :: Par1 a_a6Lng) ->
                 build
                   @ a_a6Lng
                   (\ (@ b_a6KNB)
                      (c_a6K7W [Occ=Once!, OS=OneShot] :: a_a6Lng -> b_a6KNB -> b_a6KNB)
                      (n_a6K7X [Occ=Once, OS=OneShot] :: b_a6KNB) ->
                      c_a6K7W
                        (t_a6K7V
                         `cast` (GHC.Generics.N:Par1[0] <a_a6Lng>_R
                                 :: (Par1 a_a6Lng :: *) ~R# (a_a6Lng :: *)))
                        n_a6K7X)}]
Data.Foldable.$fFoldablePar1_$ctoList
  = \ (@ a_a6Lng) (eta_XfH :: Par1 a_a6Lng) ->
      GHC.Types.:
        @ a_a6Lng
        (eta_XfH
         `cast` (GHC.Generics.N:Par1[0] <a_a6Lng>_R
                 :: (Par1 a_a6Lng :: *) ~R# (a_a6Lng :: *)))
        (GHC.Types.[] @ a_a6Lng)

-- RHS size: {terms: 17, types: 1, coercions: 79, joins: 0/0}
Data.Foldable.$fFoldablePar1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable Par1
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: Par1
                                Data.Foldable.$fFoldablePar5
                                `cast` (forall (m :: <*>_N).
                                        <Monoid m>_R
                                        ->_R <Par1 m>_R
                                        ->_R GHC.Generics.N:Par1[0] <m>_R
                                        :: (forall m. Monoid m => Par1 m -> Par1 m :: *)
                                           ~R# (forall m. Monoid m => Par1 m -> m :: *))
                                Data.Foldable.$fFoldablePar1_$cfoldMap
                                Data.Foldable.$fFoldablePar1_$cfoldr
                                Data.Foldable.$fFoldablePar1_$cfoldr
                                Data.Foldable.$fFoldablePar1_$cfoldl'
                                Data.Foldable.$fFoldablePar1_$cfoldl'
                                Data.Foldable.$fFoldablePar4
                                `cast` (forall (a :: <*>_N).
                                        <a -> a -> a>_R
                                        ->_R <Par1 a>_R
                                        ->_R GHC.Generics.N:Par1[0] <a>_R
                                        :: (forall a. (a -> a -> a) -> Par1 a -> Par1 a :: *)
                                           ~R# (forall a. (a -> a -> a) -> Par1 a -> a :: *))
                                Data.Foldable.$fFoldablePar4
                                `cast` (forall (a :: <*>_N).
                                        <a -> a -> a>_R
                                        ->_R <Par1 a>_R
                                        ->_R GHC.Generics.N:Par1[0] <a>_R
                                        :: (forall a. (a -> a -> a) -> Par1 a -> Par1 a :: *)
                                           ~R# (forall a. (a -> a -> a) -> Par1 a -> a :: *))
                                Data.Foldable.$fFoldablePar1_$ctoList
                                Data.Foldable.$fFoldablePar1_$cnull
                                Data.Foldable.$fFoldablePar1_$clength
                                Data.Foldable.$fFoldablePar1_$celem
                                Data.Foldable.$fFoldablePar3
                                `cast` (forall (a :: <*>_N).
                                        <Ord a>_R ->_R <Par1 a>_R ->_R GHC.Generics.N:Par1[0] <a>_R
                                        :: (forall a. Ord a => Par1 a -> Par1 a :: *)
                                           ~R# (forall a. Ord a => Par1 a -> a :: *))
                                Data.Foldable.$fFoldablePar3
                                `cast` (forall (a :: <*>_N).
                                        <Ord a>_R ->_R <Par1 a>_R ->_R GHC.Generics.N:Par1[0] <a>_R
                                        :: (forall a. Ord a => Par1 a -> Par1 a :: *)
                                           ~R# (forall a. Ord a => Par1 a -> a :: *))
                                Data.Foldable.$fFoldablePar2
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R ->_R <Par1 a>_R ->_R GHC.Generics.N:Par1[0] <a>_R
                                        :: (forall a. Num a => Par1 a -> Par1 a :: *)
                                           ~R# (forall a. Num a => Par1 a -> a :: *))
                                Data.Foldable.$fFoldablePar2
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R ->_R <Par1 a>_R ->_R GHC.Generics.N:Par1[0] <a>_R
                                        :: (forall a. Num a => Par1 a -> Par1 a :: *)
                                           ~R# (forall a. Num a => Par1 a -> a :: *))]
Data.Foldable.$fFoldablePar1
  = Data.Foldable.C:Foldable
      @ Par1
      (Data.Foldable.$fFoldablePar5
       `cast` (forall (m :: <*>_N).
               <Monoid m>_R ->_R <Par1 m>_R ->_R GHC.Generics.N:Par1[0] <m>_R
               :: (forall m. Monoid m => Par1 m -> Par1 m :: *)
                  ~R# (forall m. Monoid m => Par1 m -> m :: *)))
      Data.Foldable.$fFoldablePar1_$cfoldMap
      Data.Foldable.$fFoldablePar1_$cfoldr
      Data.Foldable.$fFoldablePar1_$cfoldr
      Data.Foldable.$fFoldablePar1_$cfoldl'
      Data.Foldable.$fFoldablePar1_$cfoldl'
      (Data.Foldable.$fFoldablePar4
       `cast` (forall (a :: <*>_N).
               <a -> a -> a>_R ->_R <Par1 a>_R ->_R GHC.Generics.N:Par1[0] <a>_R
               :: (forall a. (a -> a -> a) -> Par1 a -> Par1 a :: *)
                  ~R# (forall a. (a -> a -> a) -> Par1 a -> a :: *)))
      (Data.Foldable.$fFoldablePar4
       `cast` (forall (a :: <*>_N).
               <a -> a -> a>_R ->_R <Par1 a>_R ->_R GHC.Generics.N:Par1[0] <a>_R
               :: (forall a. (a -> a -> a) -> Par1 a -> Par1 a :: *)
                  ~R# (forall a. (a -> a -> a) -> Par1 a -> a :: *)))
      Data.Foldable.$fFoldablePar1_$ctoList
      Data.Foldable.$fFoldablePar1_$cnull
      Data.Foldable.$fFoldablePar1_$clength
      Data.Foldable.$fFoldablePar1_$celem
      (Data.Foldable.$fFoldablePar3
       `cast` (forall (a :: <*>_N).
               <Ord a>_R ->_R <Par1 a>_R ->_R GHC.Generics.N:Par1[0] <a>_R
               :: (forall a. Ord a => Par1 a -> Par1 a :: *)
                  ~R# (forall a. Ord a => Par1 a -> a :: *)))
      (Data.Foldable.$fFoldablePar3
       `cast` (forall (a :: <*>_N).
               <Ord a>_R ->_R <Par1 a>_R ->_R GHC.Generics.N:Par1[0] <a>_R
               :: (forall a. Ord a => Par1 a -> Par1 a :: *)
                  ~R# (forall a. Ord a => Par1 a -> a :: *)))
      (Data.Foldable.$fFoldablePar2
       `cast` (forall (a :: <*>_N).
               <Num a>_R ->_R <Par1 a>_R ->_R GHC.Generics.N:Par1[0] <a>_R
               :: (forall a. Num a => Par1 a -> Par1 a :: *)
                  ~R# (forall a. Num a => Par1 a -> a :: *)))
      (Data.Foldable.$fFoldablePar2
       `cast` (forall (a :: <*>_N).
               <Num a>_R ->_R <Par1 a>_R ->_R GHC.Generics.N:Par1[0] <a>_R
               :: (forall a. Num a => Par1 a -> Par1 a :: *)
                  ~R# (forall a. Num a => Par1 a -> a :: *)))

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableV1_$celem
  :: forall a. Eq a => a -> V1 a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Lq3) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Types.False}]
Data.Foldable.$fFoldableV1_$celem
  = \ (@ a_a6Lq3) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
      GHC.Types.False

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableV1_$csum :: forall a. Num a => V1 a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Lqx)
                 ($dNum_a6Lqz [Occ=Once] :: Num a_a6Lqx)
                 _ [Occ=Dead] ->
                 Data.Semigroup.Internal.$fMonoidSum2 @ a_a6Lqx $dNum_a6Lqz}]
Data.Foldable.$fFoldableV1_$csum
  = \ (@ a_a6Lqx) ($dNum_a6Lqz :: Num a_a6Lqx) _ [Occ=Dead] ->
      Data.Semigroup.Internal.$fMonoidSum2 @ a_a6Lqx $dNum_a6Lqz

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableV1_$cminimum
  :: forall a. Ord a => V1 a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Lqn) _ [Occ=Dead] _ [Occ=Dead] ->
                 errorWithoutStackTrace
                   @ 'LiftedRep @ a_a6Lqn Data.Foldable.$fFoldableK2}]
Data.Foldable.$fFoldableV1_$cminimum
  = \ (@ a_a6Lqn) _ [Occ=Dead] _ [Occ=Dead] ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6Lqn Data.Foldable.$fFoldableK2

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableV1_$cmaximum
  :: forall a. Ord a => V1 a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Lqd) _ [Occ=Dead] _ [Occ=Dead] ->
                 errorWithoutStackTrace
                   @ 'LiftedRep @ a_a6Lqd Data.Foldable.$fFoldableK4}]
Data.Foldable.$fFoldableV1_$cmaximum
  = \ (@ a_a6Lqd) _ [Occ=Dead] _ [Occ=Dead] ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6Lqd Data.Foldable.$fFoldableK4

-- RHS size: {terms: 6, types: 12, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableV1_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> V1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_a6Lp5)
                 (@ a_a6Lp6)
                 _ [Occ=Dead]
                 (z_X6KnK [Occ=Once] :: b_a6Lp5)
                 _ [Occ=Dead] ->
                 z_X6KnK}]
Data.Foldable.$fFoldableV1_$cfoldl
  = \ (@ b_a6Lp5)
      (@ a_a6Lp6)
      _ [Occ=Dead]
      (z_X6KnK :: b_a6Lp5)
      _ [Occ=Dead] ->
      z_X6KnK

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableV1_$cfoldl1
  :: forall a. (a -> a -> a) -> V1 a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Lpx) _ [Occ=Dead] _ [Occ=Dead] ->
                 errorWithoutStackTrace
                   @ 'LiftedRep @ a_a6Lpx Data.Foldable.$fFoldableK6}]
Data.Foldable.$fFoldableV1_$cfoldl1
  = \ (@ a_a6Lpx) _ [Occ=Dead] _ [Occ=Dead] ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6Lpx Data.Foldable.$fFoldableK6

-- RHS size: {terms: 6, types: 12, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableV1_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> V1 a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LoV)
                 (@ b_a6LoW)
                 _ [Occ=Dead]
                 (z0_a6K7t [Occ=Once] :: b_a6LoW)
                 _ [Occ=Dead] ->
                 z0_a6K7t}]
Data.Foldable.$fFoldableV1_$cfoldr'
  = \ (@ a_a6LoV)
      (@ b_a6LoW)
      _ [Occ=Dead]
      (z0_a6K7t :: b_a6LoW)
      _ [Occ=Dead] ->
      z0_a6K7t

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableV1_$clength :: forall a. V1 a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LpV) _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4}]
Data.Foldable.$fFoldableV1_$clength
  = \ (@ a_a6LpV) _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:4

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableV1_$cfoldr1
  :: forall a. (a -> a -> a) -> V1 a -> a
[GblId,
 Arity=2,
 Str=<B,A><B,A>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Lpp) _ [Occ=Dead] _ [Occ=Dead] ->
                 errorWithoutStackTrace
                   @ 'LiftedRep @ a_a6Lpp Data.Foldable.$fFoldableK8}]
Data.Foldable.$fFoldableV1_$cfoldr1
  = \ (@ a_a6Lpp) _ [Occ=Dead] _ [Occ=Dead] ->
      errorWithoutStackTrace
        @ 'LiftedRep @ a_a6Lpp Data.Foldable.$fFoldableK8

-- RHS size: {terms: 3, types: 6, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableV1_$cnull :: forall a. V1 a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LpN) _ [Occ=Dead] -> GHC.Types.True}]
Data.Foldable.$fFoldableV1_$cnull
  = \ (@ a_a6LpN) _ [Occ=Dead] -> GHC.Types.True

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableV1_$cfold
  :: forall m. Monoid m => V1 m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LSLL),1*U(A,1*U,A,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ m_a6Lor)
                 ($dMonoid_a6Lot [Occ=Once] :: Monoid m_a6Lor)
                 _ [Occ=Dead] ->
                 mempty @ m_a6Lor $dMonoid_a6Lot}]
Data.Foldable.$fFoldableV1_$cfold
  = \ (@ m_a6Lor) ($dMonoid_a6Lot :: Monoid m_a6Lor) _ [Occ=Dead] ->
      mempty @ m_a6Lor $dMonoid_a6Lot

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableV1_$cproduct
  :: forall a. Num a => V1 a -> a
[GblId,
 Arity=2,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LqH)
                 ($dNum_a6LqJ [Occ=Once] :: Num a_a6LqH)
                 _ [Occ=Dead] ->
                 Data.Semigroup.Internal.$fMonoidProduct2 @ a_a6LqH $dNum_a6LqJ}]
Data.Foldable.$fFoldableV1_$cproduct
  = \ (@ a_a6LqH) ($dNum_a6LqJ :: Num a_a6LqH) _ [Occ=Dead] ->
      Data.Semigroup.Internal.$fMonoidProduct2 @ a_a6LqH $dNum_a6LqJ

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableV1_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. V1 a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a6LpF) _ [Occ=Dead] ->
                 build
                   @ a_a6LpF
                   (\ (@ b_a6KNB)
                      _ [Occ=Dead, OS=OneShot]
                      (n_a6K7X [Occ=Once, OS=OneShot] :: b_a6KNB) ->
                      n_a6K7X)}]
Data.Foldable.$fFoldableV1_$ctoList
  = \ (@ a_a6LpF) _ [Occ=Dead] -> GHC.Types.[] @ a_a6LpF

-- RHS size: {terms: 17, types: 3, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableV1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable V1
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: V1
                                Data.Foldable.$fFoldableV1_$cfold
                                Data.Foldable.$fFoldableV1_$cfoldMap
                                Data.Foldable.$fFoldableV1_$cfoldr'
                                Data.Foldable.$fFoldableV1_$cfoldr'
                                Data.Foldable.$fFoldableV1_$cfoldl
                                Data.Foldable.$fFoldableV1_$cfoldl
                                Data.Foldable.$fFoldableV1_$cfoldr1
                                Data.Foldable.$fFoldableV1_$cfoldl1
                                Data.Foldable.$fFoldableV1_$ctoList
                                Data.Foldable.$fFoldableV1_$cnull
                                Data.Foldable.$fFoldableV1_$clength
                                Data.Foldable.$fFoldableV1_$celem
                                Data.Foldable.$fFoldableV1_$cmaximum
                                Data.Foldable.$fFoldableV1_$cminimum
                                Data.Foldable.$fFoldableV1_$csum
                                Data.Foldable.$fFoldableV1_$cproduct]
Data.Foldable.$fFoldableV1
  = Data.Foldable.C:Foldable
      @ V1
      Data.Foldable.$fFoldableV1_$cfold
      Data.Foldable.$fFoldableV1_$cfoldMap
      Data.Foldable.$fFoldableV1_$cfoldr'
      Data.Foldable.$fFoldableV1_$cfoldr'
      Data.Foldable.$fFoldableV1_$cfoldl
      Data.Foldable.$fFoldableV1_$cfoldl
      Data.Foldable.$fFoldableV1_$cfoldr1
      Data.Foldable.$fFoldableV1_$cfoldl1
      Data.Foldable.$fFoldableV1_$ctoList
      Data.Foldable.$fFoldableV1_$cnull
      Data.Foldable.$fFoldableV1_$clength
      Data.Foldable.$fFoldableV1_$celem
      Data.Foldable.$fFoldableV1_$cmaximum
      Data.Foldable.$fFoldableV1_$cminimum
      Data.Foldable.$fFoldableV1_$csum
      Data.Foldable.$fFoldableV1_$cproduct

-- RHS size: {terms: 36, types: 33, coercions: 0, joins: 0/2}
Data.Foldable.$fFoldableArray_$cfoldMap [InlPrag=INLINE (sat-args=1)]
  :: forall i m a. Monoid m => (a -> m) -> Array i a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><L,C(U)><S(LLSL),1*U(A,A,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ i_a6LGK)
                 (@ m_a6LGY)
                 (@ a_a6LGZ)
                 ($dMonoid_a6LH1 :: Monoid m_a6LGY)
                 (f_a6K7o [Occ=OnceL!] :: a_a6LGZ -> m_a6LGY) ->
                 foldrElems
                   @ a_a6LGZ
                   @ m_a6LGY
                   @ i_a6LGK
                   (let {
                      f1_i6HAj [Occ=OnceL!] :: m_a6LGY -> m_a6LGY -> m_a6LGY
                      [LclId]
                      f1_i6HAj = mappend @ m_a6LGY $dMonoid_a6LH1 } in
                    \ (x_i6HAl [Occ=Once] :: a_a6LGZ) -> f1_i6HAj (f_a6K7o x_i6HAl))
                   (mempty @ m_a6LGY $dMonoid_a6LH1)}]
Data.Foldable.$fFoldableArray_$cfoldMap
  = \ (@ i_a6LGK)
      (@ m_a6LGY)
      (@ a_a6LGZ)
      ($dMonoid_a6LH1 :: Monoid m_a6LGY)
      (f_a6K7o :: a_a6LGZ -> m_a6LGY)
      (eta_Xg6 :: Array i_a6LGK a_a6LGZ) ->
      case eta_Xg6 of { Array ww1_i6M6H ww2_i6M6I ww3_i6M6J ww4_i6M6K ->
      let {
        w1_i6Nlm :: m_a6LGY
        [LclId]
        w1_i6Nlm = mempty @ m_a6LGY $dMonoid_a6LH1 } in
      letrec {
        $wgo_s6NX8 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
          :: Int# -> m_a6LGY
        [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
        $wgo_s6NX8
          = \ (ww7_s6NX6 :: Int#) ->
              case ==# ww7_s6NX6 ww3_i6M6J of {
                __DEFAULT ->
                  mappend
                    @ m_a6LGY
                    $dMonoid_a6LH1
                    (f_a6K7o
                       (case indexArray# @ a_a6LGZ ww4_i6M6K ww7_s6NX6 of
                        { (# ipv_i6Nly #) ->
                        ipv_i6Nly
                        }))
                    ($wgo_s6NX8 (+# ww7_s6NX6 1#));
                1# -> w1_i6Nlm
              }; } in
      $wgo_s6NX8 0#
      }

-- RHS size: {terms: 34, types: 30, coercions: 8, joins: 0/2}
Data.Foldable.$fFoldableArray1
  :: forall i a. Num a => Array i a -> Product a
[GblId,
 Arity=1,
 Str=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60] 183 60}]
Data.Foldable.$fFoldableArray1
  = \ (@ i_a6LGK) (@ a_a6LJu) ($dNum_a6LJw :: Num a_a6LJu) ->
      let {
        w1_s6NlE :: a_a6LJu
        [LclId]
        w1_s6NlE
          = fromInteger
              @ a_a6LJu $dNum_a6LJw Data.Semigroup.Internal.$fMonoidProduct1 } in
      \ (w2_i6M6u :: Array i_a6LGK a_a6LJu) ->
        case w2_i6M6u of { Array ww1_i6M6H ww2_i6M6I ww3_i6M6J ww4_i6M6K ->
        letrec {
          $wgo_s6NXe [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: Int# -> Product a_a6LJu
          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
          $wgo_s6NXe
            = \ (ww7_s6NXc :: Int#) ->
                case ==# ww7_s6NXc ww3_i6M6J of {
                  __DEFAULT ->
                    (* @ a_a6LJu
                       $dNum_a6LJw
                       (case indexArray# @ a_a6LJu ww4_i6M6K ww7_s6NXc of
                        { (# ipv_i6Nly #) ->
                        ipv_i6Nly
                        })
                       (($wgo_s6NXe (+# ww7_s6NXc 1#))
                        `cast` (Data.Semigroup.Internal.N:Product[0] <a_a6LJu>_R
                                :: (Product a_a6LJu :: *) ~R# (a_a6LJu :: *))))
                    `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LJu>_R)
                            :: (a_a6LJu :: *) ~R# (Product a_a6LJu :: *));
                  1# ->
                    w1_s6NlE
                    `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LJu>_R)
                            :: (a_a6LJu :: *) ~R# (Product a_a6LJu :: *))
                }; } in
        $wgo_s6NXe 0#
        }

-- RHS size: {terms: 31, types: 21, coercions: 0, joins: 0/2}
Data.Foldable.$w$cfold [InlPrag=NOUSERINLINE[0]]
  :: forall i m. Monoid m => Int# -> Array# m -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 153 0}]
Data.Foldable.$w$cfold
  = \ (@ i_s6NXo)
      (@ m_s6NXp)
      (w_s6NXq :: Monoid m_s6NXp)
      (ww_s6NXw :: Int#)
      (ww1_s6NXx :: Array# m_s6NXp) ->
      let {
        w1_i6Nlm :: m_s6NXp
        [LclId]
        w1_i6Nlm = mempty @ m_s6NXp w_s6NXq } in
      letrec {
        $wgo_s6NXn [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
          :: Int# -> m_s6NXp
        [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
        $wgo_s6NXn
          = \ (ww2_s6NXl :: Int#) ->
              case ==# ww2_s6NXl ww_s6NXw of {
                __DEFAULT ->
                  mappend
                    @ m_s6NXp
                    w_s6NXq
                    (case indexArray# @ m_s6NXp ww1_s6NXx ww2_s6NXl of
                     { (# ipv_i6Nly #) ->
                     ipv_i6Nly
                     })
                    ($wgo_s6NXn (+# ww2_s6NXl 1#));
                1# -> w1_i6Nlm
              }; } in
      $wgo_s6NXn 0#

-- RHS size: {terms: 11, types: 19, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableArray_$cfold [InlPrag=NOUSERINLINE[0]]
  :: forall i m. Monoid m => Array i m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,U,C(C1(U)),A)><S(LLSS),1*U(A,A,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ i_s6NXo)
                 (@ m_s6NXp)
                 (w_s6NXq [Occ=Once] :: Monoid m_s6NXp)
                 (w1_s6NXr [Occ=Once!] :: Array i_s6NXo m_s6NXp) ->
                 case w1_s6NXr of
                 { Array _ [Occ=Dead] _ [Occ=Dead] ww3_s6NXw [Occ=Once]
                         ww4_s6NXx [Occ=Once] ->
                 Data.Foldable.$w$cfold
                   @ i_s6NXo @ m_s6NXp w_s6NXq ww3_s6NXw ww4_s6NXx
                 }}]
Data.Foldable.$fFoldableArray_$cfold
  = \ (@ i_s6NXo)
      (@ m_s6NXp)
      (w_s6NXq :: Monoid m_s6NXp)
      (w1_s6NXr :: Array i_s6NXo m_s6NXp) ->
      case w1_s6NXr of { Array ww1_s6NXu ww2_s6NXv ww3_s6NXw ww4_s6NXx ->
      Data.Foldable.$w$cfold
        @ i_s6NXo @ m_s6NXp w_s6NXq ww3_s6NXw ww4_s6NXx
      }

-- RHS size: {terms: 47, types: 32, coercions: 16, joins: 0/2}
Data.Foldable.$w$cmaximum [InlPrag=NOUSERINLINE[0]]
  :: forall i a. Ord a => Int# -> Array# a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 213 0}]
Data.Foldable.$w$cmaximum
  = \ (@ i_s6NXG)
      (@ a_s6NXH)
      (w_s6NXI :: Ord a_s6NXH)
      (ww_s6NXO :: Int#)
      (ww1_s6NXP :: Array# a_s6NXH) ->
      letrec {
        $wgo_s6NXF [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
          :: Int# -> Max a_s6NXH
        [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
        $wgo_s6NXF
          = \ (ww2_s6NXD :: Int#) ->
              case ==# ww2_s6NXD ww_s6NXO of {
                __DEFAULT ->
                  let {
                    x_i6HAl :: a_s6NXH
                    [LclId]
                    x_i6HAl
                      = case indexArray# @ a_s6NXH ww1_s6NXP ww2_s6NXD of
                        { (# ipv_i6Nly #) ->
                        ipv_i6Nly
                        } } in
                  case ($wgo_s6NXF (+# ww2_s6NXD 1#))
                       `cast` (Data.Functor.Utils.N:Max[0] <a_s6NXH>_N
                               :: (Max a_s6NXH :: *) ~R# (Maybe a_s6NXH :: *))
                  of wild_i6Mjl {
                    Nothing ->
                      (GHC.Base.Just @ a_s6NXH x_i6HAl)
                      `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_s6NXH>_N
                              :: (Maybe a_s6NXH :: *) ~R# (Max a_s6NXH :: *));
                    Just ipv_i6Mjp ->
                      case >= @ a_s6NXH w_s6NXI x_i6HAl ipv_i6Mjp of {
                        False ->
                          wild_i6Mjl
                          `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_s6NXH>_N
                                  :: (Maybe a_s6NXH :: *) ~R# (Max a_s6NXH :: *));
                        True ->
                          (GHC.Base.Just @ a_s6NXH x_i6HAl)
                          `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_s6NXH>_N
                                  :: (Maybe a_s6NXH :: *) ~R# (Max a_s6NXH :: *))
                      }
                  };
                1# ->
                  (GHC.Base.Nothing @ a_s6NXH)
                  `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_s6NXH>_N
                          :: (Maybe a_s6NXH :: *) ~R# (Max a_s6NXH :: *))
              }; } in
      case ($wgo_s6NXF 0#)
           `cast` (Data.Functor.Utils.N:Max[0] <a_s6NXH>_N
                   :: (Max a_s6NXH :: *) ~R# (Maybe a_s6NXH :: *))
      of {
        Nothing -> Data.Foldable.$fFoldable:*:3 @ a_s6NXH;
        Just v_i6M0Z -> v_i6M0Z
      }

-- RHS size: {terms: 11, types: 19, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableArray_$cmaximum [InlPrag=NOUSERINLINE[0]]
  :: forall i a. Ord a => Array i a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S(LLSS),1*U(A,A,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ i_s6NXG)
                 (@ a_s6NXH)
                 (w_s6NXI [Occ=Once] :: Ord a_s6NXH)
                 (w1_s6NXJ [Occ=Once!] :: Array i_s6NXG a_s6NXH) ->
                 case w1_s6NXJ of
                 { Array _ [Occ=Dead] _ [Occ=Dead] ww3_s6NXO [Occ=Once]
                         ww4_s6NXP [Occ=Once] ->
                 Data.Foldable.$w$cmaximum
                   @ i_s6NXG @ a_s6NXH w_s6NXI ww3_s6NXO ww4_s6NXP
                 }}]
Data.Foldable.$fFoldableArray_$cmaximum
  = \ (@ i_s6NXG)
      (@ a_s6NXH)
      (w_s6NXI :: Ord a_s6NXH)
      (w1_s6NXJ :: Array i_s6NXG a_s6NXH) ->
      case w1_s6NXJ of { Array ww1_s6NXM ww2_s6NXN ww3_s6NXO ww4_s6NXP ->
      Data.Foldable.$w$cmaximum
        @ i_s6NXG @ a_s6NXH w_s6NXI ww3_s6NXO ww4_s6NXP
      }

-- RHS size: {terms: 47, types: 32, coercions: 16, joins: 0/2}
Data.Foldable.$w$cminimum [InlPrag=NOUSERINLINE[0]]
  :: forall i a. Ord a => Int# -> Array# a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 213 0}]
Data.Foldable.$w$cminimum
  = \ (@ i_s6NXY)
      (@ a_s6NXZ)
      (w_s6NY0 :: Ord a_s6NXZ)
      (ww_s6NY6 :: Int#)
      (ww1_s6NY7 :: Array# a_s6NXZ) ->
      letrec {
        $wgo_s6NXX [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
          :: Int# -> Min a_s6NXZ
        [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
        $wgo_s6NXX
          = \ (ww2_s6NXV :: Int#) ->
              case ==# ww2_s6NXV ww_s6NY6 of {
                __DEFAULT ->
                  let {
                    x_i6HAl :: a_s6NXZ
                    [LclId]
                    x_i6HAl
                      = case indexArray# @ a_s6NXZ ww1_s6NY7 ww2_s6NXV of
                        { (# ipv_i6Nly #) ->
                        ipv_i6Nly
                        } } in
                  case ($wgo_s6NXX (+# ww2_s6NXV 1#))
                       `cast` (Data.Functor.Utils.N:Min[0] <a_s6NXZ>_N
                               :: (Min a_s6NXZ :: *) ~R# (Maybe a_s6NXZ :: *))
                  of wild_i6MjL {
                    Nothing ->
                      (GHC.Base.Just @ a_s6NXZ x_i6HAl)
                      `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_s6NXZ>_N
                              :: (Maybe a_s6NXZ :: *) ~R# (Min a_s6NXZ :: *));
                    Just ipv_i6MjP ->
                      case <= @ a_s6NXZ w_s6NY0 x_i6HAl ipv_i6MjP of {
                        False ->
                          wild_i6MjL
                          `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_s6NXZ>_N
                                  :: (Maybe a_s6NXZ :: *) ~R# (Min a_s6NXZ :: *));
                        True ->
                          (GHC.Base.Just @ a_s6NXZ x_i6HAl)
                          `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_s6NXZ>_N
                                  :: (Maybe a_s6NXZ :: *) ~R# (Min a_s6NXZ :: *))
                      }
                  };
                1# ->
                  (GHC.Base.Nothing @ a_s6NXZ)
                  `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_s6NXZ>_N
                          :: (Maybe a_s6NXZ :: *) ~R# (Min a_s6NXZ :: *))
              }; } in
      case ($wgo_s6NXX 0#)
           `cast` (Data.Functor.Utils.N:Min[0] <a_s6NXZ>_N
                   :: (Min a_s6NXZ :: *) ~R# (Maybe a_s6NXZ :: *))
      of {
        Nothing -> Data.Foldable.$fFoldable:*:2 @ a_s6NXZ;
        Just v_i6M0Z -> v_i6M0Z
      }

-- RHS size: {terms: 11, types: 19, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableArray_$cminimum [InlPrag=NOUSERINLINE[0]]
  :: forall i a. Ord a => Array i a -> a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S(LLSS),1*U(A,A,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ i_s6NXY)
                 (@ a_s6NXZ)
                 (w_s6NY0 [Occ=Once] :: Ord a_s6NXZ)
                 (w1_s6NY1 [Occ=Once!] :: Array i_s6NXY a_s6NXZ) ->
                 case w1_s6NY1 of
                 { Array _ [Occ=Dead] _ [Occ=Dead] ww3_s6NY6 [Occ=Once]
                         ww4_s6NY7 [Occ=Once] ->
                 Data.Foldable.$w$cminimum
                   @ i_s6NXY @ a_s6NXZ w_s6NY0 ww3_s6NY6 ww4_s6NY7
                 }}]
Data.Foldable.$fFoldableArray_$cminimum
  = \ (@ i_s6NXY)
      (@ a_s6NXZ)
      (w_s6NY0 :: Ord a_s6NXZ)
      (w1_s6NY1 :: Array i_s6NXY a_s6NXZ) ->
      case w1_s6NY1 of { Array ww1_s6NY4 ww2_s6NY5 ww3_s6NY6 ww4_s6NY7 ->
      Data.Foldable.$w$cminimum
        @ i_s6NXY @ a_s6NXZ w_s6NY0 ww3_s6NY6 ww4_s6NY7
      }

-- RHS size: {terms: 34, types: 30, coercions: 8, joins: 0/2}
Data.Foldable.$fFoldableArray2
  :: forall i a. Num a => Array i a -> Sum a
[GblId,
 Arity=1,
 Str=<L,U(C(C1(U)),A,A,A,A,A,1*C1(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60] 183 60}]
Data.Foldable.$fFoldableArray2
  = \ (@ i_X6LX9) (@ a_a6LJk) ($dNum_a6LJm :: Num a_a6LJk) ->
      let {
        w1_s6Nm6 :: a_a6LJk
        [LclId]
        w1_s6Nm6
          = fromInteger
              @ a_a6LJk $dNum_a6LJm Data.Semigroup.Internal.$fMonoidSum1 } in
      \ (w2_i6M6u :: Array i_X6LX9 a_a6LJk) ->
        case w2_i6M6u of { Array ww1_i6M6H ww2_i6M6I ww3_i6M6J ww4_i6M6K ->
        letrec {
          $wgo_s6NYf [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: Int# -> Sum a_a6LJk
          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
          $wgo_s6NYf
            = \ (ww7_s6NYd :: Int#) ->
                case ==# ww7_s6NYd ww3_i6M6J of {
                  __DEFAULT ->
                    (+ @ a_a6LJk
                       $dNum_a6LJm
                       (case indexArray# @ a_a6LJk ww4_i6M6K ww7_s6NYd of
                        { (# ipv_i6Nly #) ->
                        ipv_i6Nly
                        })
                       (($wgo_s6NYf (+# ww7_s6NYd 1#))
                        `cast` (Data.Semigroup.Internal.N:Sum[0] <a_a6LJk>_R
                                :: (Sum a_a6LJk :: *) ~R# (a_a6LJk :: *))))
                    `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6LJk>_R)
                            :: (a_a6LJk :: *) ~R# (Sum a_a6LJk :: *));
                  1# ->
                    w1_s6Nm6
                    `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6LJk>_R)
                            :: (a_a6LJk :: *) ~R# (Sum a_a6LJk :: *))
                }; } in
        $wgo_s6NYf 0#
        }

-- RHS size: {terms: 38, types: 31, coercions: 9, joins: 1/2}
Data.Foldable.$fFoldableArray_$celem
  :: forall i a. Eq a => a -> Array i a -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 131 60}]
Data.Foldable.$fFoldableArray_$celem
  = \ (@ i_X6LXe)
      (@ a_a6LIQ)
      ($dEq_a6LIS :: Eq a_a6LIQ)
      (eta_Xgc :: a_a6LIQ) ->
      let {
        f_s6MIr [Dmd=<L,C(U)>] :: a_a6LIQ -> Bool
        [LclId]
        f_s6MIr = == @ a_a6LIQ $dEq_a6LIS eta_Xgc } in
      (\ (w2_i6M6u :: Array i_X6LXe a_a6LIQ) ->
         case w2_i6M6u of { Array ww1_i6M6H ww2_i6M6I ww3_i6M6J ww4_i6M6K ->
         joinrec {
           $wgo_s6NYo [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
             :: Int# -> Data.Monoid.Any
           [LclId[JoinId(1)], Arity=1, Str=<S,U>, Unf=OtherCon []]
           $wgo_s6NYo (ww7_s6NYm :: Int#)
             = case ==# ww7_s6NYm ww3_i6M6J of {
                 __DEFAULT ->
                   case f_s6MIr
                          (case indexArray# @ a_a6LIQ ww4_i6M6K ww7_s6NYm of
                           { (# ipv_i6Nly #) ->
                           ipv_i6Nly
                           })
                   of {
                     False -> jump $wgo_s6NYo (+# ww7_s6NYm 1#);
                     True ->
                       GHC.Types.True
                       `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                               :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
                   };
                 1# ->
                   GHC.Types.False
                   `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                           :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
               }; } in
         jump $wgo_s6NYo 0#
         })
      `cast` (<Array i_X6LXe a_a6LIQ>_R
              ->_R Data.Semigroup.Internal.N:Any[0]
              :: (Array i_X6LXe a_a6LIQ -> Data.Monoid.Any :: *)
                 ~R# (Array i_X6LXe a_a6LIQ -> Bool :: *))

-- RHS size: {terms: 28, types: 50, coercions: 24, joins: 0/0}
Data.Foldable.$fFoldableArray [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i. Foldable (Array i)
[GblId[DFunId],
 Unf=DFun: \ (@ i_a6K8h) ->
       Data.Foldable.C:Foldable TYPE: Array i_a6K8h
                                Data.Foldable.$fFoldableArray_$cfold @ i_a6K8h
                                Data.Foldable.$fFoldableArray_$cfoldMap @ i_a6K8h
                                \ (@ a_a6LHa) (@ b_a6LHb) ->
                                  foldrElems @ a_a6LHa @ b_a6LHb @ i_a6K8h
                                \ (@ a_a6LHn) (@ b_a6LHo) ->
                                  foldrElems' @ a_a6LHn @ b_a6LHo @ i_a6K8h
                                \ (@ b_a6LHA) (@ a_a6LHB) ->
                                  foldlElems @ b_a6LHA @ a_a6LHB @ i_a6K8h
                                \ (@ b_a6LHN) (@ a_a6LHO) ->
                                  foldlElems' @ b_a6LHN @ a_a6LHO @ i_a6K8h
                                \ (@ a_a6LI0) -> foldr1Elems @ a_a6LI0 @ i_a6K8h
                                \ (@ a_a6LIa) -> foldl1Elems @ a_a6LIa @ i_a6K8h
                                elems @ i_a6K8h
                                Data.Foldable.$fFoldableArray_$cnull @ i_a6K8h
                                numElements @ i_a6K8h
                                Data.Foldable.$fFoldableArray_$celem @ i_a6K8h
                                Data.Foldable.$fFoldableArray_$cmaximum @ i_a6K8h
                                Data.Foldable.$fFoldableArray_$cminimum @ i_a6K8h
                                (Data.Foldable.$fFoldableArray2 @ i_a6K8h)
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <Array i_a6K8h a>_R
                                        ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
                                        :: (forall a. Num a => Array i_a6K8h a -> Sum a :: *)
                                           ~R# (forall a. Num a => Array i_a6K8h a -> a :: *))
                                (Data.Foldable.$fFoldableArray1 @ i_a6K8h)
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <Array i_a6K8h a>_R
                                        ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
                                        :: (forall a. Num a => Array i_a6K8h a -> Product a :: *)
                                           ~R# (forall a. Num a => Array i_a6K8h a -> a :: *))]
Data.Foldable.$fFoldableArray
  = \ (@ i_a6LGK) ->
      Data.Foldable.C:Foldable
        @ (Array i_a6LGK)
        (Data.Foldable.$fFoldableArray_$cfold @ i_a6LGK)
        (Data.Foldable.$fFoldableArray_$cfoldMap @ i_a6LGK)
        (\ (@ a_a6LHa) (@ b_a6LHb) ->
           foldrElems @ a_a6LHa @ b_a6LHb @ i_a6LGK)
        (\ (@ a_a6LHn) (@ b_a6LHo) ->
           foldrElems' @ a_a6LHn @ b_a6LHo @ i_a6LGK)
        (\ (@ b_a6LHA) (@ a_a6LHB) ->
           foldlElems @ b_a6LHA @ a_a6LHB @ i_a6LGK)
        (\ (@ b_a6LHN) (@ a_a6LHO) ->
           foldlElems' @ b_a6LHN @ a_a6LHO @ i_a6LGK)
        (\ (@ a_a6LI0) -> foldr1Elems @ a_a6LI0 @ i_a6LGK)
        (\ (@ a_a6LIa) -> foldl1Elems @ a_a6LIa @ i_a6LGK)
        (elems @ i_a6LGK)
        (Data.Foldable.$fFoldableArray_$cnull @ i_a6LGK)
        (numElements @ i_a6LGK)
        (Data.Foldable.$fFoldableArray_$celem @ i_a6LGK)
        (Data.Foldable.$fFoldableArray_$cmaximum @ i_a6LGK)
        (Data.Foldable.$fFoldableArray_$cminimum @ i_a6LGK)
        ((Data.Foldable.$fFoldableArray2 @ i_a6LGK)
         `cast` (forall (a :: <*>_N).
                 <Num a>_R
                 ->_R <Array i_a6LGK a>_R
                 ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
                 :: (forall a. Num a => Array i_a6LGK a -> Sum a :: *)
                    ~R# (forall a. Num a => Array i_a6LGK a -> a :: *)))
        ((Data.Foldable.$fFoldableArray1 @ i_a6LGK)
         `cast` (forall (a :: <*>_N).
                 <Num a>_R
                 ->_R <Array i_a6LGK a>_R
                 ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
                 :: (forall a. Num a => Array i_a6LGK a -> Product a :: *)
                    ~R# (forall a. Num a => Array i_a6LGK a -> a :: *)))

-- RHS size: {terms: 14, types: 18, coercions: 7, joins: 0/1}
Data.Foldable.$fFoldable(,)_$celem
  :: forall a1 a2. Eq a2 => a2 -> (a1, a2) -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LJD)
                 (@ a1_a6LLd)
                 ($dEq_a6LLf [Occ=Once] :: Eq a1_a6LLd)
                 (eta_Xge [Occ=Once] :: a1_a6LLd) ->
                 let {
                   f_s6MIp [Occ=OnceL!] :: a1_a6LLd -> Bool
                   [LclId]
                   f_s6MIp = == @ a1_a6LLd $dEq_a6LLf eta_Xge } in
                 (\ (ds_d6M8L [Occ=Once!] :: (a_a6LJD, a1_a6LLd)) ->
                    case ds_d6M8L of { (_ [Occ=Dead], y_a6K8l [Occ=Once]) ->
                    (f_s6MIp y_a6K8l)
                    `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                            :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
                    })
                 `cast` (<(a_a6LJD, a1_a6LLd)>_R
                         ->_R Data.Semigroup.Internal.N:Any[0]
                         :: ((a_a6LJD, a1_a6LLd) -> Data.Monoid.Any :: *)
                            ~R# ((a_a6LJD, a1_a6LLd) -> Bool :: *))}]
Data.Foldable.$fFoldable(,)_$celem
  = \ (@ a_a6LJD)
      (@ a1_a6LLd)
      ($dEq_a6LLf :: Eq a1_a6LLd)
      (eta_Xge :: a1_a6LLd) ->
      let {
        f_s6MIp [Dmd=<L,C(U)>] :: a1_a6LLd -> Bool
        [LclId]
        f_s6MIp = == @ a1_a6LLd $dEq_a6LLf eta_Xge } in
      (\ (ds_d6M8L :: (a_a6LJD, a1_a6LLd)) ->
         case ds_d6M8L of { (ds1_d6M8S, y_a6K8l) ->
         (f_s6MIp y_a6K8l)
         `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                 :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
         })
      `cast` (<(a_a6LJD, a1_a6LLd)>_R
              ->_R Data.Semigroup.Internal.N:Any[0]
              :: ((a_a6LJD, a1_a6LLd) -> Data.Monoid.Any :: *)
                 ~R# ((a_a6LJD, a1_a6LLd) -> Bool :: *))

-- RHS size: {terms: 8, types: 14, coercions: 3, joins: 0/0}
Data.Foldable.$fFoldable(,)2
  :: forall a1 a2. Num a2 => (a1, a2) -> Sum a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LJD)
                 (@ a1_a6LLH)
                 _ [Occ=Dead]
                 (eta_Xgf [Occ=Once!] :: (a_a6LJD, a1_a6LLH)) ->
                 case eta_Xgf of { (_ [Occ=Dead], y_a6K8l [Occ=Once]) ->
                 y_a6K8l
                 `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a1_a6LLH>_R)
                         :: (a1_a6LLH :: *) ~R# (Sum a1_a6LLH :: *))
                 }}]
Data.Foldable.$fFoldable(,)2
  = \ (@ a_a6LJD)
      (@ a1_a6LLH)
      _ [Occ=Dead]
      (eta_Xgf :: (a_a6LJD, a1_a6LLH)) ->
      case eta_Xgf of { (ds_d6M8S, y_a6K8l) ->
      y_a6K8l
      `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a1_a6LLH>_R)
              :: (a1_a6LLH :: *) ~R# (Sum a1_a6LLH :: *))
      }

-- RHS size: {terms: 7, types: 12, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable(,)3 :: forall a1 a2. (a2, a1) -> a1
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LLx)
                 (@ a1_X6LZU)
                 (x_X6HLQ [Occ=Once!] :: (a1_X6LZU, a_a6LLx)) ->
                 case x_X6HLQ of { (_ [Occ=Dead], y_a6K8l [Occ=Once]) -> y_a6K8l }}]
Data.Foldable.$fFoldable(,)3
  = \ (@ a_a6LLx) (@ a1_X6LZU) (x_X6HLQ :: (a1_X6LZU, a_a6LLx)) ->
      case x_X6HLQ of { (ds_d6M8S, y_a6K8l) -> y_a6K8l }

-- RHS size: {terms: 4, types: 8, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable(,)_$cminimum
  :: forall a1 a2. Ord a2 => (a1, a2) -> a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_X6LZU) (@ a1_a6LLx) _ [Occ=Dead] ->
                 Data.Foldable.$fFoldable(,)3 @ a1_a6LLx @ a_X6LZU}]
Data.Foldable.$fFoldable(,)_$cminimum
  = \ (@ a_X6LZU) (@ a1_a6LLx) _ [Occ=Dead] ->
      Data.Foldable.$fFoldable(,)3 @ a1_a6LLx @ a_X6LZU

-- RHS size: {terms: 7, types: 12, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable(,)_$cnull
  :: forall a1 a2. (a1, a2) -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X6LZY)
                 (@ a1_a6LKX)
                 (ds_d6M8T [Occ=Once!] :: (a_X6LZY, a1_a6LKX)) ->
                 case ds_d6M8T of { (_ [Occ=Dead], _ [Occ=Dead]) ->
                 GHC.Types.False
                 }}]
Data.Foldable.$fFoldable(,)_$cnull
  = \ (@ a_X6LZY) (@ a1_a6LKX) (ds_d6M8T :: (a_X6LZY, a1_a6LKX)) ->
      case ds_d6M8T of { (ds1_d6M8Z, y_a6K8o) -> GHC.Types.False }

-- RHS size: {terms: 8, types: 15, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable(,)_$cfoldr1
  :: forall a1 a2. (a2 -> a2 -> a2) -> (a1, a2) -> a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X6LZZ)
                 (@ a1_a6LKz)
                 _ [Occ=Dead]
                 (xs_a6K7K [Occ=Once!] :: (a_X6LZZ, a1_a6LKz)) ->
                 case xs_a6K7K of { (_ [Occ=Dead], y_a6K8o [Occ=Once]) ->
                 y_a6K8o
                 }}]
Data.Foldable.$fFoldable(,)_$cfoldr1
  = \ (@ a_X6LZZ)
      (@ a1_a6LKz)
      _ [Occ=Dead]
      (xs_a6K7K :: (a_X6LZZ, a1_a6LKz)) ->
      case xs_a6K7K of { (ds_d6M8Z, y_a6K8o) -> y_a6K8o }

-- RHS size: {terms: 12, types: 18, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable(,)_$cfoldl'
  :: forall a1 b a2. (b -> a2 -> b) -> b -> (a1, a2) -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X6M00)
                 (@ b_a6LKp)
                 (@ a1_a6LKq)
                 (f_a6K7C [Occ=Once!] :: b_a6LKp -> a1_a6LKq -> b_a6LKp)
                 (z0_a6K7D [Occ=Once] :: b_a6LKp)
                 (xs_a6K7E [Occ=Once!] :: (a_X6M00, a1_a6LKq)) ->
                 case xs_a6K7E of { (_ [Occ=Dead], y_a6K8o [Occ=Once]) ->
                 f_a6K7C z0_a6K7D y_a6K8o
                 }}]
Data.Foldable.$fFoldable(,)_$cfoldl'
  = \ (@ a_X6M00)
      (@ b_a6LKp)
      (@ a1_a6LKq)
      (f_a6K7C :: b_a6LKp -> a1_a6LKq -> b_a6LKp)
      (z0_a6K7D :: b_a6LKp)
      (xs_a6K7E :: (a_X6M00, a1_a6LKq)) ->
      case xs_a6K7E of { (ds_d6M8Z, y_a6K8o) ->
      f_a6K7C z0_a6K7D y_a6K8o
      }

-- RHS size: {terms: 7, types: 12, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable(,)_$clength
  :: forall a1 a2. (a1, a2) -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*H>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X6M01)
                 (@ a1_a6LL5)
                 (xs_a6K7E [Occ=Once!] :: (a_X6M01, a1_a6LL5)) ->
                 case xs_a6K7E of { (_ [Occ=Dead], _ [Occ=Dead]) ->
                 GHC.Types.I# 1#
                 }}]
Data.Foldable.$fFoldable(,)_$clength
  = \ (@ a_X6M01) (@ a1_a6LL5) (xs_a6K7E :: (a_X6M01, a1_a6LL5)) ->
      case xs_a6K7E of { (ds_d6M8Z, y_a6K8o) ->
      Data.Foldable.$fFoldableDual3
      }

-- RHS size: {terms: 8, types: 14, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable(,)_$cfold
  :: forall a m. Monoid m => (a, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X6M05)
                 (@ m_a6LJH)
                 _ [Occ=Dead]
                 (ds_d6M8L [Occ=Once!] :: (a_X6M05, m_a6LJH)) ->
                 case ds_d6M8L of { (_ [Occ=Dead], y_a6K8l [Occ=Once]) ->
                 y_a6K8l
                 }}]
Data.Foldable.$fFoldable(,)_$cfold
  = \ (@ a_X6M05)
      (@ m_a6LJH)
      _ [Occ=Dead]
      (ds_d6M8L :: (a_X6M05, m_a6LJH)) ->
      case ds_d6M8L of { (ds1_d6M8S, y_a6K8l) -> y_a6K8l }

-- RHS size: {terms: 8, types: 14, coercions: 3, joins: 0/0}
Data.Foldable.$fFoldable(,)1
  :: forall a1 a2. Num a2 => (a1, a2) -> Product a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S(LS),1*U(A,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X6M06)
                 (@ a1_a6LLR)
                 _ [Occ=Dead]
                 (eta_Xgx [Occ=Once!] :: (a_X6M06, a1_a6LLR)) ->
                 case eta_Xgx of { (_ [Occ=Dead], y_a6K8l [Occ=Once]) ->
                 y_a6K8l
                 `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a1_a6LLR>_R)
                         :: (a1_a6LLR :: *) ~R# (Product a1_a6LLR :: *))
                 }}]
Data.Foldable.$fFoldable(,)1
  = \ (@ a_X6M06)
      (@ a1_a6LLR)
      _ [Occ=Dead]
      (eta_Xgx :: (a_X6M06, a1_a6LLR)) ->
      case eta_Xgx of { (ds_d6M8S, y_a6K8l) ->
      y_a6K8l
      `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a1_a6LLR>_R)
              :: (a1_a6LLR :: *) ~R# (Product a1_a6LLR :: *))
      }

-- RHS size: {terms: 9, types: 14, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable(,)_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a1 a2. (a1, a2) -> [a2]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(A,U)>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_X6M0c)
                 (@ a1_a6LKP)
                 (t_a6K7V [Occ=Once!] :: (a_X6M0c, a1_a6LKP)) ->
                 build
                   @ a1_a6LKP
                   (\ (@ b_a6KNB)
                      (c_a6K7W [Occ=Once!, OS=OneShot] :: a1_a6LKP -> b_a6KNB -> b_a6KNB)
                      (n_a6K7X [Occ=Once, OS=OneShot] :: b_a6KNB) ->
                      case t_a6K7V of { (_ [Occ=Dead], y_a6K8o [Occ=Once]) ->
                      c_a6K7W y_a6K8o n_a6K7X
                      })}]
Data.Foldable.$fFoldable(,)_$ctoList
  = \ (@ a_X6M0c) (@ a1_a6LKP) (eta_XgC :: (a_X6M0c, a1_a6LKP)) ->
      case eta_XgC of { (ds_d6M8Z, y_a6K8o) ->
      GHC.Types.: @ a1_a6LKP y_a6K8o (GHC.Types.[] @ a1_a6LKP)
      }

-- RHS size: {terms: 18, types: 20, coercions: 24, joins: 0/0}
Data.Foldable.$fFoldable(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Foldable ((,) a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ (@ a_a6K8j) ->
       Data.Foldable.C:Foldable TYPE: (,) a_a6K8j
                                Data.Foldable.$fFoldable(,)_$cfold @ a_a6K8j
                                Data.Foldable.$fFoldable(,)_$cfoldMap @ a_a6K8j
                                Data.Foldable.$fFoldable(,)_$cfoldr @ a_a6K8j
                                Data.Foldable.$fFoldable(,)_$cfoldr @ a_a6K8j
                                Data.Foldable.$fFoldable(,)_$cfoldl' @ a_a6K8j
                                Data.Foldable.$fFoldable(,)_$cfoldl' @ a_a6K8j
                                Data.Foldable.$fFoldable(,)_$cfoldr1 @ a_a6K8j
                                Data.Foldable.$fFoldable(,)_$cfoldr1 @ a_a6K8j
                                Data.Foldable.$fFoldable(,)_$ctoList @ a_a6K8j
                                Data.Foldable.$fFoldable(,)_$cnull @ a_a6K8j
                                Data.Foldable.$fFoldable(,)_$clength @ a_a6K8j
                                Data.Foldable.$fFoldable(,)_$celem @ a_a6K8j
                                Data.Foldable.$fFoldable(,)_$cminimum @ a_a6K8j
                                Data.Foldable.$fFoldable(,)_$cminimum @ a_a6K8j
                                (Data.Foldable.$fFoldable(,)2 @ a_a6K8j)
                                `cast` (forall (a1 :: <*>_N).
                                        <Num a1>_R
                                        ->_R <(a_a6K8j, a1)>_R
                                        ->_R Data.Semigroup.Internal.N:Sum[0] <a1>_R
                                        :: (forall a1. Num a1 => (a_a6K8j, a1) -> Sum a1 :: *)
                                           ~R# (forall a1. Num a1 => (a_a6K8j, a1) -> a1 :: *))
                                (Data.Foldable.$fFoldable(,)1 @ a_a6K8j)
                                `cast` (forall (a1 :: <*>_N).
                                        <Num a1>_R
                                        ->_R <(a_a6K8j, a1)>_R
                                        ->_R Data.Semigroup.Internal.N:Product[0] <a1>_R
                                        :: (forall a1. Num a1 => (a_a6K8j, a1) -> Product a1 :: *)
                                           ~R# (forall a1. Num a1 => (a_a6K8j, a1) -> a1 :: *))]
Data.Foldable.$fFoldable(,)
  = \ (@ a_X6M0d) ->
      Data.Foldable.C:Foldable
        @ ((,) a_X6M0d)
        (Data.Foldable.$fFoldable(,)_$cfold @ a_X6M0d)
        (Data.Foldable.$fFoldable(,)_$cfoldMap @ a_X6M0d)
        (Data.Foldable.$fFoldable(,)_$cfoldr @ a_X6M0d)
        (Data.Foldable.$fFoldable(,)_$cfoldr @ a_X6M0d)
        (Data.Foldable.$fFoldable(,)_$cfoldl' @ a_X6M0d)
        (Data.Foldable.$fFoldable(,)_$cfoldl' @ a_X6M0d)
        (Data.Foldable.$fFoldable(,)_$cfoldr1 @ a_X6M0d)
        (Data.Foldable.$fFoldable(,)_$cfoldr1 @ a_X6M0d)
        (Data.Foldable.$fFoldable(,)_$ctoList @ a_X6M0d)
        (Data.Foldable.$fFoldable(,)_$cnull @ a_X6M0d)
        (Data.Foldable.$fFoldable(,)_$clength @ a_X6M0d)
        (Data.Foldable.$fFoldable(,)_$celem @ a_X6M0d)
        (Data.Foldable.$fFoldable(,)_$cminimum @ a_X6M0d)
        (Data.Foldable.$fFoldable(,)_$cminimum @ a_X6M0d)
        ((Data.Foldable.$fFoldable(,)2 @ a_X6M0d)
         `cast` (forall (a1 :: <*>_N).
                 <Num a1>_R
                 ->_R <(a_X6M0d, a1)>_R
                 ->_R Data.Semigroup.Internal.N:Sum[0] <a1>_R
                 :: (forall a1. Num a1 => (a_X6M0d, a1) -> Sum a1 :: *)
                    ~R# (forall a1. Num a1 => (a_X6M0d, a1) -> a1 :: *)))
        ((Data.Foldable.$fFoldable(,)1 @ a_X6M0d)
         `cast` (forall (a1 :: <*>_N).
                 <Num a1>_R
                 ->_R <(a_X6M0d, a1)>_R
                 ->_R Data.Semigroup.Internal.N:Product[0] <a1>_R
                 :: (forall a1. Num a1 => (a_X6M0d, a1) -> Product a1 :: *)
                    ~R# (forall a1. Num a1 => (a_X6M0d, a1) -> a1 :: *)))

-- RHS size: {terms: 16, types: 18, coercions: 9, joins: 0/1}
Data.Foldable.$fFoldableEither_$celem
  :: forall a1 a2. Eq a2 => a2 -> Either a1 a2 -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LM0)
                 (@ a1_a6LND)
                 ($dEq_a6LNF [Occ=Once] :: Eq a1_a6LND)
                 (eta_XgF [Occ=Once] :: a1_a6LND) ->
                 let {
                   ds_s6MIj [Occ=OnceL!] :: a1_a6LND -> Bool
                   [LclId]
                   ds_s6MIj = == @ a1_a6LND $dEq_a6LNF eta_XgF } in
                 (\ (ds1_d6M91 [Occ=Once!] :: Either a_a6LM0 a1_a6LND) ->
                    case ds1_d6M91 of {
                      Left _ [Occ=Dead] ->
                        GHC.Types.False
                        `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                                :: (Bool :: *) ~R# (Data.Monoid.Any :: *));
                      Right y_a6K8r [Occ=Once] ->
                        (ds_s6MIj y_a6K8r)
                        `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                                :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
                    })
                 `cast` (<Either a_a6LM0 a1_a6LND>_R
                         ->_R Data.Semigroup.Internal.N:Any[0]
                         :: (Either a_a6LM0 a1_a6LND -> Data.Monoid.Any :: *)
                            ~R# (Either a_a6LM0 a1_a6LND -> Bool :: *))}]
Data.Foldable.$fFoldableEither_$celem
  = \ (@ a_a6LM0)
      (@ a1_a6LND)
      ($dEq_a6LNF :: Eq a1_a6LND)
      (eta_XgF :: a1_a6LND) ->
      let {
        ds_s6MIj [Dmd=<L,C(U)>] :: a1_a6LND -> Bool
        [LclId]
        ds_s6MIj = == @ a1_a6LND $dEq_a6LNF eta_XgF } in
      (\ (ds1_d6M91 :: Either a_a6LM0 a1_a6LND) ->
         case ds1_d6M91 of {
           Left ds2_d6M9a ->
             GHC.Types.False
             `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                     :: (Bool :: *) ~R# (Data.Monoid.Any :: *));
           Right y_a6K8r ->
             (ds_s6MIj y_a6K8r)
             `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                     :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
         })
      `cast` (<Either a_a6LM0 a1_a6LND>_R
              ->_R Data.Semigroup.Internal.N:Any[0]
              :: (Either a_a6LM0 a1_a6LND -> Data.Monoid.Any :: *)
                 ~R# (Either a_a6LM0 a1_a6LND -> Bool :: *))

-- RHS size: {terms: 11, types: 15, coercions: 6, joins: 0/0}
Data.Foldable.$fFoldableEither2
  :: forall a1 a2. Num a2 => Either a1 a2 -> Sum a2
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LM0)
                 (@ a1_a6LO7)
                 ($dNum_a6LO9 [Occ=Once] :: Num a1_a6LO7)
                 (ds_d6M91 [Occ=Once!] :: Either a_a6LM0 a1_a6LO7) ->
                 case ds_d6M91 of {
                   Left _ [Occ=Dead] ->
                     (Data.Semigroup.Internal.$fMonoidSum2 @ a1_a6LO7 $dNum_a6LO9)
                     `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a1_a6LO7>_R)
                             :: (a1_a6LO7 :: *) ~R# (Sum a1_a6LO7 :: *));
                   Right y_a6K8r [Occ=Once] ->
                     y_a6K8r
                     `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a1_a6LO7>_R)
                             :: (a1_a6LO7 :: *) ~R# (Sum a1_a6LO7 :: *))
                 }}]
Data.Foldable.$fFoldableEither2
  = \ (@ a_a6LM0)
      (@ a1_a6LO7)
      ($dNum_a6LO9 :: Num a1_a6LO7)
      (ds_d6M91 :: Either a_a6LM0 a1_a6LO7) ->
      case ds_d6M91 of {
        Left ds1_d6M9a ->
          (Data.Semigroup.Internal.$fMonoidSum2 @ a1_a6LO7 $dNum_a6LO9)
          `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a1_a6LO7>_R)
                  :: (a1_a6LO7 :: *) ~R# (Sum a1_a6LO7 :: *));
        Right y_a6K8r ->
          y_a6K8r
          `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a1_a6LO7>_R)
                  :: (a1_a6LO7 :: *) ~R# (Sum a1_a6LO7 :: *))
      }

-- RHS size: {terms: 9, types: 13, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableEither3 :: forall a1 a2. Either a2 a1 -> a1
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LNX)
                 (@ a1_X6M2H)
                 (x_X6HLQ [Occ=Once!] :: Either a1_X6M2H a_a6LNX) ->
                 case x_X6HLQ of {
                   Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:2 @ a_a6LNX;
                   Right y_a6K8r [Occ=Once] -> y_a6K8r
                 }}]
Data.Foldable.$fFoldableEither3
  = \ (@ a_a6LNX)
      (@ a1_X6M2H)
      (x_X6HLQ :: Either a1_X6M2H a_a6LNX) ->
      case x_X6HLQ of {
        Left ds_d6M9a -> Data.Foldable.$fFoldable:*:2 @ a_a6LNX;
        Right y_a6K8r -> y_a6K8r
      }

-- RHS size: {terms: 4, types: 8, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableEither_$cminimum
  :: forall a1 a2. Ord a2 => Either a1 a2 -> a2
[GblId,
 Arity=2,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_X6M2H) (@ a1_a6LNX) _ [Occ=Dead] ->
                 Data.Foldable.$fFoldableEither3 @ a1_a6LNX @ a_X6M2H}]
Data.Foldable.$fFoldableEither_$cminimum
  = \ (@ a_X6M2H) (@ a1_a6LNX) _ [Occ=Dead] ->
      Data.Foldable.$fFoldableEither3 @ a1_a6LNX @ a_X6M2H

-- RHS size: {terms: 9, types: 13, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableEither4 :: forall a1 a2. Either a2 a1 -> a1
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LNN)
                 (@ a1_X6M2I)
                 (x_X6HLR [Occ=Once!] :: Either a1_X6M2I a_a6LNN) ->
                 case x_X6HLR of {
                   Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:*:3 @ a_a6LNN;
                   Right y_a6K8r [Occ=Once] -> y_a6K8r
                 }}]
Data.Foldable.$fFoldableEither4
  = \ (@ a_a6LNN)
      (@ a1_X6M2I)
      (x_X6HLR :: Either a1_X6M2I a_a6LNN) ->
      case x_X6HLR of {
        Left ds_d6M9a -> Data.Foldable.$fFoldable:*:3 @ a_a6LNN;
        Right y_a6K8r -> y_a6K8r
      }

-- RHS size: {terms: 4, types: 8, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableEither_$cmaximum
  :: forall a1 a2. Ord a2 => Either a1 a2 -> a2
[GblId,
 Arity=2,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_X6M2I) (@ a1_a6LNN) _ [Occ=Dead] ->
                 Data.Foldable.$fFoldableEither4 @ a1_a6LNN @ a_X6M2I}]
Data.Foldable.$fFoldableEither_$cmaximum
  = \ (@ a_X6M2I) (@ a1_a6LNN) _ [Occ=Dead] ->
      Data.Foldable.$fFoldableEither4 @ a1_a6LNN @ a_X6M2I

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableEither_$cfoldr1
  :: forall a1 a2. (a2 -> a2 -> a2) -> Either a1 a2 -> a2
[GblId,
 Arity=2,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X6M2J)
                 (@ a1_a6LN0)
                 _ [Occ=Dead]
                 (xs_a6K7K [Occ=Once!] :: Either a_X6M2J a1_a6LN0) ->
                 case xs_a6K7K of {
                   Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:.:3 @ a1_a6LN0;
                   Right y_a6K8v [Occ=Once] -> y_a6K8v
                 }}]
Data.Foldable.$fFoldableEither_$cfoldr1
  = \ (@ a_X6M2J)
      (@ a1_a6LN0)
      _ [Occ=Dead]
      (xs_a6K7K :: Either a_X6M2J a1_a6LN0) ->
      case xs_a6K7K of {
        Left ds_d6M9k -> Data.Foldable.$fFoldable:.:3 @ a1_a6LN0;
        Right y_a6K8v -> y_a6K8v
      }

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableEither_$cfoldl'
  :: forall a1 b a2. (b -> a2 -> b) -> b -> Either a1 a2 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X6M2K)
                 (@ b_a6LMQ)
                 (@ a1_a6LMR)
                 (f_a6K7C [Occ=Once!] :: b_a6LMQ -> a1_a6LMR -> b_a6LMQ)
                 (z0_a6K7D [Occ=Once*] :: b_a6LMQ)
                 (xs_a6K7E [Occ=Once!] :: Either a_X6M2K a1_a6LMR) ->
                 case xs_a6K7E of {
                   Left _ [Occ=Dead] -> z0_a6K7D;
                   Right y_a6K8v [Occ=Once] -> f_a6K7C z0_a6K7D y_a6K8v
                 }}]
Data.Foldable.$fFoldableEither_$cfoldl'
  = \ (@ a_X6M2K)
      (@ b_a6LMQ)
      (@ a1_a6LMR)
      (f_a6K7C :: b_a6LMQ -> a1_a6LMR -> b_a6LMQ)
      (z0_a6K7D :: b_a6LMQ)
      (xs_a6K7E :: Either a_X6M2K a1_a6LMR) ->
      case xs_a6K7E of {
        Left ds_d6M9k -> z0_a6K7D;
        Right y_a6K8v -> f_a6K7C z0_a6K7D y_a6K8v
      }

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableEither_$cfoldl1
  :: forall a1 a2. (a2 -> a2 -> a2) -> Either a1 a2 -> a2
[GblId,
 Arity=2,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X6M2M)
                 (@ a1_a6LN8)
                 _ [Occ=Dead]
                 (xs_X6KoF [Occ=Once!] :: Either a_X6M2M a1_a6LN8) ->
                 case xs_X6KoF of {
                   Left _ [Occ=Dead] -> Data.Foldable.$fFoldable:.:2 @ a1_a6LN8;
                   Right y_a6K8r [Occ=Once] -> y_a6K8r
                 }}]
Data.Foldable.$fFoldableEither_$cfoldl1
  = \ (@ a_X6M2M)
      (@ a1_a6LN8)
      _ [Occ=Dead]
      (xs_X6KoF :: Either a_X6M2M a1_a6LN8) ->
      case xs_X6KoF of {
        Left ds_d6M9a -> Data.Foldable.$fFoldable:.:2 @ a1_a6LN8;
        Right y_a6K8r -> y_a6K8r
      }

-- RHS size: {terms: 11, types: 15, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableEither_$cfold
  :: forall a m. Monoid m => Either a m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X6M2O)
                 (@ m_a6LM4)
                 ($dMonoid_a6LM6 [Occ=Once] :: Monoid m_a6LM4)
                 (ds_d6M91 [Occ=Once!] :: Either a_X6M2O m_a6LM4) ->
                 case ds_d6M91 of {
                   Left _ [Occ=Dead] -> mempty @ m_a6LM4 $dMonoid_a6LM6;
                   Right y_a6K8r [Occ=Once] -> y_a6K8r
                 }}]
Data.Foldable.$fFoldableEither_$cfold
  = \ (@ a_X6M2O)
      (@ m_a6LM4)
      ($dMonoid_a6LM6 :: Monoid m_a6LM4)
      (ds_d6M91 :: Either a_X6M2O m_a6LM4) ->
      case ds_d6M91 of {
        Left ds1_d6M9a -> mempty @ m_a6LM4 $dMonoid_a6LM6;
        Right y_a6K8r -> y_a6K8r
      }

-- RHS size: {terms: 11, types: 15, coercions: 6, joins: 0/0}
Data.Foldable.$fFoldableEither1
  :: forall a1 a2. Num a2 => Either a1 a2 -> Product a2
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X6M2P)
                 (@ a1_a6LOh)
                 ($dNum_a6LOj [Occ=Once] :: Num a1_a6LOh)
                 (ds_d6M91 [Occ=Once!] :: Either a_X6M2P a1_a6LOh) ->
                 case ds_d6M91 of {
                   Left _ [Occ=Dead] ->
                     (Data.Semigroup.Internal.$fMonoidProduct2 @ a1_a6LOh $dNum_a6LOj)
                     `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a1_a6LOh>_R)
                             :: (a1_a6LOh :: *) ~R# (Product a1_a6LOh :: *));
                   Right y_a6K8r [Occ=Once] ->
                     y_a6K8r
                     `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a1_a6LOh>_R)
                             :: (a1_a6LOh :: *) ~R# (Product a1_a6LOh :: *))
                 }}]
Data.Foldable.$fFoldableEither1
  = \ (@ a_X6M2P)
      (@ a1_a6LOh)
      ($dNum_a6LOj :: Num a1_a6LOh)
      (ds_d6M91 :: Either a_X6M2P a1_a6LOh) ->
      case ds_d6M91 of {
        Left ds1_d6M9a ->
          (Data.Semigroup.Internal.$fMonoidProduct2 @ a1_a6LOh $dNum_a6LOj)
          `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a1_a6LOh>_R)
                  :: (a1_a6LOh :: *) ~R# (Product a1_a6LOh :: *));
        Right y_a6K8r ->
          y_a6K8r
          `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a1_a6LOh>_R)
                  :: (a1_a6LOh :: *) ~R# (Product a1_a6LOh :: *))
      }

-- RHS size: {terms: 11, types: 15, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableEither_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a1 a2. Either a1 a2 -> [a2]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_X6M2U)
                 (@ a1_a6LNg)
                 (t_a6K7V [Occ=Once] :: Either a_X6M2U a1_a6LNg) ->
                 build
                   @ a1_a6LNg
                   (\ (@ b_a6KNB)
                      (c_a6K7W [Occ=Once, OS=OneShot] :: a1_a6LNg -> b_a6KNB -> b_a6KNB)
                      (n_a6K7X [Occ=Once, OS=OneShot] :: b_a6KNB) ->
                      Data.Foldable.$fFoldableEither_$cfoldr
                        @ a_X6M2U @ a1_a6LNg @ b_a6KNB c_a6K7W n_a6K7X t_a6K7V)}]
Data.Foldable.$fFoldableEither_$ctoList
  = \ (@ a_X6M2U)
      (@ a1_a6LNg)
      (eta_XgX :: Either a_X6M2U a1_a6LNg) ->
      case eta_XgX of {
        Left ds_d6M9k -> GHC.Types.[] @ a1_a6LNg;
        Right y_a6K8v ->
          GHC.Types.: @ a1_a6LNg y_a6K8v (GHC.Types.[] @ a1_a6LNg)
      }

-- RHS size: {terms: 18, types: 20, coercions: 24, joins: 0/0}
Data.Foldable.$fFoldableEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Foldable (Either a)
[GblId[DFunId],
 Unf=DFun: \ (@ a_a6K8p) ->
       Data.Foldable.C:Foldable TYPE: Either a_a6K8p
                                Data.Foldable.$fFoldableEither_$cfold @ a_a6K8p
                                Data.Foldable.$fFoldableEither_$cfoldMap @ a_a6K8p
                                Data.Foldable.$fFoldableEither_$cfoldr @ a_a6K8p
                                Data.Foldable.$fFoldableEither_$cfoldr @ a_a6K8p
                                Data.Foldable.$fFoldableEither_$cfoldl' @ a_a6K8p
                                Data.Foldable.$fFoldableEither_$cfoldl' @ a_a6K8p
                                Data.Foldable.$fFoldableEither_$cfoldr1 @ a_a6K8p
                                Data.Foldable.$fFoldableEither_$cfoldl1 @ a_a6K8p
                                Data.Foldable.$fFoldableEither_$ctoList @ a_a6K8p
                                isLeft @ a_a6K8p
                                Data.Foldable.$fFoldableEither_$clength @ a_a6K8p
                                Data.Foldable.$fFoldableEither_$celem @ a_a6K8p
                                Data.Foldable.$fFoldableEither_$cmaximum @ a_a6K8p
                                Data.Foldable.$fFoldableEither_$cminimum @ a_a6K8p
                                (Data.Foldable.$fFoldableEither2 @ a_a6K8p)
                                `cast` (forall (a1 :: <*>_N).
                                        <Num a1>_R
                                        ->_R <Either a_a6K8p a1>_R
                                        ->_R Data.Semigroup.Internal.N:Sum[0] <a1>_R
                                        :: (forall a1. Num a1 => Either a_a6K8p a1 -> Sum a1 :: *)
                                           ~R# (forall a1. Num a1 => Either a_a6K8p a1 -> a1 :: *))
                                (Data.Foldable.$fFoldableEither1 @ a_a6K8p)
                                `cast` (forall (a1 :: <*>_N).
                                        <Num a1>_R
                                        ->_R <Either a_a6K8p a1>_R
                                        ->_R Data.Semigroup.Internal.N:Product[0] <a1>_R
                                        :: (forall a1.
                                            Num a1 =>
                                            Either a_a6K8p a1 -> Product a1 :: *)
                                           ~R# (forall a1. Num a1 => Either a_a6K8p a1 -> a1 :: *))]
Data.Foldable.$fFoldableEither
  = \ (@ a_X6M2V) ->
      Data.Foldable.C:Foldable
        @ (Either a_X6M2V)
        (Data.Foldable.$fFoldableEither_$cfold @ a_X6M2V)
        (Data.Foldable.$fFoldableEither_$cfoldMap @ a_X6M2V)
        (Data.Foldable.$fFoldableEither_$cfoldr @ a_X6M2V)
        (Data.Foldable.$fFoldableEither_$cfoldr @ a_X6M2V)
        (Data.Foldable.$fFoldableEither_$cfoldl' @ a_X6M2V)
        (Data.Foldable.$fFoldableEither_$cfoldl' @ a_X6M2V)
        (Data.Foldable.$fFoldableEither_$cfoldr1 @ a_X6M2V)
        (Data.Foldable.$fFoldableEither_$cfoldl1 @ a_X6M2V)
        (Data.Foldable.$fFoldableEither_$ctoList @ a_X6M2V)
        (isLeft @ a_X6M2V)
        (Data.Foldable.$fFoldableEither_$clength @ a_X6M2V)
        (Data.Foldable.$fFoldableEither_$celem @ a_X6M2V)
        (Data.Foldable.$fFoldableEither_$cmaximum @ a_X6M2V)
        (Data.Foldable.$fFoldableEither_$cminimum @ a_X6M2V)
        ((Data.Foldable.$fFoldableEither2 @ a_X6M2V)
         `cast` (forall (a1 :: <*>_N).
                 <Num a1>_R
                 ->_R <Either a_X6M2V a1>_R
                 ->_R Data.Semigroup.Internal.N:Sum[0] <a1>_R
                 :: (forall a1. Num a1 => Either a_X6M2V a1 -> Sum a1 :: *)
                    ~R# (forall a1. Num a1 => Either a_X6M2V a1 -> a1 :: *)))
        ((Data.Foldable.$fFoldableEither1 @ a_X6M2V)
         `cast` (forall (a1 :: <*>_N).
                 <Num a1>_R
                 ->_R <Either a_X6M2V a1>_R
                 ->_R Data.Semigroup.Internal.N:Product[0] <a1>_R
                 :: (forall a1. Num a1 => Either a_X6M2V a1 -> Product a1 :: *)
                    ~R# (forall a1. Num a1 => Either a_X6M2V a1 -> a1 :: *)))

-- RHS size: {terms: 37, types: 32, coercions: 0, joins: 1/2}
Data.Foldable.$fFoldableNonEmpty_$celem
  :: forall a. Eq a => a -> NonEmpty a -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 178 60}]
Data.Foldable.$fFoldableNonEmpty_$celem
  = \ (@ a_a6LQe) ($dEq_a6LQg :: Eq a_a6LQe) (eta_XgZ :: a_a6LQe) ->
      let {
        f_s6MId [Dmd=<L,C(U)>] :: a_a6LQe -> Bool
        [LclId]
        f_s6MId = == @ a_a6LQe $dEq_a6LQg eta_XgZ } in
      \ (ds_d6M9R :: NonEmpty a_a6LQe) ->
        case f_s6MId
               (case ds_d6M9R of { :| a1_a6K8I as_a6K8J -> a1_a6K8I })
        of {
          False ->
            case ds_d6M9R of { :| a1_a6K8I as_a6K8J ->
            joinrec {
              go_i6HCY [Occ=LoopBreaker] :: [a_a6LQe] -> Bool
              [LclId[JoinId(1)], Arity=1, Str=<S,1*U>, Unf=OtherCon []]
              go_i6HCY (ds1_i6HCZ :: [a_a6LQe])
                = case ds1_i6HCZ of {
                    [] -> GHC.Types.False;
                    : y_i6HD4 ys_i6HD5 ->
                      case f_s6MId y_i6HD4 of {
                        False -> jump go_i6HCY ys_i6HD5;
                        True -> GHC.Types.True
                      }
                  }; } in
            jump go_i6HCY as_a6K8J
            };
          True -> GHC.Types.True
        }

-- RHS size: {terms: 30, types: 31, coercions: 10, joins: 0/2}
Data.Foldable.$fFoldableNonEmpty_$csum
  :: forall a. Num a => NonEmpty a -> a
[GblId,
 Arity=2,
 Str=<S(C(C(S))LLLLLL),U(C(C1(U)),A,A,A,A,A,1*C1(U))><L,U(1*U,1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 40] 220 0}]
Data.Foldable.$fFoldableNonEmpty_$csum
  = \ (@ a_a6LQI)
      ($dNum_a6LQK :: Num a_a6LQI)
      (ds_d6M9R :: NonEmpty a_a6LQI) ->
      + @ a_a6LQI
        $dNum_a6LQK
        (case ds_d6M9R of { :| a1_a6K8I as_a6K8J -> a1_a6K8I })
        (case ds_d6M9R of { :| a1_a6K8I as_a6K8J ->
         let {
           z_s6NmT :: a_a6LQI
           [LclId]
           z_s6NmT
             = fromInteger
                 @ a_a6LQI $dNum_a6LQK Data.Semigroup.Internal.$fMonoidSum1 } in
         letrec {
           go_i6HCY [Occ=LoopBreaker] :: [a_a6LQI] -> Sum a_a6LQI
           [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
           go_i6HCY
             = \ (ds1_i6HCZ :: [a_a6LQI]) ->
                 case ds1_i6HCZ of {
                   [] ->
                     z_s6NmT
                     `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6LQI>_R)
                             :: (a_a6LQI :: *) ~R# (Sum a_a6LQI :: *));
                   : y_i6HD4 ys_i6HD5 ->
                     (+ @ a_a6LQI
                        $dNum_a6LQK
                        y_i6HD4
                        ((go_i6HCY ys_i6HD5)
                         `cast` (Data.Semigroup.Internal.N:Sum[0] <a_a6LQI>_R
                                 :: (Sum a_a6LQI :: *) ~R# (a_a6LQI :: *))))
                     `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6LQI>_R)
                             :: (a_a6LQI :: *) ~R# (Sum a_a6LQI :: *))
                 }; } in
         (go_i6HCY as_a6K8J)
         `cast` (Data.Semigroup.Internal.N:Sum[0] <a_a6LQI>_R
                 :: (Sum a_a6LQI :: *) ~R# (a_a6LQI :: *))
         })

-- RHS size: {terms: 43, types: 31, coercions: 16, joins: 0/1}
Data.Foldable.$w$cminimum1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. Ord a => a -> [a] -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 260 0}]
Data.Foldable.$w$cminimum1
  = \ (@ a_s6NYC)
      (w_s6NYD :: Ord a_s6NYC)
      (ww_s6NYH :: a_s6NYC)
      (ww1_s6NYI :: [a_s6NYC]) ->
      letrec {
        go_i6HCY [Occ=LoopBreaker] :: [a_s6NYC] -> Min a_s6NYC
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_i6HCY
          = \ (ds_i6HCZ :: [a_s6NYC]) ->
              case ds_i6HCZ of {
                [] ->
                  (GHC.Base.Nothing @ a_s6NYC)
                  `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_s6NYC>_N
                          :: (Maybe a_s6NYC :: *) ~R# (Min a_s6NYC :: *));
                : y_i6HD4 ys_i6HD5 ->
                  case (go_i6HCY ys_i6HD5)
                       `cast` (Data.Functor.Utils.N:Min[0] <a_s6NYC>_N
                               :: (Min a_s6NYC :: *) ~R# (Maybe a_s6NYC :: *))
                  of wild1_i6MjL {
                    Nothing ->
                      (GHC.Base.Just @ a_s6NYC y_i6HD4)
                      `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_s6NYC>_N
                              :: (Maybe a_s6NYC :: *) ~R# (Min a_s6NYC :: *));
                    Just ipv_i6MjP ->
                      case <= @ a_s6NYC w_s6NYD y_i6HD4 ipv_i6MjP of {
                        False ->
                          wild1_i6MjL
                          `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_s6NYC>_N
                                  :: (Maybe a_s6NYC :: *) ~R# (Min a_s6NYC :: *));
                        True ->
                          (GHC.Base.Just @ a_s6NYC y_i6HD4)
                          `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a_s6NYC>_N
                                  :: (Maybe a_s6NYC :: *) ~R# (Min a_s6NYC :: *))
                      }
                  }
              }; } in
      case (go_i6HCY ww1_s6NYI)
           `cast` (Data.Functor.Utils.N:Min[0] <a_s6NYC>_N
                   :: (Min a_s6NYC :: *) ~R# (Maybe a_s6NYC :: *))
      of {
        Nothing -> ww_s6NYH;
        Just ipv_i6MjP ->
          case <= @ a_s6NYC w_s6NYD ww_s6NYH ipv_i6MjP of {
            False -> ipv_i6MjP;
            True -> ww_s6NYH
          }
      }

-- RHS size: {terms: 10, types: 12, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableNonEmpty_$cminimum [InlPrag=NOUSERINLINE[0]]
  :: forall a. Ord a => NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,C(C1(U)),A,A,A,A)><S(LS),1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6NYC)
                 (w_s6NYD [Occ=Once] :: Ord a_s6NYC)
                 (w1_s6NYE [Occ=Once!] :: NonEmpty a_s6NYC) ->
                 case w1_s6NYE of { :| ww1_s6NYH [Occ=Once] ww2_s6NYI [Occ=Once] ->
                 Data.Foldable.$w$cminimum1 @ a_s6NYC w_s6NYD ww1_s6NYH ww2_s6NYI
                 }}]
Data.Foldable.$fFoldableNonEmpty_$cminimum
  = \ (@ a_s6NYC)
      (w_s6NYD :: Ord a_s6NYC)
      (w1_s6NYE :: NonEmpty a_s6NYC) ->
      case w1_s6NYE of { :| ww1_s6NYH ww2_s6NYI ->
      Data.Foldable.$w$cminimum1 @ a_s6NYC w_s6NYD ww1_s6NYH ww2_s6NYI
      }

-- RHS size: {terms: 43, types: 31, coercions: 16, joins: 0/1}
Data.Foldable.$w$cmaximum1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. Ord a => a -> [a] -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 260 0}]
Data.Foldable.$w$cmaximum1
  = \ (@ a_s6NYM)
      (w_s6NYN :: Ord a_s6NYM)
      (ww_s6NYR :: a_s6NYM)
      (ww1_s6NYS :: [a_s6NYM]) ->
      letrec {
        go_i6HCY [Occ=LoopBreaker] :: [a_s6NYM] -> Max a_s6NYM
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_i6HCY
          = \ (ds_i6HCZ :: [a_s6NYM]) ->
              case ds_i6HCZ of {
                [] ->
                  (GHC.Base.Nothing @ a_s6NYM)
                  `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_s6NYM>_N
                          :: (Maybe a_s6NYM :: *) ~R# (Max a_s6NYM :: *));
                : y_i6HD4 ys_i6HD5 ->
                  case (go_i6HCY ys_i6HD5)
                       `cast` (Data.Functor.Utils.N:Max[0] <a_s6NYM>_N
                               :: (Max a_s6NYM :: *) ~R# (Maybe a_s6NYM :: *))
                  of wild1_i6Mjl {
                    Nothing ->
                      (GHC.Base.Just @ a_s6NYM y_i6HD4)
                      `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_s6NYM>_N
                              :: (Maybe a_s6NYM :: *) ~R# (Max a_s6NYM :: *));
                    Just ipv_i6Mjp ->
                      case >= @ a_s6NYM w_s6NYN y_i6HD4 ipv_i6Mjp of {
                        False ->
                          wild1_i6Mjl
                          `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_s6NYM>_N
                                  :: (Maybe a_s6NYM :: *) ~R# (Max a_s6NYM :: *));
                        True ->
                          (GHC.Base.Just @ a_s6NYM y_i6HD4)
                          `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a_s6NYM>_N
                                  :: (Maybe a_s6NYM :: *) ~R# (Max a_s6NYM :: *))
                      }
                  }
              }; } in
      case (go_i6HCY ww1_s6NYS)
           `cast` (Data.Functor.Utils.N:Max[0] <a_s6NYM>_N
                   :: (Max a_s6NYM :: *) ~R# (Maybe a_s6NYM :: *))
      of {
        Nothing -> ww_s6NYR;
        Just ipv_i6Mjp ->
          case >= @ a_s6NYM w_s6NYN ww_s6NYR ipv_i6Mjp of {
            False -> ipv_i6Mjp;
            True -> ww_s6NYR
          }
      }

-- RHS size: {terms: 10, types: 12, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableNonEmpty_$cmaximum [InlPrag=NOUSERINLINE[0]]
  :: forall a. Ord a => NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,A,A,A,C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6NYM)
                 (w_s6NYN [Occ=Once] :: Ord a_s6NYM)
                 (w1_s6NYO [Occ=Once!] :: NonEmpty a_s6NYM) ->
                 case w1_s6NYO of { :| ww1_s6NYR [Occ=Once] ww2_s6NYS [Occ=Once] ->
                 Data.Foldable.$w$cmaximum1 @ a_s6NYM w_s6NYN ww1_s6NYR ww2_s6NYS
                 }}]
Data.Foldable.$fFoldableNonEmpty_$cmaximum
  = \ (@ a_s6NYM)
      (w_s6NYN :: Ord a_s6NYM)
      (w1_s6NYO :: NonEmpty a_s6NYM) ->
      case w1_s6NYO of { :| ww1_s6NYR ww2_s6NYS ->
      Data.Foldable.$w$cmaximum1 @ a_s6NYM w_s6NYN ww1_s6NYR ww2_s6NYS
      }

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableNonEmpty_$cnull
  :: forall a. NonEmpty a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LPT) _ [Occ=Dead] -> GHC.Types.False}]
Data.Foldable.$fFoldableNonEmpty_$cnull
  = \ (@ a_a6LPT) _ [Occ=Dead] -> GHC.Types.False

-- RHS size: {terms: 30, types: 27, coercions: 0, joins: 0/1}
Data.Foldable.$w$cfoldr2 [InlPrag=NOUSERINLINE[0]]
  :: forall a. (a -> a -> a) -> a -> [a] -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 190 0}]
Data.Foldable.$w$cfoldr2
  = \ (@ a_s6NYW)
      (w_s6NYX :: a_s6NYW -> a_s6NYW -> a_s6NYW)
      (ww_s6NZ1 :: a_s6NYW)
      (ww1_s6NZ2 :: [a_s6NYW]) ->
      letrec {
        go_i6HCY [Occ=LoopBreaker] :: [a_s6NYW] -> Maybe a_s6NYW
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_i6HCY
          = \ (ds_i6HCZ :: [a_s6NYW]) ->
              case ds_i6HCZ of {
                [] -> GHC.Base.Nothing @ a_s6NYW;
                : y_i6HD4 ys_i6HD5 ->
                  GHC.Base.Just
                    @ a_s6NYW
                    (case go_i6HCY ys_i6HD5 of {
                       Nothing -> y_i6HD4;
                       Just y1_a6K7O -> w_s6NYX y_i6HD4 y1_a6K7O
                     })
              }; } in
      case go_i6HCY ww1_s6NZ2 of {
        Nothing -> ww_s6NZ1;
        Just y_a6K7O -> w_s6NYX ww_s6NZ1 y_a6K7O
      }

-- RHS size: {terms: 10, types: 13, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableNonEmpty_$cfoldr1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. (a -> a -> a) -> NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S(LS),1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6NYW)
                 (w_s6NYX [Occ=Once] :: a_s6NYW -> a_s6NYW -> a_s6NYW)
                 (w1_s6NYY [Occ=Once!] :: NonEmpty a_s6NYW) ->
                 case w1_s6NYY of { :| ww1_s6NZ1 [Occ=Once] ww2_s6NZ2 [Occ=Once] ->
                 Data.Foldable.$w$cfoldr2 @ a_s6NYW w_s6NYX ww1_s6NZ1 ww2_s6NZ2
                 }}]
Data.Foldable.$fFoldableNonEmpty_$cfoldr1
  = \ (@ a_s6NYW)
      (w_s6NYX :: a_s6NYW -> a_s6NYW -> a_s6NYW)
      (w1_s6NYY :: NonEmpty a_s6NYW) ->
      case w1_s6NYY of { :| ww1_s6NZ1 ww2_s6NZ2 ->
      Data.Foldable.$w$cfoldr2 @ a_s6NYW w_s6NYX ww1_s6NZ1 ww2_s6NZ2
      }

-- RHS size: {terms: 30, types: 25, coercions: 0, joins: 1/1}
Data.Foldable.$w$cfoldl'1 [InlPrag=NOUSERINLINE[0]]
  :: forall b a. (b -> a -> b) -> b -> a -> [a] -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0 0] 112 0}]
Data.Foldable.$w$cfoldl'1
  = \ (@ b_s6NZ7)
      (@ a_s6NZ8)
      (w_s6NZ9 :: b_s6NZ7 -> a_s6NZ8 -> b_s6NZ7)
      (w1_s6NZa :: b_s6NZ7)
      (ww_s6NZe :: a_s6NZ8)
      (ww1_s6NZf :: [a_s6NZ8]) ->
      case w_s6NZ9 w1_s6NZa ww_s6NZe of vx_i6M0K { __DEFAULT ->
      joinrec {
        go_i6HCY [Occ=LoopBreaker] :: [a_s6NZ8] -> b_s6NZ7 -> b_s6NZ7
        [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
        go_i6HCY (ds_i6HCZ :: [a_s6NZ8]) (eta_B1 :: b_s6NZ7)
          = case ds_i6HCZ of {
              [] -> eta_B1;
              : y_i6HD4 ys_i6HD5 ->
                case w_s6NZ9 eta_B1 y_i6HD4 of vx1_X6MhX { __DEFAULT ->
                jump go_i6HCY ys_i6HD5 vx1_X6MhX
                }
            }; } in
      jump go_i6HCY ww1_s6NZf vx_i6M0K
      }

-- RHS size: {terms: 13, types: 17, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableNonEmpty_$cfoldl' [InlPrag=NOUSERINLINE[0]]
  :: forall b a. (b -> a -> b) -> b -> NonEmpty a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(LS),1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_s6NZ7)
                 (@ a_s6NZ8)
                 (w_s6NZ9 [Occ=Once] :: b_s6NZ7 -> a_s6NZ8 -> b_s6NZ7)
                 (w1_s6NZa [Occ=Once] :: b_s6NZ7)
                 (w2_s6NZb [Occ=Once!] :: NonEmpty a_s6NZ8) ->
                 case w2_s6NZb of { :| ww1_s6NZe [Occ=Once] ww2_s6NZf [Occ=Once] ->
                 Data.Foldable.$w$cfoldl'1
                   @ b_s6NZ7 @ a_s6NZ8 w_s6NZ9 w1_s6NZa ww1_s6NZe ww2_s6NZf
                 }}]
Data.Foldable.$fFoldableNonEmpty_$cfoldl'
  = \ (@ b_s6NZ7)
      (@ a_s6NZ8)
      (w_s6NZ9 :: b_s6NZ7 -> a_s6NZ8 -> b_s6NZ7)
      (w1_s6NZa :: b_s6NZ7)
      (w2_s6NZb :: NonEmpty a_s6NZ8) ->
      case w2_s6NZb of { :| ww1_s6NZe ww2_s6NZf ->
      Data.Foldable.$w$cfoldl'1
        @ b_s6NZ7 @ a_s6NZ8 w_s6NZ9 w1_s6NZa ww1_s6NZe ww2_s6NZf
      }

-- RHS size: {terms: 34, types: 30, coercions: 0, joins: 1/1}
Data.Foldable.$w$cfoldr'1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (a -> b -> b) -> b -> a -> [a] -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0 0] 166 0}]
Data.Foldable.$w$cfoldr'1
  = \ (@ a_s6NZl)
      (@ b_s6NZm)
      (w_s6NZn :: a_s6NZl -> b_s6NZm -> b_s6NZm)
      (w1_s6NZo :: b_s6NZm)
      (ww_s6NZs :: a_s6NZl)
      (ww1_s6NZt :: [a_s6NZl]) ->
      joinrec {
        go_i6HCY [Occ=LoopBreaker]
          :: [a_s6NZl] -> (b_s6NZm -> b_s6NZm) -> b_s6NZm -> b_s6NZm
        [LclId[JoinId(3)],
         Arity=3,
         Str=<S,1*U><C(S),1*C1(U)><L,U>,
         Unf=OtherCon []]
        go_i6HCY (ds_i6HCZ :: [a_s6NZl])
                 (eta_B1 :: b_s6NZm -> b_s6NZm)
                 (eta1_X2 :: b_s6NZm)
          = case ds_i6HCZ of {
              [] -> eta_B1 eta1_X2;
              : y_i6HD4 ys_i6HD5 ->
                jump go_i6HCY
                  ys_i6HD5
                  (\ (z_a6K7y [OS=OneShot] :: b_s6NZm) ->
                     case w_s6NZn y_i6HD4 z_a6K7y of vx_i6M0K { __DEFAULT ->
                     eta_B1 vx_i6M0K
                     })
                  eta1_X2
            }; } in
      jump go_i6HCY
        ww1_s6NZt
        (\ (z_a6K7y [OS=OneShot] :: b_s6NZm) -> w_s6NZn ww_s6NZs z_a6K7y)
        w1_s6NZo

-- RHS size: {terms: 13, types: 17, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableNonEmpty_$cfoldr' [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (a -> b -> b) -> b -> NonEmpty a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U><S(LS),1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6NZl)
                 (@ b_s6NZm)
                 (w_s6NZn [Occ=Once] :: a_s6NZl -> b_s6NZm -> b_s6NZm)
                 (w1_s6NZo [Occ=Once] :: b_s6NZm)
                 (w2_s6NZp [Occ=Once!] :: NonEmpty a_s6NZl) ->
                 case w2_s6NZp of { :| ww1_s6NZs [Occ=Once] ww2_s6NZt [Occ=Once] ->
                 Data.Foldable.$w$cfoldr'1
                   @ a_s6NZl @ b_s6NZm w_s6NZn w1_s6NZo ww1_s6NZs ww2_s6NZt
                 }}]
Data.Foldable.$fFoldableNonEmpty_$cfoldr'
  = \ (@ a_s6NZl)
      (@ b_s6NZm)
      (w_s6NZn :: a_s6NZl -> b_s6NZm -> b_s6NZm)
      (w1_s6NZo :: b_s6NZm)
      (w2_s6NZp :: NonEmpty a_s6NZl) ->
      case w2_s6NZp of { :| ww1_s6NZs ww2_s6NZt ->
      Data.Foldable.$w$cfoldr'1
        @ a_s6NZl @ b_s6NZm w_s6NZn w1_s6NZo ww1_s6NZs ww2_s6NZt
      }

-- RHS size: {terms: 30, types: 31, coercions: 10, joins: 0/2}
Data.Foldable.$fFoldableNonEmpty_$cproduct
  :: forall a. Num a => NonEmpty a -> a
[GblId,
 Arity=2,
 Str=<S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,1*C1(U))><L,U(1*U,1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 40] 220 0}]
Data.Foldable.$fFoldableNonEmpty_$cproduct
  = \ (@ a_a6LQS)
      ($dNum_a6LQU :: Num a_a6LQS)
      (ds_d6M9R :: NonEmpty a_a6LQS) ->
      * @ a_a6LQS
        $dNum_a6LQU
        (case ds_d6M9R of { :| a1_a6K8I as_a6K8J -> a1_a6K8I })
        (case ds_d6M9R of { :| a1_a6K8I as_a6K8J ->
         let {
           z_s6Nnl :: a_a6LQS
           [LclId]
           z_s6Nnl
             = fromInteger
                 @ a_a6LQS $dNum_a6LQU Data.Semigroup.Internal.$fMonoidProduct1 } in
         letrec {
           go_i6HCY [Occ=LoopBreaker] :: [a_a6LQS] -> Product a_a6LQS
           [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
           go_i6HCY
             = \ (ds1_i6HCZ :: [a_a6LQS]) ->
                 case ds1_i6HCZ of {
                   [] ->
                     z_s6Nnl
                     `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LQS>_R)
                             :: (a_a6LQS :: *) ~R# (Product a_a6LQS :: *));
                   : y_i6HD4 ys_i6HD5 ->
                     (* @ a_a6LQS
                        $dNum_a6LQU
                        y_i6HD4
                        ((go_i6HCY ys_i6HD5)
                         `cast` (Data.Semigroup.Internal.N:Product[0] <a_a6LQS>_R
                                 :: (Product a_a6LQS :: *) ~R# (a_a6LQS :: *))))
                     `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LQS>_R)
                             :: (a_a6LQS :: *) ~R# (Product a_a6LQS :: *))
                 }; } in
         (go_i6HCY as_a6K8J)
         `cast` (Data.Semigroup.Internal.N:Product[0] <a_a6LQS>_R
                 :: (Product a_a6LQS :: *) ~R# (a_a6LQS :: *))
         })

-- RHS size: {terms: 17, types: 1, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable NonEmpty
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: NonEmpty
                                Data.Foldable.$fFoldableNonEmpty_$cfold
                                Data.Foldable.$fFoldableNonEmpty_$cfoldMap
                                Data.Foldable.$fFoldableNonEmpty_$cfoldr
                                Data.Foldable.$fFoldableNonEmpty_$cfoldr'
                                Data.Foldable.$fFoldableNonEmpty_$cfoldl
                                Data.Foldable.$fFoldableNonEmpty_$cfoldl'
                                Data.Foldable.$fFoldableNonEmpty_$cfoldr1
                                Data.Foldable.$fFoldableNonEmpty_$cfoldl1
                                Data.Foldable.$fFoldableNonEmpty_$ctoList
                                Data.Foldable.$fFoldableNonEmpty_$cnull
                                Data.Foldable.$fFoldableNonEmpty_$clength
                                Data.Foldable.$fFoldableNonEmpty_$celem
                                Data.Foldable.$fFoldableNonEmpty_$cmaximum
                                Data.Foldable.$fFoldableNonEmpty_$cminimum
                                Data.Foldable.$fFoldableNonEmpty_$csum
                                Data.Foldable.$fFoldableNonEmpty_$cproduct]
Data.Foldable.$fFoldableNonEmpty
  = Data.Foldable.C:Foldable
      @ NonEmpty
      Data.Foldable.$fFoldableNonEmpty_$cfold
      Data.Foldable.$fFoldableNonEmpty_$cfoldMap
      Data.Foldable.$fFoldableNonEmpty_$cfoldr
      Data.Foldable.$fFoldableNonEmpty_$cfoldr'
      Data.Foldable.$fFoldableNonEmpty_$cfoldl
      Data.Foldable.$fFoldableNonEmpty_$cfoldl'
      Data.Foldable.$fFoldableNonEmpty_$cfoldr1
      Data.Foldable.$fFoldableNonEmpty_$cfoldl1
      Data.Foldable.$fFoldableNonEmpty_$ctoList
      Data.Foldable.$fFoldableNonEmpty_$cnull
      Data.Foldable.$fFoldableNonEmpty_$clength
      Data.Foldable.$fFoldableNonEmpty_$celem
      Data.Foldable.$fFoldableNonEmpty_$cmaximum
      Data.Foldable.$fFoldableNonEmpty_$cminimum
      Data.Foldable.$fFoldableNonEmpty_$csum
      Data.Foldable.$fFoldableNonEmpty_$cproduct

-- RHS size: {terms: 15, types: 13, coercions: 8, joins: 0/1}
Data.Foldable.$fFoldableMaybe_$celem
  :: forall a. Eq a => a -> Maybe a -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LV4)
                 ($dEq_a6LV6 [Occ=Once] :: Eq a_a6LV4)
                 (eta_Xh9 [Occ=Once] :: a_a6LV4) ->
                 let {
                   eta1_s6MHX [Occ=OnceL!] :: a_a6LV4 -> Bool
                   [LclId]
                   eta1_s6MHX = == @ a_a6LV4 $dEq_a6LV6 eta_Xh9 } in
                 (\ (eta2_X6 [Occ=Once!] :: Maybe a_a6LV4) ->
                    case eta2_X6 of {
                      Nothing ->
                        GHC.Types.False
                        `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                                :: (Bool :: *) ~R# (Data.Monoid.Any :: *));
                      Just x_i6McL [Occ=Once] ->
                        (eta1_s6MHX x_i6McL)
                        `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                                :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
                    })
                 `cast` (<Maybe a_a6LV4>_R ->_R Data.Semigroup.Internal.N:Any[0]
                         :: (Maybe a_a6LV4 -> Data.Monoid.Any :: *)
                            ~R# (Maybe a_a6LV4 -> Bool :: *))}]
Data.Foldable.$fFoldableMaybe_$celem
  = \ (@ a_a6LV4) ($dEq_a6LV6 :: Eq a_a6LV4) (eta_Xh9 :: a_a6LV4) ->
      let {
        eta1_s6MHX [Dmd=<L,C(U)>] :: a_a6LV4 -> Bool
        [LclId]
        eta1_s6MHX = == @ a_a6LV4 $dEq_a6LV6 eta_Xh9 } in
      (\ (eta2_X6 :: Maybe a_a6LV4) ->
         case eta2_X6 of {
           Nothing ->
             GHC.Types.False
             `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                     :: (Bool :: *) ~R# (Data.Monoid.Any :: *));
           Just x_i6McL ->
             (eta1_s6MHX x_i6McL)
             `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                     :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
         })
      `cast` (<Maybe a_a6LV4>_R ->_R Data.Semigroup.Internal.N:Any[0]
              :: (Maybe a_a6LV4 -> Data.Monoid.Any :: *)
                 ~R# (Maybe a_a6LV4 -> Bool :: *))

-- RHS size: {terms: 10, types: 10, coercions: 6, joins: 0/0}
Data.Foldable.$fFoldableMaybe2
  :: forall a. Num a => Maybe a -> Sum a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LVy)
                 ($dNum_a6LVA [Occ=Once] :: Num a_a6LVy)
                 (eta_Xhy [Occ=Once!] :: Maybe a_a6LVy) ->
                 case eta_Xhy of {
                   Nothing ->
                     (Data.Semigroup.Internal.$fMonoidSum2 @ a_a6LVy $dNum_a6LVA)
                     `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6LVy>_R)
                             :: (a_a6LVy :: *) ~R# (Sum a_a6LVy :: *));
                   Just x_i6McL [Occ=Once] ->
                     x_i6McL
                     `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6LVy>_R)
                             :: (a_a6LVy :: *) ~R# (Sum a_a6LVy :: *))
                 }}]
Data.Foldable.$fFoldableMaybe2
  = \ (@ a_a6LVy)
      ($dNum_a6LVA :: Num a_a6LVy)
      (eta_Xhy :: Maybe a_a6LVy) ->
      case eta_Xhy of {
        Nothing ->
          (Data.Semigroup.Internal.$fMonoidSum2 @ a_a6LVy $dNum_a6LVA)
          `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6LVy>_R)
                  :: (a_a6LVy :: *) ~R# (Sum a_a6LVy :: *));
        Just x_i6McL ->
          x_i6McL
          `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6LVy>_R)
                  :: (a_a6LVy :: *) ~R# (Sum a_a6LVy :: *))
      }

-- RHS size: {terms: 8, types: 8, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableMaybe3 :: forall a. Maybe a -> a
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LVo) (x_X6HLQ [Occ=Once!] :: Maybe a_a6LVo) ->
                 case x_X6HLQ of {
                   Nothing -> Data.Foldable.$fFoldable:*:2 @ a_a6LVo;
                   Just v_i6M0Z [Occ=Once] -> v_i6M0Z
                 }}]
Data.Foldable.$fFoldableMaybe3
  = \ (@ a_a6LVo) (x_X6HLQ :: Maybe a_a6LVo) ->
      case x_X6HLQ of {
        Nothing -> Data.Foldable.$fFoldable:*:2 @ a_a6LVo;
        Just v_i6M0Z -> v_i6M0Z
      }

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableMaybe_$cminimum
  :: forall a. Ord a => Maybe a -> a
[GblId,
 Arity=2,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LVo) _ [Occ=Dead] ->
                 Data.Foldable.$fFoldableMaybe3 @ a_a6LVo}]
Data.Foldable.$fFoldableMaybe_$cminimum
  = \ (@ a_a6LVo) _ [Occ=Dead] ->
      Data.Foldable.$fFoldableMaybe3 @ a_a6LVo

-- RHS size: {terms: 8, types: 8, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableMaybe4 :: forall a. Maybe a -> a
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LVe) (x_X6HLR [Occ=Once!] :: Maybe a_a6LVe) ->
                 case x_X6HLR of {
                   Nothing -> Data.Foldable.$fFoldable:*:3 @ a_a6LVe;
                   Just v_i6M0Z [Occ=Once] -> v_i6M0Z
                 }}]
Data.Foldable.$fFoldableMaybe4
  = \ (@ a_a6LVe) (x_X6HLR :: Maybe a_a6LVe) ->
      case x_X6HLR of {
        Nothing -> Data.Foldable.$fFoldable:*:3 @ a_a6LVe;
        Just v_i6M0Z -> v_i6M0Z
      }

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableMaybe_$cmaximum
  :: forall a. Ord a => Maybe a -> a
[GblId,
 Arity=2,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LVe) _ [Occ=Dead] ->
                 Data.Foldable.$fFoldableMaybe4 @ a_a6LVe}]
Data.Foldable.$fFoldableMaybe_$cmaximum
  = \ (@ a_a6LVe) _ [Occ=Dead] ->
      Data.Foldable.$fFoldableMaybe4 @ a_a6LVe

-- RHS size: {terms: 8, types: 7, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableMaybe_$cnull :: forall a. Maybe a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LUO) (ds_d6McQ [Occ=Once!] :: Maybe a_a6LUO) ->
                 case ds_d6McQ of {
                   Nothing -> GHC.Types.True;
                   Just _ [Occ=Dead] -> GHC.Types.False
                 }}]
Data.Foldable.$fFoldableMaybe_$cnull
  = \ (@ a_a6LUO) (ds_d6McQ :: Maybe a_a6LUO) ->
      case ds_d6McQ of {
        Nothing -> GHC.Types.True;
        Just x_a6K8S -> GHC.Types.False
      }

-- RHS size: {terms: 9, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableMaybe_$cfoldl1
  :: forall a. (a -> a -> a) -> Maybe a -> a
[GblId,
 Arity=2,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LUy)
                 _ [Occ=Dead]
                 (xs_X6Kp8 [Occ=Once!] :: Maybe a_a6LUy) ->
                 case xs_X6Kp8 of {
                   Nothing -> Data.Foldable.$fFoldable:.:2 @ a_a6LUy;
                   Just v_i6M0Z [Occ=Once] -> v_i6M0Z
                 }}]
Data.Foldable.$fFoldableMaybe_$cfoldl1
  = \ (@ a_a6LUy) _ [Occ=Dead] (xs_X6Kp8 :: Maybe a_a6LUy) ->
      case xs_X6Kp8 of {
        Nothing -> Data.Foldable.$fFoldable:.:2 @ a_a6LUy;
        Just v_i6M0Z -> v_i6M0Z
      }

-- RHS size: {terms: 9, types: 11, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableMaybe_$cfoldr1
  :: forall a. (a -> a -> a) -> Maybe a -> a
[GblId,
 Arity=2,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LUq)
                 _ [Occ=Dead]
                 (xs_a6K7K [Occ=Once!] :: Maybe a_a6LUq) ->
                 case xs_a6K7K of {
                   Nothing -> Data.Foldable.$fFoldable:.:3 @ a_a6LUq;
                   Just v_i6M0Z [Occ=Once] -> v_i6M0Z
                 }}]
Data.Foldable.$fFoldableMaybe_$cfoldr1
  = \ (@ a_a6LUq) _ [Occ=Dead] (xs_a6K7K :: Maybe a_a6LUq) ->
      case xs_a6K7K of {
        Nothing -> Data.Foldable.$fFoldable:.:3 @ a_a6LUq;
        Just v_i6M0Z -> v_i6M0Z
      }

-- RHS size: {terms: 8, types: 7, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableMaybe_$clength :: forall a. Maybe a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LUW) (xs_a6K7E [Occ=Once!] :: Maybe a_a6LUW) ->
                 case xs_a6K7E of {
                   Nothing -> Data.Foldable.$fFoldable:*:4;
                   Just _ [Occ=Dead] -> GHC.Types.I# 1#
                 }}]
Data.Foldable.$fFoldableMaybe_$clength
  = \ (@ a_a6LUW) (xs_a6K7E :: Maybe a_a6LUW) ->
      case xs_a6K7E of {
        Nothing -> Data.Foldable.$fFoldable:*:4;
        Just x_a6K8S -> Data.Foldable.$fFoldableDual3
      }

-- RHS size: {terms: 10, types: 10, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableMaybe_$cfold
  :: forall m. Monoid m => Maybe m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_a6LTv)
                 ($dMonoid_a6LTx [Occ=Once] :: Monoid m_a6LTv)
                 (eta_Xho [Occ=Once!] :: Maybe m_a6LTv) ->
                 case eta_Xho of {
                   Nothing -> mempty @ m_a6LTv $dMonoid_a6LTx;
                   Just x_i6McL [Occ=Once] -> x_i6McL
                 }}]
Data.Foldable.$fFoldableMaybe_$cfold
  = \ (@ m_a6LTv)
      ($dMonoid_a6LTx :: Monoid m_a6LTv)
      (eta_Xho :: Maybe m_a6LTv) ->
      case eta_Xho of {
        Nothing -> mempty @ m_a6LTv $dMonoid_a6LTx;
        Just x_i6McL -> x_i6McL
      }

-- RHS size: {terms: 10, types: 10, coercions: 6, joins: 0/0}
Data.Foldable.$fFoldableMaybe1
  :: forall a. Num a => Maybe a -> Product a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LVI)
                 ($dNum_a6LVK [Occ=Once] :: Num a_a6LVI)
                 (eta_Xhm [Occ=Once!] :: Maybe a_a6LVI) ->
                 case eta_Xhm of {
                   Nothing ->
                     (Data.Semigroup.Internal.$fMonoidProduct2 @ a_a6LVI $dNum_a6LVK)
                     `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LVI>_R)
                             :: (a_a6LVI :: *) ~R# (Product a_a6LVI :: *));
                   Just x_i6McL [Occ=Once] ->
                     x_i6McL
                     `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LVI>_R)
                             :: (a_a6LVI :: *) ~R# (Product a_a6LVI :: *))
                 }}]
Data.Foldable.$fFoldableMaybe1
  = \ (@ a_a6LVI)
      ($dNum_a6LVK :: Num a_a6LVI)
      (eta_Xhm :: Maybe a_a6LVI) ->
      case eta_Xhm of {
        Nothing ->
          (Data.Semigroup.Internal.$fMonoidProduct2 @ a_a6LVI $dNum_a6LVK)
          `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LVI>_R)
                  :: (a_a6LVI :: *) ~R# (Product a_a6LVI :: *));
        Just x_i6McL ->
          x_i6McL
          `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LVI>_R)
                  :: (a_a6LVI :: *) ~R# (Product a_a6LVI :: *))
      }

-- RHS size: {terms: 10, types: 10, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableMaybe_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Maybe a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a6LUG) (t_a6K7V [Occ=Once] :: Maybe a_a6LUG) ->
                 build
                   @ a_a6LUG
                   (\ (@ b_a6KNB)
                      (c_a6K7W [Occ=Once, OS=OneShot] :: a_a6LUG -> b_a6KNB -> b_a6KNB)
                      (n_a6K7X [Occ=Once, OS=OneShot] :: b_a6KNB) ->
                      Data.Foldable.$fFoldableMaybe_$cfoldr
                        @ a_a6LUG @ b_a6KNB c_a6K7W n_a6K7X t_a6K7V)}]
Data.Foldable.$fFoldableMaybe_$ctoList
  = \ (@ a_a6LUG) (eta_Xhs :: Maybe a_a6LUG) ->
      case eta_Xhs of {
        Nothing -> GHC.Types.[] @ a_a6LUG;
        Just x_a6K8S ->
          GHC.Types.: @ a_a6LUG x_a6K8S (GHC.Types.[] @ a_a6LUG)
      }

-- RHS size: {terms: 17, types: 1, coercions: 22, joins: 0/0}
Data.Foldable.$fFoldableMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable Maybe
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: Maybe
                                Data.Foldable.$fFoldableMaybe_$cfold
                                Data.Foldable.$fFoldableMaybe_$cfoldMap
                                Data.Foldable.$fFoldableMaybe_$cfoldr
                                Data.Foldable.$fFoldableMaybe_$cfoldr
                                Data.Foldable.$fFoldableMaybe_$cfoldl
                                Data.Foldable.$fFoldableMaybe_$cfoldl
                                Data.Foldable.$fFoldableMaybe_$cfoldr1
                                Data.Foldable.$fFoldableMaybe_$cfoldl1
                                Data.Foldable.$fFoldableMaybe_$ctoList
                                Data.Foldable.$fFoldableMaybe_$cnull
                                Data.Foldable.$fFoldableMaybe_$clength
                                Data.Foldable.$fFoldableMaybe_$celem
                                Data.Foldable.$fFoldableMaybe_$cmaximum
                                Data.Foldable.$fFoldableMaybe_$cminimum
                                Data.Foldable.$fFoldableMaybe2
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <Maybe a>_R
                                        ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
                                        :: (forall a. Num a => Maybe a -> Sum a :: *)
                                           ~R# (forall a. Num a => Maybe a -> a :: *))
                                Data.Foldable.$fFoldableMaybe1
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <Maybe a>_R
                                        ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
                                        :: (forall a. Num a => Maybe a -> Product a :: *)
                                           ~R# (forall a. Num a => Maybe a -> a :: *))]
Data.Foldable.$fFoldableMaybe
  = Data.Foldable.C:Foldable
      @ Maybe
      Data.Foldable.$fFoldableMaybe_$cfold
      Data.Foldable.$fFoldableMaybe_$cfoldMap
      Data.Foldable.$fFoldableMaybe_$cfoldr
      Data.Foldable.$fFoldableMaybe_$cfoldr
      Data.Foldable.$fFoldableMaybe_$cfoldl
      Data.Foldable.$fFoldableMaybe_$cfoldl
      Data.Foldable.$fFoldableMaybe_$cfoldr1
      Data.Foldable.$fFoldableMaybe_$cfoldl1
      Data.Foldable.$fFoldableMaybe_$ctoList
      Data.Foldable.$fFoldableMaybe_$cnull
      Data.Foldable.$fFoldableMaybe_$clength
      Data.Foldable.$fFoldableMaybe_$celem
      Data.Foldable.$fFoldableMaybe_$cmaximum
      Data.Foldable.$fFoldableMaybe_$cminimum
      (Data.Foldable.$fFoldableMaybe2
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <Maybe a>_R
               ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall a. Num a => Maybe a -> Sum a :: *)
                  ~R# (forall a. Num a => Maybe a -> a :: *)))
      (Data.Foldable.$fFoldableMaybe1
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <Maybe a>_R
               ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall a. Num a => Maybe a -> Product a :: *)
                  ~R# (forall a. Num a => Maybe a -> a :: *)))

-- RHS size: {terms: 13, types: 14, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableLast_$cfoldMap
  :: forall m a. Monoid m => (a -> m) -> Last a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_a6Lt9)
                 (@ a_a6Lta)
                 ($dMonoid_a6Ltc [Occ=Once] :: Monoid m_a6Lt9)
                 (f_a6K81 [Occ=Once!] :: a_a6Lta -> m_a6Lt9)
                 (x_i6HAl [Occ=Once] :: Last a_a6Lta) ->
                 case x_i6HAl
                      `cast` (Data.Monoid.N:Last[0] <a_a6Lta>_N
                              :: (Last a_a6Lta :: *) ~R# (Maybe a_a6Lta :: *))
                 of {
                   Nothing -> mempty @ m_a6Lt9 $dMonoid_a6Ltc;
                   Just x1_i6McL [Occ=Once] -> f_a6K81 x1_i6McL
                 }}]
Data.Foldable.$fFoldableLast_$cfoldMap
  = \ (@ m_a6Lt9)
      (@ a_a6Lta)
      ($dMonoid_a6Ltc :: Monoid m_a6Lt9)
      (f_a6K81 :: a_a6Lta -> m_a6Lt9)
      (x_i6HAl :: Last a_a6Lta) ->
      case x_i6HAl
           `cast` (Data.Monoid.N:Last[0] <a_a6Lta>_N
                   :: (Last a_a6Lta :: *) ~R# (Maybe a_a6Lta :: *))
      of {
        Nothing -> mempty @ m_a6Lt9 $dMonoid_a6Ltc;
        Just x1_i6McL -> f_a6K81 x1_i6McL
      }

-- RHS size: {terms: 10, types: 10, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableLast_$cfold
  :: forall m. Monoid m => Last m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_a6LsZ)
                 ($dMonoid_a6Lt1 [Occ=Once] :: Monoid m_a6LsZ)
                 (x_i6HAl [Occ=Once] :: Last m_a6LsZ) ->
                 case x_i6HAl
                      `cast` (Data.Monoid.N:Last[0] <m_a6LsZ>_N
                              :: (Last m_a6LsZ :: *) ~R# (Maybe m_a6LsZ :: *))
                 of {
                   Nothing -> mempty @ m_a6LsZ $dMonoid_a6Lt1;
                   Just x1_i6McL [Occ=Once] -> x1_i6McL
                 }}]
Data.Foldable.$fFoldableLast_$cfold
  = \ (@ m_a6LsZ)
      ($dMonoid_a6Lt1 :: Monoid m_a6LsZ)
      (x_i6HAl :: Last m_a6LsZ) ->
      case x_i6HAl
           `cast` (Data.Monoid.N:Last[0] <m_a6LsZ>_N
                   :: (Last m_a6LsZ :: *) ~R# (Maybe m_a6LsZ :: *))
      of {
        Nothing -> mempty @ m_a6LsZ $dMonoid_a6Lt1;
        Just x1_i6McL -> x1_i6McL
      }

-- RHS size: {terms: 10, types: 10, coercions: 8, joins: 0/0}
Data.Foldable.$fFoldableLast2 :: forall a. Num a => Last a -> Sum a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6Lvc)
                 ($dNum_a6Lve [Occ=Once] :: Num a_a6Lvc)
                 (x_i6HAl [Occ=Once] :: Last a_a6Lvc) ->
                 case x_i6HAl
                      `cast` (Data.Monoid.N:Last[0] <a_a6Lvc>_N
                              :: (Last a_a6Lvc :: *) ~R# (Maybe a_a6Lvc :: *))
                 of {
                   Nothing ->
                     (Data.Semigroup.Internal.$fMonoidSum2 @ a_a6Lvc $dNum_a6Lve)
                     `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6Lvc>_R)
                             :: (a_a6Lvc :: *) ~R# (Sum a_a6Lvc :: *));
                   Just x1_i6McL [Occ=Once] ->
                     x1_i6McL
                     `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6Lvc>_R)
                             :: (a_a6Lvc :: *) ~R# (Sum a_a6Lvc :: *))
                 }}]
Data.Foldable.$fFoldableLast2
  = \ (@ a_a6Lvc)
      ($dNum_a6Lve :: Num a_a6Lvc)
      (x_i6HAl :: Last a_a6Lvc) ->
      case x_i6HAl
           `cast` (Data.Monoid.N:Last[0] <a_a6Lvc>_N
                   :: (Last a_a6Lvc :: *) ~R# (Maybe a_a6Lvc :: *))
      of {
        Nothing ->
          (Data.Semigroup.Internal.$fMonoidSum2 @ a_a6Lvc $dNum_a6Lve)
          `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6Lvc>_R)
                  :: (a_a6Lvc :: *) ~R# (Sum a_a6Lvc :: *));
        Just x1_i6McL ->
          x1_i6McL
          `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6Lvc>_R)
                  :: (a_a6Lvc :: *) ~R# (Sum a_a6Lvc :: *))
      }

-- RHS size: {terms: 8, types: 8, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableLast3 :: forall a. Last a -> a
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6Lv2) (x_X6HLQ [Occ=Once] :: Last a_a6Lv2) ->
                 case x_X6HLQ
                      `cast` (Data.Monoid.N:Last[0] <a_a6Lv2>_N
                              :: (Last a_a6Lv2 :: *) ~R# (Maybe a_a6Lv2 :: *))
                 of {
                   Nothing -> Data.Foldable.$fFoldable:*:2 @ a_a6Lv2;
                   Just v_i6M0Z [Occ=Once] -> v_i6M0Z
                 }}]
Data.Foldable.$fFoldableLast3
  = \ (@ a_a6Lv2) (x_X6HLQ :: Last a_a6Lv2) ->
      case x_X6HLQ
           `cast` (Data.Monoid.N:Last[0] <a_a6Lv2>_N
                   :: (Last a_a6Lv2 :: *) ~R# (Maybe a_a6Lv2 :: *))
      of {
        Nothing -> Data.Foldable.$fFoldable:*:2 @ a_a6Lv2;
        Just v_i6M0Z -> v_i6M0Z
      }

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableLast_$cminimum
  :: forall a. Ord a => Last a -> a
[GblId,
 Arity=2,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Lv2) _ [Occ=Dead] ->
                 Data.Foldable.$fFoldableLast3 @ a_a6Lv2}]
Data.Foldable.$fFoldableLast_$cminimum
  = \ (@ a_a6Lv2) _ [Occ=Dead] ->
      Data.Foldable.$fFoldableLast3 @ a_a6Lv2

-- RHS size: {terms: 8, types: 8, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableLast4 :: forall a. Last a -> a
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LuS) (x_X6HLR [Occ=Once] :: Last a_a6LuS) ->
                 case x_X6HLR
                      `cast` (Data.Monoid.N:Last[0] <a_a6LuS>_N
                              :: (Last a_a6LuS :: *) ~R# (Maybe a_a6LuS :: *))
                 of {
                   Nothing -> Data.Foldable.$fFoldable:*:3 @ a_a6LuS;
                   Just v_i6M0Z [Occ=Once] -> v_i6M0Z
                 }}]
Data.Foldable.$fFoldableLast4
  = \ (@ a_a6LuS) (x_X6HLR :: Last a_a6LuS) ->
      case x_X6HLR
           `cast` (Data.Monoid.N:Last[0] <a_a6LuS>_N
                   :: (Last a_a6LuS :: *) ~R# (Maybe a_a6LuS :: *))
      of {
        Nothing -> Data.Foldable.$fFoldable:*:3 @ a_a6LuS;
        Just v_i6M0Z -> v_i6M0Z
      }

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableLast_$cmaximum
  :: forall a. Ord a => Last a -> a
[GblId,
 Arity=2,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LuS) _ [Occ=Dead] ->
                 Data.Foldable.$fFoldableLast4 @ a_a6LuS}]
Data.Foldable.$fFoldableLast_$cmaximum
  = \ (@ a_a6LuS) _ [Occ=Dead] ->
      Data.Foldable.$fFoldableLast4 @ a_a6LuS

-- RHS size: {terms: 15, types: 13, coercions: 10, joins: 0/1}
Data.Foldable.$fFoldableLast_$celem
  :: forall a. Eq a => a -> Last a -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LuI)
                 ($dEq_a6LuK [Occ=Once] :: Eq a_a6LuI)
                 (eta_XhD [Occ=Once] :: a_a6LuI) ->
                 let {
                   f_s6MHN [Occ=OnceL!] :: a_a6LuI -> Bool
                   [LclId]
                   f_s6MHN = == @ a_a6LuI $dEq_a6LuK eta_XhD } in
                 (\ (x_X6HSd [Occ=Once] :: Last a_a6LuI) ->
                    case x_X6HSd
                         `cast` (Data.Monoid.N:Last[0] <a_a6LuI>_N
                                 :: (Last a_a6LuI :: *) ~R# (Maybe a_a6LuI :: *))
                    of {
                      Nothing ->
                        GHC.Types.False
                        `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                                :: (Bool :: *) ~R# (Data.Monoid.Any :: *));
                      Just x1_i6McL [Occ=Once] ->
                        (f_s6MHN x1_i6McL)
                        `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                                :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
                    })
                 `cast` (<Last a_a6LuI>_R ->_R Data.Semigroup.Internal.N:Any[0]
                         :: (Last a_a6LuI -> Data.Monoid.Any :: *)
                            ~R# (Last a_a6LuI -> Bool :: *))}]
Data.Foldable.$fFoldableLast_$celem
  = \ (@ a_a6LuI) ($dEq_a6LuK :: Eq a_a6LuI) (eta_XhD :: a_a6LuI) ->
      let {
        f_s6MHN [Dmd=<L,C(U)>] :: a_a6LuI -> Bool
        [LclId]
        f_s6MHN = == @ a_a6LuI $dEq_a6LuK eta_XhD } in
      (\ (x_X6HSd :: Last a_a6LuI) ->
         case x_X6HSd
              `cast` (Data.Monoid.N:Last[0] <a_a6LuI>_N
                      :: (Last a_a6LuI :: *) ~R# (Maybe a_a6LuI :: *))
         of {
           Nothing ->
             GHC.Types.False
             `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                     :: (Bool :: *) ~R# (Data.Monoid.Any :: *));
           Just x1_i6McL ->
             (f_s6MHN x1_i6McL)
             `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                     :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
         })
      `cast` (<Last a_a6LuI>_R ->_R Data.Semigroup.Internal.N:Any[0]
              :: (Last a_a6LuI -> Data.Monoid.Any :: *)
                 ~R# (Last a_a6LuI -> Bool :: *))

-- RHS size: {terms: 13, types: 13, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableLast_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> Last a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a6LtK)
                 (@ a_a6LtL)
                 (f_X6Kpf [Occ=Once!] :: b_a6LtK -> a_a6LtL -> b_a6LtK)
                 (z_X6Kph [Occ=Once*] :: b_a6LtK)
                 (t_X6Kpj [Occ=Once] :: Last a_a6LtL) ->
                 case t_X6Kpj
                      `cast` (Data.Monoid.N:Last[0] <a_a6LtL>_N
                              :: (Last a_a6LtL :: *) ~R# (Maybe a_a6LtL :: *))
                 of {
                   Nothing -> z_X6Kph;
                   Just x_i6McL [Occ=Once] -> f_X6Kpf z_X6Kph x_i6McL
                 }}]
Data.Foldable.$fFoldableLast_$cfoldl
  = \ (@ b_a6LtK)
      (@ a_a6LtL)
      (f_X6Kpf :: b_a6LtK -> a_a6LtL -> b_a6LtK)
      (z_X6Kph :: b_a6LtK)
      (t_X6Kpj :: Last a_a6LtL) ->
      case t_X6Kpj
           `cast` (Data.Monoid.N:Last[0] <a_a6LtL>_N
                   :: (Last a_a6LtL :: *) ~R# (Maybe a_a6LtL :: *))
      of {
        Nothing -> z_X6Kph;
        Just x_i6McL -> f_X6Kpf z_X6Kph x_i6McL
      }

-- RHS size: {terms: 9, types: 11, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableLast_$cfoldl1
  :: forall a. (a -> a -> a) -> Last a -> a
[GblId,
 Arity=2,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6Luc)
                 _ [Occ=Dead]
                 (xs_X6Kpx [Occ=Once] :: Last a_a6Luc) ->
                 case xs_X6Kpx
                      `cast` (Data.Monoid.N:Last[0] <a_a6Luc>_N
                              :: (Last a_a6Luc :: *) ~R# (Maybe a_a6Luc :: *))
                 of {
                   Nothing -> Data.Foldable.$fFoldable:.:2 @ a_a6Luc;
                   Just x_i6McL [Occ=Once] -> x_i6McL
                 }}]
Data.Foldable.$fFoldableLast_$cfoldl1
  = \ (@ a_a6Luc) _ [Occ=Dead] (xs_X6Kpx :: Last a_a6Luc) ->
      case xs_X6Kpx
           `cast` (Data.Monoid.N:Last[0] <a_a6Luc>_N
                   :: (Last a_a6Luc :: *) ~R# (Maybe a_a6Luc :: *))
      of {
        Nothing -> Data.Foldable.$fFoldable:.:2 @ a_a6Luc;
        Just x_i6McL -> x_i6McL
      }

-- RHS size: {terms: 13, types: 13, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableLast_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> Last a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LtA)
                 (@ b_a6LtB)
                 (f_a6K7s [Occ=Once!] :: a_a6LtA -> b_a6LtB -> b_a6LtB)
                 (z0_a6K7t [Occ=Once*] :: b_a6LtB)
                 (xs_a6K7u [Occ=Once] :: Last a_a6LtA) ->
                 case xs_a6K7u
                      `cast` (Data.Monoid.N:Last[0] <a_a6LtA>_N
                              :: (Last a_a6LtA :: *) ~R# (Maybe a_a6LtA :: *))
                 of {
                   Nothing -> z0_a6K7t;
                   Just x_i6McL [Occ=Once] -> f_a6K7s x_i6McL z0_a6K7t
                 }}]
Data.Foldable.$fFoldableLast_$cfoldr'
  = \ (@ a_a6LtA)
      (@ b_a6LtB)
      (f_a6K7s :: a_a6LtA -> b_a6LtB -> b_a6LtB)
      (z0_a6K7t :: b_a6LtB)
      (xs_a6K7u :: Last a_a6LtA) ->
      case xs_a6K7u
           `cast` (Data.Monoid.N:Last[0] <a_a6LtA>_N
                   :: (Last a_a6LtA :: *) ~R# (Maybe a_a6LtA :: *))
      of {
        Nothing -> z0_a6K7t;
        Just x_i6McL -> f_a6K7s x_i6McL z0_a6K7t
      }

-- RHS size: {terms: 8, types: 7, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableLast_$clength :: forall a. Last a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LuA) (xs_a6K7E [Occ=Once] :: Last a_a6LuA) ->
                 case xs_a6K7E
                      `cast` (Data.Monoid.N:Last[0] <a_a6LuA>_N
                              :: (Last a_a6LuA :: *) ~R# (Maybe a_a6LuA :: *))
                 of {
                   Nothing -> Data.Foldable.$fFoldable:*:4;
                   Just _ [Occ=Dead] -> GHC.Types.I# 1#
                 }}]
Data.Foldable.$fFoldableLast_$clength
  = \ (@ a_a6LuA) (xs_a6K7E :: Last a_a6LuA) ->
      case xs_a6K7E
           `cast` (Data.Monoid.N:Last[0] <a_a6LuA>_N
                   :: (Last a_a6LuA :: *) ~R# (Maybe a_a6LuA :: *))
      of {
        Nothing -> Data.Foldable.$fFoldable:*:4;
        Just x_i6McL -> Data.Foldable.$fFoldableDual3
      }

-- RHS size: {terms: 9, types: 11, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableLast_$cfoldr1
  :: forall a. (a -> a -> a) -> Last a -> a
[GblId,
 Arity=2,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6Lu4)
                 _ [Occ=Dead]
                 (xs_a6K7K [Occ=Once] :: Last a_a6Lu4) ->
                 case xs_a6K7K
                      `cast` (Data.Monoid.N:Last[0] <a_a6Lu4>_N
                              :: (Last a_a6Lu4 :: *) ~R# (Maybe a_a6Lu4 :: *))
                 of {
                   Nothing -> Data.Foldable.$fFoldable:.:3 @ a_a6Lu4;
                   Just x_i6McL [Occ=Once] -> x_i6McL
                 }}]
Data.Foldable.$fFoldableLast_$cfoldr1
  = \ (@ a_a6Lu4) _ [Occ=Dead] (xs_a6K7K :: Last a_a6Lu4) ->
      case xs_a6K7K
           `cast` (Data.Monoid.N:Last[0] <a_a6Lu4>_N
                   :: (Last a_a6Lu4 :: *) ~R# (Maybe a_a6Lu4 :: *))
      of {
        Nothing -> Data.Foldable.$fFoldable:.:3 @ a_a6Lu4;
        Just x_i6McL -> x_i6McL
      }

-- RHS size: {terms: 8, types: 7, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableLast_$cnull :: forall a. Last a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6Lus) (t_a6K7r [Occ=Once] :: Last a_a6Lus) ->
                 case t_a6K7r
                      `cast` (Data.Monoid.N:Last[0] <a_a6Lus>_N
                              :: (Last a_a6Lus :: *) ~R# (Maybe a_a6Lus :: *))
                 of {
                   Nothing -> GHC.Types.True;
                   Just _ [Occ=Dead] -> GHC.Types.False
                 }}]
Data.Foldable.$fFoldableLast_$cnull
  = \ (@ a_a6Lus) (t_a6K7r :: Last a_a6Lus) ->
      case t_a6K7r
           `cast` (Data.Monoid.N:Last[0] <a_a6Lus>_N
                   :: (Last a_a6Lus :: *) ~R# (Maybe a_a6Lus :: *))
      of {
        Nothing -> GHC.Types.True;
        Just x_i6McL -> GHC.Types.False
      }

-- RHS size: {terms: 10, types: 10, coercions: 8, joins: 0/0}
Data.Foldable.$fFoldableLast1
  :: forall a. Num a => Last a -> Product a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6Lvm)
                 ($dNum_a6Lvo [Occ=Once] :: Num a_a6Lvm)
                 (x_i6HAl [Occ=Once] :: Last a_a6Lvm) ->
                 case x_i6HAl
                      `cast` (Data.Monoid.N:Last[0] <a_a6Lvm>_N
                              :: (Last a_a6Lvm :: *) ~R# (Maybe a_a6Lvm :: *))
                 of {
                   Nothing ->
                     (Data.Semigroup.Internal.$fMonoidProduct2 @ a_a6Lvm $dNum_a6Lvo)
                     `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6Lvm>_R)
                             :: (a_a6Lvm :: *) ~R# (Product a_a6Lvm :: *));
                   Just x1_i6McL [Occ=Once] ->
                     x1_i6McL
                     `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6Lvm>_R)
                             :: (a_a6Lvm :: *) ~R# (Product a_a6Lvm :: *))
                 }}]
Data.Foldable.$fFoldableLast1
  = \ (@ a_a6Lvm)
      ($dNum_a6Lvo :: Num a_a6Lvm)
      (x_i6HAl :: Last a_a6Lvm) ->
      case x_i6HAl
           `cast` (Data.Monoid.N:Last[0] <a_a6Lvm>_N
                   :: (Last a_a6Lvm :: *) ~R# (Maybe a_a6Lvm :: *))
      of {
        Nothing ->
          (Data.Semigroup.Internal.$fMonoidProduct2 @ a_a6Lvm $dNum_a6Lvo)
          `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6Lvm>_R)
                  :: (a_a6Lvm :: *) ~R# (Product a_a6Lvm :: *));
        Just x1_i6McL ->
          x1_i6McL
          `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6Lvm>_R)
                  :: (a_a6Lvm :: *) ~R# (Product a_a6Lvm :: *))
      }

-- RHS size: {terms: 10, types: 10, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableLast_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. Last a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a6Luk) (t_a6K7V [Occ=Once] :: Last a_a6Luk) ->
                 build
                   @ a_a6Luk
                   (\ (@ b_a6KNB)
                      (c_a6K7W [Occ=Once, OS=OneShot] :: a_a6Luk -> b_a6KNB -> b_a6KNB)
                      (n_a6K7X [Occ=Once, OS=OneShot] :: b_a6KNB) ->
                      Data.Foldable.$fFoldableLast_$cfoldr'
                        @ a_a6Luk @ b_a6KNB c_a6K7W n_a6K7X t_a6K7V)}]
Data.Foldable.$fFoldableLast_$ctoList
  = \ (@ a_a6Luk) (eta_XhS :: Last a_a6Luk) ->
      case eta_XhS
           `cast` (Data.Monoid.N:Last[0] <a_a6Luk>_N
                   :: (Last a_a6Luk :: *) ~R# (Maybe a_a6Luk :: *))
      of {
        Nothing -> GHC.Types.[] @ a_a6Luk;
        Just x_i6McL ->
          GHC.Types.: @ a_a6Luk x_i6McL (GHC.Types.[] @ a_a6Luk)
      }

-- RHS size: {terms: 17, types: 1, coercions: 22, joins: 0/0}
Data.Foldable.$fFoldableLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable Last
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: Last
                                Data.Foldable.$fFoldableLast_$cfold
                                Data.Foldable.$fFoldableLast_$cfoldMap
                                Data.Foldable.$fFoldableLast_$cfoldr'
                                Data.Foldable.$fFoldableLast_$cfoldr'
                                Data.Foldable.$fFoldableLast_$cfoldl
                                Data.Foldable.$fFoldableLast_$cfoldl
                                Data.Foldable.$fFoldableLast_$cfoldr1
                                Data.Foldable.$fFoldableLast_$cfoldl1
                                Data.Foldable.$fFoldableLast_$ctoList
                                Data.Foldable.$fFoldableLast_$cnull
                                Data.Foldable.$fFoldableLast_$clength
                                Data.Foldable.$fFoldableLast_$celem
                                Data.Foldable.$fFoldableLast_$cmaximum
                                Data.Foldable.$fFoldableLast_$cminimum
                                Data.Foldable.$fFoldableLast2
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <Last a>_R
                                        ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
                                        :: (forall a. Num a => Last a -> Sum a :: *)
                                           ~R# (forall a. Num a => Last a -> a :: *))
                                Data.Foldable.$fFoldableLast1
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <Last a>_R
                                        ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
                                        :: (forall a. Num a => Last a -> Product a :: *)
                                           ~R# (forall a. Num a => Last a -> a :: *))]
Data.Foldable.$fFoldableLast
  = Data.Foldable.C:Foldable
      @ Last
      Data.Foldable.$fFoldableLast_$cfold
      Data.Foldable.$fFoldableLast_$cfoldMap
      Data.Foldable.$fFoldableLast_$cfoldr'
      Data.Foldable.$fFoldableLast_$cfoldr'
      Data.Foldable.$fFoldableLast_$cfoldl
      Data.Foldable.$fFoldableLast_$cfoldl
      Data.Foldable.$fFoldableLast_$cfoldr1
      Data.Foldable.$fFoldableLast_$cfoldl1
      Data.Foldable.$fFoldableLast_$ctoList
      Data.Foldable.$fFoldableLast_$cnull
      Data.Foldable.$fFoldableLast_$clength
      Data.Foldable.$fFoldableLast_$celem
      Data.Foldable.$fFoldableLast_$cmaximum
      Data.Foldable.$fFoldableLast_$cminimum
      (Data.Foldable.$fFoldableLast2
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <Last a>_R
               ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall a. Num a => Last a -> Sum a :: *)
                  ~R# (forall a. Num a => Last a -> a :: *)))
      (Data.Foldable.$fFoldableLast1
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <Last a>_R
               ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall a. Num a => Last a -> Product a :: *)
                  ~R# (forall a. Num a => Last a -> a :: *)))

-- RHS size: {terms: 13, types: 14, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableFirst_$cfoldMap
  :: forall m a. Monoid m => (a -> m) -> First a -> m
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_a6LvI)
                 (@ a_a6LvJ)
                 ($dMonoid_a6LvL [Occ=Once] :: Monoid m_a6LvI)
                 (f_a6K82 [Occ=Once!] :: a_a6LvJ -> m_a6LvI)
                 (x_i6HAl [Occ=Once] :: First a_a6LvJ) ->
                 case x_i6HAl
                      `cast` (Data.Monoid.N:First[0] <a_a6LvJ>_N
                              :: (First a_a6LvJ :: *) ~R# (Maybe a_a6LvJ :: *))
                 of {
                   Nothing -> mempty @ m_a6LvI $dMonoid_a6LvL;
                   Just x1_i6McL [Occ=Once] -> f_a6K82 x1_i6McL
                 }}]
Data.Foldable.$fFoldableFirst_$cfoldMap
  = \ (@ m_a6LvI)
      (@ a_a6LvJ)
      ($dMonoid_a6LvL :: Monoid m_a6LvI)
      (f_a6K82 :: a_a6LvJ -> m_a6LvI)
      (x_i6HAl :: First a_a6LvJ) ->
      case x_i6HAl
           `cast` (Data.Monoid.N:First[0] <a_a6LvJ>_N
                   :: (First a_a6LvJ :: *) ~R# (Maybe a_a6LvJ :: *))
      of {
        Nothing -> mempty @ m_a6LvI $dMonoid_a6LvL;
        Just x1_i6McL -> f_a6K82 x1_i6McL
      }

-- RHS size: {terms: 10, types: 10, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableFirst_$cfold
  :: forall m. Monoid m => First m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ m_a6Lvy)
                 ($dMonoid_a6LvA [Occ=Once] :: Monoid m_a6Lvy)
                 (x_i6HAl [Occ=Once] :: First m_a6Lvy) ->
                 case x_i6HAl
                      `cast` (Data.Monoid.N:First[0] <m_a6Lvy>_N
                              :: (First m_a6Lvy :: *) ~R# (Maybe m_a6Lvy :: *))
                 of {
                   Nothing -> mempty @ m_a6Lvy $dMonoid_a6LvA;
                   Just x1_i6McL [Occ=Once] -> x1_i6McL
                 }}]
Data.Foldable.$fFoldableFirst_$cfold
  = \ (@ m_a6Lvy)
      ($dMonoid_a6LvA :: Monoid m_a6Lvy)
      (x_i6HAl :: First m_a6Lvy) ->
      case x_i6HAl
           `cast` (Data.Monoid.N:First[0] <m_a6Lvy>_N
                   :: (First m_a6Lvy :: *) ~R# (Maybe m_a6Lvy :: *))
      of {
        Nothing -> mempty @ m_a6Lvy $dMonoid_a6LvA;
        Just x1_i6McL -> x1_i6McL
      }

-- RHS size: {terms: 10, types: 10, coercions: 8, joins: 0/0}
Data.Foldable.$fFoldableFirst2
  :: forall a. Num a => First a -> Sum a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LxL)
                 ($dNum_a6LxN [Occ=Once] :: Num a_a6LxL)
                 (x_i6HAl [Occ=Once] :: First a_a6LxL) ->
                 case x_i6HAl
                      `cast` (Data.Monoid.N:First[0] <a_a6LxL>_N
                              :: (First a_a6LxL :: *) ~R# (Maybe a_a6LxL :: *))
                 of {
                   Nothing ->
                     (Data.Semigroup.Internal.$fMonoidSum2 @ a_a6LxL $dNum_a6LxN)
                     `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6LxL>_R)
                             :: (a_a6LxL :: *) ~R# (Sum a_a6LxL :: *));
                   Just x1_i6McL [Occ=Once] ->
                     x1_i6McL
                     `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6LxL>_R)
                             :: (a_a6LxL :: *) ~R# (Sum a_a6LxL :: *))
                 }}]
Data.Foldable.$fFoldableFirst2
  = \ (@ a_a6LxL)
      ($dNum_a6LxN :: Num a_a6LxL)
      (x_i6HAl :: First a_a6LxL) ->
      case x_i6HAl
           `cast` (Data.Monoid.N:First[0] <a_a6LxL>_N
                   :: (First a_a6LxL :: *) ~R# (Maybe a_a6LxL :: *))
      of {
        Nothing ->
          (Data.Semigroup.Internal.$fMonoidSum2 @ a_a6LxL $dNum_a6LxN)
          `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6LxL>_R)
                  :: (a_a6LxL :: *) ~R# (Sum a_a6LxL :: *));
        Just x1_i6McL ->
          x1_i6McL
          `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6LxL>_R)
                  :: (a_a6LxL :: *) ~R# (Sum a_a6LxL :: *))
      }

-- RHS size: {terms: 8, types: 8, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableFirst3 :: forall a. First a -> a
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LxB) (x_X6HLQ [Occ=Once] :: First a_a6LxB) ->
                 case x_X6HLQ
                      `cast` (Data.Monoid.N:First[0] <a_a6LxB>_N
                              :: (First a_a6LxB :: *) ~R# (Maybe a_a6LxB :: *))
                 of {
                   Nothing -> Data.Foldable.$fFoldable:*:2 @ a_a6LxB;
                   Just v_i6M0Z [Occ=Once] -> v_i6M0Z
                 }}]
Data.Foldable.$fFoldableFirst3
  = \ (@ a_a6LxB) (x_X6HLQ :: First a_a6LxB) ->
      case x_X6HLQ
           `cast` (Data.Monoid.N:First[0] <a_a6LxB>_N
                   :: (First a_a6LxB :: *) ~R# (Maybe a_a6LxB :: *))
      of {
        Nothing -> Data.Foldable.$fFoldable:*:2 @ a_a6LxB;
        Just v_i6M0Z -> v_i6M0Z
      }

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableFirst_$cminimum
  :: forall a. Ord a => First a -> a
[GblId,
 Arity=2,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6LxB) _ [Occ=Dead] ->
                 Data.Foldable.$fFoldableFirst3 @ a_a6LxB}]
Data.Foldable.$fFoldableFirst_$cminimum
  = \ (@ a_a6LxB) _ [Occ=Dead] ->
      Data.Foldable.$fFoldableFirst3 @ a_a6LxB

-- RHS size: {terms: 8, types: 8, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableFirst4 :: forall a. First a -> a
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6Lxr) (x_X6HLR [Occ=Once] :: First a_a6Lxr) ->
                 case x_X6HLR
                      `cast` (Data.Monoid.N:First[0] <a_a6Lxr>_N
                              :: (First a_a6Lxr :: *) ~R# (Maybe a_a6Lxr :: *))
                 of {
                   Nothing -> Data.Foldable.$fFoldable:*:3 @ a_a6Lxr;
                   Just v_i6M0Z [Occ=Once] -> v_i6M0Z
                 }}]
Data.Foldable.$fFoldableFirst4
  = \ (@ a_a6Lxr) (x_X6HLR :: First a_a6Lxr) ->
      case x_X6HLR
           `cast` (Data.Monoid.N:First[0] <a_a6Lxr>_N
                   :: (First a_a6Lxr :: *) ~R# (Maybe a_a6Lxr :: *))
      of {
        Nothing -> Data.Foldable.$fFoldable:*:3 @ a_a6Lxr;
        Just v_i6M0Z -> v_i6M0Z
      }

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldableFirst_$cmaximum
  :: forall a. Ord a => First a -> a
[GblId,
 Arity=2,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Lxr) _ [Occ=Dead] ->
                 Data.Foldable.$fFoldableFirst4 @ a_a6Lxr}]
Data.Foldable.$fFoldableFirst_$cmaximum
  = \ (@ a_a6Lxr) _ [Occ=Dead] ->
      Data.Foldable.$fFoldableFirst4 @ a_a6Lxr

-- RHS size: {terms: 15, types: 13, coercions: 10, joins: 0/1}
Data.Foldable.$fFoldableFirst_$celem
  :: forall a. Eq a => a -> First a -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6Lxh)
                 ($dEq_a6Lxj [Occ=Once] :: Eq a_a6Lxh)
                 (eta_Xi3 [Occ=Once] :: a_a6Lxh) ->
                 let {
                   f_s6MHH [Occ=OnceL!] :: a_a6Lxh -> Bool
                   [LclId]
                   f_s6MHH = == @ a_a6Lxh $dEq_a6Lxj eta_Xi3 } in
                 (\ (x_X6HSy [Occ=Once] :: First a_a6Lxh) ->
                    case x_X6HSy
                         `cast` (Data.Monoid.N:First[0] <a_a6Lxh>_N
                                 :: (First a_a6Lxh :: *) ~R# (Maybe a_a6Lxh :: *))
                    of {
                      Nothing ->
                        GHC.Types.False
                        `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                                :: (Bool :: *) ~R# (Data.Monoid.Any :: *));
                      Just x1_i6McL [Occ=Once] ->
                        (f_s6MHH x1_i6McL)
                        `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                                :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
                    })
                 `cast` (<First a_a6Lxh>_R ->_R Data.Semigroup.Internal.N:Any[0]
                         :: (First a_a6Lxh -> Data.Monoid.Any :: *)
                            ~R# (First a_a6Lxh -> Bool :: *))}]
Data.Foldable.$fFoldableFirst_$celem
  = \ (@ a_a6Lxh) ($dEq_a6Lxj :: Eq a_a6Lxh) (eta_Xi3 :: a_a6Lxh) ->
      let {
        f_s6MHH [Dmd=<L,C(U)>] :: a_a6Lxh -> Bool
        [LclId]
        f_s6MHH = == @ a_a6Lxh $dEq_a6Lxj eta_Xi3 } in
      (\ (x_X6HSy :: First a_a6Lxh) ->
         case x_X6HSy
              `cast` (Data.Monoid.N:First[0] <a_a6Lxh>_N
                      :: (First a_a6Lxh :: *) ~R# (Maybe a_a6Lxh :: *))
         of {
           Nothing ->
             GHC.Types.False
             `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                     :: (Bool :: *) ~R# (Data.Monoid.Any :: *));
           Just x1_i6McL ->
             (f_s6MHH x1_i6McL)
             `cast` (Sym (Data.Semigroup.Internal.N:Any[0])
                     :: (Bool :: *) ~R# (Data.Monoid.Any :: *))
         })
      `cast` (<First a_a6Lxh>_R ->_R Data.Semigroup.Internal.N:Any[0]
              :: (First a_a6Lxh -> Data.Monoid.Any :: *)
                 ~R# (First a_a6Lxh -> Bool :: *))

-- RHS size: {terms: 13, types: 13, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableFirst_$cfoldl
  :: forall b a. (b -> a -> b) -> b -> First a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a6Lwj)
                 (@ a_a6Lwk)
                 (f_X6KpA [Occ=Once!] :: b_a6Lwj -> a_a6Lwk -> b_a6Lwj)
                 (z_X6KpC [Occ=Once*] :: b_a6Lwj)
                 (t_X6KpE [Occ=Once] :: First a_a6Lwk) ->
                 case t_X6KpE
                      `cast` (Data.Monoid.N:First[0] <a_a6Lwk>_N
                              :: (First a_a6Lwk :: *) ~R# (Maybe a_a6Lwk :: *))
                 of {
                   Nothing -> z_X6KpC;
                   Just x_i6McL [Occ=Once] -> f_X6KpA z_X6KpC x_i6McL
                 }}]
Data.Foldable.$fFoldableFirst_$cfoldl
  = \ (@ b_a6Lwj)
      (@ a_a6Lwk)
      (f_X6KpA :: b_a6Lwj -> a_a6Lwk -> b_a6Lwj)
      (z_X6KpC :: b_a6Lwj)
      (t_X6KpE :: First a_a6Lwk) ->
      case t_X6KpE
           `cast` (Data.Monoid.N:First[0] <a_a6Lwk>_N
                   :: (First a_a6Lwk :: *) ~R# (Maybe a_a6Lwk :: *))
      of {
        Nothing -> z_X6KpC;
        Just x_i6McL -> f_X6KpA z_X6KpC x_i6McL
      }

-- RHS size: {terms: 9, types: 11, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableFirst_$cfoldl1
  :: forall a. (a -> a -> a) -> First a -> a
[GblId,
 Arity=2,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LwL)
                 _ [Occ=Dead]
                 (xs_X6KpX [Occ=Once] :: First a_a6LwL) ->
                 case xs_X6KpX
                      `cast` (Data.Monoid.N:First[0] <a_a6LwL>_N
                              :: (First a_a6LwL :: *) ~R# (Maybe a_a6LwL :: *))
                 of {
                   Nothing -> Data.Foldable.$fFoldable:.:2 @ a_a6LwL;
                   Just x_i6McL [Occ=Once] -> x_i6McL
                 }}]
Data.Foldable.$fFoldableFirst_$cfoldl1
  = \ (@ a_a6LwL) _ [Occ=Dead] (xs_X6KpX :: First a_a6LwL) ->
      case xs_X6KpX
           `cast` (Data.Monoid.N:First[0] <a_a6LwL>_N
                   :: (First a_a6LwL :: *) ~R# (Maybe a_a6LwL :: *))
      of {
        Nothing -> Data.Foldable.$fFoldable:.:2 @ a_a6LwL;
        Just x_i6McL -> x_i6McL
      }

-- RHS size: {terms: 13, types: 13, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableFirst_$cfoldr'
  :: forall a b. (a -> b -> b) -> b -> First a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6Lw9)
                 (@ b_a6Lwa)
                 (f_a6K7s [Occ=Once!] :: a_a6Lw9 -> b_a6Lwa -> b_a6Lwa)
                 (z0_a6K7t [Occ=Once*] :: b_a6Lwa)
                 (xs_a6K7u [Occ=Once] :: First a_a6Lw9) ->
                 case xs_a6K7u
                      `cast` (Data.Monoid.N:First[0] <a_a6Lw9>_N
                              :: (First a_a6Lw9 :: *) ~R# (Maybe a_a6Lw9 :: *))
                 of {
                   Nothing -> z0_a6K7t;
                   Just x_i6McL [Occ=Once] -> f_a6K7s x_i6McL z0_a6K7t
                 }}]
Data.Foldable.$fFoldableFirst_$cfoldr'
  = \ (@ a_a6Lw9)
      (@ b_a6Lwa)
      (f_a6K7s :: a_a6Lw9 -> b_a6Lwa -> b_a6Lwa)
      (z0_a6K7t :: b_a6Lwa)
      (xs_a6K7u :: First a_a6Lw9) ->
      case xs_a6K7u
           `cast` (Data.Monoid.N:First[0] <a_a6Lw9>_N
                   :: (First a_a6Lw9 :: *) ~R# (Maybe a_a6Lw9 :: *))
      of {
        Nothing -> z0_a6K7t;
        Just x_i6McL -> f_a6K7s x_i6McL z0_a6K7t
      }

-- RHS size: {terms: 8, types: 7, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableFirst_$clength :: forall a. First a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6Lx9) (xs_a6K7E [Occ=Once] :: First a_a6Lx9) ->
                 case xs_a6K7E
                      `cast` (Data.Monoid.N:First[0] <a_a6Lx9>_N
                              :: (First a_a6Lx9 :: *) ~R# (Maybe a_a6Lx9 :: *))
                 of {
                   Nothing -> Data.Foldable.$fFoldable:*:4;
                   Just _ [Occ=Dead] -> GHC.Types.I# 1#
                 }}]
Data.Foldable.$fFoldableFirst_$clength
  = \ (@ a_a6Lx9) (xs_a6K7E :: First a_a6Lx9) ->
      case xs_a6K7E
           `cast` (Data.Monoid.N:First[0] <a_a6Lx9>_N
                   :: (First a_a6Lx9 :: *) ~R# (Maybe a_a6Lx9 :: *))
      of {
        Nothing -> Data.Foldable.$fFoldable:*:4;
        Just x_i6McL -> Data.Foldable.$fFoldableDual3
      }

-- RHS size: {terms: 9, types: 11, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableFirst_$cfoldr1
  :: forall a. (a -> a -> a) -> First a -> a
[GblId,
 Arity=2,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LwD)
                 _ [Occ=Dead]
                 (xs_a6K7K [Occ=Once] :: First a_a6LwD) ->
                 case xs_a6K7K
                      `cast` (Data.Monoid.N:First[0] <a_a6LwD>_N
                              :: (First a_a6LwD :: *) ~R# (Maybe a_a6LwD :: *))
                 of {
                   Nothing -> Data.Foldable.$fFoldable:.:3 @ a_a6LwD;
                   Just x_i6McL [Occ=Once] -> x_i6McL
                 }}]
Data.Foldable.$fFoldableFirst_$cfoldr1
  = \ (@ a_a6LwD) _ [Occ=Dead] (xs_a6K7K :: First a_a6LwD) ->
      case xs_a6K7K
           `cast` (Data.Monoid.N:First[0] <a_a6LwD>_N
                   :: (First a_a6LwD :: *) ~R# (Maybe a_a6LwD :: *))
      of {
        Nothing -> Data.Foldable.$fFoldable:.:3 @ a_a6LwD;
        Just x_i6McL -> x_i6McL
      }

-- RHS size: {terms: 8, types: 7, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableFirst_$cnull :: forall a. First a -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6Lx1) (t_a6K7r [Occ=Once] :: First a_a6Lx1) ->
                 case t_a6K7r
                      `cast` (Data.Monoid.N:First[0] <a_a6Lx1>_N
                              :: (First a_a6Lx1 :: *) ~R# (Maybe a_a6Lx1 :: *))
                 of {
                   Nothing -> GHC.Types.True;
                   Just _ [Occ=Dead] -> GHC.Types.False
                 }}]
Data.Foldable.$fFoldableFirst_$cnull
  = \ (@ a_a6Lx1) (t_a6K7r :: First a_a6Lx1) ->
      case t_a6K7r
           `cast` (Data.Monoid.N:First[0] <a_a6Lx1>_N
                   :: (First a_a6Lx1 :: *) ~R# (Maybe a_a6Lx1 :: *))
      of {
        Nothing -> GHC.Types.True;
        Just x_i6McL -> GHC.Types.False
      }

-- RHS size: {terms: 10, types: 10, coercions: 8, joins: 0/0}
Data.Foldable.$fFoldableFirst1
  :: forall a. Num a => First a -> Product a
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6LxV)
                 ($dNum_a6LxX [Occ=Once] :: Num a_a6LxV)
                 (x_i6HAl [Occ=Once] :: First a_a6LxV) ->
                 case x_i6HAl
                      `cast` (Data.Monoid.N:First[0] <a_a6LxV>_N
                              :: (First a_a6LxV :: *) ~R# (Maybe a_a6LxV :: *))
                 of {
                   Nothing ->
                     (Data.Semigroup.Internal.$fMonoidProduct2 @ a_a6LxV $dNum_a6LxX)
                     `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LxV>_R)
                             :: (a_a6LxV :: *) ~R# (Product a_a6LxV :: *));
                   Just x1_i6McL [Occ=Once] ->
                     x1_i6McL
                     `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LxV>_R)
                             :: (a_a6LxV :: *) ~R# (Product a_a6LxV :: *))
                 }}]
Data.Foldable.$fFoldableFirst1
  = \ (@ a_a6LxV)
      ($dNum_a6LxX :: Num a_a6LxV)
      (x_i6HAl :: First a_a6LxV) ->
      case x_i6HAl
           `cast` (Data.Monoid.N:First[0] <a_a6LxV>_N
                   :: (First a_a6LxV :: *) ~R# (Maybe a_a6LxV :: *))
      of {
        Nothing ->
          (Data.Semigroup.Internal.$fMonoidProduct2 @ a_a6LxV $dNum_a6LxX)
          `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LxV>_R)
                  :: (a_a6LxV :: *) ~R# (Product a_a6LxV :: *));
        Just x1_i6McL ->
          x1_i6McL
          `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a_a6LxV>_R)
                  :: (a_a6LxV :: *) ~R# (Product a_a6LxV :: *))
      }

-- RHS size: {terms: 10, types: 10, coercions: 2, joins: 0/0}
Data.Foldable.$fFoldableFirst_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall a. First a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a6LwT) (t_a6K7V [Occ=Once] :: First a_a6LwT) ->
                 build
                   @ a_a6LwT
                   (\ (@ b_a6KNB)
                      (c_a6K7W [Occ=Once, OS=OneShot] :: a_a6LwT -> b_a6KNB -> b_a6KNB)
                      (n_a6K7X [Occ=Once, OS=OneShot] :: b_a6KNB) ->
                      Data.Foldable.$fFoldableFirst_$cfoldr'
                        @ a_a6LwT @ b_a6KNB c_a6K7W n_a6K7X t_a6K7V)}]
Data.Foldable.$fFoldableFirst_$ctoList
  = \ (@ a_a6LwT) (eta_Xii :: First a_a6LwT) ->
      case eta_Xii
           `cast` (Data.Monoid.N:First[0] <a_a6LwT>_N
                   :: (First a_a6LwT :: *) ~R# (Maybe a_a6LwT :: *))
      of {
        Nothing -> GHC.Types.[] @ a_a6LwT;
        Just x_i6McL ->
          GHC.Types.: @ a_a6LwT x_i6McL (GHC.Types.[] @ a_a6LwT)
      }

-- RHS size: {terms: 17, types: 1, coercions: 22, joins: 0/0}
Data.Foldable.$fFoldableFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Foldable First
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Foldable.C:Foldable TYPE: First
                                Data.Foldable.$fFoldableFirst_$cfold
                                Data.Foldable.$fFoldableFirst_$cfoldMap
                                Data.Foldable.$fFoldableFirst_$cfoldr'
                                Data.Foldable.$fFoldableFirst_$cfoldr'
                                Data.Foldable.$fFoldableFirst_$cfoldl
                                Data.Foldable.$fFoldableFirst_$cfoldl
                                Data.Foldable.$fFoldableFirst_$cfoldr1
                                Data.Foldable.$fFoldableFirst_$cfoldl1
                                Data.Foldable.$fFoldableFirst_$ctoList
                                Data.Foldable.$fFoldableFirst_$cnull
                                Data.Foldable.$fFoldableFirst_$clength
                                Data.Foldable.$fFoldableFirst_$celem
                                Data.Foldable.$fFoldableFirst_$cmaximum
                                Data.Foldable.$fFoldableFirst_$cminimum
                                Data.Foldable.$fFoldableFirst2
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <First a>_R
                                        ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
                                        :: (forall a. Num a => First a -> Sum a :: *)
                                           ~R# (forall a. Num a => First a -> a :: *))
                                Data.Foldable.$fFoldableFirst1
                                `cast` (forall (a :: <*>_N).
                                        <Num a>_R
                                        ->_R <First a>_R
                                        ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
                                        :: (forall a. Num a => First a -> Product a :: *)
                                           ~R# (forall a. Num a => First a -> a :: *))]
Data.Foldable.$fFoldableFirst
  = Data.Foldable.C:Foldable
      @ First
      Data.Foldable.$fFoldableFirst_$cfold
      Data.Foldable.$fFoldableFirst_$cfoldMap
      Data.Foldable.$fFoldableFirst_$cfoldr'
      Data.Foldable.$fFoldableFirst_$cfoldr'
      Data.Foldable.$fFoldableFirst_$cfoldl
      Data.Foldable.$fFoldableFirst_$cfoldl
      Data.Foldable.$fFoldableFirst_$cfoldr1
      Data.Foldable.$fFoldableFirst_$cfoldl1
      Data.Foldable.$fFoldableFirst_$ctoList
      Data.Foldable.$fFoldableFirst_$cnull
      Data.Foldable.$fFoldableFirst_$clength
      Data.Foldable.$fFoldableFirst_$celem
      Data.Foldable.$fFoldableFirst_$cmaximum
      Data.Foldable.$fFoldableFirst_$cminimum
      (Data.Foldable.$fFoldableFirst2
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <First a>_R
               ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R
               :: (forall a. Num a => First a -> Sum a :: *)
                  ~R# (forall a. Num a => First a -> a :: *)))
      (Data.Foldable.$fFoldableFirst1
       `cast` (forall (a :: <*>_N).
               <Num a>_R
               ->_R <First a>_R
               ->_R Data.Semigroup.Internal.N:Product[0] <a>_R
               :: (forall a. Num a => First a -> Product a :: *)
                  ~R# (forall a. Num a => First a -> a :: *)))

-- RHS size: {terms: 8, types: 13, coercions: 4, joins: 0/0}
Data.Foldable.all1
  :: forall (t :: * -> *) a. Foldable t => (a -> Bool) -> t a -> All
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_a6KDj :: * -> *))
                 (@ a_a6KDk)
                 ($dFoldable_a6KDm [Occ=Once] :: Foldable t_a6KDj)
                 (p_a6Kai [Occ=Once] :: a_a6KDk -> Bool) ->
                 foldMap
                   @ t_a6KDj
                   $dFoldable_a6KDm
                   @ All
                   @ a_a6KDk
                   Data.Semigroup.Internal.$fMonoidAll
                   (p_a6Kai
                    `cast` (<a_a6KDk>_R ->_R Sym (Data.Semigroup.Internal.N:All[0])
                            :: (a_a6KDk -> Bool :: *) ~R# (a_a6KDk -> All :: *)))}]
Data.Foldable.all1
  = \ (@ (t_a6KDj :: * -> *))
      (@ a_a6KDk)
      ($dFoldable_a6KDm :: Foldable t_a6KDj)
      (p_a6Kai :: a_a6KDk -> Bool) ->
      foldMap
        @ t_a6KDj
        $dFoldable_a6KDm
        @ All
        @ a_a6KDk
        Data.Semigroup.Internal.$fMonoidAll
        (p_a6Kai
         `cast` (<a_a6KDk>_R ->_R Sym (Data.Semigroup.Internal.N:All[0])
                 :: (a_a6KDk -> Bool :: *) ~R# (a_a6KDk -> All :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 18, joins: 0/0}
all
  :: forall (t :: * -> *) a. Foldable t => (a -> Bool) -> t a -> Bool
[GblId,
 Arity=2,
 Str=<S(LC(C(S))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Foldable.all1
               `cast` (forall (t :: <* -> *>_N) (a :: <*>_N).
                       <Foldable t>_R
                       ->_R <a -> Bool>_R
                       ->_R <t a>_R
                       ->_R Data.Semigroup.Internal.N:All[0]
                       :: (forall (t :: * -> *) a.
                           Foldable t =>
                           (a -> Bool) -> t a -> All :: *)
                          ~R# (forall (t :: * -> *) a.
                               Foldable t =>
                               (a -> Bool) -> t a -> Bool :: *))}]
all
  = Data.Foldable.all1
    `cast` (forall (t :: <* -> *>_N) (a :: <*>_N).
            <Foldable t>_R
            ->_R <a -> Bool>_R
            ->_R <t a>_R
            ->_R Data.Semigroup.Internal.N:All[0]
            :: (forall (t :: * -> *) a.
                Foldable t =>
                (a -> Bool) -> t a -> All :: *)
               ~R# (forall (t :: * -> *) a.
                    Foldable t =>
                    (a -> Bool) -> t a -> Bool :: *))

-- RHS size: {terms: 12, types: 28, coercions: 13, joins: 0/0}
Data.Foldable.$fFoldable:.:1
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. (:.:) f g a -> All
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,A,A,A,A,A,A,A,A,1*U,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a6L4U :: * -> *))
                 (@ (g_a6L4V :: * -> *))
                 ($dFoldable_a6L4W [Occ=Once] :: Foldable f_a6L4U)
                 ($dFoldable1_a6L4X [Occ=Once] :: Foldable g_a6L4V)
                 (@ a_a6L6K)
                 (ds_d6M2E [Occ=Once] :: (:.:) f_a6L4U g_a6L4V a_a6L6K) ->
                 foldMap
                   @ f_a6L4U
                   $dFoldable_a6L4W
                   @ All
                   @ (g_a6L4V a_a6L6K)
                   Data.Semigroup.Internal.$fMonoidAll
                   ((null @ g_a6L4V $dFoldable1_a6L4X @ a_a6L6K)
                    `cast` (<g_a6L4V a_a6L6K>_R
                            ->_R Sym (Data.Semigroup.Internal.N:All[0])
                            :: (g_a6L4V a_a6L6K -> Bool :: *)
                               ~R# (g_a6L4V a_a6L6K -> All :: *)))
                   (ds_d6M2E
                    `cast` (GHC.Generics.N::.:[0]
                                <*>_N <*>_N <f_a6L4U>_R <g_a6L4V>_N <a_a6L6K>_N
                            :: ((:.:) f_a6L4U g_a6L4V a_a6L6K :: *)
                               ~R# (f_a6L4U (g_a6L4V a_a6L6K) :: *)))}]
Data.Foldable.$fFoldable:.:1
  = \ (@ (f_a6L4U :: * -> *))
      (@ (g_a6L4V :: * -> *))
      ($dFoldable_a6L4W :: Foldable f_a6L4U)
      ($dFoldable1_a6L4X :: Foldable g_a6L4V)
      (@ a_a6L6K)
      (ds_d6M2E :: (:.:) f_a6L4U g_a6L4V a_a6L6K) ->
      foldMap
        @ f_a6L4U
        $dFoldable_a6L4W
        @ All
        @ (g_a6L4V a_a6L6K)
        Data.Semigroup.Internal.$fMonoidAll
        ((null @ g_a6L4V $dFoldable1_a6L4X @ a_a6L6K)
         `cast` (<g_a6L4V a_a6L6K>_R
                 ->_R Sym (Data.Semigroup.Internal.N:All[0])
                 :: (g_a6L4V a_a6L6K -> Bool :: *)
                    ~R# (g_a6L4V a_a6L6K -> All :: *)))
        (ds_d6M2E
         `cast` (GHC.Generics.N::.:[0]
                     <*>_N <*>_N <f_a6L4U>_R <g_a6L4V>_N <a_a6L6K>_N
                 :: ((:.:) f_a6L4U g_a6L4V a_a6L6K :: *)
                    ~R# (f_a6L4U (g_a6L4V a_a6L6K) :: *)))

-- RHS size: {terms: 15, types: 32, coercions: 8, joins: 0/0}
Data.Foldable.$fFoldable:.:_$cfold
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall m. Monoid m => (:.:) f g m -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_X6Lnt :: * -> *))
                 (@ (g_X6Lnv :: * -> *))
                 ($dFoldable_X6Lnx [Occ=Once] :: Foldable f_X6Lnt)
                 ($dFoldable1_X6Lnz [Occ=Once] :: Foldable g_X6Lnv)
                 (@ m_a6L51)
                 ($dMonoid_a6L53 :: Monoid m_a6L51)
                 (ds_d6M2C [Occ=Once] :: (:.:) f_X6Lnt g_X6Lnv m_a6L51) ->
                 foldMap
                   @ f_X6Lnt
                   $dFoldable_X6Lnx
                   @ m_a6L51
                   @ (g_X6Lnv m_a6L51)
                   $dMonoid_a6L53
                   (foldMap
                      @ g_X6Lnv
                      $dFoldable1_X6Lnz
                      @ m_a6L51
                      @ m_a6L51
                      $dMonoid_a6L53
                      (id @ m_a6L51))
                   (ds_d6M2C
                    `cast` (GHC.Generics.N::.:[0]
                                <*>_N <*>_N <f_X6Lnt>_R <g_X6Lnv>_N <m_a6L51>_N
                            :: ((:.:) f_X6Lnt g_X6Lnv m_a6L51 :: *)
                               ~R# (f_X6Lnt (g_X6Lnv m_a6L51) :: *)))}]
Data.Foldable.$fFoldable:.:_$cfold
  = \ (@ (f_X6Lnt :: * -> *))
      (@ (g_X6Lnv :: * -> *))
      ($dFoldable_X6Lnx :: Foldable f_X6Lnt)
      ($dFoldable1_X6Lnz :: Foldable g_X6Lnv)
      (@ m_a6L51)
      ($dMonoid_a6L53 :: Monoid m_a6L51)
      (ds_d6M2C :: (:.:) f_X6Lnt g_X6Lnv m_a6L51) ->
      foldMap
        @ f_X6Lnt
        $dFoldable_X6Lnx
        @ m_a6L51
        @ (g_X6Lnv m_a6L51)
        $dMonoid_a6L53
        (foldMap
           @ g_X6Lnv
           $dFoldable1_X6Lnz
           @ m_a6L51
           @ m_a6L51
           $dMonoid_a6L53
           (id @ m_a6L51))
        (ds_d6M2C
         `cast` (GHC.Generics.N::.:[0]
                     <*>_N <*>_N <f_X6Lnt>_R <g_X6Lnv>_N <m_a6L51>_N
                 :: ((:.:) f_X6Lnt g_X6Lnv m_a6L51 :: *)
                    ~R# (f_X6Lnt (g_X6Lnv m_a6L51) :: *)))

-- RHS size: {terms: 20, types: 42, coercions: 24, joins: 0/2}
Data.Foldable.$fFoldable:.:_$csum
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Num a => (:.:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30 0] 140 60}]
Data.Foldable.$fFoldable:.:_$csum
  = \ (@ (f_X6Lns :: * -> *))
      (@ (g_X6Lnu :: * -> *))
      ($dFoldable_X6Lnw :: Foldable f_X6Lns)
      ($dFoldable1_X6Lny :: Foldable g_X6Lnu)
      (@ a_a6L7y)
      ($dNum_a6L7A :: Num a_a6L7y) ->
      let {
        $dMonoid_s6MHF :: Monoid (Sum a_a6L7y)
        [LclId]
        $dMonoid_s6MHF
          = Data.Semigroup.Internal.$fMonoidSum @ a_a6L7y $dNum_a6L7A } in
      let {
        lvl1_s6MRc :: g_X6Lnu a_a6L7y -> Sum a_a6L7y
        [LclId]
        lvl1_s6MRc
          = foldMap
              @ g_X6Lnu
              $dFoldable1_X6Lny
              @ (Sum a_a6L7y)
              @ a_a6L7y
              $dMonoid_s6MHF
              ((Data.Foldable.$fFoldable:*:1 @ a_a6L7y)
               `cast` (<a_a6L7y>_R
                       ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a_a6L7y>_R)
                       :: (a_a6L7y -> a_a6L7y :: *)
                          ~R# (a_a6L7y -> Sum a_a6L7y :: *))) } in
      (\ (ds_d6M2C :: (:.:) f_X6Lns g_X6Lnu a_a6L7y) ->
         foldMap
           @ f_X6Lns
           $dFoldable_X6Lnw
           @ (Sum a_a6L7y)
           @ (g_X6Lnu a_a6L7y)
           $dMonoid_s6MHF
           lvl1_s6MRc
           (ds_d6M2C
            `cast` (GHC.Generics.N::.:[0]
                        <*>_N <*>_N <f_X6Lns>_R <g_X6Lnu>_N <a_a6L7y>_N
                    :: ((:.:) f_X6Lns g_X6Lnu a_a6L7y :: *)
                       ~R# (f_X6Lns (g_X6Lnu a_a6L7y) :: *))))
      `cast` (<(:.:) f_X6Lns g_X6Lnu a_a6L7y>_R
              ->_R Data.Semigroup.Internal.N:Sum[0] <a_a6L7y>_R
              :: ((:.:) f_X6Lns g_X6Lnu a_a6L7y -> Sum a_a6L7y :: *)
                 ~R# ((:.:) f_X6Lns g_X6Lnu a_a6L7y -> a_a6L7y :: *))

-- RHS size: {terms: 25, types: 46, coercions: 15, joins: 0/2}
Data.Foldable.$fFoldable:.:_$cminimum
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Ord a => (:.:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30 0] 160 60}]
Data.Foldable.$fFoldable:.:_$cminimum
  = \ (@ (f_X6Lnr :: * -> *))
      (@ (g_X6Lnt :: * -> *))
      ($dFoldable_X6Lnv :: Foldable f_X6Lnr)
      ($dFoldable1_X6Lnx :: Foldable g_X6Lnt)
      (@ a_a6L7o)
      ($dOrd_a6L7q :: Ord a_a6L7o) ->
      let {
        $dMonoid_s6MHA :: Monoid (Min a_a6L7o)
        [LclId]
        $dMonoid_s6MHA
          = Data.Functor.Utils.$fMonoidMin @ a_a6L7o $dOrd_a6L7q } in
      let {
        lvl1_s6MRh :: g_X6Lnt a_a6L7o -> Min a_a6L7o
        [LclId]
        lvl1_s6MRh
          = foldMap
              @ g_X6Lnt
              $dFoldable1_X6Lnx
              @ (Min a_a6L7o)
              @ a_a6L7o
              $dMonoid_s6MHA
              ((GHC.Base.Just @ a_a6L7o)
               `cast` (<a_a6L7o>_R
                       ->_R Sym (Data.Functor.Utils.N:Min[0]) <a_a6L7o>_N
                       :: (a_a6L7o -> Maybe a_a6L7o :: *)
                          ~R# (a_a6L7o -> Min a_a6L7o :: *))) } in
      \ (x_X6HLQ :: (:.:) f_X6Lnr g_X6Lnt a_a6L7o) ->
        case (foldMap
                @ f_X6Lnr
                $dFoldable_X6Lnv
                @ (Min a_a6L7o)
                @ (g_X6Lnt a_a6L7o)
                $dMonoid_s6MHA
                lvl1_s6MRh
                (x_X6HLQ
                 `cast` (GHC.Generics.N::.:[0]
                             <*>_N <*>_N <f_X6Lnr>_R <g_X6Lnt>_N <a_a6L7o>_N
                         :: ((:.:) f_X6Lnr g_X6Lnt a_a6L7o :: *)
                            ~R# (f_X6Lnr (g_X6Lnt a_a6L7o) :: *))))
             `cast` (Data.Functor.Utils.N:Min[0] <a_a6L7o>_N
                     :: (Min a_a6L7o :: *) ~R# (Maybe a_a6L7o :: *))
        of {
          Nothing -> Data.Foldable.$fFoldable:*:2 @ a_a6L7o;
          Just v_i6M0Z -> v_i6M0Z
        }

-- RHS size: {terms: 25, types: 46, coercions: 15, joins: 0/2}
Data.Foldable.$fFoldable:.:_$cmaximum
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Ord a => (:.:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30 0] 160 60}]
Data.Foldable.$fFoldable:.:_$cmaximum
  = \ (@ (f_X6Lnq :: * -> *))
      (@ (g_X6Lns :: * -> *))
      ($dFoldable_X6Lnu :: Foldable f_X6Lnq)
      ($dFoldable1_X6Lnw :: Foldable g_X6Lns)
      (@ a_a6L7e)
      ($dOrd_a6L7g :: Ord a_a6L7e) ->
      let {
        $dMonoid_s6MHw :: Monoid (Max a_a6L7e)
        [LclId]
        $dMonoid_s6MHw
          = Data.Functor.Utils.$fMonoidMax @ a_a6L7e $dOrd_a6L7g } in
      let {
        lvl1_s6MRm :: g_X6Lns a_a6L7e -> Max a_a6L7e
        [LclId]
        lvl1_s6MRm
          = foldMap
              @ g_X6Lns
              $dFoldable1_X6Lnw
              @ (Max a_a6L7e)
              @ a_a6L7e
              $dMonoid_s6MHw
              ((GHC.Base.Just @ a_a6L7e)
               `cast` (<a_a6L7e>_R
                       ->_R Sym (Data.Functor.Utils.N:Max[0]) <a_a6L7e>_N
                       :: (a_a6L7e -> Maybe a_a6L7e :: *)
                          ~R# (a_a6L7e -> Max a_a6L7e :: *))) } in
      \ (x_X6HLR :: (:.:) f_X6Lnq g_X6Lns a_a6L7e) ->
        case (foldMap
                @ f_X6Lnq
                $dFoldable_X6Lnu
                @ (Max a_a6L7e)
                @ (g_X6Lns a_a6L7e)
                $dMonoid_s6MHw
                lvl1_s6MRm
                (x_X6HLR
                 `cast` (GHC.Generics.N::.:[0]
                             <*>_N <*>_N <f_X6Lnq>_R <g_X6Lns>_N <a_a6L7e>_N
                         :: ((:.:) f_X6Lnq g_X6Lns a_a6L7e :: *)
                            ~R# (f_X6Lnq (g_X6Lns a_a6L7e) :: *))))
             `cast` (Data.Functor.Utils.N:Max[0] <a_a6L7e>_N
                     :: (Max a_a6L7e :: *) ~R# (Maybe a_a6L7e :: *))
        of {
          Nothing -> Data.Foldable.$fFoldable:*:3 @ a_a6L7e;
          Just v_i6M0Z -> v_i6M0Z
        }

-- RHS size: {terms: 20, types: 36, coercions: 22, joins: 0/1}
Data.Foldable.$fFoldable:.:_$celem
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Eq a => a -> (:.:) f g a -> Bool
[GblId,
 Arity=4,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 0] 140 60}]
Data.Foldable.$fFoldable:.:_$celem
  = \ (@ (f_X6Lnp :: * -> *))
      (@ (g_X6Lnr :: * -> *))
      ($dFoldable_X6Lnt :: Foldable f_X6Lnp)
      ($dFoldable1_X6Lnv :: Foldable g_X6Lnr)
      (@ a_a6L74)
      ($dEq_a6L76 :: Eq a_a6L74)
      (eta_B1 :: a_a6L74) ->
      let {
        lvl1_s6MRn :: g_X6Lnr a_a6L74 -> Data.Monoid.Any
        [LclId]
        lvl1_s6MRn
          = foldMap
              @ g_X6Lnr
              $dFoldable1_X6Lnv
              @ Data.Monoid.Any
              @ a_a6L74
              Data.Semigroup.Internal.$fMonoidAny
              ((== @ a_a6L74 $dEq_a6L76 eta_B1)
               `cast` (<a_a6L74>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0])
                       :: (a_a6L74 -> Bool :: *)
                          ~R# (a_a6L74 -> Data.Monoid.Any :: *))) } in
      (\ (ds_d6M2C :: (:.:) f_X6Lnp g_X6Lnr a_a6L74) ->
         foldMap
           @ f_X6Lnp
           $dFoldable_X6Lnt
           @ Data.Monoid.Any
           @ (g_X6Lnr a_a6L74)
           Data.Semigroup.Internal.$fMonoidAny
           lvl1_s6MRn
           (ds_d6M2C
            `cast` (GHC.Generics.N::.:[0]
                        <*>_N <*>_N <f_X6Lnp>_R <g_X6Lnr>_N <a_a6L74>_N
                    :: ((:.:) f_X6Lnp g_X6Lnr a_a6L74 :: *)
                       ~R# (f_X6Lnp (g_X6Lnr a_a6L74) :: *))))
      `cast` (<(:.:) f_X6Lnp g_X6Lnr a_a6L74>_R
              ->_R Data.Semigroup.Internal.N:Any[0]
              :: ((:.:) f_X6Lnp g_X6Lnr a_a6L74 -> Data.Monoid.Any :: *)
                 ~R# ((:.:) f_X6Lnp g_X6Lnr a_a6L74 -> Bool :: *))

-- RHS size: {terms: 35, types: 55, coercions: 8, joins: 0/1}
Data.Foldable.$fFoldable:.:_$cfoldr1
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. (a -> a -> a) -> (:.:) f g a -> a
[GblId,
 Arity=4,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 0] 230 0}]
Data.Foldable.$fFoldable:.:_$cfoldr1
  = \ (@ (f_X6Lnm :: * -> *))
      (@ (g_X6Lno :: * -> *))
      ($dFoldable_X6Lnq :: Foldable f_X6Lnm)
      ($dFoldable1_X6Lns :: Foldable g_X6Lno)
      (@ a_a6L6m)
      (f1_a6K7J :: a_a6L6m -> a_a6L6m -> a_a6L6m)
      (xs_a6K7K :: (:.:) f_X6Lnm g_X6Lno a_a6L6m) ->
      let {
        f2_s6MHr :: a_a6L6m -> Maybe a_a6L6m -> Maybe a_a6L6m
        [LclId,
         Arity=2,
         Str=<L,U><L,1*U>,
         Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True,
                 Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
                 Tmpl= \ (x_a6K7M [Occ=Once*] :: a_a6L6m)
                         (m_a6K7N [Occ=Once!] :: Maybe a_a6L6m) ->
                         GHC.Base.Just
                           @ a_a6L6m
                           (case m_a6K7N of {
                              Nothing -> x_a6K7M;
                              Just y_a6K7O [Occ=Once] -> f1_a6K7J x_a6K7M y_a6K7O
                            })}]
        f2_s6MHr
          = \ (x_a6K7M :: a_a6L6m) (m_a6K7N :: Maybe a_a6L6m) ->
              GHC.Base.Just
                @ a_a6L6m
                (case m_a6K7N of {
                   Nothing -> x_a6K7M;
                   Just y_a6K7O -> f1_a6K7J x_a6K7M y_a6K7O
                 }) } in
      case foldr
             @ f_X6Lnm
             $dFoldable_X6Lnq
             @ (g_X6Lno a_a6L6m)
             @ (Maybe a_a6L6m)
             (\ (b1_a6KpD :: g_X6Lno a_a6L6m) (b2_a6KpE :: Maybe a_a6L6m) ->
                foldr
                  @ g_X6Lno
                  $dFoldable1_X6Lns
                  @ a_a6L6m
                  @ (Maybe a_a6L6m)
                  f2_s6MHr
                  b2_a6KpE
                  b1_a6KpD)
             (GHC.Base.Nothing @ a_a6L6m)
             (xs_a6K7K
              `cast` (GHC.Generics.N::.:[0]
                          <*>_N <*>_N <f_X6Lnm>_R <g_X6Lno>_N <a_a6L6m>_N
                      :: ((:.:) f_X6Lnm g_X6Lno a_a6L6m :: *)
                         ~R# (f_X6Lnm (g_X6Lno a_a6L6m) :: *)))
      of {
        Nothing -> Data.Foldable.$fFoldable:.:3 @ a_a6L6m;
        Just v_i6M0Z -> v_i6M0Z
      }

-- RHS size: {terms: 32, types: 52, coercions: 8, joins: 0/1}
Data.Foldable.$fFoldable:.:_$cfoldl'
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (:.:) f g a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 0 0] 230 0}]
Data.Foldable.$fFoldable:.:_$cfoldl'
  = \ (@ (f_X6Lnl :: * -> *))
      (@ (g_X6Lnn :: * -> *))
      ($dFoldable_X6Lnp :: Foldable f_X6Lnl)
      ($dFoldable1_X6Lnr :: Foldable g_X6Lnn)
      (@ b_a6L6c)
      (@ a_a6L6d)
      (f1_a6K7C :: b_a6L6c -> a_a6L6d -> b_a6L6c)
      (z0_a6K7D :: b_a6L6c)
      (xs_a6K7E :: (:.:) f_X6Lnl g_X6Lnn a_a6L6d) ->
      let {
        f2_s6MHp :: a_a6L6d -> (b_a6L6c -> b_a6L6c) -> b_a6L6c -> b_a6L6c
        [LclId,
         Arity=3,
         Str=<L,U><C(S),1*C1(U)><L,U>,
         Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                 WorkFree=True, Expandable=True,
                 Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
                 Tmpl= \ (x_a6K7G [Occ=Once] :: a_a6L6d)
                         (k_a6K7H [Occ=Once!] :: b_a6L6c -> b_a6L6c)
                         (z_a6K7I [Occ=Once] :: b_a6L6c) ->
                         case f1_a6K7C z_a6K7I x_a6K7G of vx_i6M0K { __DEFAULT ->
                         k_a6K7H vx_i6M0K
                         }}]
        f2_s6MHp
          = \ (x_a6K7G :: a_a6L6d)
              (k_a6K7H :: b_a6L6c -> b_a6L6c)
              (z_a6K7I :: b_a6L6c) ->
              case f1_a6K7C z_a6K7I x_a6K7G of vx_i6M0K { __DEFAULT ->
              k_a6K7H vx_i6M0K
              } } in
      foldr
        @ f_X6Lnl
        $dFoldable_X6Lnp
        @ (g_X6Lnn a_a6L6d)
        @ (b_a6L6c -> b_a6L6c)
        (\ (b1_a6KpD :: g_X6Lnn a_a6L6d)
           (b2_a6KpE :: b_a6L6c -> b_a6L6c) ->
           foldr
             @ g_X6Lnn
             $dFoldable1_X6Lnr
             @ a_a6L6d
             @ (b_a6L6c -> b_a6L6c)
             f2_s6MHp
             b2_a6KpE
             b1_a6KpD)
        (id @ b_a6L6c)
        (xs_a6K7E
         `cast` (GHC.Generics.N::.:[0]
                     <*>_N <*>_N <f_X6Lnl>_R <g_X6Lnn>_N <a_a6L6d>_N
                 :: ((:.:) f_X6Lnl g_X6Lnn a_a6L6d :: *)
                    ~R# (f_X6Lnl (g_X6Lnn a_a6L6d) :: *)))
        z0_a6K7D

-- RHS size: {terms: 12, types: 27, coercions: 0, joins: 0/0}
Data.Foldable.$fFoldable:.:_$clength
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. (:.:) f g a -> Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_X6Lno :: * -> *))
                 (@ (g_X6Lnq :: * -> *))
                 ($dFoldable_X6Lns [Occ=Once] :: Foldable f_X6Lno)
                 ($dFoldable1_X6Lnu [Occ=Once] :: Foldable g_X6Lnq)
                 (@ a_a6L6W)
                 (eta_B1 [Occ=Once] :: (:.:) f_X6Lno g_X6Lnq a_a6L6W) ->
                 Data.Foldable.$fFoldable:.:_$cfoldl'
                   @ f_X6Lno
                   @ g_X6Lnq
                   $dFoldable_X6Lns
                   $dFoldable1_X6Lnu
                   @ Int
                   @ a_a6L6W
                   (Data.Foldable.$fFoldable:*:5 @ a_a6L6W)
                   Data.Foldable.$fFoldable:*:4
                   eta_B1}]
Data.Foldable.$fFoldable:.:_$clength
  = \ (@ (f_X6Lno :: * -> *))
      (@ (g_X6Lnq :: * -> *))
      ($dFoldable_X6Lns :: Foldable f_X6Lno)
      ($dFoldable1_X6Lnu :: Foldable g_X6Lnq)
      (@ a_a6L6W)
      (eta_B1 :: (:.:) f_X6Lno g_X6Lnq a_a6L6W) ->
      Data.Foldable.$fFoldable:.:_$cfoldl'
        @ f_X6Lno
        @ g_X6Lnq
        $dFoldable_X6Lns
        $dFoldable1_X6Lnu
        @ Int
        @ a_a6L6W
        (Data.Foldable.$fFoldable:*:5 @ a_a6L6W)
        Data.Foldable.$fFoldable:*:4
        eta_B1

-- RHS size: {terms: 22, types: 43, coercions: 17, joins: 0/0}
Data.Foldable.$fFoldable:.:_$cfoldl
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall b a. (b -> a -> b) -> b -> (:.:) f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 0 0] 150 0}]
Data.Foldable.$fFoldable:.:_$cfoldl
  = \ (@ (f_X6Lnk :: * -> *))
      (@ (g_X6Lnm :: * -> *))
      ($dFoldable_X6Lno :: Foldable f_X6Lnk)
      ($dFoldable1_X6Lnq :: Foldable g_X6Lnm)
      (@ b_a6L62)
      (@ a_a6L63)
      (f1_a6K7z :: b_a6L62 -> a_a6L63 -> b_a6L62)
      (z_a6K7A :: b_a6L62)
      (t_a6K7B :: (:.:) f_X6Lnk g_X6Lnm a_a6L63) ->
      ((foldMap
          @ f_X6Lnk
          $dFoldable_X6Lno
          @ (Dual (Endo b_a6L62))
          @ (g_X6Lnm a_a6L63)
          (Data.Foldable.$fFoldable:*:7 @ b_a6L62)
          (foldMap
             @ g_X6Lnm
             $dFoldable1_X6Lnq
             @ (Dual (Endo b_a6L62))
             @ a_a6L63
             (Data.Foldable.$fFoldable:*:7 @ b_a6L62)
             ((\ (x_X6HLX :: a_a6L63) (y_i6M0a :: b_a6L62) ->
                 f1_a6K7z y_i6M0a x_X6HLX)
              `cast` (<a_a6L63>_R
                      ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                    (Data.Semigroup.Internal.N:Endo[0] <b_a6L62>_R))
                      :: (a_a6L63 -> b_a6L62 -> b_a6L62 :: *)
                         ~R# (a_a6L63 -> Dual (Endo b_a6L62) :: *))))
          (t_a6K7B
           `cast` (GHC.Generics.N::.:[0]
                       <*>_N <*>_N <f_X6Lnk>_R <g_X6Lnm>_N <a_a6L63>_N
                   :: ((:.:) f_X6Lnk g_X6Lnm a_a6L63 :: *)
                      ~R# (f_X6Lnk (g_X6Lnm a_a6L63) :: *))))
       `cast` (Data.Semigroup.Internal.N:Dual[0]
                   (Data.Semigroup.Internal.N:Endo[0] <b_a6L62>_R)
               :: (Dual (Endo b_a6L62) :: *) ~R# (b_a6L62 -> b_a6L62 :: *)))
        z_a6K7A

-- RHS size: {terms: 31, types: 54, coercions: 19, joins: 0/0}
Data.Foldable.$fFoldable:.:_$cfoldl1
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. (a -> a -> a) -> (:.:) f g a -> a
[GblId,
 Arity=4,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 0] 200 0}]
Data.Foldable.$fFoldable:.:_$cfoldl1
  = \ (@ (f_X6Lnn :: * -> *))
      (@ (g_X6Lnp :: * -> *))
      ($dFoldable_X6Lnr :: Foldable f_X6Lnn)
      ($dFoldable1_X6Lnt :: Foldable g_X6Lnp)
      (@ a_a6L6u)
      (f1_X6Kqo :: a_a6L6u -> a_a6L6u -> a_a6L6u)
      (xs_X6Kqq :: (:.:) f_X6Lnn g_X6Lnp a_a6L6u) ->
      case ((foldMap
               @ f_X6Lnn
               $dFoldable_X6Lnr
               @ (Dual (Endo (Maybe a_a6L6u)))
               @ (g_X6Lnp a_a6L6u)
               (Data.Foldable.$fFoldable:*:7 @ (Maybe a_a6L6u))
               (foldMap
                  @ g_X6Lnp
                  $dFoldable1_X6Lnt
                  @ (Dual (Endo (Maybe a_a6L6u)))
                  @ a_a6L6u
                  (Data.Foldable.$fFoldable:*:7 @ (Maybe a_a6L6u))
                  ((\ (x_X6HLX :: a_a6L6u) (y_i6M0a :: Maybe a_a6L6u) ->
                      GHC.Base.Just
                        @ a_a6L6u
                        (case y_i6M0a of {
                           Nothing -> x_X6HLX;
                           Just x1_a6K7U -> f1_X6Kqo x1_a6K7U x_X6HLX
                         }))
                   `cast` (<a_a6L6u>_R
                           ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                         (Data.Semigroup.Internal.N:Endo[0] <Maybe a_a6L6u>_R))
                           :: (a_a6L6u -> Maybe a_a6L6u -> Maybe a_a6L6u :: *)
                              ~R# (a_a6L6u -> Dual (Endo (Maybe a_a6L6u)) :: *))))
               (xs_X6Kqq
                `cast` (GHC.Generics.N::.:[0]
                            <*>_N <*>_N <f_X6Lnn>_R <g_X6Lnp>_N <a_a6L6u>_N
                        :: ((:.:) f_X6Lnn g_X6Lnp a_a6L6u :: *)
                           ~R# (f_X6Lnn (g_X6Lnp a_a6L6u) :: *))))
            `cast` (Data.Semigroup.Internal.N:Dual[0]
                        (Data.Semigroup.Internal.N:Endo[0] <Maybe a_a6L6u>_R)
                    :: (Dual (Endo (Maybe a_a6L6u)) :: *)
                       ~R# (Maybe a_a6L6u -> Maybe a_a6L6u :: *)))
             (GHC.Base.Nothing @ a_a6L6u)
      of {
        Nothing -> Data.Foldable.$fFoldable:.:2 @ a_a6L6u;
        Just v_i6M0Z -> v_i6M0Z
      }

-- RHS size: {terms: 28, types: 51, coercions: 19, joins: 0/0}
Data.Foldable.$fFoldable:.:_$cfoldr'
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a b. (a -> b -> b) -> b -> (:.:) f g a -> b
[GblId,
 Arity=5,
 Str=<S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 0 0] 200 0}]
Data.Foldable.$fFoldable:.:_$cfoldr'
  = \ (@ (f_X6Lnj :: * -> *))
      (@ (g_X6Lnl :: * -> *))
      ($dFoldable_X6Lnn :: Foldable f_X6Lnj)
      ($dFoldable1_X6Lnp :: Foldable g_X6Lnl)
      (@ a_a6L5S)
      (@ b_a6L5T)
      (f1_a6K7s :: a_a6L5S -> b_a6L5T -> b_a6L5T)
      (z0_a6K7t :: b_a6L5T)
      (xs_a6K7u :: (:.:) f_X6Lnj g_X6Lnl a_a6L5S) ->
      ((foldMap
          @ f_X6Lnj
          $dFoldable_X6Lnn
          @ (Dual (Endo (b_a6L5T -> b_a6L5T)))
          @ (g_X6Lnl a_a6L5S)
          (Data.Foldable.$fFoldable:*:7 @ (b_a6L5T -> b_a6L5T))
          (foldMap
             @ g_X6Lnl
             $dFoldable1_X6Lnp
             @ (Dual (Endo (b_a6L5T -> b_a6L5T)))
             @ a_a6L5S
             (Data.Foldable.$fFoldable:*:7 @ (b_a6L5T -> b_a6L5T))
             ((\ (x_X6HLX :: a_a6L5S)
                 (y_i6M0a :: b_a6L5T -> b_a6L5T)
                 (z_a6K7y :: b_a6L5T) ->
                 case f1_a6K7s x_X6HLX z_a6K7y of vx_i6M0K { __DEFAULT ->
                 y_i6M0a vx_i6M0K
                 })
              `cast` (<a_a6L5S>_R
                      ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                    (Data.Semigroup.Internal.N:Endo[0] <b_a6L5T -> b_a6L5T>_R))
                      :: (a_a6L5S -> (b_a6L5T -> b_a6L5T) -> b_a6L5T -> b_a6L5T :: *)
                         ~R# (a_a6L5S -> Dual (Endo (b_a6L5T -> b_a6L5T)) :: *))))
          (xs_a6K7u
           `cast` (GHC.Generics.N::.:[0]
                       <*>_N <*>_N <f_X6Lnj>_R <g_X6Lnl>_N <a_a6L5S>_N
                   :: ((:.:) f_X6Lnj g_X6Lnl a_a6L5S :: *)
                      ~R# (f_X6Lnj (g_X6Lnl a_a6L5S) :: *))))
       `cast` (Data.Semigroup.Internal.N:Dual[0]
                   (Data.Semigroup.Internal.N:Endo[0] <b_a6L5T -> b_a6L5T>_R)
               :: (Dual (Endo (b_a6L5T -> b_a6L5T)) :: *)
                  ~R# ((b_a6L5T -> b_a6L5T) -> b_a6L5T -> b_a6L5T :: *)))
        (id @ b_a6L5T) z0_a6K7t

-- RHS size: {terms: 20, types: 42, coercions: 24, joins: 0/2}
Data.Foldable.$fFoldable:.:_$cproduct
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. Num a => (:.:) f g a -> a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30 0] 140 60}]
Data.Foldable.$fFoldable:.:_$cproduct
  = \ (@ (f_X6Lni :: * -> *))
      (@ (g_X6Lnk :: * -> *))
      ($dFoldable_X6Lnm :: Foldable f_X6Lni)
      ($dFoldable1_X6Lno :: Foldable g_X6Lnk)
      (@ a_a6L7I)
      ($dNum_a6L7K :: Num a_a6L7I) ->
      let {
        $dMonoid_s6MHl :: Monoid (Product a_a6L7I)
        [LclId]
        $dMonoid_s6MHl
          = Data.Semigroup.Internal.$fMonoidProduct
              @ a_a6L7I $dNum_a6L7K } in
      let {
        lvl1_s6MRA :: g_X6Lnk a_a6L7I -> Product a_a6L7I
        [LclId]
        lvl1_s6MRA
          = foldMap
              @ g_X6Lnk
              $dFoldable1_X6Lno
              @ (Product a_a6L7I)
              @ a_a6L7I
              $dMonoid_s6MHl
              ((Data.Foldable.$fFoldable:*:1 @ a_a6L7I)
               `cast` (<a_a6L7I>_R
                       ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a_a6L7I>_R)
                       :: (a_a6L7I -> a_a6L7I :: *)
                          ~R# (a_a6L7I -> Product a_a6L7I :: *))) } in
      (\ (ds_d6M2C :: (:.:) f_X6Lni g_X6Lnk a_a6L7I) ->
         foldMap
           @ f_X6Lni
           $dFoldable_X6Lnm
           @ (Product a_a6L7I)
           @ (g_X6Lnk a_a6L7I)
           $dMonoid_s6MHl
           lvl1_s6MRA
           (ds_d6M2C
            `cast` (GHC.Generics.N::.:[0]
                        <*>_N <*>_N <f_X6Lni>_R <g_X6Lnk>_N <a_a6L7I>_N
                    :: ((:.:) f_X6Lni g_X6Lnk a_a6L7I :: *)
                       ~R# (f_X6Lni (g_X6Lnk a_a6L7I) :: *))))
      `cast` (<(:.:) f_X6Lni g_X6Lnk a_a6L7I>_R
              ->_R Data.Semigroup.Internal.N:Product[0] <a_a6L7I>_R
              :: ((:.:) f_X6Lni g_X6Lnk a_a6L7I -> Product a_a6L7I :: *)
                 ~R# ((:.:) f_X6Lni g_X6Lnk a_a6L7I -> a_a6L7I :: *))

-- RHS size: {terms: 17, types: 37, coercions: 8, joins: 0/0}
Data.Foldable.$fFoldable:.:_$ctoList [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     forall a. (:.:) f g a -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (f_X6Lnh :: * -> *))
                 (@ (g_X6Lnj :: * -> *))
                 ($dFoldable_X6Lnl [Occ=Once] :: Foldable f_X6Lnh)
                 ($dFoldable1_X6Lnn [Occ=Once] :: Foldable g_X6Lnj)
                 (@ a_a6L6C)
                 (t_a6K7V [Occ=Once] :: (:.:) f_X6Lnh g_X6Lnj a_a6L6C) ->
                 build
                   @ a_a6L6C
                   (\ (@ b_a6KNB)
                      (c_a6K7W [Occ=Once, OS=OneShot] :: a_a6L6C -> b_a6KNB -> b_a6KNB)
                      (n_a6K7X [Occ=Once, OS=OneShot] :: b_a6KNB) ->
                      Data.Foldable.$fFoldable:.:_$cfoldr
                        @ f_X6Lnh
                        @ g_X6Lnj
                        $dFoldable_X6Lnl
                        $dFoldable1_X6Lnn
                        @ a_a6L6C
                        @ b_a6KNB
                        c_a6K7W
                        n_a6K7X
                        t_a6K7V)}]
Data.Foldable.$fFoldable:.:_$ctoList
  = \ (@ (f_X6Lnh :: * -> *))
      (@ (g_X6Lnj :: * -> *))
      ($dFoldable_X6Lnl :: Foldable f_X6Lnh)
      ($dFoldable1_X6Lnn :: Foldable g_X6Lnj)
      (@ a_a6L6C)
      (eta_XiD :: (:.:) f_X6Lnh g_X6Lnj a_a6L6C) ->
      foldr
        @ f_X6Lnh
        $dFoldable_X6Lnl
        @ (g_X6Lnj a_a6L6C)
        @ [a_a6L6C]
        (\ (b1_a6KpD :: g_X6Lnj a_a6L6C) (b2_a6KpE :: [a_a6L6C]) ->
           foldr
             @ g_X6Lnj
             $dFoldable1_X6Lnn
             @ a_a6L6C
             @ [a_a6L6C]
             (GHC.Types.: @ a_a6L6C)
             b2_a6KpE
             b1_a6KpD)
        (GHC.Types.[] @ a_a6L6C)
        (eta_XiD
         `cast` (GHC.Generics.N::.:[0]
                     <*>_N <*>_N <f_X6Lnh>_R <g_X6Lnj>_N <a_a6L6C>_N
                 :: ((:.:) f_X6Lnh g_X6Lnj a_a6L6C :: *)
                    ~R# (f_X6Lnh (g_X6Lnj a_a6L6C) :: *)))

-- RHS size: {terms: 53, types: 51, coercions: 13, joins: 0/0}
Data.Foldable.$fFoldable:.: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Foldable f, Foldable g) =>
     Foldable (f :.: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),C(C1(C1(U))),A,A,A,A,A,A,U,A,A,A,A,A,A)>,
 Unf=DFun: \ (@ (f_a6Kau :: * -> *))
             (@ (g_a6Kav :: * -> *))
             (v_XiB :: Foldable f_a6Kau)
             (v1_Xir :: Foldable g_a6Kav) ->
       Data.Foldable.C:Foldable TYPE: f_a6Kau :.: g_a6Kav
                                Data.Foldable.$fFoldable:.:_$cfold @ f_a6Kau @ g_a6Kav v_XiB v1_Xir
                                Data.Foldable.$fFoldable:.:_$cfoldMap
                                  @ f_a6Kau @ g_a6Kav v_XiB v1_Xir
                                Data.Foldable.$fFoldable:.:_$cfoldr
                                  @ f_a6Kau @ g_a6Kav v_XiB v1_Xir
                                Data.Foldable.$fFoldable:.:_$cfoldr'
                                  @ f_a6Kau @ g_a6Kav v_XiB v1_Xir
                                Data.Foldable.$fFoldable:.:_$cfoldl
                                  @ f_a6Kau @ g_a6Kav v_XiB v1_Xir
                                Data.Foldable.$fFoldable:.:_$cfoldl'
                                  @ f_a6Kau @ g_a6Kav v_XiB v1_Xir
                                Data.Foldable.$fFoldable:.:_$cfoldr1
                                  @ f_a6Kau @ g_a6Kav v_XiB v1_Xir
                                Data.Foldable.$fFoldable:.:_$cfoldl1
                                  @ f_a6Kau @ g_a6Kav v_XiB v1_Xir
                                Data.Foldable.$fFoldable:.:_$ctoList
                                  @ f_a6Kau @ g_a6Kav v_XiB v1_Xir
                                (Data.Foldable.$fFoldable:.:1 @ f_a6Kau @ g_a6Kav v_XiB v1_Xir)
                                `cast` (forall (a :: <*>_N).
                                        <(:.:) f_a6Kau g_a6Kav a>_R
                                        ->_R Data.Semigroup.Internal.N:All[0]
                                        :: (forall a. (:.:) f_a6Kau g_a6Kav a -> All :: *)
                                           ~R# (forall a. (:.:) f_a6Kau g_a6Kav a -> Bool :: *))
                                Data.Foldable.$fFoldable:.:_$clength
                                  @ f_a6Kau @ g_a6Kav v_XiB v1_Xir
                                Data.Foldable.$fFoldable:.:_$celem @ f_a6Kau @ g_a6Kav v_XiB v1_Xir
                                Data.Foldable.$fFoldable:.:_$cmaximum
                                  @ f_a6Kau @ g_a6Kav v_XiB v1_Xir
                                Data.Foldable.$fFoldable:.:_$cminimum
                                  @ f_a6Kau @ g_a6Kav v_XiB v1_Xir
                                Data.Foldable.$fFoldable:.:_$csum @ f_a6Kau @ g_a6Kav v_XiB v1_Xir
                                Data.Foldable.$fFoldable:.:_$cproduct
                                  @ f_a6Kau @ g_a6Kav v_XiB v1_Xir]
Data.Foldable.$fFoldable:.:
  = \ (@ (f_X6Lng :: * -> *))
      (@ (g_X6Lni :: * -> *))
      ($dFoldable_X6Lnk :: Foldable f_X6Lng)
      ($dFoldable1_X6Lnm :: Foldable g_X6Lni) ->
      Data.Foldable.C:Foldable
        @ (f_X6Lng :.: g_X6Lni)
        (Data.Foldable.$fFoldable:.:_$cfold
           @ f_X6Lng @ g_X6Lni $dFoldable_X6Lnk $dFoldable1_X6Lnm)
        (Data.Foldable.$fFoldable:.:_$cfoldMap
           @ f_X6Lng @ g_X6Lni $dFoldable_X6Lnk $dFoldable1_X6Lnm)
        (Data.Foldable.$fFoldable:.:_$cfoldr
           @ f_X6Lng @ g_X6Lni $dFoldable_X6Lnk $dFoldable1_X6Lnm)
        (Data.Foldable.$fFoldable:.:_$cfoldr'
           @ f_X6Lng @ g_X6Lni $dFoldable_X6Lnk $dFoldable1_X6Lnm)
        (Data.Foldable.$fFoldable:.:_$cfoldl
           @ f_X6Lng @ g_X6Lni $dFoldable_X6Lnk $dFoldable1_X6Lnm)
        (Data.Foldable.$fFoldable:.:_$cfoldl'
           @ f_X6Lng @ g_X6Lni $dFoldable_X6Lnk $dFoldable1_X6Lnm)
        (Data.Foldable.$fFoldable:.:_$cfoldr1
           @ f_X6Lng @ g_X6Lni $dFoldable_X6Lnk $dFoldable1_X6Lnm)
        (Data.Foldable.$fFoldable:.:_$cfoldl1
           @ f_X6Lng @ g_X6Lni $dFoldable_X6Lnk $dFoldable1_X6Lnm)
        (Data.Foldable.$fFoldable:.:_$ctoList
           @ f_X6Lng @ g_X6Lni $dFoldable_X6Lnk $dFoldable1_X6Lnm)
        ((Data.Foldable.$fFoldable:.:1
            @ f_X6Lng @ g_X6Lni $dFoldable_X6Lnk $dFoldable1_X6Lnm)
         `cast` (forall (a :: <*>_N).
                 <(:.:) f_X6Lng g_X6Lni a>_R ->_R Data.Semigroup.Internal.N:All[0]
                 :: (forall a. (:.:) f_X6Lng g_X6Lni a -> All :: *)
                    ~R# (forall a. (:.:) f_X6Lng g_X6Lni a -> Bool :: *)))
        (Data.Foldable.$fFoldable:.:_$clength
           @ f_X6Lng @ g_X6Lni $dFoldable_X6Lnk $dFoldable1_X6Lnm)
        (Data.Foldable.$fFoldable:.:_$celem
           @ f_X6Lng @ g_X6Lni $dFoldable_X6Lnk $dFoldable1_X6Lnm)
        (Data.Foldable.$fFoldable:.:_$cmaximum
           @ f_X6Lng @ g_X6Lni $dFoldable_X6Lnk $dFoldable1_X6Lnm)
        (Data.Foldable.$fFoldable:.:_$cminimum
           @ f_X6Lng @ g_X6Lni $dFoldable_X6Lnk $dFoldable1_X6Lnm)
        (Data.Foldable.$fFoldable:.:_$csum
           @ f_X6Lng @ g_X6Lni $dFoldable_X6Lnk $dFoldable1_X6Lnm)
        (Data.Foldable.$fFoldable:.:_$cproduct
           @ f_X6Lng @ g_X6Lni $dFoldable_X6Lnk $dFoldable1_X6Lnm)

-- RHS size: {terms: 16, types: 16, coercions: 0, joins: 0/0}
maximumBy
  :: forall (t :: * -> *) a.
     Foldable t =>
     (a -> a -> Ordering) -> t a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)LLLLLLLL),1*U(A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A)><L,C(C1(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 60] 100 0}]
maximumBy
  = \ (@ (t_a6KCV :: * -> *))
      (@ a_a6KCW)
      ($dFoldable_a6KCY :: Foldable t_a6KCV)
      (cmp_a6Kaj :: a_a6KCW -> a_a6KCW -> Ordering) ->
      foldl1
        @ t_a6KCV
        $dFoldable_a6KCY
        @ a_a6KCW
        (\ (x_a6Kal :: a_a6KCW) (y_a6Kam :: a_a6KCW) ->
           case cmp_a6Kaj x_a6Kal y_a6Kam of {
             __DEFAULT -> y_a6Kam;
             GT -> x_a6Kal
           })

-- RHS size: {terms: 16, types: 16, coercions: 0, joins: 0/0}
minimumBy
  :: forall (t :: * -> *) a.
     Foldable t =>
     (a -> a -> Ordering) -> t a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)LLLLLLLL),1*U(A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A,A)><L,C(C1(U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 60] 100 0}]
minimumBy
  = \ (@ (t_a6KCx :: * -> *))
      (@ a_a6KCy)
      ($dFoldable_a6KCA :: Foldable t_a6KCx)
      (cmp_a6Kan :: a_a6KCy -> a_a6KCy -> Ordering) ->
      foldl1
        @ t_a6KCx
        $dFoldable_a6KCA
        @ a_a6KCy
        (\ (x_a6Kap :: a_a6KCy) (y_a6Kaq :: a_a6KCy) ->
           case cmp_a6Kan x_a6Kap y_a6Kaq of {
             __DEFAULT -> x_a6Kap;
             GT -> y_a6Kaq
           })

-- RHS size: {terms: 18, types: 19, coercions: 0, joins: 0/1}
notElem
  :: forall (t :: * -> *) a. (Foldable t, Eq a) => a -> t a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(C(U))),A,A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (t_a6KCk :: * -> *))
                 (@ a_a6KCl)
                 ($dFoldable_a6KCn [Occ=Once] :: Foldable t_a6KCk)
                 ($dEq_a6KCo [Occ=Once] :: Eq a_a6KCl)
                 (x_a6Kar [Occ=Once] :: a_a6KCl) ->
                 let {
                   g_s6MHh [Occ=OnceL!] :: t_a6KCk a_a6KCl -> Bool
                   [LclId]
                   g_s6MHh
                     = elem @ t_a6KCk $dFoldable_a6KCn @ a_a6KCl $dEq_a6KCo x_a6Kar } in
                 \ (x1_i6HAl [Occ=Once] :: t_a6KCk a_a6KCl) ->
                   case g_s6MHh x1_i6HAl of {
                     False -> GHC.Types.True;
                     True -> GHC.Types.False
                   }}]
notElem
  = \ (@ (t_a6KCk :: * -> *))
      (@ a_a6KCl)
      ($dFoldable_a6KCn :: Foldable t_a6KCk)
      ($dEq_a6KCo :: Eq a_a6KCl)
      (x_a6Kar :: a_a6KCl) ->
      let {
        g_s6MHh [Dmd=<L,C(U)>] :: t_a6KCk a_a6KCl -> Bool
        [LclId]
        g_s6MHh
          = elem @ t_a6KCk $dFoldable_a6KCn @ a_a6KCl $dEq_a6KCo x_a6Kar } in
      \ (x1_i6HAl :: t_a6KCk a_a6KCl) ->
        case g_s6MHh x1_i6HAl of {
          False -> GHC.Types.True;
          True -> GHC.Types.False
        }

-- RHS size: {terms: 20, types: 25, coercions: 10, joins: 0/1}
find
  :: forall (t :: * -> *) a.
     Foldable t =>
     (a -> Bool) -> t a -> Maybe a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 60] 140 60}]
find
  = \ (@ (t_a6KC3 :: * -> *))
      (@ a_a6KC4)
      ($dFoldable_a6KC6 :: Foldable t_a6KC3)
      (p_a6Kas :: a_a6KC4 -> Bool) ->
      let {
        g_s6MHf [Dmd=<L,C(U)>] :: t_a6KC3 a_a6KC4 -> First a_a6KC4
        [LclId]
        g_s6MHf
          = foldMap
              @ t_a6KC3
              $dFoldable_a6KC6
              @ (First a_a6KC4)
              @ a_a6KC4
              (Data.Monoid.$fMonoidFirst @ a_a6KC4)
              ((\ (x_a6Kat :: a_a6KC4) ->
                  case p_a6Kas x_a6Kat of {
                    False -> GHC.Base.Nothing @ a_a6KC4;
                    True -> GHC.Base.Just @ a_a6KC4 x_a6Kat
                  })
               `cast` (<a_a6KC4>_R ->_R Sym (Data.Monoid.N:First[0]) <a_a6KC4>_N
                       :: (a_a6KC4 -> Maybe a_a6KC4 :: *)
                          ~R# (a_a6KC4 -> First a_a6KC4 :: *))) } in
      (\ (x_i6HAl :: t_a6KC3 a_a6KC4) -> g_s6MHf x_i6HAl)
      `cast` (<t_a6KC3 a_a6KC4>_R ->_R Data.Monoid.N:First[0] <a_a6KC4>_N
              :: (t_a6KC3 a_a6KC4 -> First a_a6KC4 :: *)
                 ~R# (t_a6KC3 a_a6KC4 -> Maybe a_a6KC4 :: *))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Foldable.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Foldable.$trModule3
  = GHC.Types.TrNameS Data.Foldable.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Data.Foldable.$trModule2 = "Data.Foldable"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Foldable.$trModule1
  = GHC.Types.TrNameS Data.Foldable.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Foldable.$trModule
  = GHC.Types.Module
      Data.Foldable.$trModule3 Data.Foldable.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_r6OSX :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_r6OSX
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcConstraint (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$tcFoldable1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Foldable.$tcFoldable1
  = GHC.Types.KindRepFun GHC.Types.krep$*Arr* $krep_r6OSX

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$tcFoldable3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Foldable.$tcFoldable3 = "Foldable"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$tcFoldable2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Foldable.$tcFoldable2
  = GHC.Types.TrNameS Data.Foldable.$tcFoldable3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Foldable.$tcFoldable :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Foldable.$tcFoldable
  = GHC.Types.TyCon
      1610127274683713266##
      5928938033451775936##
      Data.Foldable.$trModule
      Data.Foldable.$tcFoldable2
      0#
      Data.Foldable.$tcFoldable1


