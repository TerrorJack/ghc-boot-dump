
==================== Output Cmm ====================
2018-03-16 16:06:56.181684333 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:56.183066492 UTC

[section ""data" . Data.List.isSubsequenceOf_closure" {
     Data.List.isSubsequenceOf_closure:
         const Data.List.isSubsequenceOf_info;
 },
 Data.List.isSubsequenceOf_entry() //  [R2, R3, R4]
         { info_tbl: [(cc20g,
                       label: Data.List.isSubsequenceOf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc20g: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cc20h; else goto uc20O;
       cc20h: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.isSubsequenceOf_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uc20O: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cc206() args: 0, res: 0, upd: 0;
     }
 },
 _cc206() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc206: // global
           I64[Sp - 8] = block_cc209_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc20R; else goto cc20a;
       uc20R: // global
           call _cc209(R1) args: 0, res: 0, upd: 0;
       cc20a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc209() //  [R1]
         { info_tbl: [(cc209,
                       label: block_cc209_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc209: // global
           if (R1 & 7 == 1) goto cc20d; else goto cc20e;
       cc20d: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc20e: // global
           I64[Sp - 8] = block_cc20o_info;
           _sc1ZY::P64 = R1;
           _sc1ZZ::P64 = P64[R1 + 6];
           _sc200::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _sc200::P64;
           P64[Sp + 16] = _sc1ZZ::P64;
           P64[Sp + 24] = _sc1ZY::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc20S; else goto cc20q;
       uc20S: // global
           call _cc20o(R1) args: 0, res: 0, upd: 0;
       cc20q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc20o() //  [R1]
         { info_tbl: [(cc20o,
                       label: block_cc20o_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc20o: // global
           if (R1 & 7 == 1) goto cc20w; else goto cc20B;
       cc20w: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc20B: // global
           I64[Sp] = block_cc20z_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp + 24] = P64[R1 + 14];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cc20z() //  [R1]
         { info_tbl: [(cc20z,
                       label: block_cc20z_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc20z: // global
           _sc1ZV::P64 = P64[Sp + 16];
           _sc203::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cc20H; else goto cc20L;
       cc20H: // global
           P64[Sp + 16] = _sc1ZV::P64;
           P64[Sp + 24] = P64[Sp + 32];
           P64[Sp + 32] = _sc203::P64;
           Sp = Sp + 16;
           goto uc20V;
       cc20L: // global
           P64[Sp + 16] = _sc1ZV::P64;
           P64[Sp + 24] = P64[Sp + 8];
           P64[Sp + 32] = _sc203::P64;
           Sp = Sp + 16;
           goto uc20V;
       uc20V: // global
           call _cc206() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.1849246 UTC

[section ""cstring" . Data.List.$trModule4_bytes" {
     Data.List.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.185518359 UTC

[section ""data" . Data.List.$trModule3_closure" {
     Data.List.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.List.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.186101261 UTC

[section ""cstring" . Data.List.$trModule2_bytes" {
     Data.List.$trModule2_bytes:
         I8[] [68,97,116,97,46,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.186690429 UTC

[section ""data" . Data.List.$trModule1_closure" {
     Data.List.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.List.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.187284909 UTC

[section ""data" . Data.List.$trModule_closure" {
     Data.List.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.List.$trModule3_closure+1;
         const Data.List.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.18787421 UTC

[section ""relreadonly" . Sc20W_srt" { Sc20W_srt:
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.188399834 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:56.189631682 UTC

[section ""data" . Data.List.isSubsequenceOf_closure" {
     Data.List.isSubsequenceOf_closure:
         const Data.List.isSubsequenceOf_info;
 },
 Data.List.isSubsequenceOf_entry() //  [R2, R3, R4]
         { info_tbl: [(cc218,
                       label: Data.List.isSubsequenceOf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc218: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cc219; else goto uc21G;
       cc219: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.isSubsequenceOf_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uc21G: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cc20Y() args: 0, res: 0, upd: 0;
     }
 },
 _cc20Y() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc20Y: // global
           I64[Sp - 8] = block_cc211_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc21J; else goto cc212;
       uc21J: // global
           call _cc211(R1) args: 0, res: 0, upd: 0;
       cc212: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc211() //  [R1]
         { info_tbl: [(cc211,
                       label: block_cc211_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc211: // global
           if (R1 & 7 == 1) goto cc215; else goto cc216;
       cc215: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc216: // global
           I64[Sp - 8] = block_cc21g_info;
           _sc1ZY::P64 = R1;
           _sc1ZZ::P64 = P64[R1 + 6];
           _sc200::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _sc200::P64;
           P64[Sp + 16] = _sc1ZZ::P64;
           P64[Sp + 24] = _sc1ZY::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc21K; else goto cc21i;
       uc21K: // global
           call _cc21g(R1) args: 0, res: 0, upd: 0;
       cc21i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc21g() //  [R1]
         { info_tbl: [(cc21g,
                       label: block_cc21g_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc21g: // global
           if (R1 & 7 == 1) goto cc21o; else goto cc21t;
       cc21o: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc21t: // global
           I64[Sp] = block_cc21r_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp + 24] = P64[R1 + 14];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cc21r() //  [R1]
         { info_tbl: [(cc21r,
                       label: block_cc21r_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc21r: // global
           _sc1ZV::P64 = P64[Sp + 16];
           _sc203::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cc21z; else goto cc21D;
       cc21z: // global
           P64[Sp + 16] = _sc1ZV::P64;
           P64[Sp + 24] = P64[Sp + 32];
           P64[Sp + 32] = _sc203::P64;
           Sp = Sp + 16;
           goto uc21N;
       cc21D: // global
           P64[Sp + 16] = _sc1ZV::P64;
           P64[Sp + 24] = P64[Sp + 8];
           P64[Sp + 32] = _sc203::P64;
           Sp = Sp + 16;
           goto uc21N;
       uc21N: // global
           call _cc20Y() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.191987508 UTC

[section ""cstring" . Data.List.$trModule4_bytes" {
     Data.List.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.192517053 UTC

[section ""data" . Data.List.$trModule3_closure" {
     Data.List.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.List.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.193092969 UTC

[section ""cstring" . Data.List.$trModule2_bytes" {
     Data.List.$trModule2_bytes:
         I8[] [68,97,116,97,46,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.193682421 UTC

[section ""data" . Data.List.$trModule1_closure" {
     Data.List.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.List.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.194235567 UTC

[section ""data" . Data.List.$trModule_closure" {
     Data.List.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.List.$trModule3_closure+1;
         const Data.List.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.194804286 UTC

[section ""relreadonly" . Sc20W_srt" { Sc20W_srt:
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.195530883 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:56.197493978 UTC

[section ""data" . Data.List.isSubsequenceOf_closure" {
     Data.List.isSubsequenceOf_closure:
         const Data.List.isSubsequenceOf_info;
 },
 Data.List.isSubsequenceOf_entry() //  [R2, R3, R4]
         { info_tbl: [(cc21Z,
                       label: Data.List.isSubsequenceOf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc21Z: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cc220; else goto uc22x;
       cc220: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.isSubsequenceOf_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uc22x: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cc21P() args: 0, res: 0, upd: 0;
     }
 },
 _cc21P() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc21P: // global
           I64[Sp - 8] = block_cc21S_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc22A; else goto cc21T;
       uc22A: // global
           call _cc21S(R1) args: 0, res: 0, upd: 0;
       cc21T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc21S() //  [R1]
         { info_tbl: [(cc21S,
                       label: block_cc21S_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc21S: // global
           if (R1 & 7 == 1) goto cc21W; else goto cc21X;
       cc21W: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc21X: // global
           I64[Sp - 8] = block_cc227_info;
           _sc1ZY::P64 = R1;
           _sc1ZZ::P64 = P64[R1 + 6];
           _sc200::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _sc200::P64;
           P64[Sp + 16] = _sc1ZZ::P64;
           P64[Sp + 24] = _sc1ZY::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc22B; else goto cc229;
       uc22B: // global
           call _cc227(R1) args: 0, res: 0, upd: 0;
       cc229: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc227() //  [R1]
         { info_tbl: [(cc227,
                       label: block_cc227_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc227: // global
           if (R1 & 7 == 1) goto cc22f; else goto cc22k;
       cc22f: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc22k: // global
           I64[Sp] = block_cc22i_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp + 24] = P64[R1 + 14];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cc22i() //  [R1]
         { info_tbl: [(cc22i,
                       label: block_cc22i_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc22i: // global
           _sc1ZV::P64 = P64[Sp + 16];
           _sc203::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cc22q; else goto cc22u;
       cc22q: // global
           P64[Sp + 16] = _sc1ZV::P64;
           P64[Sp + 24] = P64[Sp + 32];
           P64[Sp + 32] = _sc203::P64;
           Sp = Sp + 16;
           goto uc22E;
       cc22u: // global
           P64[Sp + 16] = _sc1ZV::P64;
           P64[Sp + 24] = P64[Sp + 8];
           P64[Sp + 32] = _sc203::P64;
           Sp = Sp + 16;
           goto uc22E;
       uc22E: // global
           call _cc21P() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.208759485 UTC

[section ""cstring" . Data.List.$trModule4_bytes" {
     Data.List.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.210777354 UTC

[section ""data" . Data.List.$trModule3_closure" {
     Data.List.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.List.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.212399219 UTC

[section ""cstring" . Data.List.$trModule2_bytes" {
     Data.List.$trModule2_bytes:
         I8[] [68,97,116,97,46,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.214194112 UTC

[section ""data" . Data.List.$trModule1_closure" {
     Data.List.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.List.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.215931809 UTC

[section ""data" . Data.List.$trModule_closure" {
     Data.List.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.List.$trModule3_closure+1;
         const Data.List.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.218036453 UTC

[section ""relreadonly" . Sc20W_srt" { Sc20W_srt:
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.252509694 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:56.254373337 UTC

[section ""data" . Data.List.isSubsequenceOf_closure" {
     Data.List.isSubsequenceOf_closure:
         const Data.List.isSubsequenceOf_info;
 },
 Data.List.isSubsequenceOf_entry() //  [R2, R3, R4]
         { info_tbl: [(cc23B,
                       label: Data.List.isSubsequenceOf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc23B: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cc23C; else goto uc249;
       cc23C: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.isSubsequenceOf_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uc249: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cc23r() args: 0, res: 0, upd: 0;
     }
 },
 _cc23r() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc23r: // global
           I64[Sp - 8] = block_cc23u_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc24c; else goto cc23v;
       uc24c: // global
           call _cc23u(R1) args: 0, res: 0, upd: 0;
       cc23v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc23u() //  [R1]
         { info_tbl: [(cc23u,
                       label: block_cc23u_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc23u: // global
           if (R1 & 7 == 1) goto cc23y; else goto cc23z;
       cc23y: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc23z: // global
           I64[Sp - 8] = block_cc23J_info;
           _sc23j::P64 = R1;
           _sc23k::P64 = P64[R1 + 6];
           _sc23l::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _sc23l::P64;
           P64[Sp + 16] = _sc23k::P64;
           P64[Sp + 24] = _sc23j::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc24d; else goto cc23L;
       uc24d: // global
           call _cc23J(R1) args: 0, res: 0, upd: 0;
       cc23L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc23J() //  [R1]
         { info_tbl: [(cc23J,
                       label: block_cc23J_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc23J: // global
           if (R1 & 7 == 1) goto cc23R; else goto cc23W;
       cc23R: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc23W: // global
           I64[Sp] = block_cc23U_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp + 24] = P64[R1 + 14];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cc23U() //  [R1]
         { info_tbl: [(cc23U,
                       label: block_cc23U_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc23U: // global
           _sc23g::P64 = P64[Sp + 16];
           _sc23o::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cc242; else goto cc246;
       cc242: // global
           P64[Sp + 16] = _sc23g::P64;
           P64[Sp + 24] = P64[Sp + 32];
           P64[Sp + 32] = _sc23o::P64;
           Sp = Sp + 16;
           goto uc24g;
       cc246: // global
           P64[Sp + 16] = _sc23g::P64;
           P64[Sp + 24] = P64[Sp + 8];
           P64[Sp + 32] = _sc23o::P64;
           Sp = Sp + 16;
           goto uc24g;
       uc24g: // global
           call _cc23r() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.26581877 UTC

[section ""cstring" . Data.List.$trModule4_bytes" {
     Data.List.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.267444605 UTC

[section ""data" . Data.List.$trModule3_closure" {
     Data.List.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.List.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.269052316 UTC

[section ""cstring" . Data.List.$trModule2_bytes" {
     Data.List.$trModule2_bytes:
         I8[] [68,97,116,97,46,76,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.270746552 UTC

[section ""data" . Data.List.$trModule1_closure" {
     Data.List.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.List.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.272513392 UTC

[section ""data" . Data.List.$trModule_closure" {
     Data.List.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.List.$trModule3_closure+1;
         const Data.List.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.274653272 UTC

[section ""relreadonly" . Sc24X_srt" { Sc24X_srt:
 }]

