
==================== Tidy Core ====================
2018-03-16 16:00:12.862416945 UTC

Result size of Tidy Core
  = {terms: 1,083, types: 1,837, coercions: 70, joins: 0/6}

-- RHS size: {terms: 14, types: 20, coercions: 0, joins: 0/0}
Data.Either.$fApplicativeEither_$cfmap
  :: forall a1 a2 b. (a2 -> b) -> Either a1 a2 -> Either a1 b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a5e0f)
                 (@ a1_a5e0j)
                 (@ b_a5e0k)
                 (ds_d5e3z [Occ=Once!] :: a1_a5e0j -> b_a5e0k)
                 (ds1_d5e3A [Occ=Once!] :: Either a_a5e0f a1_a5e0j) ->
                 case ds1_d5e3A of {
                   Left x_a5dN8 [Occ=Once] ->
                     Data.Either.Left @ a_a5e0f @ b_a5e0k x_a5dN8;
                   Right y_a5dNa [Occ=Once] ->
                     Data.Either.Right @ a_a5e0f @ b_a5e0k (ds_d5e3z y_a5dNa)
                 }}]
Data.Either.$fApplicativeEither_$cfmap
  = \ (@ a_a5e0f)
      (@ a1_a5e0j)
      (@ b_a5e0k)
      (ds_d5e3z :: a1_a5e0j -> b_a5e0k)
      (ds1_d5e3A :: Either a_a5e0f a1_a5e0j) ->
      case ds1_d5e3A of {
        Left x_a5dN8 -> Data.Either.Left @ a_a5e0f @ b_a5e0k x_a5dN8;
        Right y_a5dNa ->
          Data.Either.Right @ a_a5e0f @ b_a5e0k (ds_d5e3z y_a5dNa)
      }

-- RHS size: {terms: 13, types: 19, coercions: 0, joins: 0/0}
Data.Either.$fFunctorEither_$c<$
  :: forall a1 a2 b. a2 -> Either a1 b -> Either a1 a2
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a5e0f)
                 (@ a1_a5e0t)
                 (@ b_a5e0u)
                 (x_i1xYg [Occ=Once] :: a1_a5e0t)
                 (ds_d5e3A [Occ=Once!] :: Either a_a5e0f b_a5e0u) ->
                 case ds_d5e3A of {
                   Left x1_a5dN8 [Occ=Once] ->
                     Data.Either.Left @ a_a5e0f @ a1_a5e0t x1_a5dN8;
                   Right _ [Occ=Dead] ->
                     Data.Either.Right @ a_a5e0f @ a1_a5e0t x_i1xYg
                 }}]
Data.Either.$fFunctorEither_$c<$
  = \ (@ a_a5e0f)
      (@ a1_a5e0t)
      (@ b_a5e0u)
      (x_i1xYg :: a1_a5e0t)
      (ds_d5e3A :: Either a_a5e0f b_a5e0u) ->
      case ds_d5e3A of {
        Left x1_a5dN8 -> Data.Either.Left @ a_a5e0f @ a1_a5e0t x1_a5dN8;
        Right y_a5dNa -> Data.Either.Right @ a_a5e0f @ a1_a5e0t x_i1xYg
      }

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Either.$fFunctorEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Functor (Either a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_a5dN7) ->
       GHC.Base.C:Functor TYPE: Either a_a5dN7
                          Data.Either.$fApplicativeEither_$cfmap @ a_a5dN7
                          Data.Either.$fFunctorEither_$c<$ @ a_a5dN7]
Data.Either.$fFunctorEither
  = \ (@ a_a5e0f) ->
      GHC.Base.C:Functor
        @ (Either a_a5e0f)
        (Data.Either.$fApplicativeEither_$cfmap @ a_a5e0f)
        (Data.Either.$fFunctorEither_$c<$ @ a_a5e0f)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_r5exb :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl_r5exb = "stimes: positive multiplier expected"#

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
Data.Either.$fSemigroupEither1 :: forall a b. Either a b
[GblId, Str=x]
Data.Either.$fSemigroupEither1
  = \ (@ a_a5dZP) (@ b_a5dZQ) ->
      errorWithoutStackTrace
        @ 'LiftedRep @ (Either a_a5dZP b_a5dZQ) (unpackCString# lvl_r5exb)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Either.$fSemigroupEither2
  :: integer-simple-0.1.1.1:GHC.Integer.Type.Integer
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
Data.Either.$fSemigroupEither2 = 0

-- RHS size: {terms: 22, types: 22, coercions: 0, joins: 0/1}
Data.Either.$fSemigroupEither_$cstimes
  :: forall a b1 b2.
     GHC.Real.Integral b2 =>
     b2 -> Either a b1 -> Either a b1
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 160 0}]
Data.Either.$fSemigroupEither_$cstimes
  = \ (@ a_a5dZP)
      (@ b_a5dZQ)
      (@ b1_a5e03)
      ($dIntegral_a5e05 :: GHC.Real.Integral b1_a5e03)
      (eta_B2 :: b1_a5e03)
      (eta1_B1 :: Either a_a5dZP b_a5dZQ) ->
      let {
        $dReal_s5e80 [Dmd=<S(LS(LLLC(C(S))LLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A)>]
          :: GHC.Real.Real b1_a5e03
        [LclId]
        $dReal_s5e80
          = GHC.Real.$p1Integral @ b1_a5e03 $dIntegral_a5e05 } in
      case <=
             @ b1_a5e03
             (GHC.Real.$p2Real @ b1_a5e03 $dReal_s5e80)
             eta_B2
             (GHC.Num.fromInteger
                @ b1_a5e03
                (GHC.Real.$p1Real @ b1_a5e03 $dReal_s5e80)
                Data.Either.$fSemigroupEither2)
      of {
        False -> eta1_B1;
        True -> Data.Either.$fSemigroupEither1 @ a_a5dZP @ b_a5dZQ
      }

-- RHS size: {terms: 10, types: 15, coercions: 0, joins: 0/0}
Data.Either.$fSemigroupEither_$c<>
  :: forall a b. Either a b -> Either a b -> Either a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a5dZP)
                 (@ b_a5dZQ)
                 (ds_d5e3g [Occ=Once!] :: Either a_a5dZP b_a5dZQ)
                 (b1_a5dN3 [Occ=Once] :: Either a_a5dZP b_a5dZQ) ->
                 case ds_d5e3g of wild_X12 {
                   Left _ [Occ=Dead] -> b1_a5dN3;
                   Right _ [Occ=Dead] -> wild_X12
                 }}]
Data.Either.$fSemigroupEither_$c<>
  = \ (@ a_a5dZP)
      (@ b_a5dZQ)
      (ds_d5e3g :: Either a_a5dZP b_a5dZQ)
      (b1_a5dN3 :: Either a_a5dZP b_a5dZQ) ->
      case ds_d5e3g of wild_X12 {
        Left ds1_d5e3o -> b1_a5dN3;
        Right ipv_s5e3N -> wild_X12
      }

Rec {
-- RHS size: {terms: 17, types: 29, coercions: 0, joins: 0/0}
Data.Either.$fSemigroupEither3 [Occ=LoopBreaker]
  :: forall a b. Either a b -> [Either a b] -> Either a b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []]
Data.Either.$fSemigroupEither3
  = \ (@ a_a5dZP)
      (@ b_a5dZQ)
      (b1_i1y06 :: Either a_a5dZP b_a5dZQ)
      (ds1_i1y07 :: [Either a_a5dZP b_a5dZQ]) ->
      case ds1_i1y07 of {
        [] -> b1_i1y06;
        : c_i1y0f cs_i1y0g ->
          case b1_i1y06 of wild_X12 {
            Left ds_d5e3o ->
              Data.Either.$fSemigroupEither3
                @ a_a5dZP @ b_a5dZQ c_i1y0f cs_i1y0g;
            Right ipv_s5e3N -> wild_X12
          }
      }
end Rec }

-- RHS size: {terms: 9, types: 21, coercions: 0, joins: 0/0}
Data.Either.$fSemigroupEither_$csconcat
  :: forall a b. NonEmpty (Either a b) -> Either a b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a5dZP)
                 (@ b_a5dZQ)
                 (ds_i1y01 [Occ=Once!] :: NonEmpty (Either a_a5dZP b_a5dZQ)) ->
                 case ds_i1y01 of { :| a1_i1y08 [Occ=Once] as_i1y09 [Occ=Once] ->
                 Data.Either.$fSemigroupEither3
                   @ a_a5dZP @ b_a5dZQ a1_i1y08 as_i1y09
                 }}]
Data.Either.$fSemigroupEither_$csconcat
  = \ (@ a_a5dZP)
      (@ b_a5dZQ)
      (ds_i1y01 :: NonEmpty (Either a_a5dZP b_a5dZQ)) ->
      case ds_i1y01 of { :| a1_i1y08 as_i1y09 ->
      Data.Either.$fSemigroupEither3
        @ a_a5dZP @ b_a5dZQ a1_i1y08 as_i1y09
      }

-- RHS size: {terms: 6, types: 13, coercions: 0, joins: 0/0}
Data.Either.$fSemigroupEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. Semigroup (Either a b)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ a_a5dN1) (@ b_a5dN2) ->
       GHC.Base.C:Semigroup TYPE: Either a_a5dN1 b_a5dN2
                            Data.Either.$fSemigroupEither_$c<> @ a_a5dN1 @ b_a5dN2
                            Data.Either.$fSemigroupEither_$csconcat @ a_a5dN1 @ b_a5dN2
                            Data.Either.$fSemigroupEither_$cstimes @ a_a5dN1 @ b_a5dN2]
Data.Either.$fSemigroupEither
  = \ (@ a_a5dZP) (@ b_a5dZQ) ->
      GHC.Base.C:Semigroup
        @ (Either a_a5dZP b_a5dZQ)
        (Data.Either.$fSemigroupEither_$c<> @ a_a5dZP @ b_a5dZQ)
        (Data.Either.$fSemigroupEither_$csconcat @ a_a5dZP @ b_a5dZQ)
        (Data.Either.$fSemigroupEither_$cstimes @ a_a5dZP @ b_a5dZQ)

-- RHS size: {terms: 14, types: 25, coercions: 0, joins: 0/0}
Data.Either.$fApplicativeEither_$c<*>
  :: forall e a b. Either e (a -> b) -> Either e a -> Either e b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ e_a5dYS)
                 (@ a_a5dZ7)
                 (@ b_a5dZ8)
                 (ds_d5e38 [Occ=Once!] :: Either e_a5dYS (a_a5dZ7 -> b_a5dZ8))
                 (ds1_d5e39 [Occ=Once] :: Either e_a5dYS a_a5dZ7) ->
                 case ds_d5e38 of {
                   Left e1_a5dMY [Occ=Once] ->
                     Data.Either.Left @ e_a5dYS @ b_a5dZ8 e1_a5dMY;
                   Right f_a5dMZ [Occ=Once] ->
                     Data.Either.$fApplicativeEither_$cfmap
                       @ e_a5dYS @ a_a5dZ7 @ b_a5dZ8 f_a5dMZ ds1_d5e39
                 }}]
Data.Either.$fApplicativeEither_$c<*>
  = \ (@ e_a5dYS)
      (@ a_a5dZ7)
      (@ b_a5dZ8)
      (ds_d5e38 :: Either e_a5dYS (a_a5dZ7 -> b_a5dZ8))
      (ds1_d5e39 :: Either e_a5dYS a_a5dZ7) ->
      case ds_d5e38 of {
        Left e1_a5dMY -> Data.Either.Left @ e_a5dYS @ b_a5dZ8 e1_a5dMY;
        Right f_a5dMZ ->
          Data.Either.$fApplicativeEither_$cfmap
            @ e_a5dYS @ a_a5dZ7 @ b_a5dZ8 f_a5dMZ ds1_d5e39
      }

-- RHS size: {terms: 26, types: 44, coercions: 0, joins: 0/1}
Data.Either.$fApplicativeEither_$cliftA2
  :: forall e a b c.
     (a -> b -> c) -> Either e a -> Either e b -> Either e c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 40] 140 60}]
Data.Either.$fApplicativeEither_$cliftA2
  = \ (@ e_a5dYS)
      (@ a_a5dZk)
      (@ b_a5dZl)
      (@ c_a5dZm)
      (f1_i3nUm :: a_a5dZk -> b_a5dZl -> c_a5dZm)
      (x_i3nUn :: Either e_a5dYS a_a5dZk) ->
      let {
        ds_s5e7W :: Either e_a5dYS (b_a5dZl -> c_a5dZm)
        [LclId]
        ds_s5e7W
          = case x_i3nUn of {
              Left x1_a5dN8 ->
                Data.Either.Left @ e_a5dYS @ (b_a5dZl -> c_a5dZm) x1_a5dN8;
              Right y_a5dNa ->
                Data.Either.Right
                  @ e_a5dYS @ (b_a5dZl -> c_a5dZm) (f1_i3nUm y_a5dNa)
            } } in
      \ (ds1_d5e39 :: Either e_a5dYS b_a5dZl) ->
        case ds_s5e7W of {
          Left e1_a5dMY -> Data.Either.Left @ e_a5dYS @ c_a5dZm e1_a5dMY;
          Right f_a5dMZ ->
            Data.Either.$fApplicativeEither_$cfmap
              @ e_a5dYS @ b_a5dZl @ c_a5dZm f_a5dMZ ds1_d5e39
        }

-- RHS size: {terms: 12, types: 19, coercions: 0, joins: 0/0}
Data.Either.$fApplicativeEither_$c*>
  :: forall e a b. Either e a -> Either e b -> Either e b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ e_a5dYS)
                 (@ a_a5dZw)
                 (@ b_a5dZx)
                 (a1_i1xXL [Occ=Once!] :: Either e_a5dYS a_a5dZw)
                 (a2_i1xXM [Occ=Once] :: Either e_a5dYS b_a5dZx) ->
                 case a1_i1xXL of {
                   Left x_a5dN8 [Occ=Once] ->
                     Data.Either.Left @ e_a5dYS @ b_a5dZx x_a5dN8;
                   Right _ [Occ=Dead] -> a2_i1xXM
                 }}]
Data.Either.$fApplicativeEither_$c*>
  = \ (@ e_a5dYS)
      (@ a_a5dZw)
      (@ b_a5dZx)
      (a1_i1xXL :: Either e_a5dYS a_a5dZw)
      (a2_i1xXM :: Either e_a5dYS b_a5dZx) ->
      case a1_i1xXL of {
        Left x_a5dN8 -> Data.Either.Left @ e_a5dYS @ b_a5dZx x_a5dN8;
        Right y_a5dNa -> a2_i1xXM
      }

-- RHS size: {terms: 17, types: 24, coercions: 0, joins: 0/0}
Data.Either.$fApplicativeEither_$c<*
  :: forall e a b. Either e a -> Either e b -> Either e a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ e_a5dYS)
                 (@ a_a5dZG)
                 (@ b_a5dZH)
                 (x_i3nUn [Occ=Once!] :: Either e_a5dYS a_a5dZG)
                 (ds_d5e39 [Occ=Once!] :: Either e_a5dYS b_a5dZH) ->
                 case x_i3nUn of {
                   Left x1_a5dN8 [Occ=Once] ->
                     Data.Either.Left @ e_a5dYS @ a_a5dZG x1_a5dN8;
                   Right y_a5dNa [Occ=Once] ->
                     case ds_d5e39 of {
                       Left x1_a5dN8 [Occ=Once] ->
                         Data.Either.Left @ e_a5dYS @ a_a5dZG x1_a5dN8;
                       Right _ [Occ=Dead] -> Data.Either.Right @ e_a5dYS @ a_a5dZG y_a5dNa
                     }
                 }}]
Data.Either.$fApplicativeEither_$c<*
  = \ (@ e_a5dYS)
      (@ a_a5dZG)
      (@ b_a5dZH)
      (x_i3nUn :: Either e_a5dYS a_a5dZG)
      (ds_d5e39 :: Either e_a5dYS b_a5dZH) ->
      case x_i3nUn of wild_XZ {
        Left x1_a5dN8 -> wild_XZ;
        Right y_a5dNa ->
          case ds_d5e39 of {
            Left x1_a5dN8 -> Data.Either.Left @ e_a5dYS @ a_a5dZG x1_a5dN8;
            Right y1_X5dPg -> wild_XZ
          }
      }

-- RHS size: {terms: 8, types: 10, coercions: 0, joins: 0/0}
Data.Either.$fApplicativeEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall e. Applicative (Either e)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ e_a5dMX) ->
       GHC.Base.C:Applicative TYPE: Either e_a5dMX
                              Data.Either.$fFunctorEither @ e_a5dMX
                              Data.Either.Right @ e_a5dMX
                              Data.Either.$fApplicativeEither_$c<*> @ e_a5dMX
                              Data.Either.$fApplicativeEither_$cliftA2 @ e_a5dMX
                              Data.Either.$fApplicativeEither_$c*> @ e_a5dMX
                              Data.Either.$fApplicativeEither_$c<* @ e_a5dMX]
Data.Either.$fApplicativeEither
  = \ (@ e_a5dYS) ->
      GHC.Base.C:Applicative
        @ (Either e_a5dYS)
        (Data.Either.$fFunctorEither @ e_a5dYS)
        (Data.Either.Right @ e_a5dYS)
        (Data.Either.$fApplicativeEither_$c<*> @ e_a5dYS)
        (Data.Either.$fApplicativeEither_$cliftA2 @ e_a5dYS)
        (Data.Either.$fApplicativeEither_$c*> @ e_a5dYS)
        (Data.Either.$fApplicativeEither_$c<* @ e_a5dYS)

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
Data.Either.$fMonadEither_$c>>=
  :: forall e a b. Either e a -> (a -> Either e b) -> Either e b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ e_a5dYd)
                 (@ a_a5dYl)
                 (@ b_a5dYm)
                 (ds_d5e2Z [Occ=Once!] :: Either e_a5dYd a_a5dYl)
                 (ds1_d5e30 [Occ=Once!] :: a_a5dYl -> Either e_a5dYd b_a5dYm) ->
                 case ds_d5e2Z of {
                   Left l_a5dMU [Occ=Once] ->
                     Data.Either.Left @ e_a5dYd @ b_a5dYm l_a5dMU;
                   Right r_a5dMV [Occ=Once] -> ds1_d5e30 r_a5dMV
                 }}]
Data.Either.$fMonadEither_$c>>=
  = \ (@ e_a5dYd)
      (@ a_a5dYl)
      (@ b_a5dYm)
      (ds_d5e2Z :: Either e_a5dYd a_a5dYl)
      (ds1_d5e30 :: a_a5dYl -> Either e_a5dYd b_a5dYm) ->
      case ds_d5e2Z of {
        Left l_a5dMU -> Data.Either.Left @ e_a5dYd @ b_a5dYm l_a5dMU;
        Right r_a5dMV -> ds1_d5e30 r_a5dMV
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Either.$fMonadEither_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall e a b. Either e a -> Either e b -> Either e b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ e_a5dYd)
                 (@ a_a5dYt)
                 (@ b_a5dYu)
                 (m1_i3nU4 [Occ=Once!] :: Either e_a5dYd a_a5dYt)
                 (k_i3nU5 [Occ=Once] :: Either e_a5dYd b_a5dYu) ->
                 case m1_i3nU4 of {
                   Left l_a5dMU [Occ=Once] ->
                     Data.Either.Left @ e_a5dYd @ b_a5dYu l_a5dMU;
                   Right _ [Occ=Dead] -> k_i3nU5
                 }}]
Data.Either.$fMonadEither_$c>>
  = Data.Either.$fApplicativeEither_$c*>

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
lvl1_r5exc :: forall e a. [Char] -> Either e a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
lvl1_r5exc
  = \ (@ e_a5dYd) (@ a_a5dYL) (eta_B1 :: [Char]) ->
      errorWithoutStackTrace
        @ 'LiftedRep @ (Either e_a5dYd a_a5dYL) eta_B1

-- RHS size: {terms: 7, types: 9, coercions: 0, joins: 0/0}
Data.Either.$fMonadEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall e. Monad (Either e)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ e_a5dMT) ->
       GHC.Base.C:Monad TYPE: Either e_a5dMT
                        Data.Either.$fApplicativeEither @ e_a5dMT
                        Data.Either.$fMonadEither_$c>>= @ e_a5dMT
                        Data.Either.$fMonadEither_$c>> @ e_a5dMT
                        Data.Either.Right @ e_a5dMT
                        \ (@ a_a5dYL) ->
                          errorWithoutStackTrace @ 'LiftedRep @ (Either e_a5dMT a_a5dYL)]
Data.Either.$fMonadEither
  = \ (@ e_a5dYd) ->
      GHC.Base.C:Monad
        @ (Either e_a5dYd)
        (Data.Either.$fApplicativeEither @ e_a5dYd)
        (Data.Either.$fMonadEither_$c>>= @ e_a5dYd)
        (Data.Either.$fMonadEither_$c>> @ e_a5dYd)
        (Data.Either.Right @ e_a5dYd)
        (lvl1_r5exc @ e_a5dYd)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Either.$fShowEither5 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Either.$fShowEither5 = "Left "#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Either.$fShowEither4 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Either.$fShowEither4
  = unpackCString# Data.Either.$fShowEither5

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Either.$fReadEither4 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Either.$fReadEither4 = GHC.Types.I# 11#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Either.$fShowEither3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Either.$fShowEither3 = "Right "#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Either.$fShowEither2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Either.$fShowEither2
  = unpackCString# Data.Either.$fShowEither3

-- RHS size: {terms: 60, types: 37, coercions: 0, joins: 0/2}
Data.Either.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (Show a, Show b) => Int# -> Either a b -> ShowS
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 241] 442 240}]
Data.Either.$w$cshowsPrec
  = \ (@ a_s5emr)
      (@ b_s5ems)
      (w_s5emt :: Show a_s5emr)
      (w1_s5emu :: Show b_s5ems)
      (ww_s5emz :: Int#)
      (w2_s5emw :: Either a_s5emr b_s5ems) ->
      case w2_s5emw of {
        Left b1_a5dRA ->
          let {
            g_s5e7P [Dmd=<L,C(U)>] :: String -> String
            [LclId]
            g_s5e7P
              = showsPrec
                  @ a_s5emr w_s5emt Data.Either.$fReadEither4 b1_a5dRA } in
          case >=# ww_s5emz 11# of {
            __DEFAULT ->
              \ (x_i1Mhr :: String) ->
                ++ @ Char Data.Either.$fShowEither4 (g_s5e7P x_i1Mhr);
            1# ->
              \ (x_i1Mhy :: String) ->
                GHC.Types.:
                  @ Char
                  GHC.Show.$fShow(,)4
                  (++
                     @ Char
                     Data.Either.$fShowEither4
                     (g_s5e7P (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x_i1Mhy)))
          };
        Right b1_a5dRC ->
          let {
            g_s5e7T [Dmd=<L,C(U)>] :: String -> String
            [LclId]
            g_s5e7T
              = showsPrec
                  @ b_s5ems w1_s5emu Data.Either.$fReadEither4 b1_a5dRC } in
          case >=# ww_s5emz 11# of {
            __DEFAULT ->
              \ (x_i1Mhr :: String) ->
                ++ @ Char Data.Either.$fShowEither2 (g_s5e7T x_i1Mhr);
            1# ->
              \ (x_i1Mhy :: String) ->
                GHC.Types.:
                  @ Char
                  GHC.Show.$fShow(,)4
                  (++
                     @ Char
                     Data.Either.$fShowEither2
                     (g_s5e7T (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x_i1Mhy)))
          }
      }

-- RHS size: {terms: 14, types: 16, coercions: 0, joins: 0/0}
Data.Either.$fShowEither_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (Show a, Show b) => Int -> Either a b -> ShowS
[GblId,
 Arity=4,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s5emr)
                 (@ b_s5ems)
                 (w_s5emt [Occ=Once] :: Show a_s5emr)
                 (w1_s5emu [Occ=Once] :: Show b_s5ems)
                 (w2_s5emv [Occ=Once!] :: Int)
                 (w3_s5emw [Occ=Once] :: Either a_s5emr b_s5ems) ->
                 case w2_s5emv of { I# ww1_s5emz [Occ=Once] ->
                 Data.Either.$w$cshowsPrec
                   @ a_s5emr @ b_s5ems w_s5emt w1_s5emu ww1_s5emz w3_s5emw
                 }}]
Data.Either.$fShowEither_$cshowsPrec
  = \ (@ a_s5emr)
      (@ b_s5ems)
      (w_s5emt :: Show a_s5emr)
      (w1_s5emu :: Show b_s5ems)
      (w2_s5emv :: Int)
      (w3_s5emw :: Either a_s5emr b_s5ems) ->
      case w2_s5emv of { I# ww1_s5emz ->
      Data.Either.$w$cshowsPrec
        @ a_s5emr @ b_s5ems w_s5emt w1_s5emu ww1_s5emz w3_s5emw
      }

-- RHS size: {terms: 23, types: 22, coercions: 0, joins: 0/0}
Data.Either.$fShowEither_$cshow
  :: forall a b. (Show a, Show b) => Either a b -> String
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 110] 180 0}]
Data.Either.$fShowEither_$cshow
  = \ (@ a_a5dXF)
      (@ b_a5dXG)
      ($dShow_a5dXH :: Show a_a5dXF)
      ($dShow1_a5dXI :: Show b_a5dXG)
      (x_i1Jj2 :: Either a_a5dXF b_a5dXG) ->
      case x_i1Jj2 of {
        Left b1_a5dRA ->
          ++
            @ Char
            Data.Either.$fShowEither4
            (showsPrec
               @ a_a5dXF
               $dShow_a5dXH
               Data.Either.$fReadEither4
               b1_a5dRA
               (GHC.Types.[] @ Char));
        Right b1_a5dRC ->
          ++
            @ Char
            Data.Either.$fShowEither2
            (showsPrec
               @ b_a5dXG
               $dShow1_a5dXI
               Data.Either.$fReadEither4
               b1_a5dRC
               (GHC.Types.[] @ Char))
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Either.$fShowEither1 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Either.$fShowEither1 = GHC.Types.I# 0#

-- RHS size: {terms: 15, types: 21, coercions: 0, joins: 0/0}
Data.Either.$fShowEither_$cshowList
  :: forall a b. (Show a, Show b) => [Either a b] -> ShowS
[GblId,
 Arity=4,
 Str=<L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a5dXF)
                 (@ b_a5dXG)
                 ($dShow_a5dXH [Occ=Once] :: Show a_a5dXF)
                 ($dShow1_a5dXI [Occ=Once] :: Show b_a5dXG)
                 (ls_i1Mix [Occ=Once] :: [Either a_a5dXF b_a5dXG])
                 (s_i1Miy [Occ=Once] :: String) ->
                 showList__
                   @ (Either a_a5dXF b_a5dXG)
                   (Data.Either.$fShowEither_$cshowsPrec
                      @ a_a5dXF
                      @ b_a5dXG
                      $dShow_a5dXH
                      $dShow1_a5dXI
                      Data.Either.$fShowEither1)
                   ls_i1Mix
                   s_i1Miy}]
Data.Either.$fShowEither_$cshowList
  = \ (@ a_a5dXF)
      (@ b_a5dXG)
      ($dShow_a5dXH :: Show a_a5dXF)
      ($dShow1_a5dXI :: Show b_a5dXG)
      (ls_i1Mix :: [Either a_a5dXF b_a5dXG])
      (s_i1Miy :: String) ->
      showList__
        @ (Either a_a5dXF b_a5dXG)
        (\ (w_s5emw :: Either a_a5dXF b_a5dXG) ->
           Data.Either.$w$cshowsPrec
             @ a_a5dXF @ b_a5dXG $dShow_a5dXH $dShow1_a5dXI 0# w_s5emw)
        ls_i1Mix
        s_i1Miy

-- RHS size: {terms: 14, types: 17, coercions: 0, joins: 0/0}
Data.Either.$fShowEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. (Show a, Show b) => Show (Either a b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)>m,
 Unf=DFun: \ (@ a_a5dMR)
             (@ b_a5dMS)
             (v_B1 :: Show a_a5dMR)
             (v1_B2 :: Show b_a5dMS) ->
       GHC.Show.C:Show TYPE: Either a_a5dMR b_a5dMS
                       Data.Either.$fShowEither_$cshowsPrec @ a_a5dMR @ b_a5dMS v_B1 v1_B2
                       Data.Either.$fShowEither_$cshow @ a_a5dMR @ b_a5dMS v_B1 v1_B2
                       Data.Either.$fShowEither_$cshowList @ a_a5dMR @ b_a5dMS v_B1 v1_B2]
Data.Either.$fShowEither
  = \ (@ a_a5dXF)
      (@ b_a5dXG)
      ($dShow_a5dXH :: Show a_a5dXF)
      ($dShow1_a5dXI :: Show b_a5dXG) ->
      GHC.Show.C:Show
        @ (Either a_a5dXF b_a5dXG)
        (Data.Either.$fShowEither_$cshowsPrec
           @ a_a5dXF @ b_a5dXG $dShow_a5dXH $dShow1_a5dXI)
        (Data.Either.$fShowEither_$cshow
           @ a_a5dXF @ b_a5dXG $dShow_a5dXH $dShow1_a5dXI)
        (Data.Either.$fShowEither_$cshowList
           @ a_a5dXF @ b_a5dXG $dShow_a5dXH $dShow1_a5dXI)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Either.$fReadEither3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Either.$fReadEither3 = "Left"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Either.$fReadEither2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Either.$fReadEither2
  = unpackCString# Data.Either.$fReadEither3

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Either.$fReadEither_lexeme :: Text.Read.Lex.Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Either.$fReadEither_lexeme
  = Text.Read.Lex.Ident Data.Either.$fReadEither2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Either.$fReadEither6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Either.$fReadEither6 = "Right"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Either.$fReadEither5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Either.$fReadEither5
  = unpackCString# Data.Either.$fReadEither6

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Either.$fReadEither_lexeme1 :: Text.Read.Lex.Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Either.$fReadEither_lexeme1
  = Text.Read.Lex.Ident Data.Either.$fReadEither5

-- RHS size: {terms: 63, types: 70, coercions: 21, joins: 0/1}
Data.Either.$fReadEither1
  :: forall a b.
     (Read a, Read b) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b1.
        (Either a b -> Text.ParserCombinators.ReadP.P b1)
        -> Text.ParserCombinators.ReadP.P b1
[GblId,
 Arity=4,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 0] 462 0}]
Data.Either.$fReadEither1
  = \ (@ a_a5dWE)
      (@ b_a5dWF)
      ($dRead_a5dWG :: Read a_a5dWE)
      ($dRead1_a5dWH :: Read b_a5dWF)
      (eta_B2 :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b1_a3ngn)
      (eta1_B1
         :: Either a_a5dWE b_a5dWF
            -> Text.ParserCombinators.ReadP.P b1_a3ngn) ->
      GHC.Read.list3
        @ (Either a_a5dWE b_a5dWF)
        ((\ (n_a3tmw :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b2_X3ngu)
            (eta2_X9
               :: Either a_a5dWE b_a5dWF
                  -> Text.ParserCombinators.ReadP.P b2_X3ngu) ->
            case n_a3tmw of { I# x_at1e ->
            let {
              karg_s5e99 :: Text.ParserCombinators.ReadP.P b2_X3ngu
              [LclId]
              karg_s5e99
                = case <=# x_at1e 10# of {
                    __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b2_X3ngu;
                    1# ->
                      case Text.Read.Lex.$wexpect
                             Data.Either.$fReadEither_lexeme1
                             @ b2_X3ngu
                             (\ _ [Occ=Dead, OS=OneShot] ->
                                ((((readPrec @ b_a5dWF $dRead1_a5dWH)
                                   `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <b_a5dWF>_R
                                           :: (Text.ParserCombinators.ReadPrec.ReadPrec
                                                 b_a5dWF :: *)
                                              ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                   -> Text.ParserCombinators.ReadP.ReadP
                                                        b_a5dWF :: *)))
                                    Data.Either.$fReadEither4)
                                 `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <b_a5dWF>_R
                                         :: (Text.ParserCombinators.ReadP.ReadP b_a5dWF :: *)
                                            ~R# (forall b.
                                                 (b_a5dWF -> Text.ParserCombinators.ReadP.P b)
                                                 -> Text.ParserCombinators.ReadP.P b :: *)))
                                  @ b2_X3ngu
                                  (\ (a2_X3niD :: b_a5dWF) ->
                                     eta2_X9 (Data.Either.Right @ a_a5dWE @ b_a5dWF a2_X3niD)))
                      of
                      { (# ww1_s3xlt #) ->
                      Text.ParserCombinators.ReadP.Look @ b2_X3ngu ww1_s3xlt
                      }
                  } } in
            case <=# x_at1e 10# of {
              __DEFAULT ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                  @ b2_X3ngu
                  (Text.ParserCombinators.ReadP.Fail @ b2_X3ngu)
                  karg_s5e99;
              1# ->
                case Text.Read.Lex.$wexpect
                       Data.Either.$fReadEither_lexeme
                       @ b2_X3ngu
                       (\ _ [Occ=Dead, OS=OneShot] ->
                          ((((readPrec @ a_a5dWE $dRead_a5dWG)
                             `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <a_a5dWE>_R
                                     :: (Text.ParserCombinators.ReadPrec.ReadPrec a_a5dWE :: *)
                                        ~R# (Text.ParserCombinators.ReadPrec.Prec
                                             -> Text.ParserCombinators.ReadP.ReadP a_a5dWE :: *)))
                              Data.Either.$fReadEither4)
                           `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <a_a5dWE>_R
                                   :: (Text.ParserCombinators.ReadP.ReadP a_a5dWE :: *)
                                      ~R# (forall b.
                                           (a_a5dWE -> Text.ParserCombinators.ReadP.P b)
                                           -> Text.ParserCombinators.ReadP.P b :: *)))
                            @ b2_X3ngu
                            (\ (a2_X3nig :: a_a5dWE) ->
                               eta2_X9 (Data.Either.Left @ a_a5dWE @ b_a5dWF a2_X3nig)))
                of
                { (# ww1_s3xlt #) ->
                Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                  @ b2_X3ngu
                  (Text.ParserCombinators.ReadP.Look @ b2_X3ngu ww1_s3xlt)
                  karg_s5e99
                }
            }
            })
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Either
                                   a_a5dWE
                                   b_a5dWF>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Either a_a5dWE b_a5dWF>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Either a_a5dWE b_a5dWF -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (Either a_a5dWE b_a5dWF) :: *)))
        eta_B2
        @ b1_a3ngn
        eta1_B1

-- RHS size: {terms: 11, types: 20, coercions: 0, joins: 0/0}
Data.Either.$fReadEither_$creadsPrec
  :: forall a b. (Read a, Read b) => Int -> ReadS (Either a b)
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X5dY2)
                 (@ b_X5dY4)
                 ($dRead_X5dY6 [Occ=Once] :: Read a_X5dY2)
                 ($dRead1_X5dY8 [Occ=Once] :: Read b_X5dY4)
                 (n_a3tmE [Occ=Once] :: Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ (Either a_X5dY2 b_X5dY4)
                   (Data.Either.$fReadEither1
                      @ a_X5dY2
                      @ b_X5dY4
                      $dRead_X5dY6
                      $dRead1_X5dY8
                      n_a3tmE
                      @ (Either a_X5dY2 b_X5dY4)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ (Either a_X5dY2 b_X5dY4)))}]
Data.Either.$fReadEither_$creadsPrec
  = \ (@ a_X5dY2)
      (@ b_X5dY4)
      ($dRead_X5dY6 :: Read a_X5dY2)
      ($dRead1_X5dY8 :: Read b_X5dY4)
      (n_a3tmE :: Int) ->
      Text.ParserCombinators.ReadP.run
        @ (Either a_X5dY2 b_X5dY4)
        (Data.Either.$fReadEither1
           @ a_X5dY2
           @ b_X5dY4
           $dRead_X5dY6
           $dRead1_X5dY8
           n_a3tmE
           @ (Either a_X5dY2 b_X5dY4)
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ (Either a_X5dY2 b_X5dY4)))

-- RHS size: {terms: 8, types: 13, coercions: 13, joins: 0/0}
Data.Either.$fReadEither_$creadListPrec
  :: forall a b.
     (Read a, Read b) =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Either a b]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X5dY0)
                 (@ b_X5dY2)
                 ($dRead_X5dY4 [Occ=Once] :: Read a_X5dY0)
                 ($dRead1_X5dY6 [Occ=Once] :: Read b_X5dY2) ->
                 list
                   @ (Either a_X5dY0 b_X5dY2)
                   ((Data.Either.$fReadEither1
                       @ a_X5dY0 @ b_X5dY2 $dRead_X5dY4 $dRead1_X5dY6)
                    `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Either
                                              a_X5dY0
                                              b_X5dY2>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <Either a_X5dY0 b_X5dY2>_R)
                            :: (Text.ParserCombinators.ReadPrec.Prec
                                -> forall b.
                                   (Either a_X5dY0 b_X5dY2 -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)
                               ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                      (Either a_X5dY0 b_X5dY2) :: *)))}]
Data.Either.$fReadEither_$creadListPrec
  = \ (@ a_X5dY0)
      (@ b_X5dY2)
      ($dRead_X5dY4 :: Read a_X5dY0)
      ($dRead1_X5dY6 :: Read b_X5dY2) ->
      list
        @ (Either a_X5dY0 b_X5dY2)
        ((Data.Either.$fReadEither1
            @ a_X5dY0 @ b_X5dY2 $dRead_X5dY4 $dRead1_X5dY6)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Either
                                   a_X5dY0
                                   b_X5dY2>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Either a_X5dY0 b_X5dY2>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Either a_X5dY0 b_X5dY2 -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (Either a_X5dY0 b_X5dY2) :: *)))

-- RHS size: {terms: 11, types: 25, coercions: 23, joins: 0/0}
Data.Either.$fReadEither_$creadList
  :: forall a b. (Read a, Read b) => ReadS [Either a b]
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X5dY1)
                 (@ b_X5dY3)
                 ($dRead_X5dY5 [Occ=Once] :: Read a_X5dY1)
                 ($dRead1_X5dY7 [Occ=Once] :: Read b_X5dY3) ->
                 Text.ParserCombinators.ReadP.run
                   @ [Either a_X5dY1 b_X5dY3]
                   (((((list
                          @ (Either a_X5dY1 b_X5dY3)
                          ((Data.Either.$fReadEither1
                              @ a_X5dY1 @ b_X5dY3 $dRead_X5dY5 $dRead1_X5dY7)
                           `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                  <Either
                                                     a_X5dY1
                                                     b_X5dY3>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                             <Either
                                                                                a_X5dY1 b_X5dY3>_R)
                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                       -> forall b.
                                          (Either a_X5dY1 b_X5dY3
                                           -> Text.ParserCombinators.ReadP.P b)
                                          -> Text.ParserCombinators.ReadP.P b :: *)
                                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                             (Either a_X5dY1 b_X5dY3) :: *))))
                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                   <[Either a_X5dY1 b_X5dY3]>_R
                               :: (Text.ParserCombinators.ReadPrec.ReadPrec
                                     [Either a_X5dY1 b_X5dY3] :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                       -> Text.ParserCombinators.ReadP.ReadP
                                            [Either a_X5dY1 b_X5dY3] :: *)))
                        GHC.Read.$fRead()7)
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                                 <[Either a_X5dY1 b_X5dY3]>_R
                             :: (Text.ParserCombinators.ReadP.ReadP
                                   [Either a_X5dY1 b_X5dY3] :: *)
                                ~R# (forall b.
                                     ([Either a_X5dY1 b_X5dY3] -> Text.ParserCombinators.ReadP.P b)
                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                      @ [Either a_X5dY1 b_X5dY3]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [Either a_X5dY1 b_X5dY3]))}]
Data.Either.$fReadEither_$creadList
  = \ (@ a_X5dY1)
      (@ b_X5dY3)
      ($dRead_X5dY5 :: Read a_X5dY1)
      ($dRead1_X5dY7 :: Read b_X5dY3) ->
      Text.ParserCombinators.ReadP.run
        @ [Either a_X5dY1 b_X5dY3]
        (((((list
               @ (Either a_X5dY1 b_X5dY3)
               ((Data.Either.$fReadEither1
                   @ a_X5dY1 @ b_X5dY3 $dRead_X5dY5 $dRead1_X5dY7)
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Either
                                          a_X5dY1
                                          b_X5dY3>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <Either a_X5dY1 b_X5dY3>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               (Either a_X5dY1 b_X5dY3 -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                  (Either a_X5dY1 b_X5dY3) :: *))))
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[Either a_X5dY1 b_X5dY3]>_R
                    :: (Text.ParserCombinators.ReadPrec.ReadPrec
                          [Either a_X5dY1 b_X5dY3] :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.Prec
                            -> Text.ParserCombinators.ReadP.ReadP
                                 [Either a_X5dY1 b_X5dY3] :: *)))
             GHC.Read.$fRead()7)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                      <[Either a_X5dY1 b_X5dY3]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP
                        [Either a_X5dY1 b_X5dY3] :: *)
                     ~R# (forall b.
                          ([Either a_X5dY1 b_X5dY3] -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [Either a_X5dY1 b_X5dY3]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ [Either a_X5dY1 b_X5dY3]))

-- RHS size: {terms: 17, types: 19, coercions: 13, joins: 0/0}
Data.Either.$fReadEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. (Read a, Read b) => Read (Either a b)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U(A,A,C(C1(U)),A)>m,
 Unf=DFun: \ (@ a_a5dMR)
             (@ b_a5dMS)
             (v_B1 :: Read a_a5dMR)
             (v1_B2 :: Read b_a5dMS) ->
       GHC.Read.C:Read TYPE: Either a_a5dMR b_a5dMS
                       Data.Either.$fReadEither_$creadsPrec @ a_a5dMR @ b_a5dMS v_B1 v1_B2
                       Data.Either.$fReadEither_$creadList @ a_a5dMR @ b_a5dMS v_B1 v1_B2
                       (Data.Either.$fReadEither1 @ a_a5dMR @ b_a5dMS v_B1 v1_B2)
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Either
                                                 a_a5dMR
                                                 b_a5dMS>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                         <Either a_a5dMR b_a5dMS>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Either a_a5dMR b_a5dMS -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                         (Either a_a5dMR b_a5dMS) :: *))
                       Data.Either.$fReadEither_$creadListPrec
                         @ a_a5dMR @ b_a5dMS v_B1 v1_B2]
Data.Either.$fReadEither
  = \ (@ a_X5dXZ)
      (@ b_X5dY1)
      ($dRead_X5dY3 :: Read a_X5dXZ)
      ($dRead1_X5dY5 :: Read b_X5dY1) ->
      GHC.Read.C:Read
        @ (Either a_X5dXZ b_X5dY1)
        (Data.Either.$fReadEither_$creadsPrec
           @ a_X5dXZ @ b_X5dY1 $dRead_X5dY3 $dRead1_X5dY5)
        (Data.Either.$fReadEither_$creadList
           @ a_X5dXZ @ b_X5dY1 $dRead_X5dY3 $dRead1_X5dY5)
        ((Data.Either.$fReadEither1
            @ a_X5dXZ @ b_X5dY1 $dRead_X5dY3 $dRead1_X5dY5)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Either
                                   a_X5dXZ
                                   b_X5dY1>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Either a_X5dXZ b_X5dY1>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Either a_X5dXZ b_X5dY1 -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (Either a_X5dXZ b_X5dY1) :: *)))
        (Data.Either.$fReadEither_$creadListPrec
           @ a_X5dXZ @ b_X5dY1 $dRead_X5dY3 $dRead1_X5dY5)

-- RHS size: {terms: 28, types: 31, coercions: 0, joins: 0/0}
Data.Either.$fOrdEither_$c<
  :: forall a b. (Ord a, Ord b) => Either a b -> Either a b -> Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 90 60] 140 20}]
Data.Either.$fOrdEither_$c<
  = \ (@ a_a5dVA)
      (@ b_a5dVB)
      ($dOrd_a5dVC :: Ord a_a5dVA)
      ($dOrd1_a5dVD :: Ord b_a5dVB)
      (a1_a5dRl :: Either a_a5dVA b_a5dVB)
      (b1_a5dRm :: Either a_a5dVA b_a5dVB) ->
      case a1_a5dRl of {
        Left a2_a5dRn ->
          case b1_a5dRm of {
            Left b2_a5dRo -> < @ a_a5dVA $dOrd_a5dVC a2_a5dRn b2_a5dRo;
            Right ipv_s5e4G -> GHC.Types.True
          };
        Right a2_a5dRp ->
          case b1_a5dRm of {
            Left ipv_s5e4J -> GHC.Types.False;
            Right b2_a5dRq -> < @ b_a5dVB $dOrd1_a5dVD a2_a5dRp b2_a5dRq
          }
      }

-- RHS size: {terms: 28, types: 31, coercions: 0, joins: 0/0}
Data.Either.$fOrdEither_$ccompare
  :: forall a b.
     (Ord a, Ord b) =>
     Either a b -> Either a b -> Ordering
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 90 60] 140 20}]
Data.Either.$fOrdEither_$ccompare
  = \ (@ a_a5dVA)
      (@ b_a5dVB)
      ($dOrd_a5dVC :: Ord a_a5dVA)
      ($dOrd1_a5dVD :: Ord b_a5dVB)
      (a1_a5dRf :: Either a_a5dVA b_a5dVB)
      (b1_a5dRg :: Either a_a5dVA b_a5dVB) ->
      case a1_a5dRf of {
        Left a2_a5dRh ->
          case b1_a5dRg of {
            Left b2_a5dRi -> compare @ a_a5dVA $dOrd_a5dVC a2_a5dRh b2_a5dRi;
            Right ipv_s5e4N -> GHC.Types.LT
          };
        Right a2_a5dRj ->
          case b1_a5dRg of {
            Left ipv_s5e4Q -> GHC.Types.GT;
            Right b2_a5dRk -> compare @ b_a5dVB $dOrd1_a5dVD a2_a5dRj b2_a5dRk
          }
      }

-- RHS size: {terms: 28, types: 31, coercions: 0, joins: 0/0}
Data.Either.$fEqEither_$c==
  :: forall a b. (Eq a, Eq b) => Either a b -> Either a b -> Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 90 60] 140 20}]
Data.Either.$fEqEither_$c==
  = \ (@ a_a5dVh)
      (@ b_a5dVi)
      ($dEq_a5dVj :: Eq a_a5dVh)
      ($dEq1_a5dVk :: Eq b_a5dVi)
      (ds_d5e2A :: Either a_a5dVh b_a5dVi)
      (ds1_d5e2B :: Either a_a5dVh b_a5dVi) ->
      case ds_d5e2A of {
        Left a1_a5dRb ->
          case ds1_d5e2B of {
            Left b1_a5dRc -> == @ a_a5dVh $dEq_a5dVj a1_a5dRb b1_a5dRc;
            Right ipv_s5e4U -> GHC.Types.False
          };
        Right a1_a5dRd ->
          case ds1_d5e2B of {
            Left ipv_s5e4X -> GHC.Types.False;
            Right b1_a5dRe -> == @ b_a5dVi $dEq1_a5dVk a1_a5dRd b1_a5dRe
          }
      }

-- RHS size: {terms: 38, types: 33, coercions: 0, joins: 0/0}
Data.Either.$fEqEither_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a b. (Eq a, Eq b) => Either a b -> Either a b -> Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a5dVh)
                 (@ b_a5dVi)
                 ($dEq_a5dVj [Occ=Once] :: Eq a_a5dVh)
                 ($dEq1_a5dVk [Occ=Once] :: Eq b_a5dVi)
                 (x_a22b [Occ=Once!] :: Either a_a5dVh b_a5dVi)
                 (y_a22c [Occ=Once*!] :: Either a_a5dVh b_a5dVi) ->
                 case x_a22b of {
                   Left a1_a5dRb [Occ=Once] ->
                     case y_a22c of {
                       Left b1_a5dRc [Occ=Once] ->
                         case == @ a_a5dVh $dEq_a5dVj a1_a5dRb b1_a5dRc of {
                           False -> GHC.Types.True;
                           True -> GHC.Types.False
                         };
                       Right _ [Occ=Dead] -> GHC.Types.True
                     };
                   Right a1_a5dRd [Occ=Once] ->
                     case y_a22c of {
                       Left _ [Occ=Dead] -> GHC.Types.True;
                       Right b1_a5dRe [Occ=Once] ->
                         case == @ b_a5dVi $dEq1_a5dVk a1_a5dRd b1_a5dRe of {
                           False -> GHC.Types.True;
                           True -> GHC.Types.False
                         }
                     }
                 }}]
Data.Either.$fEqEither_$c/=
  = \ (@ a_a5dVh)
      (@ b_a5dVi)
      ($dEq_a5dVj :: Eq a_a5dVh)
      ($dEq1_a5dVk :: Eq b_a5dVi)
      (eta_B2 :: Either a_a5dVh b_a5dVi)
      (eta1_B1 :: Either a_a5dVh b_a5dVi) ->
      case eta_B2 of {
        Left a1_a5dRb ->
          case eta1_B1 of {
            Left b1_a5dRc ->
              case == @ a_a5dVh $dEq_a5dVj a1_a5dRb b1_a5dRc of {
                False -> GHC.Types.True;
                True -> GHC.Types.False
              };
            Right ipv_s5e4U -> GHC.Types.True
          };
        Right a1_a5dRd ->
          case eta1_B1 of {
            Left ipv_s5e4X -> GHC.Types.True;
            Right b1_a5dRe ->
              case == @ b_a5dVi $dEq1_a5dVk a1_a5dRd b1_a5dRe of {
                False -> GHC.Types.True;
                True -> GHC.Types.False
              }
          }
      }

-- RHS size: {terms: 11, types: 15, coercions: 0, joins: 0/0}
Data.Either.$fEqEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. (Eq a, Eq b) => Eq (Either a b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
 Unf=DFun: \ (@ a_a5dMR)
             (@ b_a5dMS)
             (v_B1 :: Eq a_a5dMR)
             (v1_B2 :: Eq b_a5dMS) ->
       GHC.Classes.C:Eq TYPE: Either a_a5dMR b_a5dMS
                        Data.Either.$fEqEither_$c== @ a_a5dMR @ b_a5dMS v_B1 v1_B2
                        Data.Either.$fEqEither_$c/= @ a_a5dMR @ b_a5dMS v_B1 v1_B2]
Data.Either.$fEqEither
  = \ (@ a_a5dVh)
      (@ b_a5dVi)
      ($dEq_a5dVj :: Eq a_a5dVh)
      ($dEq1_a5dVk :: Eq b_a5dVi) ->
      GHC.Classes.C:Eq
        @ (Either a_a5dVh b_a5dVi)
        (Data.Either.$fEqEither_$c==
           @ a_a5dVh @ b_a5dVi $dEq_a5dVj $dEq1_a5dVk)
        (Data.Either.$fEqEither_$c/=
           @ a_a5dVh @ b_a5dVi $dEq_a5dVj $dEq1_a5dVk)

-- RHS size: {terms: 9, types: 12, coercions: 0, joins: 0/0}
Data.Either.$fOrdEither_$cp1Ord
  :: forall a b. (Ord a, Ord b) => Eq (Either a b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)><L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a5dVA)
                 (@ b_a5dVB)
                 ($dOrd_a5dVC [Occ=Once] :: Ord a_a5dVA)
                 ($dOrd1_a5dVD [Occ=Once] :: Ord b_a5dVB) ->
                 Data.Either.$fEqEither
                   @ a_a5dVA
                   @ b_a5dVB
                   (GHC.Classes.$p1Ord @ a_a5dVA $dOrd_a5dVC)
                   (GHC.Classes.$p1Ord @ b_a5dVB $dOrd1_a5dVD)}]
Data.Either.$fOrdEither_$cp1Ord
  = \ (@ a_a5dVA)
      (@ b_a5dVB)
      ($dOrd_a5dVC :: Ord a_a5dVA)
      ($dOrd1_a5dVD :: Ord b_a5dVB) ->
      Data.Either.$fEqEither
        @ a_a5dVA
        @ b_a5dVB
        (GHC.Classes.$p1Ord @ a_a5dVA $dOrd_a5dVC)
        (GHC.Classes.$p1Ord @ b_a5dVB $dOrd1_a5dVD)

-- RHS size: {terms: 38, types: 33, coercions: 0, joins: 0/0}
Data.Either.$fOrdEither_$c<=
  :: forall a b. (Ord a, Ord b) => Either a b -> Either a b -> Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 110] 180 60}]
Data.Either.$fOrdEither_$c<=
  = \ (@ a_a5dVA)
      (@ b_a5dVB)
      ($dOrd_a5dVC :: Ord a_a5dVA)
      ($dOrd1_a5dVD :: Ord b_a5dVB)
      (a1_a5dRr :: Either a_a5dVA b_a5dVB)
      (b1_a5dRs :: Either a_a5dVA b_a5dVB) ->
      case b1_a5dRs of {
        Left a2_a5dRn ->
          case a1_a5dRr of {
            Left b2_a5dRo ->
              case < @ a_a5dVA $dOrd_a5dVC a2_a5dRn b2_a5dRo of {
                False -> GHC.Types.True;
                True -> GHC.Types.False
              };
            Right ipv_s5e4G -> GHC.Types.False
          };
        Right a2_a5dRp ->
          case a1_a5dRr of {
            Left ipv_s5e4J -> GHC.Types.True;
            Right b2_a5dRq ->
              case < @ b_a5dVB $dOrd1_a5dVD a2_a5dRp b2_a5dRq of {
                False -> GHC.Types.True;
                True -> GHC.Types.False
              }
          }
      }

-- RHS size: {terms: 38, types: 33, coercions: 0, joins: 0/0}
Data.Either.$fOrdEither_$cmax
  :: forall a b.
     (Ord a, Ord b) =>
     Either a b -> Either a b -> Either a b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 110] 180 0}]
Data.Either.$fOrdEither_$cmax
  = \ (@ a_a5dVA)
      (@ b_a5dVB)
      ($dOrd_a5dVC :: Ord a_a5dVA)
      ($dOrd1_a5dVD :: Ord b_a5dVB)
      (x_a55d :: Either a_a5dVA b_a5dVB)
      (y_a55e :: Either a_a5dVA b_a5dVB) ->
      case y_a55e of wild_X1v {
        Left a1_a5dRn ->
          case x_a55d of wild1_Xz {
            Left b1_a5dRo ->
              case < @ a_a5dVA $dOrd_a5dVC a1_a5dRn b1_a5dRo of {
                False -> wild_X1v;
                True -> wild1_Xz
              };
            Right ipv_s5e4G -> wild1_Xz
          };
        Right a1_a5dRp ->
          case x_a55d of wild1_Xz {
            Left ipv_s5e4J -> wild_X1v;
            Right b1_a5dRq ->
              case < @ b_a5dVB $dOrd1_a5dVD a1_a5dRp b1_a5dRq of {
                False -> wild_X1v;
                True -> wild1_Xz
              }
          }
      }

-- RHS size: {terms: 38, types: 33, coercions: 0, joins: 0/0}
Data.Either.$fOrdEither_$c>=
  :: forall a b. (Ord a, Ord b) => Either a b -> Either a b -> Bool
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 110 60] 180 60}]
Data.Either.$fOrdEither_$c>=
  = \ (@ a_a5dVA)
      (@ b_a5dVB)
      ($dOrd_a5dVC :: Ord a_a5dVA)
      ($dOrd1_a5dVD :: Ord b_a5dVB)
      (a1_a5dRv :: Either a_a5dVA b_a5dVB)
      (b1_a5dRw :: Either a_a5dVA b_a5dVB) ->
      case a1_a5dRv of {
        Left a2_a5dRn ->
          case b1_a5dRw of {
            Left b2_a5dRo ->
              case < @ a_a5dVA $dOrd_a5dVC a2_a5dRn b2_a5dRo of {
                False -> GHC.Types.True;
                True -> GHC.Types.False
              };
            Right ipv_s5e4G -> GHC.Types.False
          };
        Right a2_a5dRp ->
          case b1_a5dRw of {
            Left ipv_s5e4J -> GHC.Types.True;
            Right b2_a5dRq ->
              case < @ b_a5dVB $dOrd1_a5dVD a2_a5dRp b2_a5dRq of {
                False -> GHC.Types.True;
                True -> GHC.Types.False
              }
          }
      }

-- RHS size: {terms: 38, types: 33, coercions: 0, joins: 0/0}
Data.Either.$fOrdEither_$cmin
  :: forall a b.
     (Ord a, Ord b) =>
     Either a b -> Either a b -> Either a b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 60 110] 180 0}]
Data.Either.$fOrdEither_$cmin
  = \ (@ a_a5dVA)
      (@ b_a5dVB)
      ($dOrd_a5dVC :: Ord a_a5dVA)
      ($dOrd1_a5dVD :: Ord b_a5dVB)
      (x_a55m :: Either a_a5dVA b_a5dVB)
      (y_a55n :: Either a_a5dVA b_a5dVB) ->
      case y_a55n of wild_X1v {
        Left a1_a5dRn ->
          case x_a55m of wild1_Xz {
            Left b1_a5dRo ->
              case < @ a_a5dVA $dOrd_a5dVC a1_a5dRn b1_a5dRo of {
                False -> wild1_Xz;
                True -> wild_X1v
              };
            Right ipv_s5e4G -> wild_X1v
          };
        Right a1_a5dRp ->
          case x_a55m of wild1_Xz {
            Left ipv_s5e4J -> wild1_Xz;
            Right b1_a5dRq ->
              case < @ b_a5dVB $dOrd1_a5dVD a1_a5dRp b1_a5dRq of {
                False -> wild1_Xz;
                True -> wild_X1v
              }
          }
      }

-- RHS size: {terms: 33, types: 33, coercions: 0, joins: 0/0}
Data.Either.$fOrdEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. (Ord a, Ord b) => Ord (Either a b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m,
 Unf=DFun: \ (@ a_a5dMR)
             (@ b_a5dMS)
             (v_B1 :: Ord a_a5dMR)
             (v1_B2 :: Ord b_a5dMS) ->
       GHC.Classes.C:Ord TYPE: Either a_a5dMR b_a5dMS
                         Data.Either.$fOrdEither_$cp1Ord @ a_a5dMR @ b_a5dMS v_B1 v1_B2
                         Data.Either.$fOrdEither_$ccompare @ a_a5dMR @ b_a5dMS v_B1 v1_B2
                         Data.Either.$fOrdEither_$c< @ a_a5dMR @ b_a5dMS v_B1 v1_B2
                         Data.Either.$fOrdEither_$c<= @ a_a5dMR @ b_a5dMS v_B1 v1_B2
                         \ (a1_a5dRt [Occ=Once] :: Either a_a5dMR b_a5dMS)
                           (b1_a5dRu [Occ=Once] :: Either a_a5dMR b_a5dMS) ->
                           Data.Either.$fOrdEither_$c<
                             @ a_a5dMR @ b_a5dMS v_B1 v1_B2 b1_a5dRu a1_a5dRt
                         Data.Either.$fOrdEither_$c>= @ a_a5dMR @ b_a5dMS v_B1 v1_B2
                         Data.Either.$fOrdEither_$cmax @ a_a5dMR @ b_a5dMS v_B1 v1_B2
                         Data.Either.$fOrdEither_$cmin @ a_a5dMR @ b_a5dMS v_B1 v1_B2]
Data.Either.$fOrdEither
  = \ (@ a_a5dVA)
      (@ b_a5dVB)
      ($dOrd_a5dVC :: Ord a_a5dVA)
      ($dOrd1_a5dVD :: Ord b_a5dVB) ->
      GHC.Classes.C:Ord
        @ (Either a_a5dVA b_a5dVB)
        (Data.Either.$fOrdEither_$cp1Ord
           @ a_a5dVA @ b_a5dVB $dOrd_a5dVC $dOrd1_a5dVD)
        (Data.Either.$fOrdEither_$ccompare
           @ a_a5dVA @ b_a5dVB $dOrd_a5dVC $dOrd1_a5dVD)
        (Data.Either.$fOrdEither_$c<
           @ a_a5dVA @ b_a5dVB $dOrd_a5dVC $dOrd1_a5dVD)
        (Data.Either.$fOrdEither_$c<=
           @ a_a5dVA @ b_a5dVB $dOrd_a5dVC $dOrd1_a5dVD)
        (\ (a1_a5dRt :: Either a_a5dVA b_a5dVB)
           (b1_a5dRu :: Either a_a5dVA b_a5dVB) ->
           Data.Either.$fOrdEither_$c<
             @ a_a5dVA @ b_a5dVB $dOrd_a5dVC $dOrd1_a5dVD b1_a5dRu a1_a5dRt)
        (Data.Either.$fOrdEither_$c>=
           @ a_a5dVA @ b_a5dVB $dOrd_a5dVC $dOrd1_a5dVD)
        (Data.Either.$fOrdEither_$cmax
           @ a_a5dVA @ b_a5dVB $dOrd_a5dVC $dOrd1_a5dVD)
        (Data.Either.$fOrdEither_$cmin
           @ a_a5dVA @ b_a5dVB $dOrd_a5dVC $dOrd1_a5dVD)

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
either :: forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a5dU2)
                 (@ c_a5dU3)
                 (@ b_a5dU4)
                 (f_a5dNs [Occ=Once!] :: a_a5dU2 -> c_a5dU3)
                 (ds_d5e22 [Occ=Once!] :: b_a5dU4 -> c_a5dU3)
                 (ds1_d5e23 [Occ=Once!] :: Either a_a5dU2 b_a5dU4) ->
                 case ds1_d5e23 of {
                   Left x_a5dNt [Occ=Once] -> f_a5dNs x_a5dNt;
                   Right y_a5dNv [Occ=Once] -> ds_d5e22 y_a5dNv
                 }}]
either
  = \ (@ a_a5dU2)
      (@ c_a5dU3)
      (@ b_a5dU4)
      (f_a5dNs :: a_a5dU2 -> c_a5dU3)
      (ds_d5e22 :: b_a5dU4 -> c_a5dU3)
      (ds1_d5e23 :: Either a_a5dU2 b_a5dU4) ->
      case ds1_d5e23 of {
        Left x_a5dNt -> f_a5dNs x_a5dNt;
        Right y_a5dNv -> ds_d5e22 y_a5dNv
      }

Rec {
-- RHS size: {terms: 44, types: 104, coercions: 0, joins: 0/1}
Data.Either.$wpartitionEithers [InlPrag=NOUSERINLINE[0],
                                Occ=LoopBreaker]
  :: forall a b. [Either a b] -> (# [a], [b] #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []]
Data.Either.$wpartitionEithers
  = \ (@ a_s5enu)
      (@ b_s5env)
      (w_s5enw :: [Either a_s5enu b_s5env]) ->
      case w_s5enw of {
        [] -> (# GHC.Types.[] @ a_s5enu, GHC.Types.[] @ b_s5env #);
        : y_i1y1h ys_i1y1i ->
          let {
            eta_B1 [Dmd=<L,U(1*U,1*U)>] :: ([a_s5enu], [b_s5env])
            [LclId]
            eta_B1
              = case Data.Either.$wpartitionEithers @ a_s5enu @ b_s5env ys_i1y1i
                of
                { (# ww1_s5enJ, ww2_s5enK #) ->
                (ww1_s5enJ, ww2_s5enK)
                } } in
          case y_i1y1h of {
            Left x_a5dNt ->
              (# GHC.Types.:
                   @ a_s5enu
                   x_a5dNt
                   (case eta_B1 of { (l_a5dND, r_a5dNE) -> l_a5dND }),
                 case eta_B1 of { (l_a5dND, r_a5dNE) -> r_a5dNE } #);
            Right y1_a5dNv ->
              (# case eta_B1 of { (l_a5dNG, r_a5dNH) -> l_a5dNG },
                 GHC.Types.:
                   @ b_s5env
                   y1_a5dNv
                   (case eta_B1 of { (l_a5dNG, r_a5dNH) -> r_a5dNH }) #)
          }
      }
end Rec }

-- RHS size: {terms: 10, types: 25, coercions: 0, joins: 0/0}
partitionEithers [InlPrag=NOUSERINLINE[0]]
  :: forall a b. [Either a b] -> ([a], [b])
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s5enu)
                 (@ b_s5env)
                 (w_s5enw [Occ=Once] :: [Either a_s5enu b_s5env]) ->
                 case Data.Either.$wpartitionEithers @ a_s5enu @ b_s5env w_s5enw of
                 { (# ww1_s5enJ [Occ=Once], ww2_s5enK [Occ=Once] #) ->
                 (ww1_s5enJ, ww2_s5enK)
                 }}]
partitionEithers
  = \ (@ a_s5enu)
      (@ b_s5env)
      (w_s5enw :: [Either a_s5enu b_s5env]) ->
      case Data.Either.$wpartitionEithers @ a_s5enu @ b_s5env w_s5enw of
      { (# ww1_s5enJ, ww2_s5enK #) ->
      (ww1_s5enJ, ww2_s5enK)
      }

Rec {
-- RHS size: {terms: 18, types: 30, coercions: 0, joins: 0/0}
poly_go_r5exd :: forall a b. [Either a b] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []]
poly_go_r5exd
  = \ (@ a_a5dTY)
      (@ b_a5dTZ)
      (ds_i1y1c :: [Either a_a5dTY b_a5dTZ]) ->
      case ds_i1y1c of {
        [] -> GHC.Types.[] @ a_a5dTY;
        : y_i1y1h ys_i1y1i ->
          case y_i1y1h of {
            Left a1_a5dNx ->
              GHC.Types.:
                @ a_a5dTY a1_a5dNx (poly_go_r5exd @ a_a5dTY @ b_a5dTZ ys_i1y1i);
            Right ipv_s5e5i -> poly_go_r5exd @ a_a5dTY @ b_a5dTZ ys_i1y1i
          }
      }
end Rec }

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
lefts [InlPrag=INLINABLE] :: forall a b. [Either a b] -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 130 40
         Tmpl= \ (@ a_a5dTY)
                 (@ b_a5dTZ)
                 (x_a5dNw [Occ=Once] :: [Either a_a5dTY b_a5dTZ]) ->
                 build
                   @ a_a5dTY
                   (\ (@ a1_d5e1P)
                      (c_d5e1Q [Occ=OnceL!, OS=OneShot]
                         :: a_a5dTY -> a1_d5e1P -> a1_d5e1P)
                      (n_d5e1R [Occ=Once, OS=OneShot] :: a1_d5e1P) ->
                      foldr
                        @ (Either a_a5dTY b_a5dTZ)
                        @ a1_d5e1P
                        (\ (ds_d5e1T [Occ=Once!] :: Either a_a5dTY b_a5dTZ)
                           (ds1_d5e1S [Occ=Once*, OS=OneShot] :: a1_d5e1P) ->
                           case ds_d5e1T of {
                             Left a2_a5dNx [Occ=Once] -> c_d5e1Q a2_a5dNx ds1_d5e1S;
                             Right _ [Occ=Dead] -> ds1_d5e1S
                           })
                        n_d5e1R
                        x_a5dNw)}]
lefts
  = \ (@ a_a5dTY)
      (@ b_a5dTZ)
      (x_a5dNw :: [Either a_a5dTY b_a5dTZ]) ->
      poly_go_r5exd @ a_a5dTY @ b_a5dTZ x_a5dNw

Rec {
-- RHS size: {terms: 18, types: 30, coercions: 0, joins: 0/0}
poly_go1_r5exe :: forall a b. [Either a b] -> [b]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []]
poly_go1_r5exe
  = \ (@ a_a5dTU)
      (@ b_a5dTV)
      (ds_i1y1c :: [Either a_a5dTU b_a5dTV]) ->
      case ds_i1y1c of {
        [] -> GHC.Types.[] @ b_a5dTV;
        : y_i1y1h ys_i1y1i ->
          case y_i1y1h of {
            Left ipv_s5e5o -> poly_go1_r5exe @ a_a5dTU @ b_a5dTV ys_i1y1i;
            Right a1_a5dNz ->
              GHC.Types.:
                @ b_a5dTV a1_a5dNz (poly_go1_r5exe @ a_a5dTU @ b_a5dTV ys_i1y1i)
          }
      }
end Rec }

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
rights [InlPrag=INLINABLE] :: forall a b. [Either a b] -> [b]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 130 40
         Tmpl= \ (@ a_a5dTU)
                 (@ b_a5dTV)
                 (x_a5dNy [Occ=Once] :: [Either a_a5dTU b_a5dTV]) ->
                 build
                   @ b_a5dTV
                   (\ (@ a1_d5e1B)
                      (c_d5e1C [Occ=OnceL!, OS=OneShot]
                         :: b_a5dTV -> a1_d5e1B -> a1_d5e1B)
                      (n_d5e1D [Occ=Once, OS=OneShot] :: a1_d5e1B) ->
                      foldr
                        @ (Either a_a5dTU b_a5dTV)
                        @ a1_d5e1B
                        (\ (ds_d5e1F [Occ=Once!] :: Either a_a5dTU b_a5dTV)
                           (ds1_d5e1E [Occ=Once*, OS=OneShot] :: a1_d5e1B) ->
                           case ds_d5e1F of {
                             Left _ [Occ=Dead] -> ds1_d5e1E;
                             Right a2_a5dNz [Occ=Once] -> c_d5e1C a2_a5dNz ds1_d5e1E
                           })
                        n_d5e1D
                        x_a5dNy)}]
rights
  = \ (@ a_a5dTU)
      (@ b_a5dTV)
      (x_a5dNy :: [Either a_a5dTU b_a5dTV]) ->
      poly_go1_r5exe @ a_a5dTU @ b_a5dTV x_a5dNy

-- RHS size: {terms: 9, types: 12, coercions: 0, joins: 0/0}
isLeft :: forall a b. Either a b -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a5dTR)
                 (@ b_a5dTS)
                 (ds_d5e1q [Occ=Once!] :: Either a_a5dTR b_a5dTS) ->
                 case ds_d5e1q of {
                   Left _ [Occ=Dead] -> GHC.Types.True;
                   Right _ [Occ=Dead] -> GHC.Types.False
                 }}]
isLeft
  = \ (@ a_a5dTR) (@ b_a5dTS) (ds_d5e1q :: Either a_a5dTR b_a5dTS) ->
      case ds_d5e1q of {
        Left ds1_d5e1y -> GHC.Types.True;
        Right ds1_d5e1z -> GHC.Types.False
      }

-- RHS size: {terms: 9, types: 12, coercions: 0, joins: 0/0}
isRight :: forall a b. Either a b -> Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a5dTO)
                 (@ b_a5dTP)
                 (ds_d5e1g [Occ=Once!] :: Either a_a5dTO b_a5dTP) ->
                 case ds_d5e1g of {
                   Left _ [Occ=Dead] -> GHC.Types.False;
                   Right _ [Occ=Dead] -> GHC.Types.True
                 }}]
isRight
  = \ (@ a_a5dTO) (@ b_a5dTP) (ds_d5e1g :: Either a_a5dTO b_a5dTP) ->
      case ds_d5e1g of {
        Left ds1_d5e1o -> GHC.Types.False;
        Right ds1_d5e1p -> GHC.Types.True
      }

-- RHS size: {terms: 10, types: 13, coercions: 0, joins: 0/0}
fromLeft :: forall a b. a -> Either a b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a5dTL)
                 (@ b_a5dTM)
                 (ds_d5e15 [Occ=Once] :: a_a5dTL)
                 (ds1_d5e16 [Occ=Once!] :: Either a_a5dTL b_a5dTM) ->
                 case ds1_d5e16 of {
                   Left a1_a5dNI [Occ=Once] -> a1_a5dNI;
                   Right _ [Occ=Dead] -> ds_d5e15
                 }}]
fromLeft
  = \ (@ a_a5dTL)
      (@ b_a5dTM)
      (ds_d5e15 :: a_a5dTL)
      (ds1_d5e16 :: Either a_a5dTL b_a5dTM) ->
      case ds1_d5e16 of {
        Left a1_a5dNI -> a1_a5dNI;
        Right ipv_s5e5w -> ds_d5e15
      }

-- RHS size: {terms: 10, types: 13, coercions: 0, joins: 0/0}
fromRight :: forall b a. b -> Either a b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a5dTI)
                 (@ a_a5dTJ)
                 (ds_d5e0U [Occ=Once] :: b_a5dTI)
                 (ds1_d5e0V [Occ=Once!] :: Either a_a5dTJ b_a5dTI) ->
                 case ds1_d5e0V of {
                   Left _ [Occ=Dead] -> ds_d5e0U;
                   Right b1_a5dNK [Occ=Once] -> b1_a5dNK
                 }}]
fromRight
  = \ (@ b_a5dTI)
      (@ a_a5dTJ)
      (ds_d5e0U :: b_a5dTI)
      (ds1_d5e0V :: Either a_a5dTJ b_a5dTI) ->
      case ds1_d5e0V of {
        Left ipv_s5e5z -> ds_d5e0U;
        Right b1_a5dNK -> b1_a5dNK
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Either.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Either.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Either.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Either.$trModule3 = GHC.Types.TrNameS Data.Either.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Either.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Either.$trModule2 = "Data.Either"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Either.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Either.$trModule1 = GHC.Types.TrNameS Data.Either.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Either.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Either.$trModule
  = GHC.Types.Module Data.Either.$trModule3 Data.Either.$trModule1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep_r5exf :: KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep_r5exf = GHC.Types.KindRepVar 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep1_r5exg :: KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep1_r5exg = GHC.Types.KindRepVar 0#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Either.$tcEither2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Either.$tcEither2 = "Either"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Either.$tcEither1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Either.$tcEither1 = GHC.Types.TrNameS Data.Either.$tcEither2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Either.$tcEither :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Either.$tcEither
  = GHC.Types.TyCon
      16074290893719807138##
      14958199358864670905##
      Data.Either.$trModule
      Data.Either.$tcEither1
      0#
      GHC.Types.krep$*->*->*

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep2_r5exh :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep2_r5exh
  = GHC.Types.: @ KindRep $krep_r5exf (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep3_r5exi :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep3_r5exi = GHC.Types.: @ KindRep $krep1_r5exg $krep2_r5exh

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep4_r5exj :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep4_r5exj
  = GHC.Types.KindRepTyConApp Data.Either.$tcEither $krep3_r5exi

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Either.$tc'Left1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Either.$tc'Left1
  = GHC.Types.KindRepFun $krep1_r5exg $krep4_r5exj

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Either.$tc'Left3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Either.$tc'Left3 = "'Left"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Either.$tc'Left2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Either.$tc'Left2 = GHC.Types.TrNameS Data.Either.$tc'Left3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Either.$tc'Left :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Either.$tc'Left
  = GHC.Types.TyCon
      14915236324383360020##
      11027491440201056612##
      Data.Either.$trModule
      Data.Either.$tc'Left2
      2#
      Data.Either.$tc'Left1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Either.$tc'Right1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Either.$tc'Right1
  = GHC.Types.KindRepFun $krep_r5exf $krep4_r5exj

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Either.$tc'Right3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Either.$tc'Right3 = "'Right"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Either.$tc'Right2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Either.$tc'Right2 = GHC.Types.TrNameS Data.Either.$tc'Right3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Either.$tc'Right :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Either.$tc'Right
  = GHC.Types.TyCon
      10395468319011834275##
      16371021254350888909##
      Data.Either.$trModule
      Data.Either.$tc'Right2
      2#
      Data.Either.$tc'Right1


