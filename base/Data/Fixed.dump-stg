
==================== Pre unarise: ====================
2018-03-16 16:12:18.1216395 UTC

Data.Fixed.resolution [InlPrag=INLINE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall (p :: * -> *). p a -> GHC.Integer.Type.Integer
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_sgoyX] v_sgoyX;

Data.Fixed.$fDataFixed2
  :: GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sgoyY] v_sgoyY;

Data.Fixed.$fDataFixed_$cgfoldl
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Fixed.Fixed a
     -> c (Data.Fixed.Fixed a)
[GblId,
 Arity=4,
 Str=<L,A><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sgoyZ k_sgoz0 z_sgoz1 ds_sgoz2]
        let {
          sat_sgoz3 [Occ=Once]
            :: c_agnLa (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_agnL1)
          [LclId] =
              [z_sgoz1] \u [] z_sgoz1 Data.Fixed.$fDataFixed2;
        } in  k_sgoz0 Data.Data.$fDataInteger sat_sgoz3 ds_sgoz2;

Data.Fixed.$fEnumFixed1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Fixed.$fEnumFixed_$cenumFromThenTo
  :: forall a.
     Data.Fixed.Fixed a
     -> Data.Fixed.Fixed a -> Data.Fixed.Fixed a -> [Data.Fixed.Fixed a]
[GblId, Arity=3, Str=<S,U><S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [ds_sgoz4 ds1_sgoz5 ds2_sgoz6]
        case
            GHC.Integer.Type.minusInteger ds1_sgoz5 ds_sgoz4
        of
        delta_sgoz7 [Dmd=<S,U>]
        { __DEFAULT ->
              case
                  GHC.Integer.Type.geInteger# delta_sgoz7 Data.Fixed.$fEnumFixed1
              of
              { __DEFAULT ->
                    let {
                      go_sgoz9 [Occ=LoopBreaker]
                        :: GHC.Integer.Type.Integer -> [Data.Fixed.Fixed a_agnJM]
                      [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ds2_sgoz6 delta_sgoz7 go_sgoz9] \r [x_sgoza]
                              case GHC.Integer.Type.ltInteger# x_sgoza ds2_sgoz6 of {
                                __DEFAULT ->
                                    let {
                                      sat_sgozd [Occ=Once] :: [Data.Fixed.Fixed a_agnJM]
                                      [LclId] =
                                          [delta_sgoz7 go_sgoz9 x_sgoza] \u []
                                              case
                                                  GHC.Integer.Type.plusInteger x_sgoza delta_sgoz7
                                              of
                                              sat_sgozc
                                              { __DEFAULT -> go_sgoz9 sat_sgozc;
                                              };
                                    } in  : [x_sgoza sat_sgozd];
                                1# -> [] [];
                              };
                    } in  go_sgoz9 ds_sgoz4;
                1# ->
                    let {
                      go_sgoze [Occ=LoopBreaker]
                        :: GHC.Integer.Type.Integer -> [Data.Fixed.Fixed a_agnJM]
                      [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ds2_sgoz6 delta_sgoz7 go_sgoze] \r [x_sgozf]
                              case GHC.Integer.Type.gtInteger# x_sgozf ds2_sgoz6 of {
                                __DEFAULT ->
                                    let {
                                      sat_sgozi [Occ=Once] :: [Data.Fixed.Fixed a_agnJM]
                                      [LclId] =
                                          [delta_sgoz7 go_sgoze x_sgozf] \u []
                                              case
                                                  GHC.Integer.Type.plusInteger x_sgozf delta_sgoz7
                                              of
                                              sat_sgozh
                                              { __DEFAULT -> go_sgoze sat_sgozh;
                                              };
                                    } in  : [x_sgozf sat_sgozi];
                                1# -> [] [];
                              };
                    } in  go_sgoze ds_sgoz4;
              };
        };

sat_sgozj :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_sgozk :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgozj GHC.Types.[]];

Data.Fixed.$fEnumFixed2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgozk;

Data.Fixed.$fEnumFixed_$cenumFromTo
  :: forall a.
     Data.Fixed.Fixed a -> Data.Fixed.Fixed a -> [Data.Fixed.Fixed a]
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ds_sgozl ds1_sgozm]
        let {
          go_sgozn [Occ=LoopBreaker]
            :: GHC.Integer.Type.Integer -> [Data.Fixed.Fixed a_agnJM]
          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
              sat-only [ds1_sgozm go_sgozn] \r [x_sgozo]
                  case GHC.Integer.Type.gtInteger# x_sgozo ds1_sgozm of {
                    __DEFAULT ->
                        let {
                          sat_sgozr [Occ=Once] :: [Data.Fixed.Fixed a_agnJM]
                          [LclId] =
                              [go_sgozn x_sgozo] \u []
                                  case
                                      GHC.Integer.Type.plusInteger x_sgozo Data.Fixed.$fEnumFixed2
                                  of
                                  sat_sgozq
                                  { __DEFAULT -> go_sgozn sat_sgozq;
                                  };
                        } in  : [x_sgozo sat_sgozr];
                    1# -> [] [];
                  };
        } in  go_sgozn ds_sgozl;

Data.Fixed.$fEnumFixed_$cenumFromThen
  :: forall a.
     Data.Fixed.Fixed a -> Data.Fixed.Fixed a -> [Data.Fixed.Fixed a]
[GblId, Arity=2, Str=<S,U><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgozs ds1_sgozt]
        let {
          d_sgozu [Occ=OnceL] :: GHC.Integer.Type.Integer
          [LclId] =
              [ds_sgozs ds1_sgozt] \u []
                  GHC.Integer.Type.minusInteger ds1_sgozt ds_sgozs; } in
        let {
          go_sgozv [Occ=LoopBreaker]
            :: GHC.Integer.Type.Integer -> [Data.Fixed.Fixed a_agnJM]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [d_sgozu go_sgozv] \r [x_sgozw]
                  case x_sgozw of x1_sgozx {
                    __DEFAULT ->
                        let {
                          sat_sgozz [Occ=Once] :: [Data.Fixed.Fixed a_agnJM]
                          [LclId] =
                              [d_sgozu go_sgozv x1_sgozx] \u []
                                  case GHC.Integer.Type.plusInteger x1_sgozx d_sgozu of sat_sgozy {
                                    __DEFAULT -> go_sgozv sat_sgozy;
                                  };
                        } in  : [x1_sgozx sat_sgozz];
                  };
        } in  go_sgozv ds_sgozs;

Data.Fixed.$fEnumFixed3 [Occ=LoopBreaker]
  :: forall a. GHC.Integer.Type.Integer -> [Data.Fixed.Fixed a]
[GblId, Arity=1, Str=<S,1*U>m2, Unf=OtherCon []] =
    [] \r [x_sgozA]
        case x_sgozA of x1_sgozB {
          __DEFAULT ->
              let {
                sat_sgozD [Occ=Once] :: [Data.Fixed.Fixed a_agnJM]
                [LclId] =
                    [x1_sgozB] \u []
                        case
                            GHC.Integer.Type.plusInteger x1_sgozB Data.Fixed.$fEnumFixed2
                        of
                        sat_sgozC
                        { __DEFAULT -> Data.Fixed.$fEnumFixed3 sat_sgozC;
                        };
              } in  : [x1_sgozB sat_sgozD];
        };

Data.Fixed.$fEnumFixed_$cenumFrom
  :: forall a. Data.Fixed.Fixed a -> [Data.Fixed.Fixed a]
[GblId, Arity=1, Str=<S,1*U>m2, Unf=OtherCon []] =
    [] \r [ds_sgozE] Data.Fixed.$fEnumFixed3 ds_sgozE;

Data.Fixed.$fEnumFixed_$cfromEnum
  :: forall a. Data.Fixed.Fixed a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_sgozF] GHC.Enum.$fEnumInteger_$cfromEnum ds_sgozF;

Data.Fixed.$fEnumFixed4
  :: forall a. Data.Fixed.Fixed a -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgozG] GHC.Enum.$fEnumInteger_$cpred ds_sgozG;

Data.Fixed.$fEnumFixed5
  :: forall a. Data.Fixed.Fixed a -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgozH] GHC.Enum.$fEnumInteger_$csucc ds_sgozH;

Data.Fixed.$fEnumFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Enum.Enum (Data.Fixed.Fixed a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Enum.C:Enum! [Data.Fixed.$fEnumFixed5
                                    Data.Fixed.$fEnumFixed4
                                    GHC.Enum.$fEnumInteger_$ctoEnum
                                    Data.Fixed.$fEnumFixed_$cfromEnum
                                    Data.Fixed.$fEnumFixed_$cenumFrom
                                    Data.Fixed.$fEnumFixed_$cenumFromThen
                                    Data.Fixed.$fEnumFixed_$cenumFromTo
                                    Data.Fixed.$fEnumFixed_$cenumFromThenTo];

Data.Fixed.$fHasResolutionE0_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E0 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgozI] Data.Fixed.$fEnumFixed2;

Data.Fixed.$fHasResolutionE0 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E0
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE0_$cresolution eta_B1;

sat_sgozJ :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [10#];

sat_sgozK :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgozJ GHC.Types.[]];

Data.Fixed.$fHasResolutionE4 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgozK;

Data.Fixed.$fHasResolutionE1_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E1 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgozL] Data.Fixed.$fHasResolutionE4;

Data.Fixed.$fHasResolutionE1 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E1
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE1_$cresolution eta_B1;

sat_sgozM :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [100#];

sat_sgozN :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgozM GHC.Types.[]];

Data.Fixed.$fHasResolutionE7 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgozN;

Data.Fixed.$fHasResolutionE2_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E2 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgozO] Data.Fixed.$fHasResolutionE7;

Data.Fixed.$fHasResolutionE2 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E2
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE2_$cresolution eta_B1;

sat_sgozP :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1000#];

sat_sgozQ :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgozP GHC.Types.[]];

Data.Fixed.$fHasResolutionE8 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgozQ;

Data.Fixed.$fHasResolutionE3_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E3 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgozR] Data.Fixed.$fHasResolutionE8;

Data.Fixed.$fHasResolutionE3 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E3
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE3_$cresolution eta_B1;

sat_sgozS :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1000000#];

sat_sgozT :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgozS GHC.Types.[]];

Data.Fixed.$fHasResolutionE10 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgozT;

Data.Fixed.$fHasResolutionE6_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E6 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgozU] Data.Fixed.$fHasResolutionE10;

Data.Fixed.$fHasResolutionE6 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E6
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE6_$cresolution eta_B1;

sat_sgozV :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1000000000#];

sat_sgozW :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgozV GHC.Types.[]];

Data.Fixed.$fHasResolutionE11 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgozW;

Data.Fixed.$fHasResolutionE9_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E9 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgozX] Data.Fixed.$fHasResolutionE11;

Data.Fixed.$fHasResolutionE9 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E9
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE9_$cresolution eta_B1;

sat_sgozZ :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [465#];

sat_sgoA0 :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgozZ GHC.Types.[]];

sat_sgozY :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1420103680#];

sat_sgoA1 :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgozY sat_sgoA0];

Data.Fixed.$fHasResolutionE5 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgoA1;

Data.Fixed.$fHasResolutionE12_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E12 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgoA2] Data.Fixed.$fHasResolutionE5;

Data.Fixed.$fHasResolutionE12 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E12
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE12_$cresolution eta_B1;

Data.Fixed.$fDataFixed6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Fixed.Fixed"#;

Data.Fixed.$fDataFixed5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Fixed.$fDataFixed6;

w1_rgoyk :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "MkFixed"#;

w2_rgoyl :: GHC.Base.String
[GblId] =
    [] \u [] GHC.CString.unpackCString# w1_rgoyk;

go61_rgoym
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sgoA3 _ys_sgoA4]
        case ds2_sgoA3 of {
          [] -> GHC.List.badHead;
          : ipv_sgoA6 [Occ=Once!] ipv1_sgoA7 [Occ=Once] ->
              case _ys_sgoA4 of {
                [] -> GHC.List.badHead;
                : ipv2_sgoA9 [Occ=Once] ipv3_sgoAa [Occ=Once] ->
                    case ipv_sgoA6 of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sgoAd [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sgoAd w2_rgoyl of {
                            GHC.Types.False -> go61_rgoym ipv1_sgoA7 ipv3_sgoAa;
                            GHC.Types.True -> ipv2_sgoA9;
                          };
                    };
              };
        };

conMkFixed1_rgoyn :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [conMkFixed2_rgoyo];
Data.Fixed.$fDataFixed4 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Fixed.conMkFixed GHC.Types.[]];
Data.Fixed.$fDataFixed3 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Fixed.$fDataFixed4];
Data.Fixed.tyFixed :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Fixed.$fDataFixed5
                                       Data.Fixed.$fDataFixed3];
Data.Fixed.conMkFixed [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [conMkFixed1_rgoyn
                                     w2_rgoyl
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     Data.Fixed.tyFixed];
conMkFixed2_rgoyo :: Data.Data.ConIndex
[GblId] =
    [] \u [] go61_rgoym Data.Fixed.$fDataFixed4 Data.Data.mkConstr1;

Data.Fixed.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

loc_rgoyp :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Fixed.$trModule4;

Data.Fixed.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Fixed"#;

loc1_rgoyq :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Fixed.$trModule2;

loc2_rgoyr :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "./Data/Fixed.hs"#;

loc3_rgoys :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# loc2_rgoyr;

loc4_rgoyt :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [83#];

loc5_rgoyu :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [20#];

loc6_rgoyv :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [29#];

$dIP_rgoyw :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "undefined"#;

$dIP1_rgoyx :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# $dIP_rgoyw;

$dIP2_rgoyy :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [loc_rgoyp
                                           loc1_rgoyq
                                           loc3_rgoys
                                           loc4_rgoyt
                                           loc5_rgoyu
                                           loc4_rgoyt
                                           loc6_rgoyv];

$dIP3_rgoyz :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [$dIP1_rgoyx
                                                  $dIP2_rgoyy
                                                  GHC.Stack.Types.EmptyCallStack];

Data.Fixed.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$trModule4];

Data.Fixed.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$trModule2];

Data.Fixed.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Fixed.$trModule3
                                     Data.Fixed.$trModule1];

$krep_rgoyA :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Integer.Type.$tcInteger
                                              GHC.Types.[]];

$krep1_rgoyB :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Fixed.$tcHasResolution1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*
                                         $krep1_rgoyB];

$krep2_rgoyC :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

Data.Fixed.$fDataFixed10 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Fixed"#;

Data.Fixed.$fDataFixed9 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$fDataFixed10];

Data.Fixed.$tcFixed :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12850707307297787398##
                                    5875431371990069009##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$fDataFixed9
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep3_rgoyD :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rgoyC GHC.Types.[]];

$krep4_rgoyE :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Fixed.$tcFixed
                                              $krep3_rgoyD];

Data.Fixed.$tc'MkFixed1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgoyA $krep4_rgoyE];

Data.Fixed.$tc'MkFixed3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'MkFixed"#;

Data.Fixed.$tc'MkFixed2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tc'MkFixed3];

Data.Fixed.$tc'MkFixed :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8992689233320522225##
                                    9587721628087041380##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tc'MkFixed2
                                    1#
                                    Data.Fixed.$tc'MkFixed1];

Data.Fixed.$fDataFixed8
  :: Data.Typeable.Internal.TypeRep Data.Fixed.Fixed
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                12850707307297787398##
                5875431371990069009##
                Data.Fixed.$trModule
                Data.Fixed.$fDataFixed9
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sgoAj [Occ=Once]
                   ww9_sgoAk [Occ=Once]
                   ww10_sgoAl [Occ=Once]
                   ww11_sgoAm [Occ=Once]
                   ww12_sgoAn [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sgoAj
                                              ww9_sgoAk
                                              ww10_sgoAl
                                              ww11_sgoAm
                                              ww12_sgoAn];
        };

Data.Fixed.$fDataFixed7
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     Data.Typeable.Internal.TypeRep (Data.Fixed.Fixed a)
[GblId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
    [] \r [$dTypeable_sgoAo]
        Data.Typeable.Internal.mkTrApp
            Data.Fixed.$fDataFixed8 $dTypeable_sgoAo;

Data.Fixed.$fDataFixed1
  :: forall a.
     (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Fixed.$fDataFixed2 GHC.Types.False];

Data.Fixed.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall a (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgoAp w3_sgoAq w4_sgoAr]
        let {
          lvl17_sgoAs [Occ=OnceL] :: m_sgomN (Data.Fixed.Fixed a_sgomL)
          [LclId] =
              [w_sgoAp] \u [] GHC.Base.mzero w_sgoAp;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sgoAp
          of
          $dMonad_sgoAt [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgoAP [Occ=Once]
                    :: (Data.Fixed.Fixed a_sgomL, GHC.Types.Bool)
                       -> m_sgomN (Data.Fixed.Fixed a_sgomL)
                  [LclId] =
                      [lvl17_sgoAs $dMonad_sgoAt] \r [ds_sgoAK]
                          case ds_sgoAK of {
                            (,) x'_sgoAM [Occ=Once] b_sgoAN [Occ=Once!] ->
                                case b_sgoAN of {
                                  GHC.Types.False -> lvl17_sgoAs;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgoAt x'_sgoAM;
                                };
                          }; } in
                let {
                  sat_sgoAJ [Occ=Once]
                    :: m_sgomN (Data.Fixed.Fixed a_sgomL, GHC.Types.Bool)
                  [LclId] =
                      [w_sgoAp w3_sgoAq w4_sgoAr $dMonad_sgoAt] \u []
                          let {
                            lvl18_sgoAu [Occ=OnceL] :: m_sgomN GHC.Integer.Type.Integer
                            [LclId] =
                                [w3_sgoAq w4_sgoAr] \u []
                                    w3_sgoAq Data.Data.$fDataInteger w4_sgoAr; } in
                          let {
                            sat_sgoAI [Occ=Once]
                              :: (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomL,
                                  GHC.Types.Bool)
                                 -> m_sgomN (Data.Fixed.Fixed a_sgomL, GHC.Types.Bool)
                            [LclId] =
                                [w_sgoAp w4_sgoAr $dMonad_sgoAt lvl18_sgoAu] \r [ds1_sgoAw]
                                    case ds1_sgoAw of {
                                      (,) h_sgoAy b1_sgoAz [Occ=Once] ->
                                          let {
                                            sat_sgoAH [Occ=Once]
                                              :: m_sgomN (Data.Fixed.Fixed a_sgomL, GHC.Types.Bool)
                                            [LclId] =
                                                [w4_sgoAr $dMonad_sgoAt h_sgoAy b1_sgoAz] \u []
                                                    let {
                                                      sat_sgoAF [Occ=Once]
                                                        :: Data.Fixed.Fixed a_sgomL
                                                      [LclId] =
                                                          [w4_sgoAr h_sgoAy] \u []
                                                              h_sgoAy w4_sgoAr; } in
                                                    let {
                                                      sat_sgoAG [Occ=Once]
                                                        :: (Data.Fixed.Fixed a_sgomL,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sgoAF b1_sgoAz];
                                                    } in 
                                                      GHC.Base.return $dMonad_sgoAt sat_sgoAG; } in
                                          let {
                                            sat_sgoAE [Occ=Once]
                                              :: m_sgomN (Data.Fixed.Fixed a_sgomL, GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sgoAt lvl18_sgoAu h_sgoAy] \u []
                                                    let {
                                                      sat_sgoAD [Occ=Once]
                                                        :: GHC.Integer.Type.Integer
                                                           -> m_sgomN (Data.Fixed.Fixed a_sgomL,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sgoAt h_sgoAy] \r [y'_sgoAA]
                                                              let {
                                                                sat_sgoAB [Occ=Once]
                                                                  :: Data.Fixed.Fixed a_sgomL
                                                                [LclId] =
                                                                    [h_sgoAy y'_sgoAA] \u []
                                                                        h_sgoAy y'_sgoAA; } in
                                                              let {
                                                                sat_sgoAC [Occ=Once]
                                                                  :: (Data.Fixed.Fixed a_sgomL,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sgoAB
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sgoAt sat_sgoAC;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sgoAt lvl18_sgoAu sat_sgoAD;
                                          } in  GHC.Base.mplus w_sgoAp sat_sgoAE sat_sgoAH;
                                    }; } in
                          let {
                            sat_sgoAv [Occ=Once]
                              :: m_sgomN (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomL,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sgoAt] \u []
                                    GHC.Base.return $dMonad_sgoAt Data.Fixed.$fDataFixed1;
                          } in  GHC.Base.>>= $dMonad_sgoAt sat_sgoAv sat_sgoAI;
                } in  GHC.Base.>>= $dMonad_sgoAt sat_sgoAJ sat_sgoAP;
          };

Data.Fixed.$fDataFixed_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=4,
 Str=<L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgoAQ w3_sgoAR w4_sgoAS w5_sgoAT]
        Data.Fixed.$w$cgmapMp w3_sgoAR w4_sgoAS w5_sgoAT;

Data.Fixed.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=3,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgoAU w3_sgoAV w4_sgoAW]
        let {
          lvl17_sgoAX [Occ=OnceL] :: m_sgomU GHC.Integer.Type.Integer
          [LclId] =
              [w3_sgoAV w4_sgoAW] \u []
                  w3_sgoAV Data.Data.$fDataInteger w4_sgoAW; } in
        let {
          sat_sgoB3 [Occ=Once]
            :: (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomS)
               -> m_sgomU (Data.Fixed.Fixed a_sgomS)
          [LclId] =
              [w_sgoAU lvl17_sgoAX] \r [c'_sgoAZ]
                  let {
                    sat_sgoB2 [Occ=Once]
                      :: GHC.Integer.Type.Integer -> m_sgomU (Data.Fixed.Fixed a_sgomS)
                    [LclId] =
                        [w_sgoAU c'_sgoAZ] \r [x'_sgoB0]
                            let {
                              sat_sgoB1 [Occ=Once] :: Data.Fixed.Fixed a_sgomS
                              [LclId] =
                                  [c'_sgoAZ x'_sgoB0] \u [] c'_sgoAZ x'_sgoB0;
                            } in  GHC.Base.return w_sgoAU sat_sgoB1;
                  } in  GHC.Base.>>= w_sgoAU lvl17_sgoAX sat_sgoB2; } in
        let {
          sat_sgoAY [Occ=Once]
            :: m_sgomU (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomS)
          [LclId] =
              [w_sgoAU] \u [] GHC.Base.return w_sgoAU Data.Fixed.$fDataFixed2;
        } in  GHC.Base.>>= w_sgoAU sat_sgoAY sat_sgoB3;

Data.Fixed.$fDataFixed_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=4,
 Str=<L,A><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgoB4 w3_sgoB5 w4_sgoB6 w5_sgoB7]
        Data.Fixed.$w$cgmapM w3_sgoB5 w4_sgoB6 w5_sgoB7;

Data.Fixed.$fDataFixed_$cgmapQi
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Fixed.Fixed a
     -> u
[GblId,
 Arity=4,
 Str=<L,A><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sgoB8 ds_sgoB9 ds1_sgoBa x_sgoBb]
        case ds_sgoB9 of {
          GHC.Types.I# x1_sgoBd [Occ=Once!] ->
              case x1_sgoBd of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sgoBa Data.Data.$fDataInteger x_sgoBb;
              };
        };

Data.Fixed.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall a (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgoBf w3_sgoBg w4_sgoBh]
        let {
          lvl17_sgoBi [Occ=OnceL] :: m_sgon1 (Data.Fixed.Fixed a_sgomZ)
          [LclId] =
              [w_sgoBf] \u [] GHC.Base.mzero w_sgoBf;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sgoBf
          of
          $dMonad_sgoBj [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgoBI [Occ=Once]
                    :: (Data.Fixed.Fixed a_sgomZ, GHC.Types.Bool)
                       -> m_sgon1 (Data.Fixed.Fixed a_sgomZ)
                  [LclId] =
                      [lvl17_sgoBi $dMonad_sgoBj] \r [ds_sgoBD]
                          case ds_sgoBD of {
                            (,) x'_sgoBF [Occ=Once] b_sgoBG [Occ=Once!] ->
                                case b_sgoBG of {
                                  GHC.Types.False -> lvl17_sgoBi;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgoBj x'_sgoBF;
                                };
                          }; } in
                let {
                  sat_sgoBC [Occ=Once]
                    :: m_sgon1 (Data.Fixed.Fixed a_sgomZ, GHC.Types.Bool)
                  [LclId] =
                      [w_sgoBf w3_sgoBg w4_sgoBh $dMonad_sgoBj] \u []
                          let {
                            lvl18_sgoBk [Occ=OnceL] :: m_sgon1 GHC.Integer.Type.Integer
                            [LclId] =
                                [w3_sgoBg w4_sgoBh] \u []
                                    w3_sgoBg Data.Data.$fDataInteger w4_sgoBh; } in
                          let {
                            sat_sgoBB [Occ=Once]
                              :: (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomZ,
                                  GHC.Types.Bool)
                                 -> m_sgon1 (Data.Fixed.Fixed a_sgomZ, GHC.Types.Bool)
                            [LclId] =
                                [w_sgoBf w4_sgoBh $dMonad_sgoBj lvl18_sgoBk] \r [ds1_sgoBm]
                                    case ds1_sgoBm of {
                                      (,) h_sgoBo b1_sgoBp [Occ=Once!] ->
                                          case b1_sgoBp of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sgoBy [Occ=Once]
                                                    :: m_sgon1 (Data.Fixed.Fixed a_sgomZ,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [w4_sgoBh $dMonad_sgoBj h_sgoBo] \u []
                                                          let {
                                                            sat_sgoBw [Occ=Once]
                                                              :: Data.Fixed.Fixed a_sgomZ
                                                            [LclId] =
                                                                [w4_sgoBh h_sgoBo] \u []
                                                                    h_sgoBo w4_sgoBh; } in
                                                          let {
                                                            sat_sgoBx [Occ=Once]
                                                              :: (Data.Fixed.Fixed a_sgomZ,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sgoBw
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sgoBj sat_sgoBx; } in
                                                let {
                                                  sat_sgoBv [Occ=Once]
                                                    :: m_sgon1 (Data.Fixed.Fixed a_sgomZ,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sgoBj lvl18_sgoBk h_sgoBo] \u []
                                                          let {
                                                            sat_sgoBu [Occ=Once]
                                                              :: GHC.Integer.Type.Integer
                                                                 -> m_sgon1 (Data.Fixed.Fixed
                                                                               a_sgomZ,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sgoBj
                                                                 h_sgoBo] \r [y'_sgoBr]
                                                                    let {
                                                                      sat_sgoBs [Occ=Once]
                                                                        :: Data.Fixed.Fixed a_sgomZ
                                                                      [LclId] =
                                                                          [h_sgoBo y'_sgoBr] \u []
                                                                              h_sgoBo y'_sgoBr; } in
                                                                    let {
                                                                      sat_sgoBt [Occ=Once]
                                                                        :: (Data.Fixed.Fixed
                                                                              a_sgomZ,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sgoBs
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sgoBj sat_sgoBt;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sgoBj lvl18_sgoBk sat_sgoBu;
                                                } in  GHC.Base.mplus w_sgoBf sat_sgoBv sat_sgoBy;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sgoBz [Occ=Once] :: Data.Fixed.Fixed a_sgomZ
                                                  [LclId] =
                                                      [w4_sgoBh h_sgoBo] \u []
                                                          h_sgoBo w4_sgoBh; } in
                                                let {
                                                  sat_sgoBA [Occ=Once]
                                                    :: (Data.Fixed.Fixed a_sgomZ, GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sgoBz GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sgoBj sat_sgoBA;
                                          };
                                    }; } in
                          let {
                            sat_sgoBl [Occ=Once]
                              :: m_sgon1 (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomZ,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sgoBj] \u []
                                    GHC.Base.return $dMonad_sgoBj Data.Fixed.$fDataFixed1;
                          } in  GHC.Base.>>= $dMonad_sgoBj sat_sgoBl sat_sgoBB;
                } in  GHC.Base.>>= $dMonad_sgoBj sat_sgoBC sat_sgoBI;
          };

Data.Fixed.$fDataFixed_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=4,
 Str=<L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgoBJ w3_sgoBK w4_sgoBL w5_sgoBM]
        Data.Fixed.$w$cgmapMo w3_sgoBK w4_sgoBL w5_sgoBM;

lvl_rgoyF :: forall a. Data.Fixed.Fixed a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sgoBN] Data.Fixed.conMkFixed;

lvl1_rgoyG :: forall a. Data.Fixed.Fixed a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sgoBO] Data.Fixed.tyFixed;

lvl2_rgoyH
  :: forall a (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Fixed.Fixed a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sgoBP ds_sgoBQ] GHC.Base.Nothing [];

lvl3_rgoyI
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Fixed.Fixed a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sgoBR ds_sgoBS] GHC.Base.Nothing [];

lvl4_rgoyJ
  :: forall a.
     (forall b. Data.Data.Data b => b -> b)
     -> Data.Fixed.Fixed a -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<C(C(S)),1*C1(C1(U))><L,U>, Unf=OtherCon []] =
    [] \r [ds_sgoBT x0_sgoBU]
        ds_sgoBT Data.Data.$fDataInteger x0_sgoBU;

lvl5_rgoyK
  :: forall a r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Fixed.Fixed a
     -> r
[GblId,
 Arity=4,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgoBV ds1_sgoBW ds2_sgoBX eta_sgoBY]
        let {
          sat_sgoBZ [Occ=Once] :: r'_agnMw
          [LclId] =
              [ds2_sgoBX eta_sgoBY] \u []
                  ds2_sgoBX Data.Data.$fDataInteger eta_sgoBY;
        } in  ds_sgoBV ds1_sgoBW sat_sgoBZ;

lvl6_rgoyL
  :: forall a r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Fixed.Fixed a
     -> r
[GblId,
 Arity=4,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgoC0 ds1_sgoC1 ds2_sgoC2 x0_sgoC3]
        let {
          sat_sgoC4 [Occ=Once] :: r'_agnMN
          [LclId] =
              [ds2_sgoC2 x0_sgoC3] \u []
                  ds2_sgoC2 Data.Data.$fDataInteger x0_sgoC3;
        } in  ds_sgoC0 sat_sgoC4 ds1_sgoC1;

lvl7_rgoyM
  :: forall a u.
     (forall d. Data.Data.Data d => d -> u) -> Data.Fixed.Fixed a -> [u]
[GblId, Arity=2, Str=<L,1*C1(C1(U))><L,U>m2, Unf=OtherCon []] =
    [] \r [ds_sgoC5 x0_sgoC6]
        let {
          sat_sgoC7 [Occ=Once] :: u_agnN3
          [LclId] =
              [ds_sgoC5 x0_sgoC6] \u []
                  ds_sgoC5 Data.Data.$fDataInteger x0_sgoC6;
        } in  : [sat_sgoC7 GHC.Types.[]];

lvl8_rgoyN
  :: forall a (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c (Data.Fixed.Fixed a)
[GblId,
 Arity=3,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [k_sgoC8 z_sgoC9 ds_sgoCa]
        let {
          sat_sgoCb [Occ=Once]
            :: c_agnLl (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_XgnO4)
          [LclId] =
              [z_sgoC9] \u [] z_sgoC9 Data.Fixed.$fDataFixed2;
        } in  k_sgoC8 Data.Data.$fDataInteger sat_sgoCb;

Data.Fixed.$fDataFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     Data.Data.Data (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,U>] =
    [] \r [$dTypeable_sgoCc]
        let {
          sat_sgoCf [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Fixed.Fixed a_XgnO4
               -> u
          [LclId] =
              [$dTypeable_sgoCc] \r [eta_B3 eta_B2 eta_B1]
                  Data.Fixed.$fDataFixed_$cgmapQi
                      $dTypeable_sgoCc eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgoCe [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Fixed.Fixed a_XgnO4
               -> c (Data.Fixed.Fixed a_XgnO4)
          [LclId] =
              [$dTypeable_sgoCc] \r [eta_B3 eta_B2 eta_B1]
                  Data.Fixed.$fDataFixed_$cgfoldl
                      $dTypeable_sgoCc eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgoCd [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Fixed.Fixed a_XgnO4)
          [LclId] =
              [$dTypeable_sgoCc] \u [] Data.Fixed.$fDataFixed7 $dTypeable_sgoCc;
        } in 
          Data.Data.C:Data [sat_sgoCd
                            sat_sgoCe
                            lvl8_rgoyN
                            lvl_rgoyF
                            lvl1_rgoyG
                            lvl2_rgoyH
                            lvl3_rgoyI
                            lvl4_rgoyJ
                            lvl5_rgoyK
                            lvl6_rgoyL
                            lvl7_rgoyM
                            sat_sgoCf
                            Data.Fixed.$w$cgmapM
                            Data.Fixed.$w$cgmapMp
                            Data.Fixed.$w$cgmapMo];

Data.Fixed.$tcHasResolution3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "HasResolution"#;

Data.Fixed.$tcHasResolution2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcHasResolution3];

Data.Fixed.$tcHasResolution :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7410670074803796200##
                                    11622449620609036983##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcHasResolution2
                                    0#
                                    Data.Fixed.$tcHasResolution1];

Data.Fixed.$tcE5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E0"#;

Data.Fixed.$tcE4 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE5];

Data.Fixed.$tcE0 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1111589946053822622##
                                    14645449775626969178##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE4
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE8 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E1"#;

Data.Fixed.$tcE7 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE8];

Data.Fixed.$tcE1 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17242267792727872229##
                                    10571291330004494282##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE7
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE14 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E2"#;

Data.Fixed.$tcE13 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE14];

Data.Fixed.$tcE2 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [18184774527647329547##
                                    15895109557895358229##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE13
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE16 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E3"#;

Data.Fixed.$tcE15 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE16];

Data.Fixed.$tcE3 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2281297682271263739##
                                    13982938170987291273##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE15
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE18 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E6"#;

Data.Fixed.$tcE17 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE18];

Data.Fixed.$tcE6 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6430880657524859014##
                                    16351944333195325805##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE17
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE20 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E9"#;

Data.Fixed.$tcE19 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE20];

Data.Fixed.$tcE9 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8202840314884717291##
                                    5390706447224283764##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE19
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE11 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E12"#;

Data.Fixed.$tcE10 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE11];

Data.Fixed.$tcE12 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11177455628646877585##
                                    1804744900678580889##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE10
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.div'
  :: forall a b.
     (GHC.Real.Real a, GHC.Real.Integral b) =>
     a -> a -> b
[GblId,
 Arity=4,
 Str=<S(LLC(S(SS))),U(A,A,C(U(U,U)))><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dReal_sgoCg $dIntegral_sgoCh n_sgoCi d_sgoCj]
        case GHC.Real.toRational $dReal_sgoCg n_sgoCi of {
          GHC.Real.:% ww1_sgoCl [Occ=Once] ww2_sgoCm [Occ=Once] ->
              case GHC.Real.toRational $dReal_sgoCg d_sgoCj of {
                GHC.Real.:% ww4_sgoCo [Occ=Once] ww5_sgoCp [Occ=Once] ->
                    case GHC.Real.$w$s$c/ ww1_sgoCl ww2_sgoCm ww4_sgoCo ww5_sgoCp of {
                      (#,#) ww7_sgoCr [Occ=Once] ww8_sgoCs [Occ=Once] ->
                          GHC.Real.$w$s$cfloor $dIntegral_sgoCh ww7_sgoCr ww8_sgoCs;
                    };
              };
        };

Data.Fixed.$wdivMod' [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Real.Real a, GHC.Real.Integral b) =>
     a -> a -> (# b, a #)
[GblId,
 Arity=4,
 Str=<L,U(1*U(A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,1*C1(U)),A,C(U(U,U)))><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,1*C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgoCt w3_sgoCu w4_sgoCv w5_sgoCw]
        let {
          f_sgoCx :: b_sgond
          [LclId] =
              [w_sgoCt w3_sgoCu w4_sgoCv w5_sgoCw] \u []
                  Data.Fixed.div' w_sgoCt w3_sgoCu w4_sgoCv w5_sgoCw; } in
        let {
          sat_sgoCC [Occ=Once] :: a_sgonc
          [LclId] =
              [w_sgoCt w3_sgoCu w4_sgoCv w5_sgoCw f_sgoCx] \u []
                  case
                      GHC.Real.$p1Real w_sgoCt
                  of
                  $dNum_sgoCy [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,1*C1(U))>]
                  { __DEFAULT ->
                        let {
                          sat_sgoCB [Occ=Once] :: a_sgonc
                          [LclId] =
                              [w3_sgoCu w5_sgoCw f_sgoCx $dNum_sgoCy] \u []
                                  let {
                                    sat_sgoCA [Occ=Once] :: a_sgonc
                                    [LclId] =
                                        [w3_sgoCu f_sgoCx $dNum_sgoCy] \u []
                                            let {
                                              sat_sgoCz [Occ=Once] :: GHC.Integer.Type.Integer
                                              [LclId] =
                                                  [w3_sgoCu f_sgoCx] \u []
                                                      GHC.Real.toInteger w3_sgoCu f_sgoCx;
                                            } in  GHC.Num.fromInteger $dNum_sgoCy sat_sgoCz;
                                  } in  GHC.Num.* $dNum_sgoCy sat_sgoCA w5_sgoCw;
                        } in  GHC.Num.- $dNum_sgoCy w4_sgoCv sat_sgoCB;
                  };
        } in  (#,#) [f_sgoCx sat_sgoCC];

Data.Fixed.divMod' [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Real.Real a, GHC.Real.Integral b) =>
     a -> a -> (b, a)
[GblId,
 Arity=4,
 Str=<L,U(U(A,C(C1(U)),C(C1(U)),A,A,A,C(U)),A,C(U(U,U)))><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sgoCD w3_sgoCE w4_sgoCF w5_sgoCG]
        case Data.Fixed.$wdivMod' w_sgoCD w3_sgoCE w4_sgoCF w5_sgoCG of {
          (#,#) ww1_sgoCI [Occ=Once] ww2_sgoCJ [Occ=Once] ->
              (,) [ww1_sgoCI ww2_sgoCJ];
        };

Data.Fixed.mod' :: forall a. GHC.Real.Real a => a -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(LC(C(S))LLLLL)LL),U(1*U(A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,1*C1(U)),A,C(U(U,U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dReal_sgoCK eta_sgoCL eta1_sgoCM]
        case
            GHC.Real.$p1Real $dReal_sgoCK
        of
        $dNum_sgoCN [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,1*C1(U))>]
        { __DEFAULT ->
              let {
                sat_sgoCQ [Occ=Once] :: a_agnBF
                [LclId] =
                    [$dReal_sgoCK eta_sgoCL eta1_sgoCM $dNum_sgoCN] \u []
                        let {
                          sat_sgoCP [Occ=Once] :: a_agnBF
                          [LclId] =
                              [$dReal_sgoCK eta_sgoCL eta1_sgoCM $dNum_sgoCN] \u []
                                  let {
                                    sat_sgoCO [Occ=Once] :: GHC.Integer.Type.Integer
                                    [LclId] =
                                        [$dReal_sgoCK eta_sgoCL eta1_sgoCM] \u []
                                            Data.Fixed.div'
                                                $dReal_sgoCK
                                                GHC.Real.$fIntegralInteger
                                                eta_sgoCL
                                                eta1_sgoCM;
                                  } in  GHC.Num.fromInteger $dNum_sgoCN sat_sgoCO;
                        } in  GHC.Num.* $dNum_sgoCN sat_sgoCP eta1_sgoCM;
              } in  GHC.Num.- $dNum_sgoCN eta_sgoCL sat_sgoCQ;
        };

Data.Fixed.$fFractionalFixed2 :: forall a. GHC.Types.Any a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined $dIP3_rgoyz;

Data.Fixed.$w$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sgoCR ww_sgoCS ww1_sgoCT]
        case w_sgoCR Data.Fixed.$fFractionalFixed2 of dt_sgoCU {
          __DEFAULT ->
              case
                  GHC.Integer.Type.timesInteger ww1_sgoCT GHC.Real.$fEnumRatio1
              of
              sat_sgoCW
              { __DEFAULT ->
                    case GHC.Integer.Type.timesInteger ww_sgoCS dt_sgoCU of sat_sgoCV {
                      __DEFAULT ->
                          case GHC.Real.$w$sreduce sat_sgoCV sat_sgoCW of {
                            (#,#) ww7_sgoCY [Occ=Once] ww8_sgoCZ [Occ=Once] ->
                                GHC.Real.$w$s$cfloor
                                    GHC.Real.$fIntegralInteger ww7_sgoCY ww8_sgoCZ;
                          };
                    };
              };
        };

Data.Fixed.$fFractionalFixed1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Real.Rational -> GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<C(S),1*C1(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgoD0 w3_sgoD1]
        case w3_sgoD1 of {
          GHC.Real.:% ww1_sgoD3 [Occ=Once] ww2_sgoD4 [Occ=Once] ->
              Data.Fixed.$w$cfromRational w_sgoD0 ww1_sgoD3 ww2_sgoD4;
        };

Data.Fixed.$fRealFixed_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a -> GHC.Real.Rational
[GblId, Arity=2, Str=<C(S),1*C1(U)><S,U>m, Unf=OtherCon []] =
    [] \r [w_sgoD5 w3_sgoD6]
        case w_sgoD5 w3_sgoD6 of dt_sgoD7 {
          __DEFAULT ->
              case
                  GHC.Real.$w$s$c/
                      w3_sgoD6 GHC.Real.$fEnumRatio1 dt_sgoD7 GHC.Real.$fEnumRatio1
              of
              { (#,#) ww1_sgoD9 [Occ=Once] ww2_sgoDa [Occ=Once] ->
                    GHC.Real.:% [ww1_sgoD9 ww2_sgoDa];
              };
        };

Data.Fixed.$fFractionalFixed3
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a
     -> Data.Fixed.Fixed a -> GHC.Integer.Type.Integer
[GblId, Arity=3, Str=<C(S),1*C1(U)><S,U><S,U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoDb fa_sgoDc ds_sgoDd]
        case
            GHC.Integer.Type.eqInteger# ds_sgoDd Data.Fixed.$fEnumFixed1
        of
        { __DEFAULT ->
              case $dHasResolution_sgoDb fa_sgoDc of sat_sgoDf {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger fa_sgoDc sat_sgoDf
                    of
                    sat_sgoDg
                    { __DEFAULT -> GHC.Integer.Type.divInteger sat_sgoDg ds_sgoDd;
                    };
              };
          1# -> GHC.Real.divZeroError;
        };

Data.Fixed.$fFractionalFixed_$crecip
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a -> Data.Fixed.Fixed a
[GblId, Arity=2, Str=<C(S),1*C1(U)><S,U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoDh fa_sgoDi]
        case
            GHC.Integer.Type.eqInteger# fa_sgoDi Data.Fixed.$fEnumFixed1
        of
        { __DEFAULT ->
              case $dHasResolution_sgoDh fa_sgoDi of res_sgoDk [Dmd=<S,U>] {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger res_sgoDk res_sgoDk
                    of
                    sat_sgoDl
                    { __DEFAULT -> GHC.Integer.Type.divInteger sat_sgoDl fa_sgoDi;
                    };
              };
          1# -> GHC.Real.divZeroError;
        };

Data.Fixed.$fNumFixed_$c*
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a -> Data.Fixed.Fixed a -> Data.Fixed.Fixed a
[GblId, Arity=3, Str=<C(S),1*C1(U)><S,U><S,1*U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoDm fa_sgoDn ds_sgoDo]
        case $dHasResolution_sgoDm fa_sgoDn of ds1_sgoDp [Dmd=<S,U>] {
          __DEFAULT ->
              case
                  GHC.Integer.Type.eqInteger# ds1_sgoDp Data.Fixed.$fEnumFixed1
              of
              { __DEFAULT ->
                    case GHC.Integer.Type.timesInteger fa_sgoDn ds_sgoDo of sat_sgoDr {
                      __DEFAULT -> GHC.Integer.Type.divInteger sat_sgoDr ds1_sgoDp;
                    };
                1# -> GHC.Real.divZeroError;
              };
        };

Data.Fixed.$fNumFixed1
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<C(S),1*C1(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoDs i_sgoDt]
        case
            $dHasResolution_sgoDs Data.Fixed.$fFractionalFixed2
        of
        sat_sgoDu
        { __DEFAULT -> GHC.Integer.Type.timesInteger i_sgoDt sat_sgoDu;
        };

Data.Fixed.$fNumFixed2
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<C(S),1*C1(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoDv ds_sgoDw]
        case
            $dHasResolution_sgoDv Data.Fixed.$fFractionalFixed2
        of
        sat_sgoDy
        { __DEFAULT ->
              case GHC.Integer.Type.signumInteger ds_sgoDw of sat_sgoDx {
                __DEFAULT -> GHC.Integer.Type.timesInteger sat_sgoDx sat_sgoDy;
              };
        };

Data.Fixed.$fNumFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Num.Num (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgoDz]
        let {
          sat_sgoDC [Occ=Once]
            :: GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_XgnN5
          [LclId] =
              [$dHasResolution_sgoDz] \r [eta_B1]
                  Data.Fixed.$fNumFixed1 $dHasResolution_sgoDz eta_B1; } in
        let {
          sat_sgoDB [Occ=Once]
            :: Data.Fixed.Fixed a_XgnN5 -> Data.Fixed.Fixed a_XgnN5
          [LclId] =
              [$dHasResolution_sgoDz] \r [eta_B1]
                  Data.Fixed.$fNumFixed2 $dHasResolution_sgoDz eta_B1; } in
        let {
          sat_sgoDA [Occ=Once]
            :: Data.Fixed.Fixed a_XgnN5
               -> Data.Fixed.Fixed a_XgnN5 -> Data.Fixed.Fixed a_XgnN5
          [LclId] =
              [$dHasResolution_sgoDz] \r [eta_B2 eta_B1]
                  Data.Fixed.$fNumFixed_$c* $dHasResolution_sgoDz eta_B2 eta_B1;
        } in 
          GHC.Num.C:Num [GHC.Integer.Type.plusInteger
                         GHC.Integer.Type.minusInteger
                         sat_sgoDA
                         GHC.Integer.Type.negateInteger
                         GHC.Integer.Type.absInteger
                         sat_sgoDB
                         sat_sgoDC];

Data.Fixed.$fFractionalFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Real.Fractional (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgoDD]
        let {
          sat_sgoDH [Occ=Once]
            :: GHC.Real.Rational -> Data.Fixed.Fixed a_XgnLO
          [LclId] =
              [$dHasResolution_sgoDD] \r [eta_B1]
                  Data.Fixed.$fFractionalFixed1 $dHasResolution_sgoDD eta_B1; } in
        let {
          sat_sgoDG [Occ=Once]
            :: Data.Fixed.Fixed a_XgnLO -> Data.Fixed.Fixed a_XgnLO
          [LclId] =
              [$dHasResolution_sgoDD] \r [eta_B1]
                  Data.Fixed.$fFractionalFixed_$crecip
                      $dHasResolution_sgoDD eta_B1; } in
        let {
          sat_sgoDF [Occ=Once]
            :: Data.Fixed.Fixed a_XgnLO
               -> Data.Fixed.Fixed a_XgnLO -> Data.Fixed.Fixed a_XgnLO
          [LclId] =
              [$dHasResolution_sgoDD] \r [eta_B2 eta_B1]
                  Data.Fixed.$fFractionalFixed3
                      $dHasResolution_sgoDD eta_B2 eta_B1; } in
        let {
          sat_sgoDE [Occ=Once] :: GHC.Num.Num (Data.Fixed.Fixed a_XgnLO)
          [LclId] =
              [$dHasResolution_sgoDD] \u []
                  Data.Fixed.$fNumFixed $dHasResolution_sgoDD;
        } in 
          GHC.Real.C:Fractional [sat_sgoDE sat_sgoDF sat_sgoDG sat_sgoDH];

Data.Fixed.$fReadFixed2 :: GHC.Types.Double
[GblId] =
    [] \u []
        case logDouble# [10.0##] of v_sgoDI {
          __DEFAULT -> GHC.Types.D# [v_sgoDI];
        };

lvl9_rgoyO :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [172#];

lvl10_rgoyP :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [27#];

lvl11_rgoyQ :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [36#];

lvl12_rgoyR :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [loc_rgoyp
                                           loc1_rgoyq
                                           loc3_rgoys
                                           lvl9_rgoyO
                                           lvl10_rgoyP
                                           lvl9_rgoyO
                                           lvl11_rgoyQ];

lvl13_rgoyS :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [$dIP1_rgoyx
                                                  lvl12_rgoyR
                                                  GHC.Stack.Types.EmptyCallStack];

Data.Fixed.$fReadFixed3 :: forall a. Data.Fixed.Fixed a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined lvl13_rgoyS;

Data.Fixed.$fReadFixed1
  :: forall a.
     Data.Fixed.HasResolution a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Fixed.Fixed a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoDJ]
        let {
          lvl17_sgoDK :: GHC.Integer.Type.Integer
          [LclId] =
              [$dHasResolution_sgoDJ] \u []
                  $dHasResolution_sgoDJ Data.Fixed.$fFractionalFixed2; } in
        let {
          e_sgoDL :: GHC.Integer.Type.Integer
          [LclId] =
              [$dHasResolution_sgoDJ] \u []
                  case $dHasResolution_sgoDJ Data.Fixed.$fReadFixed3 of sat_sgoDM {
                    __DEFAULT ->
                        case GHC.Integer.Type.doubleFromInteger sat_sgoDM of wild_sgoDN {
                          __DEFAULT ->
                              case logDouble# [wild_sgoDN] of wild1_sgoDO {
                                __DEFAULT ->
                                    case Data.Fixed.$fReadFixed2 of {
                                      GHC.Types.D# v1_sgoDQ [Occ=Once] ->
                                          case /## [wild1_sgoDO v1_sgoDQ] of wild4_sgoDR {
                                            __DEFAULT ->
                                                case negateDouble# [wild4_sgoDR] of sat_sgoDS {
                                                  __DEFAULT ->
                                                      case
                                                          GHC.Integer.Type.decodeDoubleInteger
                                                              sat_sgoDS
                                                      of
                                                      { (#,#) ipv_sgoDU [Occ=Once*] ipv1_sgoDV ->
                                                            case <# [ipv1_sgoDV 0#] of {
                                                              __DEFAULT ->
                                                                  case
                                                                      GHC.Integer.Type.shiftLInteger
                                                                          ipv_sgoDU ipv1_sgoDV
                                                                  of
                                                                  sat_sgoDX
                                                                  { __DEFAULT ->
                                                                        GHC.Integer.Type.negateInteger
                                                                            sat_sgoDX;
                                                                  };
                                                              1# ->
                                                                  case
                                                                      negateInt# [ipv1_sgoDV]
                                                                  of
                                                                  s_sgoDY [Dmd=<S,U>]
                                                                  { __DEFAULT ->
                                                                        case ># [s_sgoDY 52#] of {
                                                                          __DEFAULT ->
                                                                              case
                                                                                  GHC.Integer.Type.integerToInt
                                                                                      ipv_sgoDU
                                                                              of
                                                                              n_sgoE0
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        uncheckedIShiftRA# [n_sgoE0
                                                                                                            s_sgoDY]
                                                                                    of
                                                                                    sat_sgoE1
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              GHC.Integer.Type.smallInteger
                                                                                                  sat_sgoE1
                                                                                          of
                                                                                          sat_sgoE2
                                                                                          { __DEFAULT ->
                                                                                                GHC.Integer.Type.negateInteger
                                                                                                    sat_sgoE2;
                                                                                          };
                                                                                    };
                                                                              };
                                                                          1# ->
                                                                              case
                                                                                  GHC.Integer.Type.ltInteger#
                                                                                      ipv_sgoDU
                                                                                      Data.Fixed.$fEnumFixed1
                                                                              of
                                                                              { __DEFAULT ->
                                                                                    Data.Fixed.$fEnumFixed1;
                                                                                1# ->
                                                                                    Data.Fixed.$fEnumFixed2;
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                        };
                  }; } in
        let {
          lvl18_sgoE4 [Occ=OnceL] :: Data.Fixed.Fixed a_agnFb
          [LclId] =
              [$dHasResolution_sgoDJ e_sgoDL] \u []
                  let {
                    sat_sgoE7 [Occ=Once] :: Data.Fixed.Fixed a_agnFb
                    [LclId] =
                        [$dHasResolution_sgoDJ] \u []
                            case
                                $dHasResolution_sgoDJ Data.Fixed.$fFractionalFixed2
                            of
                            sat_sgoE6
                            { __DEFAULT ->
                                  GHC.Integer.Type.timesInteger
                                      Data.Fixed.$fHasResolutionE4 sat_sgoE6;
                            }; } in
                  let {
                    sat_sgoE5 [Occ=Once, Dmd=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))>]
                      :: GHC.Num.Num (Data.Fixed.Fixed a_agnFb)
                    [LclId] =
                        [$dHasResolution_sgoDJ] \u []
                            Data.Fixed.$fNumFixed $dHasResolution_sgoDJ;
                  } in 
                    GHC.Real.^
                        sat_sgoE5 GHC.Real.$fIntegralInteger sat_sgoE7 e_sgoDL; } in
        let {
          sat_sgoEo [Occ=Once]
            :: Text.Read.Lex.Lexeme
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Fixed.Fixed a_agnFb)
          [LclId] =
              [$dHasResolution_sgoDJ
               lvl17_sgoDK
               e_sgoDL
               lvl18_sgoE4] \r [ds_sgoE9]
                  case ds_sgoE9 of {
                    __DEFAULT ->
                        Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4;
                    Text.Read.Lex.Number n_sgoEb [Occ=Once] ->
                        case Text.Read.Lex.numberToFixed e_sgoDL n_sgoEb of {
                          GHC.Base.Nothing ->
                              Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4;
                          GHC.Base.Just ds1_sgoEd [Occ=Once!] ->
                              case ds1_sgoEd of {
                                (,) i_sgoEf [Occ=Once] f_sgoEg [Occ=Once] ->
                                    let {
                                      x_sgoEh [Occ=OnceL] :: GHC.Integer.Type.Integer
                                      [LclId] =
                                          [$dHasResolution_sgoDJ
                                           lvl17_sgoDK
                                           lvl18_sgoE4
                                           i_sgoEf
                                           f_sgoEg] \u []
                                              case
                                                  GHC.Integer.Type.timesInteger f_sgoEg lvl17_sgoDK
                                              of
                                              sat_sgoEj
                                              { __DEFAULT ->
                                                    case
                                                        Data.Fixed.$fFractionalFixed3
                                                            $dHasResolution_sgoDJ
                                                            sat_sgoEj
                                                            lvl18_sgoE4
                                                    of
                                                    sat_sgoEk
                                                    { __DEFAULT ->
                                                          case
                                                              GHC.Integer.Type.timesInteger
                                                                  i_sgoEf lvl17_sgoDK
                                                          of
                                                          sat_sgoEi
                                                          { __DEFAULT ->
                                                                GHC.Integer.Type.plusInteger
                                                                    sat_sgoEi sat_sgoEk;
                                                          };
                                                    };
                                              }; } in
                                    let {
                                      sat_sgoEn [Occ=Once]
                                        :: Text.ParserCombinators.ReadPrec.Prec
                                           -> forall b.
                                              (Data.Fixed.Fixed a_agnFb
                                               -> Text.ParserCombinators.ReadP.P b)
                                              -> Text.ParserCombinators.ReadP.P b
                                      [LclId] =
                                          [x_sgoEh] \r [ds2_sgoEl k_sgoEm] k_sgoEm x_sgoEh;
                                    } in  sat_sgoEn;
                              };
                        };
                  }; } in
        let {
          sat_sgoE8 [Occ=Once] :: GHC.Num.Num (Data.Fixed.Fixed a_agnFb)
          [LclId] =
              [$dHasResolution_sgoDJ] \u []
                  Data.Fixed.$fNumFixed $dHasResolution_sgoDJ;
        } in  GHC.Read.readNumber1 sat_sgoE8 sat_sgoEo;

Data.Fixed.$fReadFixed_$creadsPrec
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Fixed.Fixed a)
[GblId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoEp]
        let {
          ds_sgoEq [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Fixed.Fixed a_XgnJE -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dHasResolution_sgoEp] \u []
                  Data.Fixed.$fReadFixed1 $dHasResolution_sgoEp; } in
        let {
          sat_sgoEt [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Fixed.Fixed a_XgnJE)
          [LclId] =
              [ds_sgoEq] \r [n_sgoEr]
                  let {
                    sat_sgoEs [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (Data.Fixed.Fixed a_XgnJE)
                    [LclId] =
                        [ds_sgoEq n_sgoEr] \u []
                            ds_sgoEq
                                n_sgoEr Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sgoEs;
        } in  sat_sgoEt;

Data.Fixed.$fReadFixed_$creadListPrec
  :: forall a.
     Data.Fixed.HasResolution a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Fixed.Fixed a]
[GblId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoEu]
        let {
          sat_sgoEv [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Fixed.Fixed a_XgnJC)
          [LclId] =
              [$dHasResolution_sgoEu] \s []
                  Data.Fixed.$fReadFixed1 $dHasResolution_sgoEu;
        } in  GHC.Read.list sat_sgoEv;

Data.Fixed.$fReadFixed_$creadList
  :: forall a.
     Data.Fixed.HasResolution a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Fixed.Fixed a]
[GblId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoEw]
        let {
          sat_sgoEy [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Fixed.Fixed a_XgnJD]
          [LclId] =
              [$dHasResolution_sgoEw] \u []
                  let {
                    sat_sgoEx [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Fixed.Fixed a_XgnJD)
                    [LclId] =
                        [$dHasResolution_sgoEw] \s []
                            Data.Fixed.$fReadFixed1 $dHasResolution_sgoEw;
                  } in 
                    GHC.Read.list
                        sat_sgoEx
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sgoEy;

Data.Fixed.$fReadFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Read.Read (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgoEz]
        let {
          sat_sgoED [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Fixed.Fixed a_XgnJB]
          [LclId] =
              [$dHasResolution_sgoEz] \u []
                  Data.Fixed.$fReadFixed_$creadListPrec $dHasResolution_sgoEz; } in
        let {
          sat_sgoEC [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Fixed.Fixed a_XgnJB)
          [LclId] =
              [$dHasResolution_sgoEz] \u []
                  Data.Fixed.$fReadFixed1 $dHasResolution_sgoEz; } in
        let {
          sat_sgoEB [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Fixed.Fixed a_XgnJB]
          [LclId] =
              [$dHasResolution_sgoEz] \u []
                  Data.Fixed.$fReadFixed_$creadList $dHasResolution_sgoEz; } in
        let {
          sat_sgoEA [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Fixed.Fixed a_XgnJB)
          [LclId] =
              [$dHasResolution_sgoEz] \u []
                  Data.Fixed.$fReadFixed_$creadsPrec $dHasResolution_sgoEz;
        } in  GHC.Read.C:Read [sat_sgoEA sat_sgoEB sat_sgoEC sat_sgoED];

Data.Fixed.$fEqFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Classes.Eq (Data.Fixed.Fixed a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [GHC.Integer.Type.eqInteger
                                     GHC.Integer.Type.neqInteger];

Data.Fixed.$fOrdFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Classes.Ord (Data.Fixed.Fixed a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Fixed.$fEqFixed
                                      GHC.Integer.Type.compareInteger
                                      GHC.Integer.Type.ltInteger
                                      GHC.Integer.Type.leInteger
                                      GHC.Integer.Type.gtInteger
                                      GHC.Integer.Type.geInteger
                                      GHC.Integer.Type.$fOrdInteger_$cmax
                                      GHC.Integer.Type.$fOrdInteger_$cmin];

Data.Fixed.$fRealFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Real.Real (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgoEE]
        let {
          sat_sgoEG [Occ=Once]
            :: Data.Fixed.Fixed a_agnIn -> GHC.Real.Rational
          [LclId] =
              [$dHasResolution_sgoEE] \r [eta_B1]
                  Data.Fixed.$fRealFixed_$ctoRational
                      $dHasResolution_sgoEE eta_B1; } in
        let {
          sat_sgoEF [Occ=Once] :: GHC.Num.Num (Data.Fixed.Fixed a_agnIn)
          [LclId] =
              [$dHasResolution_sgoEE] \u []
                  Data.Fixed.$fNumFixed $dHasResolution_sgoEE;
        } in  GHC.Real.C:Real [sat_sgoEF Data.Fixed.$fOrdFixed sat_sgoEG];

Data.Fixed.$fRealFracFixed_$ctruncate
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b. GHC.Real.Integral b => Data.Fixed.Fixed a -> b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoEH $dIntegral_sgoEI f_sgoEJ]
        case $dHasResolution_sgoEH f_sgoEJ of dt_sgoEK {
          __DEFAULT ->
              case
                  GHC.Real.$w$s$c/
                      f_sgoEJ GHC.Real.$fEnumRatio1 dt_sgoEK GHC.Real.$fEnumRatio1
              of
              { (#,#) ww7_sgoEM [Occ=Once] ww8_sgoEN ->
                    let {
                      sat_sgoEV [Occ=Once] :: GHC.Integer.Type.Integer
                      [LclId] =
                          [ww7_sgoEM ww8_sgoEN] \u []
                              case
                                  GHC.Integer.Type.eqInteger# ww8_sgoEN Data.Fixed.$fEnumFixed1
                              of
                              { __DEFAULT ->
                                    case GHC.Integer.Type.quotRemInteger ww7_sgoEM ww8_sgoEN of {
                                      (#,#) ipv_sgoES [Occ=Once] _ [Occ=Dead] -> ipv_sgoES;
                                    };
                                1# -> GHC.Real.divZeroError;
                              };
                    } in 
                      case GHC.Real.$p1Integral $dIntegral_sgoEI of sat_sgoEO {
                        __DEFAULT ->
                            case GHC.Real.$p1Real sat_sgoEO of sat_sgoEP {
                              __DEFAULT -> GHC.Num.fromInteger sat_sgoEP sat_sgoEV;
                            };
                      };
              };
        };

Data.Fixed.$fRealFracFixed_$cround
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b. GHC.Real.Integral b => Data.Fixed.Fixed a -> b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,U(U(U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoEW $dIntegral_sgoEX f_sgoEY]
        case $dHasResolution_sgoEW f_sgoEY of dt_sgoEZ {
          __DEFAULT ->
              case
                  GHC.Real.$w$s$c/
                      f_sgoEY GHC.Real.$fEnumRatio1 dt_sgoEZ GHC.Real.$fEnumRatio1
              of
              { (#,#) ww7_sgoF1 [Occ=Once] ww8_sgoF2 [Occ=Once] ->
                    GHC.Real.$w$s$cround $dIntegral_sgoEX ww7_sgoF1 ww8_sgoF2;
              };
        };

Data.Fixed.$fRealFracFixed_$cceiling
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b. GHC.Real.Integral b => Data.Fixed.Fixed a -> b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,U(U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoF3 $dIntegral_sgoF4 f_sgoF5]
        case $dHasResolution_sgoF3 f_sgoF5 of dt_sgoF6 {
          __DEFAULT ->
              case
                  GHC.Real.$w$s$c/
                      f_sgoF5 GHC.Real.$fEnumRatio1 dt_sgoF6 GHC.Real.$fEnumRatio1
              of
              { (#,#) ww7_sgoF8 [Occ=Once] ww8_sgoF9 [Occ=Once] ->
                    GHC.Real.$w$s$cceiling $dIntegral_sgoF4 ww7_sgoF8 ww8_sgoF9;
              };
        };

Data.Fixed.$fRealFracFixed_$cfloor
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b. GHC.Real.Integral b => Data.Fixed.Fixed a -> b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoFa $dIntegral_sgoFb f_sgoFc]
        case $dHasResolution_sgoFa f_sgoFc of dt_sgoFd {
          __DEFAULT ->
              case
                  GHC.Real.$w$s$c/
                      f_sgoFc GHC.Real.$fEnumRatio1 dt_sgoFd GHC.Real.$fEnumRatio1
              of
              { (#,#) ww7_sgoFf [Occ=Once] ww8_sgoFg [Occ=Once] ->
                    GHC.Real.$w$s$cfloor $dIntegral_sgoFb ww7_sgoFf ww8_sgoFg;
              };
        };

Data.Fixed.$w$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b.
     GHC.Real.Integral b =>
     Data.Fixed.Fixed a -> (# b, Data.Fixed.Fixed a #)
[GblId,
 Arity=3,
 Str=<L,C(U)><L,U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgoFh w3_sgoFi w4_sgoFj]
        let {
          i_sgoFk :: b_sgooh
          [LclId] =
              [w_sgoFh w3_sgoFi w4_sgoFj] \u []
                  Data.Fixed.$fRealFracFixed_$ctruncate
                      w_sgoFh w3_sgoFi w4_sgoFj; } in
        let {
          sat_sgoFo [Occ=Once] :: Data.Fixed.Fixed a_sgoof
          [LclId] =
              [w_sgoFh w3_sgoFi w4_sgoFj i_sgoFk] \u []
                  case w_sgoFh Data.Fixed.$fFractionalFixed2 of sat_sgoFm {
                    __DEFAULT ->
                        case GHC.Real.toInteger w3_sgoFi i_sgoFk of sat_sgoFl {
                          __DEFAULT ->
                              case
                                  GHC.Integer.Type.timesInteger sat_sgoFl sat_sgoFm
                              of
                              sat_sgoFn
                              { __DEFAULT -> GHC.Integer.Type.minusInteger w4_sgoFj sat_sgoFn;
                              };
                        };
                  };
        } in  (#,#) [i_sgoFk sat_sgoFo];

Data.Fixed.$fRealFracFixed_$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b.
     GHC.Real.Integral b =>
     Data.Fixed.Fixed a -> (b, Data.Fixed.Fixed a)
[GblId,
 Arity=3,
 Str=<L,C(U)><L,U(U(U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sgoFp w3_sgoFq w4_sgoFr]
        case Data.Fixed.$w$cproperFraction w_sgoFp w3_sgoFq w4_sgoFr of {
          (#,#) ww1_sgoFt [Occ=Once] ww2_sgoFu [Occ=Once] ->
              (,) [ww1_sgoFt ww2_sgoFu];
        };

Data.Fixed.$fRealFracFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Real.RealFrac (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgoFv]
        let {
          sat_sgoFC [Occ=Once]
            :: forall b. GHC.Real.Integral b => Data.Fixed.Fixed a_agnG0 -> b
          [LclId] =
              [$dHasResolution_sgoFv] \r [eta_B2 eta_B1]
                  Data.Fixed.$fRealFracFixed_$cfloor
                      $dHasResolution_sgoFv eta_B2 eta_B1; } in
        let {
          sat_sgoFB [Occ=Once]
            :: forall b. GHC.Real.Integral b => Data.Fixed.Fixed a_agnG0 -> b
          [LclId] =
              [$dHasResolution_sgoFv] \r [eta_B2 eta_B1]
                  Data.Fixed.$fRealFracFixed_$cceiling
                      $dHasResolution_sgoFv eta_B2 eta_B1; } in
        let {
          sat_sgoFA [Occ=Once]
            :: forall b. GHC.Real.Integral b => Data.Fixed.Fixed a_agnG0 -> b
          [LclId] =
              [$dHasResolution_sgoFv] \r [eta_B2 eta_B1]
                  Data.Fixed.$fRealFracFixed_$cround
                      $dHasResolution_sgoFv eta_B2 eta_B1; } in
        let {
          sat_sgoFz [Occ=Once]
            :: forall b. GHC.Real.Integral b => Data.Fixed.Fixed a_agnG0 -> b
          [LclId] =
              [$dHasResolution_sgoFv] \r [eta_B2 eta_B1]
                  Data.Fixed.$fRealFracFixed_$ctruncate
                      $dHasResolution_sgoFv eta_B2 eta_B1; } in
        let {
          sat_sgoFy [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Fixed.Fixed a_agnG0 -> (b, Data.Fixed.Fixed a_agnG0)
          [LclId] =
              [$dHasResolution_sgoFv] \r [eta_B2 eta_B1]
                  Data.Fixed.$fRealFracFixed_$cproperFraction
                      $dHasResolution_sgoFv eta_B2 eta_B1; } in
        let {
          sat_sgoFx [Occ=Once]
            :: GHC.Real.Fractional (Data.Fixed.Fixed a_agnG0)
          [LclId] =
              [$dHasResolution_sgoFv] \u []
                  Data.Fixed.$fFractionalFixed $dHasResolution_sgoFv; } in
        let {
          sat_sgoFw [Occ=Once] :: GHC.Real.Real (Data.Fixed.Fixed a_agnG0)
          [LclId] =
              [$dHasResolution_sgoFv] \u []
                  Data.Fixed.$fRealFixed $dHasResolution_sgoFv;
        } in 
          GHC.Real.C:RealFrac [sat_sgoFw
                               sat_sgoFx
                               sat_sgoFy
                               sat_sgoFz
                               sat_sgoFA
                               sat_sgoFB
                               sat_sgoFC];

chopZeros_rgnn4 :: GHC.Integer.Type.Integer -> GHC.Base.String
[GblId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
    sat-only [] \r [ds_sgoFD]
        case
            GHC.Integer.Type.eqInteger# ds_sgoFD Data.Fixed.$fEnumFixed1
        of
        { __DEFAULT ->
              case
                  GHC.Integer.Type.modInteger ds_sgoFD Data.Fixed.$fHasResolutionE4
              of
              sat_sgoFF
              { __DEFAULT ->
                    case
                        GHC.Integer.Type.eqInteger# sat_sgoFF Data.Fixed.$fEnumFixed1
                    of
                    { __DEFAULT -> GHC.Show.$fShowInteger_$cshow ds_sgoFD;
                      1# ->
                          case
                              GHC.Integer.Type.divInteger ds_sgoFD Data.Fixed.$fHasResolutionE4
                          of
                          sat_sgoFH
                          { __DEFAULT -> chopZeros_rgnn4 sat_sgoFH;
                          };
                    };
              };
          1# -> [] [];
        };

lvl14_rgoyT :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! ['0'#];

lvl15_rgoyU :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! ['.'#];

lvl16_rgoyV :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "-"#;

Data.Fixed.showFixed [Occ=LoopBreaker]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Types.Bool -> Data.Fixed.Fixed a -> GHC.Base.String
[GblId, Arity=3, Str=<L,1*C1(U)><L,U><S,U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoFI chopTrailingZeros_sgoFJ fa_sgoFK]
        case
            GHC.Integer.Type.ltInteger# fa_sgoFK Data.Fixed.$fEnumFixed1
        of
        { __DEFAULT ->
              case $dHasResolution_sgoFI fa_sgoFK of res_sgoFM [Dmd=<S,U>] {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.eqInteger# res_sgoFM Data.Fixed.$fEnumFixed1
                    of
                    { __DEFAULT ->
                          case GHC.Integer.Type.divModInteger fa_sgoFK res_sgoFM of {
                            (#,#) ipv_sgoFP [Occ=Once] ipv1_sgoFQ [Occ=Once*] ->
                                case GHC.Show.$w$cshowsPrec4 0# ipv_sgoFP GHC.Types.[] of {
                                  (#,#) ww3_sgoFS [Occ=Once] ww4_sgoFT [Occ=Once] ->
                                      let {
                                        sat_sgoGK [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                        [LclId] =
                                            [chopTrailingZeros_sgoFJ res_sgoFM ipv1_sgoFQ] \s []
                                                case
                                                    GHC.Integer.Type.doubleFromInteger res_sgoFM
                                                of
                                                wild2_sgoFV
                                                { __DEFAULT ->
                                                      case logDouble# [wild2_sgoFV] of wild3_sgoFW {
                                                        __DEFAULT ->
                                                            case Data.Fixed.$fReadFixed2 of {
                                                              GHC.Types.D# v1_sgoFY [Occ=Once] ->
                                                                  case
                                                                      /## [wild3_sgoFW v1_sgoFY]
                                                                  of
                                                                  wild4_sgoFZ
                                                                  { __DEFAULT ->
                                                                        case
                                                                            double2Int# [wild4_sgoFZ]
                                                                        of
                                                                        n_sgoG0 [Dmd=<S,U>]
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  int2Double# [n_sgoG0]
                                                                              of
                                                                              sat_sgoGH
                                                                              { __DEFAULT ->
                                                                                    let-no-escape {
                                                                                      $j_sgoG1 [Occ=Once*!T[1],
                                                                                                Dmd=<C(S),1*C1(U)>]
                                                                                        :: GHC.Prim.Int#
                                                                                           -> [GHC.Types.Char]
                                                                                      [LclId[JoinId(1)],
                                                                                       Arity=1,
                                                                                       Str=<S,U>,
                                                                                       Unf=OtherCon []] =
                                                                                          sat-only [chopTrailingZeros_sgoFJ
                                                                                                    res_sgoFM
                                                                                                    ipv1_sgoFQ] \r [ww_sgoG2]
                                                                                              case
                                                                                                  <# [ww_sgoG2
                                                                                                      0#]
                                                                                              of
                                                                                              { __DEFAULT ->
                                                                                                    let-no-escape {
                                                                                                      $j1_sgoG4 [Occ=Once*!T[1],
                                                                                                                 Dmd=<C(S),1*C1(U)>]
                                                                                                        :: GHC.Integer.Type.Integer
                                                                                                           -> [GHC.Types.Char]
                                                                                                      [LclId[JoinId(1)],
                                                                                                       Arity=1,
                                                                                                       Str=<S,U>,
                                                                                                       Unf=OtherCon []] =
                                                                                                          sat-only [chopTrailingZeros_sgoFJ
                                                                                                                    ww_sgoG2] \r [ds_sgoG5]
                                                                                                              let-no-escape {
                                                                                                                fail_sgoG6 [Occ=Once*!T[1],
                                                                                                                            Dmd=<L,1*C1(U)>]
                                                                                                                  :: GHC.Prim.Void#
                                                                                                                     -> [GHC.Types.Char]
                                                                                                                [LclId[JoinId(1)],
                                                                                                                 Arity=1,
                                                                                                                 Str=<L,A>,
                                                                                                                 Unf=OtherCon []] =
                                                                                                                    sat-only [chopTrailingZeros_sgoFJ
                                                                                                                              ww_sgoG2
                                                                                                                              ds_sgoG5] \r [ds1_sgoG7]
                                                                                                                        case
                                                                                                                            GHC.Show.$w$cshowsPrec4
                                                                                                                                0#
                                                                                                                                ds_sgoG5
                                                                                                                                GHC.Types.[]
                                                                                                                        of
                                                                                                                        { (#,#) ww5_sgoG9 [Occ=OnceL]
                                                                                                                                ww6_sgoGa [Occ=OnceL] ->
                                                                                                                              let {
                                                                                                                                s_sgoGb [Dmd=<S,U>]
                                                                                                                                  :: GHC.Base.String
                                                                                                                                [LclId,
                                                                                                                                 Unf=OtherCon []] =
                                                                                                                                    CCCS :! [ww5_sgoG9
                                                                                                                                             ww6_sgoGa];
                                                                                                                              } in 
                                                                                                                                case
                                                                                                                                    GHC.List.$wlenAcc
                                                                                                                                        s_sgoGb
                                                                                                                                        0#
                                                                                                                                of
                                                                                                                                ww7_sgoGc
                                                                                                                                { __DEFAULT ->
                                                                                                                                      case
                                                                                                                                          -# [ww_sgoG2
                                                                                                                                              ww7_sgoGc]
                                                                                                                                      of
                                                                                                                                      y_sgoGd [Dmd=<S,U>]
                                                                                                                                      { __DEFAULT ->
                                                                                                                                            case
                                                                                                                                                <# [0#
                                                                                                                                                    y_sgoGd]
                                                                                                                                            of
                                                                                                                                            { __DEFAULT ->
                                                                                                                                                  case
                                                                                                                                                      chopTrailingZeros_sgoFJ
                                                                                                                                                  of
                                                                                                                                                  { GHC.Types.False ->
                                                                                                                                                        : [lvl15_rgoyU
                                                                                                                                                           s_sgoGb];
                                                                                                                                                    GHC.Types.True ->
                                                                                                                                                        case
                                                                                                                                                            chopZeros_rgnn4
                                                                                                                                                                ds_sgoG5
                                                                                                                                                        of
                                                                                                                                                        wild6_sgoGg
                                                                                                                                                        { [] ->
                                                                                                                                                              [] [];
                                                                                                                                                          : _ [Occ=Dead]
                                                                                                                                                            _ [Occ=Dead] ->
                                                                                                                                                              : [lvl15_rgoyU
                                                                                                                                                                 wild6_sgoGg];
                                                                                                                                                        };
                                                                                                                                                  };
                                                                                                                                              1# ->
                                                                                                                                                  let {
                                                                                                                                                    n1_sgoGj [Occ=OnceL]
                                                                                                                                                      :: [GHC.Types.Char]
                                                                                                                                                    [LclId] =
                                                                                                                                                        [chopTrailingZeros_sgoFJ
                                                                                                                                                         ds_sgoG5
                                                                                                                                                         s_sgoGb] \u []
                                                                                                                                                            case
                                                                                                                                                                chopTrailingZeros_sgoFJ
                                                                                                                                                            of
                                                                                                                                                            { GHC.Types.False ->
                                                                                                                                                                  s_sgoGb;
                                                                                                                                                              GHC.Types.True ->
                                                                                                                                                                  chopZeros_rgnn4
                                                                                                                                                                      ds_sgoG5;
                                                                                                                                                            }; } in
                                                                                                                                                  let {
                                                                                                                                                    lvl17_sgoGl [Occ=OnceL]
                                                                                                                                                      :: [GHC.Types.Char]
                                                                                                                                                    [LclId,
                                                                                                                                                     Unf=OtherCon []] =
                                                                                                                                                        CCCS :! [lvl14_rgoyT
                                                                                                                                                                 n1_sgoGj]; } in
                                                                                                                                                  let {
                                                                                                                                                    $wxs_sgoGm [InlPrag=NOUSERINLINE[0],
                                                                                                                                                                Occ=LoopBreaker]
                                                                                                                                                      :: GHC.Prim.Int#
                                                                                                                                                         -> [GHC.Types.Char]
                                                                                                                                                    [LclId,
                                                                                                                                                     Arity=1,
                                                                                                                                                     Str=<S,1*U>,
                                                                                                                                                     Unf=OtherCon []] =
                                                                                                                                                        sat-only [lvl17_sgoGl
                                                                                                                                                                  $wxs_sgoGm] \r [ww8_sgoGn]
                                                                                                                                                            case
                                                                                                                                                                ww8_sgoGn
                                                                                                                                                            of
                                                                                                                                                            ds3_sgoGo
                                                                                                                                                            { __DEFAULT ->
                                                                                                                                                                  let {
                                                                                                                                                                    sat_sgoGq [Occ=Once]
                                                                                                                                                                      :: [GHC.Types.Char]
                                                                                                                                                                    [LclId] =
                                                                                                                                                                        [$wxs_sgoGm
                                                                                                                                                                         ds3_sgoGo] \u []
                                                                                                                                                                            case
                                                                                                                                                                                -# [ds3_sgoGo
                                                                                                                                                                                    1#]
                                                                                                                                                                            of
                                                                                                                                                                            sat_sgoGp
                                                                                                                                                                            { __DEFAULT ->
                                                                                                                                                                                  $wxs_sgoGm
                                                                                                                                                                                      sat_sgoGp;
                                                                                                                                                                            };
                                                                                                                                                                  } in 
                                                                                                                                                                    : [lvl14_rgoyT
                                                                                                                                                                       sat_sgoGq];
                                                                                                                                                              1# ->
                                                                                                                                                                  lvl17_sgoGl;
                                                                                                                                                            };
                                                                                                                                                  } in 
                                                                                                                                                    case
                                                                                                                                                        $wxs_sgoGm
                                                                                                                                                            y_sgoGd
                                                                                                                                                    of
                                                                                                                                                    wild5_sgoGr
                                                                                                                                                    { [] ->
                                                                                                                                                          [] [];
                                                                                                                                                      : _ [Occ=Dead]
                                                                                                                                                        _ [Occ=Dead] ->
                                                                                                                                                          : [lvl15_rgoyU
                                                                                                                                                             wild5_sgoGr];
                                                                                                                                                    };
                                                                                                                                            };
                                                                                                                                      };
                                                                                                                                };
                                                                                                                        };
                                                                                                              } in 
                                                                                                                case
                                                                                                                    chopTrailingZeros_sgoFJ
                                                                                                                of
                                                                                                                { GHC.Types.False ->
                                                                                                                      fail_sgoG6
                                                                                                                          GHC.Prim.void#;
                                                                                                                  GHC.Types.True ->
                                                                                                                      case
                                                                                                                          GHC.Integer.Type.eqInteger#
                                                                                                                              ds_sgoG5
                                                                                                                              Data.Fixed.$fEnumFixed1
                                                                                                                      of
                                                                                                                      { __DEFAULT ->
                                                                                                                            fail_sgoG6
                                                                                                                                GHC.Prim.void#;
                                                                                                                        1# ->
                                                                                                                            [] [];
                                                                                                                      };
                                                                                                                };
                                                                                                    } in 
                                                                                                      case
                                                                                                          ww_sgoG2
                                                                                                      of
                                                                                                      wild5_sgoGw
                                                                                                      { __DEFAULT ->
                                                                                                            case
                                                                                                                GHC.Real.$wf
                                                                                                                    Data.Fixed.$fHasResolutionE4
                                                                                                                    wild5_sgoGw
                                                                                                            of
                                                                                                            sat_sgoGx
                                                                                                            { __DEFAULT ->
                                                                                                                  case
                                                                                                                      GHC.Integer.Type.timesInteger
                                                                                                                          ipv1_sgoFQ
                                                                                                                          sat_sgoGx
                                                                                                                  of
                                                                                                                  sat_sgoGy
                                                                                                                  { __DEFAULT ->
                                                                                                                        case
                                                                                                                            GHC.Integer.Type.plusInteger
                                                                                                                                sat_sgoGy
                                                                                                                                res_sgoFM
                                                                                                                        of
                                                                                                                        sat_sgoGz
                                                                                                                        { __DEFAULT ->
                                                                                                                              case
                                                                                                                                  GHC.Integer.Type.minusInteger
                                                                                                                                      sat_sgoGz
                                                                                                                                      Data.Fixed.$fEnumFixed2
                                                                                                                              of
                                                                                                                              sat_sgoGA
                                                                                                                              { __DEFAULT ->
                                                                                                                                    case
                                                                                                                                        GHC.Integer.Type.divInteger
                                                                                                                                            sat_sgoGA
                                                                                                                                            res_sgoFM
                                                                                                                                    of
                                                                                                                                    sat_sgoGB
                                                                                                                                    { __DEFAULT ->
                                                                                                                                          $j1_sgoG4
                                                                                                                                              sat_sgoGB;
                                                                                                                                    };
                                                                                                                              };
                                                                                                                        };
                                                                                                                  };
                                                                                                            };
                                                                                                        0# ->
                                                                                                            case
                                                                                                                GHC.Integer.Type.timesInteger
                                                                                                                    ipv1_sgoFQ
                                                                                                                    GHC.Real.$fEnumRatio1
                                                                                                            of
                                                                                                            sat_sgoGC
                                                                                                            { __DEFAULT ->
                                                                                                                  case
                                                                                                                      GHC.Integer.Type.plusInteger
                                                                                                                          sat_sgoGC
                                                                                                                          res_sgoFM
                                                                                                                  of
                                                                                                                  sat_sgoGD
                                                                                                                  { __DEFAULT ->
                                                                                                                        case
                                                                                                                            GHC.Integer.Type.minusInteger
                                                                                                                                sat_sgoGD
                                                                                                                                Data.Fixed.$fEnumFixed2
                                                                                                                        of
                                                                                                                        sat_sgoGE
                                                                                                                        { __DEFAULT ->
                                                                                                                              case
                                                                                                                                  GHC.Integer.Type.divInteger
                                                                                                                                      sat_sgoGE
                                                                                                                                      res_sgoFM
                                                                                                                              of
                                                                                                                              sat_sgoGF
                                                                                                                              { __DEFAULT ->
                                                                                                                                    $j1_sgoG4
                                                                                                                                        sat_sgoGF;
                                                                                                                              };
                                                                                                                        };
                                                                                                                  };
                                                                                                            };
                                                                                                      };
                                                                                                1# ->
                                                                                                    GHC.Real.^1;
                                                                                              };
                                                                                    } in 
                                                                                      case
                                                                                          <## [sat_sgoGH
                                                                                               wild4_sgoFZ]
                                                                                      of
                                                                                      { __DEFAULT ->
                                                                                            $j_sgoG1
                                                                                                n_sgoG0;
                                                                                        1# ->
                                                                                            case
                                                                                                +# [n_sgoG0
                                                                                                    1#]
                                                                                            of
                                                                                            sat_sgoGJ
                                                                                            { __DEFAULT ->
                                                                                                  $j_sgoG1
                                                                                                      sat_sgoGJ;
                                                                                            };
                                                                                      };
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                }; } in
                                      let {
                                        sat_sgoFU [Occ=Once] :: [GHC.Types.Char]
                                        [LclId] =
                                            CCCS :! [ww3_sgoFS ww4_sgoFT];
                                      } in  GHC.Base.++ sat_sgoFU sat_sgoGK;
                                };
                          };
                      1# -> GHC.Real.divZeroError;
                    };
              };
          1# ->
              let {
                sat_sgoGN [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [$dHasResolution_sgoFI chopTrailingZeros_sgoFJ fa_sgoFK] \u []
                        case GHC.Integer.Type.negateInteger fa_sgoFK of sat_sgoGM {
                          __DEFAULT ->
                              Data.Fixed.showFixed
                                  $dHasResolution_sgoFI chopTrailingZeros_sgoFJ sat_sgoGM;
                        };
              } in  GHC.CString.unpackAppendCString# lvl16_rgoyV sat_sgoGN;
        };

Data.Fixed.$fShowFixed_$cshow
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a -> GHC.Base.String
[GblId, Arity=2, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoGO eta_B1]
        Data.Fixed.showFixed $dHasResolution_sgoGO GHC.Types.False eta_B1;

Data.Fixed.$fShowFixed_$cshowsPrec
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Types.Int -> Data.Fixed.Fixed a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*C1(U)><L,A><S,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoGP ds_sgoGQ x_sgoGR s_sgoGS]
        case
            Data.Fixed.showFixed $dHasResolution_sgoGP GHC.Types.False x_sgoGR
        of
        sat_sgoGT
        { __DEFAULT -> GHC.Base.++ sat_sgoGT s_sgoGS;
        };

Data.Fixed.$fShowFixed_$cshowList
  :: forall a.
     Data.Fixed.HasResolution a =>
     [Data.Fixed.Fixed a] -> GHC.Show.ShowS
[GblId, Arity=3, Str=<L,C(U)><S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoGU ls_sgoGV s_sgoGW]
        let {
          sat_sgoH0 [Occ=Once] :: Data.Fixed.Fixed a_agnFG -> GHC.Show.ShowS
          [LclId] =
              [$dHasResolution_sgoGU] \r [x_sgoGX s1_sgoGY]
                  case
                      Data.Fixed.showFixed $dHasResolution_sgoGU GHC.Types.False x_sgoGX
                  of
                  sat_sgoGZ
                  { __DEFAULT -> GHC.Base.++ sat_sgoGZ s1_sgoGY;
                  };
        } in  GHC.Show.showList__ sat_sgoH0 ls_sgoGV s_sgoGW;

Data.Fixed.$fShowFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Show.Show (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgoH1]
        let {
          sat_sgoH4 [Occ=Once]
            :: [Data.Fixed.Fixed a_agnFG] -> GHC.Show.ShowS
          [LclId] =
              [$dHasResolution_sgoH1] \r [eta_B2 eta_B1]
                  Data.Fixed.$fShowFixed_$cshowList
                      $dHasResolution_sgoH1 eta_B2 eta_B1; } in
        let {
          sat_sgoH3 [Occ=Once] :: Data.Fixed.Fixed a_agnFG -> GHC.Base.String
          [LclId] =
              [$dHasResolution_sgoH1] \r [eta_B1]
                  Data.Fixed.$fShowFixed_$cshow $dHasResolution_sgoH1 eta_B1; } in
        let {
          sat_sgoH2 [Occ=Once]
            :: GHC.Types.Int -> Data.Fixed.Fixed a_agnFG -> GHC.Show.ShowS
          [LclId] =
              [$dHasResolution_sgoH1] \r [eta_B3 eta_B2 eta_B1]
                  Data.Fixed.$fShowFixed_$cshowsPrec
                      $dHasResolution_sgoH1 eta_B3 eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sgoH2 sat_sgoH3 sat_sgoH4];


==================== STG syntax: ====================
2018-03-16 16:12:18.161882605 UTC

Data.Fixed.resolution [InlPrag=INLINE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall (p :: * -> *). p a -> GHC.Integer.Type.Integer
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_sgoyX] v_sgoyX;

Data.Fixed.$fDataFixed2
  :: GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sgoyY] v_sgoyY;

Data.Fixed.$fDataFixed_$cgfoldl
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Fixed.Fixed a
     -> c (Data.Fixed.Fixed a)
[GblId,
 Arity=4,
 Str=<L,A><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sgoyZ k_sgoz0 z_sgoz1 ds_sgoz2]
        let {
          sat_sgoz3 [Occ=Once]
            :: c_agnLa (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_agnL1)
          [LclId] =
              [z_sgoz1] \u [] z_sgoz1 Data.Fixed.$fDataFixed2;
        } in  k_sgoz0 Data.Data.$fDataInteger sat_sgoz3 ds_sgoz2;

Data.Fixed.$fEnumFixed1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Fixed.$fEnumFixed_$cenumFromThenTo
  :: forall a.
     Data.Fixed.Fixed a
     -> Data.Fixed.Fixed a -> Data.Fixed.Fixed a -> [Data.Fixed.Fixed a]
[GblId, Arity=3, Str=<S,U><S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [ds_sgoz4 ds1_sgoz5 ds2_sgoz6]
        case
            GHC.Integer.Type.minusInteger ds1_sgoz5 ds_sgoz4
        of
        delta_sgoz7 [Dmd=<S,U>]
        { __DEFAULT ->
              case
                  GHC.Integer.Type.geInteger# delta_sgoz7 Data.Fixed.$fEnumFixed1
              of
              { __DEFAULT ->
                    let {
                      go_sgoz9 [Occ=LoopBreaker]
                        :: GHC.Integer.Type.Integer -> [Data.Fixed.Fixed a_agnJM]
                      [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ds2_sgoz6 delta_sgoz7 go_sgoz9] \r [x_sgoza]
                              case GHC.Integer.Type.ltInteger# x_sgoza ds2_sgoz6 of {
                                __DEFAULT ->
                                    let {
                                      sat_sgozd [Occ=Once] :: [Data.Fixed.Fixed a_agnJM]
                                      [LclId] =
                                          [delta_sgoz7 go_sgoz9 x_sgoza] \u []
                                              case
                                                  GHC.Integer.Type.plusInteger x_sgoza delta_sgoz7
                                              of
                                              sat_sgozc
                                              { __DEFAULT -> go_sgoz9 sat_sgozc;
                                              };
                                    } in  : [x_sgoza sat_sgozd];
                                1# -> [] [];
                              };
                    } in  go_sgoz9 ds_sgoz4;
                1# ->
                    let {
                      go_sgoze [Occ=LoopBreaker]
                        :: GHC.Integer.Type.Integer -> [Data.Fixed.Fixed a_agnJM]
                      [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ds2_sgoz6 delta_sgoz7 go_sgoze] \r [x_sgozf]
                              case GHC.Integer.Type.gtInteger# x_sgozf ds2_sgoz6 of {
                                __DEFAULT ->
                                    let {
                                      sat_sgozi [Occ=Once] :: [Data.Fixed.Fixed a_agnJM]
                                      [LclId] =
                                          [delta_sgoz7 go_sgoze x_sgozf] \u []
                                              case
                                                  GHC.Integer.Type.plusInteger x_sgozf delta_sgoz7
                                              of
                                              sat_sgozh
                                              { __DEFAULT -> go_sgoze sat_sgozh;
                                              };
                                    } in  : [x_sgozf sat_sgozi];
                                1# -> [] [];
                              };
                    } in  go_sgoze ds_sgoz4;
              };
        };

sat_sgozj :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_sgozk :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgozj GHC.Types.[]];

Data.Fixed.$fEnumFixed2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgozk;

Data.Fixed.$fEnumFixed_$cenumFromTo
  :: forall a.
     Data.Fixed.Fixed a -> Data.Fixed.Fixed a -> [Data.Fixed.Fixed a]
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ds_sgozl ds1_sgozm]
        let {
          go_sgozn [Occ=LoopBreaker]
            :: GHC.Integer.Type.Integer -> [Data.Fixed.Fixed a_agnJM]
          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
              sat-only [ds1_sgozm go_sgozn] \r [x_sgozo]
                  case GHC.Integer.Type.gtInteger# x_sgozo ds1_sgozm of {
                    __DEFAULT ->
                        let {
                          sat_sgozr [Occ=Once] :: [Data.Fixed.Fixed a_agnJM]
                          [LclId] =
                              [go_sgozn x_sgozo] \u []
                                  case
                                      GHC.Integer.Type.plusInteger x_sgozo Data.Fixed.$fEnumFixed2
                                  of
                                  sat_sgozq
                                  { __DEFAULT -> go_sgozn sat_sgozq;
                                  };
                        } in  : [x_sgozo sat_sgozr];
                    1# -> [] [];
                  };
        } in  go_sgozn ds_sgozl;

Data.Fixed.$fEnumFixed_$cenumFromThen
  :: forall a.
     Data.Fixed.Fixed a -> Data.Fixed.Fixed a -> [Data.Fixed.Fixed a]
[GblId, Arity=2, Str=<S,U><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgozs ds1_sgozt]
        let {
          d_sgozu [Occ=OnceL] :: GHC.Integer.Type.Integer
          [LclId] =
              [ds_sgozs ds1_sgozt] \u []
                  GHC.Integer.Type.minusInteger ds1_sgozt ds_sgozs; } in
        let {
          go_sgozv [Occ=LoopBreaker]
            :: GHC.Integer.Type.Integer -> [Data.Fixed.Fixed a_agnJM]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [d_sgozu go_sgozv] \r [x_sgozw]
                  case x_sgozw of x1_sgozx {
                    __DEFAULT ->
                        let {
                          sat_sgozz [Occ=Once] :: [Data.Fixed.Fixed a_agnJM]
                          [LclId] =
                              [d_sgozu go_sgozv x1_sgozx] \u []
                                  case GHC.Integer.Type.plusInteger x1_sgozx d_sgozu of sat_sgozy {
                                    __DEFAULT -> go_sgozv sat_sgozy;
                                  };
                        } in  : [x1_sgozx sat_sgozz];
                  };
        } in  go_sgozv ds_sgozs;

Data.Fixed.$fEnumFixed3 [Occ=LoopBreaker]
  :: forall a. GHC.Integer.Type.Integer -> [Data.Fixed.Fixed a]
[GblId, Arity=1, Str=<S,1*U>m2, Unf=OtherCon []] =
    [] \r [x_sgozA]
        case x_sgozA of x1_sgozB {
          __DEFAULT ->
              let {
                sat_sgozD [Occ=Once] :: [Data.Fixed.Fixed a_agnJM]
                [LclId] =
                    [x1_sgozB] \u []
                        case
                            GHC.Integer.Type.plusInteger x1_sgozB Data.Fixed.$fEnumFixed2
                        of
                        sat_sgozC
                        { __DEFAULT -> Data.Fixed.$fEnumFixed3 sat_sgozC;
                        };
              } in  : [x1_sgozB sat_sgozD];
        };

Data.Fixed.$fEnumFixed_$cenumFrom
  :: forall a. Data.Fixed.Fixed a -> [Data.Fixed.Fixed a]
[GblId, Arity=1, Str=<S,1*U>m2, Unf=OtherCon []] =
    [] \r [ds_sgozE] Data.Fixed.$fEnumFixed3 ds_sgozE;

Data.Fixed.$fEnumFixed_$cfromEnum
  :: forall a. Data.Fixed.Fixed a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_sgozF] GHC.Enum.$fEnumInteger_$cfromEnum ds_sgozF;

Data.Fixed.$fEnumFixed4
  :: forall a. Data.Fixed.Fixed a -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgozG] GHC.Enum.$fEnumInteger_$cpred ds_sgozG;

Data.Fixed.$fEnumFixed5
  :: forall a. Data.Fixed.Fixed a -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgozH] GHC.Enum.$fEnumInteger_$csucc ds_sgozH;

Data.Fixed.$fEnumFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Enum.Enum (Data.Fixed.Fixed a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Enum.C:Enum! [Data.Fixed.$fEnumFixed5
                                    Data.Fixed.$fEnumFixed4
                                    GHC.Enum.$fEnumInteger_$ctoEnum
                                    Data.Fixed.$fEnumFixed_$cfromEnum
                                    Data.Fixed.$fEnumFixed_$cenumFrom
                                    Data.Fixed.$fEnumFixed_$cenumFromThen
                                    Data.Fixed.$fEnumFixed_$cenumFromTo
                                    Data.Fixed.$fEnumFixed_$cenumFromThenTo];

Data.Fixed.$fHasResolutionE0_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E0 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgozI] Data.Fixed.$fEnumFixed2;

Data.Fixed.$fHasResolutionE0 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E0
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE0_$cresolution eta_B1;

sat_sgozJ :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [10#];

sat_sgozK :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgozJ GHC.Types.[]];

Data.Fixed.$fHasResolutionE4 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgozK;

Data.Fixed.$fHasResolutionE1_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E1 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgozL] Data.Fixed.$fHasResolutionE4;

Data.Fixed.$fHasResolutionE1 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E1
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE1_$cresolution eta_B1;

sat_sgozM :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [100#];

sat_sgozN :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgozM GHC.Types.[]];

Data.Fixed.$fHasResolutionE7 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgozN;

Data.Fixed.$fHasResolutionE2_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E2 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgozO] Data.Fixed.$fHasResolutionE7;

Data.Fixed.$fHasResolutionE2 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E2
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE2_$cresolution eta_B1;

sat_sgozP :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1000#];

sat_sgozQ :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgozP GHC.Types.[]];

Data.Fixed.$fHasResolutionE8 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgozQ;

Data.Fixed.$fHasResolutionE3_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E3 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgozR] Data.Fixed.$fHasResolutionE8;

Data.Fixed.$fHasResolutionE3 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E3
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE3_$cresolution eta_B1;

sat_sgozS :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1000000#];

sat_sgozT :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgozS GHC.Types.[]];

Data.Fixed.$fHasResolutionE10 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgozT;

Data.Fixed.$fHasResolutionE6_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E6 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgozU] Data.Fixed.$fHasResolutionE10;

Data.Fixed.$fHasResolutionE6 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E6
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE6_$cresolution eta_B1;

sat_sgozV :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1000000000#];

sat_sgozW :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgozV GHC.Types.[]];

Data.Fixed.$fHasResolutionE11 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgozW;

Data.Fixed.$fHasResolutionE9_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E9 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgozX] Data.Fixed.$fHasResolutionE11;

Data.Fixed.$fHasResolutionE9 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E9
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE9_$cresolution eta_B1;

sat_sgozZ :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [465#];

sat_sgoA0 :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgozZ GHC.Types.[]];

sat_sgozY :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1420103680#];

sat_sgoA1 :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgozY sat_sgoA0];

Data.Fixed.$fHasResolutionE5 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgoA1;

Data.Fixed.$fHasResolutionE12_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E12 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgoA2] Data.Fixed.$fHasResolutionE5;

Data.Fixed.$fHasResolutionE12 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E12
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE12_$cresolution eta_B1;

Data.Fixed.$fDataFixed6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Fixed.Fixed"#;

Data.Fixed.$fDataFixed5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Fixed.$fDataFixed6;

w1_rgoyk :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "MkFixed"#;

w2_rgoyl :: GHC.Base.String
[GblId] =
    [] \u [] GHC.CString.unpackCString# w1_rgoyk;

go61_rgoym
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sgoA3 _ys_sgoA4]
        case ds2_sgoA3 of {
          [] -> GHC.List.badHead;
          : ipv_sgoA6 [Occ=Once!] ipv1_sgoA7 [Occ=Once] ->
              case _ys_sgoA4 of {
                [] -> GHC.List.badHead;
                : ipv2_sgoA9 [Occ=Once] ipv3_sgoAa [Occ=Once] ->
                    case ipv_sgoA6 of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sgoAd [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sgoAd w2_rgoyl of {
                            GHC.Types.False -> go61_rgoym ipv1_sgoA7 ipv3_sgoAa;
                            GHC.Types.True -> ipv2_sgoA9;
                          };
                    };
              };
        };

conMkFixed1_rgoyn :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [conMkFixed2_rgoyo];
Data.Fixed.$fDataFixed4 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Fixed.conMkFixed GHC.Types.[]];
Data.Fixed.$fDataFixed3 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Fixed.$fDataFixed4];
Data.Fixed.tyFixed :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Fixed.$fDataFixed5
                                       Data.Fixed.$fDataFixed3];
Data.Fixed.conMkFixed [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [conMkFixed1_rgoyn
                                     w2_rgoyl
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     Data.Fixed.tyFixed];
conMkFixed2_rgoyo :: Data.Data.ConIndex
[GblId] =
    [] \u [] go61_rgoym Data.Fixed.$fDataFixed4 Data.Data.mkConstr1;

Data.Fixed.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

loc_rgoyp :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Fixed.$trModule4;

Data.Fixed.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Fixed"#;

loc1_rgoyq :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Fixed.$trModule2;

loc2_rgoyr :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "./Data/Fixed.hs"#;

loc3_rgoys :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# loc2_rgoyr;

loc4_rgoyt :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [83#];

loc5_rgoyu :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [20#];

loc6_rgoyv :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [29#];

$dIP_rgoyw :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "undefined"#;

$dIP1_rgoyx :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# $dIP_rgoyw;

$dIP2_rgoyy :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [loc_rgoyp
                                           loc1_rgoyq
                                           loc3_rgoys
                                           loc4_rgoyt
                                           loc5_rgoyu
                                           loc4_rgoyt
                                           loc6_rgoyv];

$dIP3_rgoyz :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [$dIP1_rgoyx
                                                  $dIP2_rgoyy
                                                  GHC.Stack.Types.EmptyCallStack];

Data.Fixed.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$trModule4];

Data.Fixed.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$trModule2];

Data.Fixed.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Fixed.$trModule3
                                     Data.Fixed.$trModule1];

$krep_rgoyA :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Integer.Type.$tcInteger
                                              GHC.Types.[]];

$krep1_rgoyB :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Fixed.$tcHasResolution1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*
                                         $krep1_rgoyB];

$krep2_rgoyC :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

Data.Fixed.$fDataFixed10 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Fixed"#;

Data.Fixed.$fDataFixed9 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$fDataFixed10];

Data.Fixed.$tcFixed :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12850707307297787398##
                                    5875431371990069009##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$fDataFixed9
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep3_rgoyD :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rgoyC GHC.Types.[]];

$krep4_rgoyE :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Fixed.$tcFixed
                                              $krep3_rgoyD];

Data.Fixed.$tc'MkFixed1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgoyA $krep4_rgoyE];

Data.Fixed.$tc'MkFixed3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'MkFixed"#;

Data.Fixed.$tc'MkFixed2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tc'MkFixed3];

Data.Fixed.$tc'MkFixed :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8992689233320522225##
                                    9587721628087041380##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tc'MkFixed2
                                    1#
                                    Data.Fixed.$tc'MkFixed1];

Data.Fixed.$fDataFixed8
  :: Data.Typeable.Internal.TypeRep Data.Fixed.Fixed
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                12850707307297787398##
                5875431371990069009##
                Data.Fixed.$trModule
                Data.Fixed.$fDataFixed9
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sgoAj [Occ=Once]
                   ww9_sgoAk [Occ=Once]
                   ww10_sgoAl [Occ=Once]
                   ww11_sgoAm [Occ=Once]
                   ww12_sgoAn [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sgoAj
                                              ww9_sgoAk
                                              ww10_sgoAl
                                              ww11_sgoAm
                                              ww12_sgoAn];
        };

Data.Fixed.$fDataFixed7
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     Data.Typeable.Internal.TypeRep (Data.Fixed.Fixed a)
[GblId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
    [] \r [$dTypeable_sgoAo]
        Data.Typeable.Internal.mkTrApp
            Data.Fixed.$fDataFixed8 $dTypeable_sgoAo;

Data.Fixed.$fDataFixed1
  :: forall a.
     (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Fixed.$fDataFixed2 GHC.Types.False];

Data.Fixed.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall a (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgoAp w3_sgoAq w4_sgoAr]
        let {
          lvl17_sgoAs [Occ=OnceL] :: m_sgomN (Data.Fixed.Fixed a_sgomL)
          [LclId] =
              [w_sgoAp] \u [] GHC.Base.mzero w_sgoAp;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sgoAp
          of
          $dMonad_sgoAt [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgoAP [Occ=Once]
                    :: (Data.Fixed.Fixed a_sgomL, GHC.Types.Bool)
                       -> m_sgomN (Data.Fixed.Fixed a_sgomL)
                  [LclId] =
                      [lvl17_sgoAs $dMonad_sgoAt] \r [ds_sgoAK]
                          case ds_sgoAK of {
                            (,) x'_sgoAM [Occ=Once] b_sgoAN [Occ=Once!] ->
                                case b_sgoAN of {
                                  GHC.Types.False -> lvl17_sgoAs;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgoAt x'_sgoAM;
                                };
                          }; } in
                let {
                  sat_sgoAJ [Occ=Once]
                    :: m_sgomN (Data.Fixed.Fixed a_sgomL, GHC.Types.Bool)
                  [LclId] =
                      [w_sgoAp w3_sgoAq w4_sgoAr $dMonad_sgoAt] \u []
                          let {
                            lvl18_sgoAu [Occ=OnceL] :: m_sgomN GHC.Integer.Type.Integer
                            [LclId] =
                                [w3_sgoAq w4_sgoAr] \u []
                                    w3_sgoAq Data.Data.$fDataInteger w4_sgoAr; } in
                          let {
                            sat_sgoAI [Occ=Once]
                              :: (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomL,
                                  GHC.Types.Bool)
                                 -> m_sgomN (Data.Fixed.Fixed a_sgomL, GHC.Types.Bool)
                            [LclId] =
                                [w_sgoAp w4_sgoAr $dMonad_sgoAt lvl18_sgoAu] \r [ds1_sgoAw]
                                    case ds1_sgoAw of {
                                      (,) h_sgoAy b1_sgoAz [Occ=Once] ->
                                          let {
                                            sat_sgoAH [Occ=Once]
                                              :: m_sgomN (Data.Fixed.Fixed a_sgomL, GHC.Types.Bool)
                                            [LclId] =
                                                [w4_sgoAr $dMonad_sgoAt h_sgoAy b1_sgoAz] \u []
                                                    let {
                                                      sat_sgoAF [Occ=Once]
                                                        :: Data.Fixed.Fixed a_sgomL
                                                      [LclId] =
                                                          [w4_sgoAr h_sgoAy] \u []
                                                              h_sgoAy w4_sgoAr; } in
                                                    let {
                                                      sat_sgoAG [Occ=Once]
                                                        :: (Data.Fixed.Fixed a_sgomL,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sgoAF b1_sgoAz];
                                                    } in 
                                                      GHC.Base.return $dMonad_sgoAt sat_sgoAG; } in
                                          let {
                                            sat_sgoAE [Occ=Once]
                                              :: m_sgomN (Data.Fixed.Fixed a_sgomL, GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sgoAt lvl18_sgoAu h_sgoAy] \u []
                                                    let {
                                                      sat_sgoAD [Occ=Once]
                                                        :: GHC.Integer.Type.Integer
                                                           -> m_sgomN (Data.Fixed.Fixed a_sgomL,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sgoAt h_sgoAy] \r [y'_sgoAA]
                                                              let {
                                                                sat_sgoAB [Occ=Once]
                                                                  :: Data.Fixed.Fixed a_sgomL
                                                                [LclId] =
                                                                    [h_sgoAy y'_sgoAA] \u []
                                                                        h_sgoAy y'_sgoAA; } in
                                                              let {
                                                                sat_sgoAC [Occ=Once]
                                                                  :: (Data.Fixed.Fixed a_sgomL,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sgoAB
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sgoAt sat_sgoAC;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sgoAt lvl18_sgoAu sat_sgoAD;
                                          } in  GHC.Base.mplus w_sgoAp sat_sgoAE sat_sgoAH;
                                    }; } in
                          let {
                            sat_sgoAv [Occ=Once]
                              :: m_sgomN (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomL,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sgoAt] \u []
                                    GHC.Base.return $dMonad_sgoAt Data.Fixed.$fDataFixed1;
                          } in  GHC.Base.>>= $dMonad_sgoAt sat_sgoAv sat_sgoAI;
                } in  GHC.Base.>>= $dMonad_sgoAt sat_sgoAJ sat_sgoAP;
          };

Data.Fixed.$fDataFixed_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=4,
 Str=<L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgoAQ w3_sgoAR w4_sgoAS w5_sgoAT]
        Data.Fixed.$w$cgmapMp w3_sgoAR w4_sgoAS w5_sgoAT;

Data.Fixed.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=3,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgoAU w3_sgoAV w4_sgoAW]
        let {
          lvl17_sgoAX [Occ=OnceL] :: m_sgomU GHC.Integer.Type.Integer
          [LclId] =
              [w3_sgoAV w4_sgoAW] \u []
                  w3_sgoAV Data.Data.$fDataInteger w4_sgoAW; } in
        let {
          sat_sgoB3 [Occ=Once]
            :: (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomS)
               -> m_sgomU (Data.Fixed.Fixed a_sgomS)
          [LclId] =
              [w_sgoAU lvl17_sgoAX] \r [c'_sgoAZ]
                  let {
                    sat_sgoB2 [Occ=Once]
                      :: GHC.Integer.Type.Integer -> m_sgomU (Data.Fixed.Fixed a_sgomS)
                    [LclId] =
                        [w_sgoAU c'_sgoAZ] \r [x'_sgoB0]
                            let {
                              sat_sgoB1 [Occ=Once] :: Data.Fixed.Fixed a_sgomS
                              [LclId] =
                                  [c'_sgoAZ x'_sgoB0] \u [] c'_sgoAZ x'_sgoB0;
                            } in  GHC.Base.return w_sgoAU sat_sgoB1;
                  } in  GHC.Base.>>= w_sgoAU lvl17_sgoAX sat_sgoB2; } in
        let {
          sat_sgoAY [Occ=Once]
            :: m_sgomU (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomS)
          [LclId] =
              [w_sgoAU] \u [] GHC.Base.return w_sgoAU Data.Fixed.$fDataFixed2;
        } in  GHC.Base.>>= w_sgoAU sat_sgoAY sat_sgoB3;

Data.Fixed.$fDataFixed_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=4,
 Str=<L,A><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgoB4 w3_sgoB5 w4_sgoB6 w5_sgoB7]
        Data.Fixed.$w$cgmapM w3_sgoB5 w4_sgoB6 w5_sgoB7;

Data.Fixed.$fDataFixed_$cgmapQi
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Fixed.Fixed a
     -> u
[GblId,
 Arity=4,
 Str=<L,A><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sgoB8 ds_sgoB9 ds1_sgoBa x_sgoBb]
        case ds_sgoB9 of {
          GHC.Types.I# x1_sgoBd [Occ=Once!] ->
              case x1_sgoBd of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sgoBa Data.Data.$fDataInteger x_sgoBb;
              };
        };

Data.Fixed.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall a (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgoBf w3_sgoBg w4_sgoBh]
        let {
          lvl17_sgoBi [Occ=OnceL] :: m_sgon1 (Data.Fixed.Fixed a_sgomZ)
          [LclId] =
              [w_sgoBf] \u [] GHC.Base.mzero w_sgoBf;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sgoBf
          of
          $dMonad_sgoBj [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgoBI [Occ=Once]
                    :: (Data.Fixed.Fixed a_sgomZ, GHC.Types.Bool)
                       -> m_sgon1 (Data.Fixed.Fixed a_sgomZ)
                  [LclId] =
                      [lvl17_sgoBi $dMonad_sgoBj] \r [ds_sgoBD]
                          case ds_sgoBD of {
                            (,) x'_sgoBF [Occ=Once] b_sgoBG [Occ=Once!] ->
                                case b_sgoBG of {
                                  GHC.Types.False -> lvl17_sgoBi;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgoBj x'_sgoBF;
                                };
                          }; } in
                let {
                  sat_sgoBC [Occ=Once]
                    :: m_sgon1 (Data.Fixed.Fixed a_sgomZ, GHC.Types.Bool)
                  [LclId] =
                      [w_sgoBf w3_sgoBg w4_sgoBh $dMonad_sgoBj] \u []
                          let {
                            lvl18_sgoBk [Occ=OnceL] :: m_sgon1 GHC.Integer.Type.Integer
                            [LclId] =
                                [w3_sgoBg w4_sgoBh] \u []
                                    w3_sgoBg Data.Data.$fDataInteger w4_sgoBh; } in
                          let {
                            sat_sgoBB [Occ=Once]
                              :: (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomZ,
                                  GHC.Types.Bool)
                                 -> m_sgon1 (Data.Fixed.Fixed a_sgomZ, GHC.Types.Bool)
                            [LclId] =
                                [w_sgoBf w4_sgoBh $dMonad_sgoBj lvl18_sgoBk] \r [ds1_sgoBm]
                                    case ds1_sgoBm of {
                                      (,) h_sgoBo b1_sgoBp [Occ=Once!] ->
                                          case b1_sgoBp of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sgoBy [Occ=Once]
                                                    :: m_sgon1 (Data.Fixed.Fixed a_sgomZ,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [w4_sgoBh $dMonad_sgoBj h_sgoBo] \u []
                                                          let {
                                                            sat_sgoBw [Occ=Once]
                                                              :: Data.Fixed.Fixed a_sgomZ
                                                            [LclId] =
                                                                [w4_sgoBh h_sgoBo] \u []
                                                                    h_sgoBo w4_sgoBh; } in
                                                          let {
                                                            sat_sgoBx [Occ=Once]
                                                              :: (Data.Fixed.Fixed a_sgomZ,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sgoBw
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sgoBj sat_sgoBx; } in
                                                let {
                                                  sat_sgoBv [Occ=Once]
                                                    :: m_sgon1 (Data.Fixed.Fixed a_sgomZ,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sgoBj lvl18_sgoBk h_sgoBo] \u []
                                                          let {
                                                            sat_sgoBu [Occ=Once]
                                                              :: GHC.Integer.Type.Integer
                                                                 -> m_sgon1 (Data.Fixed.Fixed
                                                                               a_sgomZ,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sgoBj
                                                                 h_sgoBo] \r [y'_sgoBr]
                                                                    let {
                                                                      sat_sgoBs [Occ=Once]
                                                                        :: Data.Fixed.Fixed a_sgomZ
                                                                      [LclId] =
                                                                          [h_sgoBo y'_sgoBr] \u []
                                                                              h_sgoBo y'_sgoBr; } in
                                                                    let {
                                                                      sat_sgoBt [Occ=Once]
                                                                        :: (Data.Fixed.Fixed
                                                                              a_sgomZ,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sgoBs
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sgoBj sat_sgoBt;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sgoBj lvl18_sgoBk sat_sgoBu;
                                                } in  GHC.Base.mplus w_sgoBf sat_sgoBv sat_sgoBy;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sgoBz [Occ=Once] :: Data.Fixed.Fixed a_sgomZ
                                                  [LclId] =
                                                      [w4_sgoBh h_sgoBo] \u []
                                                          h_sgoBo w4_sgoBh; } in
                                                let {
                                                  sat_sgoBA [Occ=Once]
                                                    :: (Data.Fixed.Fixed a_sgomZ, GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sgoBz GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sgoBj sat_sgoBA;
                                          };
                                    }; } in
                          let {
                            sat_sgoBl [Occ=Once]
                              :: m_sgon1 (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomZ,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sgoBj] \u []
                                    GHC.Base.return $dMonad_sgoBj Data.Fixed.$fDataFixed1;
                          } in  GHC.Base.>>= $dMonad_sgoBj sat_sgoBl sat_sgoBB;
                } in  GHC.Base.>>= $dMonad_sgoBj sat_sgoBC sat_sgoBI;
          };

Data.Fixed.$fDataFixed_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=4,
 Str=<L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgoBJ w3_sgoBK w4_sgoBL w5_sgoBM]
        Data.Fixed.$w$cgmapMo w3_sgoBK w4_sgoBL w5_sgoBM;

lvl_rgoyF :: forall a. Data.Fixed.Fixed a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sgoBN] Data.Fixed.conMkFixed;

lvl1_rgoyG :: forall a. Data.Fixed.Fixed a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sgoBO] Data.Fixed.tyFixed;

lvl2_rgoyH
  :: forall a (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Fixed.Fixed a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sgoBP ds_sgoBQ] GHC.Base.Nothing [];

lvl3_rgoyI
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Fixed.Fixed a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sgoBR ds_sgoBS] GHC.Base.Nothing [];

lvl4_rgoyJ
  :: forall a.
     (forall b. Data.Data.Data b => b -> b)
     -> Data.Fixed.Fixed a -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<C(C(S)),1*C1(C1(U))><L,U>, Unf=OtherCon []] =
    [] \r [ds_sgoBT x0_sgoBU]
        ds_sgoBT Data.Data.$fDataInteger x0_sgoBU;

lvl5_rgoyK
  :: forall a r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Fixed.Fixed a
     -> r
[GblId,
 Arity=4,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgoBV ds1_sgoBW ds2_sgoBX eta_sgoBY]
        let {
          sat_sgoBZ [Occ=Once] :: r'_agnMw
          [LclId] =
              [ds2_sgoBX eta_sgoBY] \u []
                  ds2_sgoBX Data.Data.$fDataInteger eta_sgoBY;
        } in  ds_sgoBV ds1_sgoBW sat_sgoBZ;

lvl6_rgoyL
  :: forall a r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Fixed.Fixed a
     -> r
[GblId,
 Arity=4,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgoC0 ds1_sgoC1 ds2_sgoC2 x0_sgoC3]
        let {
          sat_sgoC4 [Occ=Once] :: r'_agnMN
          [LclId] =
              [ds2_sgoC2 x0_sgoC3] \u []
                  ds2_sgoC2 Data.Data.$fDataInteger x0_sgoC3;
        } in  ds_sgoC0 sat_sgoC4 ds1_sgoC1;

lvl7_rgoyM
  :: forall a u.
     (forall d. Data.Data.Data d => d -> u) -> Data.Fixed.Fixed a -> [u]
[GblId, Arity=2, Str=<L,1*C1(C1(U))><L,U>m2, Unf=OtherCon []] =
    [] \r [ds_sgoC5 x0_sgoC6]
        let {
          sat_sgoC7 [Occ=Once] :: u_agnN3
          [LclId] =
              [ds_sgoC5 x0_sgoC6] \u []
                  ds_sgoC5 Data.Data.$fDataInteger x0_sgoC6;
        } in  : [sat_sgoC7 GHC.Types.[]];

lvl8_rgoyN
  :: forall a (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c (Data.Fixed.Fixed a)
[GblId,
 Arity=3,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [k_sgoC8 z_sgoC9 ds_sgoCa]
        let {
          sat_sgoCb [Occ=Once]
            :: c_agnLl (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_XgnO4)
          [LclId] =
              [z_sgoC9] \u [] z_sgoC9 Data.Fixed.$fDataFixed2;
        } in  k_sgoC8 Data.Data.$fDataInteger sat_sgoCb;

Data.Fixed.$fDataFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     Data.Data.Data (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,U>] =
    [] \r [$dTypeable_sgoCc]
        let {
          sat_sgoCf [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Fixed.Fixed a_XgnO4
               -> u
          [LclId] =
              [$dTypeable_sgoCc] \r [eta_B3 eta_B2 eta_B1]
                  Data.Fixed.$fDataFixed_$cgmapQi
                      $dTypeable_sgoCc eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgoCe [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Fixed.Fixed a_XgnO4
               -> c (Data.Fixed.Fixed a_XgnO4)
          [LclId] =
              [$dTypeable_sgoCc] \r [eta_B3 eta_B2 eta_B1]
                  Data.Fixed.$fDataFixed_$cgfoldl
                      $dTypeable_sgoCc eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgoCd [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Fixed.Fixed a_XgnO4)
          [LclId] =
              [$dTypeable_sgoCc] \u [] Data.Fixed.$fDataFixed7 $dTypeable_sgoCc;
        } in 
          Data.Data.C:Data [sat_sgoCd
                            sat_sgoCe
                            lvl8_rgoyN
                            lvl_rgoyF
                            lvl1_rgoyG
                            lvl2_rgoyH
                            lvl3_rgoyI
                            lvl4_rgoyJ
                            lvl5_rgoyK
                            lvl6_rgoyL
                            lvl7_rgoyM
                            sat_sgoCf
                            Data.Fixed.$w$cgmapM
                            Data.Fixed.$w$cgmapMp
                            Data.Fixed.$w$cgmapMo];

Data.Fixed.$tcHasResolution3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "HasResolution"#;

Data.Fixed.$tcHasResolution2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcHasResolution3];

Data.Fixed.$tcHasResolution :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7410670074803796200##
                                    11622449620609036983##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcHasResolution2
                                    0#
                                    Data.Fixed.$tcHasResolution1];

Data.Fixed.$tcE5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E0"#;

Data.Fixed.$tcE4 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE5];

Data.Fixed.$tcE0 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1111589946053822622##
                                    14645449775626969178##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE4
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE8 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E1"#;

Data.Fixed.$tcE7 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE8];

Data.Fixed.$tcE1 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17242267792727872229##
                                    10571291330004494282##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE7
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE14 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E2"#;

Data.Fixed.$tcE13 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE14];

Data.Fixed.$tcE2 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [18184774527647329547##
                                    15895109557895358229##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE13
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE16 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E3"#;

Data.Fixed.$tcE15 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE16];

Data.Fixed.$tcE3 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2281297682271263739##
                                    13982938170987291273##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE15
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE18 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E6"#;

Data.Fixed.$tcE17 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE18];

Data.Fixed.$tcE6 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6430880657524859014##
                                    16351944333195325805##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE17
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE20 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E9"#;

Data.Fixed.$tcE19 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE20];

Data.Fixed.$tcE9 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8202840314884717291##
                                    5390706447224283764##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE19
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE11 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E12"#;

Data.Fixed.$tcE10 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE11];

Data.Fixed.$tcE12 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11177455628646877585##
                                    1804744900678580889##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE10
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.div'
  :: forall a b.
     (GHC.Real.Real a, GHC.Real.Integral b) =>
     a -> a -> b
[GblId,
 Arity=4,
 Str=<S(LLC(S(SS))),U(A,A,C(U(U,U)))><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dReal_sgoCg $dIntegral_sgoCh n_sgoCi d_sgoCj]
        case GHC.Real.toRational $dReal_sgoCg n_sgoCi of {
          GHC.Real.:% ww1_sgoCl [Occ=Once] ww2_sgoCm [Occ=Once] ->
              case GHC.Real.toRational $dReal_sgoCg d_sgoCj of {
                GHC.Real.:% ww4_sgoCo [Occ=Once] ww5_sgoCp [Occ=Once] ->
                    case GHC.Real.$w$s$c/ ww1_sgoCl ww2_sgoCm ww4_sgoCo ww5_sgoCp of {
                      (#,#) ww7_sgoCr [Occ=Once] ww8_sgoCs [Occ=Once] ->
                          GHC.Real.$w$s$cfloor $dIntegral_sgoCh ww7_sgoCr ww8_sgoCs;
                    };
              };
        };

Data.Fixed.$wdivMod' [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Real.Real a, GHC.Real.Integral b) =>
     a -> a -> (# b, a #)
[GblId,
 Arity=4,
 Str=<L,U(1*U(A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,1*C1(U)),A,C(U(U,U)))><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,1*C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgoCt w3_sgoCu w4_sgoCv w5_sgoCw]
        let {
          f_sgoCx :: b_sgond
          [LclId] =
              [w_sgoCt w3_sgoCu w4_sgoCv w5_sgoCw] \u []
                  Data.Fixed.div' w_sgoCt w3_sgoCu w4_sgoCv w5_sgoCw; } in
        let {
          sat_sgoCC [Occ=Once] :: a_sgonc
          [LclId] =
              [w_sgoCt w3_sgoCu w4_sgoCv w5_sgoCw f_sgoCx] \u []
                  case
                      GHC.Real.$p1Real w_sgoCt
                  of
                  $dNum_sgoCy [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,1*C1(U))>]
                  { __DEFAULT ->
                        let {
                          sat_sgoCB [Occ=Once] :: a_sgonc
                          [LclId] =
                              [w3_sgoCu w5_sgoCw f_sgoCx $dNum_sgoCy] \u []
                                  let {
                                    sat_sgoCA [Occ=Once] :: a_sgonc
                                    [LclId] =
                                        [w3_sgoCu f_sgoCx $dNum_sgoCy] \u []
                                            let {
                                              sat_sgoCz [Occ=Once] :: GHC.Integer.Type.Integer
                                              [LclId] =
                                                  [w3_sgoCu f_sgoCx] \u []
                                                      GHC.Real.toInteger w3_sgoCu f_sgoCx;
                                            } in  GHC.Num.fromInteger $dNum_sgoCy sat_sgoCz;
                                  } in  GHC.Num.* $dNum_sgoCy sat_sgoCA w5_sgoCw;
                        } in  GHC.Num.- $dNum_sgoCy w4_sgoCv sat_sgoCB;
                  };
        } in  (#,#) [f_sgoCx sat_sgoCC];

Data.Fixed.divMod' [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Real.Real a, GHC.Real.Integral b) =>
     a -> a -> (b, a)
[GblId,
 Arity=4,
 Str=<L,U(U(A,C(C1(U)),C(C1(U)),A,A,A,C(U)),A,C(U(U,U)))><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sgoCD w3_sgoCE w4_sgoCF w5_sgoCG]
        case Data.Fixed.$wdivMod' w_sgoCD w3_sgoCE w4_sgoCF w5_sgoCG of {
          (#,#) ww1_sgoCI [Occ=Once] ww2_sgoCJ [Occ=Once] ->
              (,) [ww1_sgoCI ww2_sgoCJ];
        };

Data.Fixed.mod' :: forall a. GHC.Real.Real a => a -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(LC(C(S))LLLLL)LL),U(1*U(A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,1*C1(U)),A,C(U(U,U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dReal_sgoCK eta_sgoCL eta1_sgoCM]
        case
            GHC.Real.$p1Real $dReal_sgoCK
        of
        $dNum_sgoCN [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,1*C1(U))>]
        { __DEFAULT ->
              let {
                sat_sgoCQ [Occ=Once] :: a_agnBF
                [LclId] =
                    [$dReal_sgoCK eta_sgoCL eta1_sgoCM $dNum_sgoCN] \u []
                        let {
                          sat_sgoCP [Occ=Once] :: a_agnBF
                          [LclId] =
                              [$dReal_sgoCK eta_sgoCL eta1_sgoCM $dNum_sgoCN] \u []
                                  let {
                                    sat_sgoCO [Occ=Once] :: GHC.Integer.Type.Integer
                                    [LclId] =
                                        [$dReal_sgoCK eta_sgoCL eta1_sgoCM] \u []
                                            Data.Fixed.div'
                                                $dReal_sgoCK
                                                GHC.Real.$fIntegralInteger
                                                eta_sgoCL
                                                eta1_sgoCM;
                                  } in  GHC.Num.fromInteger $dNum_sgoCN sat_sgoCO;
                        } in  GHC.Num.* $dNum_sgoCN sat_sgoCP eta1_sgoCM;
              } in  GHC.Num.- $dNum_sgoCN eta_sgoCL sat_sgoCQ;
        };

Data.Fixed.$fFractionalFixed2 :: forall a. GHC.Types.Any a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined $dIP3_rgoyz;

Data.Fixed.$w$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sgoCR ww_sgoCS ww1_sgoCT]
        case w_sgoCR Data.Fixed.$fFractionalFixed2 of dt_sgoCU {
          __DEFAULT ->
              case
                  GHC.Integer.Type.timesInteger ww1_sgoCT GHC.Real.$fEnumRatio1
              of
              sat_sgoCW
              { __DEFAULT ->
                    case GHC.Integer.Type.timesInteger ww_sgoCS dt_sgoCU of sat_sgoCV {
                      __DEFAULT ->
                          case GHC.Real.$w$sreduce sat_sgoCV sat_sgoCW of {
                            (#,#) ww7_sgoCY [Occ=Once] ww8_sgoCZ [Occ=Once] ->
                                GHC.Real.$w$s$cfloor
                                    GHC.Real.$fIntegralInteger ww7_sgoCY ww8_sgoCZ;
                          };
                    };
              };
        };

Data.Fixed.$fFractionalFixed1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Real.Rational -> GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<C(S),1*C1(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgoD0 w3_sgoD1]
        case w3_sgoD1 of {
          GHC.Real.:% ww1_sgoD3 [Occ=Once] ww2_sgoD4 [Occ=Once] ->
              Data.Fixed.$w$cfromRational w_sgoD0 ww1_sgoD3 ww2_sgoD4;
        };

Data.Fixed.$fRealFixed_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a -> GHC.Real.Rational
[GblId, Arity=2, Str=<C(S),1*C1(U)><S,U>m, Unf=OtherCon []] =
    [] \r [w_sgoD5 w3_sgoD6]
        case w_sgoD5 w3_sgoD6 of dt_sgoD7 {
          __DEFAULT ->
              case
                  GHC.Real.$w$s$c/
                      w3_sgoD6 GHC.Real.$fEnumRatio1 dt_sgoD7 GHC.Real.$fEnumRatio1
              of
              { (#,#) ww1_sgoD9 [Occ=Once] ww2_sgoDa [Occ=Once] ->
                    GHC.Real.:% [ww1_sgoD9 ww2_sgoDa];
              };
        };

Data.Fixed.$fFractionalFixed3
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a
     -> Data.Fixed.Fixed a -> GHC.Integer.Type.Integer
[GblId, Arity=3, Str=<C(S),1*C1(U)><S,U><S,U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoDb fa_sgoDc ds_sgoDd]
        case
            GHC.Integer.Type.eqInteger# ds_sgoDd Data.Fixed.$fEnumFixed1
        of
        { __DEFAULT ->
              case $dHasResolution_sgoDb fa_sgoDc of sat_sgoDf {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger fa_sgoDc sat_sgoDf
                    of
                    sat_sgoDg
                    { __DEFAULT -> GHC.Integer.Type.divInteger sat_sgoDg ds_sgoDd;
                    };
              };
          1# -> GHC.Real.divZeroError;
        };

Data.Fixed.$fFractionalFixed_$crecip
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a -> Data.Fixed.Fixed a
[GblId, Arity=2, Str=<C(S),1*C1(U)><S,U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoDh fa_sgoDi]
        case
            GHC.Integer.Type.eqInteger# fa_sgoDi Data.Fixed.$fEnumFixed1
        of
        { __DEFAULT ->
              case $dHasResolution_sgoDh fa_sgoDi of res_sgoDk [Dmd=<S,U>] {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger res_sgoDk res_sgoDk
                    of
                    sat_sgoDl
                    { __DEFAULT -> GHC.Integer.Type.divInteger sat_sgoDl fa_sgoDi;
                    };
              };
          1# -> GHC.Real.divZeroError;
        };

Data.Fixed.$fNumFixed_$c*
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a -> Data.Fixed.Fixed a -> Data.Fixed.Fixed a
[GblId, Arity=3, Str=<C(S),1*C1(U)><S,U><S,1*U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoDm fa_sgoDn ds_sgoDo]
        case $dHasResolution_sgoDm fa_sgoDn of ds1_sgoDp [Dmd=<S,U>] {
          __DEFAULT ->
              case
                  GHC.Integer.Type.eqInteger# ds1_sgoDp Data.Fixed.$fEnumFixed1
              of
              { __DEFAULT ->
                    case GHC.Integer.Type.timesInteger fa_sgoDn ds_sgoDo of sat_sgoDr {
                      __DEFAULT -> GHC.Integer.Type.divInteger sat_sgoDr ds1_sgoDp;
                    };
                1# -> GHC.Real.divZeroError;
              };
        };

Data.Fixed.$fNumFixed1
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<C(S),1*C1(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoDs i_sgoDt]
        case
            $dHasResolution_sgoDs Data.Fixed.$fFractionalFixed2
        of
        sat_sgoDu
        { __DEFAULT -> GHC.Integer.Type.timesInteger i_sgoDt sat_sgoDu;
        };

Data.Fixed.$fNumFixed2
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<C(S),1*C1(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoDv ds_sgoDw]
        case
            $dHasResolution_sgoDv Data.Fixed.$fFractionalFixed2
        of
        sat_sgoDy
        { __DEFAULT ->
              case GHC.Integer.Type.signumInteger ds_sgoDw of sat_sgoDx {
                __DEFAULT -> GHC.Integer.Type.timesInteger sat_sgoDx sat_sgoDy;
              };
        };

Data.Fixed.$fNumFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Num.Num (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgoDz]
        let {
          sat_sgoDC [Occ=Once]
            :: GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_XgnN5
          [LclId] =
              [$dHasResolution_sgoDz] \r [eta_B1]
                  Data.Fixed.$fNumFixed1 $dHasResolution_sgoDz eta_B1; } in
        let {
          sat_sgoDB [Occ=Once]
            :: Data.Fixed.Fixed a_XgnN5 -> Data.Fixed.Fixed a_XgnN5
          [LclId] =
              [$dHasResolution_sgoDz] \r [eta_B1]
                  Data.Fixed.$fNumFixed2 $dHasResolution_sgoDz eta_B1; } in
        let {
          sat_sgoDA [Occ=Once]
            :: Data.Fixed.Fixed a_XgnN5
               -> Data.Fixed.Fixed a_XgnN5 -> Data.Fixed.Fixed a_XgnN5
          [LclId] =
              [$dHasResolution_sgoDz] \r [eta_B2 eta_B1]
                  Data.Fixed.$fNumFixed_$c* $dHasResolution_sgoDz eta_B2 eta_B1;
        } in 
          GHC.Num.C:Num [GHC.Integer.Type.plusInteger
                         GHC.Integer.Type.minusInteger
                         sat_sgoDA
                         GHC.Integer.Type.negateInteger
                         GHC.Integer.Type.absInteger
                         sat_sgoDB
                         sat_sgoDC];

Data.Fixed.$fFractionalFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Real.Fractional (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgoDD]
        let {
          sat_sgoDH [Occ=Once]
            :: GHC.Real.Rational -> Data.Fixed.Fixed a_XgnLO
          [LclId] =
              [$dHasResolution_sgoDD] \r [eta_B1]
                  Data.Fixed.$fFractionalFixed1 $dHasResolution_sgoDD eta_B1; } in
        let {
          sat_sgoDG [Occ=Once]
            :: Data.Fixed.Fixed a_XgnLO -> Data.Fixed.Fixed a_XgnLO
          [LclId] =
              [$dHasResolution_sgoDD] \r [eta_B1]
                  Data.Fixed.$fFractionalFixed_$crecip
                      $dHasResolution_sgoDD eta_B1; } in
        let {
          sat_sgoDF [Occ=Once]
            :: Data.Fixed.Fixed a_XgnLO
               -> Data.Fixed.Fixed a_XgnLO -> Data.Fixed.Fixed a_XgnLO
          [LclId] =
              [$dHasResolution_sgoDD] \r [eta_B2 eta_B1]
                  Data.Fixed.$fFractionalFixed3
                      $dHasResolution_sgoDD eta_B2 eta_B1; } in
        let {
          sat_sgoDE [Occ=Once] :: GHC.Num.Num (Data.Fixed.Fixed a_XgnLO)
          [LclId] =
              [$dHasResolution_sgoDD] \u []
                  Data.Fixed.$fNumFixed $dHasResolution_sgoDD;
        } in 
          GHC.Real.C:Fractional [sat_sgoDE sat_sgoDF sat_sgoDG sat_sgoDH];

Data.Fixed.$fReadFixed2 :: GHC.Types.Double
[GblId] =
    [] \u []
        case logDouble# [10.0##] of v_sgoDI {
          __DEFAULT -> GHC.Types.D# [v_sgoDI];
        };

lvl9_rgoyO :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [172#];

lvl10_rgoyP :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [27#];

lvl11_rgoyQ :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [36#];

lvl12_rgoyR :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [loc_rgoyp
                                           loc1_rgoyq
                                           loc3_rgoys
                                           lvl9_rgoyO
                                           lvl10_rgoyP
                                           lvl9_rgoyO
                                           lvl11_rgoyQ];

lvl13_rgoyS :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [$dIP1_rgoyx
                                                  lvl12_rgoyR
                                                  GHC.Stack.Types.EmptyCallStack];

Data.Fixed.$fReadFixed3 :: forall a. Data.Fixed.Fixed a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined lvl13_rgoyS;

Data.Fixed.$fReadFixed1
  :: forall a.
     Data.Fixed.HasResolution a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Fixed.Fixed a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoDJ]
        let {
          lvl17_sgoDK :: GHC.Integer.Type.Integer
          [LclId] =
              [$dHasResolution_sgoDJ] \u []
                  $dHasResolution_sgoDJ Data.Fixed.$fFractionalFixed2; } in
        let {
          e_sgoDL :: GHC.Integer.Type.Integer
          [LclId] =
              [$dHasResolution_sgoDJ] \u []
                  case $dHasResolution_sgoDJ Data.Fixed.$fReadFixed3 of sat_sgoDM {
                    __DEFAULT ->
                        case GHC.Integer.Type.doubleFromInteger sat_sgoDM of wild_sgoDN {
                          __DEFAULT ->
                              case logDouble# [wild_sgoDN] of wild1_sgoDO {
                                __DEFAULT ->
                                    case Data.Fixed.$fReadFixed2 of {
                                      GHC.Types.D# v1_sgoDQ [Occ=Once] ->
                                          case /## [wild1_sgoDO v1_sgoDQ] of wild4_sgoDR {
                                            __DEFAULT ->
                                                case negateDouble# [wild4_sgoDR] of sat_sgoDS {
                                                  __DEFAULT ->
                                                      case
                                                          GHC.Integer.Type.decodeDoubleInteger
                                                              sat_sgoDS
                                                      of
                                                      { (#,#) ipv_sgoDU [Occ=Once*] ipv1_sgoDV ->
                                                            case <# [ipv1_sgoDV 0#] of {
                                                              __DEFAULT ->
                                                                  case
                                                                      GHC.Integer.Type.shiftLInteger
                                                                          ipv_sgoDU ipv1_sgoDV
                                                                  of
                                                                  sat_sgoDX
                                                                  { __DEFAULT ->
                                                                        GHC.Integer.Type.negateInteger
                                                                            sat_sgoDX;
                                                                  };
                                                              1# ->
                                                                  case
                                                                      negateInt# [ipv1_sgoDV]
                                                                  of
                                                                  s_sgoDY [Dmd=<S,U>]
                                                                  { __DEFAULT ->
                                                                        case ># [s_sgoDY 52#] of {
                                                                          __DEFAULT ->
                                                                              case
                                                                                  GHC.Integer.Type.integerToInt
                                                                                      ipv_sgoDU
                                                                              of
                                                                              n_sgoE0
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        uncheckedIShiftRA# [n_sgoE0
                                                                                                            s_sgoDY]
                                                                                    of
                                                                                    sat_sgoE1
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              GHC.Integer.Type.smallInteger
                                                                                                  sat_sgoE1
                                                                                          of
                                                                                          sat_sgoE2
                                                                                          { __DEFAULT ->
                                                                                                GHC.Integer.Type.negateInteger
                                                                                                    sat_sgoE2;
                                                                                          };
                                                                                    };
                                                                              };
                                                                          1# ->
                                                                              case
                                                                                  GHC.Integer.Type.ltInteger#
                                                                                      ipv_sgoDU
                                                                                      Data.Fixed.$fEnumFixed1
                                                                              of
                                                                              { __DEFAULT ->
                                                                                    Data.Fixed.$fEnumFixed1;
                                                                                1# ->
                                                                                    Data.Fixed.$fEnumFixed2;
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                        };
                  }; } in
        let {
          lvl18_sgoE4 [Occ=OnceL] :: Data.Fixed.Fixed a_agnFb
          [LclId] =
              [$dHasResolution_sgoDJ e_sgoDL] \u []
                  let {
                    sat_sgoE7 [Occ=Once] :: Data.Fixed.Fixed a_agnFb
                    [LclId] =
                        [$dHasResolution_sgoDJ] \u []
                            case
                                $dHasResolution_sgoDJ Data.Fixed.$fFractionalFixed2
                            of
                            sat_sgoE6
                            { __DEFAULT ->
                                  GHC.Integer.Type.timesInteger
                                      Data.Fixed.$fHasResolutionE4 sat_sgoE6;
                            }; } in
                  let {
                    sat_sgoE5 [Occ=Once, Dmd=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))>]
                      :: GHC.Num.Num (Data.Fixed.Fixed a_agnFb)
                    [LclId] =
                        [$dHasResolution_sgoDJ] \u []
                            Data.Fixed.$fNumFixed $dHasResolution_sgoDJ;
                  } in 
                    GHC.Real.^
                        sat_sgoE5 GHC.Real.$fIntegralInteger sat_sgoE7 e_sgoDL; } in
        let {
          sat_sgoEo [Occ=Once]
            :: Text.Read.Lex.Lexeme
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Fixed.Fixed a_agnFb)
          [LclId] =
              [$dHasResolution_sgoDJ
               lvl17_sgoDK
               e_sgoDL
               lvl18_sgoE4] \r [ds_sgoE9]
                  case ds_sgoE9 of {
                    __DEFAULT ->
                        Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4;
                    Text.Read.Lex.Number n_sgoEb [Occ=Once] ->
                        case Text.Read.Lex.numberToFixed e_sgoDL n_sgoEb of {
                          GHC.Base.Nothing ->
                              Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4;
                          GHC.Base.Just ds1_sgoEd [Occ=Once!] ->
                              case ds1_sgoEd of {
                                (,) i_sgoEf [Occ=Once] f_sgoEg [Occ=Once] ->
                                    let {
                                      x_sgoEh [Occ=OnceL] :: GHC.Integer.Type.Integer
                                      [LclId] =
                                          [$dHasResolution_sgoDJ
                                           lvl17_sgoDK
                                           lvl18_sgoE4
                                           i_sgoEf
                                           f_sgoEg] \u []
                                              case
                                                  GHC.Integer.Type.timesInteger f_sgoEg lvl17_sgoDK
                                              of
                                              sat_sgoEj
                                              { __DEFAULT ->
                                                    case
                                                        Data.Fixed.$fFractionalFixed3
                                                            $dHasResolution_sgoDJ
                                                            sat_sgoEj
                                                            lvl18_sgoE4
                                                    of
                                                    sat_sgoEk
                                                    { __DEFAULT ->
                                                          case
                                                              GHC.Integer.Type.timesInteger
                                                                  i_sgoEf lvl17_sgoDK
                                                          of
                                                          sat_sgoEi
                                                          { __DEFAULT ->
                                                                GHC.Integer.Type.plusInteger
                                                                    sat_sgoEi sat_sgoEk;
                                                          };
                                                    };
                                              }; } in
                                    let {
                                      sat_sgoEn [Occ=Once]
                                        :: Text.ParserCombinators.ReadPrec.Prec
                                           -> forall b.
                                              (Data.Fixed.Fixed a_agnFb
                                               -> Text.ParserCombinators.ReadP.P b)
                                              -> Text.ParserCombinators.ReadP.P b
                                      [LclId] =
                                          [x_sgoEh] \r [ds2_sgoEl k_sgoEm] k_sgoEm x_sgoEh;
                                    } in  sat_sgoEn;
                              };
                        };
                  }; } in
        let {
          sat_sgoE8 [Occ=Once] :: GHC.Num.Num (Data.Fixed.Fixed a_agnFb)
          [LclId] =
              [$dHasResolution_sgoDJ] \u []
                  Data.Fixed.$fNumFixed $dHasResolution_sgoDJ;
        } in  GHC.Read.readNumber1 sat_sgoE8 sat_sgoEo;

Data.Fixed.$fReadFixed_$creadsPrec
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Fixed.Fixed a)
[GblId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoEp]
        let {
          ds_sgoEq [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Fixed.Fixed a_XgnJE -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dHasResolution_sgoEp] \u []
                  Data.Fixed.$fReadFixed1 $dHasResolution_sgoEp; } in
        let {
          sat_sgoEt [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Fixed.Fixed a_XgnJE)
          [LclId] =
              [ds_sgoEq] \r [n_sgoEr]
                  let {
                    sat_sgoEs [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (Data.Fixed.Fixed a_XgnJE)
                    [LclId] =
                        [ds_sgoEq n_sgoEr] \u []
                            ds_sgoEq
                                n_sgoEr Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sgoEs;
        } in  sat_sgoEt;

Data.Fixed.$fReadFixed_$creadListPrec
  :: forall a.
     Data.Fixed.HasResolution a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Fixed.Fixed a]
[GblId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoEu]
        let {
          sat_sgoEv [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Fixed.Fixed a_XgnJC)
          [LclId] =
              [$dHasResolution_sgoEu] \s []
                  Data.Fixed.$fReadFixed1 $dHasResolution_sgoEu;
        } in  GHC.Read.list sat_sgoEv;

Data.Fixed.$fReadFixed_$creadList
  :: forall a.
     Data.Fixed.HasResolution a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Fixed.Fixed a]
[GblId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoEw]
        let {
          sat_sgoEy [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Fixed.Fixed a_XgnJD]
          [LclId] =
              [$dHasResolution_sgoEw] \u []
                  let {
                    sat_sgoEx [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Fixed.Fixed a_XgnJD)
                    [LclId] =
                        [$dHasResolution_sgoEw] \s []
                            Data.Fixed.$fReadFixed1 $dHasResolution_sgoEw;
                  } in 
                    GHC.Read.list
                        sat_sgoEx
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sgoEy;

Data.Fixed.$fReadFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Read.Read (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgoEz]
        let {
          sat_sgoED [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Fixed.Fixed a_XgnJB]
          [LclId] =
              [$dHasResolution_sgoEz] \u []
                  Data.Fixed.$fReadFixed_$creadListPrec $dHasResolution_sgoEz; } in
        let {
          sat_sgoEC [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Fixed.Fixed a_XgnJB)
          [LclId] =
              [$dHasResolution_sgoEz] \u []
                  Data.Fixed.$fReadFixed1 $dHasResolution_sgoEz; } in
        let {
          sat_sgoEB [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Fixed.Fixed a_XgnJB]
          [LclId] =
              [$dHasResolution_sgoEz] \u []
                  Data.Fixed.$fReadFixed_$creadList $dHasResolution_sgoEz; } in
        let {
          sat_sgoEA [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Fixed.Fixed a_XgnJB)
          [LclId] =
              [$dHasResolution_sgoEz] \u []
                  Data.Fixed.$fReadFixed_$creadsPrec $dHasResolution_sgoEz;
        } in  GHC.Read.C:Read [sat_sgoEA sat_sgoEB sat_sgoEC sat_sgoED];

Data.Fixed.$fEqFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Classes.Eq (Data.Fixed.Fixed a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [GHC.Integer.Type.eqInteger
                                     GHC.Integer.Type.neqInteger];

Data.Fixed.$fOrdFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Classes.Ord (Data.Fixed.Fixed a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Fixed.$fEqFixed
                                      GHC.Integer.Type.compareInteger
                                      GHC.Integer.Type.ltInteger
                                      GHC.Integer.Type.leInteger
                                      GHC.Integer.Type.gtInteger
                                      GHC.Integer.Type.geInteger
                                      GHC.Integer.Type.$fOrdInteger_$cmax
                                      GHC.Integer.Type.$fOrdInteger_$cmin];

Data.Fixed.$fRealFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Real.Real (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgoEE]
        let {
          sat_sgoEG [Occ=Once]
            :: Data.Fixed.Fixed a_agnIn -> GHC.Real.Rational
          [LclId] =
              [$dHasResolution_sgoEE] \r [eta_B1]
                  Data.Fixed.$fRealFixed_$ctoRational
                      $dHasResolution_sgoEE eta_B1; } in
        let {
          sat_sgoEF [Occ=Once] :: GHC.Num.Num (Data.Fixed.Fixed a_agnIn)
          [LclId] =
              [$dHasResolution_sgoEE] \u []
                  Data.Fixed.$fNumFixed $dHasResolution_sgoEE;
        } in  GHC.Real.C:Real [sat_sgoEF Data.Fixed.$fOrdFixed sat_sgoEG];

Data.Fixed.$fRealFracFixed_$ctruncate
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b. GHC.Real.Integral b => Data.Fixed.Fixed a -> b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoEH $dIntegral_sgoEI f_sgoEJ]
        case $dHasResolution_sgoEH f_sgoEJ of dt_sgoEK {
          __DEFAULT ->
              case
                  GHC.Real.$w$s$c/
                      f_sgoEJ GHC.Real.$fEnumRatio1 dt_sgoEK GHC.Real.$fEnumRatio1
              of
              { (#,#) ww7_sgoEM [Occ=Once] ww8_sgoEN ->
                    let {
                      sat_sgoEV [Occ=Once] :: GHC.Integer.Type.Integer
                      [LclId] =
                          [ww7_sgoEM ww8_sgoEN] \u []
                              case
                                  GHC.Integer.Type.eqInteger# ww8_sgoEN Data.Fixed.$fEnumFixed1
                              of
                              { __DEFAULT ->
                                    case GHC.Integer.Type.quotRemInteger ww7_sgoEM ww8_sgoEN of {
                                      (#,#) ipv_sgoES [Occ=Once] _ [Occ=Dead] -> ipv_sgoES;
                                    };
                                1# -> GHC.Real.divZeroError;
                              };
                    } in 
                      case GHC.Real.$p1Integral $dIntegral_sgoEI of sat_sgoEO {
                        __DEFAULT ->
                            case GHC.Real.$p1Real sat_sgoEO of sat_sgoEP {
                              __DEFAULT -> GHC.Num.fromInteger sat_sgoEP sat_sgoEV;
                            };
                      };
              };
        };

Data.Fixed.$fRealFracFixed_$cround
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b. GHC.Real.Integral b => Data.Fixed.Fixed a -> b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,U(U(U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoEW $dIntegral_sgoEX f_sgoEY]
        case $dHasResolution_sgoEW f_sgoEY of dt_sgoEZ {
          __DEFAULT ->
              case
                  GHC.Real.$w$s$c/
                      f_sgoEY GHC.Real.$fEnumRatio1 dt_sgoEZ GHC.Real.$fEnumRatio1
              of
              { (#,#) ww7_sgoF1 [Occ=Once] ww8_sgoF2 [Occ=Once] ->
                    GHC.Real.$w$s$cround $dIntegral_sgoEX ww7_sgoF1 ww8_sgoF2;
              };
        };

Data.Fixed.$fRealFracFixed_$cceiling
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b. GHC.Real.Integral b => Data.Fixed.Fixed a -> b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,U(U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoF3 $dIntegral_sgoF4 f_sgoF5]
        case $dHasResolution_sgoF3 f_sgoF5 of dt_sgoF6 {
          __DEFAULT ->
              case
                  GHC.Real.$w$s$c/
                      f_sgoF5 GHC.Real.$fEnumRatio1 dt_sgoF6 GHC.Real.$fEnumRatio1
              of
              { (#,#) ww7_sgoF8 [Occ=Once] ww8_sgoF9 [Occ=Once] ->
                    GHC.Real.$w$s$cceiling $dIntegral_sgoF4 ww7_sgoF8 ww8_sgoF9;
              };
        };

Data.Fixed.$fRealFracFixed_$cfloor
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b. GHC.Real.Integral b => Data.Fixed.Fixed a -> b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoFa $dIntegral_sgoFb f_sgoFc]
        case $dHasResolution_sgoFa f_sgoFc of dt_sgoFd {
          __DEFAULT ->
              case
                  GHC.Real.$w$s$c/
                      f_sgoFc GHC.Real.$fEnumRatio1 dt_sgoFd GHC.Real.$fEnumRatio1
              of
              { (#,#) ww7_sgoFf [Occ=Once] ww8_sgoFg [Occ=Once] ->
                    GHC.Real.$w$s$cfloor $dIntegral_sgoFb ww7_sgoFf ww8_sgoFg;
              };
        };

Data.Fixed.$w$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b.
     GHC.Real.Integral b =>
     Data.Fixed.Fixed a -> (# b, Data.Fixed.Fixed a #)
[GblId,
 Arity=3,
 Str=<L,C(U)><L,U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgoFh w3_sgoFi w4_sgoFj]
        let {
          i_sgoFk :: b_sgooh
          [LclId] =
              [w_sgoFh w3_sgoFi w4_sgoFj] \u []
                  Data.Fixed.$fRealFracFixed_$ctruncate
                      w_sgoFh w3_sgoFi w4_sgoFj; } in
        let {
          sat_sgoFo [Occ=Once] :: Data.Fixed.Fixed a_sgoof
          [LclId] =
              [w_sgoFh w3_sgoFi w4_sgoFj i_sgoFk] \u []
                  case w_sgoFh Data.Fixed.$fFractionalFixed2 of sat_sgoFm {
                    __DEFAULT ->
                        case GHC.Real.toInteger w3_sgoFi i_sgoFk of sat_sgoFl {
                          __DEFAULT ->
                              case
                                  GHC.Integer.Type.timesInteger sat_sgoFl sat_sgoFm
                              of
                              sat_sgoFn
                              { __DEFAULT -> GHC.Integer.Type.minusInteger w4_sgoFj sat_sgoFn;
                              };
                        };
                  };
        } in  (#,#) [i_sgoFk sat_sgoFo];

Data.Fixed.$fRealFracFixed_$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b.
     GHC.Real.Integral b =>
     Data.Fixed.Fixed a -> (b, Data.Fixed.Fixed a)
[GblId,
 Arity=3,
 Str=<L,C(U)><L,U(U(U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sgoFp w3_sgoFq w4_sgoFr]
        case Data.Fixed.$w$cproperFraction w_sgoFp w3_sgoFq w4_sgoFr of {
          (#,#) ww1_sgoFt [Occ=Once] ww2_sgoFu [Occ=Once] ->
              (,) [ww1_sgoFt ww2_sgoFu];
        };

Data.Fixed.$fRealFracFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Real.RealFrac (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgoFv]
        let {
          sat_sgoFC [Occ=Once]
            :: forall b. GHC.Real.Integral b => Data.Fixed.Fixed a_agnG0 -> b
          [LclId] =
              [$dHasResolution_sgoFv] \r [eta_B2 eta_B1]
                  Data.Fixed.$fRealFracFixed_$cfloor
                      $dHasResolution_sgoFv eta_B2 eta_B1; } in
        let {
          sat_sgoFB [Occ=Once]
            :: forall b. GHC.Real.Integral b => Data.Fixed.Fixed a_agnG0 -> b
          [LclId] =
              [$dHasResolution_sgoFv] \r [eta_B2 eta_B1]
                  Data.Fixed.$fRealFracFixed_$cceiling
                      $dHasResolution_sgoFv eta_B2 eta_B1; } in
        let {
          sat_sgoFA [Occ=Once]
            :: forall b. GHC.Real.Integral b => Data.Fixed.Fixed a_agnG0 -> b
          [LclId] =
              [$dHasResolution_sgoFv] \r [eta_B2 eta_B1]
                  Data.Fixed.$fRealFracFixed_$cround
                      $dHasResolution_sgoFv eta_B2 eta_B1; } in
        let {
          sat_sgoFz [Occ=Once]
            :: forall b. GHC.Real.Integral b => Data.Fixed.Fixed a_agnG0 -> b
          [LclId] =
              [$dHasResolution_sgoFv] \r [eta_B2 eta_B1]
                  Data.Fixed.$fRealFracFixed_$ctruncate
                      $dHasResolution_sgoFv eta_B2 eta_B1; } in
        let {
          sat_sgoFy [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Fixed.Fixed a_agnG0 -> (b, Data.Fixed.Fixed a_agnG0)
          [LclId] =
              [$dHasResolution_sgoFv] \r [eta_B2 eta_B1]
                  Data.Fixed.$fRealFracFixed_$cproperFraction
                      $dHasResolution_sgoFv eta_B2 eta_B1; } in
        let {
          sat_sgoFx [Occ=Once]
            :: GHC.Real.Fractional (Data.Fixed.Fixed a_agnG0)
          [LclId] =
              [$dHasResolution_sgoFv] \u []
                  Data.Fixed.$fFractionalFixed $dHasResolution_sgoFv; } in
        let {
          sat_sgoFw [Occ=Once] :: GHC.Real.Real (Data.Fixed.Fixed a_agnG0)
          [LclId] =
              [$dHasResolution_sgoFv] \u []
                  Data.Fixed.$fRealFixed $dHasResolution_sgoFv;
        } in 
          GHC.Real.C:RealFrac [sat_sgoFw
                               sat_sgoFx
                               sat_sgoFy
                               sat_sgoFz
                               sat_sgoFA
                               sat_sgoFB
                               sat_sgoFC];

chopZeros_rgnn4 :: GHC.Integer.Type.Integer -> GHC.Base.String
[GblId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
    sat-only [] \r [ds_sgoFD]
        case
            GHC.Integer.Type.eqInteger# ds_sgoFD Data.Fixed.$fEnumFixed1
        of
        { __DEFAULT ->
              case
                  GHC.Integer.Type.modInteger ds_sgoFD Data.Fixed.$fHasResolutionE4
              of
              sat_sgoFF
              { __DEFAULT ->
                    case
                        GHC.Integer.Type.eqInteger# sat_sgoFF Data.Fixed.$fEnumFixed1
                    of
                    { __DEFAULT -> GHC.Show.$fShowInteger_$cshow ds_sgoFD;
                      1# ->
                          case
                              GHC.Integer.Type.divInteger ds_sgoFD Data.Fixed.$fHasResolutionE4
                          of
                          sat_sgoFH
                          { __DEFAULT -> chopZeros_rgnn4 sat_sgoFH;
                          };
                    };
              };
          1# -> [] [];
        };

lvl14_rgoyT :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! ['0'#];

lvl15_rgoyU :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! ['.'#];

lvl16_rgoyV :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "-"#;

Data.Fixed.showFixed [Occ=LoopBreaker]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Types.Bool -> Data.Fixed.Fixed a -> GHC.Base.String
[GblId, Arity=3, Str=<L,1*C1(U)><L,U><S,U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoFI chopTrailingZeros_sgoFJ fa_sgoFK]
        case
            GHC.Integer.Type.ltInteger# fa_sgoFK Data.Fixed.$fEnumFixed1
        of
        { __DEFAULT ->
              case $dHasResolution_sgoFI fa_sgoFK of res_sgoFM [Dmd=<S,U>] {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.eqInteger# res_sgoFM Data.Fixed.$fEnumFixed1
                    of
                    { __DEFAULT ->
                          case GHC.Integer.Type.divModInteger fa_sgoFK res_sgoFM of {
                            (#,#) ipv_sgoFP [Occ=Once] ipv1_sgoFQ [Occ=Once*] ->
                                case GHC.Show.$w$cshowsPrec4 0# ipv_sgoFP GHC.Types.[] of {
                                  (#,#) ww3_sgoFS [Occ=Once] ww4_sgoFT [Occ=Once] ->
                                      let {
                                        sat_sgoGK [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                        [LclId] =
                                            [chopTrailingZeros_sgoFJ res_sgoFM ipv1_sgoFQ] \s []
                                                case
                                                    GHC.Integer.Type.doubleFromInteger res_sgoFM
                                                of
                                                wild2_sgoFV
                                                { __DEFAULT ->
                                                      case logDouble# [wild2_sgoFV] of wild3_sgoFW {
                                                        __DEFAULT ->
                                                            case Data.Fixed.$fReadFixed2 of {
                                                              GHC.Types.D# v1_sgoFY [Occ=Once] ->
                                                                  case
                                                                      /## [wild3_sgoFW v1_sgoFY]
                                                                  of
                                                                  wild4_sgoFZ
                                                                  { __DEFAULT ->
                                                                        case
                                                                            double2Int# [wild4_sgoFZ]
                                                                        of
                                                                        n_sgoG0 [Dmd=<S,U>]
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  int2Double# [n_sgoG0]
                                                                              of
                                                                              sat_sgoGH
                                                                              { __DEFAULT ->
                                                                                    let-no-escape {
                                                                                      $j_sgoG1 [Occ=Once*!T[1],
                                                                                                Dmd=<C(S),1*C1(U)>]
                                                                                        :: GHC.Prim.Int#
                                                                                           -> [GHC.Types.Char]
                                                                                      [LclId[JoinId(1)],
                                                                                       Arity=1,
                                                                                       Str=<S,U>,
                                                                                       Unf=OtherCon []] =
                                                                                          sat-only [chopTrailingZeros_sgoFJ
                                                                                                    res_sgoFM
                                                                                                    ipv1_sgoFQ] \r [ww_sgoG2]
                                                                                              case
                                                                                                  <# [ww_sgoG2
                                                                                                      0#]
                                                                                              of
                                                                                              { __DEFAULT ->
                                                                                                    let-no-escape {
                                                                                                      $j1_sgoG4 [Occ=Once*!T[1],
                                                                                                                 Dmd=<C(S),1*C1(U)>]
                                                                                                        :: GHC.Integer.Type.Integer
                                                                                                           -> [GHC.Types.Char]
                                                                                                      [LclId[JoinId(1)],
                                                                                                       Arity=1,
                                                                                                       Str=<S,U>,
                                                                                                       Unf=OtherCon []] =
                                                                                                          sat-only [chopTrailingZeros_sgoFJ
                                                                                                                    ww_sgoG2] \r [ds_sgoG5]
                                                                                                              let-no-escape {
                                                                                                                fail_sgoG6 [Occ=Once*!T[1],
                                                                                                                            Dmd=<L,1*C1(U)>]
                                                                                                                  :: GHC.Prim.Void#
                                                                                                                     -> [GHC.Types.Char]
                                                                                                                [LclId[JoinId(1)],
                                                                                                                 Arity=1,
                                                                                                                 Str=<L,A>,
                                                                                                                 Unf=OtherCon []] =
                                                                                                                    sat-only [chopTrailingZeros_sgoFJ
                                                                                                                              ww_sgoG2
                                                                                                                              ds_sgoG5] \r [void_0E]
                                                                                                                        case
                                                                                                                            GHC.Show.$w$cshowsPrec4
                                                                                                                                0#
                                                                                                                                ds_sgoG5
                                                                                                                                GHC.Types.[]
                                                                                                                        of
                                                                                                                        { (#,#) ww5_sgoG9 [Occ=OnceL]
                                                                                                                                ww6_sgoGa [Occ=OnceL] ->
                                                                                                                              let {
                                                                                                                                s_sgoGb [Dmd=<S,U>]
                                                                                                                                  :: GHC.Base.String
                                                                                                                                [LclId,
                                                                                                                                 Unf=OtherCon []] =
                                                                                                                                    CCCS :! [ww5_sgoG9
                                                                                                                                             ww6_sgoGa];
                                                                                                                              } in 
                                                                                                                                case
                                                                                                                                    GHC.List.$wlenAcc
                                                                                                                                        s_sgoGb
                                                                                                                                        0#
                                                                                                                                of
                                                                                                                                ww7_sgoGc
                                                                                                                                { __DEFAULT ->
                                                                                                                                      case
                                                                                                                                          -# [ww_sgoG2
                                                                                                                                              ww7_sgoGc]
                                                                                                                                      of
                                                                                                                                      y_sgoGd [Dmd=<S,U>]
                                                                                                                                      { __DEFAULT ->
                                                                                                                                            case
                                                                                                                                                <# [0#
                                                                                                                                                    y_sgoGd]
                                                                                                                                            of
                                                                                                                                            { __DEFAULT ->
                                                                                                                                                  case
                                                                                                                                                      chopTrailingZeros_sgoFJ
                                                                                                                                                  of
                                                                                                                                                  { GHC.Types.False ->
                                                                                                                                                        : [lvl15_rgoyU
                                                                                                                                                           s_sgoGb];
                                                                                                                                                    GHC.Types.True ->
                                                                                                                                                        case
                                                                                                                                                            chopZeros_rgnn4
                                                                                                                                                                ds_sgoG5
                                                                                                                                                        of
                                                                                                                                                        wild6_sgoGg
                                                                                                                                                        { [] ->
                                                                                                                                                              [] [];
                                                                                                                                                          : _ [Occ=Dead]
                                                                                                                                                            _ [Occ=Dead] ->
                                                                                                                                                              : [lvl15_rgoyU
                                                                                                                                                                 wild6_sgoGg];
                                                                                                                                                        };
                                                                                                                                                  };
                                                                                                                                              1# ->
                                                                                                                                                  let {
                                                                                                                                                    n1_sgoGj [Occ=OnceL]
                                                                                                                                                      :: [GHC.Types.Char]
                                                                                                                                                    [LclId] =
                                                                                                                                                        [chopTrailingZeros_sgoFJ
                                                                                                                                                         ds_sgoG5
                                                                                                                                                         s_sgoGb] \u []
                                                                                                                                                            case
                                                                                                                                                                chopTrailingZeros_sgoFJ
                                                                                                                                                            of
                                                                                                                                                            { GHC.Types.False ->
                                                                                                                                                                  s_sgoGb;
                                                                                                                                                              GHC.Types.True ->
                                                                                                                                                                  chopZeros_rgnn4
                                                                                                                                                                      ds_sgoG5;
                                                                                                                                                            }; } in
                                                                                                                                                  let {
                                                                                                                                                    lvl17_sgoGl [Occ=OnceL]
                                                                                                                                                      :: [GHC.Types.Char]
                                                                                                                                                    [LclId,
                                                                                                                                                     Unf=OtherCon []] =
                                                                                                                                                        CCCS :! [lvl14_rgoyT
                                                                                                                                                                 n1_sgoGj]; } in
                                                                                                                                                  let {
                                                                                                                                                    $wxs_sgoGm [InlPrag=NOUSERINLINE[0],
                                                                                                                                                                Occ=LoopBreaker]
                                                                                                                                                      :: GHC.Prim.Int#
                                                                                                                                                         -> [GHC.Types.Char]
                                                                                                                                                    [LclId,
                                                                                                                                                     Arity=1,
                                                                                                                                                     Str=<S,1*U>,
                                                                                                                                                     Unf=OtherCon []] =
                                                                                                                                                        sat-only [lvl17_sgoGl
                                                                                                                                                                  $wxs_sgoGm] \r [ww8_sgoGn]
                                                                                                                                                            case
                                                                                                                                                                ww8_sgoGn
                                                                                                                                                            of
                                                                                                                                                            ds3_sgoGo
                                                                                                                                                            { __DEFAULT ->
                                                                                                                                                                  let {
                                                                                                                                                                    sat_sgoGq [Occ=Once]
                                                                                                                                                                      :: [GHC.Types.Char]
                                                                                                                                                                    [LclId] =
                                                                                                                                                                        [$wxs_sgoGm
                                                                                                                                                                         ds3_sgoGo] \u []
                                                                                                                                                                            case
                                                                                                                                                                                -# [ds3_sgoGo
                                                                                                                                                                                    1#]
                                                                                                                                                                            of
                                                                                                                                                                            sat_sgoGp
                                                                                                                                                                            { __DEFAULT ->
                                                                                                                                                                                  $wxs_sgoGm
                                                                                                                                                                                      sat_sgoGp;
                                                                                                                                                                            };
                                                                                                                                                                  } in 
                                                                                                                                                                    : [lvl14_rgoyT
                                                                                                                                                                       sat_sgoGq];
                                                                                                                                                              1# ->
                                                                                                                                                                  lvl17_sgoGl;
                                                                                                                                                            };
                                                                                                                                                  } in 
                                                                                                                                                    case
                                                                                                                                                        $wxs_sgoGm
                                                                                                                                                            y_sgoGd
                                                                                                                                                    of
                                                                                                                                                    wild5_sgoGr
                                                                                                                                                    { [] ->
                                                                                                                                                          [] [];
                                                                                                                                                      : _ [Occ=Dead]
                                                                                                                                                        _ [Occ=Dead] ->
                                                                                                                                                          : [lvl15_rgoyU
                                                                                                                                                             wild5_sgoGr];
                                                                                                                                                    };
                                                                                                                                            };
                                                                                                                                      };
                                                                                                                                };
                                                                                                                        };
                                                                                                              } in 
                                                                                                                case
                                                                                                                    chopTrailingZeros_sgoFJ
                                                                                                                of
                                                                                                                { GHC.Types.False ->
                                                                                                                      fail_sgoG6
                                                                                                                          GHC.Prim.void#;
                                                                                                                  GHC.Types.True ->
                                                                                                                      case
                                                                                                                          GHC.Integer.Type.eqInteger#
                                                                                                                              ds_sgoG5
                                                                                                                              Data.Fixed.$fEnumFixed1
                                                                                                                      of
                                                                                                                      { __DEFAULT ->
                                                                                                                            fail_sgoG6
                                                                                                                                GHC.Prim.void#;
                                                                                                                        1# ->
                                                                                                                            [] [];
                                                                                                                      };
                                                                                                                };
                                                                                                    } in 
                                                                                                      case
                                                                                                          ww_sgoG2
                                                                                                      of
                                                                                                      wild5_sgoGw
                                                                                                      { __DEFAULT ->
                                                                                                            case
                                                                                                                GHC.Real.$wf
                                                                                                                    Data.Fixed.$fHasResolutionE4
                                                                                                                    wild5_sgoGw
                                                                                                            of
                                                                                                            sat_sgoGx
                                                                                                            { __DEFAULT ->
                                                                                                                  case
                                                                                                                      GHC.Integer.Type.timesInteger
                                                                                                                          ipv1_sgoFQ
                                                                                                                          sat_sgoGx
                                                                                                                  of
                                                                                                                  sat_sgoGy
                                                                                                                  { __DEFAULT ->
                                                                                                                        case
                                                                                                                            GHC.Integer.Type.plusInteger
                                                                                                                                sat_sgoGy
                                                                                                                                res_sgoFM
                                                                                                                        of
                                                                                                                        sat_sgoGz
                                                                                                                        { __DEFAULT ->
                                                                                                                              case
                                                                                                                                  GHC.Integer.Type.minusInteger
                                                                                                                                      sat_sgoGz
                                                                                                                                      Data.Fixed.$fEnumFixed2
                                                                                                                              of
                                                                                                                              sat_sgoGA
                                                                                                                              { __DEFAULT ->
                                                                                                                                    case
                                                                                                                                        GHC.Integer.Type.divInteger
                                                                                                                                            sat_sgoGA
                                                                                                                                            res_sgoFM
                                                                                                                                    of
                                                                                                                                    sat_sgoGB
                                                                                                                                    { __DEFAULT ->
                                                                                                                                          $j1_sgoG4
                                                                                                                                              sat_sgoGB;
                                                                                                                                    };
                                                                                                                              };
                                                                                                                        };
                                                                                                                  };
                                                                                                            };
                                                                                                        0# ->
                                                                                                            case
                                                                                                                GHC.Integer.Type.timesInteger
                                                                                                                    ipv1_sgoFQ
                                                                                                                    GHC.Real.$fEnumRatio1
                                                                                                            of
                                                                                                            sat_sgoGC
                                                                                                            { __DEFAULT ->
                                                                                                                  case
                                                                                                                      GHC.Integer.Type.plusInteger
                                                                                                                          sat_sgoGC
                                                                                                                          res_sgoFM
                                                                                                                  of
                                                                                                                  sat_sgoGD
                                                                                                                  { __DEFAULT ->
                                                                                                                        case
                                                                                                                            GHC.Integer.Type.minusInteger
                                                                                                                                sat_sgoGD
                                                                                                                                Data.Fixed.$fEnumFixed2
                                                                                                                        of
                                                                                                                        sat_sgoGE
                                                                                                                        { __DEFAULT ->
                                                                                                                              case
                                                                                                                                  GHC.Integer.Type.divInteger
                                                                                                                                      sat_sgoGE
                                                                                                                                      res_sgoFM
                                                                                                                              of
                                                                                                                              sat_sgoGF
                                                                                                                              { __DEFAULT ->
                                                                                                                                    $j1_sgoG4
                                                                                                                                        sat_sgoGF;
                                                                                                                              };
                                                                                                                        };
                                                                                                                  };
                                                                                                            };
                                                                                                      };
                                                                                                1# ->
                                                                                                    GHC.Real.^1;
                                                                                              };
                                                                                    } in 
                                                                                      case
                                                                                          <## [sat_sgoGH
                                                                                               wild4_sgoFZ]
                                                                                      of
                                                                                      { __DEFAULT ->
                                                                                            $j_sgoG1
                                                                                                n_sgoG0;
                                                                                        1# ->
                                                                                            case
                                                                                                +# [n_sgoG0
                                                                                                    1#]
                                                                                            of
                                                                                            sat_sgoGJ
                                                                                            { __DEFAULT ->
                                                                                                  $j_sgoG1
                                                                                                      sat_sgoGJ;
                                                                                            };
                                                                                      };
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                }; } in
                                      let {
                                        sat_sgoFU [Occ=Once] :: [GHC.Types.Char]
                                        [LclId] =
                                            CCCS :! [ww3_sgoFS ww4_sgoFT];
                                      } in  GHC.Base.++ sat_sgoFU sat_sgoGK;
                                };
                          };
                      1# -> GHC.Real.divZeroError;
                    };
              };
          1# ->
              let {
                sat_sgoGN [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [$dHasResolution_sgoFI chopTrailingZeros_sgoFJ fa_sgoFK] \u []
                        case GHC.Integer.Type.negateInteger fa_sgoFK of sat_sgoGM {
                          __DEFAULT ->
                              Data.Fixed.showFixed
                                  $dHasResolution_sgoFI chopTrailingZeros_sgoFJ sat_sgoGM;
                        };
              } in  GHC.CString.unpackAppendCString# lvl16_rgoyV sat_sgoGN;
        };

Data.Fixed.$fShowFixed_$cshow
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a -> GHC.Base.String
[GblId, Arity=2, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoGO eta_B1]
        Data.Fixed.showFixed $dHasResolution_sgoGO GHC.Types.False eta_B1;

Data.Fixed.$fShowFixed_$cshowsPrec
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Types.Int -> Data.Fixed.Fixed a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*C1(U)><L,A><S,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoGP ds_sgoGQ x_sgoGR s_sgoGS]
        case
            Data.Fixed.showFixed $dHasResolution_sgoGP GHC.Types.False x_sgoGR
        of
        sat_sgoGT
        { __DEFAULT -> GHC.Base.++ sat_sgoGT s_sgoGS;
        };

Data.Fixed.$fShowFixed_$cshowList
  :: forall a.
     Data.Fixed.HasResolution a =>
     [Data.Fixed.Fixed a] -> GHC.Show.ShowS
[GblId, Arity=3, Str=<L,C(U)><S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgoGU ls_sgoGV s_sgoGW]
        let {
          sat_sgoH0 [Occ=Once] :: Data.Fixed.Fixed a_agnFG -> GHC.Show.ShowS
          [LclId] =
              [$dHasResolution_sgoGU] \r [x_sgoGX s1_sgoGY]
                  case
                      Data.Fixed.showFixed $dHasResolution_sgoGU GHC.Types.False x_sgoGX
                  of
                  sat_sgoGZ
                  { __DEFAULT -> GHC.Base.++ sat_sgoGZ s1_sgoGY;
                  };
        } in  GHC.Show.showList__ sat_sgoH0 ls_sgoGV s_sgoGW;

Data.Fixed.$fShowFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Show.Show (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgoH1]
        let {
          sat_sgoH4 [Occ=Once]
            :: [Data.Fixed.Fixed a_agnFG] -> GHC.Show.ShowS
          [LclId] =
              [$dHasResolution_sgoH1] \r [eta_B2 eta_B1]
                  Data.Fixed.$fShowFixed_$cshowList
                      $dHasResolution_sgoH1 eta_B2 eta_B1; } in
        let {
          sat_sgoH3 [Occ=Once] :: Data.Fixed.Fixed a_agnFG -> GHC.Base.String
          [LclId] =
              [$dHasResolution_sgoH1] \r [eta_B1]
                  Data.Fixed.$fShowFixed_$cshow $dHasResolution_sgoH1 eta_B1; } in
        let {
          sat_sgoH2 [Occ=Once]
            :: GHC.Types.Int -> Data.Fixed.Fixed a_agnFG -> GHC.Show.ShowS
          [LclId] =
              [$dHasResolution_sgoH1] \r [eta_B3 eta_B2 eta_B1]
                  Data.Fixed.$fShowFixed_$cshowsPrec
                      $dHasResolution_sgoH1 eta_B3 eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sgoH2 sat_sgoH3 sat_sgoH4];


==================== Pre unarise: ====================
2018-03-16 16:12:22.412346764 UTC

Data.Fixed.resolution [InlPrag=INLINE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall (p :: * -> *). p a -> GHC.Integer.Type.Integer
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_sgr4l] v_sgr4l;

Data.Fixed.$fDataFixed2
  :: GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sgr4m] v_sgr4m;

Data.Fixed.$fDataFixed_$cgfoldl
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Fixed.Fixed a
     -> c (Data.Fixed.Fixed a)
[GblId,
 Arity=4,
 Str=<L,A><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sgr4n k_sgr4o z_sgr4p ds_sgr4q]
        let {
          sat_sgr4r [Occ=Once]
            :: c_agnLa (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_agnL1)
          [LclId] =
              [z_sgr4p] \u [] z_sgr4p Data.Fixed.$fDataFixed2;
        } in  k_sgr4o Data.Data.$fDataInteger sat_sgr4r ds_sgr4q;

Data.Fixed.$fEnumFixed1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Fixed.$fEnumFixed_$cenumFromThenTo
  :: forall a.
     Data.Fixed.Fixed a
     -> Data.Fixed.Fixed a -> Data.Fixed.Fixed a -> [Data.Fixed.Fixed a]
[GblId, Arity=3, Str=<S,U><S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [ds_sgr4s ds1_sgr4t ds2_sgr4u]
        case
            GHC.Integer.Type.minusInteger ds1_sgr4t ds_sgr4s
        of
        delta_sgr4v [Dmd=<S,U>]
        { __DEFAULT ->
              case
                  GHC.Integer.Type.geInteger# delta_sgr4v Data.Fixed.$fEnumFixed1
              of
              { __DEFAULT ->
                    let {
                      go_sgr4x [Occ=LoopBreaker]
                        :: GHC.Integer.Type.Integer -> [Data.Fixed.Fixed a_agnJM]
                      [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ds2_sgr4u delta_sgr4v go_sgr4x] \r [x_sgr4y]
                              case GHC.Integer.Type.ltInteger# x_sgr4y ds2_sgr4u of {
                                __DEFAULT ->
                                    let {
                                      sat_sgr4B [Occ=Once] :: [Data.Fixed.Fixed a_agnJM]
                                      [LclId] =
                                          [delta_sgr4v go_sgr4x x_sgr4y] \u []
                                              case
                                                  GHC.Integer.Type.plusInteger x_sgr4y delta_sgr4v
                                              of
                                              sat_sgr4A
                                              { __DEFAULT -> go_sgr4x sat_sgr4A;
                                              };
                                    } in  : [x_sgr4y sat_sgr4B];
                                1# -> [] [];
                              };
                    } in  go_sgr4x ds_sgr4s;
                1# ->
                    let {
                      go_sgr4C [Occ=LoopBreaker]
                        :: GHC.Integer.Type.Integer -> [Data.Fixed.Fixed a_agnJM]
                      [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ds2_sgr4u delta_sgr4v go_sgr4C] \r [x_sgr4D]
                              case GHC.Integer.Type.gtInteger# x_sgr4D ds2_sgr4u of {
                                __DEFAULT ->
                                    let {
                                      sat_sgr4G [Occ=Once] :: [Data.Fixed.Fixed a_agnJM]
                                      [LclId] =
                                          [delta_sgr4v go_sgr4C x_sgr4D] \u []
                                              case
                                                  GHC.Integer.Type.plusInteger x_sgr4D delta_sgr4v
                                              of
                                              sat_sgr4F
                                              { __DEFAULT -> go_sgr4C sat_sgr4F;
                                              };
                                    } in  : [x_sgr4D sat_sgr4G];
                                1# -> [] [];
                              };
                    } in  go_sgr4C ds_sgr4s;
              };
        };

sat_sgr4H :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_sgr4I :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgr4H GHC.Types.[]];

Data.Fixed.$fEnumFixed2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgr4I;

Data.Fixed.$fEnumFixed_$cenumFromTo
  :: forall a.
     Data.Fixed.Fixed a -> Data.Fixed.Fixed a -> [Data.Fixed.Fixed a]
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ds_sgr4J ds1_sgr4K]
        let {
          go_sgr4L [Occ=LoopBreaker]
            :: GHC.Integer.Type.Integer -> [Data.Fixed.Fixed a_agnJM]
          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
              sat-only [ds1_sgr4K go_sgr4L] \r [x_sgr4M]
                  case GHC.Integer.Type.gtInteger# x_sgr4M ds1_sgr4K of {
                    __DEFAULT ->
                        let {
                          sat_sgr4P [Occ=Once] :: [Data.Fixed.Fixed a_agnJM]
                          [LclId] =
                              [go_sgr4L x_sgr4M] \u []
                                  case
                                      GHC.Integer.Type.plusInteger x_sgr4M Data.Fixed.$fEnumFixed2
                                  of
                                  sat_sgr4O
                                  { __DEFAULT -> go_sgr4L sat_sgr4O;
                                  };
                        } in  : [x_sgr4M sat_sgr4P];
                    1# -> [] [];
                  };
        } in  go_sgr4L ds_sgr4J;

Data.Fixed.$fEnumFixed_$cenumFromThen
  :: forall a.
     Data.Fixed.Fixed a -> Data.Fixed.Fixed a -> [Data.Fixed.Fixed a]
[GblId, Arity=2, Str=<S,U><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgr4Q ds1_sgr4R]
        let {
          d_sgr4S [Occ=OnceL] :: GHC.Integer.Type.Integer
          [LclId] =
              [ds_sgr4Q ds1_sgr4R] \u []
                  GHC.Integer.Type.minusInteger ds1_sgr4R ds_sgr4Q; } in
        let {
          go_sgr4T [Occ=LoopBreaker]
            :: GHC.Integer.Type.Integer -> [Data.Fixed.Fixed a_agnJM]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [d_sgr4S go_sgr4T] \r [x_sgr4U]
                  case x_sgr4U of x1_sgr4V {
                    __DEFAULT ->
                        let {
                          sat_sgr4X [Occ=Once] :: [Data.Fixed.Fixed a_agnJM]
                          [LclId] =
                              [d_sgr4S go_sgr4T x1_sgr4V] \u []
                                  case GHC.Integer.Type.plusInteger x1_sgr4V d_sgr4S of sat_sgr4W {
                                    __DEFAULT -> go_sgr4T sat_sgr4W;
                                  };
                        } in  : [x1_sgr4V sat_sgr4X];
                  };
        } in  go_sgr4T ds_sgr4Q;

Data.Fixed.$fEnumFixed3 [Occ=LoopBreaker]
  :: forall a. GHC.Integer.Type.Integer -> [Data.Fixed.Fixed a]
[GblId, Arity=1, Str=<S,1*U>m2, Unf=OtherCon []] =
    [] \r [x_sgr4Y]
        case x_sgr4Y of x1_sgr4Z {
          __DEFAULT ->
              let {
                sat_sgr51 [Occ=Once] :: [Data.Fixed.Fixed a_agnJM]
                [LclId] =
                    [x1_sgr4Z] \u []
                        case
                            GHC.Integer.Type.plusInteger x1_sgr4Z Data.Fixed.$fEnumFixed2
                        of
                        sat_sgr50
                        { __DEFAULT -> Data.Fixed.$fEnumFixed3 sat_sgr50;
                        };
              } in  : [x1_sgr4Z sat_sgr51];
        };

Data.Fixed.$fEnumFixed_$cenumFrom
  :: forall a. Data.Fixed.Fixed a -> [Data.Fixed.Fixed a]
[GblId, Arity=1, Str=<S,1*U>m2, Unf=OtherCon []] =
    [] \r [ds_sgr52] Data.Fixed.$fEnumFixed3 ds_sgr52;

Data.Fixed.$fEnumFixed_$cfromEnum
  :: forall a. Data.Fixed.Fixed a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_sgr53] GHC.Enum.$fEnumInteger_$cfromEnum ds_sgr53;

Data.Fixed.$fEnumFixed4
  :: forall a. Data.Fixed.Fixed a -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgr54] GHC.Enum.$fEnumInteger_$cpred ds_sgr54;

Data.Fixed.$fEnumFixed5
  :: forall a. Data.Fixed.Fixed a -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgr55] GHC.Enum.$fEnumInteger_$csucc ds_sgr55;

Data.Fixed.$fEnumFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Enum.Enum (Data.Fixed.Fixed a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Enum.C:Enum! [Data.Fixed.$fEnumFixed5
                                    Data.Fixed.$fEnumFixed4
                                    GHC.Enum.$fEnumInteger_$ctoEnum
                                    Data.Fixed.$fEnumFixed_$cfromEnum
                                    Data.Fixed.$fEnumFixed_$cenumFrom
                                    Data.Fixed.$fEnumFixed_$cenumFromThen
                                    Data.Fixed.$fEnumFixed_$cenumFromTo
                                    Data.Fixed.$fEnumFixed_$cenumFromThenTo];

Data.Fixed.$fHasResolutionE0_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E0 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgr56] Data.Fixed.$fEnumFixed2;

Data.Fixed.$fHasResolutionE0 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E0
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE0_$cresolution eta_B1;

sat_sgr57 :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [10#];

sat_sgr58 :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgr57 GHC.Types.[]];

Data.Fixed.$fHasResolutionE4 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgr58;

Data.Fixed.$fHasResolutionE1_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E1 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgr59] Data.Fixed.$fHasResolutionE4;

Data.Fixed.$fHasResolutionE1 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E1
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE1_$cresolution eta_B1;

sat_sgr5a :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [100#];

sat_sgr5b :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgr5a GHC.Types.[]];

Data.Fixed.$fHasResolutionE7 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgr5b;

Data.Fixed.$fHasResolutionE2_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E2 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgr5c] Data.Fixed.$fHasResolutionE7;

Data.Fixed.$fHasResolutionE2 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E2
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE2_$cresolution eta_B1;

sat_sgr5d :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1000#];

sat_sgr5e :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgr5d GHC.Types.[]];

Data.Fixed.$fHasResolutionE8 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgr5e;

Data.Fixed.$fHasResolutionE3_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E3 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgr5f] Data.Fixed.$fHasResolutionE8;

Data.Fixed.$fHasResolutionE3 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E3
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE3_$cresolution eta_B1;

sat_sgr5g :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1000000#];

sat_sgr5h :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgr5g GHC.Types.[]];

Data.Fixed.$fHasResolutionE10 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgr5h;

Data.Fixed.$fHasResolutionE6_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E6 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgr5i] Data.Fixed.$fHasResolutionE10;

Data.Fixed.$fHasResolutionE6 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E6
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE6_$cresolution eta_B1;

sat_sgr5j :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1000000000#];

sat_sgr5k :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgr5j GHC.Types.[]];

Data.Fixed.$fHasResolutionE11 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgr5k;

Data.Fixed.$fHasResolutionE9_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E9 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgr5l] Data.Fixed.$fHasResolutionE11;

Data.Fixed.$fHasResolutionE9 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E9
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE9_$cresolution eta_B1;

sat_sgr5n :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [465#];

sat_sgr5o :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgr5n GHC.Types.[]];

sat_sgr5m :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1420103680#];

sat_sgr5p :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgr5m sat_sgr5o];

Data.Fixed.$fHasResolutionE5 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgr5p;

Data.Fixed.$fHasResolutionE12_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E12 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgr5q] Data.Fixed.$fHasResolutionE5;

Data.Fixed.$fHasResolutionE12 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E12
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE12_$cresolution eta_B1;

Data.Fixed.$fDataFixed6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Fixed.Fixed"#;

Data.Fixed.$fDataFixed5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Fixed.$fDataFixed6;

w1_rgoyk :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "MkFixed"#;

w2_rgoyl :: GHC.Base.String
[GblId] =
    [] \u [] GHC.CString.unpackCString# w1_rgoyk;

go61_rgoym
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sgr5r _ys_sgr5s]
        case ds2_sgr5r of {
          [] -> GHC.List.badHead;
          : ipv_sgr5u [Occ=Once!] ipv1_sgr5v [Occ=Once] ->
              case _ys_sgr5s of {
                [] -> GHC.List.badHead;
                : ipv2_sgr5x [Occ=Once] ipv3_sgr5y [Occ=Once] ->
                    case ipv_sgr5u of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sgr5B [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sgr5B w2_rgoyl of {
                            GHC.Types.False -> go61_rgoym ipv1_sgr5v ipv3_sgr5y;
                            GHC.Types.True -> ipv2_sgr5x;
                          };
                    };
              };
        };

conMkFixed1_rgoyn :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [conMkFixed2_rgoyo];
Data.Fixed.$fDataFixed4 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Fixed.conMkFixed GHC.Types.[]];
Data.Fixed.$fDataFixed3 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Fixed.$fDataFixed4];
Data.Fixed.tyFixed :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Fixed.$fDataFixed5
                                       Data.Fixed.$fDataFixed3];
Data.Fixed.conMkFixed [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [conMkFixed1_rgoyn
                                     w2_rgoyl
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     Data.Fixed.tyFixed];
conMkFixed2_rgoyo :: Data.Data.ConIndex
[GblId] =
    [] \u [] go61_rgoym Data.Fixed.$fDataFixed4 Data.Data.mkConstr1;

Data.Fixed.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

loc_rgoyp :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Fixed.$trModule4;

Data.Fixed.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Fixed"#;

loc1_rgoyq :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Fixed.$trModule2;

loc2_rgoyr :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "./Data/Fixed.hs"#;

loc3_rgoys :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# loc2_rgoyr;

loc4_rgoyt :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [83#];

loc5_rgoyu :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [20#];

loc6_rgoyv :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [29#];

$dIP_rgoyw :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "undefined"#;

$dIP1_rgoyx :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# $dIP_rgoyw;

$dIP2_rgoyy :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [loc_rgoyp
                                           loc1_rgoyq
                                           loc3_rgoys
                                           loc4_rgoyt
                                           loc5_rgoyu
                                           loc4_rgoyt
                                           loc6_rgoyv];

$dIP3_rgoyz :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [$dIP1_rgoyx
                                                  $dIP2_rgoyy
                                                  GHC.Stack.Types.EmptyCallStack];

Data.Fixed.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$trModule4];

Data.Fixed.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$trModule2];

Data.Fixed.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Fixed.$trModule3
                                     Data.Fixed.$trModule1];

$krep_rgoyA :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Integer.Type.$tcInteger
                                              GHC.Types.[]];

$krep1_rgoyB :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Fixed.$tcHasResolution1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*
                                         $krep1_rgoyB];

$krep2_rgoyC :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

Data.Fixed.$fDataFixed10 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Fixed"#;

Data.Fixed.$fDataFixed9 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$fDataFixed10];

Data.Fixed.$tcFixed :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12850707307297787398##
                                    5875431371990069009##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$fDataFixed9
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep3_rgoyD :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rgoyC GHC.Types.[]];

$krep4_rgoyE :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Fixed.$tcFixed
                                              $krep3_rgoyD];

Data.Fixed.$tc'MkFixed1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgoyA $krep4_rgoyE];

Data.Fixed.$tc'MkFixed3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'MkFixed"#;

Data.Fixed.$tc'MkFixed2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tc'MkFixed3];

Data.Fixed.$tc'MkFixed :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8992689233320522225##
                                    9587721628087041380##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tc'MkFixed2
                                    1#
                                    Data.Fixed.$tc'MkFixed1];

Data.Fixed.$fDataFixed8
  :: Data.Typeable.Internal.TypeRep Data.Fixed.Fixed
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                12850707307297787398##
                5875431371990069009##
                Data.Fixed.$trModule
                Data.Fixed.$fDataFixed9
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sgr5H [Occ=Once]
                   ww9_sgr5I [Occ=Once]
                   ww10_sgr5J [Occ=Once]
                   ww11_sgr5K [Occ=Once]
                   ww12_sgr5L [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sgr5H
                                              ww9_sgr5I
                                              ww10_sgr5J
                                              ww11_sgr5K
                                              ww12_sgr5L];
        };

Data.Fixed.$fDataFixed7
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     Data.Typeable.Internal.TypeRep (Data.Fixed.Fixed a)
[GblId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
    [] \r [$dTypeable_sgr5M]
        Data.Typeable.Internal.mkTrApp
            Data.Fixed.$fDataFixed8 $dTypeable_sgr5M;

Data.Fixed.$fDataFixed1
  :: forall a.
     (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Fixed.$fDataFixed2 GHC.Types.False];

Data.Fixed.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall a (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgr5N w3_sgr5O w4_sgr5P]
        let {
          lvl17_sgr5Q [Occ=OnceL] :: m_sgomN (Data.Fixed.Fixed a_sgomL)
          [LclId] =
              [w_sgr5N] \u [] GHC.Base.mzero w_sgr5N;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sgr5N
          of
          $dMonad_sgr5R [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgr6d [Occ=Once]
                    :: (Data.Fixed.Fixed a_sgomL, GHC.Types.Bool)
                       -> m_sgomN (Data.Fixed.Fixed a_sgomL)
                  [LclId] =
                      [lvl17_sgr5Q $dMonad_sgr5R] \r [ds_sgr68]
                          case ds_sgr68 of {
                            (,) x'_sgr6a [Occ=Once] b_sgr6b [Occ=Once!] ->
                                case b_sgr6b of {
                                  GHC.Types.False -> lvl17_sgr5Q;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgr5R x'_sgr6a;
                                };
                          }; } in
                let {
                  sat_sgr67 [Occ=Once]
                    :: m_sgomN (Data.Fixed.Fixed a_sgomL, GHC.Types.Bool)
                  [LclId] =
                      [w_sgr5N w3_sgr5O w4_sgr5P $dMonad_sgr5R] \u []
                          let {
                            lvl18_sgr5S [Occ=OnceL] :: m_sgomN GHC.Integer.Type.Integer
                            [LclId] =
                                [w3_sgr5O w4_sgr5P] \u []
                                    w3_sgr5O Data.Data.$fDataInteger w4_sgr5P; } in
                          let {
                            sat_sgr66 [Occ=Once]
                              :: (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomL,
                                  GHC.Types.Bool)
                                 -> m_sgomN (Data.Fixed.Fixed a_sgomL, GHC.Types.Bool)
                            [LclId] =
                                [w_sgr5N w4_sgr5P $dMonad_sgr5R lvl18_sgr5S] \r [ds1_sgr5U]
                                    case ds1_sgr5U of {
                                      (,) h_sgr5W b1_sgr5X [Occ=Once] ->
                                          let {
                                            sat_sgr65 [Occ=Once]
                                              :: m_sgomN (Data.Fixed.Fixed a_sgomL, GHC.Types.Bool)
                                            [LclId] =
                                                [w4_sgr5P $dMonad_sgr5R h_sgr5W b1_sgr5X] \u []
                                                    let {
                                                      sat_sgr63 [Occ=Once]
                                                        :: Data.Fixed.Fixed a_sgomL
                                                      [LclId] =
                                                          [w4_sgr5P h_sgr5W] \u []
                                                              h_sgr5W w4_sgr5P; } in
                                                    let {
                                                      sat_sgr64 [Occ=Once]
                                                        :: (Data.Fixed.Fixed a_sgomL,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sgr63 b1_sgr5X];
                                                    } in 
                                                      GHC.Base.return $dMonad_sgr5R sat_sgr64; } in
                                          let {
                                            sat_sgr62 [Occ=Once]
                                              :: m_sgomN (Data.Fixed.Fixed a_sgomL, GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sgr5R lvl18_sgr5S h_sgr5W] \u []
                                                    let {
                                                      sat_sgr61 [Occ=Once]
                                                        :: GHC.Integer.Type.Integer
                                                           -> m_sgomN (Data.Fixed.Fixed a_sgomL,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sgr5R h_sgr5W] \r [y'_sgr5Y]
                                                              let {
                                                                sat_sgr5Z [Occ=Once]
                                                                  :: Data.Fixed.Fixed a_sgomL
                                                                [LclId] =
                                                                    [h_sgr5W y'_sgr5Y] \u []
                                                                        h_sgr5W y'_sgr5Y; } in
                                                              let {
                                                                sat_sgr60 [Occ=Once]
                                                                  :: (Data.Fixed.Fixed a_sgomL,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sgr5Z
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sgr5R sat_sgr60;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sgr5R lvl18_sgr5S sat_sgr61;
                                          } in  GHC.Base.mplus w_sgr5N sat_sgr62 sat_sgr65;
                                    }; } in
                          let {
                            sat_sgr5T [Occ=Once]
                              :: m_sgomN (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomL,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sgr5R] \u []
                                    GHC.Base.return $dMonad_sgr5R Data.Fixed.$fDataFixed1;
                          } in  GHC.Base.>>= $dMonad_sgr5R sat_sgr5T sat_sgr66;
                } in  GHC.Base.>>= $dMonad_sgr5R sat_sgr67 sat_sgr6d;
          };

Data.Fixed.$fDataFixed_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=4,
 Str=<L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgr6e w3_sgr6f w4_sgr6g w5_sgr6h]
        Data.Fixed.$w$cgmapMp w3_sgr6f w4_sgr6g w5_sgr6h;

Data.Fixed.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=3,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgr6i w3_sgr6j w4_sgr6k]
        let {
          lvl17_sgr6l [Occ=OnceL] :: m_sgomU GHC.Integer.Type.Integer
          [LclId] =
              [w3_sgr6j w4_sgr6k] \u []
                  w3_sgr6j Data.Data.$fDataInteger w4_sgr6k; } in
        let {
          sat_sgr6r [Occ=Once]
            :: (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomS)
               -> m_sgomU (Data.Fixed.Fixed a_sgomS)
          [LclId] =
              [w_sgr6i lvl17_sgr6l] \r [c'_sgr6n]
                  let {
                    sat_sgr6q [Occ=Once]
                      :: GHC.Integer.Type.Integer -> m_sgomU (Data.Fixed.Fixed a_sgomS)
                    [LclId] =
                        [w_sgr6i c'_sgr6n] \r [x'_sgr6o]
                            let {
                              sat_sgr6p [Occ=Once] :: Data.Fixed.Fixed a_sgomS
                              [LclId] =
                                  [c'_sgr6n x'_sgr6o] \u [] c'_sgr6n x'_sgr6o;
                            } in  GHC.Base.return w_sgr6i sat_sgr6p;
                  } in  GHC.Base.>>= w_sgr6i lvl17_sgr6l sat_sgr6q; } in
        let {
          sat_sgr6m [Occ=Once]
            :: m_sgomU (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomS)
          [LclId] =
              [w_sgr6i] \u [] GHC.Base.return w_sgr6i Data.Fixed.$fDataFixed2;
        } in  GHC.Base.>>= w_sgr6i sat_sgr6m sat_sgr6r;

Data.Fixed.$fDataFixed_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=4,
 Str=<L,A><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgr6s w3_sgr6t w4_sgr6u w5_sgr6v]
        Data.Fixed.$w$cgmapM w3_sgr6t w4_sgr6u w5_sgr6v;

Data.Fixed.$fDataFixed_$cgmapQi
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Fixed.Fixed a
     -> u
[GblId,
 Arity=4,
 Str=<L,A><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sgr6w ds_sgr6x ds1_sgr6y x_sgr6z]
        case ds_sgr6x of {
          GHC.Types.I# x1_sgr6B [Occ=Once!] ->
              case x1_sgr6B of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sgr6y Data.Data.$fDataInteger x_sgr6z;
              };
        };

Data.Fixed.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall a (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgr6D w3_sgr6E w4_sgr6F]
        let {
          lvl17_sgr6G [Occ=OnceL] :: m_sgon1 (Data.Fixed.Fixed a_sgomZ)
          [LclId] =
              [w_sgr6D] \u [] GHC.Base.mzero w_sgr6D;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sgr6D
          of
          $dMonad_sgr6H [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgr76 [Occ=Once]
                    :: (Data.Fixed.Fixed a_sgomZ, GHC.Types.Bool)
                       -> m_sgon1 (Data.Fixed.Fixed a_sgomZ)
                  [LclId] =
                      [lvl17_sgr6G $dMonad_sgr6H] \r [ds_sgr71]
                          case ds_sgr71 of {
                            (,) x'_sgr73 [Occ=Once] b_sgr74 [Occ=Once!] ->
                                case b_sgr74 of {
                                  GHC.Types.False -> lvl17_sgr6G;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgr6H x'_sgr73;
                                };
                          }; } in
                let {
                  sat_sgr70 [Occ=Once]
                    :: m_sgon1 (Data.Fixed.Fixed a_sgomZ, GHC.Types.Bool)
                  [LclId] =
                      [w_sgr6D w3_sgr6E w4_sgr6F $dMonad_sgr6H] \u []
                          let {
                            lvl18_sgr6I [Occ=OnceL] :: m_sgon1 GHC.Integer.Type.Integer
                            [LclId] =
                                [w3_sgr6E w4_sgr6F] \u []
                                    w3_sgr6E Data.Data.$fDataInteger w4_sgr6F; } in
                          let {
                            sat_sgr6Z [Occ=Once]
                              :: (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomZ,
                                  GHC.Types.Bool)
                                 -> m_sgon1 (Data.Fixed.Fixed a_sgomZ, GHC.Types.Bool)
                            [LclId] =
                                [w_sgr6D w4_sgr6F $dMonad_sgr6H lvl18_sgr6I] \r [ds1_sgr6K]
                                    case ds1_sgr6K of {
                                      (,) h_sgr6M b1_sgr6N [Occ=Once!] ->
                                          case b1_sgr6N of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sgr6W [Occ=Once]
                                                    :: m_sgon1 (Data.Fixed.Fixed a_sgomZ,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [w4_sgr6F $dMonad_sgr6H h_sgr6M] \u []
                                                          let {
                                                            sat_sgr6U [Occ=Once]
                                                              :: Data.Fixed.Fixed a_sgomZ
                                                            [LclId] =
                                                                [w4_sgr6F h_sgr6M] \u []
                                                                    h_sgr6M w4_sgr6F; } in
                                                          let {
                                                            sat_sgr6V [Occ=Once]
                                                              :: (Data.Fixed.Fixed a_sgomZ,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sgr6U
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sgr6H sat_sgr6V; } in
                                                let {
                                                  sat_sgr6T [Occ=Once]
                                                    :: m_sgon1 (Data.Fixed.Fixed a_sgomZ,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sgr6H lvl18_sgr6I h_sgr6M] \u []
                                                          let {
                                                            sat_sgr6S [Occ=Once]
                                                              :: GHC.Integer.Type.Integer
                                                                 -> m_sgon1 (Data.Fixed.Fixed
                                                                               a_sgomZ,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sgr6H
                                                                 h_sgr6M] \r [y'_sgr6P]
                                                                    let {
                                                                      sat_sgr6Q [Occ=Once]
                                                                        :: Data.Fixed.Fixed a_sgomZ
                                                                      [LclId] =
                                                                          [h_sgr6M y'_sgr6P] \u []
                                                                              h_sgr6M y'_sgr6P; } in
                                                                    let {
                                                                      sat_sgr6R [Occ=Once]
                                                                        :: (Data.Fixed.Fixed
                                                                              a_sgomZ,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sgr6Q
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sgr6H sat_sgr6R;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sgr6H lvl18_sgr6I sat_sgr6S;
                                                } in  GHC.Base.mplus w_sgr6D sat_sgr6T sat_sgr6W;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sgr6X [Occ=Once] :: Data.Fixed.Fixed a_sgomZ
                                                  [LclId] =
                                                      [w4_sgr6F h_sgr6M] \u []
                                                          h_sgr6M w4_sgr6F; } in
                                                let {
                                                  sat_sgr6Y [Occ=Once]
                                                    :: (Data.Fixed.Fixed a_sgomZ, GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sgr6X GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sgr6H sat_sgr6Y;
                                          };
                                    }; } in
                          let {
                            sat_sgr6J [Occ=Once]
                              :: m_sgon1 (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomZ,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sgr6H] \u []
                                    GHC.Base.return $dMonad_sgr6H Data.Fixed.$fDataFixed1;
                          } in  GHC.Base.>>= $dMonad_sgr6H sat_sgr6J sat_sgr6Z;
                } in  GHC.Base.>>= $dMonad_sgr6H sat_sgr70 sat_sgr76;
          };

Data.Fixed.$fDataFixed_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=4,
 Str=<L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgr77 w3_sgr78 w4_sgr79 w5_sgr7a]
        Data.Fixed.$w$cgmapMo w3_sgr78 w4_sgr79 w5_sgr7a;

lvl_rgoyF :: forall a. Data.Fixed.Fixed a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sgr7b] Data.Fixed.conMkFixed;

lvl1_rgoyG :: forall a. Data.Fixed.Fixed a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sgr7c] Data.Fixed.tyFixed;

lvl2_rgoyH
  :: forall a (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Fixed.Fixed a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sgr7d ds_sgr7e] GHC.Base.Nothing [];

lvl3_rgoyI
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Fixed.Fixed a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sgr7f ds_sgr7g] GHC.Base.Nothing [];

lvl4_rgoyJ
  :: forall a.
     (forall b. Data.Data.Data b => b -> b)
     -> Data.Fixed.Fixed a -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<C(C(S)),1*C1(C1(U))><L,U>, Unf=OtherCon []] =
    [] \r [ds_sgr7h x0_sgr7i]
        ds_sgr7h Data.Data.$fDataInteger x0_sgr7i;

lvl5_rgoyK
  :: forall a r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Fixed.Fixed a
     -> r
[GblId,
 Arity=4,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgr7j ds1_sgr7k ds2_sgr7l eta_sgr7m]
        let {
          sat_sgr7n [Occ=Once] :: r'_agnMw
          [LclId] =
              [ds2_sgr7l eta_sgr7m] \u []
                  ds2_sgr7l Data.Data.$fDataInteger eta_sgr7m;
        } in  ds_sgr7j ds1_sgr7k sat_sgr7n;

lvl6_rgoyL
  :: forall a r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Fixed.Fixed a
     -> r
[GblId,
 Arity=4,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgr7o ds1_sgr7p ds2_sgr7q x0_sgr7r]
        let {
          sat_sgr7s [Occ=Once] :: r'_agnMN
          [LclId] =
              [ds2_sgr7q x0_sgr7r] \u []
                  ds2_sgr7q Data.Data.$fDataInteger x0_sgr7r;
        } in  ds_sgr7o sat_sgr7s ds1_sgr7p;

lvl7_rgoyM
  :: forall a u.
     (forall d. Data.Data.Data d => d -> u) -> Data.Fixed.Fixed a -> [u]
[GblId, Arity=2, Str=<L,1*C1(C1(U))><L,U>m2, Unf=OtherCon []] =
    [] \r [ds_sgr7t x0_sgr7u]
        let {
          sat_sgr7v [Occ=Once] :: u_agnN3
          [LclId] =
              [ds_sgr7t x0_sgr7u] \u []
                  ds_sgr7t Data.Data.$fDataInteger x0_sgr7u;
        } in  : [sat_sgr7v GHC.Types.[]];

lvl8_rgoyN
  :: forall a (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c (Data.Fixed.Fixed a)
[GblId,
 Arity=3,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [k_sgr7w z_sgr7x ds_sgr7y]
        let {
          sat_sgr7z [Occ=Once]
            :: c_agnLl (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_XgnO4)
          [LclId] =
              [z_sgr7x] \u [] z_sgr7x Data.Fixed.$fDataFixed2;
        } in  k_sgr7w Data.Data.$fDataInteger sat_sgr7z;

Data.Fixed.$fDataFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     Data.Data.Data (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,U>] =
    [] \r [$dTypeable_sgr7A]
        let {
          sat_sgr7D [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Fixed.Fixed a_XgnO4
               -> u
          [LclId] =
              [$dTypeable_sgr7A] \r [eta_B3 eta_B2 eta_B1]
                  Data.Fixed.$fDataFixed_$cgmapQi
                      $dTypeable_sgr7A eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgr7C [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Fixed.Fixed a_XgnO4
               -> c (Data.Fixed.Fixed a_XgnO4)
          [LclId] =
              [$dTypeable_sgr7A] \r [eta_B3 eta_B2 eta_B1]
                  Data.Fixed.$fDataFixed_$cgfoldl
                      $dTypeable_sgr7A eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgr7B [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Fixed.Fixed a_XgnO4)
          [LclId] =
              [$dTypeable_sgr7A] \u [] Data.Fixed.$fDataFixed7 $dTypeable_sgr7A;
        } in 
          Data.Data.C:Data [sat_sgr7B
                            sat_sgr7C
                            lvl8_rgoyN
                            lvl_rgoyF
                            lvl1_rgoyG
                            lvl2_rgoyH
                            lvl3_rgoyI
                            lvl4_rgoyJ
                            lvl5_rgoyK
                            lvl6_rgoyL
                            lvl7_rgoyM
                            sat_sgr7D
                            Data.Fixed.$w$cgmapM
                            Data.Fixed.$w$cgmapMp
                            Data.Fixed.$w$cgmapMo];

Data.Fixed.$tcHasResolution3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "HasResolution"#;

Data.Fixed.$tcHasResolution2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcHasResolution3];

Data.Fixed.$tcHasResolution :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7410670074803796200##
                                    11622449620609036983##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcHasResolution2
                                    0#
                                    Data.Fixed.$tcHasResolution1];

Data.Fixed.$tcE5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E0"#;

Data.Fixed.$tcE4 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE5];

Data.Fixed.$tcE0 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1111589946053822622##
                                    14645449775626969178##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE4
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE8 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E1"#;

Data.Fixed.$tcE7 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE8];

Data.Fixed.$tcE1 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17242267792727872229##
                                    10571291330004494282##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE7
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE14 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E2"#;

Data.Fixed.$tcE13 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE14];

Data.Fixed.$tcE2 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [18184774527647329547##
                                    15895109557895358229##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE13
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE16 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E3"#;

Data.Fixed.$tcE15 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE16];

Data.Fixed.$tcE3 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2281297682271263739##
                                    13982938170987291273##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE15
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE18 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E6"#;

Data.Fixed.$tcE17 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE18];

Data.Fixed.$tcE6 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6430880657524859014##
                                    16351944333195325805##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE17
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE20 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E9"#;

Data.Fixed.$tcE19 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE20];

Data.Fixed.$tcE9 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8202840314884717291##
                                    5390706447224283764##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE19
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE11 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E12"#;

Data.Fixed.$tcE10 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE11];

Data.Fixed.$tcE12 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11177455628646877585##
                                    1804744900678580889##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE10
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.div'
  :: forall a b.
     (GHC.Real.Real a, GHC.Real.Integral b) =>
     a -> a -> b
[GblId,
 Arity=4,
 Str=<S(LLC(S(SS))),U(A,A,C(U(U,U)))><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dReal_sgr7E $dIntegral_sgr7F n_sgr7G d_sgr7H]
        case GHC.Real.toRational $dReal_sgr7E n_sgr7G of {
          GHC.Real.:% ww1_sgr7J [Occ=Once] ww2_sgr7K [Occ=Once] ->
              case GHC.Real.toRational $dReal_sgr7E d_sgr7H of {
                GHC.Real.:% ww4_sgr7M [Occ=Once] ww5_sgr7N [Occ=Once] ->
                    case GHC.Real.$w$s$c/ ww1_sgr7J ww2_sgr7K ww4_sgr7M ww5_sgr7N of {
                      (#,#) ww7_sgr7P [Occ=Once] ww8_sgr7Q [Occ=Once] ->
                          GHC.Real.$w$s$cfloor $dIntegral_sgr7F ww7_sgr7P ww8_sgr7Q;
                    };
              };
        };

Data.Fixed.$wdivMod' [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Real.Real a, GHC.Real.Integral b) =>
     a -> a -> (# b, a #)
[GblId,
 Arity=4,
 Str=<L,U(1*U(A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,1*C1(U)),A,C(U(U,U)))><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,1*C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgr7R w3_sgr7S w4_sgr7T w5_sgr7U]
        let {
          f_sgr7V :: b_sgond
          [LclId] =
              [w_sgr7R w3_sgr7S w4_sgr7T w5_sgr7U] \u []
                  Data.Fixed.div' w_sgr7R w3_sgr7S w4_sgr7T w5_sgr7U; } in
        let {
          sat_sgr80 [Occ=Once] :: a_sgonc
          [LclId] =
              [w_sgr7R w3_sgr7S w4_sgr7T w5_sgr7U f_sgr7V] \u []
                  case
                      GHC.Real.$p1Real w_sgr7R
                  of
                  $dNum_sgr7W [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,1*C1(U))>]
                  { __DEFAULT ->
                        let {
                          sat_sgr7Z [Occ=Once] :: a_sgonc
                          [LclId] =
                              [w3_sgr7S w5_sgr7U f_sgr7V $dNum_sgr7W] \u []
                                  let {
                                    sat_sgr7Y [Occ=Once] :: a_sgonc
                                    [LclId] =
                                        [w3_sgr7S f_sgr7V $dNum_sgr7W] \u []
                                            let {
                                              sat_sgr7X [Occ=Once] :: GHC.Integer.Type.Integer
                                              [LclId] =
                                                  [w3_sgr7S f_sgr7V] \u []
                                                      GHC.Real.toInteger w3_sgr7S f_sgr7V;
                                            } in  GHC.Num.fromInteger $dNum_sgr7W sat_sgr7X;
                                  } in  GHC.Num.* $dNum_sgr7W sat_sgr7Y w5_sgr7U;
                        } in  GHC.Num.- $dNum_sgr7W w4_sgr7T sat_sgr7Z;
                  };
        } in  (#,#) [f_sgr7V sat_sgr80];

Data.Fixed.divMod' [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Real.Real a, GHC.Real.Integral b) =>
     a -> a -> (b, a)
[GblId,
 Arity=4,
 Str=<L,U(U(A,C(C1(U)),C(C1(U)),A,A,A,C(U)),A,C(U(U,U)))><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sgr81 w3_sgr82 w4_sgr83 w5_sgr84]
        case Data.Fixed.$wdivMod' w_sgr81 w3_sgr82 w4_sgr83 w5_sgr84 of {
          (#,#) ww1_sgr86 [Occ=Once] ww2_sgr87 [Occ=Once] ->
              (,) [ww1_sgr86 ww2_sgr87];
        };

Data.Fixed.mod' :: forall a. GHC.Real.Real a => a -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(LC(C(S))LLLLL)LL),U(1*U(A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,1*C1(U)),A,C(U(U,U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dReal_sgr88 eta_sgr89 eta1_sgr8a]
        case
            GHC.Real.$p1Real $dReal_sgr88
        of
        $dNum_sgr8b [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,1*C1(U))>]
        { __DEFAULT ->
              let {
                sat_sgr8e [Occ=Once] :: a_agnBF
                [LclId] =
                    [$dReal_sgr88 eta_sgr89 eta1_sgr8a $dNum_sgr8b] \u []
                        let {
                          sat_sgr8d [Occ=Once] :: a_agnBF
                          [LclId] =
                              [$dReal_sgr88 eta_sgr89 eta1_sgr8a $dNum_sgr8b] \u []
                                  let {
                                    sat_sgr8c [Occ=Once] :: GHC.Integer.Type.Integer
                                    [LclId] =
                                        [$dReal_sgr88 eta_sgr89 eta1_sgr8a] \u []
                                            Data.Fixed.div'
                                                $dReal_sgr88
                                                GHC.Real.$fIntegralInteger
                                                eta_sgr89
                                                eta1_sgr8a;
                                  } in  GHC.Num.fromInteger $dNum_sgr8b sat_sgr8c;
                        } in  GHC.Num.* $dNum_sgr8b sat_sgr8d eta1_sgr8a;
              } in  GHC.Num.- $dNum_sgr8b eta_sgr89 sat_sgr8e;
        };

Data.Fixed.$fFractionalFixed2 :: forall a. GHC.Types.Any a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined $dIP3_rgoyz;

Data.Fixed.$w$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sgr8f ww_sgr8g ww1_sgr8h]
        case w_sgr8f Data.Fixed.$fFractionalFixed2 of dt_sgr8i {
          __DEFAULT ->
              case
                  GHC.Integer.Type.timesInteger ww1_sgr8h GHC.Real.$fEnumRatio1
              of
              sat_sgr8k
              { __DEFAULT ->
                    case GHC.Integer.Type.timesInteger ww_sgr8g dt_sgr8i of sat_sgr8j {
                      __DEFAULT ->
                          case GHC.Real.$w$sreduce sat_sgr8j sat_sgr8k of {
                            (#,#) ww7_sgr8m [Occ=Once] ww8_sgr8n [Occ=Once] ->
                                GHC.Real.$w$s$cfloor
                                    GHC.Real.$fIntegralInteger ww7_sgr8m ww8_sgr8n;
                          };
                    };
              };
        };

Data.Fixed.$fFractionalFixed1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Real.Rational -> GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<C(S),1*C1(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgr8o w3_sgr8p]
        case w3_sgr8p of {
          GHC.Real.:% ww1_sgr8r [Occ=Once] ww2_sgr8s [Occ=Once] ->
              Data.Fixed.$w$cfromRational w_sgr8o ww1_sgr8r ww2_sgr8s;
        };

Data.Fixed.$fRealFixed_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a -> GHC.Real.Rational
[GblId, Arity=2, Str=<C(S),1*C1(U)><S,U>m, Unf=OtherCon []] =
    [] \r [w_sgr8t w3_sgr8u]
        case w_sgr8t w3_sgr8u of dt_sgr8v {
          __DEFAULT ->
              case
                  GHC.Real.$w$s$c/
                      w3_sgr8u GHC.Real.$fEnumRatio1 dt_sgr8v GHC.Real.$fEnumRatio1
              of
              { (#,#) ww1_sgr8x [Occ=Once] ww2_sgr8y [Occ=Once] ->
                    GHC.Real.:% [ww1_sgr8x ww2_sgr8y];
              };
        };

Data.Fixed.$fFractionalFixed3
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a
     -> Data.Fixed.Fixed a -> GHC.Integer.Type.Integer
[GblId, Arity=3, Str=<C(S),1*C1(U)><S,U><S,U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgr8z fa_sgr8A ds_sgr8B]
        case
            GHC.Integer.Type.eqInteger# ds_sgr8B Data.Fixed.$fEnumFixed1
        of
        { __DEFAULT ->
              case $dHasResolution_sgr8z fa_sgr8A of sat_sgr8D {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger fa_sgr8A sat_sgr8D
                    of
                    sat_sgr8E
                    { __DEFAULT -> GHC.Integer.Type.divInteger sat_sgr8E ds_sgr8B;
                    };
              };
          1# -> GHC.Real.divZeroError;
        };

Data.Fixed.$fFractionalFixed_$crecip
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a -> Data.Fixed.Fixed a
[GblId, Arity=2, Str=<C(S),1*C1(U)><S,U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgr8F fa_sgr8G]
        case
            GHC.Integer.Type.eqInteger# fa_sgr8G Data.Fixed.$fEnumFixed1
        of
        { __DEFAULT ->
              case $dHasResolution_sgr8F fa_sgr8G of res_sgr8I [Dmd=<S,U>] {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger res_sgr8I res_sgr8I
                    of
                    sat_sgr8J
                    { __DEFAULT -> GHC.Integer.Type.divInteger sat_sgr8J fa_sgr8G;
                    };
              };
          1# -> GHC.Real.divZeroError;
        };

Data.Fixed.$fNumFixed_$c*
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a -> Data.Fixed.Fixed a -> Data.Fixed.Fixed a
[GblId, Arity=3, Str=<C(S),1*C1(U)><S,U><S,1*U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgr8K fa_sgr8L ds_sgr8M]
        case $dHasResolution_sgr8K fa_sgr8L of ds1_sgr8N [Dmd=<S,U>] {
          __DEFAULT ->
              case
                  GHC.Integer.Type.eqInteger# ds1_sgr8N Data.Fixed.$fEnumFixed1
              of
              { __DEFAULT ->
                    case GHC.Integer.Type.timesInteger fa_sgr8L ds_sgr8M of sat_sgr8P {
                      __DEFAULT -> GHC.Integer.Type.divInteger sat_sgr8P ds1_sgr8N;
                    };
                1# -> GHC.Real.divZeroError;
              };
        };

Data.Fixed.$fNumFixed1
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<C(S),1*C1(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgr8Q i_sgr8R]
        case
            $dHasResolution_sgr8Q Data.Fixed.$fFractionalFixed2
        of
        sat_sgr8S
        { __DEFAULT -> GHC.Integer.Type.timesInteger i_sgr8R sat_sgr8S;
        };

Data.Fixed.$fNumFixed2
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<C(S),1*C1(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgr8T ds_sgr8U]
        case
            $dHasResolution_sgr8T Data.Fixed.$fFractionalFixed2
        of
        sat_sgr8W
        { __DEFAULT ->
              case GHC.Integer.Type.signumInteger ds_sgr8U of sat_sgr8V {
                __DEFAULT -> GHC.Integer.Type.timesInteger sat_sgr8V sat_sgr8W;
              };
        };

Data.Fixed.$fNumFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Num.Num (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgr8X]
        let {
          sat_sgr90 [Occ=Once]
            :: GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_XgnN5
          [LclId] =
              [$dHasResolution_sgr8X] \r [eta_B1]
                  Data.Fixed.$fNumFixed1 $dHasResolution_sgr8X eta_B1; } in
        let {
          sat_sgr8Z [Occ=Once]
            :: Data.Fixed.Fixed a_XgnN5 -> Data.Fixed.Fixed a_XgnN5
          [LclId] =
              [$dHasResolution_sgr8X] \r [eta_B1]
                  Data.Fixed.$fNumFixed2 $dHasResolution_sgr8X eta_B1; } in
        let {
          sat_sgr8Y [Occ=Once]
            :: Data.Fixed.Fixed a_XgnN5
               -> Data.Fixed.Fixed a_XgnN5 -> Data.Fixed.Fixed a_XgnN5
          [LclId] =
              [$dHasResolution_sgr8X] \r [eta_B2 eta_B1]
                  Data.Fixed.$fNumFixed_$c* $dHasResolution_sgr8X eta_B2 eta_B1;
        } in 
          GHC.Num.C:Num [GHC.Integer.Type.plusInteger
                         GHC.Integer.Type.minusInteger
                         sat_sgr8Y
                         GHC.Integer.Type.negateInteger
                         GHC.Integer.Type.absInteger
                         sat_sgr8Z
                         sat_sgr90];

Data.Fixed.$fFractionalFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Real.Fractional (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgr91]
        let {
          sat_sgr95 [Occ=Once]
            :: GHC.Real.Rational -> Data.Fixed.Fixed a_XgnLO
          [LclId] =
              [$dHasResolution_sgr91] \r [eta_B1]
                  Data.Fixed.$fFractionalFixed1 $dHasResolution_sgr91 eta_B1; } in
        let {
          sat_sgr94 [Occ=Once]
            :: Data.Fixed.Fixed a_XgnLO -> Data.Fixed.Fixed a_XgnLO
          [LclId] =
              [$dHasResolution_sgr91] \r [eta_B1]
                  Data.Fixed.$fFractionalFixed_$crecip
                      $dHasResolution_sgr91 eta_B1; } in
        let {
          sat_sgr93 [Occ=Once]
            :: Data.Fixed.Fixed a_XgnLO
               -> Data.Fixed.Fixed a_XgnLO -> Data.Fixed.Fixed a_XgnLO
          [LclId] =
              [$dHasResolution_sgr91] \r [eta_B2 eta_B1]
                  Data.Fixed.$fFractionalFixed3
                      $dHasResolution_sgr91 eta_B2 eta_B1; } in
        let {
          sat_sgr92 [Occ=Once] :: GHC.Num.Num (Data.Fixed.Fixed a_XgnLO)
          [LclId] =
              [$dHasResolution_sgr91] \u []
                  Data.Fixed.$fNumFixed $dHasResolution_sgr91;
        } in 
          GHC.Real.C:Fractional [sat_sgr92 sat_sgr93 sat_sgr94 sat_sgr95];

Data.Fixed.$fReadFixed2 :: GHC.Types.Double
[GblId] =
    [] \u []
        case logDouble# [10.0##] of v_sgr96 {
          __DEFAULT -> GHC.Types.D# [v_sgr96];
        };

lvl9_rgoyO :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [172#];

lvl10_rgoyP :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [27#];

lvl11_rgoyQ :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [36#];

lvl12_rgoyR :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [loc_rgoyp
                                           loc1_rgoyq
                                           loc3_rgoys
                                           lvl9_rgoyO
                                           lvl10_rgoyP
                                           lvl9_rgoyO
                                           lvl11_rgoyQ];

lvl13_rgoyS :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [$dIP1_rgoyx
                                                  lvl12_rgoyR
                                                  GHC.Stack.Types.EmptyCallStack];

Data.Fixed.$fReadFixed3 :: forall a. Data.Fixed.Fixed a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined lvl13_rgoyS;

Data.Fixed.$fReadFixed1
  :: forall a.
     Data.Fixed.HasResolution a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Fixed.Fixed a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgr97]
        let {
          lvl17_sgr98 :: GHC.Integer.Type.Integer
          [LclId] =
              [$dHasResolution_sgr97] \u []
                  $dHasResolution_sgr97 Data.Fixed.$fFractionalFixed2; } in
        let {
          e_sgr99 :: GHC.Integer.Type.Integer
          [LclId] =
              [$dHasResolution_sgr97] \u []
                  case $dHasResolution_sgr97 Data.Fixed.$fReadFixed3 of sat_sgr9a {
                    __DEFAULT ->
                        case GHC.Integer.Type.doubleFromInteger sat_sgr9a of wild_sgr9b {
                          __DEFAULT ->
                              case logDouble# [wild_sgr9b] of wild1_sgr9c {
                                __DEFAULT ->
                                    case Data.Fixed.$fReadFixed2 of {
                                      GHC.Types.D# v1_sgr9e [Occ=Once] ->
                                          case /## [wild1_sgr9c v1_sgr9e] of wild4_sgr9f {
                                            __DEFAULT ->
                                                case negateDouble# [wild4_sgr9f] of sat_sgr9g {
                                                  __DEFAULT ->
                                                      case
                                                          GHC.Integer.Type.decodeDoubleInteger
                                                              sat_sgr9g
                                                      of
                                                      { (#,#) ipv_sgr9i [Occ=Once*] ipv1_sgr9j ->
                                                            case <# [ipv1_sgr9j 0#] of {
                                                              __DEFAULT ->
                                                                  case
                                                                      GHC.Integer.Type.shiftLInteger
                                                                          ipv_sgr9i ipv1_sgr9j
                                                                  of
                                                                  sat_sgr9l
                                                                  { __DEFAULT ->
                                                                        GHC.Integer.Type.negateInteger
                                                                            sat_sgr9l;
                                                                  };
                                                              1# ->
                                                                  case
                                                                      negateInt# [ipv1_sgr9j]
                                                                  of
                                                                  s_sgr9m [Dmd=<S,U>]
                                                                  { __DEFAULT ->
                                                                        case ># [s_sgr9m 52#] of {
                                                                          __DEFAULT ->
                                                                              case
                                                                                  GHC.Integer.Type.integerToInt
                                                                                      ipv_sgr9i
                                                                              of
                                                                              n_sgr9o
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        uncheckedIShiftRA# [n_sgr9o
                                                                                                            s_sgr9m]
                                                                                    of
                                                                                    sat_sgr9p
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              GHC.Integer.Type.smallInteger
                                                                                                  sat_sgr9p
                                                                                          of
                                                                                          sat_sgr9q
                                                                                          { __DEFAULT ->
                                                                                                GHC.Integer.Type.negateInteger
                                                                                                    sat_sgr9q;
                                                                                          };
                                                                                    };
                                                                              };
                                                                          1# ->
                                                                              case
                                                                                  GHC.Integer.Type.ltInteger#
                                                                                      ipv_sgr9i
                                                                                      Data.Fixed.$fEnumFixed1
                                                                              of
                                                                              { __DEFAULT ->
                                                                                    Data.Fixed.$fEnumFixed1;
                                                                                1# ->
                                                                                    Data.Fixed.$fEnumFixed2;
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                        };
                  }; } in
        let {
          lvl18_sgr9s [Occ=OnceL] :: Data.Fixed.Fixed a_agnFb
          [LclId] =
              [$dHasResolution_sgr97 e_sgr99] \u []
                  let {
                    sat_sgr9v [Occ=Once] :: Data.Fixed.Fixed a_agnFb
                    [LclId] =
                        [$dHasResolution_sgr97] \u []
                            case
                                $dHasResolution_sgr97 Data.Fixed.$fFractionalFixed2
                            of
                            sat_sgr9u
                            { __DEFAULT ->
                                  GHC.Integer.Type.timesInteger
                                      Data.Fixed.$fHasResolutionE4 sat_sgr9u;
                            }; } in
                  let {
                    sat_sgr9t [Occ=Once, Dmd=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))>]
                      :: GHC.Num.Num (Data.Fixed.Fixed a_agnFb)
                    [LclId] =
                        [$dHasResolution_sgr97] \u []
                            Data.Fixed.$fNumFixed $dHasResolution_sgr97;
                  } in 
                    GHC.Real.^
                        sat_sgr9t GHC.Real.$fIntegralInteger sat_sgr9v e_sgr99; } in
        let {
          sat_sgr9M [Occ=Once]
            :: Text.Read.Lex.Lexeme
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Fixed.Fixed a_agnFb)
          [LclId] =
              [$dHasResolution_sgr97
               lvl17_sgr98
               e_sgr99
               lvl18_sgr9s] \r [ds_sgr9x]
                  case ds_sgr9x of {
                    __DEFAULT ->
                        Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4;
                    Text.Read.Lex.Number n_sgr9z [Occ=Once] ->
                        case Text.Read.Lex.numberToFixed e_sgr99 n_sgr9z of {
                          GHC.Base.Nothing ->
                              Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4;
                          GHC.Base.Just ds1_sgr9B [Occ=Once!] ->
                              case ds1_sgr9B of {
                                (,) i_sgr9D [Occ=Once] f_sgr9E [Occ=Once] ->
                                    let {
                                      x_sgr9F [Occ=OnceL] :: GHC.Integer.Type.Integer
                                      [LclId] =
                                          [$dHasResolution_sgr97
                                           lvl17_sgr98
                                           lvl18_sgr9s
                                           i_sgr9D
                                           f_sgr9E] \u []
                                              case
                                                  GHC.Integer.Type.timesInteger f_sgr9E lvl17_sgr98
                                              of
                                              sat_sgr9H
                                              { __DEFAULT ->
                                                    case
                                                        Data.Fixed.$fFractionalFixed3
                                                            $dHasResolution_sgr97
                                                            sat_sgr9H
                                                            lvl18_sgr9s
                                                    of
                                                    sat_sgr9I
                                                    { __DEFAULT ->
                                                          case
                                                              GHC.Integer.Type.timesInteger
                                                                  i_sgr9D lvl17_sgr98
                                                          of
                                                          sat_sgr9G
                                                          { __DEFAULT ->
                                                                GHC.Integer.Type.plusInteger
                                                                    sat_sgr9G sat_sgr9I;
                                                          };
                                                    };
                                              }; } in
                                    let {
                                      sat_sgr9L [Occ=Once]
                                        :: Text.ParserCombinators.ReadPrec.Prec
                                           -> forall b.
                                              (Data.Fixed.Fixed a_agnFb
                                               -> Text.ParserCombinators.ReadP.P b)
                                              -> Text.ParserCombinators.ReadP.P b
                                      [LclId] =
                                          [x_sgr9F] \r [ds2_sgr9J k_sgr9K] k_sgr9K x_sgr9F;
                                    } in  sat_sgr9L;
                              };
                        };
                  }; } in
        let {
          sat_sgr9w [Occ=Once] :: GHC.Num.Num (Data.Fixed.Fixed a_agnFb)
          [LclId] =
              [$dHasResolution_sgr97] \u []
                  Data.Fixed.$fNumFixed $dHasResolution_sgr97;
        } in  GHC.Read.readNumber1 sat_sgr9w sat_sgr9M;

Data.Fixed.$fReadFixed_$creadsPrec
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Fixed.Fixed a)
[GblId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgr9N]
        let {
          ds_sgr9O [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Fixed.Fixed a_XgnJE -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dHasResolution_sgr9N] \u []
                  Data.Fixed.$fReadFixed1 $dHasResolution_sgr9N; } in
        let {
          sat_sgr9R [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Fixed.Fixed a_XgnJE)
          [LclId] =
              [ds_sgr9O] \r [n_sgr9P]
                  let {
                    sat_sgr9Q [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (Data.Fixed.Fixed a_XgnJE)
                    [LclId] =
                        [ds_sgr9O n_sgr9P] \u []
                            ds_sgr9O
                                n_sgr9P Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sgr9Q;
        } in  sat_sgr9R;

Data.Fixed.$fReadFixed_$creadListPrec
  :: forall a.
     Data.Fixed.HasResolution a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Fixed.Fixed a]
[GblId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgr9S]
        let {
          sat_sgr9T [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Fixed.Fixed a_XgnJC)
          [LclId] =
              [$dHasResolution_sgr9S] \s []
                  Data.Fixed.$fReadFixed1 $dHasResolution_sgr9S;
        } in  GHC.Read.list sat_sgr9T;

Data.Fixed.$fReadFixed_$creadList
  :: forall a.
     Data.Fixed.HasResolution a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Fixed.Fixed a]
[GblId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgr9U]
        let {
          sat_sgr9W [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Fixed.Fixed a_XgnJD]
          [LclId] =
              [$dHasResolution_sgr9U] \u []
                  let {
                    sat_sgr9V [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Fixed.Fixed a_XgnJD)
                    [LclId] =
                        [$dHasResolution_sgr9U] \s []
                            Data.Fixed.$fReadFixed1 $dHasResolution_sgr9U;
                  } in 
                    GHC.Read.list
                        sat_sgr9V
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sgr9W;

Data.Fixed.$fReadFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Read.Read (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgr9X]
        let {
          sat_sgra1 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Fixed.Fixed a_XgnJB]
          [LclId] =
              [$dHasResolution_sgr9X] \u []
                  Data.Fixed.$fReadFixed_$creadListPrec $dHasResolution_sgr9X; } in
        let {
          sat_sgra0 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Fixed.Fixed a_XgnJB)
          [LclId] =
              [$dHasResolution_sgr9X] \u []
                  Data.Fixed.$fReadFixed1 $dHasResolution_sgr9X; } in
        let {
          sat_sgr9Z [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Fixed.Fixed a_XgnJB]
          [LclId] =
              [$dHasResolution_sgr9X] \u []
                  Data.Fixed.$fReadFixed_$creadList $dHasResolution_sgr9X; } in
        let {
          sat_sgr9Y [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Fixed.Fixed a_XgnJB)
          [LclId] =
              [$dHasResolution_sgr9X] \u []
                  Data.Fixed.$fReadFixed_$creadsPrec $dHasResolution_sgr9X;
        } in  GHC.Read.C:Read [sat_sgr9Y sat_sgr9Z sat_sgra0 sat_sgra1];

Data.Fixed.$fEqFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Classes.Eq (Data.Fixed.Fixed a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [GHC.Integer.Type.eqInteger
                                     GHC.Integer.Type.neqInteger];

Data.Fixed.$fOrdFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Classes.Ord (Data.Fixed.Fixed a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Fixed.$fEqFixed
                                      GHC.Integer.Type.compareInteger
                                      GHC.Integer.Type.ltInteger
                                      GHC.Integer.Type.leInteger
                                      GHC.Integer.Type.gtInteger
                                      GHC.Integer.Type.geInteger
                                      GHC.Integer.Type.$fOrdInteger_$cmax
                                      GHC.Integer.Type.$fOrdInteger_$cmin];

Data.Fixed.$fRealFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Real.Real (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgra2]
        let {
          sat_sgra4 [Occ=Once]
            :: Data.Fixed.Fixed a_agnIn -> GHC.Real.Rational
          [LclId] =
              [$dHasResolution_sgra2] \r [eta_B1]
                  Data.Fixed.$fRealFixed_$ctoRational
                      $dHasResolution_sgra2 eta_B1; } in
        let {
          sat_sgra3 [Occ=Once] :: GHC.Num.Num (Data.Fixed.Fixed a_agnIn)
          [LclId] =
              [$dHasResolution_sgra2] \u []
                  Data.Fixed.$fNumFixed $dHasResolution_sgra2;
        } in  GHC.Real.C:Real [sat_sgra3 Data.Fixed.$fOrdFixed sat_sgra4];

Data.Fixed.$fRealFracFixed_$ctruncate
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b. GHC.Real.Integral b => Data.Fixed.Fixed a -> b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dHasResolution_sgra5 $dIntegral_sgra6 f_sgra7]
        case $dHasResolution_sgra5 f_sgra7 of dt_sgra8 {
          __DEFAULT ->
              case
                  GHC.Real.$w$s$c/
                      f_sgra7 GHC.Real.$fEnumRatio1 dt_sgra8 GHC.Real.$fEnumRatio1
              of
              { (#,#) ww7_sgraa [Occ=Once] ww8_sgrab ->
                    let {
                      sat_sgraj [Occ=Once] :: GHC.Integer.Type.Integer
                      [LclId] =
                          [ww7_sgraa ww8_sgrab] \u []
                              case
                                  GHC.Integer.Type.eqInteger# ww8_sgrab Data.Fixed.$fEnumFixed1
                              of
                              { __DEFAULT ->
                                    case GHC.Integer.Type.quotRemInteger ww7_sgraa ww8_sgrab of {
                                      (#,#) ipv_sgrag [Occ=Once] _ [Occ=Dead] -> ipv_sgrag;
                                    };
                                1# -> GHC.Real.divZeroError;
                              };
                    } in 
                      case GHC.Real.$p1Integral $dIntegral_sgra6 of sat_sgrac {
                        __DEFAULT ->
                            case GHC.Real.$p1Real sat_sgrac of sat_sgrad {
                              __DEFAULT -> GHC.Num.fromInteger sat_sgrad sat_sgraj;
                            };
                      };
              };
        };

Data.Fixed.$fRealFracFixed_$cround
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b. GHC.Real.Integral b => Data.Fixed.Fixed a -> b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,U(U(U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dHasResolution_sgrak $dIntegral_sgral f_sgram]
        case $dHasResolution_sgrak f_sgram of dt_sgran {
          __DEFAULT ->
              case
                  GHC.Real.$w$s$c/
                      f_sgram GHC.Real.$fEnumRatio1 dt_sgran GHC.Real.$fEnumRatio1
              of
              { (#,#) ww7_sgrap [Occ=Once] ww8_sgraq [Occ=Once] ->
                    GHC.Real.$w$s$cround $dIntegral_sgral ww7_sgrap ww8_sgraq;
              };
        };

Data.Fixed.$fRealFracFixed_$cceiling
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b. GHC.Real.Integral b => Data.Fixed.Fixed a -> b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,U(U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dHasResolution_sgrar $dIntegral_sgras f_sgrat]
        case $dHasResolution_sgrar f_sgrat of dt_sgrau {
          __DEFAULT ->
              case
                  GHC.Real.$w$s$c/
                      f_sgrat GHC.Real.$fEnumRatio1 dt_sgrau GHC.Real.$fEnumRatio1
              of
              { (#,#) ww7_sgraw [Occ=Once] ww8_sgrax [Occ=Once] ->
                    GHC.Real.$w$s$cceiling $dIntegral_sgras ww7_sgraw ww8_sgrax;
              };
        };

Data.Fixed.$fRealFracFixed_$cfloor
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b. GHC.Real.Integral b => Data.Fixed.Fixed a -> b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dHasResolution_sgray $dIntegral_sgraz f_sgraA]
        case $dHasResolution_sgray f_sgraA of dt_sgraB {
          __DEFAULT ->
              case
                  GHC.Real.$w$s$c/
                      f_sgraA GHC.Real.$fEnumRatio1 dt_sgraB GHC.Real.$fEnumRatio1
              of
              { (#,#) ww7_sgraD [Occ=Once] ww8_sgraE [Occ=Once] ->
                    GHC.Real.$w$s$cfloor $dIntegral_sgraz ww7_sgraD ww8_sgraE;
              };
        };

Data.Fixed.$w$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b.
     GHC.Real.Integral b =>
     Data.Fixed.Fixed a -> (# b, Data.Fixed.Fixed a #)
[GblId,
 Arity=3,
 Str=<L,C(U)><L,U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgraF w3_sgraG w4_sgraH]
        let {
          i_sgraI :: b_sgooh
          [LclId] =
              [w_sgraF w3_sgraG w4_sgraH] \u []
                  Data.Fixed.$fRealFracFixed_$ctruncate
                      w_sgraF w3_sgraG w4_sgraH; } in
        let {
          sat_sgraM [Occ=Once] :: Data.Fixed.Fixed a_sgoof
          [LclId] =
              [w_sgraF w3_sgraG w4_sgraH i_sgraI] \u []
                  case w_sgraF Data.Fixed.$fFractionalFixed2 of sat_sgraK {
                    __DEFAULT ->
                        case GHC.Real.toInteger w3_sgraG i_sgraI of sat_sgraJ {
                          __DEFAULT ->
                              case
                                  GHC.Integer.Type.timesInteger sat_sgraJ sat_sgraK
                              of
                              sat_sgraL
                              { __DEFAULT -> GHC.Integer.Type.minusInteger w4_sgraH sat_sgraL;
                              };
                        };
                  };
        } in  (#,#) [i_sgraI sat_sgraM];

Data.Fixed.$fRealFracFixed_$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b.
     GHC.Real.Integral b =>
     Data.Fixed.Fixed a -> (b, Data.Fixed.Fixed a)
[GblId,
 Arity=3,
 Str=<L,C(U)><L,U(U(U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sgraN w3_sgraO w4_sgraP]
        case Data.Fixed.$w$cproperFraction w_sgraN w3_sgraO w4_sgraP of {
          (#,#) ww1_sgraR [Occ=Once] ww2_sgraS [Occ=Once] ->
              (,) [ww1_sgraR ww2_sgraS];
        };

Data.Fixed.$fRealFracFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Real.RealFrac (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgraT]
        let {
          sat_sgrb0 [Occ=Once]
            :: forall b. GHC.Real.Integral b => Data.Fixed.Fixed a_agnG0 -> b
          [LclId] =
              [$dHasResolution_sgraT] \r [eta_B2 eta_B1]
                  Data.Fixed.$fRealFracFixed_$cfloor
                      $dHasResolution_sgraT eta_B2 eta_B1; } in
        let {
          sat_sgraZ [Occ=Once]
            :: forall b. GHC.Real.Integral b => Data.Fixed.Fixed a_agnG0 -> b
          [LclId] =
              [$dHasResolution_sgraT] \r [eta_B2 eta_B1]
                  Data.Fixed.$fRealFracFixed_$cceiling
                      $dHasResolution_sgraT eta_B2 eta_B1; } in
        let {
          sat_sgraY [Occ=Once]
            :: forall b. GHC.Real.Integral b => Data.Fixed.Fixed a_agnG0 -> b
          [LclId] =
              [$dHasResolution_sgraT] \r [eta_B2 eta_B1]
                  Data.Fixed.$fRealFracFixed_$cround
                      $dHasResolution_sgraT eta_B2 eta_B1; } in
        let {
          sat_sgraX [Occ=Once]
            :: forall b. GHC.Real.Integral b => Data.Fixed.Fixed a_agnG0 -> b
          [LclId] =
              [$dHasResolution_sgraT] \r [eta_B2 eta_B1]
                  Data.Fixed.$fRealFracFixed_$ctruncate
                      $dHasResolution_sgraT eta_B2 eta_B1; } in
        let {
          sat_sgraW [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Fixed.Fixed a_agnG0 -> (b, Data.Fixed.Fixed a_agnG0)
          [LclId] =
              [$dHasResolution_sgraT] \r [eta_B2 eta_B1]
                  Data.Fixed.$fRealFracFixed_$cproperFraction
                      $dHasResolution_sgraT eta_B2 eta_B1; } in
        let {
          sat_sgraV [Occ=Once]
            :: GHC.Real.Fractional (Data.Fixed.Fixed a_agnG0)
          [LclId] =
              [$dHasResolution_sgraT] \u []
                  Data.Fixed.$fFractionalFixed $dHasResolution_sgraT; } in
        let {
          sat_sgraU [Occ=Once] :: GHC.Real.Real (Data.Fixed.Fixed a_agnG0)
          [LclId] =
              [$dHasResolution_sgraT] \u []
                  Data.Fixed.$fRealFixed $dHasResolution_sgraT;
        } in 
          GHC.Real.C:RealFrac [sat_sgraU
                               sat_sgraV
                               sat_sgraW
                               sat_sgraX
                               sat_sgraY
                               sat_sgraZ
                               sat_sgrb0];

chopZeros_rgnn4 :: GHC.Integer.Type.Integer -> GHC.Base.String
[GblId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
    sat-only [] \r [ds_sgrb1]
        case
            GHC.Integer.Type.eqInteger# ds_sgrb1 Data.Fixed.$fEnumFixed1
        of
        { __DEFAULT ->
              case
                  GHC.Integer.Type.modInteger ds_sgrb1 Data.Fixed.$fHasResolutionE4
              of
              sat_sgrb3
              { __DEFAULT ->
                    case
                        GHC.Integer.Type.eqInteger# sat_sgrb3 Data.Fixed.$fEnumFixed1
                    of
                    { __DEFAULT -> GHC.Show.$fShowInteger_$cshow ds_sgrb1;
                      1# ->
                          case
                              GHC.Integer.Type.divInteger ds_sgrb1 Data.Fixed.$fHasResolutionE4
                          of
                          sat_sgrb5
                          { __DEFAULT -> chopZeros_rgnn4 sat_sgrb5;
                          };
                    };
              };
          1# -> [] [];
        };

lvl14_rgoyT :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! ['0'#];

lvl15_rgoyU :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! ['.'#];

lvl16_rgoyV :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "-"#;

Data.Fixed.showFixed [Occ=LoopBreaker]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Types.Bool -> Data.Fixed.Fixed a -> GHC.Base.String
[GblId, Arity=3, Str=<L,1*C1(U)><L,U><S,U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgrb6 chopTrailingZeros_sgrb7 fa_sgrb8]
        case
            GHC.Integer.Type.ltInteger# fa_sgrb8 Data.Fixed.$fEnumFixed1
        of
        { __DEFAULT ->
              case $dHasResolution_sgrb6 fa_sgrb8 of res_sgrba [Dmd=<S,U>] {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.eqInteger# res_sgrba Data.Fixed.$fEnumFixed1
                    of
                    { __DEFAULT ->
                          case GHC.Integer.Type.divModInteger fa_sgrb8 res_sgrba of {
                            (#,#) ipv_sgrbd [Occ=Once] ipv1_sgrbe [Occ=Once*] ->
                                case GHC.Show.$w$cshowsPrec4 0# ipv_sgrbd GHC.Types.[] of {
                                  (#,#) ww3_sgrbg [Occ=Once] ww4_sgrbh [Occ=Once] ->
                                      let {
                                        sat_sgrc8 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                        [LclId] =
                                            [chopTrailingZeros_sgrb7 res_sgrba ipv1_sgrbe] \s []
                                                case
                                                    GHC.Integer.Type.doubleFromInteger res_sgrba
                                                of
                                                wild2_sgrbj
                                                { __DEFAULT ->
                                                      case logDouble# [wild2_sgrbj] of wild3_sgrbk {
                                                        __DEFAULT ->
                                                            case Data.Fixed.$fReadFixed2 of {
                                                              GHC.Types.D# v1_sgrbm [Occ=Once] ->
                                                                  case
                                                                      /## [wild3_sgrbk v1_sgrbm]
                                                                  of
                                                                  wild4_sgrbn
                                                                  { __DEFAULT ->
                                                                        case
                                                                            double2Int# [wild4_sgrbn]
                                                                        of
                                                                        n_sgrbo [Dmd=<S,U>]
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  int2Double# [n_sgrbo]
                                                                              of
                                                                              sat_sgrc5
                                                                              { __DEFAULT ->
                                                                                    let-no-escape {
                                                                                      $j_sgrbp [Occ=Once*!T[1],
                                                                                                Dmd=<C(S),1*C1(U)>]
                                                                                        :: GHC.Prim.Int#
                                                                                           -> [GHC.Types.Char]
                                                                                      [LclId[JoinId(1)],
                                                                                       Arity=1,
                                                                                       Str=<S,U>,
                                                                                       Unf=OtherCon []] =
                                                                                          sat-only [chopTrailingZeros_sgrb7
                                                                                                    res_sgrba
                                                                                                    ipv1_sgrbe] \r [ww_sgrbq]
                                                                                              case
                                                                                                  <# [ww_sgrbq
                                                                                                      0#]
                                                                                              of
                                                                                              { __DEFAULT ->
                                                                                                    let-no-escape {
                                                                                                      $j1_sgrbs [Occ=Once*!T[1],
                                                                                                                 Dmd=<C(S),1*C1(U)>]
                                                                                                        :: GHC.Integer.Type.Integer
                                                                                                           -> [GHC.Types.Char]
                                                                                                      [LclId[JoinId(1)],
                                                                                                       Arity=1,
                                                                                                       Str=<S,U>,
                                                                                                       Unf=OtherCon []] =
                                                                                                          sat-only [chopTrailingZeros_sgrb7
                                                                                                                    ww_sgrbq] \r [ds_sgrbt]
                                                                                                              let-no-escape {
                                                                                                                fail_sgrbu [Occ=Once*!T[1],
                                                                                                                            Dmd=<L,1*C1(U)>]
                                                                                                                  :: GHC.Prim.Void#
                                                                                                                     -> [GHC.Types.Char]
                                                                                                                [LclId[JoinId(1)],
                                                                                                                 Arity=1,
                                                                                                                 Str=<L,A>,
                                                                                                                 Unf=OtherCon []] =
                                                                                                                    sat-only [chopTrailingZeros_sgrb7
                                                                                                                              ww_sgrbq
                                                                                                                              ds_sgrbt] \r [ds1_sgrbv]
                                                                                                                        case
                                                                                                                            GHC.Show.$w$cshowsPrec4
                                                                                                                                0#
                                                                                                                                ds_sgrbt
                                                                                                                                GHC.Types.[]
                                                                                                                        of
                                                                                                                        { (#,#) ww5_sgrbx [Occ=OnceL]
                                                                                                                                ww6_sgrby [Occ=OnceL] ->
                                                                                                                              let {
                                                                                                                                s_sgrbz [Dmd=<S,U>]
                                                                                                                                  :: GHC.Base.String
                                                                                                                                [LclId,
                                                                                                                                 Unf=OtherCon []] =
                                                                                                                                    CCCS :! [ww5_sgrbx
                                                                                                                                             ww6_sgrby];
                                                                                                                              } in 
                                                                                                                                case
                                                                                                                                    GHC.List.$wlenAcc
                                                                                                                                        s_sgrbz
                                                                                                                                        0#
                                                                                                                                of
                                                                                                                                ww7_sgrbA
                                                                                                                                { __DEFAULT ->
                                                                                                                                      case
                                                                                                                                          -# [ww_sgrbq
                                                                                                                                              ww7_sgrbA]
                                                                                                                                      of
                                                                                                                                      y_sgrbB [Dmd=<S,U>]
                                                                                                                                      { __DEFAULT ->
                                                                                                                                            case
                                                                                                                                                <# [0#
                                                                                                                                                    y_sgrbB]
                                                                                                                                            of
                                                                                                                                            { __DEFAULT ->
                                                                                                                                                  case
                                                                                                                                                      chopTrailingZeros_sgrb7
                                                                                                                                                  of
                                                                                                                                                  { GHC.Types.False ->
                                                                                                                                                        : [lvl15_rgoyU
                                                                                                                                                           s_sgrbz];
                                                                                                                                                    GHC.Types.True ->
                                                                                                                                                        case
                                                                                                                                                            chopZeros_rgnn4
                                                                                                                                                                ds_sgrbt
                                                                                                                                                        of
                                                                                                                                                        wild6_sgrbE
                                                                                                                                                        { [] ->
                                                                                                                                                              [] [];
                                                                                                                                                          : _ [Occ=Dead]
                                                                                                                                                            _ [Occ=Dead] ->
                                                                                                                                                              : [lvl15_rgoyU
                                                                                                                                                                 wild6_sgrbE];
                                                                                                                                                        };
                                                                                                                                                  };
                                                                                                                                              1# ->
                                                                                                                                                  let {
                                                                                                                                                    n1_sgrbH [Occ=OnceL]
                                                                                                                                                      :: [GHC.Types.Char]
                                                                                                                                                    [LclId] =
                                                                                                                                                        [chopTrailingZeros_sgrb7
                                                                                                                                                         ds_sgrbt
                                                                                                                                                         s_sgrbz] \u []
                                                                                                                                                            case
                                                                                                                                                                chopTrailingZeros_sgrb7
                                                                                                                                                            of
                                                                                                                                                            { GHC.Types.False ->
                                                                                                                                                                  s_sgrbz;
                                                                                                                                                              GHC.Types.True ->
                                                                                                                                                                  chopZeros_rgnn4
                                                                                                                                                                      ds_sgrbt;
                                                                                                                                                            }; } in
                                                                                                                                                  let {
                                                                                                                                                    lvl17_sgrbJ [Occ=OnceL]
                                                                                                                                                      :: [GHC.Types.Char]
                                                                                                                                                    [LclId,
                                                                                                                                                     Unf=OtherCon []] =
                                                                                                                                                        CCCS :! [lvl14_rgoyT
                                                                                                                                                                 n1_sgrbH]; } in
                                                                                                                                                  let {
                                                                                                                                                    $wxs_sgrbK [InlPrag=NOUSERINLINE[0],
                                                                                                                                                                Occ=LoopBreaker]
                                                                                                                                                      :: GHC.Prim.Int#
                                                                                                                                                         -> [GHC.Types.Char]
                                                                                                                                                    [LclId,
                                                                                                                                                     Arity=1,
                                                                                                                                                     Str=<S,1*U>,
                                                                                                                                                     Unf=OtherCon []] =
                                                                                                                                                        sat-only [lvl17_sgrbJ
                                                                                                                                                                  $wxs_sgrbK] \r [ww8_sgrbL]
                                                                                                                                                            case
                                                                                                                                                                ww8_sgrbL
                                                                                                                                                            of
                                                                                                                                                            ds3_sgrbM
                                                                                                                                                            { __DEFAULT ->
                                                                                                                                                                  let {
                                                                                                                                                                    sat_sgrbO [Occ=Once]
                                                                                                                                                                      :: [GHC.Types.Char]
                                                                                                                                                                    [LclId] =
                                                                                                                                                                        [$wxs_sgrbK
                                                                                                                                                                         ds3_sgrbM] \u []
                                                                                                                                                                            case
                                                                                                                                                                                -# [ds3_sgrbM
                                                                                                                                                                                    1#]
                                                                                                                                                                            of
                                                                                                                                                                            sat_sgrbN
                                                                                                                                                                            { __DEFAULT ->
                                                                                                                                                                                  $wxs_sgrbK
                                                                                                                                                                                      sat_sgrbN;
                                                                                                                                                                            };
                                                                                                                                                                  } in 
                                                                                                                                                                    : [lvl14_rgoyT
                                                                                                                                                                       sat_sgrbO];
                                                                                                                                                              1# ->
                                                                                                                                                                  lvl17_sgrbJ;
                                                                                                                                                            };
                                                                                                                                                  } in 
                                                                                                                                                    case
                                                                                                                                                        $wxs_sgrbK
                                                                                                                                                            y_sgrbB
                                                                                                                                                    of
                                                                                                                                                    wild5_sgrbP
                                                                                                                                                    { [] ->
                                                                                                                                                          [] [];
                                                                                                                                                      : _ [Occ=Dead]
                                                                                                                                                        _ [Occ=Dead] ->
                                                                                                                                                          : [lvl15_rgoyU
                                                                                                                                                             wild5_sgrbP];
                                                                                                                                                    };
                                                                                                                                            };
                                                                                                                                      };
                                                                                                                                };
                                                                                                                        };
                                                                                                              } in 
                                                                                                                case
                                                                                                                    chopTrailingZeros_sgrb7
                                                                                                                of
                                                                                                                { GHC.Types.False ->
                                                                                                                      fail_sgrbu
                                                                                                                          GHC.Prim.void#;
                                                                                                                  GHC.Types.True ->
                                                                                                                      case
                                                                                                                          GHC.Integer.Type.eqInteger#
                                                                                                                              ds_sgrbt
                                                                                                                              Data.Fixed.$fEnumFixed1
                                                                                                                      of
                                                                                                                      { __DEFAULT ->
                                                                                                                            fail_sgrbu
                                                                                                                                GHC.Prim.void#;
                                                                                                                        1# ->
                                                                                                                            [] [];
                                                                                                                      };
                                                                                                                };
                                                                                                    } in 
                                                                                                      case
                                                                                                          ww_sgrbq
                                                                                                      of
                                                                                                      wild5_sgrbU
                                                                                                      { __DEFAULT ->
                                                                                                            case
                                                                                                                GHC.Real.$wf
                                                                                                                    Data.Fixed.$fHasResolutionE4
                                                                                                                    wild5_sgrbU
                                                                                                            of
                                                                                                            sat_sgrbV
                                                                                                            { __DEFAULT ->
                                                                                                                  case
                                                                                                                      GHC.Integer.Type.timesInteger
                                                                                                                          ipv1_sgrbe
                                                                                                                          sat_sgrbV
                                                                                                                  of
                                                                                                                  sat_sgrbW
                                                                                                                  { __DEFAULT ->
                                                                                                                        case
                                                                                                                            GHC.Integer.Type.plusInteger
                                                                                                                                sat_sgrbW
                                                                                                                                res_sgrba
                                                                                                                        of
                                                                                                                        sat_sgrbX
                                                                                                                        { __DEFAULT ->
                                                                                                                              case
                                                                                                                                  GHC.Integer.Type.minusInteger
                                                                                                                                      sat_sgrbX
                                                                                                                                      Data.Fixed.$fEnumFixed2
                                                                                                                              of
                                                                                                                              sat_sgrbY
                                                                                                                              { __DEFAULT ->
                                                                                                                                    case
                                                                                                                                        GHC.Integer.Type.divInteger
                                                                                                                                            sat_sgrbY
                                                                                                                                            res_sgrba
                                                                                                                                    of
                                                                                                                                    sat_sgrbZ
                                                                                                                                    { __DEFAULT ->
                                                                                                                                          $j1_sgrbs
                                                                                                                                              sat_sgrbZ;
                                                                                                                                    };
                                                                                                                              };
                                                                                                                        };
                                                                                                                  };
                                                                                                            };
                                                                                                        0# ->
                                                                                                            case
                                                                                                                GHC.Integer.Type.timesInteger
                                                                                                                    ipv1_sgrbe
                                                                                                                    GHC.Real.$fEnumRatio1
                                                                                                            of
                                                                                                            sat_sgrc0
                                                                                                            { __DEFAULT ->
                                                                                                                  case
                                                                                                                      GHC.Integer.Type.plusInteger
                                                                                                                          sat_sgrc0
                                                                                                                          res_sgrba
                                                                                                                  of
                                                                                                                  sat_sgrc1
                                                                                                                  { __DEFAULT ->
                                                                                                                        case
                                                                                                                            GHC.Integer.Type.minusInteger
                                                                                                                                sat_sgrc1
                                                                                                                                Data.Fixed.$fEnumFixed2
                                                                                                                        of
                                                                                                                        sat_sgrc2
                                                                                                                        { __DEFAULT ->
                                                                                                                              case
                                                                                                                                  GHC.Integer.Type.divInteger
                                                                                                                                      sat_sgrc2
                                                                                                                                      res_sgrba
                                                                                                                              of
                                                                                                                              sat_sgrc3
                                                                                                                              { __DEFAULT ->
                                                                                                                                    $j1_sgrbs
                                                                                                                                        sat_sgrc3;
                                                                                                                              };
                                                                                                                        };
                                                                                                                  };
                                                                                                            };
                                                                                                      };
                                                                                                1# ->
                                                                                                    GHC.Real.^1;
                                                                                              };
                                                                                    } in 
                                                                                      case
                                                                                          <## [sat_sgrc5
                                                                                               wild4_sgrbn]
                                                                                      of
                                                                                      { __DEFAULT ->
                                                                                            $j_sgrbp
                                                                                                n_sgrbo;
                                                                                        1# ->
                                                                                            case
                                                                                                +# [n_sgrbo
                                                                                                    1#]
                                                                                            of
                                                                                            sat_sgrc7
                                                                                            { __DEFAULT ->
                                                                                                  $j_sgrbp
                                                                                                      sat_sgrc7;
                                                                                            };
                                                                                      };
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                }; } in
                                      let {
                                        sat_sgrbi [Occ=Once] :: [GHC.Types.Char]
                                        [LclId] =
                                            CCCS :! [ww3_sgrbg ww4_sgrbh];
                                      } in  GHC.Base.++ sat_sgrbi sat_sgrc8;
                                };
                          };
                      1# -> GHC.Real.divZeroError;
                    };
              };
          1# ->
              let {
                sat_sgrcb [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [$dHasResolution_sgrb6 chopTrailingZeros_sgrb7 fa_sgrb8] \u []
                        case GHC.Integer.Type.negateInteger fa_sgrb8 of sat_sgrca {
                          __DEFAULT ->
                              Data.Fixed.showFixed
                                  $dHasResolution_sgrb6 chopTrailingZeros_sgrb7 sat_sgrca;
                        };
              } in  GHC.CString.unpackAppendCString# lvl16_rgoyV sat_sgrcb;
        };

Data.Fixed.$fShowFixed_$cshow
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a -> GHC.Base.String
[GblId, Arity=2, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgrcc eta_B1]
        Data.Fixed.showFixed $dHasResolution_sgrcc GHC.Types.False eta_B1;

Data.Fixed.$fShowFixed_$cshowsPrec
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Types.Int -> Data.Fixed.Fixed a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*C1(U)><L,A><S,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dHasResolution_sgrcd ds_sgrce x_sgrcf s_sgrcg]
        case
            Data.Fixed.showFixed $dHasResolution_sgrcd GHC.Types.False x_sgrcf
        of
        sat_sgrch
        { __DEFAULT -> GHC.Base.++ sat_sgrch s_sgrcg;
        };

Data.Fixed.$fShowFixed_$cshowList
  :: forall a.
     Data.Fixed.HasResolution a =>
     [Data.Fixed.Fixed a] -> GHC.Show.ShowS
[GblId, Arity=3, Str=<L,C(U)><S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgrci ls_sgrcj s_sgrck]
        let {
          sat_sgrco [Occ=Once] :: Data.Fixed.Fixed a_agnFG -> GHC.Show.ShowS
          [LclId] =
              [$dHasResolution_sgrci] \r [x_sgrcl s1_sgrcm]
                  case
                      Data.Fixed.showFixed $dHasResolution_sgrci GHC.Types.False x_sgrcl
                  of
                  sat_sgrcn
                  { __DEFAULT -> GHC.Base.++ sat_sgrcn s1_sgrcm;
                  };
        } in  GHC.Show.showList__ sat_sgrco ls_sgrcj s_sgrck;

Data.Fixed.$fShowFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Show.Show (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgrcp]
        let {
          sat_sgrcs [Occ=Once]
            :: [Data.Fixed.Fixed a_agnFG] -> GHC.Show.ShowS
          [LclId] =
              [$dHasResolution_sgrcp] \r [eta_B2 eta_B1]
                  Data.Fixed.$fShowFixed_$cshowList
                      $dHasResolution_sgrcp eta_B2 eta_B1; } in
        let {
          sat_sgrcr [Occ=Once] :: Data.Fixed.Fixed a_agnFG -> GHC.Base.String
          [LclId] =
              [$dHasResolution_sgrcp] \r [eta_B1]
                  Data.Fixed.$fShowFixed_$cshow $dHasResolution_sgrcp eta_B1; } in
        let {
          sat_sgrcq [Occ=Once]
            :: GHC.Types.Int -> Data.Fixed.Fixed a_agnFG -> GHC.Show.ShowS
          [LclId] =
              [$dHasResolution_sgrcp] \r [eta_B3 eta_B2 eta_B1]
                  Data.Fixed.$fShowFixed_$cshowsPrec
                      $dHasResolution_sgrcp eta_B3 eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sgrcq sat_sgrcr sat_sgrcs];


==================== STG syntax: ====================
2018-03-16 16:12:22.509599348 UTC

Data.Fixed.resolution [InlPrag=INLINE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall (p :: * -> *). p a -> GHC.Integer.Type.Integer
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=OtherCon []] =
    [] \r [v_sgr4l] v_sgr4l;

Data.Fixed.$fDataFixed2
  :: GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sgr4m] v_sgr4m;

Data.Fixed.$fDataFixed_$cgfoldl
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> Data.Fixed.Fixed a
     -> c (Data.Fixed.Fixed a)
[GblId,
 Arity=4,
 Str=<L,A><C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sgr4n k_sgr4o z_sgr4p ds_sgr4q]
        let {
          sat_sgr4r [Occ=Once]
            :: c_agnLa (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_agnL1)
          [LclId] =
              [z_sgr4p] \u [] z_sgr4p Data.Fixed.$fDataFixed2;
        } in  k_sgr4o Data.Data.$fDataInteger sat_sgr4r ds_sgr4q;

Data.Fixed.$fEnumFixed1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Fixed.$fEnumFixed_$cenumFromThenTo
  :: forall a.
     Data.Fixed.Fixed a
     -> Data.Fixed.Fixed a -> Data.Fixed.Fixed a -> [Data.Fixed.Fixed a]
[GblId, Arity=3, Str=<S,U><S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [ds_sgr4s ds1_sgr4t ds2_sgr4u]
        case
            GHC.Integer.Type.minusInteger ds1_sgr4t ds_sgr4s
        of
        delta_sgr4v [Dmd=<S,U>]
        { __DEFAULT ->
              case
                  GHC.Integer.Type.geInteger# delta_sgr4v Data.Fixed.$fEnumFixed1
              of
              { __DEFAULT ->
                    let {
                      go_sgr4x [Occ=LoopBreaker]
                        :: GHC.Integer.Type.Integer -> [Data.Fixed.Fixed a_agnJM]
                      [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ds2_sgr4u delta_sgr4v go_sgr4x] \r [x_sgr4y]
                              case GHC.Integer.Type.ltInteger# x_sgr4y ds2_sgr4u of {
                                __DEFAULT ->
                                    let {
                                      sat_sgr4B [Occ=Once] :: [Data.Fixed.Fixed a_agnJM]
                                      [LclId] =
                                          [delta_sgr4v go_sgr4x x_sgr4y] \u []
                                              case
                                                  GHC.Integer.Type.plusInteger x_sgr4y delta_sgr4v
                                              of
                                              sat_sgr4A
                                              { __DEFAULT -> go_sgr4x sat_sgr4A;
                                              };
                                    } in  : [x_sgr4y sat_sgr4B];
                                1# -> [] [];
                              };
                    } in  go_sgr4x ds_sgr4s;
                1# ->
                    let {
                      go_sgr4C [Occ=LoopBreaker]
                        :: GHC.Integer.Type.Integer -> [Data.Fixed.Fixed a_agnJM]
                      [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
                          sat-only [ds2_sgr4u delta_sgr4v go_sgr4C] \r [x_sgr4D]
                              case GHC.Integer.Type.gtInteger# x_sgr4D ds2_sgr4u of {
                                __DEFAULT ->
                                    let {
                                      sat_sgr4G [Occ=Once] :: [Data.Fixed.Fixed a_agnJM]
                                      [LclId] =
                                          [delta_sgr4v go_sgr4C x_sgr4D] \u []
                                              case
                                                  GHC.Integer.Type.plusInteger x_sgr4D delta_sgr4v
                                              of
                                              sat_sgr4F
                                              { __DEFAULT -> go_sgr4C sat_sgr4F;
                                              };
                                    } in  : [x_sgr4D sat_sgr4G];
                                1# -> [] [];
                              };
                    } in  go_sgr4C ds_sgr4s;
              };
        };

sat_sgr4H :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_sgr4I :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgr4H GHC.Types.[]];

Data.Fixed.$fEnumFixed2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgr4I;

Data.Fixed.$fEnumFixed_$cenumFromTo
  :: forall a.
     Data.Fixed.Fixed a -> Data.Fixed.Fixed a -> [Data.Fixed.Fixed a]
[GblId, Arity=2, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [ds_sgr4J ds1_sgr4K]
        let {
          go_sgr4L [Occ=LoopBreaker]
            :: GHC.Integer.Type.Integer -> [Data.Fixed.Fixed a_agnJM]
          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
              sat-only [ds1_sgr4K go_sgr4L] \r [x_sgr4M]
                  case GHC.Integer.Type.gtInteger# x_sgr4M ds1_sgr4K of {
                    __DEFAULT ->
                        let {
                          sat_sgr4P [Occ=Once] :: [Data.Fixed.Fixed a_agnJM]
                          [LclId] =
                              [go_sgr4L x_sgr4M] \u []
                                  case
                                      GHC.Integer.Type.plusInteger x_sgr4M Data.Fixed.$fEnumFixed2
                                  of
                                  sat_sgr4O
                                  { __DEFAULT -> go_sgr4L sat_sgr4O;
                                  };
                        } in  : [x_sgr4M sat_sgr4P];
                    1# -> [] [];
                  };
        } in  go_sgr4L ds_sgr4J;

Data.Fixed.$fEnumFixed_$cenumFromThen
  :: forall a.
     Data.Fixed.Fixed a -> Data.Fixed.Fixed a -> [Data.Fixed.Fixed a]
[GblId, Arity=2, Str=<S,U><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgr4Q ds1_sgr4R]
        let {
          d_sgr4S [Occ=OnceL] :: GHC.Integer.Type.Integer
          [LclId] =
              [ds_sgr4Q ds1_sgr4R] \u []
                  GHC.Integer.Type.minusInteger ds1_sgr4R ds_sgr4Q; } in
        let {
          go_sgr4T [Occ=LoopBreaker]
            :: GHC.Integer.Type.Integer -> [Data.Fixed.Fixed a_agnJM]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [d_sgr4S go_sgr4T] \r [x_sgr4U]
                  case x_sgr4U of x1_sgr4V {
                    __DEFAULT ->
                        let {
                          sat_sgr4X [Occ=Once] :: [Data.Fixed.Fixed a_agnJM]
                          [LclId] =
                              [d_sgr4S go_sgr4T x1_sgr4V] \u []
                                  case GHC.Integer.Type.plusInteger x1_sgr4V d_sgr4S of sat_sgr4W {
                                    __DEFAULT -> go_sgr4T sat_sgr4W;
                                  };
                        } in  : [x1_sgr4V sat_sgr4X];
                  };
        } in  go_sgr4T ds_sgr4Q;

Data.Fixed.$fEnumFixed3 [Occ=LoopBreaker]
  :: forall a. GHC.Integer.Type.Integer -> [Data.Fixed.Fixed a]
[GblId, Arity=1, Str=<S,1*U>m2, Unf=OtherCon []] =
    [] \r [x_sgr4Y]
        case x_sgr4Y of x1_sgr4Z {
          __DEFAULT ->
              let {
                sat_sgr51 [Occ=Once] :: [Data.Fixed.Fixed a_agnJM]
                [LclId] =
                    [x1_sgr4Z] \u []
                        case
                            GHC.Integer.Type.plusInteger x1_sgr4Z Data.Fixed.$fEnumFixed2
                        of
                        sat_sgr50
                        { __DEFAULT -> Data.Fixed.$fEnumFixed3 sat_sgr50;
                        };
              } in  : [x1_sgr4Z sat_sgr51];
        };

Data.Fixed.$fEnumFixed_$cenumFrom
  :: forall a. Data.Fixed.Fixed a -> [Data.Fixed.Fixed a]
[GblId, Arity=1, Str=<S,1*U>m2, Unf=OtherCon []] =
    [] \r [ds_sgr52] Data.Fixed.$fEnumFixed3 ds_sgr52;

Data.Fixed.$fEnumFixed_$cfromEnum
  :: forall a. Data.Fixed.Fixed a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_sgr53] GHC.Enum.$fEnumInteger_$cfromEnum ds_sgr53;

Data.Fixed.$fEnumFixed4
  :: forall a. Data.Fixed.Fixed a -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgr54] GHC.Enum.$fEnumInteger_$cpred ds_sgr54;

Data.Fixed.$fEnumFixed5
  :: forall a. Data.Fixed.Fixed a -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgr55] GHC.Enum.$fEnumInteger_$csucc ds_sgr55;

Data.Fixed.$fEnumFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Enum.Enum (Data.Fixed.Fixed a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Enum.C:Enum! [Data.Fixed.$fEnumFixed5
                                    Data.Fixed.$fEnumFixed4
                                    GHC.Enum.$fEnumInteger_$ctoEnum
                                    Data.Fixed.$fEnumFixed_$cfromEnum
                                    Data.Fixed.$fEnumFixed_$cenumFrom
                                    Data.Fixed.$fEnumFixed_$cenumFromThen
                                    Data.Fixed.$fEnumFixed_$cenumFromTo
                                    Data.Fixed.$fEnumFixed_$cenumFromThenTo];

Data.Fixed.$fHasResolutionE0_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E0 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgr56] Data.Fixed.$fEnumFixed2;

Data.Fixed.$fHasResolutionE0 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E0
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE0_$cresolution eta_B1;

sat_sgr57 :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [10#];

sat_sgr58 :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgr57 GHC.Types.[]];

Data.Fixed.$fHasResolutionE4 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgr58;

Data.Fixed.$fHasResolutionE1_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E1 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgr59] Data.Fixed.$fHasResolutionE4;

Data.Fixed.$fHasResolutionE1 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E1
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE1_$cresolution eta_B1;

sat_sgr5a :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [100#];

sat_sgr5b :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgr5a GHC.Types.[]];

Data.Fixed.$fHasResolutionE7 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgr5b;

Data.Fixed.$fHasResolutionE2_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E2 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgr5c] Data.Fixed.$fHasResolutionE7;

Data.Fixed.$fHasResolutionE2 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E2
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE2_$cresolution eta_B1;

sat_sgr5d :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1000#];

sat_sgr5e :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgr5d GHC.Types.[]];

Data.Fixed.$fHasResolutionE8 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgr5e;

Data.Fixed.$fHasResolutionE3_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E3 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgr5f] Data.Fixed.$fHasResolutionE8;

Data.Fixed.$fHasResolutionE3 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E3
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE3_$cresolution eta_B1;

sat_sgr5g :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1000000#];

sat_sgr5h :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgr5g GHC.Types.[]];

Data.Fixed.$fHasResolutionE10 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgr5h;

Data.Fixed.$fHasResolutionE6_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E6 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgr5i] Data.Fixed.$fHasResolutionE10;

Data.Fixed.$fHasResolutionE6 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E6
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE6_$cresolution eta_B1;

sat_sgr5j :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1000000000#];

sat_sgr5k :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgr5j GHC.Types.[]];

Data.Fixed.$fHasResolutionE11 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgr5k;

Data.Fixed.$fHasResolutionE9_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E9 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgr5l] Data.Fixed.$fHasResolutionE11;

Data.Fixed.$fHasResolutionE9 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E9
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE9_$cresolution eta_B1;

sat_sgr5n :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [465#];

sat_sgr5o :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgr5n GHC.Types.[]];

sat_sgr5m :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1420103680#];

sat_sgr5p :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sgr5m sat_sgr5o];

Data.Fixed.$fHasResolutionE5 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sgr5p;

Data.Fixed.$fHasResolutionE12_$cresolution
  :: forall (p :: * -> *).
     p Data.Fixed.E12 -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sgr5q] Data.Fixed.$fHasResolutionE5;

Data.Fixed.$fHasResolutionE12 [InlPrag=INLINE (sat-args=0)]
  :: Data.Fixed.HasResolution Data.Fixed.E12
[GblId[DFunId(nt)], Arity=1, Str=<L,A>, Unf=OtherCon []] =
    [] \r [eta_B1] Data.Fixed.$fHasResolutionE12_$cresolution eta_B1;

Data.Fixed.$fDataFixed6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Fixed.Fixed"#;

Data.Fixed.$fDataFixed5 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Fixed.$fDataFixed6;

w1_rgoyk :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "MkFixed"#;

w2_rgoyl :: GHC.Base.String
[GblId] =
    [] \u [] GHC.CString.unpackCString# w1_rgoyk;

go61_rgoym
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sgr5r _ys_sgr5s]
        case ds2_sgr5r of {
          [] -> GHC.List.badHead;
          : ipv_sgr5u [Occ=Once!] ipv1_sgr5v [Occ=Once] ->
              case _ys_sgr5s of {
                [] -> GHC.List.badHead;
                : ipv2_sgr5x [Occ=Once] ipv3_sgr5y [Occ=Once] ->
                    case ipv_sgr5u of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sgr5B [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sgr5B w2_rgoyl of {
                            GHC.Types.False -> go61_rgoym ipv1_sgr5v ipv3_sgr5y;
                            GHC.Types.True -> ipv2_sgr5x;
                          };
                    };
              };
        };

conMkFixed1_rgoyn :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [conMkFixed2_rgoyo];
Data.Fixed.$fDataFixed4 :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [Data.Fixed.conMkFixed GHC.Types.[]];
Data.Fixed.$fDataFixed3 :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [Data.Fixed.$fDataFixed4];
Data.Fixed.tyFixed :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Fixed.$fDataFixed5
                                       Data.Fixed.$fDataFixed3];
Data.Fixed.conMkFixed [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [conMkFixed1_rgoyn
                                     w2_rgoyl
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     Data.Fixed.tyFixed];
conMkFixed2_rgoyo :: Data.Data.ConIndex
[GblId] =
    [] \u [] go61_rgoym Data.Fixed.$fDataFixed4 Data.Data.mkConstr1;

Data.Fixed.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

loc_rgoyp :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Fixed.$trModule4;

Data.Fixed.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Fixed"#;

loc1_rgoyq :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Fixed.$trModule2;

loc2_rgoyr :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "./Data/Fixed.hs"#;

loc3_rgoys :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# loc2_rgoyr;

loc4_rgoyt :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [83#];

loc5_rgoyu :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [20#];

loc6_rgoyv :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [29#];

$dIP_rgoyw :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "undefined"#;

$dIP1_rgoyx :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# $dIP_rgoyw;

$dIP2_rgoyy :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [loc_rgoyp
                                           loc1_rgoyq
                                           loc3_rgoys
                                           loc4_rgoyt
                                           loc5_rgoyu
                                           loc4_rgoyt
                                           loc6_rgoyv];

$dIP3_rgoyz :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [$dIP1_rgoyx
                                                  $dIP2_rgoyy
                                                  GHC.Stack.Types.EmptyCallStack];

Data.Fixed.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$trModule4];

Data.Fixed.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$trModule2];

Data.Fixed.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Fixed.$trModule3
                                     Data.Fixed.$trModule1];

$krep_rgoyA :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Integer.Type.$tcInteger
                                              GHC.Types.[]];

$krep1_rgoyB :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Fixed.$tcHasResolution1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*
                                         $krep1_rgoyB];

$krep2_rgoyC :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

Data.Fixed.$fDataFixed10 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Fixed"#;

Data.Fixed.$fDataFixed9 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$fDataFixed10];

Data.Fixed.$tcFixed :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12850707307297787398##
                                    5875431371990069009##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$fDataFixed9
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep3_rgoyD :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep2_rgoyC GHC.Types.[]];

$krep4_rgoyE :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Fixed.$tcFixed
                                              $krep3_rgoyD];

Data.Fixed.$tc'MkFixed1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_rgoyA $krep4_rgoyE];

Data.Fixed.$tc'MkFixed3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'MkFixed"#;

Data.Fixed.$tc'MkFixed2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tc'MkFixed3];

Data.Fixed.$tc'MkFixed :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8992689233320522225##
                                    9587721628087041380##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tc'MkFixed2
                                    1#
                                    Data.Fixed.$tc'MkFixed1];

Data.Fixed.$fDataFixed8
  :: Data.Typeable.Internal.TypeRep Data.Fixed.Fixed
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                12850707307297787398##
                5875431371990069009##
                Data.Fixed.$trModule
                Data.Fixed.$fDataFixed9
                0#
                GHC.Types.krep$*Arr*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sgr5H [Occ=Once]
                   ww9_sgr5I [Occ=Once]
                   ww10_sgr5J [Occ=Once]
                   ww11_sgr5K [Occ=Once]
                   ww12_sgr5L [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sgr5H
                                              ww9_sgr5I
                                              ww10_sgr5J
                                              ww11_sgr5K
                                              ww12_sgr5L];
        };

Data.Fixed.$fDataFixed7
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     Data.Typeable.Internal.TypeRep (Data.Fixed.Fixed a)
[GblId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
    [] \r [$dTypeable_sgr5M]
        Data.Typeable.Internal.mkTrApp
            Data.Fixed.$fDataFixed8 $dTypeable_sgr5M;

Data.Fixed.$fDataFixed1
  :: forall a.
     (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [Data.Fixed.$fDataFixed2 GHC.Types.False];

Data.Fixed.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall a (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgr5N w3_sgr5O w4_sgr5P]
        let {
          lvl17_sgr5Q [Occ=OnceL] :: m_sgomN (Data.Fixed.Fixed a_sgomL)
          [LclId] =
              [w_sgr5N] \u [] GHC.Base.mzero w_sgr5N;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sgr5N
          of
          $dMonad_sgr5R [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgr6d [Occ=Once]
                    :: (Data.Fixed.Fixed a_sgomL, GHC.Types.Bool)
                       -> m_sgomN (Data.Fixed.Fixed a_sgomL)
                  [LclId] =
                      [lvl17_sgr5Q $dMonad_sgr5R] \r [ds_sgr68]
                          case ds_sgr68 of {
                            (,) x'_sgr6a [Occ=Once] b_sgr6b [Occ=Once!] ->
                                case b_sgr6b of {
                                  GHC.Types.False -> lvl17_sgr5Q;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgr5R x'_sgr6a;
                                };
                          }; } in
                let {
                  sat_sgr67 [Occ=Once]
                    :: m_sgomN (Data.Fixed.Fixed a_sgomL, GHC.Types.Bool)
                  [LclId] =
                      [w_sgr5N w3_sgr5O w4_sgr5P $dMonad_sgr5R] \u []
                          let {
                            lvl18_sgr5S [Occ=OnceL] :: m_sgomN GHC.Integer.Type.Integer
                            [LclId] =
                                [w3_sgr5O w4_sgr5P] \u []
                                    w3_sgr5O Data.Data.$fDataInteger w4_sgr5P; } in
                          let {
                            sat_sgr66 [Occ=Once]
                              :: (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomL,
                                  GHC.Types.Bool)
                                 -> m_sgomN (Data.Fixed.Fixed a_sgomL, GHC.Types.Bool)
                            [LclId] =
                                [w_sgr5N w4_sgr5P $dMonad_sgr5R lvl18_sgr5S] \r [ds1_sgr5U]
                                    case ds1_sgr5U of {
                                      (,) h_sgr5W b1_sgr5X [Occ=Once] ->
                                          let {
                                            sat_sgr65 [Occ=Once]
                                              :: m_sgomN (Data.Fixed.Fixed a_sgomL, GHC.Types.Bool)
                                            [LclId] =
                                                [w4_sgr5P $dMonad_sgr5R h_sgr5W b1_sgr5X] \u []
                                                    let {
                                                      sat_sgr63 [Occ=Once]
                                                        :: Data.Fixed.Fixed a_sgomL
                                                      [LclId] =
                                                          [w4_sgr5P h_sgr5W] \u []
                                                              h_sgr5W w4_sgr5P; } in
                                                    let {
                                                      sat_sgr64 [Occ=Once]
                                                        :: (Data.Fixed.Fixed a_sgomL,
                                                            GHC.Types.Bool)
                                                      [LclId] =
                                                          CCCS (,)! [sat_sgr63 b1_sgr5X];
                                                    } in 
                                                      GHC.Base.return $dMonad_sgr5R sat_sgr64; } in
                                          let {
                                            sat_sgr62 [Occ=Once]
                                              :: m_sgomN (Data.Fixed.Fixed a_sgomL, GHC.Types.Bool)
                                            [LclId] =
                                                [$dMonad_sgr5R lvl18_sgr5S h_sgr5W] \u []
                                                    let {
                                                      sat_sgr61 [Occ=Once]
                                                        :: GHC.Integer.Type.Integer
                                                           -> m_sgomN (Data.Fixed.Fixed a_sgomL,
                                                                       GHC.Types.Bool)
                                                      [LclId] =
                                                          [$dMonad_sgr5R h_sgr5W] \r [y'_sgr5Y]
                                                              let {
                                                                sat_sgr5Z [Occ=Once]
                                                                  :: Data.Fixed.Fixed a_sgomL
                                                                [LclId] =
                                                                    [h_sgr5W y'_sgr5Y] \u []
                                                                        h_sgr5W y'_sgr5Y; } in
                                                              let {
                                                                sat_sgr60 [Occ=Once]
                                                                  :: (Data.Fixed.Fixed a_sgomL,
                                                                      GHC.Types.Bool)
                                                                [LclId] =
                                                                    CCCS (,)! [sat_sgr5Z
                                                                               GHC.Types.True];
                                                              } in 
                                                                GHC.Base.return
                                                                    $dMonad_sgr5R sat_sgr60;
                                                    } in 
                                                      GHC.Base.>>=
                                                          $dMonad_sgr5R lvl18_sgr5S sat_sgr61;
                                          } in  GHC.Base.mplus w_sgr5N sat_sgr62 sat_sgr65;
                                    }; } in
                          let {
                            sat_sgr5T [Occ=Once]
                              :: m_sgomN (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomL,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sgr5R] \u []
                                    GHC.Base.return $dMonad_sgr5R Data.Fixed.$fDataFixed1;
                          } in  GHC.Base.>>= $dMonad_sgr5R sat_sgr5T sat_sgr66;
                } in  GHC.Base.>>= $dMonad_sgr5R sat_sgr67 sat_sgr6d;
          };

Data.Fixed.$fDataFixed_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=4,
 Str=<L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgr6e w3_sgr6f w4_sgr6g w5_sgr6h]
        Data.Fixed.$w$cgmapMp w3_sgr6f w4_sgr6g w5_sgr6h;

Data.Fixed.$w$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=3,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgr6i w3_sgr6j w4_sgr6k]
        let {
          lvl17_sgr6l [Occ=OnceL] :: m_sgomU GHC.Integer.Type.Integer
          [LclId] =
              [w3_sgr6j w4_sgr6k] \u []
                  w3_sgr6j Data.Data.$fDataInteger w4_sgr6k; } in
        let {
          sat_sgr6r [Occ=Once]
            :: (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomS)
               -> m_sgomU (Data.Fixed.Fixed a_sgomS)
          [LclId] =
              [w_sgr6i lvl17_sgr6l] \r [c'_sgr6n]
                  let {
                    sat_sgr6q [Occ=Once]
                      :: GHC.Integer.Type.Integer -> m_sgomU (Data.Fixed.Fixed a_sgomS)
                    [LclId] =
                        [w_sgr6i c'_sgr6n] \r [x'_sgr6o]
                            let {
                              sat_sgr6p [Occ=Once] :: Data.Fixed.Fixed a_sgomS
                              [LclId] =
                                  [c'_sgr6n x'_sgr6o] \u [] c'_sgr6n x'_sgr6o;
                            } in  GHC.Base.return w_sgr6i sat_sgr6p;
                  } in  GHC.Base.>>= w_sgr6i lvl17_sgr6l sat_sgr6q; } in
        let {
          sat_sgr6m [Occ=Once]
            :: m_sgomU (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomS)
          [LclId] =
              [w_sgr6i] \u [] GHC.Base.return w_sgr6i Data.Fixed.$fDataFixed2;
        } in  GHC.Base.>>= w_sgr6i sat_sgr6m sat_sgr6r;

Data.Fixed.$fDataFixed_$cgmapM [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=4,
 Str=<L,A><S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgr6s w3_sgr6t w4_sgr6u w5_sgr6v]
        Data.Fixed.$w$cgmapM w3_sgr6t w4_sgr6u w5_sgr6v;

Data.Fixed.$fDataFixed_$cgmapQi
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> Data.Fixed.Fixed a
     -> u
[GblId,
 Arity=4,
 Str=<L,A><S(S),1*U(1*U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTypeable_sgr6w ds_sgr6x ds1_sgr6y x_sgr6z]
        case ds_sgr6x of {
          GHC.Types.I# x1_sgr6B [Occ=Once!] ->
              case x1_sgr6B of {
                __DEFAULT -> Data.Maybe.fromJust1;
                0# -> ds1_sgr6y Data.Data.$fDataInteger x_sgr6z;
              };
        };

Data.Fixed.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall a (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=3,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,C(C1(U)),A,C(U),A),1*U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgr6D w3_sgr6E w4_sgr6F]
        let {
          lvl17_sgr6G [Occ=OnceL] :: m_sgon1 (Data.Fixed.Fixed a_sgomZ)
          [LclId] =
              [w_sgr6D] \u [] GHC.Base.mzero w_sgr6D;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sgr6D
          of
          $dMonad_sgr6H [Dmd=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sgr76 [Occ=Once]
                    :: (Data.Fixed.Fixed a_sgomZ, GHC.Types.Bool)
                       -> m_sgon1 (Data.Fixed.Fixed a_sgomZ)
                  [LclId] =
                      [lvl17_sgr6G $dMonad_sgr6H] \r [ds_sgr71]
                          case ds_sgr71 of {
                            (,) x'_sgr73 [Occ=Once] b_sgr74 [Occ=Once!] ->
                                case b_sgr74 of {
                                  GHC.Types.False -> lvl17_sgr6G;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sgr6H x'_sgr73;
                                };
                          }; } in
                let {
                  sat_sgr70 [Occ=Once]
                    :: m_sgon1 (Data.Fixed.Fixed a_sgomZ, GHC.Types.Bool)
                  [LclId] =
                      [w_sgr6D w3_sgr6E w4_sgr6F $dMonad_sgr6H] \u []
                          let {
                            lvl18_sgr6I [Occ=OnceL] :: m_sgon1 GHC.Integer.Type.Integer
                            [LclId] =
                                [w3_sgr6E w4_sgr6F] \u []
                                    w3_sgr6E Data.Data.$fDataInteger w4_sgr6F; } in
                          let {
                            sat_sgr6Z [Occ=Once]
                              :: (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomZ,
                                  GHC.Types.Bool)
                                 -> m_sgon1 (Data.Fixed.Fixed a_sgomZ, GHC.Types.Bool)
                            [LclId] =
                                [w_sgr6D w4_sgr6F $dMonad_sgr6H lvl18_sgr6I] \r [ds1_sgr6K]
                                    case ds1_sgr6K of {
                                      (,) h_sgr6M b1_sgr6N [Occ=Once!] ->
                                          case b1_sgr6N of {
                                            GHC.Types.False ->
                                                let {
                                                  sat_sgr6W [Occ=Once]
                                                    :: m_sgon1 (Data.Fixed.Fixed a_sgomZ,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [w4_sgr6F $dMonad_sgr6H h_sgr6M] \u []
                                                          let {
                                                            sat_sgr6U [Occ=Once]
                                                              :: Data.Fixed.Fixed a_sgomZ
                                                            [LclId] =
                                                                [w4_sgr6F h_sgr6M] \u []
                                                                    h_sgr6M w4_sgr6F; } in
                                                          let {
                                                            sat_sgr6V [Occ=Once]
                                                              :: (Data.Fixed.Fixed a_sgomZ,
                                                                  GHC.Types.Bool)
                                                            [LclId] =
                                                                CCCS (,)! [sat_sgr6U
                                                                           GHC.Types.False];
                                                          } in 
                                                            GHC.Base.return
                                                                $dMonad_sgr6H sat_sgr6V; } in
                                                let {
                                                  sat_sgr6T [Occ=Once]
                                                    :: m_sgon1 (Data.Fixed.Fixed a_sgomZ,
                                                                GHC.Types.Bool)
                                                  [LclId] =
                                                      [$dMonad_sgr6H lvl18_sgr6I h_sgr6M] \u []
                                                          let {
                                                            sat_sgr6S [Occ=Once]
                                                              :: GHC.Integer.Type.Integer
                                                                 -> m_sgon1 (Data.Fixed.Fixed
                                                                               a_sgomZ,
                                                                             GHC.Types.Bool)
                                                            [LclId] =
                                                                [$dMonad_sgr6H
                                                                 h_sgr6M] \r [y'_sgr6P]
                                                                    let {
                                                                      sat_sgr6Q [Occ=Once]
                                                                        :: Data.Fixed.Fixed a_sgomZ
                                                                      [LclId] =
                                                                          [h_sgr6M y'_sgr6P] \u []
                                                                              h_sgr6M y'_sgr6P; } in
                                                                    let {
                                                                      sat_sgr6R [Occ=Once]
                                                                        :: (Data.Fixed.Fixed
                                                                              a_sgomZ,
                                                                            GHC.Types.Bool)
                                                                      [LclId] =
                                                                          CCCS (,)! [sat_sgr6Q
                                                                                     GHC.Types.True];
                                                                    } in 
                                                                      GHC.Base.return
                                                                          $dMonad_sgr6H sat_sgr6R;
                                                          } in 
                                                            GHC.Base.>>=
                                                                $dMonad_sgr6H lvl18_sgr6I sat_sgr6S;
                                                } in  GHC.Base.mplus w_sgr6D sat_sgr6T sat_sgr6W;
                                            GHC.Types.True ->
                                                let {
                                                  sat_sgr6X [Occ=Once] :: Data.Fixed.Fixed a_sgomZ
                                                  [LclId] =
                                                      [w4_sgr6F h_sgr6M] \u []
                                                          h_sgr6M w4_sgr6F; } in
                                                let {
                                                  sat_sgr6Y [Occ=Once]
                                                    :: (Data.Fixed.Fixed a_sgomZ, GHC.Types.Bool)
                                                  [LclId] =
                                                      CCCS (,)! [sat_sgr6X GHC.Types.True];
                                                } in  GHC.Base.return $dMonad_sgr6H sat_sgr6Y;
                                          };
                                    }; } in
                          let {
                            sat_sgr6J [Occ=Once]
                              :: m_sgon1 (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_sgomZ,
                                          GHC.Types.Bool)
                            [LclId] =
                                [$dMonad_sgr6H] \u []
                                    GHC.Base.return $dMonad_sgr6H Data.Fixed.$fDataFixed1;
                          } in  GHC.Base.>>= $dMonad_sgr6H sat_sgr6J sat_sgr6Z;
                } in  GHC.Base.>>= $dMonad_sgr6H sat_sgr70 sat_sgr76;
          };

Data.Fixed.$fDataFixed_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Fixed.Fixed a -> m (Data.Fixed.Fixed a)
[GblId,
 Arity=4,
 Str=<L,A><S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,C(C1(U)))><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgr77 w3_sgr78 w4_sgr79 w5_sgr7a]
        Data.Fixed.$w$cgmapMo w3_sgr78 w4_sgr79 w5_sgr7a;

lvl_rgoyF :: forall a. Data.Fixed.Fixed a -> Data.Data.Constr
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sgr7b] Data.Fixed.conMkFixed;

lvl1_rgoyG :: forall a. Data.Fixed.Fixed a -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sgr7c] Data.Fixed.tyFixed;

lvl2_rgoyH
  :: forall a (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c (Data.Fixed.Fixed a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sgr7d ds_sgr7e] GHC.Base.Nothing [];

lvl3_rgoyI
  :: forall a (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c (Data.Fixed.Fixed a))
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sgr7f ds_sgr7g] GHC.Base.Nothing [];

lvl4_rgoyJ
  :: forall a.
     (forall b. Data.Data.Data b => b -> b)
     -> Data.Fixed.Fixed a -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<C(C(S)),1*C1(C1(U))><L,U>, Unf=OtherCon []] =
    [] \r [ds_sgr7h x0_sgr7i]
        ds_sgr7h Data.Data.$fDataInteger x0_sgr7i;

lvl5_rgoyK
  :: forall a r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Fixed.Fixed a
     -> r
[GblId,
 Arity=4,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgr7j ds1_sgr7k ds2_sgr7l eta_sgr7m]
        let {
          sat_sgr7n [Occ=Once] :: r'_agnMw
          [LclId] =
              [ds2_sgr7l eta_sgr7m] \u []
                  ds2_sgr7l Data.Data.$fDataInteger eta_sgr7m;
        } in  ds_sgr7j ds1_sgr7k sat_sgr7n;

lvl6_rgoyL
  :: forall a r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Fixed.Fixed a
     -> r
[GblId,
 Arity=4,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgr7o ds1_sgr7p ds2_sgr7q x0_sgr7r]
        let {
          sat_sgr7s [Occ=Once] :: r'_agnMN
          [LclId] =
              [ds2_sgr7q x0_sgr7r] \u []
                  ds2_sgr7q Data.Data.$fDataInteger x0_sgr7r;
        } in  ds_sgr7o sat_sgr7s ds1_sgr7p;

lvl7_rgoyM
  :: forall a u.
     (forall d. Data.Data.Data d => d -> u) -> Data.Fixed.Fixed a -> [u]
[GblId, Arity=2, Str=<L,1*C1(C1(U))><L,U>m2, Unf=OtherCon []] =
    [] \r [ds_sgr7t x0_sgr7u]
        let {
          sat_sgr7v [Occ=Once] :: u_agnN3
          [LclId] =
              [ds_sgr7t x0_sgr7u] \u []
                  ds_sgr7t Data.Data.$fDataInteger x0_sgr7u;
        } in  : [sat_sgr7v GHC.Types.[]];

lvl8_rgoyN
  :: forall a (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c (Data.Fixed.Fixed a)
[GblId,
 Arity=3,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,A>,
 Unf=OtherCon []] =
    [] \r [k_sgr7w z_sgr7x ds_sgr7y]
        let {
          sat_sgr7z [Occ=Once]
            :: c_agnLl (GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_XgnO4)
          [LclId] =
              [z_sgr7x] \u [] z_sgr7x Data.Fixed.$fDataFixed2;
        } in  k_sgr7w Data.Data.$fDataInteger sat_sgr7z;

Data.Fixed.$fDataFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Typeable.Internal.Typeable a =>
     Data.Data.Data (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,U>] =
    [] \r [$dTypeable_sgr7A]
        let {
          sat_sgr7D [Occ=Once]
            :: forall u.
               GHC.Types.Int
               -> (forall d. Data.Data.Data d => d -> u)
               -> Data.Fixed.Fixed a_XgnO4
               -> u
          [LclId] =
              [$dTypeable_sgr7A] \r [eta_B3 eta_B2 eta_B1]
                  Data.Fixed.$fDataFixed_$cgmapQi
                      $dTypeable_sgr7A eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgr7C [Occ=Once]
            :: forall (c :: * -> *).
               (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
               -> (forall g. g -> c g)
               -> Data.Fixed.Fixed a_XgnO4
               -> c (Data.Fixed.Fixed a_XgnO4)
          [LclId] =
              [$dTypeable_sgr7A] \r [eta_B3 eta_B2 eta_B1]
                  Data.Fixed.$fDataFixed_$cgfoldl
                      $dTypeable_sgr7A eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgr7B [Occ=Once]
            :: Data.Typeable.Internal.Typeable (Data.Fixed.Fixed a_XgnO4)
          [LclId] =
              [$dTypeable_sgr7A] \u [] Data.Fixed.$fDataFixed7 $dTypeable_sgr7A;
        } in 
          Data.Data.C:Data [sat_sgr7B
                            sat_sgr7C
                            lvl8_rgoyN
                            lvl_rgoyF
                            lvl1_rgoyG
                            lvl2_rgoyH
                            lvl3_rgoyI
                            lvl4_rgoyJ
                            lvl5_rgoyK
                            lvl6_rgoyL
                            lvl7_rgoyM
                            sat_sgr7D
                            Data.Fixed.$w$cgmapM
                            Data.Fixed.$w$cgmapMp
                            Data.Fixed.$w$cgmapMo];

Data.Fixed.$tcHasResolution3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "HasResolution"#;

Data.Fixed.$tcHasResolution2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcHasResolution3];

Data.Fixed.$tcHasResolution :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7410670074803796200##
                                    11622449620609036983##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcHasResolution2
                                    0#
                                    Data.Fixed.$tcHasResolution1];

Data.Fixed.$tcE5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E0"#;

Data.Fixed.$tcE4 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE5];

Data.Fixed.$tcE0 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1111589946053822622##
                                    14645449775626969178##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE4
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE8 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E1"#;

Data.Fixed.$tcE7 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE8];

Data.Fixed.$tcE1 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17242267792727872229##
                                    10571291330004494282##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE7
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE14 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E2"#;

Data.Fixed.$tcE13 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE14];

Data.Fixed.$tcE2 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [18184774527647329547##
                                    15895109557895358229##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE13
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE16 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E3"#;

Data.Fixed.$tcE15 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE16];

Data.Fixed.$tcE3 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [2281297682271263739##
                                    13982938170987291273##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE15
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE18 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E6"#;

Data.Fixed.$tcE17 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE18];

Data.Fixed.$tcE6 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6430880657524859014##
                                    16351944333195325805##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE17
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE20 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E9"#;

Data.Fixed.$tcE19 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE20];

Data.Fixed.$tcE9 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8202840314884717291##
                                    5390706447224283764##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE19
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.$tcE11 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "E12"#;

Data.Fixed.$tcE10 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Fixed.$tcE11];

Data.Fixed.$tcE12 :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11177455628646877585##
                                    1804744900678580889##
                                    Data.Fixed.$trModule
                                    Data.Fixed.$tcE10
                                    0#
                                    GHC.Types.krep$*];

Data.Fixed.div'
  :: forall a b.
     (GHC.Real.Real a, GHC.Real.Integral b) =>
     a -> a -> b
[GblId,
 Arity=4,
 Str=<S(LLC(S(SS))),U(A,A,C(U(U,U)))><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dReal_sgr7E $dIntegral_sgr7F n_sgr7G d_sgr7H]
        case GHC.Real.toRational $dReal_sgr7E n_sgr7G of {
          GHC.Real.:% ww1_sgr7J [Occ=Once] ww2_sgr7K [Occ=Once] ->
              case GHC.Real.toRational $dReal_sgr7E d_sgr7H of {
                GHC.Real.:% ww4_sgr7M [Occ=Once] ww5_sgr7N [Occ=Once] ->
                    case GHC.Real.$w$s$c/ ww1_sgr7J ww2_sgr7K ww4_sgr7M ww5_sgr7N of {
                      (#,#) ww7_sgr7P [Occ=Once] ww8_sgr7Q [Occ=Once] ->
                          GHC.Real.$w$s$cfloor $dIntegral_sgr7F ww7_sgr7P ww8_sgr7Q;
                    };
              };
        };

Data.Fixed.$wdivMod' [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Real.Real a, GHC.Real.Integral b) =>
     a -> a -> (# b, a #)
[GblId,
 Arity=4,
 Str=<L,U(1*U(A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,1*C1(U)),A,C(U(U,U)))><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,1*C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgr7R w3_sgr7S w4_sgr7T w5_sgr7U]
        let {
          f_sgr7V :: b_sgond
          [LclId] =
              [w_sgr7R w3_sgr7S w4_sgr7T w5_sgr7U] \u []
                  Data.Fixed.div' w_sgr7R w3_sgr7S w4_sgr7T w5_sgr7U; } in
        let {
          sat_sgr80 [Occ=Once] :: a_sgonc
          [LclId] =
              [w_sgr7R w3_sgr7S w4_sgr7T w5_sgr7U f_sgr7V] \u []
                  case
                      GHC.Real.$p1Real w_sgr7R
                  of
                  $dNum_sgr7W [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,1*C1(U))>]
                  { __DEFAULT ->
                        let {
                          sat_sgr7Z [Occ=Once] :: a_sgonc
                          [LclId] =
                              [w3_sgr7S w5_sgr7U f_sgr7V $dNum_sgr7W] \u []
                                  let {
                                    sat_sgr7Y [Occ=Once] :: a_sgonc
                                    [LclId] =
                                        [w3_sgr7S f_sgr7V $dNum_sgr7W] \u []
                                            let {
                                              sat_sgr7X [Occ=Once] :: GHC.Integer.Type.Integer
                                              [LclId] =
                                                  [w3_sgr7S f_sgr7V] \u []
                                                      GHC.Real.toInteger w3_sgr7S f_sgr7V;
                                            } in  GHC.Num.fromInteger $dNum_sgr7W sat_sgr7X;
                                  } in  GHC.Num.* $dNum_sgr7W sat_sgr7Y w5_sgr7U;
                        } in  GHC.Num.- $dNum_sgr7W w4_sgr7T sat_sgr7Z;
                  };
        } in  (#,#) [f_sgr7V sat_sgr80];

Data.Fixed.divMod' [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Real.Real a, GHC.Real.Integral b) =>
     a -> a -> (b, a)
[GblId,
 Arity=4,
 Str=<L,U(U(A,C(C1(U)),C(C1(U)),A,A,A,C(U)),A,C(U(U,U)))><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sgr81 w3_sgr82 w4_sgr83 w5_sgr84]
        case Data.Fixed.$wdivMod' w_sgr81 w3_sgr82 w4_sgr83 w5_sgr84 of {
          (#,#) ww1_sgr86 [Occ=Once] ww2_sgr87 [Occ=Once] ->
              (,) [ww1_sgr86 ww2_sgr87];
        };

Data.Fixed.mod' :: forall a. GHC.Real.Real a => a -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(LC(C(S))LLLLL)LL),U(1*U(A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,1*C1(U)),A,C(U(U,U)))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dReal_sgr88 eta_sgr89 eta1_sgr8a]
        case
            GHC.Real.$p1Real $dReal_sgr88
        of
        $dNum_sgr8b [Dmd=<S(LC(C(S))LLLLL),U(A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,1*C1(U))>]
        { __DEFAULT ->
              let {
                sat_sgr8e [Occ=Once] :: a_agnBF
                [LclId] =
                    [$dReal_sgr88 eta_sgr89 eta1_sgr8a $dNum_sgr8b] \u []
                        let {
                          sat_sgr8d [Occ=Once] :: a_agnBF
                          [LclId] =
                              [$dReal_sgr88 eta_sgr89 eta1_sgr8a $dNum_sgr8b] \u []
                                  let {
                                    sat_sgr8c [Occ=Once] :: GHC.Integer.Type.Integer
                                    [LclId] =
                                        [$dReal_sgr88 eta_sgr89 eta1_sgr8a] \u []
                                            Data.Fixed.div'
                                                $dReal_sgr88
                                                GHC.Real.$fIntegralInteger
                                                eta_sgr89
                                                eta1_sgr8a;
                                  } in  GHC.Num.fromInteger $dNum_sgr8b sat_sgr8c;
                        } in  GHC.Num.* $dNum_sgr8b sat_sgr8d eta1_sgr8a;
              } in  GHC.Num.- $dNum_sgr8b eta_sgr89 sat_sgr8e;
        };

Data.Fixed.$fFractionalFixed2 :: forall a. GHC.Types.Any a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined $dIP3_rgoyz;

Data.Fixed.$w$cfromRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sgr8f ww_sgr8g ww1_sgr8h]
        case w_sgr8f Data.Fixed.$fFractionalFixed2 of dt_sgr8i {
          __DEFAULT ->
              case
                  GHC.Integer.Type.timesInteger ww1_sgr8h GHC.Real.$fEnumRatio1
              of
              sat_sgr8k
              { __DEFAULT ->
                    case GHC.Integer.Type.timesInteger ww_sgr8g dt_sgr8i of sat_sgr8j {
                      __DEFAULT ->
                          case GHC.Real.$w$sreduce sat_sgr8j sat_sgr8k of {
                            (#,#) ww7_sgr8m [Occ=Once] ww8_sgr8n [Occ=Once] ->
                                GHC.Real.$w$s$cfloor
                                    GHC.Real.$fIntegralInteger ww7_sgr8m ww8_sgr8n;
                          };
                    };
              };
        };

Data.Fixed.$fFractionalFixed1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Real.Rational -> GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Str=<C(S),1*C1(U)><S(SS),1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sgr8o w3_sgr8p]
        case w3_sgr8p of {
          GHC.Real.:% ww1_sgr8r [Occ=Once] ww2_sgr8s [Occ=Once] ->
              Data.Fixed.$w$cfromRational w_sgr8o ww1_sgr8r ww2_sgr8s;
        };

Data.Fixed.$fRealFixed_$ctoRational [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a -> GHC.Real.Rational
[GblId, Arity=2, Str=<C(S),1*C1(U)><S,U>m, Unf=OtherCon []] =
    [] \r [w_sgr8t w3_sgr8u]
        case w_sgr8t w3_sgr8u of dt_sgr8v {
          __DEFAULT ->
              case
                  GHC.Real.$w$s$c/
                      w3_sgr8u GHC.Real.$fEnumRatio1 dt_sgr8v GHC.Real.$fEnumRatio1
              of
              { (#,#) ww1_sgr8x [Occ=Once] ww2_sgr8y [Occ=Once] ->
                    GHC.Real.:% [ww1_sgr8x ww2_sgr8y];
              };
        };

Data.Fixed.$fFractionalFixed3
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a
     -> Data.Fixed.Fixed a -> GHC.Integer.Type.Integer
[GblId, Arity=3, Str=<C(S),1*C1(U)><S,U><S,U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgr8z fa_sgr8A ds_sgr8B]
        case
            GHC.Integer.Type.eqInteger# ds_sgr8B Data.Fixed.$fEnumFixed1
        of
        { __DEFAULT ->
              case $dHasResolution_sgr8z fa_sgr8A of sat_sgr8D {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger fa_sgr8A sat_sgr8D
                    of
                    sat_sgr8E
                    { __DEFAULT -> GHC.Integer.Type.divInteger sat_sgr8E ds_sgr8B;
                    };
              };
          1# -> GHC.Real.divZeroError;
        };

Data.Fixed.$fFractionalFixed_$crecip
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a -> Data.Fixed.Fixed a
[GblId, Arity=2, Str=<C(S),1*C1(U)><S,U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgr8F fa_sgr8G]
        case
            GHC.Integer.Type.eqInteger# fa_sgr8G Data.Fixed.$fEnumFixed1
        of
        { __DEFAULT ->
              case $dHasResolution_sgr8F fa_sgr8G of res_sgr8I [Dmd=<S,U>] {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.timesInteger res_sgr8I res_sgr8I
                    of
                    sat_sgr8J
                    { __DEFAULT -> GHC.Integer.Type.divInteger sat_sgr8J fa_sgr8G;
                    };
              };
          1# -> GHC.Real.divZeroError;
        };

Data.Fixed.$fNumFixed_$c*
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a -> Data.Fixed.Fixed a -> Data.Fixed.Fixed a
[GblId, Arity=3, Str=<C(S),1*C1(U)><S,U><S,1*U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgr8K fa_sgr8L ds_sgr8M]
        case $dHasResolution_sgr8K fa_sgr8L of ds1_sgr8N [Dmd=<S,U>] {
          __DEFAULT ->
              case
                  GHC.Integer.Type.eqInteger# ds1_sgr8N Data.Fixed.$fEnumFixed1
              of
              { __DEFAULT ->
                    case GHC.Integer.Type.timesInteger fa_sgr8L ds_sgr8M of sat_sgr8P {
                      __DEFAULT -> GHC.Integer.Type.divInteger sat_sgr8P ds1_sgr8N;
                    };
                1# -> GHC.Real.divZeroError;
              };
        };

Data.Fixed.$fNumFixed1
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<C(S),1*C1(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgr8Q i_sgr8R]
        case
            $dHasResolution_sgr8Q Data.Fixed.$fFractionalFixed2
        of
        sat_sgr8S
        { __DEFAULT -> GHC.Integer.Type.timesInteger i_sgr8R sat_sgr8S;
        };

Data.Fixed.$fNumFixed2
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a -> GHC.Integer.Type.Integer
[GblId, Arity=2, Str=<C(S),1*C1(U)><S,1*U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgr8T ds_sgr8U]
        case
            $dHasResolution_sgr8T Data.Fixed.$fFractionalFixed2
        of
        sat_sgr8W
        { __DEFAULT ->
              case GHC.Integer.Type.signumInteger ds_sgr8U of sat_sgr8V {
                __DEFAULT -> GHC.Integer.Type.timesInteger sat_sgr8V sat_sgr8W;
              };
        };

Data.Fixed.$fNumFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Num.Num (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgr8X]
        let {
          sat_sgr90 [Occ=Once]
            :: GHC.Integer.Type.Integer -> Data.Fixed.Fixed a_XgnN5
          [LclId] =
              [$dHasResolution_sgr8X] \r [eta_B1]
                  Data.Fixed.$fNumFixed1 $dHasResolution_sgr8X eta_B1; } in
        let {
          sat_sgr8Z [Occ=Once]
            :: Data.Fixed.Fixed a_XgnN5 -> Data.Fixed.Fixed a_XgnN5
          [LclId] =
              [$dHasResolution_sgr8X] \r [eta_B1]
                  Data.Fixed.$fNumFixed2 $dHasResolution_sgr8X eta_B1; } in
        let {
          sat_sgr8Y [Occ=Once]
            :: Data.Fixed.Fixed a_XgnN5
               -> Data.Fixed.Fixed a_XgnN5 -> Data.Fixed.Fixed a_XgnN5
          [LclId] =
              [$dHasResolution_sgr8X] \r [eta_B2 eta_B1]
                  Data.Fixed.$fNumFixed_$c* $dHasResolution_sgr8X eta_B2 eta_B1;
        } in 
          GHC.Num.C:Num [GHC.Integer.Type.plusInteger
                         GHC.Integer.Type.minusInteger
                         sat_sgr8Y
                         GHC.Integer.Type.negateInteger
                         GHC.Integer.Type.absInteger
                         sat_sgr8Z
                         sat_sgr90];

Data.Fixed.$fFractionalFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Real.Fractional (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgr91]
        let {
          sat_sgr95 [Occ=Once]
            :: GHC.Real.Rational -> Data.Fixed.Fixed a_XgnLO
          [LclId] =
              [$dHasResolution_sgr91] \r [eta_B1]
                  Data.Fixed.$fFractionalFixed1 $dHasResolution_sgr91 eta_B1; } in
        let {
          sat_sgr94 [Occ=Once]
            :: Data.Fixed.Fixed a_XgnLO -> Data.Fixed.Fixed a_XgnLO
          [LclId] =
              [$dHasResolution_sgr91] \r [eta_B1]
                  Data.Fixed.$fFractionalFixed_$crecip
                      $dHasResolution_sgr91 eta_B1; } in
        let {
          sat_sgr93 [Occ=Once]
            :: Data.Fixed.Fixed a_XgnLO
               -> Data.Fixed.Fixed a_XgnLO -> Data.Fixed.Fixed a_XgnLO
          [LclId] =
              [$dHasResolution_sgr91] \r [eta_B2 eta_B1]
                  Data.Fixed.$fFractionalFixed3
                      $dHasResolution_sgr91 eta_B2 eta_B1; } in
        let {
          sat_sgr92 [Occ=Once] :: GHC.Num.Num (Data.Fixed.Fixed a_XgnLO)
          [LclId] =
              [$dHasResolution_sgr91] \u []
                  Data.Fixed.$fNumFixed $dHasResolution_sgr91;
        } in 
          GHC.Real.C:Fractional [sat_sgr92 sat_sgr93 sat_sgr94 sat_sgr95];

Data.Fixed.$fReadFixed2 :: GHC.Types.Double
[GblId] =
    [] \u []
        case logDouble# [10.0##] of v_sgr96 {
          __DEFAULT -> GHC.Types.D# [v_sgr96];
        };

lvl9_rgoyO :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [172#];

lvl10_rgoyP :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [27#];

lvl11_rgoyQ :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [36#];

lvl12_rgoyR :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [loc_rgoyp
                                           loc1_rgoyq
                                           loc3_rgoys
                                           lvl9_rgoyO
                                           lvl10_rgoyP
                                           lvl9_rgoyO
                                           lvl11_rgoyQ];

lvl13_rgoyS :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [$dIP1_rgoyx
                                                  lvl12_rgoyR
                                                  GHC.Stack.Types.EmptyCallStack];

Data.Fixed.$fReadFixed3 :: forall a. Data.Fixed.Fixed a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined lvl13_rgoyS;

Data.Fixed.$fReadFixed1
  :: forall a.
     Data.Fixed.HasResolution a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Fixed.Fixed a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgr97]
        let {
          lvl17_sgr98 :: GHC.Integer.Type.Integer
          [LclId] =
              [$dHasResolution_sgr97] \u []
                  $dHasResolution_sgr97 Data.Fixed.$fFractionalFixed2; } in
        let {
          e_sgr99 :: GHC.Integer.Type.Integer
          [LclId] =
              [$dHasResolution_sgr97] \u []
                  case $dHasResolution_sgr97 Data.Fixed.$fReadFixed3 of sat_sgr9a {
                    __DEFAULT ->
                        case GHC.Integer.Type.doubleFromInteger sat_sgr9a of wild_sgr9b {
                          __DEFAULT ->
                              case logDouble# [wild_sgr9b] of wild1_sgr9c {
                                __DEFAULT ->
                                    case Data.Fixed.$fReadFixed2 of {
                                      GHC.Types.D# v1_sgr9e [Occ=Once] ->
                                          case /## [wild1_sgr9c v1_sgr9e] of wild4_sgr9f {
                                            __DEFAULT ->
                                                case negateDouble# [wild4_sgr9f] of sat_sgr9g {
                                                  __DEFAULT ->
                                                      case
                                                          GHC.Integer.Type.decodeDoubleInteger
                                                              sat_sgr9g
                                                      of
                                                      { (#,#) ipv_sgr9i [Occ=Once*] ipv1_sgr9j ->
                                                            case <# [ipv1_sgr9j 0#] of {
                                                              __DEFAULT ->
                                                                  case
                                                                      GHC.Integer.Type.shiftLInteger
                                                                          ipv_sgr9i ipv1_sgr9j
                                                                  of
                                                                  sat_sgr9l
                                                                  { __DEFAULT ->
                                                                        GHC.Integer.Type.negateInteger
                                                                            sat_sgr9l;
                                                                  };
                                                              1# ->
                                                                  case
                                                                      negateInt# [ipv1_sgr9j]
                                                                  of
                                                                  s_sgr9m [Dmd=<S,U>]
                                                                  { __DEFAULT ->
                                                                        case ># [s_sgr9m 52#] of {
                                                                          __DEFAULT ->
                                                                              case
                                                                                  GHC.Integer.Type.integerToInt
                                                                                      ipv_sgr9i
                                                                              of
                                                                              n_sgr9o
                                                                              { __DEFAULT ->
                                                                                    case
                                                                                        uncheckedIShiftRA# [n_sgr9o
                                                                                                            s_sgr9m]
                                                                                    of
                                                                                    sat_sgr9p
                                                                                    { __DEFAULT ->
                                                                                          case
                                                                                              GHC.Integer.Type.smallInteger
                                                                                                  sat_sgr9p
                                                                                          of
                                                                                          sat_sgr9q
                                                                                          { __DEFAULT ->
                                                                                                GHC.Integer.Type.negateInteger
                                                                                                    sat_sgr9q;
                                                                                          };
                                                                                    };
                                                                              };
                                                                          1# ->
                                                                              case
                                                                                  GHC.Integer.Type.ltInteger#
                                                                                      ipv_sgr9i
                                                                                      Data.Fixed.$fEnumFixed1
                                                                              of
                                                                              { __DEFAULT ->
                                                                                    Data.Fixed.$fEnumFixed1;
                                                                                1# ->
                                                                                    Data.Fixed.$fEnumFixed2;
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                };
                                          };
                                    };
                              };
                        };
                  }; } in
        let {
          lvl18_sgr9s [Occ=OnceL] :: Data.Fixed.Fixed a_agnFb
          [LclId] =
              [$dHasResolution_sgr97 e_sgr99] \u []
                  let {
                    sat_sgr9v [Occ=Once] :: Data.Fixed.Fixed a_agnFb
                    [LclId] =
                        [$dHasResolution_sgr97] \u []
                            case
                                $dHasResolution_sgr97 Data.Fixed.$fFractionalFixed2
                            of
                            sat_sgr9u
                            { __DEFAULT ->
                                  GHC.Integer.Type.timesInteger
                                      Data.Fixed.$fHasResolutionE4 sat_sgr9u;
                            }; } in
                  let {
                    sat_sgr9t [Occ=Once, Dmd=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))>]
                      :: GHC.Num.Num (Data.Fixed.Fixed a_agnFb)
                    [LclId] =
                        [$dHasResolution_sgr97] \u []
                            Data.Fixed.$fNumFixed $dHasResolution_sgr97;
                  } in 
                    GHC.Real.^
                        sat_sgr9t GHC.Real.$fIntegralInteger sat_sgr9v e_sgr99; } in
        let {
          sat_sgr9M [Occ=Once]
            :: Text.Read.Lex.Lexeme
               -> Text.ParserCombinators.ReadPrec.ReadPrec
                    (Data.Fixed.Fixed a_agnFb)
          [LclId] =
              [$dHasResolution_sgr97
               lvl17_sgr98
               e_sgr99
               lvl18_sgr9s] \r [ds_sgr9x]
                  case ds_sgr9x of {
                    __DEFAULT ->
                        Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4;
                    Text.Read.Lex.Number n_sgr9z [Occ=Once] ->
                        case Text.Read.Lex.numberToFixed e_sgr99 n_sgr9z of {
                          GHC.Base.Nothing ->
                              Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4;
                          GHC.Base.Just ds1_sgr9B [Occ=Once!] ->
                              case ds1_sgr9B of {
                                (,) i_sgr9D [Occ=Once] f_sgr9E [Occ=Once] ->
                                    let {
                                      x_sgr9F [Occ=OnceL] :: GHC.Integer.Type.Integer
                                      [LclId] =
                                          [$dHasResolution_sgr97
                                           lvl17_sgr98
                                           lvl18_sgr9s
                                           i_sgr9D
                                           f_sgr9E] \u []
                                              case
                                                  GHC.Integer.Type.timesInteger f_sgr9E lvl17_sgr98
                                              of
                                              sat_sgr9H
                                              { __DEFAULT ->
                                                    case
                                                        Data.Fixed.$fFractionalFixed3
                                                            $dHasResolution_sgr97
                                                            sat_sgr9H
                                                            lvl18_sgr9s
                                                    of
                                                    sat_sgr9I
                                                    { __DEFAULT ->
                                                          case
                                                              GHC.Integer.Type.timesInteger
                                                                  i_sgr9D lvl17_sgr98
                                                          of
                                                          sat_sgr9G
                                                          { __DEFAULT ->
                                                                GHC.Integer.Type.plusInteger
                                                                    sat_sgr9G sat_sgr9I;
                                                          };
                                                    };
                                              }; } in
                                    let {
                                      sat_sgr9L [Occ=Once]
                                        :: Text.ParserCombinators.ReadPrec.Prec
                                           -> forall b.
                                              (Data.Fixed.Fixed a_agnFb
                                               -> Text.ParserCombinators.ReadP.P b)
                                              -> Text.ParserCombinators.ReadP.P b
                                      [LclId] =
                                          [x_sgr9F] \r [ds2_sgr9J k_sgr9K] k_sgr9K x_sgr9F;
                                    } in  sat_sgr9L;
                              };
                        };
                  }; } in
        let {
          sat_sgr9w [Occ=Once] :: GHC.Num.Num (Data.Fixed.Fixed a_agnFb)
          [LclId] =
              [$dHasResolution_sgr97] \u []
                  Data.Fixed.$fNumFixed $dHasResolution_sgr97;
        } in  GHC.Read.readNumber1 sat_sgr9w sat_sgr9M;

Data.Fixed.$fReadFixed_$creadsPrec
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Fixed.Fixed a)
[GblId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgr9N]
        let {
          ds_sgr9O [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Fixed.Fixed a_XgnJE -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dHasResolution_sgr9N] \u []
                  Data.Fixed.$fReadFixed1 $dHasResolution_sgr9N; } in
        let {
          sat_sgr9R [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Fixed.Fixed a_XgnJE)
          [LclId] =
              [ds_sgr9O] \r [n_sgr9P]
                  let {
                    sat_sgr9Q [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P (Data.Fixed.Fixed a_XgnJE)
                    [LclId] =
                        [ds_sgr9O n_sgr9P] \u []
                            ds_sgr9O
                                n_sgr9P Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_sgr9Q;
        } in  sat_sgr9R;

Data.Fixed.$fReadFixed_$creadListPrec
  :: forall a.
     Data.Fixed.HasResolution a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Fixed.Fixed a]
[GblId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgr9S]
        let {
          sat_sgr9T [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Fixed.Fixed a_XgnJC)
          [LclId] =
              [$dHasResolution_sgr9S] \s []
                  Data.Fixed.$fReadFixed1 $dHasResolution_sgr9S;
        } in  GHC.Read.list sat_sgr9T;

Data.Fixed.$fReadFixed_$creadList
  :: forall a.
     Data.Fixed.HasResolution a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Fixed.Fixed a]
[GblId, Arity=1, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgr9U]
        let {
          sat_sgr9W [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Fixed.Fixed a_XgnJD]
          [LclId] =
              [$dHasResolution_sgr9U] \u []
                  let {
                    sat_sgr9V [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Fixed.Fixed a_XgnJD)
                    [LclId] =
                        [$dHasResolution_sgr9U] \s []
                            Data.Fixed.$fReadFixed1 $dHasResolution_sgr9U;
                  } in 
                    GHC.Read.list
                        sat_sgr9V
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_sgr9W;

Data.Fixed.$fReadFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Read.Read (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgr9X]
        let {
          sat_sgra1 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Fixed.Fixed a_XgnJB]
          [LclId] =
              [$dHasResolution_sgr9X] \u []
                  Data.Fixed.$fReadFixed_$creadListPrec $dHasResolution_sgr9X; } in
        let {
          sat_sgra0 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Fixed.Fixed a_XgnJB)
          [LclId] =
              [$dHasResolution_sgr9X] \u []
                  Data.Fixed.$fReadFixed1 $dHasResolution_sgr9X; } in
        let {
          sat_sgr9Z [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Fixed.Fixed a_XgnJB]
          [LclId] =
              [$dHasResolution_sgr9X] \u []
                  Data.Fixed.$fReadFixed_$creadList $dHasResolution_sgr9X; } in
        let {
          sat_sgr9Y [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Fixed.Fixed a_XgnJB)
          [LclId] =
              [$dHasResolution_sgr9X] \u []
                  Data.Fixed.$fReadFixed_$creadsPrec $dHasResolution_sgr9X;
        } in  GHC.Read.C:Read [sat_sgr9Y sat_sgr9Z sat_sgra0 sat_sgra1];

Data.Fixed.$fEqFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Classes.Eq (Data.Fixed.Fixed a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [GHC.Integer.Type.eqInteger
                                     GHC.Integer.Type.neqInteger];

Data.Fixed.$fOrdFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Classes.Ord (Data.Fixed.Fixed a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Fixed.$fEqFixed
                                      GHC.Integer.Type.compareInteger
                                      GHC.Integer.Type.ltInteger
                                      GHC.Integer.Type.leInteger
                                      GHC.Integer.Type.gtInteger
                                      GHC.Integer.Type.geInteger
                                      GHC.Integer.Type.$fOrdInteger_$cmax
                                      GHC.Integer.Type.$fOrdInteger_$cmin];

Data.Fixed.$fRealFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Real.Real (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgra2]
        let {
          sat_sgra4 [Occ=Once]
            :: Data.Fixed.Fixed a_agnIn -> GHC.Real.Rational
          [LclId] =
              [$dHasResolution_sgra2] \r [eta_B1]
                  Data.Fixed.$fRealFixed_$ctoRational
                      $dHasResolution_sgra2 eta_B1; } in
        let {
          sat_sgra3 [Occ=Once] :: GHC.Num.Num (Data.Fixed.Fixed a_agnIn)
          [LclId] =
              [$dHasResolution_sgra2] \u []
                  Data.Fixed.$fNumFixed $dHasResolution_sgra2;
        } in  GHC.Real.C:Real [sat_sgra3 Data.Fixed.$fOrdFixed sat_sgra4];

Data.Fixed.$fRealFracFixed_$ctruncate
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b. GHC.Real.Integral b => Data.Fixed.Fixed a -> b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S(S(S(LLLLLLC(S))LL)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,A)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dHasResolution_sgra5 $dIntegral_sgra6 f_sgra7]
        case $dHasResolution_sgra5 f_sgra7 of dt_sgra8 {
          __DEFAULT ->
              case
                  GHC.Real.$w$s$c/
                      f_sgra7 GHC.Real.$fEnumRatio1 dt_sgra8 GHC.Real.$fEnumRatio1
              of
              { (#,#) ww7_sgraa [Occ=Once] ww8_sgrab ->
                    let {
                      sat_sgraj [Occ=Once] :: GHC.Integer.Type.Integer
                      [LclId] =
                          [ww7_sgraa ww8_sgrab] \u []
                              case
                                  GHC.Integer.Type.eqInteger# ww8_sgrab Data.Fixed.$fEnumFixed1
                              of
                              { __DEFAULT ->
                                    case GHC.Integer.Type.quotRemInteger ww7_sgraa ww8_sgrab of {
                                      (#,#) ipv_sgrag [Occ=Once] _ [Occ=Dead] -> ipv_sgrag;
                                    };
                                1# -> GHC.Real.divZeroError;
                              };
                    } in 
                      case GHC.Real.$p1Integral $dIntegral_sgra6 of sat_sgrac {
                        __DEFAULT ->
                            case GHC.Real.$p1Real sat_sgrac of sat_sgrad {
                              __DEFAULT -> GHC.Num.fromInteger sat_sgrad sat_sgraj;
                            };
                      };
              };
        };

Data.Fixed.$fRealFracFixed_$cround
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b. GHC.Real.Integral b => Data.Fixed.Fixed a -> b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,U(U(U(C(C1(U)),C(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,C(C1(U)),A,A,A,A,A)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dHasResolution_sgrak $dIntegral_sgral f_sgram]
        case $dHasResolution_sgrak f_sgram of dt_sgran {
          __DEFAULT ->
              case
                  GHC.Real.$w$s$c/
                      f_sgram GHC.Real.$fEnumRatio1 dt_sgran GHC.Real.$fEnumRatio1
              of
              { (#,#) ww7_sgrap [Occ=Once] ww8_sgraq [Occ=Once] ->
                    GHC.Real.$w$s$cround $dIntegral_sgral ww7_sgrap ww8_sgraq;
              };
        };

Data.Fixed.$fRealFracFixed_$cceiling
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b. GHC.Real.Integral b => Data.Fixed.Fixed a -> b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,U(U(U(C(C1(U)),A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dHasResolution_sgrar $dIntegral_sgras f_sgrat]
        case $dHasResolution_sgrar f_sgrat of dt_sgrau {
          __DEFAULT ->
              case
                  GHC.Real.$w$s$c/
                      f_sgrat GHC.Real.$fEnumRatio1 dt_sgrau GHC.Real.$fEnumRatio1
              of
              { (#,#) ww7_sgraw [Occ=Once] ww8_sgrax [Occ=Once] ->
                    GHC.Real.$w$s$cceiling $dIntegral_sgras ww7_sgraw ww8_sgrax;
              };
        };

Data.Fixed.$fRealFracFixed_$cfloor
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b. GHC.Real.Integral b => Data.Fixed.Fixed a -> b
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,A)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dHasResolution_sgray $dIntegral_sgraz f_sgraA]
        case $dHasResolution_sgray f_sgraA of dt_sgraB {
          __DEFAULT ->
              case
                  GHC.Real.$w$s$c/
                      f_sgraA GHC.Real.$fEnumRatio1 dt_sgraB GHC.Real.$fEnumRatio1
              of
              { (#,#) ww7_sgraD [Occ=Once] ww8_sgraE [Occ=Once] ->
                    GHC.Real.$w$s$cfloor $dIntegral_sgraz ww7_sgraD ww8_sgraE;
              };
        };

Data.Fixed.$w$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b.
     GHC.Real.Integral b =>
     Data.Fixed.Fixed a -> (# b, Data.Fixed.Fixed a #)
[GblId,
 Arity=3,
 Str=<L,C(U)><L,U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),A,A),A,A,A,A,A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sgraF w3_sgraG w4_sgraH]
        let {
          i_sgraI :: b_sgooh
          [LclId] =
              [w_sgraF w3_sgraG w4_sgraH] \u []
                  Data.Fixed.$fRealFracFixed_$ctruncate
                      w_sgraF w3_sgraG w4_sgraH; } in
        let {
          sat_sgraM [Occ=Once] :: Data.Fixed.Fixed a_sgoof
          [LclId] =
              [w_sgraF w3_sgraG w4_sgraH i_sgraI] \u []
                  case w_sgraF Data.Fixed.$fFractionalFixed2 of sat_sgraK {
                    __DEFAULT ->
                        case GHC.Real.toInteger w3_sgraG i_sgraI of sat_sgraJ {
                          __DEFAULT ->
                              case
                                  GHC.Integer.Type.timesInteger sat_sgraJ sat_sgraK
                              of
                              sat_sgraL
                              { __DEFAULT -> GHC.Integer.Type.minusInteger w4_sgraH sat_sgraL;
                              };
                        };
                  };
        } in  (#,#) [i_sgraI sat_sgraM];

Data.Fixed.$fRealFracFixed_$cproperFraction [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Data.Fixed.HasResolution a =>
     forall b.
     GHC.Real.Integral b =>
     Data.Fixed.Fixed a -> (b, Data.Fixed.Fixed a)
[GblId,
 Arity=3,
 Str=<L,C(U)><L,U(U(U(A,A,A,A,A,A,C(U)),A,A),A,A,A,A,A,A,A,C(U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sgraN w3_sgraO w4_sgraP]
        case Data.Fixed.$w$cproperFraction w_sgraN w3_sgraO w4_sgraP of {
          (#,#) ww1_sgraR [Occ=Once] ww2_sgraS [Occ=Once] ->
              (,) [ww1_sgraR ww2_sgraS];
        };

Data.Fixed.$fRealFracFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Real.RealFrac (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgraT]
        let {
          sat_sgrb0 [Occ=Once]
            :: forall b. GHC.Real.Integral b => Data.Fixed.Fixed a_agnG0 -> b
          [LclId] =
              [$dHasResolution_sgraT] \r [eta_B2 eta_B1]
                  Data.Fixed.$fRealFracFixed_$cfloor
                      $dHasResolution_sgraT eta_B2 eta_B1; } in
        let {
          sat_sgraZ [Occ=Once]
            :: forall b. GHC.Real.Integral b => Data.Fixed.Fixed a_agnG0 -> b
          [LclId] =
              [$dHasResolution_sgraT] \r [eta_B2 eta_B1]
                  Data.Fixed.$fRealFracFixed_$cceiling
                      $dHasResolution_sgraT eta_B2 eta_B1; } in
        let {
          sat_sgraY [Occ=Once]
            :: forall b. GHC.Real.Integral b => Data.Fixed.Fixed a_agnG0 -> b
          [LclId] =
              [$dHasResolution_sgraT] \r [eta_B2 eta_B1]
                  Data.Fixed.$fRealFracFixed_$cround
                      $dHasResolution_sgraT eta_B2 eta_B1; } in
        let {
          sat_sgraX [Occ=Once]
            :: forall b. GHC.Real.Integral b => Data.Fixed.Fixed a_agnG0 -> b
          [LclId] =
              [$dHasResolution_sgraT] \r [eta_B2 eta_B1]
                  Data.Fixed.$fRealFracFixed_$ctruncate
                      $dHasResolution_sgraT eta_B2 eta_B1; } in
        let {
          sat_sgraW [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               Data.Fixed.Fixed a_agnG0 -> (b, Data.Fixed.Fixed a_agnG0)
          [LclId] =
              [$dHasResolution_sgraT] \r [eta_B2 eta_B1]
                  Data.Fixed.$fRealFracFixed_$cproperFraction
                      $dHasResolution_sgraT eta_B2 eta_B1; } in
        let {
          sat_sgraV [Occ=Once]
            :: GHC.Real.Fractional (Data.Fixed.Fixed a_agnG0)
          [LclId] =
              [$dHasResolution_sgraT] \u []
                  Data.Fixed.$fFractionalFixed $dHasResolution_sgraT; } in
        let {
          sat_sgraU [Occ=Once] :: GHC.Real.Real (Data.Fixed.Fixed a_agnG0)
          [LclId] =
              [$dHasResolution_sgraT] \u []
                  Data.Fixed.$fRealFixed $dHasResolution_sgraT;
        } in 
          GHC.Real.C:RealFrac [sat_sgraU
                               sat_sgraV
                               sat_sgraW
                               sat_sgraX
                               sat_sgraY
                               sat_sgraZ
                               sat_sgrb0];

chopZeros_rgnn4 :: GHC.Integer.Type.Integer -> GHC.Base.String
[GblId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
    sat-only [] \r [ds_sgrb1]
        case
            GHC.Integer.Type.eqInteger# ds_sgrb1 Data.Fixed.$fEnumFixed1
        of
        { __DEFAULT ->
              case
                  GHC.Integer.Type.modInteger ds_sgrb1 Data.Fixed.$fHasResolutionE4
              of
              sat_sgrb3
              { __DEFAULT ->
                    case
                        GHC.Integer.Type.eqInteger# sat_sgrb3 Data.Fixed.$fEnumFixed1
                    of
                    { __DEFAULT -> GHC.Show.$fShowInteger_$cshow ds_sgrb1;
                      1# ->
                          case
                              GHC.Integer.Type.divInteger ds_sgrb1 Data.Fixed.$fHasResolutionE4
                          of
                          sat_sgrb5
                          { __DEFAULT -> chopZeros_rgnn4 sat_sgrb5;
                          };
                    };
              };
          1# -> [] [];
        };

lvl14_rgoyT :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! ['0'#];

lvl15_rgoyU :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! ['.'#];

lvl16_rgoyV :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "-"#;

Data.Fixed.showFixed [Occ=LoopBreaker]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Types.Bool -> Data.Fixed.Fixed a -> GHC.Base.String
[GblId, Arity=3, Str=<L,1*C1(U)><L,U><S,U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgrb6 chopTrailingZeros_sgrb7 fa_sgrb8]
        case
            GHC.Integer.Type.ltInteger# fa_sgrb8 Data.Fixed.$fEnumFixed1
        of
        { __DEFAULT ->
              case $dHasResolution_sgrb6 fa_sgrb8 of res_sgrba [Dmd=<S,U>] {
                __DEFAULT ->
                    case
                        GHC.Integer.Type.eqInteger# res_sgrba Data.Fixed.$fEnumFixed1
                    of
                    { __DEFAULT ->
                          case GHC.Integer.Type.divModInteger fa_sgrb8 res_sgrba of {
                            (#,#) ipv_sgrbd [Occ=Once] ipv1_sgrbe [Occ=Once*] ->
                                case GHC.Show.$w$cshowsPrec4 0# ipv_sgrbd GHC.Types.[] of {
                                  (#,#) ww3_sgrbg [Occ=Once] ww4_sgrbh [Occ=Once] ->
                                      let {
                                        sat_sgrc8 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                        [LclId] =
                                            [chopTrailingZeros_sgrb7 res_sgrba ipv1_sgrbe] \s []
                                                case
                                                    GHC.Integer.Type.doubleFromInteger res_sgrba
                                                of
                                                wild2_sgrbj
                                                { __DEFAULT ->
                                                      case logDouble# [wild2_sgrbj] of wild3_sgrbk {
                                                        __DEFAULT ->
                                                            case Data.Fixed.$fReadFixed2 of {
                                                              GHC.Types.D# v1_sgrbm [Occ=Once] ->
                                                                  case
                                                                      /## [wild3_sgrbk v1_sgrbm]
                                                                  of
                                                                  wild4_sgrbn
                                                                  { __DEFAULT ->
                                                                        case
                                                                            double2Int# [wild4_sgrbn]
                                                                        of
                                                                        n_sgrbo [Dmd=<S,U>]
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  int2Double# [n_sgrbo]
                                                                              of
                                                                              sat_sgrc5
                                                                              { __DEFAULT ->
                                                                                    let-no-escape {
                                                                                      $j_sgrbp [Occ=Once*!T[1],
                                                                                                Dmd=<C(S),1*C1(U)>]
                                                                                        :: GHC.Prim.Int#
                                                                                           -> [GHC.Types.Char]
                                                                                      [LclId[JoinId(1)],
                                                                                       Arity=1,
                                                                                       Str=<S,U>,
                                                                                       Unf=OtherCon []] =
                                                                                          sat-only [chopTrailingZeros_sgrb7
                                                                                                    res_sgrba
                                                                                                    ipv1_sgrbe] \r [ww_sgrbq]
                                                                                              case
                                                                                                  <# [ww_sgrbq
                                                                                                      0#]
                                                                                              of
                                                                                              { __DEFAULT ->
                                                                                                    let-no-escape {
                                                                                                      $j1_sgrbs [Occ=Once*!T[1],
                                                                                                                 Dmd=<C(S),1*C1(U)>]
                                                                                                        :: GHC.Integer.Type.Integer
                                                                                                           -> [GHC.Types.Char]
                                                                                                      [LclId[JoinId(1)],
                                                                                                       Arity=1,
                                                                                                       Str=<S,U>,
                                                                                                       Unf=OtherCon []] =
                                                                                                          sat-only [chopTrailingZeros_sgrb7
                                                                                                                    ww_sgrbq] \r [ds_sgrbt]
                                                                                                              let-no-escape {
                                                                                                                fail_sgrbu [Occ=Once*!T[1],
                                                                                                                            Dmd=<L,1*C1(U)>]
                                                                                                                  :: GHC.Prim.Void#
                                                                                                                     -> [GHC.Types.Char]
                                                                                                                [LclId[JoinId(1)],
                                                                                                                 Arity=1,
                                                                                                                 Str=<L,A>,
                                                                                                                 Unf=OtherCon []] =
                                                                                                                    sat-only [chopTrailingZeros_sgrb7
                                                                                                                              ww_sgrbq
                                                                                                                              ds_sgrbt] \r [void_0E]
                                                                                                                        case
                                                                                                                            GHC.Show.$w$cshowsPrec4
                                                                                                                                0#
                                                                                                                                ds_sgrbt
                                                                                                                                GHC.Types.[]
                                                                                                                        of
                                                                                                                        { (#,#) ww5_sgrbx [Occ=OnceL]
                                                                                                                                ww6_sgrby [Occ=OnceL] ->
                                                                                                                              let {
                                                                                                                                s_sgrbz [Dmd=<S,U>]
                                                                                                                                  :: GHC.Base.String
                                                                                                                                [LclId,
                                                                                                                                 Unf=OtherCon []] =
                                                                                                                                    CCCS :! [ww5_sgrbx
                                                                                                                                             ww6_sgrby];
                                                                                                                              } in 
                                                                                                                                case
                                                                                                                                    GHC.List.$wlenAcc
                                                                                                                                        s_sgrbz
                                                                                                                                        0#
                                                                                                                                of
                                                                                                                                ww7_sgrbA
                                                                                                                                { __DEFAULT ->
                                                                                                                                      case
                                                                                                                                          -# [ww_sgrbq
                                                                                                                                              ww7_sgrbA]
                                                                                                                                      of
                                                                                                                                      y_sgrbB [Dmd=<S,U>]
                                                                                                                                      { __DEFAULT ->
                                                                                                                                            case
                                                                                                                                                <# [0#
                                                                                                                                                    y_sgrbB]
                                                                                                                                            of
                                                                                                                                            { __DEFAULT ->
                                                                                                                                                  case
                                                                                                                                                      chopTrailingZeros_sgrb7
                                                                                                                                                  of
                                                                                                                                                  { GHC.Types.False ->
                                                                                                                                                        : [lvl15_rgoyU
                                                                                                                                                           s_sgrbz];
                                                                                                                                                    GHC.Types.True ->
                                                                                                                                                        case
                                                                                                                                                            chopZeros_rgnn4
                                                                                                                                                                ds_sgrbt
                                                                                                                                                        of
                                                                                                                                                        wild6_sgrbE
                                                                                                                                                        { [] ->
                                                                                                                                                              [] [];
                                                                                                                                                          : _ [Occ=Dead]
                                                                                                                                                            _ [Occ=Dead] ->
                                                                                                                                                              : [lvl15_rgoyU
                                                                                                                                                                 wild6_sgrbE];
                                                                                                                                                        };
                                                                                                                                                  };
                                                                                                                                              1# ->
                                                                                                                                                  let {
                                                                                                                                                    n1_sgrbH [Occ=OnceL]
                                                                                                                                                      :: [GHC.Types.Char]
                                                                                                                                                    [LclId] =
                                                                                                                                                        [chopTrailingZeros_sgrb7
                                                                                                                                                         ds_sgrbt
                                                                                                                                                         s_sgrbz] \u []
                                                                                                                                                            case
                                                                                                                                                                chopTrailingZeros_sgrb7
                                                                                                                                                            of
                                                                                                                                                            { GHC.Types.False ->
                                                                                                                                                                  s_sgrbz;
                                                                                                                                                              GHC.Types.True ->
                                                                                                                                                                  chopZeros_rgnn4
                                                                                                                                                                      ds_sgrbt;
                                                                                                                                                            }; } in
                                                                                                                                                  let {
                                                                                                                                                    lvl17_sgrbJ [Occ=OnceL]
                                                                                                                                                      :: [GHC.Types.Char]
                                                                                                                                                    [LclId,
                                                                                                                                                     Unf=OtherCon []] =
                                                                                                                                                        CCCS :! [lvl14_rgoyT
                                                                                                                                                                 n1_sgrbH]; } in
                                                                                                                                                  let {
                                                                                                                                                    $wxs_sgrbK [InlPrag=NOUSERINLINE[0],
                                                                                                                                                                Occ=LoopBreaker]
                                                                                                                                                      :: GHC.Prim.Int#
                                                                                                                                                         -> [GHC.Types.Char]
                                                                                                                                                    [LclId,
                                                                                                                                                     Arity=1,
                                                                                                                                                     Str=<S,1*U>,
                                                                                                                                                     Unf=OtherCon []] =
                                                                                                                                                        sat-only [lvl17_sgrbJ
                                                                                                                                                                  $wxs_sgrbK] \r [ww8_sgrbL]
                                                                                                                                                            case
                                                                                                                                                                ww8_sgrbL
                                                                                                                                                            of
                                                                                                                                                            ds3_sgrbM
                                                                                                                                                            { __DEFAULT ->
                                                                                                                                                                  let {
                                                                                                                                                                    sat_sgrbO [Occ=Once]
                                                                                                                                                                      :: [GHC.Types.Char]
                                                                                                                                                                    [LclId] =
                                                                                                                                                                        [$wxs_sgrbK
                                                                                                                                                                         ds3_sgrbM] \u []
                                                                                                                                                                            case
                                                                                                                                                                                -# [ds3_sgrbM
                                                                                                                                                                                    1#]
                                                                                                                                                                            of
                                                                                                                                                                            sat_sgrbN
                                                                                                                                                                            { __DEFAULT ->
                                                                                                                                                                                  $wxs_sgrbK
                                                                                                                                                                                      sat_sgrbN;
                                                                                                                                                                            };
                                                                                                                                                                  } in 
                                                                                                                                                                    : [lvl14_rgoyT
                                                                                                                                                                       sat_sgrbO];
                                                                                                                                                              1# ->
                                                                                                                                                                  lvl17_sgrbJ;
                                                                                                                                                            };
                                                                                                                                                  } in 
                                                                                                                                                    case
                                                                                                                                                        $wxs_sgrbK
                                                                                                                                                            y_sgrbB
                                                                                                                                                    of
                                                                                                                                                    wild5_sgrbP
                                                                                                                                                    { [] ->
                                                                                                                                                          [] [];
                                                                                                                                                      : _ [Occ=Dead]
                                                                                                                                                        _ [Occ=Dead] ->
                                                                                                                                                          : [lvl15_rgoyU
                                                                                                                                                             wild5_sgrbP];
                                                                                                                                                    };
                                                                                                                                            };
                                                                                                                                      };
                                                                                                                                };
                                                                                                                        };
                                                                                                              } in 
                                                                                                                case
                                                                                                                    chopTrailingZeros_sgrb7
                                                                                                                of
                                                                                                                { GHC.Types.False ->
                                                                                                                      fail_sgrbu
                                                                                                                          GHC.Prim.void#;
                                                                                                                  GHC.Types.True ->
                                                                                                                      case
                                                                                                                          GHC.Integer.Type.eqInteger#
                                                                                                                              ds_sgrbt
                                                                                                                              Data.Fixed.$fEnumFixed1
                                                                                                                      of
                                                                                                                      { __DEFAULT ->
                                                                                                                            fail_sgrbu
                                                                                                                                GHC.Prim.void#;
                                                                                                                        1# ->
                                                                                                                            [] [];
                                                                                                                      };
                                                                                                                };
                                                                                                    } in 
                                                                                                      case
                                                                                                          ww_sgrbq
                                                                                                      of
                                                                                                      wild5_sgrbU
                                                                                                      { __DEFAULT ->
                                                                                                            case
                                                                                                                GHC.Real.$wf
                                                                                                                    Data.Fixed.$fHasResolutionE4
                                                                                                                    wild5_sgrbU
                                                                                                            of
                                                                                                            sat_sgrbV
                                                                                                            { __DEFAULT ->
                                                                                                                  case
                                                                                                                      GHC.Integer.Type.timesInteger
                                                                                                                          ipv1_sgrbe
                                                                                                                          sat_sgrbV
                                                                                                                  of
                                                                                                                  sat_sgrbW
                                                                                                                  { __DEFAULT ->
                                                                                                                        case
                                                                                                                            GHC.Integer.Type.plusInteger
                                                                                                                                sat_sgrbW
                                                                                                                                res_sgrba
                                                                                                                        of
                                                                                                                        sat_sgrbX
                                                                                                                        { __DEFAULT ->
                                                                                                                              case
                                                                                                                                  GHC.Integer.Type.minusInteger
                                                                                                                                      sat_sgrbX
                                                                                                                                      Data.Fixed.$fEnumFixed2
                                                                                                                              of
                                                                                                                              sat_sgrbY
                                                                                                                              { __DEFAULT ->
                                                                                                                                    case
                                                                                                                                        GHC.Integer.Type.divInteger
                                                                                                                                            sat_sgrbY
                                                                                                                                            res_sgrba
                                                                                                                                    of
                                                                                                                                    sat_sgrbZ
                                                                                                                                    { __DEFAULT ->
                                                                                                                                          $j1_sgrbs
                                                                                                                                              sat_sgrbZ;
                                                                                                                                    };
                                                                                                                              };
                                                                                                                        };
                                                                                                                  };
                                                                                                            };
                                                                                                        0# ->
                                                                                                            case
                                                                                                                GHC.Integer.Type.timesInteger
                                                                                                                    ipv1_sgrbe
                                                                                                                    GHC.Real.$fEnumRatio1
                                                                                                            of
                                                                                                            sat_sgrc0
                                                                                                            { __DEFAULT ->
                                                                                                                  case
                                                                                                                      GHC.Integer.Type.plusInteger
                                                                                                                          sat_sgrc0
                                                                                                                          res_sgrba
                                                                                                                  of
                                                                                                                  sat_sgrc1
                                                                                                                  { __DEFAULT ->
                                                                                                                        case
                                                                                                                            GHC.Integer.Type.minusInteger
                                                                                                                                sat_sgrc1
                                                                                                                                Data.Fixed.$fEnumFixed2
                                                                                                                        of
                                                                                                                        sat_sgrc2
                                                                                                                        { __DEFAULT ->
                                                                                                                              case
                                                                                                                                  GHC.Integer.Type.divInteger
                                                                                                                                      sat_sgrc2
                                                                                                                                      res_sgrba
                                                                                                                              of
                                                                                                                              sat_sgrc3
                                                                                                                              { __DEFAULT ->
                                                                                                                                    $j1_sgrbs
                                                                                                                                        sat_sgrc3;
                                                                                                                              };
                                                                                                                        };
                                                                                                                  };
                                                                                                            };
                                                                                                      };
                                                                                                1# ->
                                                                                                    GHC.Real.^1;
                                                                                              };
                                                                                    } in 
                                                                                      case
                                                                                          <## [sat_sgrc5
                                                                                               wild4_sgrbn]
                                                                                      of
                                                                                      { __DEFAULT ->
                                                                                            $j_sgrbp
                                                                                                n_sgrbo;
                                                                                        1# ->
                                                                                            case
                                                                                                +# [n_sgrbo
                                                                                                    1#]
                                                                                            of
                                                                                            sat_sgrc7
                                                                                            { __DEFAULT ->
                                                                                                  $j_sgrbp
                                                                                                      sat_sgrc7;
                                                                                            };
                                                                                      };
                                                                              };
                                                                        };
                                                                  };
                                                            };
                                                      };
                                                }; } in
                                      let {
                                        sat_sgrbi [Occ=Once] :: [GHC.Types.Char]
                                        [LclId] =
                                            CCCS :! [ww3_sgrbg ww4_sgrbh];
                                      } in  GHC.Base.++ sat_sgrbi sat_sgrc8;
                                };
                          };
                      1# -> GHC.Real.divZeroError;
                    };
              };
          1# ->
              let {
                sat_sgrcb [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [$dHasResolution_sgrb6 chopTrailingZeros_sgrb7 fa_sgrb8] \u []
                        case GHC.Integer.Type.negateInteger fa_sgrb8 of sat_sgrca {
                          __DEFAULT ->
                              Data.Fixed.showFixed
                                  $dHasResolution_sgrb6 chopTrailingZeros_sgrb7 sat_sgrca;
                        };
              } in  GHC.CString.unpackAppendCString# lvl16_rgoyV sat_sgrcb;
        };

Data.Fixed.$fShowFixed_$cshow
  :: forall a.
     Data.Fixed.HasResolution a =>
     Data.Fixed.Fixed a -> GHC.Base.String
[GblId, Arity=2, Str=<L,C(U)>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgrcc eta_B1]
        Data.Fixed.showFixed $dHasResolution_sgrcc GHC.Types.False eta_B1;

Data.Fixed.$fShowFixed_$cshowsPrec
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Types.Int -> Data.Fixed.Fixed a -> GHC.Show.ShowS
[GblId,
 Arity=4,
 Str=<L,1*C1(U)><L,A><S,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dHasResolution_sgrcd ds_sgrce x_sgrcf s_sgrcg]
        case
            Data.Fixed.showFixed $dHasResolution_sgrcd GHC.Types.False x_sgrcf
        of
        sat_sgrch
        { __DEFAULT -> GHC.Base.++ sat_sgrch s_sgrcg;
        };

Data.Fixed.$fShowFixed_$cshowList
  :: forall a.
     Data.Fixed.HasResolution a =>
     [Data.Fixed.Fixed a] -> GHC.Show.ShowS
[GblId, Arity=3, Str=<L,C(U)><S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [$dHasResolution_sgrci ls_sgrcj s_sgrck]
        let {
          sat_sgrco [Occ=Once] :: Data.Fixed.Fixed a_agnFG -> GHC.Show.ShowS
          [LclId] =
              [$dHasResolution_sgrci] \r [x_sgrcl s1_sgrcm]
                  case
                      Data.Fixed.showFixed $dHasResolution_sgrci GHC.Types.False x_sgrcl
                  of
                  sat_sgrcn
                  { __DEFAULT -> GHC.Base.++ sat_sgrcn s1_sgrcm;
                  };
        } in  GHC.Show.showList__ sat_sgrco ls_sgrcj s_sgrck;

Data.Fixed.$fShowFixed [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     Data.Fixed.HasResolution a =>
     GHC.Show.Show (Data.Fixed.Fixed a)
[GblId[DFunId], Arity=1, Str=<L,C(U)>m] =
    [] \r [$dHasResolution_sgrcp]
        let {
          sat_sgrcs [Occ=Once]
            :: [Data.Fixed.Fixed a_agnFG] -> GHC.Show.ShowS
          [LclId] =
              [$dHasResolution_sgrcp] \r [eta_B2 eta_B1]
                  Data.Fixed.$fShowFixed_$cshowList
                      $dHasResolution_sgrcp eta_B2 eta_B1; } in
        let {
          sat_sgrcr [Occ=Once] :: Data.Fixed.Fixed a_agnFG -> GHC.Base.String
          [LclId] =
              [$dHasResolution_sgrcp] \r [eta_B1]
                  Data.Fixed.$fShowFixed_$cshow $dHasResolution_sgrcp eta_B1; } in
        let {
          sat_sgrcq [Occ=Once]
            :: GHC.Types.Int -> Data.Fixed.Fixed a_agnFG -> GHC.Show.ShowS
          [LclId] =
              [$dHasResolution_sgrcp] \r [eta_B3 eta_B2 eta_B1]
                  Data.Fixed.$fShowFixed_$cshowsPrec
                      $dHasResolution_sgrcp eta_B3 eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_sgrcq sat_sgrcr sat_sgrcs];

