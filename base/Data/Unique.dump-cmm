
==================== Output Cmm ====================
2018-03-16 16:07:30.210885947 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:30.2114563 UTC

[section ""data" . Data.Unique.$fEqUnique_closure" {
     Data.Unique.$fEqUnique_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Integer.Type.eqInteger_closure+2;
         const GHC.Integer.Type.neqInteger_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.212040037 UTC

[section ""data" . Data.Unique.$fOrdUnique_closure" {
     Data.Unique.$fOrdUnique_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Unique.$fEqUnique_closure+1;
         const GHC.Integer.Type.compareInteger_closure+2;
         const GHC.Integer.Type.ltInteger_closure+2;
         const GHC.Integer.Type.leInteger_closure+2;
         const GHC.Integer.Type.gtInteger_closure+2;
         const GHC.Integer.Type.geInteger_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmax_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.212978041 UTC

[section ""data" . lvl_rcBip_closure" {
     lvl_rcBip_closure:
         const lvl_rcBip_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_rcBip_entry() //  [R1]
         { info_tbl: [(ccBiW,
                       label: lvl_rcBip_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBiW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccBiX; else goto ccBiY;
       ccBiX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccBiY: // global
           (_ccBiT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccBiT::I64 == 0) goto ccBiV; else goto ccBiU;
       ccBiV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccBiU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccBiT::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.214230213 UTC

[section ""data" . lvl1_rcBiq_closure" {
     lvl1_rcBiq_closure:
         const lvl1_rcBiq_info;
         const 0;
 },
 lvl1_rcBiq_entry() //  []
         { info_tbl: [(ccBj8,
                       label: lvl1_rcBiq_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBj8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccBj9; else goto ccBja;
       ccBj9: // global
           R1 = lvl1_rcBiq_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccBja: // global
           I64[Sp - 8] = block_ccBj3_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _ccBj3() //  []
         { info_tbl: [(ccBj3,
                       label: block_ccBj3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBj3: // global
           I64[Sp] = block_ccBj5_info;
           R1 = lvl_rcBip_closure;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccBj5() //  [R1]
         { info_tbl: [(ccBj5,
                       label: block_ccBj5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBj5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccBje; else goto ccBjd;
       ccBje: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccBjd: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.215539363 UTC

[section ""data" . Data.Unique.uniqSource_closure" {
     Data.Unique.uniqSource_closure:
         const Data.Unique.uniqSource_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Unique.uniqSource_entry() //  [R1]
         { info_tbl: [(ccBjo,
                       label: Data.Unique.uniqSource_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBjo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccBjp; else goto ccBjq;
       ccBjp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccBjq: // global
           (_ccBjj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccBjj::I64 == 0) goto ccBjl; else goto ccBjk;
       ccBjl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccBjk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccBjj::I64;
           I64[Sp - 24] = block_ccBjm_info;
           Sp = Sp - 24;
           call lvl1_rcBiq_entry() args: 8, res: 8, upd: 24;
     }
 },
 _ccBjm() //  [R1]
         { info_tbl: [(ccBjm,
                       label: block_ccBjm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBjm: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.216782878 UTC

[section ""data" . Data.Unique.hashUnique_closure" {
     Data.Unique.hashUnique_closure:
         const Data.Unique.hashUnique_info;
 },
 Data.Unique.hashUnique_entry() //  [R2]
         { info_tbl: [(ccBjy,
                       label: Data.Unique.hashUnique_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBjy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccBjC; else goto ccBjD;
       ccBjC: // global
           R2 = R2;
           R1 = Data.Unique.hashUnique_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccBjD: // global
           I64[Sp - 8] = block_ccBjw_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.hashInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccBjw() //  [R1]
         { info_tbl: [(ccBjw,
                       label: block_ccBjw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBjw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccBjG; else goto ccBjF;
       ccBjG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccBjF: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.217811541 UTC

[section ""cstring" . Data.Unique.$trModule4_bytes" {
     Data.Unique.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.218395073 UTC

[section ""data" . Data.Unique.$trModule3_closure" {
     Data.Unique.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Unique.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.218970968 UTC

[section ""cstring" . Data.Unique.$trModule2_bytes" {
     Data.Unique.$trModule2_bytes:
         I8[] [68,97,116,97,46,85,110,105,113,117,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.219479208 UTC

[section ""data" . Data.Unique.$trModule1_closure" {
     Data.Unique.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Unique.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.220030638 UTC

[section ""data" . Data.Unique.$trModule_closure" {
     Data.Unique.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Unique.$trModule3_closure+1;
         const Data.Unique.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.220585825 UTC

[section ""data" . $krep_rcBir_closure" {
     $krep_rcBir_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.221106096 UTC

[section ""cstring" . Data.Unique.$tcUnique2_bytes" {
     Data.Unique.$tcUnique2_bytes:
         I8[] [85,110,105,113,117,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.221705852 UTC

[section ""data" . Data.Unique.$tcUnique1_closure" {
     Data.Unique.$tcUnique1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Unique.$tcUnique2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.222259803 UTC

[section ""data" . Data.Unique.$tcUnique_closure" {
     Data.Unique.$tcUnique_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Unique.$trModule_closure+1;
         const Data.Unique.$tcUnique1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9376197555697821408;
         const 12289580968443169787;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.222854124 UTC

[section ""data" . $krep1_rcBis_closure" {
     $krep1_rcBis_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Unique.$tcUnique_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.223426827 UTC

[section ""data" . Data.Unique.$tc'Unique1_closure" {
     Data.Unique.$tc'Unique1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcBir_closure+1;
         const $krep1_rcBis_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.224040097 UTC

[section ""cstring" . Data.Unique.$tc'Unique3_bytes" {
     Data.Unique.$tc'Unique3_bytes:
         I8[] [39,85,110,105,113,117,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.224582354 UTC

[section ""data" . Data.Unique.$tc'Unique2_closure" {
     Data.Unique.$tc'Unique2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Unique.$tc'Unique3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.225181764 UTC

[section ""data" . Data.Unique.$tc'Unique_closure" {
     Data.Unique.$tc'Unique_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Unique.$trModule_closure+1;
         const Data.Unique.$tc'Unique2_closure+1;
         const Data.Unique.$tc'Unique1_closure+4;
         const 6673795421757133892;
         const 3923002115329816747;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.225823401 UTC

[section ""data" . sat_scBiF_closure" {
     sat_scBiF_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.226397565 UTC

[section ""data" . sat_scBiG_closure" {
     sat_scBiG_closure:
         const :_con_info;
         const sat_scBiF_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.22721262 UTC

[section ""data" . Data.Unique.newUnique3_closure" {
     Data.Unique.newUnique3_closure:
         const Data.Unique.newUnique3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Unique.newUnique3_entry() //  [R1]
         { info_tbl: [(ccBjN,
                       label: Data.Unique.newUnique3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBjN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccBjO; else goto ccBjP;
       ccBjO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccBjP: // global
           (_ccBjK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccBjK::I64 == 0) goto ccBjM; else goto ccBjL;
       ccBjM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccBjL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccBjK::I64;
           R3 = sat_scBiG_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.228386126 UTC

[section ""data" . Data.Unique.newUnique2_closure" {
     Data.Unique.newUnique2_closure:
         const Data.Unique.newUnique2_info;
         const 0;
 },
 Data.Unique.newUnique2_entry() //  [R2]
         { info_tbl: [(ccBjW,
                       label: Data.Unique.newUnique2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBjW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccBk0; else goto ccBk1;
       ccBk0: // global
           R2 = R2;
           R1 = Data.Unique.newUnique2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccBk1: // global
           I64[Sp - 8] = block_ccBjU_info;
           R3 = Data.Unique.newUnique3_closure;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccBjU() //  [R1]
         { info_tbl: [(ccBjU,
                       label: block_ccBjU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBjU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccBk4; else goto ccBk3;
       ccBk4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccBk3: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.229777611 UTC

[section ""data" . Data.Unique.newUnique1_closure" {
     Data.Unique.newUnique1_closure:
         const Data.Unique.newUnique1_info;
         const 0;
 },
 Data.Unique.newUnique1_entry() //  []
         { info_tbl: [(ccBkc,
                       label: Data.Unique.newUnique1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBkc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccBki; else goto ccBkj;
       ccBki: // global
           R1 = Data.Unique.newUnique1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccBkj: // global
           I64[Sp - 8] = block_ccBk9_info;
           R1 = Data.Unique.uniqSource_closure;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucBkr; else goto ccBka;
       ucBkr: // global
           call _ccBk9(R1) args: 0, res: 0, upd: 0;
       ccBka: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccBk9() //  [R1]
         { info_tbl: [(ccBk9,
                       label: block_ccBk9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBk9: // global
           I64[Sp] = block_ccBkf_info;
           R2 = Data.Unique.newUnique2_closure+1;
           R1 = P64[R1 + 7];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccBkf() //  [R1]
         { info_tbl: [(ccBkf,
                       label: block_ccBkf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBkf: // global
           I64[Sp - 8] = block_ccBkh_info;
           _scBiO::P64 = R1;
           R1 = R1;
           P64[Sp] = _scBiO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucBks; else goto ccBkm;
       ucBks: // global
           call _ccBkh() args: 0, res: 0, upd: 0;
       ccBkm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccBkh() //  []
         { info_tbl: [(ccBkh,
                       label: block_ccBkh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBkh: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.231178076 UTC

[section ""data" . Data.Unique.newUnique_closure" {
     Data.Unique.newUnique_closure:
         const Data.Unique.newUnique_info;
         const 0;
 },
 Data.Unique.newUnique_entry() //  []
         { info_tbl: [(ccBkx,
                       label: Data.Unique.newUnique_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBkx: // global
           call Data.Unique.newUnique1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.231873282 UTC

[section ""relreadonly" . ScBjf_srt" {
     ScBjf_srt:
         const lvl_rcBip_closure;
         const lvl1_rcBiq_closure;
         const sat_scBiG_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const Data.Unique.newUnique2_closure;
         const Data.Unique.newUnique3_closure;
         const Data.Unique.uniqSource_closure;
         const Data.Unique.newUnique1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.232467853 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:30.232974968 UTC

[section ""data" . Data.Unique.$fEqUnique_closure" {
     Data.Unique.$fEqUnique_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Integer.Type.eqInteger_closure+2;
         const GHC.Integer.Type.neqInteger_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.233964913 UTC

[section ""data" . Data.Unique.$fOrdUnique_closure" {
     Data.Unique.$fOrdUnique_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Unique.$fEqUnique_closure+1;
         const GHC.Integer.Type.compareInteger_closure+2;
         const GHC.Integer.Type.ltInteger_closure+2;
         const GHC.Integer.Type.leInteger_closure+2;
         const GHC.Integer.Type.gtInteger_closure+2;
         const GHC.Integer.Type.geInteger_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmax_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.234765815 UTC

[section ""data" . lvl_rcBip_closure" {
     lvl_rcBip_closure:
         const lvl_rcBip_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_rcBip_entry() //  [R1]
         { info_tbl: [(ccBkG,
                       label: lvl_rcBip_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBkG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccBkH; else goto ccBkI;
       ccBkH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccBkI: // global
           (_ccBkD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccBkD::I64 == 0) goto ccBkF; else goto ccBkE;
       ccBkF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccBkE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccBkD::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.235908375 UTC

[section ""data" . lvl1_rcBiq_closure" {
     lvl1_rcBiq_closure:
         const lvl1_rcBiq_info;
         const 0;
 },
 lvl1_rcBiq_entry() //  []
         { info_tbl: [(ccBkS,
                       label: lvl1_rcBiq_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBkS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccBkT; else goto ccBkU;
       ccBkT: // global
           R1 = lvl1_rcBiq_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccBkU: // global
           I64[Sp - 8] = block_ccBkN_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _ccBkN() //  []
         { info_tbl: [(ccBkN,
                       label: block_ccBkN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBkN: // global
           I64[Sp] = block_ccBkP_info;
           R1 = lvl_rcBip_closure;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccBkP() //  [R1]
         { info_tbl: [(ccBkP,
                       label: block_ccBkP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBkP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccBkY; else goto ccBkX;
       ccBkY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccBkX: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.23717467 UTC

[section ""data" . Data.Unique.uniqSource_closure" {
     Data.Unique.uniqSource_closure:
         const Data.Unique.uniqSource_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Unique.uniqSource_entry() //  [R1]
         { info_tbl: [(ccBl7,
                       label: Data.Unique.uniqSource_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBl7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccBl8; else goto ccBl9;
       ccBl8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccBl9: // global
           (_ccBl2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccBl2::I64 == 0) goto ccBl4; else goto ccBl3;
       ccBl4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccBl3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccBl2::I64;
           I64[Sp - 24] = block_ccBl5_info;
           Sp = Sp - 24;
           call lvl1_rcBiq_entry() args: 8, res: 8, upd: 24;
     }
 },
 _ccBl5() //  [R1]
         { info_tbl: [(ccBl5,
                       label: block_ccBl5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBl5: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.238456743 UTC

[section ""data" . Data.Unique.hashUnique_closure" {
     Data.Unique.hashUnique_closure:
         const Data.Unique.hashUnique_info;
 },
 Data.Unique.hashUnique_entry() //  [R2]
         { info_tbl: [(ccBlh,
                       label: Data.Unique.hashUnique_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBlh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccBll; else goto ccBlm;
       ccBll: // global
           R2 = R2;
           R1 = Data.Unique.hashUnique_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccBlm: // global
           I64[Sp - 8] = block_ccBlf_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.hashInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccBlf() //  [R1]
         { info_tbl: [(ccBlf,
                       label: block_ccBlf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBlf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccBlp; else goto ccBlo;
       ccBlp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccBlo: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.239479925 UTC

[section ""cstring" . Data.Unique.$trModule4_bytes" {
     Data.Unique.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.240024955 UTC

[section ""data" . Data.Unique.$trModule3_closure" {
     Data.Unique.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Unique.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.240563489 UTC

[section ""cstring" . Data.Unique.$trModule2_bytes" {
     Data.Unique.$trModule2_bytes:
         I8[] [68,97,116,97,46,85,110,105,113,117,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.24109679 UTC

[section ""data" . Data.Unique.$trModule1_closure" {
     Data.Unique.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Unique.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.24169363 UTC

[section ""data" . Data.Unique.$trModule_closure" {
     Data.Unique.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Unique.$trModule3_closure+1;
         const Data.Unique.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.243157596 UTC

[section ""data" . $krep_rcBir_closure" {
     $krep_rcBir_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.24370355 UTC

[section ""cstring" . Data.Unique.$tcUnique2_bytes" {
     Data.Unique.$tcUnique2_bytes:
         I8[] [85,110,105,113,117,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.244224509 UTC

[section ""data" . Data.Unique.$tcUnique1_closure" {
     Data.Unique.$tcUnique1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Unique.$tcUnique2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.244765228 UTC

[section ""data" . Data.Unique.$tcUnique_closure" {
     Data.Unique.$tcUnique_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Unique.$trModule_closure+1;
         const Data.Unique.$tcUnique1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9376197555697821408;
         const 12289580968443169787;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.245729025 UTC

[section ""data" . $krep1_rcBis_closure" {
     $krep1_rcBis_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Unique.$tcUnique_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.246273971 UTC

[section ""data" . Data.Unique.$tc'Unique1_closure" {
     Data.Unique.$tc'Unique1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcBir_closure+1;
         const $krep1_rcBis_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.246851625 UTC

[section ""cstring" . Data.Unique.$tc'Unique3_bytes" {
     Data.Unique.$tc'Unique3_bytes:
         I8[] [39,85,110,105,113,117,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.247363833 UTC

[section ""data" . Data.Unique.$tc'Unique2_closure" {
     Data.Unique.$tc'Unique2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Unique.$tc'Unique3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.247937007 UTC

[section ""data" . Data.Unique.$tc'Unique_closure" {
     Data.Unique.$tc'Unique_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Unique.$trModule_closure+1;
         const Data.Unique.$tc'Unique2_closure+1;
         const Data.Unique.$tc'Unique1_closure+4;
         const 6673795421757133892;
         const 3923002115329816747;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.248511278 UTC

[section ""data" . sat_scBiF_closure" {
     sat_scBiF_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.249082241 UTC

[section ""data" . sat_scBiG_closure" {
     sat_scBiG_closure:
         const :_con_info;
         const sat_scBiF_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.249941139 UTC

[section ""data" . Data.Unique.newUnique3_closure" {
     Data.Unique.newUnique3_closure:
         const Data.Unique.newUnique3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Unique.newUnique3_entry() //  [R1]
         { info_tbl: [(ccBlw,
                       label: Data.Unique.newUnique3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBlw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccBlx; else goto ccBly;
       ccBlx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccBly: // global
           (_ccBlt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccBlt::I64 == 0) goto ccBlv; else goto ccBlu;
       ccBlv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccBlu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccBlt::I64;
           R3 = sat_scBiG_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.251123026 UTC

[section ""data" . Data.Unique.newUnique2_closure" {
     Data.Unique.newUnique2_closure:
         const Data.Unique.newUnique2_info;
         const 0;
 },
 Data.Unique.newUnique2_entry() //  [R2]
         { info_tbl: [(ccBlF,
                       label: Data.Unique.newUnique2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBlF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccBlJ; else goto ccBlK;
       ccBlJ: // global
           R2 = R2;
           R1 = Data.Unique.newUnique2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccBlK: // global
           I64[Sp - 8] = block_ccBlD_info;
           R3 = Data.Unique.newUnique3_closure;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccBlD() //  [R1]
         { info_tbl: [(ccBlD,
                       label: block_ccBlD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBlD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccBlN; else goto ccBlM;
       ccBlN: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccBlM: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.252424697 UTC

[section ""data" . Data.Unique.newUnique1_closure" {
     Data.Unique.newUnique1_closure:
         const Data.Unique.newUnique1_info;
         const 0;
 },
 Data.Unique.newUnique1_entry() //  []
         { info_tbl: [(ccBlV,
                       label: Data.Unique.newUnique1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBlV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccBm1; else goto ccBm2;
       ccBm1: // global
           R1 = Data.Unique.newUnique1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccBm2: // global
           I64[Sp - 8] = block_ccBlS_info;
           R1 = Data.Unique.uniqSource_closure;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucBma; else goto ccBlT;
       ucBma: // global
           call _ccBlS(R1) args: 0, res: 0, upd: 0;
       ccBlT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccBlS() //  [R1]
         { info_tbl: [(ccBlS,
                       label: block_ccBlS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBlS: // global
           I64[Sp] = block_ccBlY_info;
           R2 = Data.Unique.newUnique2_closure+1;
           R1 = P64[R1 + 7];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccBlY() //  [R1]
         { info_tbl: [(ccBlY,
                       label: block_ccBlY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBlY: // global
           I64[Sp - 8] = block_ccBm0_info;
           _scBiO::P64 = R1;
           R1 = R1;
           P64[Sp] = _scBiO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucBmb; else goto ccBm5;
       ucBmb: // global
           call _ccBm0() args: 0, res: 0, upd: 0;
       ccBm5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccBm0() //  []
         { info_tbl: [(ccBm0,
                       label: block_ccBm0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBm0: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.253809025 UTC

[section ""data" . Data.Unique.newUnique_closure" {
     Data.Unique.newUnique_closure:
         const Data.Unique.newUnique_info;
         const 0;
 },
 Data.Unique.newUnique_entry() //  []
         { info_tbl: [(ccBmg,
                       label: Data.Unique.newUnique_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBmg: // global
           call Data.Unique.newUnique1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.254499937 UTC

[section ""relreadonly" . ScBjf_srt" {
     ScBjf_srt:
         const lvl_rcBip_closure;
         const lvl1_rcBiq_closure;
         const sat_scBiG_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const Data.Unique.newUnique2_closure;
         const Data.Unique.newUnique3_closure;
         const Data.Unique.uniqSource_closure;
         const Data.Unique.newUnique1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.255342392 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:30.256476165 UTC

[section ""data" . Data.Unique.$fEqUnique_closure" {
     Data.Unique.$fEqUnique_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Integer.Type.eqInteger_closure+2;
         const GHC.Integer.Type.neqInteger_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.258336614 UTC

[section ""data" . Data.Unique.$fOrdUnique_closure" {
     Data.Unique.$fOrdUnique_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Unique.$fEqUnique_closure+1;
         const GHC.Integer.Type.compareInteger_closure+2;
         const GHC.Integer.Type.ltInteger_closure+2;
         const GHC.Integer.Type.leInteger_closure+2;
         const GHC.Integer.Type.gtInteger_closure+2;
         const GHC.Integer.Type.geInteger_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmax_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.260420281 UTC

[section ""data" . lvl_rcBip_closure" {
     lvl_rcBip_closure:
         const lvl_rcBip_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_rcBip_entry() //  [R1]
         { info_tbl: [(ccBmr,
                       label: lvl_rcBip_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBmr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccBms; else goto ccBmt;
       ccBms: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccBmt: // global
           (_ccBmo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccBmo::I64 == 0) goto ccBmq; else goto ccBmp;
       ccBmq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccBmp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccBmo::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.264689717 UTC

[section ""data" . lvl1_rcBiq_closure" {
     lvl1_rcBiq_closure:
         const lvl1_rcBiq_info;
         const 0;
 },
 lvl1_rcBiq_entry() //  []
         { info_tbl: [(ccBmK,
                       label: lvl1_rcBiq_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBmK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccBmL; else goto ccBmM;
       ccBmL: // global
           R1 = lvl1_rcBiq_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccBmM: // global
           I64[Sp - 8] = block_ccBmF_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _ccBmF() //  []
         { info_tbl: [(ccBmF,
                       label: block_ccBmF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBmF: // global
           I64[Sp] = block_ccBmH_info;
           R1 = lvl_rcBip_closure;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccBmH() //  [R1]
         { info_tbl: [(ccBmH,
                       label: block_ccBmH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBmH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccBmQ; else goto ccBmP;
       ccBmQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccBmP: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.271861151 UTC

[section ""data" . Data.Unique.uniqSource_closure" {
     Data.Unique.uniqSource_closure:
         const Data.Unique.uniqSource_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Unique.uniqSource_entry() //  [R1]
         { info_tbl: [(ccBnb,
                       label: Data.Unique.uniqSource_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBnb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccBnc; else goto ccBnd;
       ccBnc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccBnd: // global
           (_ccBn6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccBn6::I64 == 0) goto ccBn8; else goto ccBn7;
       ccBn8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccBn7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccBn6::I64;
           I64[Sp - 24] = block_ccBn9_info;
           Sp = Sp - 24;
           call lvl1_rcBiq_entry() args: 8, res: 8, upd: 24;
     }
 },
 _ccBn9() //  [R1]
         { info_tbl: [(ccBn9,
                       label: block_ccBn9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBn9: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.278300195 UTC

[section ""data" . Data.Unique.hashUnique_closure" {
     Data.Unique.hashUnique_closure:
         const Data.Unique.hashUnique_info;
 },
 Data.Unique.hashUnique_entry() //  [R2]
         { info_tbl: [(ccBnx,
                       label: Data.Unique.hashUnique_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBnx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccBnB; else goto ccBnC;
       ccBnB: // global
           R2 = R2;
           R1 = Data.Unique.hashUnique_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccBnC: // global
           I64[Sp - 8] = block_ccBnv_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.hashInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccBnv() //  [R1]
         { info_tbl: [(ccBnv,
                       label: block_ccBnv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBnv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccBnF; else goto ccBnE;
       ccBnF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccBnE: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.284081469 UTC

[section ""cstring" . Data.Unique.$trModule4_bytes" {
     Data.Unique.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.285720997 UTC

[section ""data" . Data.Unique.$trModule3_closure" {
     Data.Unique.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Unique.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.28734582 UTC

[section ""cstring" . Data.Unique.$trModule2_bytes" {
     Data.Unique.$trModule2_bytes:
         I8[] [68,97,116,97,46,85,110,105,113,117,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.288932493 UTC

[section ""data" . Data.Unique.$trModule1_closure" {
     Data.Unique.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Unique.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.290651971 UTC

[section ""data" . Data.Unique.$trModule_closure" {
     Data.Unique.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Unique.$trModule3_closure+1;
         const Data.Unique.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.292387788 UTC

[section ""data" . $krep_rcBir_closure" {
     $krep_rcBir_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.294549436 UTC

[section ""cstring" . Data.Unique.$tcUnique2_bytes" {
     Data.Unique.$tcUnique2_bytes:
         I8[] [85,110,105,113,117,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.296195118 UTC

[section ""data" . Data.Unique.$tcUnique1_closure" {
     Data.Unique.$tcUnique1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Unique.$tcUnique2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.297902575 UTC

[section ""data" . Data.Unique.$tcUnique_closure" {
     Data.Unique.$tcUnique_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Unique.$trModule_closure+1;
         const Data.Unique.$tcUnique1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9376197555697821408;
         const 12289580968443169787;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.299729708 UTC

[section ""data" . $krep1_rcBis_closure" {
     $krep1_rcBis_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Unique.$tcUnique_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.301428461 UTC

[section ""data" . Data.Unique.$tc'Unique1_closure" {
     Data.Unique.$tc'Unique1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcBir_closure+1;
         const $krep1_rcBis_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.30374485 UTC

[section ""cstring" . Data.Unique.$tc'Unique3_bytes" {
     Data.Unique.$tc'Unique3_bytes:
         I8[] [39,85,110,105,113,117,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.305462556 UTC

[section ""data" . Data.Unique.$tc'Unique2_closure" {
     Data.Unique.$tc'Unique2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Unique.$tc'Unique3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.307143911 UTC

[section ""data" . Data.Unique.$tc'Unique_closure" {
     Data.Unique.$tc'Unique_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Unique.$trModule_closure+1;
         const Data.Unique.$tc'Unique2_closure+1;
         const Data.Unique.$tc'Unique1_closure+4;
         const 6673795421757133892;
         const 3923002115329816747;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.308918972 UTC

[section ""data" . sat_scBiF_closure" {
     sat_scBiF_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.310560889 UTC

[section ""data" . sat_scBiG_closure" {
     sat_scBiG_closure:
         const :_con_info;
         const sat_scBiF_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.31257918 UTC

[section ""data" . Data.Unique.newUnique3_closure" {
     Data.Unique.newUnique3_closure:
         const Data.Unique.newUnique3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Unique.newUnique3_entry() //  [R1]
         { info_tbl: [(ccBob,
                       label: Data.Unique.newUnique3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBob: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccBoc; else goto ccBod;
       ccBoc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccBod: // global
           (_ccBo8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccBo8::I64 == 0) goto ccBoa; else goto ccBo9;
       ccBoa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccBo9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccBo8::I64;
           R3 = sat_scBiG_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.317287677 UTC

[section ""data" . Data.Unique.newUnique2_closure" {
     Data.Unique.newUnique2_closure:
         const Data.Unique.newUnique2_info;
         const 0;
 },
 Data.Unique.newUnique2_entry() //  [R2]
         { info_tbl: [(ccBor,
                       label: Data.Unique.newUnique2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBor: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccBov; else goto ccBow;
       ccBov: // global
           R2 = R2;
           R1 = Data.Unique.newUnique2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccBow: // global
           I64[Sp - 8] = block_ccBop_info;
           R3 = Data.Unique.newUnique3_closure;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccBop() //  [R1]
         { info_tbl: [(ccBop,
                       label: block_ccBop_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBop: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccBoz; else goto ccBoy;
       ccBoz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccBoy: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.322823405 UTC

[section ""data" . Data.Unique.newUnique1_closure" {
     Data.Unique.newUnique1_closure:
         const Data.Unique.newUnique1_info;
         const 0;
 },
 Data.Unique.newUnique1_entry() //  []
         { info_tbl: [(ccBoQ,
                       label: Data.Unique.newUnique1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBoQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccBoW; else goto ccBoX;
       ccBoW: // global
           R1 = Data.Unique.newUnique1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccBoX: // global
           I64[Sp - 8] = block_ccBoN_info;
           R1 = Data.Unique.uniqSource_closure;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucBp5; else goto ccBoO;
       ucBp5: // global
           call _ccBoN(R1) args: 0, res: 0, upd: 0;
       ccBoO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccBoN() //  [R1]
         { info_tbl: [(ccBoN,
                       label: block_ccBoN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBoN: // global
           I64[Sp] = block_ccBoT_info;
           R2 = Data.Unique.newUnique2_closure+1;
           R1 = P64[R1 + 7];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccBoT() //  [R1]
         { info_tbl: [(ccBoT,
                       label: block_ccBoT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBoT: // global
           I64[Sp - 8] = block_ccBoV_info;
           _scBiO::P64 = R1;
           R1 = R1;
           P64[Sp] = _scBiO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucBp6; else goto ccBp0;
       ucBp6: // global
           call _ccBoV() args: 0, res: 0, upd: 0;
       ccBp0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccBoV() //  []
         { info_tbl: [(ccBoV,
                       label: block_ccBoV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBoV: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.331183897 UTC

[section ""data" . Data.Unique.newUnique_closure" {
     Data.Unique.newUnique_closure:
         const Data.Unique.newUnique_info;
         const 0;
 },
 Data.Unique.newUnique_entry() //  []
         { info_tbl: [(ccBps,
                       label: Data.Unique.newUnique_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBps: // global
           call Data.Unique.newUnique1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.334806332 UTC

[section ""relreadonly" . ScBjf_srt" {
     ScBjf_srt:
         const lvl_rcBip_closure;
         const lvl1_rcBiq_closure;
         const sat_scBiG_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const Data.Unique.newUnique2_closure;
         const Data.Unique.newUnique3_closure;
         const Data.Unique.uniqSource_closure;
         const Data.Unique.newUnique1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.429262785 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:30.430326429 UTC

[section ""data" . Data.Unique.$fEqUnique_closure" {
     Data.Unique.$fEqUnique_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Integer.Type.eqInteger_closure+2;
         const GHC.Integer.Type.neqInteger_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.432117498 UTC

[section ""data" . Data.Unique.$fOrdUnique_closure" {
     Data.Unique.$fOrdUnique_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Unique.$fEqUnique_closure+1;
         const GHC.Integer.Type.compareInteger_closure+2;
         const GHC.Integer.Type.ltInteger_closure+2;
         const GHC.Integer.Type.leInteger_closure+2;
         const GHC.Integer.Type.gtInteger_closure+2;
         const GHC.Integer.Type.geInteger_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmax_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.434312885 UTC

[section ""data" . lvl_rcBip_closure" {
     lvl_rcBip_closure:
         const lvl_rcBip_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_rcBip_entry() //  [R1]
         { info_tbl: [(ccBq4,
                       label: lvl_rcBip_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBq4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccBq5; else goto ccBq6;
       ccBq5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccBq6: // global
           (_ccBq1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccBq1::I64 == 0) goto ccBq3; else goto ccBq2;
       ccBq3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccBq2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccBq1::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.438681225 UTC

[section ""data" . lvl1_rcBiq_closure" {
     lvl1_rcBiq_closure:
         const lvl1_rcBiq_info;
         const 0;
 },
 lvl1_rcBiq_entry() //  []
         { info_tbl: [(ccBqq,
                       label: lvl1_rcBiq_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBqq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccBqr; else goto ccBqs;
       ccBqr: // global
           R1 = lvl1_rcBiq_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccBqs: // global
           I64[Sp - 8] = block_ccBql_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _ccBql() //  []
         { info_tbl: [(ccBql,
                       label: block_ccBql_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBql: // global
           I64[Sp] = block_ccBqn_info;
           R1 = lvl_rcBip_closure;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccBqn() //  [R1]
         { info_tbl: [(ccBqn,
                       label: block_ccBqn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBqn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccBqw; else goto ccBqv;
       ccBqw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccBqv: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.445805625 UTC

[section ""data" . Data.Unique.uniqSource_closure" {
     Data.Unique.uniqSource_closure:
         const Data.Unique.uniqSource_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Unique.uniqSource_entry() //  [R1]
         { info_tbl: [(ccBqV,
                       label: Data.Unique.uniqSource_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBqV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccBqW; else goto ccBqX;
       ccBqW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccBqX: // global
           (_ccBqQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccBqQ::I64 == 0) goto ccBqS; else goto ccBqR;
       ccBqS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccBqR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccBqQ::I64;
           I64[Sp - 24] = block_ccBqT_info;
           Sp = Sp - 24;
           call lvl1_rcBiq_entry() args: 8, res: 8, upd: 24;
     }
 },
 _ccBqT() //  [R1]
         { info_tbl: [(ccBqT,
                       label: block_ccBqT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBqT: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.45188197 UTC

[section ""data" . Data.Unique.hashUnique_closure" {
     Data.Unique.hashUnique_closure:
         const Data.Unique.hashUnique_info;
 },
 Data.Unique.hashUnique_entry() //  [R2]
         { info_tbl: [(ccBrj,
                       label: Data.Unique.hashUnique_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBrj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccBrn; else goto ccBro;
       ccBrn: // global
           R2 = R2;
           R1 = Data.Unique.hashUnique_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccBro: // global
           I64[Sp - 8] = block_ccBrh_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.hashInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccBrh() //  [R1]
         { info_tbl: [(ccBrh,
                       label: block_ccBrh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBrh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccBrr; else goto ccBrq;
       ccBrr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccBrq: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.458002653 UTC

[section ""cstring" . Data.Unique.$trModule4_bytes" {
     Data.Unique.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.459782929 UTC

[section ""data" . Data.Unique.$trModule3_closure" {
     Data.Unique.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Unique.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.461488481 UTC

[section ""cstring" . Data.Unique.$trModule2_bytes" {
     Data.Unique.$trModule2_bytes:
         I8[] [68,97,116,97,46,85,110,105,113,117,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.463068201 UTC

[section ""data" . Data.Unique.$trModule1_closure" {
     Data.Unique.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Unique.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.464759276 UTC

[section ""data" . Data.Unique.$trModule_closure" {
     Data.Unique.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Unique.$trModule3_closure+1;
         const Data.Unique.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.466787698 UTC

[section ""data" . $krep_rcBir_closure" {
     $krep_rcBir_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.468598434 UTC

[section ""cstring" . Data.Unique.$tcUnique2_bytes" {
     Data.Unique.$tcUnique2_bytes:
         I8[] [85,110,105,113,117,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.470321509 UTC

[section ""data" . Data.Unique.$tcUnique1_closure" {
     Data.Unique.$tcUnique1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Unique.$tcUnique2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.472108205 UTC

[section ""data" . Data.Unique.$tcUnique_closure" {
     Data.Unique.$tcUnique_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Unique.$trModule_closure+1;
         const Data.Unique.$tcUnique1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9376197555697821408;
         const 12289580968443169787;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.473967294 UTC

[section ""data" . $krep1_rcBis_closure" {
     $krep1_rcBis_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Unique.$tcUnique_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.475702739 UTC

[section ""data" . Data.Unique.$tc'Unique1_closure" {
     Data.Unique.$tc'Unique1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcBir_closure+1;
         const $krep1_rcBis_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.477378811 UTC

[section ""cstring" . Data.Unique.$tc'Unique3_bytes" {
     Data.Unique.$tc'Unique3_bytes:
         I8[] [39,85,110,105,113,117,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.479081796 UTC

[section ""data" . Data.Unique.$tc'Unique2_closure" {
     Data.Unique.$tc'Unique2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Unique.$tc'Unique3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.480727415 UTC

[section ""data" . Data.Unique.$tc'Unique_closure" {
     Data.Unique.$tc'Unique_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Unique.$trModule_closure+1;
         const Data.Unique.$tc'Unique2_closure+1;
         const Data.Unique.$tc'Unique1_closure+4;
         const 6673795421757133892;
         const 3923002115329816747;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.483093512 UTC

[section ""data" . sat_scBpL_closure" {
     sat_scBpL_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.484659562 UTC

[section ""data" . sat_scBpM_closure" {
     sat_scBpM_closure:
         const :_con_info;
         const sat_scBpL_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.487311937 UTC

[section ""data" . Data.Unique.newUnique3_closure" {
     Data.Unique.newUnique3_closure:
         const Data.Unique.newUnique3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Unique.newUnique3_entry() //  [R1]
         { info_tbl: [(ccBrZ,
                       label: Data.Unique.newUnique3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBrZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccBs0; else goto ccBs1;
       ccBs0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccBs1: // global
           (_ccBrW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccBrW::I64 == 0) goto ccBrY; else goto ccBrX;
       ccBrY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccBrX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccBrW::I64;
           R3 = sat_scBpM_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.491724441 UTC

[section ""data" . Data.Unique.newUnique2_closure" {
     Data.Unique.newUnique2_closure:
         const Data.Unique.newUnique2_info;
         const 0;
 },
 Data.Unique.newUnique2_entry() //  [R2]
         { info_tbl: [(ccBsh,
                       label: Data.Unique.newUnique2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBsh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccBsl; else goto ccBsm;
       ccBsl: // global
           R2 = R2;
           R1 = Data.Unique.newUnique2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccBsm: // global
           I64[Sp - 8] = block_ccBsf_info;
           R3 = Data.Unique.newUnique3_closure;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccBsf() //  [R1]
         { info_tbl: [(ccBsf,
                       label: block_ccBsf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBsf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccBsp; else goto ccBso;
       ccBsp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccBso: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.497952605 UTC

[section ""data" . Data.Unique.newUnique1_closure" {
     Data.Unique.newUnique1_closure:
         const Data.Unique.newUnique1_info;
         const 0;
 },
 Data.Unique.newUnique1_entry() //  []
         { info_tbl: [(ccBsI,
                       label: Data.Unique.newUnique1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBsI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccBsO; else goto ccBsP;
       ccBsO: // global
           R1 = Data.Unique.newUnique1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccBsP: // global
           I64[Sp - 8] = block_ccBsF_info;
           R1 = Data.Unique.uniqSource_closure;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucBsX; else goto ccBsG;
       ucBsX: // global
           call _ccBsF(R1) args: 0, res: 0, upd: 0;
       ccBsG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccBsF() //  [R1]
         { info_tbl: [(ccBsF,
                       label: block_ccBsF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBsF: // global
           I64[Sp] = block_ccBsL_info;
           R2 = Data.Unique.newUnique2_closure+1;
           R1 = P64[R1 + 7];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccBsL() //  [R1]
         { info_tbl: [(ccBsL,
                       label: block_ccBsL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBsL: // global
           I64[Sp - 8] = block_ccBsN_info;
           _scBpU::P64 = R1;
           R1 = R1;
           P64[Sp] = _scBpU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucBsY; else goto ccBsS;
       ucBsY: // global
           call _ccBsN() args: 0, res: 0, upd: 0;
       ccBsS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccBsN() //  []
         { info_tbl: [(ccBsN,
                       label: block_ccBsN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBsN: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.5063466 UTC

[section ""data" . Data.Unique.newUnique_closure" {
     Data.Unique.newUnique_closure:
         const Data.Unique.newUnique_info;
         const 0;
 },
 Data.Unique.newUnique_entry() //  []
         { info_tbl: [(ccBtn,
                       label: Data.Unique.newUnique_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccBtn: // global
           call Data.Unique.newUnique1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.509402118 UTC

[section ""relreadonly" . ScBqx_srt" {
     ScBqx_srt:
         const lvl_rcBip_closure;
         const lvl1_rcBiq_closure;
         const sat_scBpM_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const Data.Unique.newUnique2_closure;
         const Data.Unique.newUnique3_closure;
         const Data.Unique.uniqSource_closure;
         const Data.Unique.newUnique1_closure;
 }]

