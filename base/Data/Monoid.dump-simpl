
==================== Tidy Core ====================
2018-03-16 16:01:56.704139562 UTC

Result size of Tidy Core
  = {terms: 837, types: 1,152, coercions: 1,496, joins: 0/4}

-- RHS size: {terms: 9, types: 9, coercions: 5, joins: 0/0}
Data.Monoid.$fMonoidFirst_$c<>
  :: forall a. First a -> First a -> First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6Hs2)
                 (ds_d6HBZ [Occ=Once] :: First a_a6Hs2)
                 (b_a6Gk2 [Occ=Once] :: First a_a6Hs2) ->
                 case ds_d6HBZ
                      `cast` (Data.Monoid.N:First[0] <a_a6Hs2>_N
                              :: (First a_a6Hs2 :: *) ~R# (Maybe a_a6Hs2 :: *))
                 of wild_X1R {
                   Nothing -> b_a6Gk2;
                   Just _ [Occ=Dead] ->
                     wild_X1R
                     `cast` (Sym (Data.Monoid.N:First[0]) <a_a6Hs2>_N
                             :: (Maybe a_a6Hs2 :: *) ~R# (First a_a6Hs2 :: *))
                 }}]
Data.Monoid.$fMonoidFirst_$c<>
  = \ (@ a_a6Hs2)
      (ds_d6HBZ :: First a_a6Hs2)
      (b_a6Gk2 :: First a_a6Hs2) ->
      case ds_d6HBZ
           `cast` (Data.Monoid.N:First[0] <a_a6Hs2>_N
                   :: (First a_a6Hs2 :: *) ~R# (Maybe a_a6Hs2 :: *))
      of wild_X1R {
        Nothing -> b_a6Gk2;
        Just ipv_s6HCS ->
          wild_X1R
          `cast` (Sym (Data.Monoid.N:First[0]) <a_a6Hs2>_N
                  :: (Maybe a_a6Hs2 :: *) ~R# (First a_a6Hs2 :: *))
      }

Rec {
-- RHS size: {terms: 16, types: 19, coercions: 5, joins: 0/0}
Data.Monoid.$fSemigroupFirst1 [Occ=LoopBreaker]
  :: forall a. First a -> [First a] -> First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []]
Data.Monoid.$fSemigroupFirst1
  = \ (@ a_a6Hs2)
      (b_i6HBr :: First a_a6Hs2)
      (ds1_i6HBs :: [First a_a6Hs2]) ->
      case ds1_i6HBs of {
        [] -> b_i6HBr;
        : c_i6HBA cs_i6HBB ->
          case b_i6HBr
               `cast` (Data.Monoid.N:First[0] <a_a6Hs2>_N
                       :: (First a_a6Hs2 :: *) ~R# (Maybe a_a6Hs2 :: *))
          of wild_X1R {
            Nothing ->
              Data.Monoid.$fSemigroupFirst1 @ a_a6Hs2 c_i6HBA cs_i6HBB;
            Just ipv_s6HCS ->
              wild_X1R
              `cast` (Sym (Data.Monoid.N:First[0]) <a_a6Hs2>_N
                      :: (Maybe a_a6Hs2 :: *) ~R# (First a_a6Hs2 :: *))
          }
      }
end Rec }

-- RHS size: {terms: 8, types: 14, coercions: 0, joins: 0/0}
Data.Monoid.$fSemigroupFirst_$csconcat
  :: forall a. NonEmpty (First a) -> First a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6Hs2)
                 (ds_i6HBm [Occ=Once!] :: NonEmpty (First a_a6Hs2)) ->
                 case ds_i6HBm of { :| a1_i6HBt [Occ=Once] as_i6HBu [Occ=Once] ->
                 Data.Monoid.$fSemigroupFirst1 @ a_a6Hs2 a1_i6HBt as_i6HBu
                 }}]
Data.Monoid.$fSemigroupFirst_$csconcat
  = \ (@ a_a6Hs2) (ds_i6HBm :: NonEmpty (First a_a6Hs2)) ->
      case ds_i6HBm of { :| a1_i6HBt as_i6HBu ->
      Data.Monoid.$fSemigroupFirst1 @ a_a6Hs2 a1_i6HBt as_i6HBu
      }

Rec {
-- RHS size: {terms: 14, types: 18, coercions: 8, joins: 0/0}
Data.Monoid.$fMonoidFirst_go [Occ=LoopBreaker]
  :: forall a. [First a] -> First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []]
Data.Monoid.$fMonoidFirst_go
  = \ (@ a_a6HrF) (ds_i6HCZ :: [First a_a6HrF]) ->
      case ds_i6HCZ of {
        [] ->
          (GHC.Base.Nothing @ a_a6HrF)
          `cast` (Sym (Data.Monoid.N:First[0]) <a_a6HrF>_N
                  :: (Maybe a_a6HrF :: *) ~R# (First a_a6HrF :: *));
        : y_i6HD4 ys_i6HD5 ->
          case y_i6HD4
               `cast` (Data.Monoid.N:First[0] <a_a6HrF>_N
                       :: (First a_a6HrF :: *) ~R# (Maybe a_a6HrF :: *))
          of wild1_X1R {
            Nothing -> Data.Monoid.$fMonoidFirst_go @ a_a6HrF ys_i6HD5;
            Just ipv_s6HCS ->
              wild1_X1R
              `cast` (Sym (Data.Monoid.N:First[0]) <a_a6HrF>_N
                      :: (Maybe a_a6HrF :: *) ~R# (First a_a6HrF :: *))
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 5, types: 7, coercions: 0, joins: 0/0}
Data.Monoid.$fSemigroupFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Semigroup (First a)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ a_a6Gk1) ->
       GHC.Base.C:Semigroup TYPE: First a_a6Gk1
                            Data.Monoid.$fMonoidFirst_$c<> @ a_a6Gk1
                            Data.Monoid.$fSemigroupFirst_$csconcat @ a_a6Gk1
                            Data.Monoid.$fSemigroupFirst_$cstimes @ a_a6Gk1]
Data.Monoid.$fSemigroupFirst
  = \ (@ a_a6Hs2) ->
      GHC.Base.C:Semigroup
        @ (First a_a6Hs2)
        (Data.Monoid.$fMonoidFirst_$c<> @ a_a6Hs2)
        (Data.Monoid.$fSemigroupFirst_$csconcat @ a_a6Hs2)
        (Data.Monoid.$fSemigroupFirst_$cstimes @ a_a6Hs2)

-- RHS size: {terms: 6, types: 8, coercions: 3, joins: 0/0}
Data.Monoid.$fMonoidFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Monoid (First a)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ a_a6Gk0) ->
       GHC.Base.C:Monoid TYPE: First a_a6Gk0
                         Data.Monoid.$fSemigroupFirst @ a_a6Gk0
                         (GHC.Base.Nothing @ a_a6Gk0)
                         `cast` (Sym (Data.Monoid.N:First[0]) <a_a6Gk0>_N
                                 :: (Maybe a_a6Gk0 :: *) ~R# (First a_a6Gk0 :: *))
                         Data.Monoid.$fMonoidFirst_$c<> @ a_a6Gk0
                         Data.Monoid.$fMonoidFirst_go @ a_a6Gk0]
Data.Monoid.$fMonoidFirst
  = \ (@ a_a6HrF) ->
      GHC.Base.C:Monoid
        @ (First a_a6HrF)
        (Data.Monoid.$fSemigroupFirst @ a_a6HrF)
        ((GHC.Base.Nothing @ a_a6HrF)
         `cast` (Sym (Data.Monoid.N:First[0]) <a_a6HrF>_N
                 :: (Maybe a_a6HrF :: *) ~R# (First a_a6HrF :: *)))
        (Data.Monoid.$fMonoidFirst_$c<> @ a_a6HrF)
        (Data.Monoid.$fMonoidFirst_go @ a_a6HrF)

-- RHS size: {terms: 6, types: 10, coercions: 0, joins: 0/0}
Data.Monoid.$fSemigroupFirst_$cstimes [Occ=LoopBreaker]
  :: forall a b. GHC.Real.Integral b => b -> First a -> First a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,C(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []]
Data.Monoid.$fSemigroupFirst_$cstimes
  = \ (@ a_a6Hs2)
      (@ b_a6Hsf)
      ($dIntegral_a6Hsh :: GHC.Real.Integral b_a6Hsf) ->
      stimesIdempotentMonoid
        @ b_a6Hsf
        @ (First a_a6Hs2)
        $dIntegral_a6Hsh
        (Data.Monoid.$fMonoidFirst @ a_a6Hs2)
end Rec }

-- RHS size: {terms: 9, types: 9, coercions: 5, joins: 0/0}
Data.Monoid.$fMonoidLast_$c<>
  :: forall a. Last a -> Last a -> Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6Hr1)
                 (a1_a6GjY [Occ=Once] :: Last a_a6Hr1)
                 (ds_d6HB9 [Occ=Once] :: Last a_a6Hr1) ->
                 case ds_d6HB9
                      `cast` (Data.Monoid.N:Last[0] <a_a6Hr1>_N
                              :: (Last a_a6Hr1 :: *) ~R# (Maybe a_a6Hr1 :: *))
                 of wild_X1Z {
                   Nothing -> a1_a6GjY;
                   Just _ [Occ=Dead] ->
                     wild_X1Z
                     `cast` (Sym (Data.Monoid.N:Last[0]) <a_a6Hr1>_N
                             :: (Maybe a_a6Hr1 :: *) ~R# (Last a_a6Hr1 :: *))
                 }}]
Data.Monoid.$fMonoidLast_$c<>
  = \ (@ a_a6Hr1)
      (a1_a6GjY :: Last a_a6Hr1)
      (ds_d6HB9 :: Last a_a6Hr1) ->
      case ds_d6HB9
           `cast` (Data.Monoid.N:Last[0] <a_a6Hr1>_N
                   :: (Last a_a6Hr1 :: *) ~R# (Maybe a_a6Hr1 :: *))
      of wild_X1Z {
        Nothing -> a1_a6GjY;
        Just ipv_s6HF5 ->
          wild_X1Z
          `cast` (Sym (Data.Monoid.N:Last[0]) <a_a6Hr1>_N
                  :: (Maybe a_a6Hr1 :: *) ~R# (Last a_a6Hr1 :: *))
      }

Rec {
-- RHS size: {terms: 16, types: 19, coercions: 5, joins: 0/0}
Data.Monoid.$fSemigroupLast1 [Occ=LoopBreaker]
  :: forall a. Last a -> [Last a] -> Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []]
Data.Monoid.$fSemigroupLast1
  = \ (@ a_a6Hr1)
      (b_i6HBr :: Last a_a6Hr1)
      (ds1_i6HBs :: [Last a_a6Hr1]) ->
      case ds1_i6HBs of {
        [] -> b_i6HBr;
        : c_i6HBA cs_i6HBB ->
          case (Data.Monoid.$fSemigroupLast1 @ a_a6Hr1 c_i6HBA cs_i6HBB)
               `cast` (Data.Monoid.N:Last[0] <a_a6Hr1>_N
                       :: (Last a_a6Hr1 :: *) ~R# (Maybe a_a6Hr1 :: *))
          of wild_X1Z {
            Nothing -> b_i6HBr;
            Just ipv_s6HF5 ->
              wild_X1Z
              `cast` (Sym (Data.Monoid.N:Last[0]) <a_a6Hr1>_N
                      :: (Maybe a_a6Hr1 :: *) ~R# (Last a_a6Hr1 :: *))
          }
      }
end Rec }

-- RHS size: {terms: 8, types: 14, coercions: 0, joins: 0/0}
Data.Monoid.$fSemigroupLast_$csconcat
  :: forall a. NonEmpty (Last a) -> Last a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6Hr1)
                 (ds_i6HBm [Occ=Once!] :: NonEmpty (Last a_a6Hr1)) ->
                 case ds_i6HBm of { :| a1_i6HBt [Occ=Once] as_i6HBu [Occ=Once] ->
                 Data.Monoid.$fSemigroupLast1 @ a_a6Hr1 a1_i6HBt as_i6HBu
                 }}]
Data.Monoid.$fSemigroupLast_$csconcat
  = \ (@ a_a6Hr1) (ds_i6HBm :: NonEmpty (Last a_a6Hr1)) ->
      case ds_i6HBm of { :| a1_i6HBt as_i6HBu ->
      Data.Monoid.$fSemigroupLast1 @ a_a6Hr1 a1_i6HBt as_i6HBu
      }

Rec {
-- RHS size: {terms: 14, types: 18, coercions: 8, joins: 0/0}
Data.Monoid.$fMonoidLast_go [Occ=LoopBreaker]
  :: forall a. [Last a] -> Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []]
Data.Monoid.$fMonoidLast_go
  = \ (@ a_a6HqA) (ds_i6HCZ :: [Last a_a6HqA]) ->
      case ds_i6HCZ of {
        [] ->
          (GHC.Base.Nothing @ a_a6HqA)
          `cast` (Sym (Data.Monoid.N:Last[0]) <a_a6HqA>_N
                  :: (Maybe a_a6HqA :: *) ~R# (Last a_a6HqA :: *));
        : y_i6HD4 ys_i6HD5 ->
          case (Data.Monoid.$fMonoidLast_go @ a_a6HqA ys_i6HD5)
               `cast` (Data.Monoid.N:Last[0] <a_a6HqA>_N
                       :: (Last a_a6HqA :: *) ~R# (Maybe a_a6HqA :: *))
          of wild1_X1Z {
            Nothing -> y_i6HD4;
            Just ipv_s6HF5 ->
              wild1_X1Z
              `cast` (Sym (Data.Monoid.N:Last[0]) <a_a6HqA>_N
                      :: (Maybe a_a6HqA :: *) ~R# (Last a_a6HqA :: *))
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 5, types: 7, coercions: 0, joins: 0/0}
Data.Monoid.$fSemigroupLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Semigroup (Last a)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ a_a6GjX) ->
       GHC.Base.C:Semigroup TYPE: Last a_a6GjX
                            Data.Monoid.$fMonoidLast_$c<> @ a_a6GjX
                            Data.Monoid.$fSemigroupLast_$csconcat @ a_a6GjX
                            Data.Monoid.$fSemigroupLast_$cstimes @ a_a6GjX]
Data.Monoid.$fSemigroupLast
  = \ (@ a_a6Hr1) ->
      GHC.Base.C:Semigroup
        @ (Last a_a6Hr1)
        (Data.Monoid.$fMonoidLast_$c<> @ a_a6Hr1)
        (Data.Monoid.$fSemigroupLast_$csconcat @ a_a6Hr1)
        (Data.Monoid.$fSemigroupLast_$cstimes @ a_a6Hr1)

-- RHS size: {terms: 6, types: 8, coercions: 3, joins: 0/0}
Data.Monoid.$fMonoidLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Monoid (Last a)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ a_a6GjW) ->
       GHC.Base.C:Monoid TYPE: Last a_a6GjW
                         Data.Monoid.$fSemigroupLast @ a_a6GjW
                         (GHC.Base.Nothing @ a_a6GjW)
                         `cast` (Sym (Data.Monoid.N:Last[0]) <a_a6GjW>_N
                                 :: (Maybe a_a6GjW :: *) ~R# (Last a_a6GjW :: *))
                         Data.Monoid.$fMonoidLast_$c<> @ a_a6GjW
                         Data.Monoid.$fMonoidLast_go @ a_a6GjW]
Data.Monoid.$fMonoidLast
  = \ (@ a_a6HqA) ->
      GHC.Base.C:Monoid
        @ (Last a_a6HqA)
        (Data.Monoid.$fSemigroupLast @ a_a6HqA)
        ((GHC.Base.Nothing @ a_a6HqA)
         `cast` (Sym (Data.Monoid.N:Last[0]) <a_a6HqA>_N
                 :: (Maybe a_a6HqA :: *) ~R# (Last a_a6HqA :: *)))
        (Data.Monoid.$fMonoidLast_$c<> @ a_a6HqA)
        (Data.Monoid.$fMonoidLast_go @ a_a6HqA)

-- RHS size: {terms: 6, types: 10, coercions: 0, joins: 0/0}
Data.Monoid.$fSemigroupLast_$cstimes [Occ=LoopBreaker]
  :: forall a b. GHC.Real.Integral b => b -> Last a -> Last a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,C(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []]
Data.Monoid.$fSemigroupLast_$cstimes
  = \ (@ a_a6Hr1)
      (@ b_a6Hrs)
      ($dIntegral_a6Hru :: GHC.Real.Integral b_a6Hrs) ->
      stimesIdempotentMonoid
        @ b_a6Hrs
        @ (Last a_a6Hr1)
        $dIntegral_a6Hru
        (Data.Monoid.$fMonoidLast @ a_a6Hr1)
end Rec }

-- RHS size: {terms: 3, types: 1, coercions: 31, joins: 0/0}
Data.Monoid.$fFunctorLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Functor Last
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Functor TYPE: Last
                          GHC.Base.$fApplicativeMaybe_$cfmap
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a -> b>_R
                                  ->_R Sym (Data.Monoid.N:Last[0]) <a>_N
                                  ->_R Sym (Data.Monoid.N:Last[0]) <b>_N
                                  :: (forall a b. (a -> b) -> Maybe a -> Maybe b :: *)
                                     ~R# (forall a b. (a -> b) -> Last a -> Last b :: *))
                          GHC.Base.$fFunctorMaybe_$c<$
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a>_R
                                  ->_R Sym (Data.Monoid.N:Last[0]) <b>_N
                                  ->_R Sym (Data.Monoid.N:Last[0]) <a>_N
                                  :: (forall a b. a -> Maybe b -> Maybe a :: *)
                                     ~R# (forall a b. a -> Last b -> Last a :: *))]
Data.Monoid.$fFunctorLast
  = GHC.Base.C:Functor
      @ Last
      (GHC.Base.$fApplicativeMaybe_$cfmap
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a -> b>_R
               ->_R Sym (Data.Monoid.N:Last[0]) <a>_N
               ->_R Sym (Data.Monoid.N:Last[0]) <b>_N
               :: (forall a b. (a -> b) -> Maybe a -> Maybe b :: *)
                  ~R# (forall a b. (a -> b) -> Last a -> Last b :: *)))
      (GHC.Base.$fFunctorMaybe_$c<$
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a>_R
               ->_R Sym (Data.Monoid.N:Last[0]) <b>_N
               ->_R Sym (Data.Monoid.N:Last[0]) <a>_N
               :: (forall a b. a -> Maybe b -> Maybe a :: *)
                  ~R# (forall a b. a -> Last b -> Last a :: *)))

-- RHS size: {terms: 7, types: 1, coercions: 84, joins: 0/0}
Data.Monoid.$fApplicativeLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Applicative Last
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Applicative TYPE: Last
                              Data.Monoid.$fFunctorLast
                              GHC.Base.Just
                              `cast` (forall (a :: <*>_N).
                                      <a>_R ->_R Sym (Data.Monoid.N:Last[0]) <a>_N
                                      :: (forall a. a -> Maybe a :: *)
                                         ~R# (forall a. a -> Last a :: *))
                              GHC.Base.$fApplicativeMaybe_$c<*>
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      Sym (Data.Monoid.N:Last[0]) <a -> b>_N
                                      ->_R Sym (Data.Monoid.N:Last[0]) <a>_N
                                      ->_R Sym (Data.Monoid.N:Last[0]) <b>_N
                                      :: (forall a b. Maybe (a -> b) -> Maybe a -> Maybe b :: *)
                                         ~R# (forall a b. Last (a -> b) -> Last a -> Last b :: *))
                              GHC.Base.$fApplicativeMaybe_$cliftA2
                              `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                                      <a -> b -> c>_R
                                      ->_R Sym (Data.Monoid.N:Last[0]) <a>_N
                                      ->_R Sym (Data.Monoid.N:Last[0]) <b>_N
                                      ->_R Sym (Data.Monoid.N:Last[0]) <c>_N
                                      :: (forall a b c.
                                          (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c :: *)
                                         ~R# (forall a b c.
                                              (a -> b -> c) -> Last a -> Last b -> Last c :: *))
                              GHC.Base.$fApplicativeMaybe_$c*>
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      Sym (Data.Monoid.N:Last[0]) <a>_N
                                      ->_R Sym (Data.Monoid.N:Last[0]) <b>_N
                                      ->_R Sym (Data.Monoid.N:Last[0]) <b>_N
                                      :: (forall a b. Maybe a -> Maybe b -> Maybe b :: *)
                                         ~R# (forall a b. Last a -> Last b -> Last b :: *))
                              GHC.Base.$fApplicativeMaybe_$c<*
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      Sym (Data.Monoid.N:Last[0]) <a>_N
                                      ->_R Sym (Data.Monoid.N:Last[0]) <b>_N
                                      ->_R Sym (Data.Monoid.N:Last[0]) <a>_N
                                      :: (forall a b. Maybe a -> Maybe b -> Maybe a :: *)
                                         ~R# (forall a b. Last a -> Last b -> Last a :: *))]
Data.Monoid.$fApplicativeLast
  = GHC.Base.C:Applicative
      @ Last
      Data.Monoid.$fFunctorLast
      (GHC.Base.Just
       `cast` (forall (a :: <*>_N).
               <a>_R ->_R Sym (Data.Monoid.N:Last[0]) <a>_N
               :: (forall a. a -> Maybe a :: *) ~R# (forall a. a -> Last a :: *)))
      (GHC.Base.$fApplicativeMaybe_$c<*>
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               Sym (Data.Monoid.N:Last[0]) <a -> b>_N
               ->_R Sym (Data.Monoid.N:Last[0]) <a>_N
               ->_R Sym (Data.Monoid.N:Last[0]) <b>_N
               :: (forall a b. Maybe (a -> b) -> Maybe a -> Maybe b :: *)
                  ~R# (forall a b. Last (a -> b) -> Last a -> Last b :: *)))
      (GHC.Base.$fApplicativeMaybe_$cliftA2
       `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
               <a -> b -> c>_R
               ->_R Sym (Data.Monoid.N:Last[0]) <a>_N
               ->_R Sym (Data.Monoid.N:Last[0]) <b>_N
               ->_R Sym (Data.Monoid.N:Last[0]) <c>_N
               :: (forall a b c.
                   (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c :: *)
                  ~R# (forall a b c.
                       (a -> b -> c) -> Last a -> Last b -> Last c :: *)))
      (GHC.Base.$fApplicativeMaybe_$c*>
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               Sym (Data.Monoid.N:Last[0]) <a>_N
               ->_R Sym (Data.Monoid.N:Last[0]) <b>_N
               ->_R Sym (Data.Monoid.N:Last[0]) <b>_N
               :: (forall a b. Maybe a -> Maybe b -> Maybe b :: *)
                  ~R# (forall a b. Last a -> Last b -> Last b :: *)))
      (GHC.Base.$fApplicativeMaybe_$c<*
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               Sym (Data.Monoid.N:Last[0]) <a>_N
               ->_R Sym (Data.Monoid.N:Last[0]) <b>_N
               ->_R Sym (Data.Monoid.N:Last[0]) <a>_N
               :: (forall a b. Maybe a -> Maybe b -> Maybe a :: *)
                  ~R# (forall a b. Last a -> Last b -> Last a :: *)))

-- RHS size: {terms: 6, types: 1, coercions: 53, joins: 0/0}
Data.Monoid.$fMonadLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Monad Last
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Monad TYPE: Last
                        Data.Monoid.$fApplicativeLast
                        GHC.Base.$fMonadMaybe_$c>>=
                        `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                Sym (Data.Monoid.N:Last[0]) <a>_N
                                ->_R (<a>_R ->_R Sym (Data.Monoid.N:Last[0]) <b>_N)
                                ->_R Sym (Data.Monoid.N:Last[0]) <b>_N
                                :: (forall a b. Maybe a -> (a -> Maybe b) -> Maybe b :: *)
                                   ~R# (forall a b. Last a -> (a -> Last b) -> Last b :: *))
                        GHC.Base.$fApplicativeMaybe_$c*>
                        `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                Sym (Data.Monoid.N:Last[0]) <a>_N
                                ->_R Sym (Data.Monoid.N:Last[0]) <b>_N
                                ->_R Sym (Data.Monoid.N:Last[0]) <b>_N
                                :: (forall a b. Maybe a -> Maybe b -> Maybe b :: *)
                                   ~R# (forall a b. Last a -> Last b -> Last b :: *))
                        GHC.Base.Just
                        `cast` (forall (a :: <*>_N).
                                <a>_R ->_R Sym (Data.Monoid.N:Last[0]) <a>_N
                                :: (forall a. a -> Maybe a :: *) ~R# (forall a. a -> Last a :: *))
                        GHC.Base.$fMonadMaybe_$cfail
                        `cast` (forall (a :: <*>_N).
                                <[Char]>_R ->_R Sym (Data.Monoid.N:Last[0]) <a>_N
                                :: (forall a. [Char] -> Maybe a :: *)
                                   ~R# (forall a. [Char] -> Last a :: *))]
Data.Monoid.$fMonadLast
  = GHC.Base.C:Monad
      @ Last
      Data.Monoid.$fApplicativeLast
      (GHC.Base.$fMonadMaybe_$c>>=
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               Sym (Data.Monoid.N:Last[0]) <a>_N
               ->_R (<a>_R ->_R Sym (Data.Monoid.N:Last[0]) <b>_N)
               ->_R Sym (Data.Monoid.N:Last[0]) <b>_N
               :: (forall a b. Maybe a -> (a -> Maybe b) -> Maybe b :: *)
                  ~R# (forall a b. Last a -> (a -> Last b) -> Last b :: *)))
      (GHC.Base.$fApplicativeMaybe_$c*>
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               Sym (Data.Monoid.N:Last[0]) <a>_N
               ->_R Sym (Data.Monoid.N:Last[0]) <b>_N
               ->_R Sym (Data.Monoid.N:Last[0]) <b>_N
               :: (forall a b. Maybe a -> Maybe b -> Maybe b :: *)
                  ~R# (forall a b. Last a -> Last b -> Last b :: *)))
      (GHC.Base.Just
       `cast` (forall (a :: <*>_N).
               <a>_R ->_R Sym (Data.Monoid.N:Last[0]) <a>_N
               :: (forall a. a -> Maybe a :: *) ~R# (forall a. a -> Last a :: *)))
      (GHC.Base.$fMonadMaybe_$cfail
       `cast` (forall (a :: <*>_N).
               <[Char]>_R ->_R Sym (Data.Monoid.N:Last[0]) <a>_N
               :: (forall a. [Char] -> Maybe a :: *)
                  ~R# (forall a. [Char] -> Last a :: *)))

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Monoid.$fGeneric1Last1 :: forall a. Rep1 Last a -> Rep1 Last a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Hlf) (ds_d6HAX [Occ=Once] :: Rep1 Last a_a6Hlf) ->
                 ds_d6HAX}]
Data.Monoid.$fGeneric1Last1
  = \ (@ a_a6Hlf) (ds_d6HAX :: Rep1 Last a_a6Hlf) -> ds_d6HAX

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Monoid.$fGeneric1Last2 :: forall a. Last a -> Last a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6HkO) (x_a6H4K [Occ=Once] :: Last a_a6HkO) ->
                 x_a6H4K}]
Data.Monoid.$fGeneric1Last2
  = \ (@ a_a6HkO) (x_a6H4K :: Last a_a6HkO) -> x_a6H4K

-- RHS size: {terms: 3, types: 3, coercions: 184, joins: 0/0}
Data.Monoid.$fGeneric1Last [InlPrag=NOUSERINLINE CONLIKE]
  :: Generic1 Last
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Generics.C:Generic1 TYPE: *
                               TYPE: Last
                               Data.Monoid.$fGeneric1Last2
                               `cast` (forall (a :: <*>_N).
                                       <Last a>_R
                                       ->_R (Sym (GHC.Generics.N:Rec1[0]
                                                      <*>_N
                                                      (Sym (Data.Monoid.N:Last[0]))) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                 <*>_N
                                                                                                 <S>_P
                                                                                                 <'MetaSel
                                                                                                    ('Just
                                                                                                       "getLast")
                                                                                                    'NoSourceUnpackedness
                                                                                                    'NoSourceStrictness
                                                                                                    'DecidedLazy>_P
                                                                                                 <Rec1
                                                                                                    Maybe>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                          <*>_N
                                                                                                                          <C>_P
                                                                                                                          <'MetaCons
                                                                                                                             "Last"
                                                                                                                             'PrefixI
                                                                                                                             'True>_P
                                                                                                                          <M1
                                                                                                                             S
                                                                                                                             ('MetaSel
                                                                                                                                ('Just
                                                                                                                                   "getLast")
                                                                                                                                'NoSourceUnpackedness
                                                                                                                                'NoSourceStrictness
                                                                                                                                'DecidedLazy)
                                                                                                                             (Rec1
                                                                                                                                Maybe)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                       <*>_N
                                                                                                                                                       <D>_P
                                                                                                                                                       <'MetaData
                                                                                                                                                          "Last"
                                                                                                                                                          "Data.Monoid"
                                                                                                                                                          "base"
                                                                                                                                                          'True>_P
                                                                                                                                                       <M1
                                                                                                                                                          C
                                                                                                                                                          ('MetaCons
                                                                                                                                                             "Last"
                                                                                                                                                             'PrefixI
                                                                                                                                                             'True)
                                                                                                                                                          (M1
                                                                                                                                                             S
                                                                                                                                                             ('MetaSel
                                                                                                                                                                ('Just
                                                                                                                                                                   "getLast")
                                                                                                                                                                'NoSourceUnpackedness
                                                                                                                                                                'NoSourceStrictness
                                                                                                                                                                'DecidedLazy)
                                                                                                                                                             (Rec1
                                                                                                                                                                Maybe))>_R) ; Sub (Sym (Data.Monoid.Rep1_Last[0])))))) <a>_N
                                       :: (forall a. Last a -> Last a :: *)
                                          ~R# (forall a. Last a -> Rep1 Last a :: *))
                               Data.Monoid.$fGeneric1Last1
                               `cast` (forall (a :: <*>_N).
                                       <Rep1 Last a>_R
                                       ->_R (Sub (Data.Monoid.Rep1_Last[0]) ; (GHC.Generics.N:M1[0]
                                                                                   <*>_N
                                                                                   <D>_P
                                                                                   <'MetaData
                                                                                      "Last"
                                                                                      "Data.Monoid"
                                                                                      "base"
                                                                                      'True>_P
                                                                                   <M1
                                                                                      C
                                                                                      ('MetaCons
                                                                                         "Last"
                                                                                         'PrefixI
                                                                                         'True)
                                                                                      (M1
                                                                                         S
                                                                                         ('MetaSel
                                                                                            ('Just
                                                                                               "getLast")
                                                                                            'NoSourceUnpackedness
                                                                                            'NoSourceStrictness
                                                                                            'DecidedLazy)
                                                                                         (Rec1
                                                                                            Maybe))>_R ; (GHC.Generics.N:M1[0]
                                                                                                              <*>_N
                                                                                                              <C>_P
                                                                                                              <'MetaCons
                                                                                                                 "Last"
                                                                                                                 'PrefixI
                                                                                                                 'True>_P
                                                                                                              <M1
                                                                                                                 S
                                                                                                                 ('MetaSel
                                                                                                                    ('Just
                                                                                                                       "getLast")
                                                                                                                    'NoSourceUnpackedness
                                                                                                                    'NoSourceStrictness
                                                                                                                    'DecidedLazy)
                                                                                                                 (Rec1
                                                                                                                    Maybe)>_R ; (GHC.Generics.N:M1[0]
                                                                                                                                     <*>_N
                                                                                                                                     <S>_P
                                                                                                                                     <'MetaSel
                                                                                                                                        ('Just
                                                                                                                                           "getLast")
                                                                                                                                        'NoSourceUnpackedness
                                                                                                                                        'NoSourceStrictness
                                                                                                                                        'DecidedLazy>_P
                                                                                                                                     <Rec1
                                                                                                                                        Maybe>_R ; GHC.Generics.N:Rec1[0]
                                                                                                                                                       <*>_N
                                                                                                                                                       (Sym (Data.Monoid.N:Last[0])))))) <a>_N
                                       :: (forall a. Rep1 Last a -> Rep1 Last a :: *)
                                          ~R# (forall a. Rep1 Last a -> Last a :: *))]
Data.Monoid.$fGeneric1Last
  = GHC.Generics.C:Generic1
      @ *
      @ Last
      (Data.Monoid.$fGeneric1Last2
       `cast` (forall (a :: <*>_N).
               <Last a>_R
               ->_R (Sym (GHC.Generics.N:Rec1[0]
                              <*>_N (Sym (Data.Monoid.N:Last[0]))) ; (Sym (GHC.Generics.N:M1[0]
                                                                               <*>_N
                                                                               <S>_P
                                                                               <'MetaSel
                                                                                  ('Just "getLast")
                                                                                  'NoSourceUnpackedness
                                                                                  'NoSourceStrictness
                                                                                  'DecidedLazy>_P
                                                                               <Rec1
                                                                                  Maybe>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                        <*>_N
                                                                                                        <C>_P
                                                                                                        <'MetaCons
                                                                                                           "Last"
                                                                                                           'PrefixI
                                                                                                           'True>_P
                                                                                                        <M1
                                                                                                           S
                                                                                                           ('MetaSel
                                                                                                              ('Just
                                                                                                                 "getLast")
                                                                                                              'NoSourceUnpackedness
                                                                                                              'NoSourceStrictness
                                                                                                              'DecidedLazy)
                                                                                                           (Rec1
                                                                                                              Maybe)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                     <*>_N
                                                                                                                                     <D>_P
                                                                                                                                     <'MetaData
                                                                                                                                        "Last"
                                                                                                                                        "Data.Monoid"
                                                                                                                                        "base"
                                                                                                                                        'True>_P
                                                                                                                                     <M1
                                                                                                                                        C
                                                                                                                                        ('MetaCons
                                                                                                                                           "Last"
                                                                                                                                           'PrefixI
                                                                                                                                           'True)
                                                                                                                                        (M1
                                                                                                                                           S
                                                                                                                                           ('MetaSel
                                                                                                                                              ('Just
                                                                                                                                                 "getLast")
                                                                                                                                              'NoSourceUnpackedness
                                                                                                                                              'NoSourceStrictness
                                                                                                                                              'DecidedLazy)
                                                                                                                                           (Rec1
                                                                                                                                              Maybe))>_R) ; Sub (Sym (Data.Monoid.Rep1_Last[0])))))) <a>_N
               :: (forall a. Last a -> Last a :: *)
                  ~R# (forall a. Last a -> Rep1 Last a :: *)))
      (Data.Monoid.$fGeneric1Last1
       `cast` (forall (a :: <*>_N).
               <Rep1 Last a>_R
               ->_R (Sub (Data.Monoid.Rep1_Last[0]) ; (GHC.Generics.N:M1[0]
                                                           <*>_N
                                                           <D>_P
                                                           <'MetaData
                                                              "Last" "Data.Monoid" "base" 'True>_P
                                                           <M1
                                                              C
                                                              ('MetaCons "Last" 'PrefixI 'True)
                                                              (M1
                                                                 S
                                                                 ('MetaSel
                                                                    ('Just "getLast")
                                                                    'NoSourceUnpackedness
                                                                    'NoSourceStrictness
                                                                    'DecidedLazy)
                                                                 (Rec1
                                                                    Maybe))>_R ; (GHC.Generics.N:M1[0]
                                                                                      <*>_N
                                                                                      <C>_P
                                                                                      <'MetaCons
                                                                                         "Last"
                                                                                         'PrefixI
                                                                                         'True>_P
                                                                                      <M1
                                                                                         S
                                                                                         ('MetaSel
                                                                                            ('Just
                                                                                               "getLast")
                                                                                            'NoSourceUnpackedness
                                                                                            'NoSourceStrictness
                                                                                            'DecidedLazy)
                                                                                         (Rec1
                                                                                            Maybe)>_R ; (GHC.Generics.N:M1[0]
                                                                                                             <*>_N
                                                                                                             <S>_P
                                                                                                             <'MetaSel
                                                                                                                ('Just
                                                                                                                   "getLast")
                                                                                                                'NoSourceUnpackedness
                                                                                                                'NoSourceStrictness
                                                                                                                'DecidedLazy>_P
                                                                                                             <Rec1
                                                                                                                Maybe>_R ; GHC.Generics.N:Rec1[0]
                                                                                                                               <*>_N
                                                                                                                               (Sym (Data.Monoid.N:Last[0])))))) <a>_N
               :: (forall a. Rep1 Last a -> Rep1 Last a :: *)
                  ~R# (forall a. Rep1 Last a -> Last a :: *)))

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Monoid.$fGenericLast1
  :: forall a x. Rep (Last a) x -> Rep (Last a) x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6HjN)
                 (@ x_a6Hkj)
                 (ds_d6HAR [Occ=Once] :: Rep (Last a_a6HjN) x_a6Hkj) ->
                 ds_d6HAR}]
Data.Monoid.$fGenericLast1
  = \ (@ a_a6HjN)
      (@ x_a6Hkj)
      (ds_d6HAR :: Rep (Last a_a6HjN) x_a6Hkj) ->
      ds_d6HAR

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Data.Monoid.$fGenericLast2 :: forall a x. Last a -> Last a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_X6Hmj)
                 (@ x_a6HjR)
                 (x1_a6H4G [Occ=Once] :: Last a_X6Hmj) ->
                 x1_a6H4G}]
Data.Monoid.$fGenericLast2
  = \ (@ a_X6Hmj) (@ x_a6HjR) (x1_a6H4G :: Last a_X6Hmj) -> x1_a6H4G

-- RHS size: {terms: 4, types: 6, coercions: 206, joins: 0/0}
Data.Monoid.$fGenericLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Generic (Last a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_a6GjU) ->
       GHC.Generics.C:Generic TYPE: Last a_a6GjU
                              (Data.Monoid.$fGenericLast2 @ a_a6GjU)
                              `cast` (forall (x :: <*>_N).
                                      <Last a_a6GjU>_R
                                      ->_R Data.Monoid.N:Last[0] <a_a6GjU>_N ; (Sym (GHC.Generics.N:K1[0]
                                                                                         <*>_N
                                                                                         <R>_P
                                                                                         <Maybe
                                                                                            a_a6GjU>_R
                                                                                         <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                            <*>_N
                                                                                                            <S>_P
                                                                                                            <'MetaSel
                                                                                                               ('Just
                                                                                                                  "getLast")
                                                                                                               'NoSourceUnpackedness
                                                                                                               'NoSourceStrictness
                                                                                                               'DecidedLazy>_P
                                                                                                            <K1
                                                                                                               R
                                                                                                               (Maybe
                                                                                                                  a_a6GjU)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                           <*>_N
                                                                                                                                           <C>_P
                                                                                                                                           <'MetaCons
                                                                                                                                              "Last"
                                                                                                                                              'PrefixI
                                                                                                                                              'True>_P
                                                                                                                                           <M1
                                                                                                                                              S
                                                                                                                                              ('MetaSel
                                                                                                                                                 ('Just
                                                                                                                                                    "getLast")
                                                                                                                                                 'NoSourceUnpackedness
                                                                                                                                                 'NoSourceStrictness
                                                                                                                                                 'DecidedLazy)
                                                                                                                                              (K1
                                                                                                                                                 R
                                                                                                                                                 (Maybe
                                                                                                                                                    a_a6GjU))>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                                              <*>_N
                                                                                                                                                                              <D>_P
                                                                                                                                                                              <'MetaData
                                                                                                                                                                                 "Last"
                                                                                                                                                                                 "Data.Monoid"
                                                                                                                                                                                 "base"
                                                                                                                                                                                 'True>_P
                                                                                                                                                                              <M1
                                                                                                                                                                                 C
                                                                                                                                                                                 ('MetaCons
                                                                                                                                                                                    "Last"
                                                                                                                                                                                    'PrefixI
                                                                                                                                                                                    'True)
                                                                                                                                                                                 (M1
                                                                                                                                                                                    S
                                                                                                                                                                                    ('MetaSel
                                                                                                                                                                                       ('Just
                                                                                                                                                                                          "getLast")
                                                                                                                                                                                       'NoSourceUnpackedness
                                                                                                                                                                                       'NoSourceStrictness
                                                                                                                                                                                       'DecidedLazy)
                                                                                                                                                                                    (K1
                                                                                                                                                                                       R
                                                                                                                                                                                       (Maybe
                                                                                                                                                                                          a_a6GjU)))>_R) ; Sub (Sym (Data.Monoid.Rep_Last[0]
                                                                                                                                                                                                                         <a_a6GjU>_N))))) <x>_N)
                                      :: (forall x. Last a_a6GjU -> Last a_a6GjU :: *)
                                         ~R# (forall x. Last a_a6GjU -> Rep (Last a_a6GjU) x :: *))
                              (Data.Monoid.$fGenericLast1 @ a_a6GjU)
                              `cast` (forall (x :: <*>_N).
                                      <Rep (Last a_a6GjU) x>_R
                                      ->_R (Sub (Data.Monoid.Rep_Last[0]
                                                     <a_a6GjU>_N) ; (GHC.Generics.N:M1[0]
                                                                         <*>_N
                                                                         <D>_P
                                                                         <'MetaData
                                                                            "Last"
                                                                            "Data.Monoid"
                                                                            "base"
                                                                            'True>_P
                                                                         <M1
                                                                            C
                                                                            ('MetaCons
                                                                               "Last"
                                                                               'PrefixI
                                                                               'True)
                                                                            (M1
                                                                               S
                                                                               ('MetaSel
                                                                                  ('Just "getLast")
                                                                                  'NoSourceUnpackedness
                                                                                  'NoSourceStrictness
                                                                                  'DecidedLazy)
                                                                               (K1
                                                                                  R
                                                                                  (Maybe
                                                                                     a_a6GjU)))>_R ; (GHC.Generics.N:M1[0]
                                                                                                          <*>_N
                                                                                                          <C>_P
                                                                                                          <'MetaCons
                                                                                                             "Last"
                                                                                                             'PrefixI
                                                                                                             'True>_P
                                                                                                          <M1
                                                                                                             S
                                                                                                             ('MetaSel
                                                                                                                ('Just
                                                                                                                   "getLast")
                                                                                                                'NoSourceUnpackedness
                                                                                                                'NoSourceStrictness
                                                                                                                'DecidedLazy)
                                                                                                             (K1
                                                                                                                R
                                                                                                                (Maybe
                                                                                                                   a_a6GjU))>_R ; GHC.Generics.N:M1[0]
                                                                                                                                      <*>_N
                                                                                                                                      <S>_P
                                                                                                                                      <'MetaSel
                                                                                                                                         ('Just
                                                                                                                                            "getLast")
                                                                                                                                         'NoSourceUnpackedness
                                                                                                                                         'NoSourceStrictness
                                                                                                                                         'DecidedLazy>_P
                                                                                                                                      <K1
                                                                                                                                         R
                                                                                                                                         (Maybe
                                                                                                                                            a_a6GjU)>_R))) <x>_N ; (GHC.Generics.N:K1[0]
                                                                                                                                                                        <*>_N
                                                                                                                                                                        <R>_P
                                                                                                                                                                        <Maybe
                                                                                                                                                                           a_a6GjU>_R
                                                                                                                                                                        <x>_P ; Sym (Data.Monoid.N:Last[0]) <a_a6GjU>_N)
                                      :: (forall x.
                                          Rep (Last a_a6GjU) x -> Rep (Last a_a6GjU) x :: *)
                                         ~R# (forall x. Rep (Last a_a6GjU) x -> Last a_a6GjU :: *))]
Data.Monoid.$fGenericLast
  = \ (@ a_X6Hmo) ->
      GHC.Generics.C:Generic
        @ (Last a_X6Hmo)
        ((Data.Monoid.$fGenericLast2 @ a_X6Hmo)
         `cast` (forall (x :: <*>_N).
                 <Last a_X6Hmo>_R
                 ->_R Data.Monoid.N:Last[0] <a_X6Hmo>_N ; (Sym (GHC.Generics.N:K1[0]
                                                                    <*>_N
                                                                    <R>_P
                                                                    <Maybe a_X6Hmo>_R
                                                                    <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                       <*>_N
                                                                                       <S>_P
                                                                                       <'MetaSel
                                                                                          ('Just
                                                                                             "getLast")
                                                                                          'NoSourceUnpackedness
                                                                                          'NoSourceStrictness
                                                                                          'DecidedLazy>_P
                                                                                       <K1
                                                                                          R
                                                                                          (Maybe
                                                                                             a_X6Hmo)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                      <*>_N
                                                                                                                      <C>_P
                                                                                                                      <'MetaCons
                                                                                                                         "Last"
                                                                                                                         'PrefixI
                                                                                                                         'True>_P
                                                                                                                      <M1
                                                                                                                         S
                                                                                                                         ('MetaSel
                                                                                                                            ('Just
                                                                                                                               "getLast")
                                                                                                                            'NoSourceUnpackedness
                                                                                                                            'NoSourceStrictness
                                                                                                                            'DecidedLazy)
                                                                                                                         (K1
                                                                                                                            R
                                                                                                                            (Maybe
                                                                                                                               a_X6Hmo))>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                         <*>_N
                                                                                                                                                         <D>_P
                                                                                                                                                         <'MetaData
                                                                                                                                                            "Last"
                                                                                                                                                            "Data.Monoid"
                                                                                                                                                            "base"
                                                                                                                                                            'True>_P
                                                                                                                                                         <M1
                                                                                                                                                            C
                                                                                                                                                            ('MetaCons
                                                                                                                                                               "Last"
                                                                                                                                                               'PrefixI
                                                                                                                                                               'True)
                                                                                                                                                            (M1
                                                                                                                                                               S
                                                                                                                                                               ('MetaSel
                                                                                                                                                                  ('Just
                                                                                                                                                                     "getLast")
                                                                                                                                                                  'NoSourceUnpackedness
                                                                                                                                                                  'NoSourceStrictness
                                                                                                                                                                  'DecidedLazy)
                                                                                                                                                               (K1
                                                                                                                                                                  R
                                                                                                                                                                  (Maybe
                                                                                                                                                                     a_X6Hmo)))>_R) ; Sub (Sym (Data.Monoid.Rep_Last[0]
                                                                                                                                                                                                    <a_X6Hmo>_N))))) <x>_N)
                 :: (forall x. Last a_X6Hmo -> Last a_X6Hmo :: *)
                    ~R# (forall x. Last a_X6Hmo -> Rep (Last a_X6Hmo) x :: *)))
        ((Data.Monoid.$fGenericLast1 @ a_X6Hmo)
         `cast` (forall (x :: <*>_N).
                 <Rep (Last a_X6Hmo) x>_R
                 ->_R (Sub (Data.Monoid.Rep_Last[0]
                                <a_X6Hmo>_N) ; (GHC.Generics.N:M1[0]
                                                    <*>_N
                                                    <D>_P
                                                    <'MetaData "Last" "Data.Monoid" "base" 'True>_P
                                                    <M1
                                                       C
                                                       ('MetaCons "Last" 'PrefixI 'True)
                                                       (M1
                                                          S
                                                          ('MetaSel
                                                             ('Just "getLast")
                                                             'NoSourceUnpackedness
                                                             'NoSourceStrictness
                                                             'DecidedLazy)
                                                          (K1
                                                             R
                                                             (Maybe
                                                                a_X6Hmo)))>_R ; (GHC.Generics.N:M1[0]
                                                                                     <*>_N
                                                                                     <C>_P
                                                                                     <'MetaCons
                                                                                        "Last"
                                                                                        'PrefixI
                                                                                        'True>_P
                                                                                     <M1
                                                                                        S
                                                                                        ('MetaSel
                                                                                           ('Just
                                                                                              "getLast")
                                                                                           'NoSourceUnpackedness
                                                                                           'NoSourceStrictness
                                                                                           'DecidedLazy)
                                                                                        (K1
                                                                                           R
                                                                                           (Maybe
                                                                                              a_X6Hmo))>_R ; GHC.Generics.N:M1[0]
                                                                                                                 <*>_N
                                                                                                                 <S>_P
                                                                                                                 <'MetaSel
                                                                                                                    ('Just
                                                                                                                       "getLast")
                                                                                                                    'NoSourceUnpackedness
                                                                                                                    'NoSourceStrictness
                                                                                                                    'DecidedLazy>_P
                                                                                                                 <K1
                                                                                                                    R
                                                                                                                    (Maybe
                                                                                                                       a_X6Hmo)>_R))) <x>_N ; (GHC.Generics.N:K1[0]
                                                                                                                                                   <*>_N
                                                                                                                                                   <R>_P
                                                                                                                                                   <Maybe
                                                                                                                                                      a_X6Hmo>_R
                                                                                                                                                   <x>_P ; Sym (Data.Monoid.N:Last[0]) <a_X6Hmo>_N)
                 :: (forall x. Rep (Last a_X6Hmo) x -> Rep (Last a_X6Hmo) x :: *)
                    ~R# (forall x. Rep (Last a_X6Hmo) x -> Last a_X6Hmo :: *)))

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$fShowFirst1 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Monoid.$fShowFirst1 = GHC.Types.I# 0#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$fShowLast2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Monoid.$fShowLast2 = "Last {"#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$fShowLast1 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Monoid.$fShowLast1 = "getLast = "#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$fReadFirst4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Monoid.$fReadFirst4 = "}"#

-- RHS size: {terms: 37, types: 15, coercions: 2, joins: 0/1}
Data.Monoid.$w$cshowsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => Int# -> Last a -> ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 331 120}]
Data.Monoid.$w$cshowsPrec1
  = \ (@ a_s6HWQ)
      (w_s6HWR :: Show a_s6HWQ)
      (ww_s6HWW :: Int#)
      (w1_s6HWT :: Last a_s6HWQ) ->
      let {
        f_s6HQU [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        f_s6HQU
          = GHC.Show.$fShowMaybe_$cshowsPrec
              @ a_s6HWQ
              w_s6HWR
              Data.Monoid.$fShowFirst1
              (w1_s6HWT
               `cast` (Data.Monoid.N:Last[0] <a_s6HWQ>_N
                       :: (Last a_s6HWQ :: *) ~R# (Maybe a_s6HWQ :: *))) } in
      case >=# ww_s6HWW 11# of {
        __DEFAULT ->
          \ (x_X6HDi :: String) ->
            unpackAppendCString#
              Data.Monoid.$fShowLast2
              (unpackAppendCString#
                 Data.Monoid.$fShowLast1
                 (f_s6HQU (unpackAppendCString# Data.Monoid.$fReadFirst4 x_X6HDi)));
        1# ->
          \ (x_i6HAc :: String) ->
            GHC.Types.:
              @ Char
              GHC.Show.$fShow(,)4
              (unpackAppendCString#
                 Data.Monoid.$fShowLast2
                 (unpackAppendCString#
                    Data.Monoid.$fShowLast1
                    (f_s6HQU
                       (unpackAppendCString#
                          Data.Monoid.$fReadFirst4
                          (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x_i6HAc)))))
      }

-- RHS size: {terms: 11, types: 10, coercions: 0, joins: 0/0}
Data.Monoid.$fShowLast_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => Int -> Last a -> ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6HWQ)
                 (w_s6HWR [Occ=Once] :: Show a_s6HWQ)
                 (w1_s6HWS [Occ=Once!] :: Int)
                 (w2_s6HWT [Occ=Once] :: Last a_s6HWQ) ->
                 case w1_s6HWS of { I# ww1_s6HWW [Occ=Once] ->
                 Data.Monoid.$w$cshowsPrec1 @ a_s6HWQ w_s6HWR ww1_s6HWW w2_s6HWT
                 }}]
Data.Monoid.$fShowLast_$cshowsPrec
  = \ (@ a_s6HWQ)
      (w_s6HWR :: Show a_s6HWQ)
      (w1_s6HWS :: Int)
      (w2_s6HWT :: Last a_s6HWQ) ->
      case w1_s6HWS of { I# ww1_s6HWW ->
      Data.Monoid.$w$cshowsPrec1 @ a_s6HWQ w_s6HWR ww1_s6HWW w2_s6HWT
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$fReadFirst3 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Monoid.$fReadFirst3 = unpackCString# Data.Monoid.$fReadFirst4

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Monoid.$fShowFirst4 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
Data.Monoid.$fShowFirst4
  = ++ @ Char GHC.Show.$fShowMaybe4 Data.Monoid.$fReadFirst3

-- RHS size: {terms: 19, types: 11, coercions: 2, joins: 0/0}
Data.Monoid.$fShowLast_$cshow
  :: forall a. Show a => Last a -> String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30] 160 0}]
Data.Monoid.$fShowLast_$cshow
  = \ (@ a_a6Hji)
      ($dShow_a6Hjj :: Show a_a6Hji)
      (x_i6HAp :: Last a_a6Hji) ->
      unpackAppendCString#
        Data.Monoid.$fShowLast2
        (unpackAppendCString#
           Data.Monoid.$fShowLast1
           (case x_i6HAp
                 `cast` (Data.Monoid.N:Last[0] <a_a6Hji>_N
                         :: (Last a_a6Hji :: *) ~R# (Maybe a_a6Hji :: *))
            of {
              Nothing -> Data.Monoid.$fShowFirst4;
              Just b1_i6HHj ->
                ++
                  @ Char
                  GHC.Show.$fShowMaybe1
                  (showsPrec
                     @ a_a6Hji $dShow_a6Hjj appPrec1 b1_i6HHj Data.Monoid.$fReadFirst3)
            }))

-- RHS size: {terms: 12, types: 13, coercions: 0, joins: 0/0}
Data.Monoid.$fShowLast_$cshowList
  :: forall a. Show a => [Last a] -> ShowS
[GblId,
 Arity=3,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6Hji)
                 ($dShow_a6Hjj [Occ=Once] :: Show a_a6Hji)
                 (ls_i6HAs [Occ=Once] :: [Last a_a6Hji])
                 (s_i6HAt [Occ=Once] :: String) ->
                 showList__
                   @ (Last a_a6Hji)
                   (Data.Monoid.$fShowLast_$cshowsPrec
                      @ a_a6Hji $dShow_a6Hjj Data.Monoid.$fShowFirst1)
                   ls_i6HAs
                   s_i6HAt}]
Data.Monoid.$fShowLast_$cshowList
  = \ (@ a_a6Hji)
      ($dShow_a6Hjj :: Show a_a6Hji)
      (ls_i6HAs :: [Last a_a6Hji])
      (s_i6HAt :: String) ->
      showList__
        @ (Last a_a6Hji)
        (\ (w_s6HWT :: Last a_a6Hji) ->
           Data.Monoid.$w$cshowsPrec1 @ a_a6Hji $dShow_a6Hjj 0# w_s6HWT)
        ls_i6HAs
        s_i6HAt

-- RHS size: {terms: 9, types: 9, coercions: 0, joins: 0/0}
Data.Monoid.$fShowLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Show a => Show (Last a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(C1(C(U))),A,A)>m,
 Unf=DFun: \ (@ a_a6GjU) (v_B1 :: Show a_a6GjU) ->
       GHC.Show.C:Show TYPE: Last a_a6GjU
                       Data.Monoid.$fShowLast_$cshowsPrec @ a_a6GjU v_B1
                       Data.Monoid.$fShowLast_$cshow @ a_a6GjU v_B1
                       Data.Monoid.$fShowLast_$cshowList @ a_a6GjU v_B1]
Data.Monoid.$fShowLast
  = \ (@ a_a6Hji) ($dShow_a6Hjj :: Show a_a6Hji) ->
      GHC.Show.C:Show
        @ (Last a_a6Hji)
        (Data.Monoid.$fShowLast_$cshowsPrec @ a_a6Hji $dShow_a6Hjj)
        (Data.Monoid.$fShowLast_$cshow @ a_a6Hji $dShow_a6Hjj)
        (Data.Monoid.$fShowLast_$cshowList @ a_a6Hji $dShow_a6Hjj)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$fReadLast5 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Monoid.$fReadLast5 = "Last"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$fReadLast4 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Monoid.$fReadLast4 = unpackCString# Data.Monoid.$fReadLast5

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$fReadLast_lexeme :: Text.Read.Lex.Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Monoid.$fReadLast_lexeme
  = Text.Read.Lex.Ident Data.Monoid.$fReadLast4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$fReadFirst9 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Monoid.$fReadFirst9 = "{"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$fReadFirst8 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Monoid.$fReadFirst8 = unpackCString# Data.Monoid.$fReadFirst9

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$fReadFirst_lexeme :: Text.Read.Lex.Lexeme
[GblId,
 Str=m3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Monoid.$fReadFirst_lexeme
  = Text.Read.Lex.Punc Data.Monoid.$fReadFirst8

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$fReadLast3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Monoid.$fReadLast3 = "getLast"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$fReadLast2 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Monoid.$fReadLast2 = unpackCString# Data.Monoid.$fReadLast3

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$fReadFirst5 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Monoid.$fReadFirst5 = GHC.Types.I# 11#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$fReadFirst2 :: Text.Read.Lex.Lexeme
[GblId,
 Str=m3,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Monoid.$fReadFirst2
  = Text.Read.Lex.Punc Data.Monoid.$fReadFirst3

-- RHS size: {terms: 57, types: 81, coercions: 31, joins: 0/1}
Data.Monoid.$fReadLast1
  :: forall a.
     Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Last a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 421 0}]
Data.Monoid.$fReadLast1
  = \ (@ a_a6Hit)
      ($dRead_a6Hiu :: Read a_a6Hit)
      (eta_B2 :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b_i6HzL)
      (eta1_B1
         :: Last a_a6Hit -> Text.ParserCombinators.ReadP.P b_i6HzL) ->
      GHC.Read.list3
        @ (Last a_a6Hit)
        (let {
           ds_s6HQH [Dmd=<L,C(C1(U))>]
             :: Text.ParserCombinators.ReadPrec.Prec
                -> forall b1.
                   (Maybe a_a6Hit -> Text.ParserCombinators.ReadP.P b1)
                   -> Text.ParserCombinators.ReadP.P b1
           [LclId,
            Arity=2,
            Str=<L,A><L,U>,
            Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                    WorkFree=True, Expandable=True,
                    Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
                    Tmpl= \ _ [Occ=Dead]
                            (@ b1_i6HCr)
                            (eta2_X7 [Occ=Once]
                               :: Maybe a_a6Hit -> Text.ParserCombinators.ReadP.P b1_i6HCr) ->
                            GHC.Read.$fReadMaybe1
                              @ a_a6Hit
                              $dRead_a6Hiu
                              Text.ParserCombinators.ReadPrec.minPrec
                              @ b1_i6HCr
                              eta2_X7}]
           ds_s6HQH
             = \ _ [Occ=Dead]
                 (@ b1_i6HCr)
                 (eta2_X7 [OS=OneShot]
                    :: Maybe a_a6Hit -> Text.ParserCombinators.ReadP.P b1_i6HCr) ->
                 GHC.Read.$fReadMaybe1
                   @ a_a6Hit
                   $dRead_a6Hiu
                   Text.ParserCombinators.ReadPrec.minPrec
                   @ b1_i6HCr
                   eta2_X7 } in
         (\ (c_i6HJ4 :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b1_i6HIg)
            (eta2_X2a
               :: Last a_a6Hit -> Text.ParserCombinators.ReadP.P b1_i6HIg) ->
            case c_i6HJ4 of { I# x_i6HJ7 ->
            case <=# x_i6HJ7 11# of {
              __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1_i6HIg;
              1# ->
                case Text.Read.Lex.$wexpect
                       Data.Monoid.$fReadLast_lexeme
                       @ b1_i6HIg
                       (\ _ [Occ=Dead, OS=OneShot] ->
                          case Text.Read.Lex.$wexpect
                                 Data.Monoid.$fReadFirst_lexeme
                                 @ b1_i6HIg
                                 (\ _ [Occ=Dead, OS=OneShot] ->
                                    ((((readField
                                          @ (Maybe a_a6Hit)
                                          Data.Monoid.$fReadLast2
                                          (ds_s6HQH
                                           `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                                  <Maybe
                                                                     a_a6Hit>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                                             <Maybe
                                                                                                a_a6Hit>_R)
                                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                                       -> forall b.
                                                          (Maybe a_a6Hit
                                                           -> Text.ParserCombinators.ReadP.P b)
                                                          -> Text.ParserCombinators.ReadP.P b :: *)
                                                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                                             (Maybe a_a6Hit) :: *))))
                                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                   <Maybe a_a6Hit>_R
                                               :: (Text.ParserCombinators.ReadPrec.ReadPrec
                                                     (Maybe a_a6Hit) :: *)
                                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                       -> Text.ParserCombinators.ReadP.ReadP
                                                            (Maybe a_a6Hit) :: *)))
                                        Data.Monoid.$fReadFirst5)
                                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                 <Maybe a_a6Hit>_R
                                             :: (Text.ParserCombinators.ReadP.ReadP
                                                   (Maybe a_a6Hit) :: *)
                                                ~R# (forall b.
                                                     (Maybe a_a6Hit
                                                      -> Text.ParserCombinators.ReadP.P b)
                                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                                      @ b1_i6HIg
                                      (\ (a3_i6HKa :: Maybe a_a6Hit) ->
                                         case Text.Read.Lex.$wexpect
                                                Data.Monoid.$fReadFirst2
                                                @ b1_i6HIg
                                                (\ _ [Occ=Dead, OS=OneShot] ->
                                                   eta2_X2a
                                                     (a3_i6HKa
                                                      `cast` (Sym (Data.Monoid.N:Last[0]) <a_a6Hit>_N
                                                              :: (Maybe a_a6Hit :: *)
                                                                 ~R# (Last a_a6Hit :: *))))
                                         of
                                         { (# ww1_i6HJX #) ->
                                         Text.ParserCombinators.ReadP.Look @ b1_i6HIg ww1_i6HJX
                                         }))
                          of
                          { (# ww1_i6HJX #) ->
                          Text.ParserCombinators.ReadP.Look @ b1_i6HIg ww1_i6HJX
                          })
                of
                { (# ww1_i6HJX #) ->
                Text.ParserCombinators.ReadP.Look @ b1_i6HIg ww1_i6HJX
                }
            }
            })
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Last
                                   a_a6Hit>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Last a_a6Hit>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Last a_a6Hit -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (Last a_a6Hit) :: *)))
        eta_B2
        @ b_i6HzL
        eta1_B1

-- RHS size: {terms: 8, types: 12, coercions: 0, joins: 0/0}
Data.Monoid.$fReadLast_$creadsPrec
  :: forall a. Read a => Int -> ReadS (Last a)
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X6Hlg)
                 ($dRead_X6Hli [Occ=Once] :: Read a_X6Hlg)
                 (n_i6HzD [Occ=Once] :: Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ (Last a_X6Hlg)
                   (Data.Monoid.$fReadLast1
                      @ a_X6Hlg
                      $dRead_X6Hli
                      n_i6HzD
                      @ (Last a_X6Hlg)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ (Last a_X6Hlg)))}]
Data.Monoid.$fReadLast_$creadsPrec
  = \ (@ a_X6Hlg) ($dRead_X6Hli :: Read a_X6Hlg) (n_i6HzD :: Int) ->
      Text.ParserCombinators.ReadP.run
        @ (Last a_X6Hlg)
        (Data.Monoid.$fReadLast1
           @ a_X6Hlg
           $dRead_X6Hli
           n_i6HzD
           @ (Last a_X6Hlg)
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ (Last a_X6Hlg)))

-- RHS size: {terms: 5, types: 7, coercions: 11, joins: 0/0}
Data.Monoid.$fReadLast_$creadListPrec
  :: forall a.
     Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Last a]
[GblId,
 Arity=1,
 Str=<L,U(A,A,C(C1(U)),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X6Hle) ($dRead_X6Hlg [Occ=Once] :: Read a_X6Hle) ->
                 list
                   @ (Last a_X6Hle)
                   ((Data.Monoid.$fReadLast1 @ a_X6Hle $dRead_X6Hlg)
                    `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Last
                                              a_X6Hle>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <Last a_X6Hle>_R)
                            :: (Text.ParserCombinators.ReadPrec.Prec
                                -> forall b.
                                   (Last a_X6Hle -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)
                               ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                      (Last a_X6Hle) :: *)))}]
Data.Monoid.$fReadLast_$creadListPrec
  = \ (@ a_X6Hle) ($dRead_X6Hlg :: Read a_X6Hle) ->
      list
        @ (Last a_X6Hle)
        ((Data.Monoid.$fReadLast1 @ a_X6Hle $dRead_X6Hlg)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Last
                                   a_X6Hle>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Last a_X6Hle>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Last a_X6Hle -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (Last a_X6Hle) :: *)))

-- RHS size: {terms: 8, types: 16, coercions: 19, joins: 0/0}
Data.Monoid.$fReadLast_$creadList
  :: forall a. Read a => ReadS [Last a]
[GblId,
 Arity=1,
 Str=<L,U(A,A,C(C1(U)),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X6Hlf) ($dRead_X6Hlh [Occ=Once] :: Read a_X6Hlf) ->
                 Text.ParserCombinators.ReadP.run
                   @ [Last a_X6Hlf]
                   (((((list
                          @ (Last a_X6Hlf)
                          ((Data.Monoid.$fReadLast1 @ a_X6Hlf $dRead_X6Hlh)
                           `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                  <Last
                                                     a_X6Hlf>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                             <Last a_X6Hlf>_R)
                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                       -> forall b.
                                          (Last a_X6Hlf -> Text.ParserCombinators.ReadP.P b)
                                          -> Text.ParserCombinators.ReadP.P b :: *)
                                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                             (Last a_X6Hlf) :: *))))
                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                   <[Last a_X6Hlf]>_R
                               :: (Text.ParserCombinators.ReadPrec.ReadPrec [Last a_X6Hlf] :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                       -> Text.ParserCombinators.ReadP.ReadP [Last a_X6Hlf] :: *)))
                        GHC.Read.$fRead()7)
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[Last a_X6Hlf]>_R
                             :: (Text.ParserCombinators.ReadP.ReadP [Last a_X6Hlf] :: *)
                                ~R# (forall b.
                                     ([Last a_X6Hlf] -> Text.ParserCombinators.ReadP.P b)
                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                      @ [Last a_X6Hlf]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [Last a_X6Hlf]))}]
Data.Monoid.$fReadLast_$creadList
  = \ (@ a_X6Hlf) ($dRead_X6Hlh :: Read a_X6Hlf) ->
      Text.ParserCombinators.ReadP.run
        @ [Last a_X6Hlf]
        (((((list
               @ (Last a_X6Hlf)
               ((Data.Monoid.$fReadLast1 @ a_X6Hlf $dRead_X6Hlh)
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Last
                                          a_X6Hlf>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <Last a_X6Hlf>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               (Last a_X6Hlf -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                  (Last a_X6Hlf) :: *))))
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[Last a_X6Hlf]>_R
                    :: (Text.ParserCombinators.ReadPrec.ReadPrec [Last a_X6Hlf] :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.Prec
                            -> Text.ParserCombinators.ReadP.ReadP [Last a_X6Hlf] :: *)))
             GHC.Read.$fRead()7)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[Last a_X6Hlf]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP [Last a_X6Hlf] :: *)
                     ~R# (forall b.
                          ([Last a_X6Hlf] -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [Last a_X6Hlf]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ [Last a_X6Hlf]))

-- RHS size: {terms: 11, types: 10, coercions: 11, joins: 0/0}
Data.Monoid.$fReadLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Read a => Read (Last a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,A,C(C1(U)),A)>m,
 Unf=DFun: \ (@ a_a6GjU) (v_B1 :: Read a_a6GjU) ->
       GHC.Read.C:Read TYPE: Last a_a6GjU
                       Data.Monoid.$fReadLast_$creadsPrec @ a_a6GjU v_B1
                       Data.Monoid.$fReadLast_$creadList @ a_a6GjU v_B1
                       (Data.Monoid.$fReadLast1 @ a_a6GjU v_B1)
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Last
                                                 a_a6GjU>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                         <Last a_a6GjU>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Last a_a6GjU -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                         (Last a_a6GjU) :: *))
                       Data.Monoid.$fReadLast_$creadListPrec @ a_a6GjU v_B1]
Data.Monoid.$fReadLast
  = \ (@ a_X6Hld) ($dRead_X6Hlf :: Read a_X6Hld) ->
      GHC.Read.C:Read
        @ (Last a_X6Hld)
        (Data.Monoid.$fReadLast_$creadsPrec @ a_X6Hld $dRead_X6Hlf)
        (Data.Monoid.$fReadLast_$creadList @ a_X6Hld $dRead_X6Hlf)
        ((Data.Monoid.$fReadLast1 @ a_X6Hld $dRead_X6Hlf)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <Last
                                   a_X6Hld>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <Last a_X6Hld>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (Last a_X6Hld -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (Last a_X6Hld) :: *)))
        (Data.Monoid.$fReadLast_$creadListPrec @ a_X6Hld $dRead_X6Hlf)

-- RHS size: {terms: 7, types: 8, coercions: 18, joins: 0/0}
Data.Monoid.$fEqLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Eq a => Eq (Last a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)>m,
 Unf=DFun: \ (@ a_a6GjU) (v_B1 :: Eq a_a6GjU) ->
       GHC.Classes.C:Eq TYPE: Last a_a6GjU
                        (GHC.Base.$fEqMaybe_$c== @ a_a6GjU v_B1)
                        `cast` (Sym (Data.Monoid.N:Last[0]) <a_a6GjU>_N
                                ->_R Sym (Data.Monoid.N:Last[0]) <a_a6GjU>_N
                                ->_R <Bool>_R
                                :: (Maybe a_a6GjU -> Maybe a_a6GjU -> Bool :: *)
                                   ~R# (Last a_a6GjU -> Last a_a6GjU -> Bool :: *))
                        (GHC.Base.$fEqMaybe_$c/= @ a_a6GjU v_B1)
                        `cast` (Sym (Data.Monoid.N:Last[0]) <a_a6GjU>_N
                                ->_R Sym (Data.Monoid.N:Last[0]) <a_a6GjU>_N
                                ->_R <Bool>_R
                                :: (Maybe a_a6GjU -> Maybe a_a6GjU -> Bool :: *)
                                   ~R# (Last a_a6GjU -> Last a_a6GjU -> Bool :: *))]
Data.Monoid.$fEqLast
  = \ (@ a_a6Hg6) ($dEq_a6Hg7 :: Eq a_a6Hg6) ->
      GHC.Classes.C:Eq
        @ (Last a_a6Hg6)
        ((GHC.Base.$fEqMaybe_$c== @ a_a6Hg6 $dEq_a6Hg7)
         `cast` (Sym (Data.Monoid.N:Last[0]) <a_a6Hg6>_N
                 ->_R Sym (Data.Monoid.N:Last[0]) <a_a6Hg6>_N
                 ->_R <Bool>_R
                 :: (Maybe a_a6Hg6 -> Maybe a_a6Hg6 -> Bool :: *)
                    ~R# (Last a_a6Hg6 -> Last a_a6Hg6 -> Bool :: *)))
        ((GHC.Base.$fEqMaybe_$c/= @ a_a6Hg6 $dEq_a6Hg7)
         `cast` (Sym (Data.Monoid.N:Last[0]) <a_a6Hg6>_N
                 ->_R Sym (Data.Monoid.N:Last[0]) <a_a6Hg6>_N
                 ->_R <Bool>_R
                 :: (Maybe a_a6Hg6 -> Maybe a_a6Hg6 -> Bool :: *)
                    ~R# (Last a_a6Hg6 -> Last a_a6Hg6 -> Bool :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Monoid.$fOrdLast_$cp1Ord :: forall a. Ord a => Eq (Last a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X6HjF) ($dOrd_X6HjH [Occ=Once] :: Ord a_X6HjF) ->
                 Data.Monoid.$fEqLast
                   @ a_X6HjF (GHC.Classes.$p1Ord @ a_X6HjF $dOrd_X6HjH)}]
Data.Monoid.$fOrdLast_$cp1Ord
  = \ (@ a_X6HjF) ($dOrd_X6HjH :: Ord a_X6HjF) ->
      Data.Monoid.$fEqLast
        @ a_X6HjF (GHC.Classes.$p1Ord @ a_X6HjF $dOrd_X6HjH)

-- RHS size: {terms: 23, types: 18, coercions: 67, joins: 0/0}
Data.Monoid.$fOrdLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Ord a => Ord (Last a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m,
 Unf=DFun: \ (@ a_a6GjU) (v_B1 :: Ord a_a6GjU) ->
       GHC.Classes.C:Ord TYPE: Last a_a6GjU
                         Data.Monoid.$fOrdLast_$cp1Ord @ a_a6GjU v_B1
                         (GHC.Base.$fOrdMaybe_$ccompare @ a_a6GjU v_B1)
                         `cast` (Sym (Data.Monoid.N:Last[0]) <a_a6GjU>_N
                                 ->_R Sym (Data.Monoid.N:Last[0]) <a_a6GjU>_N
                                 ->_R <Ordering>_R
                                 :: (Maybe a_a6GjU -> Maybe a_a6GjU -> Ordering :: *)
                                    ~R# (Last a_a6GjU -> Last a_a6GjU -> Ordering :: *))
                         (GHC.Base.$fOrdMaybe_$c< @ a_a6GjU v_B1)
                         `cast` (Sym (Data.Monoid.N:Last[0]) <a_a6GjU>_N
                                 ->_R Sym (Data.Monoid.N:Last[0]) <a_a6GjU>_N
                                 ->_R <Bool>_R
                                 :: (Maybe a_a6GjU -> Maybe a_a6GjU -> Bool :: *)
                                    ~R# (Last a_a6GjU -> Last a_a6GjU -> Bool :: *))
                         (GHC.Base.$fOrdMaybe_$c<= @ a_a6GjU v_B1)
                         `cast` (Sym (Data.Monoid.N:Last[0]) <a_a6GjU>_N
                                 ->_R Sym (Data.Monoid.N:Last[0]) <a_a6GjU>_N
                                 ->_R <Bool>_R
                                 :: (Maybe a_a6GjU -> Maybe a_a6GjU -> Bool :: *)
                                    ~R# (Last a_a6GjU -> Last a_a6GjU -> Bool :: *))
                         (\ (a1_i6HCD [Occ=Once] :: Maybe a_a6GjU)
                            (b_i6HCE [Occ=Once] :: Maybe a_a6GjU) ->
                            GHC.Base.$fOrdMaybe_$c< @ a_a6GjU v_B1 b_i6HCE a1_i6HCD)
                         `cast` (Sym (Data.Monoid.N:Last[0]) <a_a6GjU>_N
                                 ->_R Sym (Data.Monoid.N:Last[0]) <a_a6GjU>_N
                                 ->_R <Bool>_R
                                 :: (Maybe a_a6GjU -> Maybe a_a6GjU -> Bool :: *)
                                    ~R# (Last a_a6GjU -> Last a_a6GjU -> Bool :: *))
                         (GHC.Base.$fOrdMaybe_$c>= @ a_a6GjU v_B1)
                         `cast` (Sym (Data.Monoid.N:Last[0]) <a_a6GjU>_N
                                 ->_R Sym (Data.Monoid.N:Last[0]) <a_a6GjU>_N
                                 ->_R <Bool>_R
                                 :: (Maybe a_a6GjU -> Maybe a_a6GjU -> Bool :: *)
                                    ~R# (Last a_a6GjU -> Last a_a6GjU -> Bool :: *))
                         (GHC.Base.$fOrdMaybe_$cmax @ a_a6GjU v_B1)
                         `cast` (Sym (Data.Monoid.N:Last[0]) <a_a6GjU>_N
                                 ->_R Sym (Data.Monoid.N:Last[0]) <a_a6GjU>_N
                                 ->_R Sym (Data.Monoid.N:Last[0]) <a_a6GjU>_N
                                 :: (Maybe a_a6GjU -> Maybe a_a6GjU -> Maybe a_a6GjU :: *)
                                    ~R# (Last a_a6GjU -> Last a_a6GjU -> Last a_a6GjU :: *))
                         (GHC.Base.$fOrdMaybe_$cmin @ a_a6GjU v_B1)
                         `cast` (Sym (Data.Monoid.N:Last[0]) <a_a6GjU>_N
                                 ->_R Sym (Data.Monoid.N:Last[0]) <a_a6GjU>_N
                                 ->_R Sym (Data.Monoid.N:Last[0]) <a_a6GjU>_N
                                 :: (Maybe a_a6GjU -> Maybe a_a6GjU -> Maybe a_a6GjU :: *)
                                    ~R# (Last a_a6GjU -> Last a_a6GjU -> Last a_a6GjU :: *))]
Data.Monoid.$fOrdLast
  = \ (@ a_X6HjG) ($dOrd_X6HjI :: Ord a_X6HjG) ->
      GHC.Classes.C:Ord
        @ (Last a_X6HjG)
        (Data.Monoid.$fOrdLast_$cp1Ord @ a_X6HjG $dOrd_X6HjI)
        ((GHC.Base.$fOrdMaybe_$ccompare @ a_X6HjG $dOrd_X6HjI)
         `cast` (Sym (Data.Monoid.N:Last[0]) <a_X6HjG>_N
                 ->_R Sym (Data.Monoid.N:Last[0]) <a_X6HjG>_N
                 ->_R <Ordering>_R
                 :: (Maybe a_X6HjG -> Maybe a_X6HjG -> Ordering :: *)
                    ~R# (Last a_X6HjG -> Last a_X6HjG -> Ordering :: *)))
        ((GHC.Base.$fOrdMaybe_$c< @ a_X6HjG $dOrd_X6HjI)
         `cast` (Sym (Data.Monoid.N:Last[0]) <a_X6HjG>_N
                 ->_R Sym (Data.Monoid.N:Last[0]) <a_X6HjG>_N
                 ->_R <Bool>_R
                 :: (Maybe a_X6HjG -> Maybe a_X6HjG -> Bool :: *)
                    ~R# (Last a_X6HjG -> Last a_X6HjG -> Bool :: *)))
        ((GHC.Base.$fOrdMaybe_$c<= @ a_X6HjG $dOrd_X6HjI)
         `cast` (Sym (Data.Monoid.N:Last[0]) <a_X6HjG>_N
                 ->_R Sym (Data.Monoid.N:Last[0]) <a_X6HjG>_N
                 ->_R <Bool>_R
                 :: (Maybe a_X6HjG -> Maybe a_X6HjG -> Bool :: *)
                    ~R# (Last a_X6HjG -> Last a_X6HjG -> Bool :: *)))
        ((\ (a1_i6HCD :: Maybe a_X6HjG) (b_i6HCE :: Maybe a_X6HjG) ->
            GHC.Base.$fOrdMaybe_$c< @ a_X6HjG $dOrd_X6HjI b_i6HCE a1_i6HCD)
         `cast` (Sym (Data.Monoid.N:Last[0]) <a_X6HjG>_N
                 ->_R Sym (Data.Monoid.N:Last[0]) <a_X6HjG>_N
                 ->_R <Bool>_R
                 :: (Maybe a_X6HjG -> Maybe a_X6HjG -> Bool :: *)
                    ~R# (Last a_X6HjG -> Last a_X6HjG -> Bool :: *)))
        ((GHC.Base.$fOrdMaybe_$c>= @ a_X6HjG $dOrd_X6HjI)
         `cast` (Sym (Data.Monoid.N:Last[0]) <a_X6HjG>_N
                 ->_R Sym (Data.Monoid.N:Last[0]) <a_X6HjG>_N
                 ->_R <Bool>_R
                 :: (Maybe a_X6HjG -> Maybe a_X6HjG -> Bool :: *)
                    ~R# (Last a_X6HjG -> Last a_X6HjG -> Bool :: *)))
        ((GHC.Base.$fOrdMaybe_$cmax @ a_X6HjG $dOrd_X6HjI)
         `cast` (Sym (Data.Monoid.N:Last[0]) <a_X6HjG>_N
                 ->_R Sym (Data.Monoid.N:Last[0]) <a_X6HjG>_N
                 ->_R Sym (Data.Monoid.N:Last[0]) <a_X6HjG>_N
                 :: (Maybe a_X6HjG -> Maybe a_X6HjG -> Maybe a_X6HjG :: *)
                    ~R# (Last a_X6HjG -> Last a_X6HjG -> Last a_X6HjG :: *)))
        ((GHC.Base.$fOrdMaybe_$cmin @ a_X6HjG $dOrd_X6HjI)
         `cast` (Sym (Data.Monoid.N:Last[0]) <a_X6HjG>_N
                 ->_R Sym (Data.Monoid.N:Last[0]) <a_X6HjG>_N
                 ->_R Sym (Data.Monoid.N:Last[0]) <a_X6HjG>_N
                 :: (Maybe a_X6HjG -> Maybe a_X6HjG -> Maybe a_X6HjG :: *)
                    ~R# (Last a_X6HjG -> Last a_X6HjG -> Last a_X6HjG :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 31, joins: 0/0}
Data.Monoid.$fFunctorFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Functor First
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Functor TYPE: First
                          GHC.Base.$fApplicativeMaybe_$cfmap
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a -> b>_R
                                  ->_R Sym (Data.Monoid.N:First[0]) <a>_N
                                  ->_R Sym (Data.Monoid.N:First[0]) <b>_N
                                  :: (forall a b. (a -> b) -> Maybe a -> Maybe b :: *)
                                     ~R# (forall a b. (a -> b) -> First a -> First b :: *))
                          GHC.Base.$fFunctorMaybe_$c<$
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a>_R
                                  ->_R Sym (Data.Monoid.N:First[0]) <b>_N
                                  ->_R Sym (Data.Monoid.N:First[0]) <a>_N
                                  :: (forall a b. a -> Maybe b -> Maybe a :: *)
                                     ~R# (forall a b. a -> First b -> First a :: *))]
Data.Monoid.$fFunctorFirst
  = GHC.Base.C:Functor
      @ First
      (GHC.Base.$fApplicativeMaybe_$cfmap
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a -> b>_R
               ->_R Sym (Data.Monoid.N:First[0]) <a>_N
               ->_R Sym (Data.Monoid.N:First[0]) <b>_N
               :: (forall a b. (a -> b) -> Maybe a -> Maybe b :: *)
                  ~R# (forall a b. (a -> b) -> First a -> First b :: *)))
      (GHC.Base.$fFunctorMaybe_$c<$
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a>_R
               ->_R Sym (Data.Monoid.N:First[0]) <b>_N
               ->_R Sym (Data.Monoid.N:First[0]) <a>_N
               :: (forall a b. a -> Maybe b -> Maybe a :: *)
                  ~R# (forall a b. a -> First b -> First a :: *)))

-- RHS size: {terms: 7, types: 1, coercions: 84, joins: 0/0}
Data.Monoid.$fApplicativeFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Applicative First
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Applicative TYPE: First
                              Data.Monoid.$fFunctorFirst
                              GHC.Base.Just
                              `cast` (forall (a :: <*>_N).
                                      <a>_R ->_R Sym (Data.Monoid.N:First[0]) <a>_N
                                      :: (forall a. a -> Maybe a :: *)
                                         ~R# (forall a. a -> First a :: *))
                              GHC.Base.$fApplicativeMaybe_$c<*>
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      Sym (Data.Monoid.N:First[0]) <a -> b>_N
                                      ->_R Sym (Data.Monoid.N:First[0]) <a>_N
                                      ->_R Sym (Data.Monoid.N:First[0]) <b>_N
                                      :: (forall a b. Maybe (a -> b) -> Maybe a -> Maybe b :: *)
                                         ~R# (forall a b.
                                              First (a -> b) -> First a -> First b :: *))
                              GHC.Base.$fApplicativeMaybe_$cliftA2
                              `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                                      <a -> b -> c>_R
                                      ->_R Sym (Data.Monoid.N:First[0]) <a>_N
                                      ->_R Sym (Data.Monoid.N:First[0]) <b>_N
                                      ->_R Sym (Data.Monoid.N:First[0]) <c>_N
                                      :: (forall a b c.
                                          (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c :: *)
                                         ~R# (forall a b c.
                                              (a -> b -> c) -> First a -> First b -> First c :: *))
                              GHC.Base.$fApplicativeMaybe_$c*>
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      Sym (Data.Monoid.N:First[0]) <a>_N
                                      ->_R Sym (Data.Monoid.N:First[0]) <b>_N
                                      ->_R Sym (Data.Monoid.N:First[0]) <b>_N
                                      :: (forall a b. Maybe a -> Maybe b -> Maybe b :: *)
                                         ~R# (forall a b. First a -> First b -> First b :: *))
                              GHC.Base.$fApplicativeMaybe_$c<*
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      Sym (Data.Monoid.N:First[0]) <a>_N
                                      ->_R Sym (Data.Monoid.N:First[0]) <b>_N
                                      ->_R Sym (Data.Monoid.N:First[0]) <a>_N
                                      :: (forall a b. Maybe a -> Maybe b -> Maybe a :: *)
                                         ~R# (forall a b. First a -> First b -> First a :: *))]
Data.Monoid.$fApplicativeFirst
  = GHC.Base.C:Applicative
      @ First
      Data.Monoid.$fFunctorFirst
      (GHC.Base.Just
       `cast` (forall (a :: <*>_N).
               <a>_R ->_R Sym (Data.Monoid.N:First[0]) <a>_N
               :: (forall a. a -> Maybe a :: *)
                  ~R# (forall a. a -> First a :: *)))
      (GHC.Base.$fApplicativeMaybe_$c<*>
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               Sym (Data.Monoid.N:First[0]) <a -> b>_N
               ->_R Sym (Data.Monoid.N:First[0]) <a>_N
               ->_R Sym (Data.Monoid.N:First[0]) <b>_N
               :: (forall a b. Maybe (a -> b) -> Maybe a -> Maybe b :: *)
                  ~R# (forall a b. First (a -> b) -> First a -> First b :: *)))
      (GHC.Base.$fApplicativeMaybe_$cliftA2
       `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
               <a -> b -> c>_R
               ->_R Sym (Data.Monoid.N:First[0]) <a>_N
               ->_R Sym (Data.Monoid.N:First[0]) <b>_N
               ->_R Sym (Data.Monoid.N:First[0]) <c>_N
               :: (forall a b c.
                   (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c :: *)
                  ~R# (forall a b c.
                       (a -> b -> c) -> First a -> First b -> First c :: *)))
      (GHC.Base.$fApplicativeMaybe_$c*>
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               Sym (Data.Monoid.N:First[0]) <a>_N
               ->_R Sym (Data.Monoid.N:First[0]) <b>_N
               ->_R Sym (Data.Monoid.N:First[0]) <b>_N
               :: (forall a b. Maybe a -> Maybe b -> Maybe b :: *)
                  ~R# (forall a b. First a -> First b -> First b :: *)))
      (GHC.Base.$fApplicativeMaybe_$c<*
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               Sym (Data.Monoid.N:First[0]) <a>_N
               ->_R Sym (Data.Monoid.N:First[0]) <b>_N
               ->_R Sym (Data.Monoid.N:First[0]) <a>_N
               :: (forall a b. Maybe a -> Maybe b -> Maybe a :: *)
                  ~R# (forall a b. First a -> First b -> First a :: *)))

-- RHS size: {terms: 6, types: 1, coercions: 53, joins: 0/0}
Data.Monoid.$fMonadFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Monad First
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Monad TYPE: First
                        Data.Monoid.$fApplicativeFirst
                        GHC.Base.$fMonadMaybe_$c>>=
                        `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                Sym (Data.Monoid.N:First[0]) <a>_N
                                ->_R (<a>_R ->_R Sym (Data.Monoid.N:First[0]) <b>_N)
                                ->_R Sym (Data.Monoid.N:First[0]) <b>_N
                                :: (forall a b. Maybe a -> (a -> Maybe b) -> Maybe b :: *)
                                   ~R# (forall a b. First a -> (a -> First b) -> First b :: *))
                        GHC.Base.$fApplicativeMaybe_$c*>
                        `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                Sym (Data.Monoid.N:First[0]) <a>_N
                                ->_R Sym (Data.Monoid.N:First[0]) <b>_N
                                ->_R Sym (Data.Monoid.N:First[0]) <b>_N
                                :: (forall a b. Maybe a -> Maybe b -> Maybe b :: *)
                                   ~R# (forall a b. First a -> First b -> First b :: *))
                        GHC.Base.Just
                        `cast` (forall (a :: <*>_N).
                                <a>_R ->_R Sym (Data.Monoid.N:First[0]) <a>_N
                                :: (forall a. a -> Maybe a :: *) ~R# (forall a. a -> First a :: *))
                        GHC.Base.$fMonadMaybe_$cfail
                        `cast` (forall (a :: <*>_N).
                                <[Char]>_R ->_R Sym (Data.Monoid.N:First[0]) <a>_N
                                :: (forall a. [Char] -> Maybe a :: *)
                                   ~R# (forall a. [Char] -> First a :: *))]
Data.Monoid.$fMonadFirst
  = GHC.Base.C:Monad
      @ First
      Data.Monoid.$fApplicativeFirst
      (GHC.Base.$fMonadMaybe_$c>>=
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               Sym (Data.Monoid.N:First[0]) <a>_N
               ->_R (<a>_R ->_R Sym (Data.Monoid.N:First[0]) <b>_N)
               ->_R Sym (Data.Monoid.N:First[0]) <b>_N
               :: (forall a b. Maybe a -> (a -> Maybe b) -> Maybe b :: *)
                  ~R# (forall a b. First a -> (a -> First b) -> First b :: *)))
      (GHC.Base.$fApplicativeMaybe_$c*>
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               Sym (Data.Monoid.N:First[0]) <a>_N
               ->_R Sym (Data.Monoid.N:First[0]) <b>_N
               ->_R Sym (Data.Monoid.N:First[0]) <b>_N
               :: (forall a b. Maybe a -> Maybe b -> Maybe b :: *)
                  ~R# (forall a b. First a -> First b -> First b :: *)))
      (GHC.Base.Just
       `cast` (forall (a :: <*>_N).
               <a>_R ->_R Sym (Data.Monoid.N:First[0]) <a>_N
               :: (forall a. a -> Maybe a :: *)
                  ~R# (forall a. a -> First a :: *)))
      (GHC.Base.$fMonadMaybe_$cfail
       `cast` (forall (a :: <*>_N).
               <[Char]>_R ->_R Sym (Data.Monoid.N:First[0]) <a>_N
               :: (forall a. [Char] -> Maybe a :: *)
                  ~R# (forall a. [Char] -> First a :: *)))

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
Data.Monoid.$fGeneric1First1
  :: forall a. Rep1 First a -> Rep1 First a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6HaH) (ds_d6HAD [Occ=Once] :: Rep1 First a_a6HaH) ->
                 ds_d6HAD}]
Data.Monoid.$fGeneric1First1
  = \ (@ a_a6HaH) (ds_d6HAD :: Rep1 First a_a6HaH) -> ds_d6HAD

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Data.Monoid.$fGeneric1First2 :: forall a. First a -> First a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6Hae) (x_a6H4z [Occ=Once] :: First a_a6Hae) ->
                 x_a6H4z}]
Data.Monoid.$fGeneric1First2
  = \ (@ a_a6Hae) (x_a6H4z :: First a_a6Hae) -> x_a6H4z

-- RHS size: {terms: 3, types: 3, coercions: 184, joins: 0/0}
Data.Monoid.$fGeneric1First [InlPrag=NOUSERINLINE CONLIKE]
  :: Generic1 First
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Generics.C:Generic1 TYPE: *
                               TYPE: First
                               Data.Monoid.$fGeneric1First2
                               `cast` (forall (a :: <*>_N).
                                       <First a>_R
                                       ->_R (Sym (GHC.Generics.N:Rec1[0]
                                                      <*>_N
                                                      (Sym (Data.Monoid.N:First[0]))) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                  <*>_N
                                                                                                  <S>_P
                                                                                                  <'MetaSel
                                                                                                     ('Just
                                                                                                        "getFirst")
                                                                                                     'NoSourceUnpackedness
                                                                                                     'NoSourceStrictness
                                                                                                     'DecidedLazy>_P
                                                                                                  <Rec1
                                                                                                     Maybe>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                           <*>_N
                                                                                                                           <C>_P
                                                                                                                           <'MetaCons
                                                                                                                              "First"
                                                                                                                              'PrefixI
                                                                                                                              'True>_P
                                                                                                                           <M1
                                                                                                                              S
                                                                                                                              ('MetaSel
                                                                                                                                 ('Just
                                                                                                                                    "getFirst")
                                                                                                                                 'NoSourceUnpackedness
                                                                                                                                 'NoSourceStrictness
                                                                                                                                 'DecidedLazy)
                                                                                                                              (Rec1
                                                                                                                                 Maybe)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                        <*>_N
                                                                                                                                                        <D>_P
                                                                                                                                                        <'MetaData
                                                                                                                                                           "First"
                                                                                                                                                           "Data.Monoid"
                                                                                                                                                           "base"
                                                                                                                                                           'True>_P
                                                                                                                                                        <M1
                                                                                                                                                           C
                                                                                                                                                           ('MetaCons
                                                                                                                                                              "First"
                                                                                                                                                              'PrefixI
                                                                                                                                                              'True)
                                                                                                                                                           (M1
                                                                                                                                                              S
                                                                                                                                                              ('MetaSel
                                                                                                                                                                 ('Just
                                                                                                                                                                    "getFirst")
                                                                                                                                                                 'NoSourceUnpackedness
                                                                                                                                                                 'NoSourceStrictness
                                                                                                                                                                 'DecidedLazy)
                                                                                                                                                              (Rec1
                                                                                                                                                                 Maybe))>_R) ; Sub (Sym (Data.Monoid.Rep1_First[0])))))) <a>_N
                                       :: (forall a. First a -> First a :: *)
                                          ~R# (forall a. First a -> Rep1 First a :: *))
                               Data.Monoid.$fGeneric1First1
                               `cast` (forall (a :: <*>_N).
                                       <Rep1 First a>_R
                                       ->_R (Sub (Data.Monoid.Rep1_First[0]) ; (GHC.Generics.N:M1[0]
                                                                                    <*>_N
                                                                                    <D>_P
                                                                                    <'MetaData
                                                                                       "First"
                                                                                       "Data.Monoid"
                                                                                       "base"
                                                                                       'True>_P
                                                                                    <M1
                                                                                       C
                                                                                       ('MetaCons
                                                                                          "First"
                                                                                          'PrefixI
                                                                                          'True)
                                                                                       (M1
                                                                                          S
                                                                                          ('MetaSel
                                                                                             ('Just
                                                                                                "getFirst")
                                                                                             'NoSourceUnpackedness
                                                                                             'NoSourceStrictness
                                                                                             'DecidedLazy)
                                                                                          (Rec1
                                                                                             Maybe))>_R ; (GHC.Generics.N:M1[0]
                                                                                                               <*>_N
                                                                                                               <C>_P
                                                                                                               <'MetaCons
                                                                                                                  "First"
                                                                                                                  'PrefixI
                                                                                                                  'True>_P
                                                                                                               <M1
                                                                                                                  S
                                                                                                                  ('MetaSel
                                                                                                                     ('Just
                                                                                                                        "getFirst")
                                                                                                                     'NoSourceUnpackedness
                                                                                                                     'NoSourceStrictness
                                                                                                                     'DecidedLazy)
                                                                                                                  (Rec1
                                                                                                                     Maybe)>_R ; (GHC.Generics.N:M1[0]
                                                                                                                                      <*>_N
                                                                                                                                      <S>_P
                                                                                                                                      <'MetaSel
                                                                                                                                         ('Just
                                                                                                                                            "getFirst")
                                                                                                                                         'NoSourceUnpackedness
                                                                                                                                         'NoSourceStrictness
                                                                                                                                         'DecidedLazy>_P
                                                                                                                                      <Rec1
                                                                                                                                         Maybe>_R ; GHC.Generics.N:Rec1[0]
                                                                                                                                                        <*>_N
                                                                                                                                                        (Sym (Data.Monoid.N:First[0])))))) <a>_N
                                       :: (forall a. Rep1 First a -> Rep1 First a :: *)
                                          ~R# (forall a. Rep1 First a -> First a :: *))]
Data.Monoid.$fGeneric1First
  = GHC.Generics.C:Generic1
      @ *
      @ First
      (Data.Monoid.$fGeneric1First2
       `cast` (forall (a :: <*>_N).
               <First a>_R
               ->_R (Sym (GHC.Generics.N:Rec1[0]
                              <*>_N (Sym (Data.Monoid.N:First[0]))) ; (Sym (GHC.Generics.N:M1[0]
                                                                                <*>_N
                                                                                <S>_P
                                                                                <'MetaSel
                                                                                   ('Just
                                                                                      "getFirst")
                                                                                   'NoSourceUnpackedness
                                                                                   'NoSourceStrictness
                                                                                   'DecidedLazy>_P
                                                                                <Rec1
                                                                                   Maybe>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                         <*>_N
                                                                                                         <C>_P
                                                                                                         <'MetaCons
                                                                                                            "First"
                                                                                                            'PrefixI
                                                                                                            'True>_P
                                                                                                         <M1
                                                                                                            S
                                                                                                            ('MetaSel
                                                                                                               ('Just
                                                                                                                  "getFirst")
                                                                                                               'NoSourceUnpackedness
                                                                                                               'NoSourceStrictness
                                                                                                               'DecidedLazy)
                                                                                                            (Rec1
                                                                                                               Maybe)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                      <*>_N
                                                                                                                                      <D>_P
                                                                                                                                      <'MetaData
                                                                                                                                         "First"
                                                                                                                                         "Data.Monoid"
                                                                                                                                         "base"
                                                                                                                                         'True>_P
                                                                                                                                      <M1
                                                                                                                                         C
                                                                                                                                         ('MetaCons
                                                                                                                                            "First"
                                                                                                                                            'PrefixI
                                                                                                                                            'True)
                                                                                                                                         (M1
                                                                                                                                            S
                                                                                                                                            ('MetaSel
                                                                                                                                               ('Just
                                                                                                                                                  "getFirst")
                                                                                                                                               'NoSourceUnpackedness
                                                                                                                                               'NoSourceStrictness
                                                                                                                                               'DecidedLazy)
                                                                                                                                            (Rec1
                                                                                                                                               Maybe))>_R) ; Sub (Sym (Data.Monoid.Rep1_First[0])))))) <a>_N
               :: (forall a. First a -> First a :: *)
                  ~R# (forall a. First a -> Rep1 First a :: *)))
      (Data.Monoid.$fGeneric1First1
       `cast` (forall (a :: <*>_N).
               <Rep1 First a>_R
               ->_R (Sub (Data.Monoid.Rep1_First[0]) ; (GHC.Generics.N:M1[0]
                                                            <*>_N
                                                            <D>_P
                                                            <'MetaData
                                                               "First" "Data.Monoid" "base" 'True>_P
                                                            <M1
                                                               C
                                                               ('MetaCons "First" 'PrefixI 'True)
                                                               (M1
                                                                  S
                                                                  ('MetaSel
                                                                     ('Just "getFirst")
                                                                     'NoSourceUnpackedness
                                                                     'NoSourceStrictness
                                                                     'DecidedLazy)
                                                                  (Rec1
                                                                     Maybe))>_R ; (GHC.Generics.N:M1[0]
                                                                                       <*>_N
                                                                                       <C>_P
                                                                                       <'MetaCons
                                                                                          "First"
                                                                                          'PrefixI
                                                                                          'True>_P
                                                                                       <M1
                                                                                          S
                                                                                          ('MetaSel
                                                                                             ('Just
                                                                                                "getFirst")
                                                                                             'NoSourceUnpackedness
                                                                                             'NoSourceStrictness
                                                                                             'DecidedLazy)
                                                                                          (Rec1
                                                                                             Maybe)>_R ; (GHC.Generics.N:M1[0]
                                                                                                              <*>_N
                                                                                                              <S>_P
                                                                                                              <'MetaSel
                                                                                                                 ('Just
                                                                                                                    "getFirst")
                                                                                                                 'NoSourceUnpackedness
                                                                                                                 'NoSourceStrictness
                                                                                                                 'DecidedLazy>_P
                                                                                                              <Rec1
                                                                                                                 Maybe>_R ; GHC.Generics.N:Rec1[0]
                                                                                                                                <*>_N
                                                                                                                                (Sym (Data.Monoid.N:First[0])))))) <a>_N
               :: (forall a. Rep1 First a -> Rep1 First a :: *)
                  ~R# (forall a. Rep1 First a -> First a :: *)))

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
Data.Monoid.$fGenericFirst1
  :: forall a x. Rep (First a) x -> Rep (First a) x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a6H98)
                 (@ x_a6H9I)
                 (ds_d6HAx [Occ=Once] :: Rep (First a_a6H98) x_a6H9I) ->
                 ds_d6HAx}]
Data.Monoid.$fGenericFirst1
  = \ (@ a_a6H98)
      (@ x_a6H9I)
      (ds_d6HAx :: Rep (First a_a6H98) x_a6H9I) ->
      ds_d6HAx

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Data.Monoid.$fGenericFirst2 :: forall a x. First a -> First a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_X6HcD)
                 (@ x_a6H9d)
                 (x1_a6H4v [Occ=Once] :: First a_X6HcD) ->
                 x1_a6H4v}]
Data.Monoid.$fGenericFirst2
  = \ (@ a_X6HcD) (@ x_a6H9d) (x1_a6H4v :: First a_X6HcD) -> x1_a6H4v

-- RHS size: {terms: 4, types: 6, coercions: 206, joins: 0/0}
Data.Monoid.$fGenericFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Generic (First a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_a6GjV) ->
       GHC.Generics.C:Generic TYPE: First a_a6GjV
                              (Data.Monoid.$fGenericFirst2 @ a_a6GjV)
                              `cast` (forall (x :: <*>_N).
                                      <First a_a6GjV>_R
                                      ->_R Data.Monoid.N:First[0] <a_a6GjV>_N ; (Sym (GHC.Generics.N:K1[0]
                                                                                          <*>_N
                                                                                          <R>_P
                                                                                          <Maybe
                                                                                             a_a6GjV>_R
                                                                                          <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                             <*>_N
                                                                                                             <S>_P
                                                                                                             <'MetaSel
                                                                                                                ('Just
                                                                                                                   "getFirst")
                                                                                                                'NoSourceUnpackedness
                                                                                                                'NoSourceStrictness
                                                                                                                'DecidedLazy>_P
                                                                                                             <K1
                                                                                                                R
                                                                                                                (Maybe
                                                                                                                   a_a6GjV)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                            <*>_N
                                                                                                                                            <C>_P
                                                                                                                                            <'MetaCons
                                                                                                                                               "First"
                                                                                                                                               'PrefixI
                                                                                                                                               'True>_P
                                                                                                                                            <M1
                                                                                                                                               S
                                                                                                                                               ('MetaSel
                                                                                                                                                  ('Just
                                                                                                                                                     "getFirst")
                                                                                                                                                  'NoSourceUnpackedness
                                                                                                                                                  'NoSourceStrictness
                                                                                                                                                  'DecidedLazy)
                                                                                                                                               (K1
                                                                                                                                                  R
                                                                                                                                                  (Maybe
                                                                                                                                                     a_a6GjV))>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                                               <*>_N
                                                                                                                                                                               <D>_P
                                                                                                                                                                               <'MetaData
                                                                                                                                                                                  "First"
                                                                                                                                                                                  "Data.Monoid"
                                                                                                                                                                                  "base"
                                                                                                                                                                                  'True>_P
                                                                                                                                                                               <M1
                                                                                                                                                                                  C
                                                                                                                                                                                  ('MetaCons
                                                                                                                                                                                     "First"
                                                                                                                                                                                     'PrefixI
                                                                                                                                                                                     'True)
                                                                                                                                                                                  (M1
                                                                                                                                                                                     S
                                                                                                                                                                                     ('MetaSel
                                                                                                                                                                                        ('Just
                                                                                                                                                                                           "getFirst")
                                                                                                                                                                                        'NoSourceUnpackedness
                                                                                                                                                                                        'NoSourceStrictness
                                                                                                                                                                                        'DecidedLazy)
                                                                                                                                                                                     (K1
                                                                                                                                                                                        R
                                                                                                                                                                                        (Maybe
                                                                                                                                                                                           a_a6GjV)))>_R) ; Sub (Sym (Data.Monoid.Rep_First[0]
                                                                                                                                                                                                                          <a_a6GjV>_N))))) <x>_N)
                                      :: (forall x. First a_a6GjV -> First a_a6GjV :: *)
                                         ~R# (forall x.
                                              First a_a6GjV -> Rep (First a_a6GjV) x :: *))
                              (Data.Monoid.$fGenericFirst1 @ a_a6GjV)
                              `cast` (forall (x :: <*>_N).
                                      <Rep (First a_a6GjV) x>_R
                                      ->_R (Sub (Data.Monoid.Rep_First[0]
                                                     <a_a6GjV>_N) ; (GHC.Generics.N:M1[0]
                                                                         <*>_N
                                                                         <D>_P
                                                                         <'MetaData
                                                                            "First"
                                                                            "Data.Monoid"
                                                                            "base"
                                                                            'True>_P
                                                                         <M1
                                                                            C
                                                                            ('MetaCons
                                                                               "First"
                                                                               'PrefixI
                                                                               'True)
                                                                            (M1
                                                                               S
                                                                               ('MetaSel
                                                                                  ('Just "getFirst")
                                                                                  'NoSourceUnpackedness
                                                                                  'NoSourceStrictness
                                                                                  'DecidedLazy)
                                                                               (K1
                                                                                  R
                                                                                  (Maybe
                                                                                     a_a6GjV)))>_R ; (GHC.Generics.N:M1[0]
                                                                                                          <*>_N
                                                                                                          <C>_P
                                                                                                          <'MetaCons
                                                                                                             "First"
                                                                                                             'PrefixI
                                                                                                             'True>_P
                                                                                                          <M1
                                                                                                             S
                                                                                                             ('MetaSel
                                                                                                                ('Just
                                                                                                                   "getFirst")
                                                                                                                'NoSourceUnpackedness
                                                                                                                'NoSourceStrictness
                                                                                                                'DecidedLazy)
                                                                                                             (K1
                                                                                                                R
                                                                                                                (Maybe
                                                                                                                   a_a6GjV))>_R ; GHC.Generics.N:M1[0]
                                                                                                                                      <*>_N
                                                                                                                                      <S>_P
                                                                                                                                      <'MetaSel
                                                                                                                                         ('Just
                                                                                                                                            "getFirst")
                                                                                                                                         'NoSourceUnpackedness
                                                                                                                                         'NoSourceStrictness
                                                                                                                                         'DecidedLazy>_P
                                                                                                                                      <K1
                                                                                                                                         R
                                                                                                                                         (Maybe
                                                                                                                                            a_a6GjV)>_R))) <x>_N ; (GHC.Generics.N:K1[0]
                                                                                                                                                                        <*>_N
                                                                                                                                                                        <R>_P
                                                                                                                                                                        <Maybe
                                                                                                                                                                           a_a6GjV>_R
                                                                                                                                                                        <x>_P ; Sym (Data.Monoid.N:First[0]) <a_a6GjV>_N)
                                      :: (forall x.
                                          Rep (First a_a6GjV) x -> Rep (First a_a6GjV) x :: *)
                                         ~R# (forall x.
                                              Rep (First a_a6GjV) x -> First a_a6GjV :: *))]
Data.Monoid.$fGenericFirst
  = \ (@ a_X6HcI) ->
      GHC.Generics.C:Generic
        @ (First a_X6HcI)
        ((Data.Monoid.$fGenericFirst2 @ a_X6HcI)
         `cast` (forall (x :: <*>_N).
                 <First a_X6HcI>_R
                 ->_R Data.Monoid.N:First[0] <a_X6HcI>_N ; (Sym (GHC.Generics.N:K1[0]
                                                                     <*>_N
                                                                     <R>_P
                                                                     <Maybe a_X6HcI>_R
                                                                     <x>_P) ; (Sym (GHC.Generics.N:M1[0]
                                                                                        <*>_N
                                                                                        <S>_P
                                                                                        <'MetaSel
                                                                                           ('Just
                                                                                              "getFirst")
                                                                                           'NoSourceUnpackedness
                                                                                           'NoSourceStrictness
                                                                                           'DecidedLazy>_P
                                                                                        <K1
                                                                                           R
                                                                                           (Maybe
                                                                                              a_X6HcI)>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                       <*>_N
                                                                                                                       <C>_P
                                                                                                                       <'MetaCons
                                                                                                                          "First"
                                                                                                                          'PrefixI
                                                                                                                          'True>_P
                                                                                                                       <M1
                                                                                                                          S
                                                                                                                          ('MetaSel
                                                                                                                             ('Just
                                                                                                                                "getFirst")
                                                                                                                             'NoSourceUnpackedness
                                                                                                                             'NoSourceStrictness
                                                                                                                             'DecidedLazy)
                                                                                                                          (K1
                                                                                                                             R
                                                                                                                             (Maybe
                                                                                                                                a_X6HcI))>_R) ; (Sym (GHC.Generics.N:M1[0]
                                                                                                                                                          <*>_N
                                                                                                                                                          <D>_P
                                                                                                                                                          <'MetaData
                                                                                                                                                             "First"
                                                                                                                                                             "Data.Monoid"
                                                                                                                                                             "base"
                                                                                                                                                             'True>_P
                                                                                                                                                          <M1
                                                                                                                                                             C
                                                                                                                                                             ('MetaCons
                                                                                                                                                                "First"
                                                                                                                                                                'PrefixI
                                                                                                                                                                'True)
                                                                                                                                                             (M1
                                                                                                                                                                S
                                                                                                                                                                ('MetaSel
                                                                                                                                                                   ('Just
                                                                                                                                                                      "getFirst")
                                                                                                                                                                   'NoSourceUnpackedness
                                                                                                                                                                   'NoSourceStrictness
                                                                                                                                                                   'DecidedLazy)
                                                                                                                                                                (K1
                                                                                                                                                                   R
                                                                                                                                                                   (Maybe
                                                                                                                                                                      a_X6HcI)))>_R) ; Sub (Sym (Data.Monoid.Rep_First[0]
                                                                                                                                                                                                     <a_X6HcI>_N))))) <x>_N)
                 :: (forall x. First a_X6HcI -> First a_X6HcI :: *)
                    ~R# (forall x. First a_X6HcI -> Rep (First a_X6HcI) x :: *)))
        ((Data.Monoid.$fGenericFirst1 @ a_X6HcI)
         `cast` (forall (x :: <*>_N).
                 <Rep (First a_X6HcI) x>_R
                 ->_R (Sub (Data.Monoid.Rep_First[0]
                                <a_X6HcI>_N) ; (GHC.Generics.N:M1[0]
                                                    <*>_N
                                                    <D>_P
                                                    <'MetaData "First" "Data.Monoid" "base" 'True>_P
                                                    <M1
                                                       C
                                                       ('MetaCons "First" 'PrefixI 'True)
                                                       (M1
                                                          S
                                                          ('MetaSel
                                                             ('Just "getFirst")
                                                             'NoSourceUnpackedness
                                                             'NoSourceStrictness
                                                             'DecidedLazy)
                                                          (K1
                                                             R
                                                             (Maybe
                                                                a_X6HcI)))>_R ; (GHC.Generics.N:M1[0]
                                                                                     <*>_N
                                                                                     <C>_P
                                                                                     <'MetaCons
                                                                                        "First"
                                                                                        'PrefixI
                                                                                        'True>_P
                                                                                     <M1
                                                                                        S
                                                                                        ('MetaSel
                                                                                           ('Just
                                                                                              "getFirst")
                                                                                           'NoSourceUnpackedness
                                                                                           'NoSourceStrictness
                                                                                           'DecidedLazy)
                                                                                        (K1
                                                                                           R
                                                                                           (Maybe
                                                                                              a_X6HcI))>_R ; GHC.Generics.N:M1[0]
                                                                                                                 <*>_N
                                                                                                                 <S>_P
                                                                                                                 <'MetaSel
                                                                                                                    ('Just
                                                                                                                       "getFirst")
                                                                                                                    'NoSourceUnpackedness
                                                                                                                    'NoSourceStrictness
                                                                                                                    'DecidedLazy>_P
                                                                                                                 <K1
                                                                                                                    R
                                                                                                                    (Maybe
                                                                                                                       a_X6HcI)>_R))) <x>_N ; (GHC.Generics.N:K1[0]
                                                                                                                                                   <*>_N
                                                                                                                                                   <R>_P
                                                                                                                                                   <Maybe
                                                                                                                                                      a_X6HcI>_R
                                                                                                                                                   <x>_P ; Sym (Data.Monoid.N:First[0]) <a_X6HcI>_N)
                 :: (forall x. Rep (First a_X6HcI) x -> Rep (First a_X6HcI) x :: *)
                    ~R# (forall x. Rep (First a_X6HcI) x -> First a_X6HcI :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$fShowFirst3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Monoid.$fShowFirst3 = "First {"#

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$fShowFirst2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Monoid.$fShowFirst2 = "getFirst = "#

-- RHS size: {terms: 37, types: 15, coercions: 2, joins: 0/1}
Data.Monoid.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => Int# -> First a -> ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 331 120}]
Data.Monoid.$w$cshowsPrec
  = \ (@ a_s6HX7)
      (w_s6HX8 :: Show a_s6HX7)
      (ww_s6HXd :: Int#)
      (w1_s6HXa :: First a_s6HX7) ->
      let {
        f_s6HQw [Dmd=<L,C(U)>] :: String -> String
        [LclId]
        f_s6HQw
          = GHC.Show.$fShowMaybe_$cshowsPrec
              @ a_s6HX7
              w_s6HX8
              Data.Monoid.$fShowFirst1
              (w1_s6HXa
               `cast` (Data.Monoid.N:First[0] <a_s6HX7>_N
                       :: (First a_s6HX7 :: *) ~R# (Maybe a_s6HX7 :: *))) } in
      case >=# ww_s6HXd 11# of {
        __DEFAULT ->
          \ (x_X6HEh :: String) ->
            unpackAppendCString#
              Data.Monoid.$fShowFirst3
              (unpackAppendCString#
                 Data.Monoid.$fShowFirst2
                 (f_s6HQw (unpackAppendCString# Data.Monoid.$fReadFirst4 x_X6HEh)));
        1# ->
          \ (x_i6HAc :: String) ->
            GHC.Types.:
              @ Char
              GHC.Show.$fShow(,)4
              (unpackAppendCString#
                 Data.Monoid.$fShowFirst3
                 (unpackAppendCString#
                    Data.Monoid.$fShowFirst2
                    (f_s6HQw
                       (unpackAppendCString#
                          Data.Monoid.$fReadFirst4
                          (GHC.Types.: @ Char GHC.Show.$fShow(,)2 x_i6HAc)))))
      }

-- RHS size: {terms: 11, types: 10, coercions: 0, joins: 0/0}
Data.Monoid.$fShowFirst_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a. Show a => Int -> First a -> ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6HX7)
                 (w_s6HX8 [Occ=Once] :: Show a_s6HX7)
                 (w1_s6HX9 [Occ=Once!] :: Int)
                 (w2_s6HXa [Occ=Once] :: First a_s6HX7) ->
                 case w1_s6HX9 of { I# ww1_s6HXd [Occ=Once] ->
                 Data.Monoid.$w$cshowsPrec @ a_s6HX7 w_s6HX8 ww1_s6HXd w2_s6HXa
                 }}]
Data.Monoid.$fShowFirst_$cshowsPrec
  = \ (@ a_s6HX7)
      (w_s6HX8 :: Show a_s6HX7)
      (w1_s6HX9 :: Int)
      (w2_s6HXa :: First a_s6HX7) ->
      case w1_s6HX9 of { I# ww1_s6HXd ->
      Data.Monoid.$w$cshowsPrec @ a_s6HX7 w_s6HX8 ww1_s6HXd w2_s6HXa
      }

-- RHS size: {terms: 19, types: 11, coercions: 2, joins: 0/0}
Data.Monoid.$fShowFirst_$cshow
  :: forall a. Show a => First a -> String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30] 160 0}]
Data.Monoid.$fShowFirst_$cshow
  = \ (@ a_a6H8s)
      ($dShow_a6H8t :: Show a_a6H8s)
      (x_i6HAp :: First a_a6H8s) ->
      unpackAppendCString#
        Data.Monoid.$fShowFirst3
        (unpackAppendCString#
           Data.Monoid.$fShowFirst2
           (case x_i6HAp
                 `cast` (Data.Monoid.N:First[0] <a_a6H8s>_N
                         :: (First a_a6H8s :: *) ~R# (Maybe a_a6H8s :: *))
            of {
              Nothing -> Data.Monoid.$fShowFirst4;
              Just b1_i6HHj ->
                ++
                  @ Char
                  GHC.Show.$fShowMaybe1
                  (showsPrec
                     @ a_a6H8s $dShow_a6H8t appPrec1 b1_i6HHj Data.Monoid.$fReadFirst3)
            }))

-- RHS size: {terms: 12, types: 13, coercions: 0, joins: 0/0}
Data.Monoid.$fShowFirst_$cshowList
  :: forall a. Show a => [First a] -> ShowS
[GblId,
 Arity=3,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a6H8s)
                 ($dShow_a6H8t [Occ=Once] :: Show a_a6H8s)
                 (ls_i6HAs [Occ=Once] :: [First a_a6H8s])
                 (s_i6HAt [Occ=Once] :: String) ->
                 showList__
                   @ (First a_a6H8s)
                   (Data.Monoid.$fShowFirst_$cshowsPrec
                      @ a_a6H8s $dShow_a6H8t Data.Monoid.$fShowFirst1)
                   ls_i6HAs
                   s_i6HAt}]
Data.Monoid.$fShowFirst_$cshowList
  = \ (@ a_a6H8s)
      ($dShow_a6H8t :: Show a_a6H8s)
      (ls_i6HAs :: [First a_a6H8s])
      (s_i6HAt :: String) ->
      showList__
        @ (First a_a6H8s)
        (\ (w_s6HXa :: First a_a6H8s) ->
           Data.Monoid.$w$cshowsPrec @ a_a6H8s $dShow_a6H8t 0# w_s6HXa)
        ls_i6HAs
        s_i6HAt

-- RHS size: {terms: 9, types: 9, coercions: 0, joins: 0/0}
Data.Monoid.$fShowFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Show a => Show (First a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(C1(C(U))),A,A)>m,
 Unf=DFun: \ (@ a_a6GjV) (v_B1 :: Show a_a6GjV) ->
       GHC.Show.C:Show TYPE: First a_a6GjV
                       Data.Monoid.$fShowFirst_$cshowsPrec @ a_a6GjV v_B1
                       Data.Monoid.$fShowFirst_$cshow @ a_a6GjV v_B1
                       Data.Monoid.$fShowFirst_$cshowList @ a_a6GjV v_B1]
Data.Monoid.$fShowFirst
  = \ (@ a_a6H8s) ($dShow_a6H8t :: Show a_a6H8s) ->
      GHC.Show.C:Show
        @ (First a_a6H8s)
        (Data.Monoid.$fShowFirst_$cshowsPrec @ a_a6H8s $dShow_a6H8t)
        (Data.Monoid.$fShowFirst_$cshow @ a_a6H8s $dShow_a6H8t)
        (Data.Monoid.$fShowFirst_$cshowList @ a_a6H8s $dShow_a6H8t)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$fReadFirst11 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Monoid.$fReadFirst11 = "First"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$fReadFirst10 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Monoid.$fReadFirst10
  = unpackCString# Data.Monoid.$fReadFirst11

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$fReadFirst_lexeme1 :: Text.Read.Lex.Lexeme
[GblId,
 Str=m4,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Monoid.$fReadFirst_lexeme1
  = Text.Read.Lex.Ident Data.Monoid.$fReadFirst10

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$fReadFirst7 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Monoid.$fReadFirst7 = "getFirst"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$fReadFirst6 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Monoid.$fReadFirst6 = unpackCString# Data.Monoid.$fReadFirst7

-- RHS size: {terms: 57, types: 81, coercions: 31, joins: 0/1}
Data.Monoid.$fReadFirst1
  :: forall a.
     Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (First a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0 0] 421 0}]
Data.Monoid.$fReadFirst1
  = \ (@ a_a6H7b)
      ($dRead_a6H7c :: Read a_a6H7b)
      (eta_B2 :: Text.ParserCombinators.ReadPrec.Prec)
      (@ b_i6HzL)
      (eta1_B1
         :: First a_a6H7b -> Text.ParserCombinators.ReadP.P b_i6HzL) ->
      GHC.Read.list3
        @ (First a_a6H7b)
        (let {
           ds_s6HQj [Dmd=<L,C(C1(U))>]
             :: Text.ParserCombinators.ReadPrec.Prec
                -> forall b1.
                   (Maybe a_a6H7b -> Text.ParserCombinators.ReadP.P b1)
                   -> Text.ParserCombinators.ReadP.P b1
           [LclId,
            Arity=2,
            Str=<L,A><L,U>,
            Unf=Unf{Src=InlineStable, TopLvl=False, Value=True, ConLike=True,
                    WorkFree=True, Expandable=True,
                    Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
                    Tmpl= \ _ [Occ=Dead]
                            (@ b1_i6HCr)
                            (eta2_X7 [Occ=Once]
                               :: Maybe a_a6H7b -> Text.ParserCombinators.ReadP.P b1_i6HCr) ->
                            GHC.Read.$fReadMaybe1
                              @ a_a6H7b
                              $dRead_a6H7c
                              Text.ParserCombinators.ReadPrec.minPrec
                              @ b1_i6HCr
                              eta2_X7}]
           ds_s6HQj
             = \ _ [Occ=Dead]
                 (@ b1_i6HCr)
                 (eta2_X7 [OS=OneShot]
                    :: Maybe a_a6H7b -> Text.ParserCombinators.ReadP.P b1_i6HCr) ->
                 GHC.Read.$fReadMaybe1
                   @ a_a6H7b
                   $dRead_a6H7c
                   Text.ParserCombinators.ReadPrec.minPrec
                   @ b1_i6HCr
                   eta2_X7 } in
         (\ (c_i6HJ4 :: Text.ParserCombinators.ReadPrec.Prec)
            (@ b1_i6HIg)
            (eta2_X2v
               :: First a_a6H7b -> Text.ParserCombinators.ReadP.P b1_i6HIg) ->
            case c_i6HJ4 of { I# x_i6HJ7 ->
            case <=# x_i6HJ7 11# of {
              __DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1_i6HIg;
              1# ->
                case Text.Read.Lex.$wexpect
                       Data.Monoid.$fReadFirst_lexeme1
                       @ b1_i6HIg
                       (\ _ [Occ=Dead, OS=OneShot] ->
                          case Text.Read.Lex.$wexpect
                                 Data.Monoid.$fReadFirst_lexeme
                                 @ b1_i6HIg
                                 (\ _ [Occ=Dead, OS=OneShot] ->
                                    ((((readField
                                          @ (Maybe a_a6H7b)
                                          Data.Monoid.$fReadFirst6
                                          (ds_s6HQj
                                           `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                                  <Maybe
                                                                     a_a6H7b>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                                             <Maybe
                                                                                                a_a6H7b>_R)
                                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                                       -> forall b.
                                                          (Maybe a_a6H7b
                                                           -> Text.ParserCombinators.ReadP.P b)
                                                          -> Text.ParserCombinators.ReadP.P b :: *)
                                                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                                             (Maybe a_a6H7b) :: *))))
                                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                   <Maybe a_a6H7b>_R
                                               :: (Text.ParserCombinators.ReadPrec.ReadPrec
                                                     (Maybe a_a6H7b) :: *)
                                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                                       -> Text.ParserCombinators.ReadP.ReadP
                                                            (Maybe a_a6H7b) :: *)))
                                        Data.Monoid.$fReadFirst5)
                                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                 <Maybe a_a6H7b>_R
                                             :: (Text.ParserCombinators.ReadP.ReadP
                                                   (Maybe a_a6H7b) :: *)
                                                ~R# (forall b.
                                                     (Maybe a_a6H7b
                                                      -> Text.ParserCombinators.ReadP.P b)
                                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                                      @ b1_i6HIg
                                      (\ (a3_i6HKa :: Maybe a_a6H7b) ->
                                         case Text.Read.Lex.$wexpect
                                                Data.Monoid.$fReadFirst2
                                                @ b1_i6HIg
                                                (\ _ [Occ=Dead, OS=OneShot] ->
                                                   eta2_X2v
                                                     (a3_i6HKa
                                                      `cast` (Sym (Data.Monoid.N:First[0]) <a_a6H7b>_N
                                                              :: (Maybe a_a6H7b :: *)
                                                                 ~R# (First a_a6H7b :: *))))
                                         of
                                         { (# ww1_i6HJX #) ->
                                         Text.ParserCombinators.ReadP.Look @ b1_i6HIg ww1_i6HJX
                                         }))
                          of
                          { (# ww1_i6HJX #) ->
                          Text.ParserCombinators.ReadP.Look @ b1_i6HIg ww1_i6HJX
                          })
                of
                { (# ww1_i6HJX #) ->
                Text.ParserCombinators.ReadP.Look @ b1_i6HIg ww1_i6HJX
                }
            }
            })
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <First
                                   a_a6H7b>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <First a_a6H7b>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (First a_a6H7b -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (First a_a6H7b) :: *)))
        eta_B2
        @ b_i6HzL
        eta1_B1

-- RHS size: {terms: 8, types: 12, coercions: 0, joins: 0/0}
Data.Monoid.$fReadFirst_$creadsPrec
  :: forall a. Read a => Int -> ReadS (First a)
[GblId,
 Arity=2,
 Str=<L,U(A,A,C(C1(U)),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X6HaX)
                 ($dRead_X6HaZ [Occ=Once] :: Read a_X6HaX)
                 (n_i6HzD [Occ=Once] :: Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ (First a_X6HaX)
                   (Data.Monoid.$fReadFirst1
                      @ a_X6HaX
                      $dRead_X6HaZ
                      n_i6HzD
                      @ (First a_X6HaX)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ (First a_X6HaX)))}]
Data.Monoid.$fReadFirst_$creadsPrec
  = \ (@ a_X6HaX) ($dRead_X6HaZ :: Read a_X6HaX) (n_i6HzD :: Int) ->
      Text.ParserCombinators.ReadP.run
        @ (First a_X6HaX)
        (Data.Monoid.$fReadFirst1
           @ a_X6HaX
           $dRead_X6HaZ
           n_i6HzD
           @ (First a_X6HaX)
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ (First a_X6HaX)))

-- RHS size: {terms: 5, types: 7, coercions: 11, joins: 0/0}
Data.Monoid.$fReadFirst_$creadListPrec
  :: forall a.
     Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [First a]
[GblId,
 Arity=1,
 Str=<L,U(A,A,C(C1(U)),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X6HaV) ($dRead_X6HaX [Occ=Once] :: Read a_X6HaV) ->
                 list
                   @ (First a_X6HaV)
                   ((Data.Monoid.$fReadFirst1 @ a_X6HaV $dRead_X6HaX)
                    `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <First
                                              a_X6HaV>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <First a_X6HaV>_R)
                            :: (Text.ParserCombinators.ReadPrec.Prec
                                -> forall b.
                                   (First a_X6HaV -> Text.ParserCombinators.ReadP.P b)
                                   -> Text.ParserCombinators.ReadP.P b :: *)
                               ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                      (First a_X6HaV) :: *)))}]
Data.Monoid.$fReadFirst_$creadListPrec
  = \ (@ a_X6HaV) ($dRead_X6HaX :: Read a_X6HaV) ->
      list
        @ (First a_X6HaV)
        ((Data.Monoid.$fReadFirst1 @ a_X6HaV $dRead_X6HaX)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <First
                                   a_X6HaV>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <First a_X6HaV>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (First a_X6HaV -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (First a_X6HaV) :: *)))

-- RHS size: {terms: 8, types: 16, coercions: 19, joins: 0/0}
Data.Monoid.$fReadFirst_$creadList
  :: forall a. Read a => ReadS [First a]
[GblId,
 Arity=1,
 Str=<L,U(A,A,C(C1(U)),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X6HaW) ($dRead_X6HaY [Occ=Once] :: Read a_X6HaW) ->
                 Text.ParserCombinators.ReadP.run
                   @ [First a_X6HaW]
                   (((((list
                          @ (First a_X6HaW)
                          ((Data.Monoid.$fReadFirst1 @ a_X6HaW $dRead_X6HaY)
                           `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                  <First
                                                     a_X6HaW>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                             <First a_X6HaW>_R)
                                   :: (Text.ParserCombinators.ReadPrec.Prec
                                       -> forall b.
                                          (First a_X6HaW -> Text.ParserCombinators.ReadP.P b)
                                          -> Text.ParserCombinators.ReadP.P b :: *)
                                      ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                             (First a_X6HaW) :: *))))
                       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                   <[First a_X6HaW]>_R
                               :: (Text.ParserCombinators.ReadPrec.ReadPrec [First a_X6HaW] :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                                       -> Text.ParserCombinators.ReadP.ReadP [First a_X6HaW] :: *)))
                        GHC.Read.$fRead()7)
                     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[First a_X6HaW]>_R
                             :: (Text.ParserCombinators.ReadP.ReadP [First a_X6HaW] :: *)
                                ~R# (forall b.
                                     ([First a_X6HaW] -> Text.ParserCombinators.ReadP.P b)
                                     -> Text.ParserCombinators.ReadP.P b :: *)))
                      @ [First a_X6HaW]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [First a_X6HaW]))}]
Data.Monoid.$fReadFirst_$creadList
  = \ (@ a_X6HaW) ($dRead_X6HaY :: Read a_X6HaW) ->
      Text.ParserCombinators.ReadP.run
        @ [First a_X6HaW]
        (((((list
               @ (First a_X6HaW)
               ((Data.Monoid.$fReadFirst1 @ a_X6HaW $dRead_X6HaY)
                `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <First
                                          a_X6HaW>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                  <First a_X6HaW>_R)
                        :: (Text.ParserCombinators.ReadPrec.Prec
                            -> forall b.
                               (First a_X6HaW -> Text.ParserCombinators.ReadP.P b)
                               -> Text.ParserCombinators.ReadP.P b :: *)
                           ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                  (First a_X6HaW) :: *))))
            `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                        <[First a_X6HaW]>_R
                    :: (Text.ParserCombinators.ReadPrec.ReadPrec [First a_X6HaW] :: *)
                       ~R# (Text.ParserCombinators.ReadPrec.Prec
                            -> Text.ParserCombinators.ReadP.ReadP [First a_X6HaW] :: *)))
             GHC.Read.$fRead()7)
          `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[First a_X6HaW]>_R
                  :: (Text.ParserCombinators.ReadP.ReadP [First a_X6HaW] :: *)
                     ~R# (forall b.
                          ([First a_X6HaW] -> Text.ParserCombinators.ReadP.P b)
                          -> Text.ParserCombinators.ReadP.P b :: *)))
           @ [First a_X6HaW]
           (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
              @ [First a_X6HaW]))

-- RHS size: {terms: 11, types: 10, coercions: 11, joins: 0/0}
Data.Monoid.$fReadFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Read a => Read (First a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(A,A,C(C1(U)),A)>m,
 Unf=DFun: \ (@ a_a6GjV) (v_B1 :: Read a_a6GjV) ->
       GHC.Read.C:Read TYPE: First a_a6GjV
                       Data.Monoid.$fReadFirst_$creadsPrec @ a_a6GjV v_B1
                       Data.Monoid.$fReadFirst_$creadList @ a_a6GjV v_B1
                       (Data.Monoid.$fReadFirst1 @ a_a6GjV v_B1)
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <First
                                                 a_a6GjV>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                         <First a_a6GjV>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (First a_a6GjV -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                                         (First a_a6GjV) :: *))
                       Data.Monoid.$fReadFirst_$creadListPrec @ a_a6GjV v_B1]
Data.Monoid.$fReadFirst
  = \ (@ a_X6HaU) ($dRead_X6HaW :: Read a_X6HaU) ->
      GHC.Read.C:Read
        @ (First a_X6HaU)
        (Data.Monoid.$fReadFirst_$creadsPrec @ a_X6HaU $dRead_X6HaW)
        (Data.Monoid.$fReadFirst_$creadList @ a_X6HaU $dRead_X6HaW)
        ((Data.Monoid.$fReadFirst1 @ a_X6HaU $dRead_X6HaW)
         `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                  ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                <First
                                   a_X6HaU>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                           <First a_X6HaU>_R)
                 :: (Text.ParserCombinators.ReadPrec.Prec
                     -> forall b.
                        (First a_X6HaU -> Text.ParserCombinators.ReadP.P b)
                        -> Text.ParserCombinators.ReadP.P b :: *)
                    ~R# (Text.ParserCombinators.ReadPrec.ReadPrec
                           (First a_X6HaU) :: *)))
        (Data.Monoid.$fReadFirst_$creadListPrec @ a_X6HaU $dRead_X6HaW)

-- RHS size: {terms: 7, types: 8, coercions: 18, joins: 0/0}
Data.Monoid.$fEqFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Eq a => Eq (First a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)>m,
 Unf=DFun: \ (@ a_a6GjV) (v_B1 :: Eq a_a6GjV) ->
       GHC.Classes.C:Eq TYPE: First a_a6GjV
                        (GHC.Base.$fEqMaybe_$c== @ a_a6GjV v_B1)
                        `cast` (Sym (Data.Monoid.N:First[0]) <a_a6GjV>_N
                                ->_R Sym (Data.Monoid.N:First[0]) <a_a6GjV>_N
                                ->_R <Bool>_R
                                :: (Maybe a_a6GjV -> Maybe a_a6GjV -> Bool :: *)
                                   ~R# (First a_a6GjV -> First a_a6GjV -> Bool :: *))
                        (GHC.Base.$fEqMaybe_$c/= @ a_a6GjV v_B1)
                        `cast` (Sym (Data.Monoid.N:First[0]) <a_a6GjV>_N
                                ->_R Sym (Data.Monoid.N:First[0]) <a_a6GjV>_N
                                ->_R <Bool>_R
                                :: (Maybe a_a6GjV -> Maybe a_a6GjV -> Bool :: *)
                                   ~R# (First a_a6GjV -> First a_a6GjV -> Bool :: *))]
Data.Monoid.$fEqFirst
  = \ (@ a_a6H4O) ($dEq_a6H4P :: Eq a_a6H4O) ->
      GHC.Classes.C:Eq
        @ (First a_a6H4O)
        ((GHC.Base.$fEqMaybe_$c== @ a_a6H4O $dEq_a6H4P)
         `cast` (Sym (Data.Monoid.N:First[0]) <a_a6H4O>_N
                 ->_R Sym (Data.Monoid.N:First[0]) <a_a6H4O>_N
                 ->_R <Bool>_R
                 :: (Maybe a_a6H4O -> Maybe a_a6H4O -> Bool :: *)
                    ~R# (First a_a6H4O -> First a_a6H4O -> Bool :: *)))
        ((GHC.Base.$fEqMaybe_$c/= @ a_a6H4O $dEq_a6H4P)
         `cast` (Sym (Data.Monoid.N:First[0]) <a_a6H4O>_N
                 ->_R Sym (Data.Monoid.N:First[0]) <a_a6H4O>_N
                 ->_R <Bool>_R
                 :: (Maybe a_a6H4O -> Maybe a_a6H4O -> Bool :: *)
                    ~R# (First a_a6H4O -> First a_a6H4O -> Bool :: *)))

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
Data.Monoid.$fOrdFirst_$cp1Ord :: forall a. Ord a => Eq (First a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X6H9m) ($dOrd_X6H9o [Occ=Once] :: Ord a_X6H9m) ->
                 Data.Monoid.$fEqFirst
                   @ a_X6H9m (GHC.Classes.$p1Ord @ a_X6H9m $dOrd_X6H9o)}]
Data.Monoid.$fOrdFirst_$cp1Ord
  = \ (@ a_X6H9m) ($dOrd_X6H9o :: Ord a_X6H9m) ->
      Data.Monoid.$fEqFirst
        @ a_X6H9m (GHC.Classes.$p1Ord @ a_X6H9m $dOrd_X6H9o)

-- RHS size: {terms: 23, types: 18, coercions: 67, joins: 0/0}
Data.Monoid.$fOrdFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Ord a => Ord (First a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m,
 Unf=DFun: \ (@ a_a6GjV) (v_B1 :: Ord a_a6GjV) ->
       GHC.Classes.C:Ord TYPE: First a_a6GjV
                         Data.Monoid.$fOrdFirst_$cp1Ord @ a_a6GjV v_B1
                         (GHC.Base.$fOrdMaybe_$ccompare @ a_a6GjV v_B1)
                         `cast` (Sym (Data.Monoid.N:First[0]) <a_a6GjV>_N
                                 ->_R Sym (Data.Monoid.N:First[0]) <a_a6GjV>_N
                                 ->_R <Ordering>_R
                                 :: (Maybe a_a6GjV -> Maybe a_a6GjV -> Ordering :: *)
                                    ~R# (First a_a6GjV -> First a_a6GjV -> Ordering :: *))
                         (GHC.Base.$fOrdMaybe_$c< @ a_a6GjV v_B1)
                         `cast` (Sym (Data.Monoid.N:First[0]) <a_a6GjV>_N
                                 ->_R Sym (Data.Monoid.N:First[0]) <a_a6GjV>_N
                                 ->_R <Bool>_R
                                 :: (Maybe a_a6GjV -> Maybe a_a6GjV -> Bool :: *)
                                    ~R# (First a_a6GjV -> First a_a6GjV -> Bool :: *))
                         (GHC.Base.$fOrdMaybe_$c<= @ a_a6GjV v_B1)
                         `cast` (Sym (Data.Monoid.N:First[0]) <a_a6GjV>_N
                                 ->_R Sym (Data.Monoid.N:First[0]) <a_a6GjV>_N
                                 ->_R <Bool>_R
                                 :: (Maybe a_a6GjV -> Maybe a_a6GjV -> Bool :: *)
                                    ~R# (First a_a6GjV -> First a_a6GjV -> Bool :: *))
                         (\ (a1_i6HCD [Occ=Once] :: Maybe a_a6GjV)
                            (b_i6HCE [Occ=Once] :: Maybe a_a6GjV) ->
                            GHC.Base.$fOrdMaybe_$c< @ a_a6GjV v_B1 b_i6HCE a1_i6HCD)
                         `cast` (Sym (Data.Monoid.N:First[0]) <a_a6GjV>_N
                                 ->_R Sym (Data.Monoid.N:First[0]) <a_a6GjV>_N
                                 ->_R <Bool>_R
                                 :: (Maybe a_a6GjV -> Maybe a_a6GjV -> Bool :: *)
                                    ~R# (First a_a6GjV -> First a_a6GjV -> Bool :: *))
                         (GHC.Base.$fOrdMaybe_$c>= @ a_a6GjV v_B1)
                         `cast` (Sym (Data.Monoid.N:First[0]) <a_a6GjV>_N
                                 ->_R Sym (Data.Monoid.N:First[0]) <a_a6GjV>_N
                                 ->_R <Bool>_R
                                 :: (Maybe a_a6GjV -> Maybe a_a6GjV -> Bool :: *)
                                    ~R# (First a_a6GjV -> First a_a6GjV -> Bool :: *))
                         (GHC.Base.$fOrdMaybe_$cmax @ a_a6GjV v_B1)
                         `cast` (Sym (Data.Monoid.N:First[0]) <a_a6GjV>_N
                                 ->_R Sym (Data.Monoid.N:First[0]) <a_a6GjV>_N
                                 ->_R Sym (Data.Monoid.N:First[0]) <a_a6GjV>_N
                                 :: (Maybe a_a6GjV -> Maybe a_a6GjV -> Maybe a_a6GjV :: *)
                                    ~R# (First a_a6GjV -> First a_a6GjV -> First a_a6GjV :: *))
                         (GHC.Base.$fOrdMaybe_$cmin @ a_a6GjV v_B1)
                         `cast` (Sym (Data.Monoid.N:First[0]) <a_a6GjV>_N
                                 ->_R Sym (Data.Monoid.N:First[0]) <a_a6GjV>_N
                                 ->_R Sym (Data.Monoid.N:First[0]) <a_a6GjV>_N
                                 :: (Maybe a_a6GjV -> Maybe a_a6GjV -> Maybe a_a6GjV :: *)
                                    ~R# (First a_a6GjV -> First a_a6GjV -> First a_a6GjV :: *))]
Data.Monoid.$fOrdFirst
  = \ (@ a_X6H9n) ($dOrd_X6H9p :: Ord a_X6H9n) ->
      GHC.Classes.C:Ord
        @ (First a_X6H9n)
        (Data.Monoid.$fOrdFirst_$cp1Ord @ a_X6H9n $dOrd_X6H9p)
        ((GHC.Base.$fOrdMaybe_$ccompare @ a_X6H9n $dOrd_X6H9p)
         `cast` (Sym (Data.Monoid.N:First[0]) <a_X6H9n>_N
                 ->_R Sym (Data.Monoid.N:First[0]) <a_X6H9n>_N
                 ->_R <Ordering>_R
                 :: (Maybe a_X6H9n -> Maybe a_X6H9n -> Ordering :: *)
                    ~R# (First a_X6H9n -> First a_X6H9n -> Ordering :: *)))
        ((GHC.Base.$fOrdMaybe_$c< @ a_X6H9n $dOrd_X6H9p)
         `cast` (Sym (Data.Monoid.N:First[0]) <a_X6H9n>_N
                 ->_R Sym (Data.Monoid.N:First[0]) <a_X6H9n>_N
                 ->_R <Bool>_R
                 :: (Maybe a_X6H9n -> Maybe a_X6H9n -> Bool :: *)
                    ~R# (First a_X6H9n -> First a_X6H9n -> Bool :: *)))
        ((GHC.Base.$fOrdMaybe_$c<= @ a_X6H9n $dOrd_X6H9p)
         `cast` (Sym (Data.Monoid.N:First[0]) <a_X6H9n>_N
                 ->_R Sym (Data.Monoid.N:First[0]) <a_X6H9n>_N
                 ->_R <Bool>_R
                 :: (Maybe a_X6H9n -> Maybe a_X6H9n -> Bool :: *)
                    ~R# (First a_X6H9n -> First a_X6H9n -> Bool :: *)))
        ((\ (a1_i6HCD :: Maybe a_X6H9n) (b_i6HCE :: Maybe a_X6H9n) ->
            GHC.Base.$fOrdMaybe_$c< @ a_X6H9n $dOrd_X6H9p b_i6HCE a1_i6HCD)
         `cast` (Sym (Data.Monoid.N:First[0]) <a_X6H9n>_N
                 ->_R Sym (Data.Monoid.N:First[0]) <a_X6H9n>_N
                 ->_R <Bool>_R
                 :: (Maybe a_X6H9n -> Maybe a_X6H9n -> Bool :: *)
                    ~R# (First a_X6H9n -> First a_X6H9n -> Bool :: *)))
        ((GHC.Base.$fOrdMaybe_$c>= @ a_X6H9n $dOrd_X6H9p)
         `cast` (Sym (Data.Monoid.N:First[0]) <a_X6H9n>_N
                 ->_R Sym (Data.Monoid.N:First[0]) <a_X6H9n>_N
                 ->_R <Bool>_R
                 :: (Maybe a_X6H9n -> Maybe a_X6H9n -> Bool :: *)
                    ~R# (First a_X6H9n -> First a_X6H9n -> Bool :: *)))
        ((GHC.Base.$fOrdMaybe_$cmax @ a_X6H9n $dOrd_X6H9p)
         `cast` (Sym (Data.Monoid.N:First[0]) <a_X6H9n>_N
                 ->_R Sym (Data.Monoid.N:First[0]) <a_X6H9n>_N
                 ->_R Sym (Data.Monoid.N:First[0]) <a_X6H9n>_N
                 :: (Maybe a_X6H9n -> Maybe a_X6H9n -> Maybe a_X6H9n :: *)
                    ~R# (First a_X6H9n -> First a_X6H9n -> First a_X6H9n :: *)))
        ((GHC.Base.$fOrdMaybe_$cmin @ a_X6H9n $dOrd_X6H9p)
         `cast` (Sym (Data.Monoid.N:First[0]) <a_X6H9n>_N
                 ->_R Sym (Data.Monoid.N:First[0]) <a_X6H9n>_N
                 ->_R Sym (Data.Monoid.N:First[0]) <a_X6H9n>_N
                 :: (Maybe a_X6H9n -> Maybe a_X6H9n -> Maybe a_X6H9n :: *)
                    ~R# (First a_X6H9n -> First a_X6H9n -> First a_X6H9n :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
getFirst :: forall a. First a -> Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Monoid.$fGeneric1First2
               `cast` (forall (a :: <*>_N).
                       <First a>_R ->_R Data.Monoid.N:First[0] <a>_N
                       :: (forall a. First a -> First a :: *)
                          ~R# (forall a. First a -> Maybe a :: *))}]
getFirst
  = Data.Monoid.$fGeneric1First2
    `cast` (forall (a :: <*>_N).
            <First a>_R ->_R Data.Monoid.N:First[0] <a>_N
            :: (forall a. First a -> First a :: *)
               ~R# (forall a. First a -> Maybe a :: *))

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
getLast :: forall a. Last a -> Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Data.Monoid.$fGeneric1Last2
               `cast` (forall (a :: <*>_N).
                       <Last a>_R ->_R Data.Monoid.N:Last[0] <a>_N
                       :: (forall a. Last a -> Last a :: *)
                          ~R# (forall a. Last a -> Maybe a :: *))}]
getLast
  = Data.Monoid.$fGeneric1Last2
    `cast` (forall (a :: <*>_N).
            <Last a>_R ->_R Data.Monoid.N:Last[0] <a>_N
            :: (forall a. Last a -> Last a :: *)
               ~R# (forall a. Last a -> Maybe a :: *))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Monoid.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Monoid.$trModule3 = GHC.Types.TrNameS Data.Monoid.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Monoid.$trModule2 = "Data.Monoid"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Monoid.$trModule1 = GHC.Types.TrNameS Data.Monoid.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Monoid.$trModule
  = GHC.Types.Module Data.Monoid.$trModule3 Data.Monoid.$trModule1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep_r6I1r :: KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep_r6I1r = GHC.Types.KindRepVar 0#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep1_r6I1s :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep1_r6I1s
  = GHC.Types.: @ KindRep $krep_r6I1r (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep2_r6I1t :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep2_r6I1t
  = GHC.Types.KindRepTyConApp GHC.Base.$tcMaybe $krep1_r6I1s

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$tcFirst1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Monoid.$tcFirst1 = GHC.Types.TrNameS Data.Monoid.$fReadFirst11

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$tcFirst :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Monoid.$tcFirst
  = GHC.Types.TyCon
      12072287807032806756##
      12788244796562536401##
      Data.Monoid.$trModule
      Data.Monoid.$tcFirst1
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep3_r6I1u :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep3_r6I1u
  = GHC.Types.KindRepTyConApp Data.Monoid.$tcFirst $krep1_r6I1s

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$tc'First1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Monoid.$tc'First1
  = GHC.Types.KindRepFun $krep2_r6I1t $krep3_r6I1u

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$tc'First3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Monoid.$tc'First3 = "'First"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$tc'First2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Monoid.$tc'First2 = GHC.Types.TrNameS Data.Monoid.$tc'First3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$tc'First :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Monoid.$tc'First
  = GHC.Types.TyCon
      7752528083504400280##
      15965132804789246607##
      Data.Monoid.$trModule
      Data.Monoid.$tc'First2
      1#
      Data.Monoid.$tc'First1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$tcLast1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Monoid.$tcLast1 = GHC.Types.TrNameS Data.Monoid.$fReadLast5

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$tcLast :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Monoid.$tcLast
  = GHC.Types.TyCon
      6920195955404695016##
      2388797855174213212##
      Data.Monoid.$trModule
      Data.Monoid.$tcLast1
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep4_r6I1v :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep4_r6I1v
  = GHC.Types.KindRepTyConApp Data.Monoid.$tcLast $krep1_r6I1s

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$tc'Last1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Data.Monoid.$tc'Last1
  = GHC.Types.KindRepFun $krep2_r6I1t $krep4_r6I1v

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$tc'Last3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Data.Monoid.$tc'Last3 = "'Last"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$tc'Last2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Monoid.$tc'Last2 = GHC.Types.TrNameS Data.Monoid.$tc'Last3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Monoid.$tc'Last :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Monoid.$tc'Last
  = GHC.Types.TyCon
      5411164464353425083##
      12998161994081761510##
      Data.Monoid.$trModule
      Data.Monoid.$tc'Last2
      1#
      Data.Monoid.$tc'Last1


