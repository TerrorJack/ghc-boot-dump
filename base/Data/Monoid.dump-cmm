
==================== Output Cmm ====================
2018-03-16 16:01:56.818972286 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:01:56.820060324 UTC

[section ""data" . Data.Monoid.$fMonoidFirst_$c<>_closure" {
     Data.Monoid.$fMonoidFirst_$c<>_closure:
         const Data.Monoid.$fMonoidFirst_$c<>_info;
 },
 Data.Monoid.$fMonoidFirst_$c<>_entry() //  [R2, R3]
         { info_tbl: [(c6I5y,
                       label: Data.Monoid.$fMonoidFirst_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I5y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6I5z; else goto c6I5A;
       c6I5z: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fMonoidFirst_$c<>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6I5A: // global
           I64[Sp - 16] = block_c6I5r_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6I5H; else goto c6I5s;
       u6I5H: // global
           call _c6I5r(R1) args: 0, res: 0, upd: 0;
       c6I5s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6I5r() //  [R1]
         { info_tbl: [(c6I5r,
                       label: block_c6I5r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I5r: // global
           if (R1 & 7 == 1) goto c6I5v; else goto c6I5w;
       c6I5v: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6I5w: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.821744562 UTC

[section ""data" . Data.Monoid.$fSemigroupFirst1_closure" {
     Data.Monoid.$fSemigroupFirst1_closure:
         const Data.Monoid.$fSemigroupFirst1_info;
 },
 Data.Monoid.$fSemigroupFirst1_entry() //  [R2, R3]
         { info_tbl: [(c6I5T,
                       label: Data.Monoid.$fSemigroupFirst1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I5T: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6I5U; else goto u6I6f;
       c6I5U: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fSemigroupFirst1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u6I6f: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c6I5J() args: 0, res: 0, upd: 0;
     }
 },
 _c6I5J() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I5J: // global
           I64[Sp - 8] = block_c6I5M_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6I6h; else goto c6I5N;
       u6I6h: // global
           call _c6I5M(R1) args: 0, res: 0, upd: 0;
       c6I5N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6I5M() //  [R1]
         { info_tbl: [(c6I5M,
                       label: block_c6I5M_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I5M: // global
           _s6I1B::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6I5Q; else goto c6I5R;
       c6I5Q: // global
           R1 = _s6I1B::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6I5R: // global
           I64[Sp] = block_c6I61_info;
           _s6I1E::P64 = P64[R1 + 6];
           _s6I1F::P64 = P64[R1 + 14];
           R1 = _s6I1B::P64;
           P64[Sp + 8] = _s6I1F::P64;
           P64[Sp + 16] = _s6I1E::P64;
           if (R1 & 7 != 0) goto u6I6i; else goto c6I63;
       u6I6i: // global
           call _c6I61(R1) args: 0, res: 0, upd: 0;
       c6I63: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6I61() //  [R1]
         { info_tbl: [(c6I61,
                       label: block_c6I61_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I61: // global
           if (R1 & 7 == 1) goto c6I69; else goto c6I6d;
       c6I69: // global
           _s6I1C::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s6I1C::P64;
           Sp = Sp + 8;
           call _c6I5J() args: 0, res: 0, upd: 0;
       c6I6d: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.823436847 UTC

[section ""data" . Data.Monoid.$fSemigroupFirst_$csconcat_closure" {
     Data.Monoid.$fSemigroupFirst_$csconcat_closure:
         const Data.Monoid.$fSemigroupFirst_$csconcat_info;
 },
 Data.Monoid.$fSemigroupFirst_$csconcat_entry() //  [R2]
         { info_tbl: [(c6I6s,
                       label: Data.Monoid.$fSemigroupFirst_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I6s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6I6t; else goto c6I6u;
       c6I6t: // global
           R2 = R2;
           R1 = Data.Monoid.$fSemigroupFirst_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6I6u: // global
           I64[Sp - 8] = block_c6I6p_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6I6y; else goto c6I6q;
       u6I6y: // global
           call _c6I6p(R1) args: 0, res: 0, upd: 0;
       c6I6q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6I6p() //  [R1]
         { info_tbl: [(c6I6p,
                       label: block_c6I6p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I6p: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Monoid.$fSemigroupFirst1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.824858557 UTC

[section ""data" . Data.Monoid.$fMonoidFirst_go_closure" {
     Data.Monoid.$fMonoidFirst_go_closure:
         const Data.Monoid.$fMonoidFirst_go_info;
 },
 Data.Monoid.$fMonoidFirst_go_entry() //  [R2]
         { info_tbl: [(c6I6K,
                       label: Data.Monoid.$fMonoidFirst_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I6K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6I6L; else goto u6I76;
       c6I6L: // global
           R2 = R2;
           R1 = Data.Monoid.$fMonoidFirst_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u6I76: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c6I6A() args: 0, res: 0, upd: 0;
     }
 },
 _c6I6A() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I6A: // global
           _s6I1M::P64 = P64[Sp];
           I64[Sp] = block_c6I6D_info;
           R1 = _s6I1M::P64;
           if (R1 & 7 != 0) goto u6I78; else goto c6I6E;
       u6I78: // global
           call _c6I6D(R1) args: 0, res: 0, upd: 0;
       c6I6E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6I6D() //  [R1]
         { info_tbl: [(c6I6D,
                       label: block_c6I6D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I6D: // global
           if (R1 & 7 == 1) goto c6I6H; else goto c6I6I;
       c6I6H: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6I6I: // global
           I64[Sp - 8] = block_c6I6S_info;
           _s6I1P::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s6I1P::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6I79; else goto c6I6U;
       u6I79: // global
           call _c6I6S(R1) args: 0, res: 0, upd: 0;
       c6I6U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6I6S() //  [R1]
         { info_tbl: [(c6I6S,
                       label: block_c6I6S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I6S: // global
           if (R1 & 7 == 1) goto c6I70; else goto c6I74;
       c6I70: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c6I6A() args: 0, res: 0, upd: 0;
       c6I74: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.826458271 UTC

[section ""data" . Data.Monoid.$fSemigroupFirst_closure" {
     Data.Monoid.$fSemigroupFirst_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Monoid.$fMonoidFirst_$c<>_closure+2;
         const Data.Monoid.$fSemigroupFirst_$csconcat_closure+1;
         const Data.Monoid.$fSemigroupFirst_$cstimes_closure+3;
         const 0;
 },
 section ""data" . Data.Monoid.$fMonoidFirst_closure" {
     Data.Monoid.$fMonoidFirst_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Monoid.$fSemigroupFirst_closure+1;
         const GHC.Base.Nothing_closure+1;
         const Data.Monoid.$fMonoidFirst_$c<>_closure+2;
         const Data.Monoid.$fMonoidFirst_go_closure+1;
         const 0;
 },
 section ""data" . Data.Monoid.$fSemigroupFirst_$cstimes_closure" {
     Data.Monoid.$fSemigroupFirst_$cstimes_closure:
         const Data.Monoid.$fSemigroupFirst_$cstimes_info;
         const 0;
 },
 Data.Monoid.$fSemigroupFirst_$cstimes_entry() //  [R2, R3, R4]
         { info_tbl: [(c6I7g,
                       label: Data.Monoid.$fSemigroupFirst_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I7g: // global
           R5 = R4;
           R4 = R3;
           R3 = Data.Monoid.$fMonoidFirst_closure+1;
           R2 = R2;
           call Data.Semigroup.Internal.stimesIdempotentMonoid_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.827740311 UTC

[section ""data" . Data.Monoid.$fMonoidLast_$c<>_closure" {
     Data.Monoid.$fMonoidLast_$c<>_closure:
         const Data.Monoid.$fMonoidLast_$c<>_info;
 },
 Data.Monoid.$fMonoidLast_$c<>_entry() //  [R2, R3]
         { info_tbl: [(c6I7v,
                       label: Data.Monoid.$fMonoidLast_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I7v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6I7w; else goto c6I7x;
       c6I7w: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fMonoidLast_$c<>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6I7x: // global
           I64[Sp - 16] = block_c6I7o_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6I7E; else goto c6I7p;
       u6I7E: // global
           call _c6I7o(R1) args: 0, res: 0, upd: 0;
       c6I7p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6I7o() //  [R1]
         { info_tbl: [(c6I7o,
                       label: block_c6I7o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I7o: // global
           if (R1 & 7 == 1) goto c6I7s; else goto c6I7t;
       c6I7s: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6I7t: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.829213732 UTC

[section ""data" . Data.Monoid.$fSemigroupLast1_closure" {
     Data.Monoid.$fSemigroupLast1_closure:
         const Data.Monoid.$fSemigroupLast1_info;
 },
 Data.Monoid.$fSemigroupLast1_entry() //  [R2, R3]
         { info_tbl: [(c6I7Q,
                       label: Data.Monoid.$fSemigroupLast1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I7Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6I7R; else goto c6I7S;
       c6I7R: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fSemigroupLast1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6I7S: // global
           I64[Sp - 16] = block_c6I7J_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6I8e; else goto c6I7K;
       u6I8e: // global
           call _c6I7J(R1) args: 0, res: 0, upd: 0;
       c6I7K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6I7J() //  [R1]
         { info_tbl: [(c6I7J,
                       label: block_c6I7J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I7J: // global
           if (R1 & 7 == 1) goto u6I8b; else goto c6I7O;
       u6I8b: // global
           Sp = Sp + 8;
           call _c6I85() args: 0, res: 0, upd: 0;
       c6I7O: // global
           I64[Sp] = block_c6I7Y_info;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Monoid.$fSemigroupLast1_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6I7Y() //  [R1]
         { info_tbl: [(c6I7Y,
                       label: block_c6I7Y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I7Y: // global
           if (R1 & 7 == 1) goto u6I8c; else goto c6I89;
       u6I8c: // global
           Sp = Sp + 8;
           call _c6I85() args: 0, res: 0, upd: 0;
       c6I89: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6I85() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I85: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.830754401 UTC

[section ""data" . Data.Monoid.$fSemigroupLast_$csconcat_closure" {
     Data.Monoid.$fSemigroupLast_$csconcat_closure:
         const Data.Monoid.$fSemigroupLast_$csconcat_info;
 },
 Data.Monoid.$fSemigroupLast_$csconcat_entry() //  [R2]
         { info_tbl: [(c6I8n,
                       label: Data.Monoid.$fSemigroupLast_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I8n: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6I8o; else goto c6I8p;
       c6I8o: // global
           R2 = R2;
           R1 = Data.Monoid.$fSemigroupLast_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6I8p: // global
           I64[Sp - 8] = block_c6I8k_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6I8t; else goto c6I8l;
       u6I8t: // global
           call _c6I8k(R1) args: 0, res: 0, upd: 0;
       c6I8l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6I8k() //  [R1]
         { info_tbl: [(c6I8k,
                       label: block_c6I8k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I8k: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Monoid.$fSemigroupLast1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.832099701 UTC

[section ""data" . Data.Monoid.$fMonoidLast_go_closure" {
     Data.Monoid.$fMonoidLast_go_closure:
         const Data.Monoid.$fMonoidLast_go_info;
 },
 Data.Monoid.$fMonoidLast_go_entry() //  [R2]
         { info_tbl: [(c6I8F,
                       label: Data.Monoid.$fMonoidLast_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I8F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6I8G; else goto c6I8H;
       c6I8G: // global
           R2 = R2;
           R1 = Data.Monoid.$fMonoidLast_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6I8H: // global
           I64[Sp - 8] = block_c6I8y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6I90; else goto c6I8z;
       u6I90: // global
           call _c6I8y(R1) args: 0, res: 0, upd: 0;
       c6I8z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6I8y() //  [R1]
         { info_tbl: [(c6I8y,
                       label: block_c6I8y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I8y: // global
           if (R1 & 7 == 1) goto c6I8C; else goto c6I8D;
       c6I8C: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6I8D: // global
           I64[Sp - 8] = block_c6I8N_info;
           R2 = P64[R1 + 14];
           P64[Sp] = P64[R1 + 6];
           Sp = Sp - 8;
           call Data.Monoid.$fMonoidLast_go_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6I8N() //  [R1]
         { info_tbl: [(c6I8N,
                       label: block_c6I8N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I8N: // global
           if (R1 & 7 == 1) goto c6I8U; else goto c6I8Y;
       c6I8U: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6I8Y: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.833596477 UTC

[section ""data" . Data.Monoid.$fSemigroupLast_closure" {
     Data.Monoid.$fSemigroupLast_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Monoid.$fMonoidLast_$c<>_closure+2;
         const Data.Monoid.$fSemigroupLast_$csconcat_closure+1;
         const Data.Monoid.$fSemigroupLast_$cstimes_closure+3;
         const 0;
 },
 section ""data" . Data.Monoid.$fMonoidLast_closure" {
     Data.Monoid.$fMonoidLast_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Monoid.$fSemigroupLast_closure+1;
         const GHC.Base.Nothing_closure+1;
         const Data.Monoid.$fMonoidLast_$c<>_closure+2;
         const Data.Monoid.$fMonoidLast_go_closure+1;
         const 0;
 },
 section ""data" . Data.Monoid.$fSemigroupLast_$cstimes_closure" {
     Data.Monoid.$fSemigroupLast_$cstimes_closure:
         const Data.Monoid.$fSemigroupLast_$cstimes_info;
         const 0;
 },
 Data.Monoid.$fSemigroupLast_$cstimes_entry() //  [R2, R3, R4]
         { info_tbl: [(c6I95,
                       label: Data.Monoid.$fSemigroupLast_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I95: // global
           R5 = R4;
           R4 = R3;
           R3 = Data.Monoid.$fMonoidLast_closure+1;
           R2 = R2;
           call Data.Semigroup.Internal.stimesIdempotentMonoid_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.834514107 UTC

[section ""data" . Data.Monoid.$fFunctorLast_closure" {
     Data.Monoid.$fFunctorLast_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fApplicativeMaybe_$cfmap_closure+2;
         const GHC.Base.$fFunctorMaybe_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.835127764 UTC

[section ""data" . Data.Monoid.$fApplicativeLast_closure" {
     Data.Monoid.$fApplicativeLast_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Monoid.$fFunctorLast_closure+1;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fApplicativeMaybe_$c<*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$cliftA2_closure+3;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c<*_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.835761468 UTC

[section ""data" . Data.Monoid.$fMonadLast_closure" {
     Data.Monoid.$fMonadLast_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Monoid.$fApplicativeLast_closure+1;
         const GHC.Base.$fMonadMaybe_$c>>=_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fMonadMaybe_$cfail_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.836473174 UTC

[section ""data" . Data.Monoid.$fGeneric1Last1_closure" {
     Data.Monoid.$fGeneric1Last1_closure:
         const Data.Monoid.$fGeneric1Last1_info;
 },
 Data.Monoid.$fGeneric1Last1_entry() //  [R2]
         { info_tbl: [(c6I9c,
                       label: Data.Monoid.$fGeneric1Last1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I9c: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.837329374 UTC

[section ""data" . Data.Monoid.$fGeneric1Last2_closure" {
     Data.Monoid.$fGeneric1Last2_closure:
         const Data.Monoid.$fGeneric1Last2_info;
 },
 Data.Monoid.$fGeneric1Last2_entry() //  [R2]
         { info_tbl: [(c6I9j,
                       label: Data.Monoid.$fGeneric1Last2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I9j: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.838108358 UTC

[section ""data" . Data.Monoid.$fGeneric1Last_closure" {
     Data.Monoid.$fGeneric1Last_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Monoid.$fGeneric1Last2_closure+1;
         const Data.Monoid.$fGeneric1Last1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.838825469 UTC

[section ""data" . Data.Monoid.$fGenericLast1_closure" {
     Data.Monoid.$fGenericLast1_closure:
         const Data.Monoid.$fGenericLast1_info;
 },
 Data.Monoid.$fGenericLast1_entry() //  [R2]
         { info_tbl: [(c6I9q,
                       label: Data.Monoid.$fGenericLast1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I9q: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.839680705 UTC

[section ""data" . Data.Monoid.$fGenericLast2_closure" {
     Data.Monoid.$fGenericLast2_closure:
         const Data.Monoid.$fGenericLast2_info;
 },
 Data.Monoid.$fGenericLast2_entry() //  [R2]
         { info_tbl: [(c6I9x,
                       label: Data.Monoid.$fGenericLast2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I9x: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.841755802 UTC

[section ""data" . Data.Monoid.$fGenericLast_closure" {
     Data.Monoid.$fGenericLast_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Monoid.$fGenericLast2_closure+1;
         const Data.Monoid.$fGenericLast1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.842555251 UTC

[section ""data" . Data.Monoid.$fShowFirst1_closure" {
     Data.Monoid.$fShowFirst1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.843178019 UTC

[section ""cstring" . Data.Monoid.$fShowLast2_bytes" {
     Data.Monoid.$fShowLast2_bytes:
         I8[] [76,97,115,116,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.843775991 UTC

[section ""cstring" . Data.Monoid.$fShowLast1_bytes" {
     Data.Monoid.$fShowLast1_bytes:
         I8[] [103,101,116,76,97,115,116,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.844326905 UTC

[section ""cstring" . Data.Monoid.$fReadFirst4_bytes" {
     Data.Monoid.$fReadFirst4_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.846982309 UTC

[section ""data" . Data.Monoid.$w$cshowsPrec1_closure" {
     Data.Monoid.$w$cshowsPrec1_closure:
         const Data.Monoid.$w$cshowsPrec1_info;
         const 0;
 },
 f_s6I2m_entry() //  [R1]
         { info_tbl: [(c6I9I,
                       label: f_s6I2m_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6I9I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6I9J; else goto c6I9K;
       c6I9J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6I9K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = Data.Monoid.$fShowFirst1_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.$fShowMaybe_$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2p_entry() //  [R1]
         { info_tbl: [(c6Ia5,
                       label: sat_s6I2p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ia5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Ia6; else goto c6Ia7;
       c6Ia6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Ia7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Monoid.$fReadFirst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2q_entry() //  [R1]
         { info_tbl: [(c6Ia8,
                       label: sat_s6I2q_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ia8: // global
           _s6I2q::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6Ia9; else goto c6Iaa;
       c6Iaa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Iac; else goto c6Iab;
       c6Iac: // global
           HpAlloc = 24;
           goto c6Ia9;
       c6Ia9: // global
           R1 = _s6I2q::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Iab: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I2q::P64;
           _s6I2m::P64 = P64[_s6I2q::P64 + 16];
           _s6I2o::P64 = P64[_s6I2q::P64 + 24];
           I64[Hp - 16] = sat_s6I2p_info;
           P64[Hp] = _s6I2o::P64;
           R2 = Hp - 16;
           R1 = _s6I2m::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2r_entry() //  [R1]
         { info_tbl: [(c6Iad,
                       label: sat_s6I2r_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iad: // global
           _s6I2r::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6Iae; else goto c6Iaf;
       c6Iaf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Iah; else goto c6Iag;
       c6Iah: // global
           HpAlloc = 32;
           goto c6Iae;
       c6Iae: // global
           R1 = _s6I2r::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Iag: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I2r::P64;
           _s6I2m::P64 = P64[_s6I2r::P64 + 16];
           _s6I2o::P64 = P64[_s6I2r::P64 + 24];
           I64[Hp - 24] = sat_s6I2q_info;
           P64[Hp - 8] = _s6I2m::P64;
           P64[Hp] = _s6I2o::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2s_entry() //  [R1, R2]
         { info_tbl: [(c6Iai,
                       label: sat_s6I2s_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iai: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Iam; else goto c6Ial;
       c6Iam: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Ial: // global
           _s6I2m::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6I2r_info;
           P64[Hp - 8] = _s6I2m::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I2v_entry() //  [R1]
         { info_tbl: [(c6IaK,
                       label: sat_s6I2v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IaK: // global
           _s6I2v::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IaL; else goto c6IaM;
       c6IaM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IaO; else goto c6IaN;
       c6IaO: // global
           HpAlloc = 24;
           goto c6IaL;
       c6IaL: // global
           R1 = _s6I2v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IaN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I2v::P64;
           _s6I2t::P64 = P64[_s6I2v::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6I2t::P64;
           R3 = Hp - 14;
           R2 = Data.Monoid.$fReadFirst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2w_entry() //  [R1]
         { info_tbl: [(c6IaP,
                       label: sat_s6I2w_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IaP: // global
           _s6I2w::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IaQ; else goto c6IaR;
       c6IaR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IaT; else goto c6IaS;
       c6IaT: // global
           HpAlloc = 24;
           goto c6IaQ;
       c6IaQ: // global
           R1 = _s6I2w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IaS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I2w::P64;
           _s6I2m::P64 = P64[_s6I2w::P64 + 16];
           _s6I2t::P64 = P64[_s6I2w::P64 + 24];
           I64[Hp - 16] = sat_s6I2v_info;
           P64[Hp] = _s6I2t::P64;
           R2 = Hp - 16;
           R1 = _s6I2m::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2x_entry() //  [R1]
         { info_tbl: [(c6IaU,
                       label: sat_s6I2x_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IaU: // global
           _s6I2x::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IaV; else goto c6IaW;
       c6IaW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6IaY; else goto c6IaX;
       c6IaY: // global
           HpAlloc = 32;
           goto c6IaV;
       c6IaV: // global
           R1 = _s6I2x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IaX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I2x::P64;
           _s6I2m::P64 = P64[_s6I2x::P64 + 16];
           _s6I2t::P64 = P64[_s6I2x::P64 + 24];
           I64[Hp - 24] = sat_s6I2w_info;
           P64[Hp - 8] = _s6I2m::P64;
           P64[Hp] = _s6I2t::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2y_entry() //  [R1]
         { info_tbl: [(c6IaZ,
                       label: sat_s6I2y_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IaZ: // global
           _s6I2y::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6Ib0; else goto c6Ib1;
       c6Ib1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Ib3; else goto c6Ib2;
       c6Ib3: // global
           HpAlloc = 32;
           goto c6Ib0;
       c6Ib0: // global
           R1 = _s6I2y::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Ib2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I2y::P64;
           _s6I2m::P64 = P64[_s6I2y::P64 + 16];
           _s6I2t::P64 = P64[_s6I2y::P64 + 24];
           I64[Hp - 24] = sat_s6I2x_info;
           P64[Hp - 8] = _s6I2m::P64;
           P64[Hp] = _s6I2t::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2z_entry() //  [R1, R2]
         { info_tbl: [(c6Ib5,
                       label: sat_s6I2z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ib5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6Ib9; else goto c6Ib8;
       c6Ib9: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Ib8: // global
           _s6I2m::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6I2y_info;
           P64[Hp - 32] = _s6I2m::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$w$cshowsPrec1_entry() //  [R2, R3, R4]
         { info_tbl: [(c6Ibd,
                       label: Data.Monoid.$w$cshowsPrec1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ibd: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6Ibh; else goto c6Ibg;
       c6Ibh: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$w$cshowsPrec1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Ibg: // global
           I64[Hp - 40] = f_s6I2m_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6I9E::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6Ibb; else goto c6Ibc;
       c6Ibb: // global
           I64[Hp - 8] = sat_s6I2s_info;
           P64[Hp] = _c6I9E::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6Ibc: // global
           I64[Hp - 8] = sat_s6I2z_info;
           P64[Hp] = _c6I9E::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.851700045 UTC

[section ""data" . Data.Monoid.$fShowLast_$cshowsPrec_closure" {
     Data.Monoid.$fShowLast_$cshowsPrec_closure:
         const Data.Monoid.$fShowLast_$cshowsPrec_info;
         const 0;
 },
 Data.Monoid.$fShowLast_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c6Ibp,
                       label: Data.Monoid.$fShowLast_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ibp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6Ibq; else goto c6Ibr;
       c6Ibq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowLast_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Ibr: // global
           I64[Sp - 24] = block_c6Ibm_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6Ibv; else goto c6Ibn;
       u6Ibv: // global
           call _c6Ibm(R1) args: 0, res: 0, upd: 0;
       c6Ibn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Ibm() //  [R1]
         { info_tbl: [(c6Ibm,
                       label: block_c6Ibm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ibm: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Monoid.$w$cshowsPrec1_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.853027458 UTC

[section ""data" . Data.Monoid.$fReadFirst3_closure" {
     Data.Monoid.$fReadFirst3_closure:
         const Data.Monoid.$fReadFirst3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadFirst3_entry() //  [R1]
         { info_tbl: [(c6IbC,
                       label: Data.Monoid.$fReadFirst3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IbC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IbD; else goto c6IbE;
       c6IbD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IbE: // global
           (_c6Ibz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6Ibz::I64 == 0) goto c6IbB; else goto c6IbA;
       c6IbB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6IbA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6Ibz::I64;
           R2 = Data.Monoid.$fReadFirst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.854165642 UTC

[section ""data" . Data.Monoid.$fShowFirst4_closure" {
     Data.Monoid.$fShowFirst4_closure:
         const Data.Monoid.$fShowFirst4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fShowFirst4_entry() //  [R1]
         { info_tbl: [(c6IbL,
                       label: Data.Monoid.$fShowFirst4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IbL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IbM; else goto c6IbN;
       c6IbM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IbN: // global
           (_c6IbI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6IbI::I64 == 0) goto c6IbK; else goto c6IbJ;
       c6IbK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6IbJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6IbI::I64;
           R3 = Data.Monoid.$fReadFirst3_closure;
           R2 = GHC.Show.$fShowMaybe4_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.856010346 UTC

[section ""data" . Data.Monoid.$fShowLast_$cshow_closure" {
     Data.Monoid.$fShowLast_$cshow_closure:
         const Data.Monoid.$fShowLast_$cshow_info;
         const 0;
 },
 sat_s6I2J_entry() //  [R1]
         { info_tbl: [(c6Ica,
                       label: sat_s6I2J_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ica: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6Icb; else goto c6Icc;
       c6Icb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Icc: // global
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Show.appPrec1_closure;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = Data.Monoid.$fReadFirst3_closure;
           Sp = Sp - 32;
           call GHC.Show.showsPrec_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_s6I2K_entry() //  [R1]
         { info_tbl: [(c6Ich,
                       label: sat_s6I2K_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ich: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6Ici; else goto c6Icj;
       c6Ici: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Icj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6Ic0_info;
           _s6I2F::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s6I2F::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6Icp; else goto c6Ic1;
       u6Icp: // global
           call _c6Ic0(R1) args: 0, res: 0, upd: 0;
       c6Ic1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6Ic0() //  [R1]
         { info_tbl: [(c6Ic0,
                       label: block_c6Ic0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ic0: // global
           if (R1 & 7 == 1) goto c6Ice; else goto c6Icf;
       c6Ice: // global
           R1 = Data.Monoid.$fShowFirst4_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c6Icf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Ico; else goto c6Icn;
       c6Ico: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6Icn: // global
           _s6I2I::P64 = P64[R1 + 6];
           I64[Hp - 24] = sat_s6I2J_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _s6I2I::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.$fShowMaybe1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2L_entry() //  [R1]
         { info_tbl: [(c6Icq,
                       label: sat_s6I2L_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Icq: // global
           _s6I2L::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6Icr; else goto c6Ics;
       c6Ics: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Icu; else goto c6Ict;
       c6Icu: // global
           HpAlloc = 32;
           goto c6Icr;
       c6Icr: // global
           R1 = _s6I2L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Ict: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I2L::P64;
           _s6I2F::P64 = P64[_s6I2L::P64 + 16];
           _s6I2G::P64 = P64[_s6I2L::P64 + 24];
           I64[Hp - 24] = sat_s6I2K_info;
           P64[Hp - 8] = _s6I2F::P64;
           P64[Hp] = _s6I2G::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fShowLast_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6Icv,
                       label: Data.Monoid.$fShowLast_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Icv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Icz; else goto c6Icy;
       c6Icz: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowLast_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Icy: // global
           I64[Hp - 24] = sat_s6I2L_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.858583353 UTC

[section ""data" . Data.Monoid.$fShowLast_$cshowList_closure" {
     Data.Monoid.$fShowLast_$cshowList_closure:
         const Data.Monoid.$fShowLast_$cshowList_info;
         const 0;
 },
 sat_s6I2Q_entry() //  [R1, R2]
         { info_tbl: [(c6IcJ,
                       label: sat_s6I2Q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IcJ: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Monoid.$w$cshowsPrec1_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fShowLast_$cshowList_entry() //  [R2, R3, R4]
         { info_tbl: [(c6IcM,
                       label: Data.Monoid.$fShowLast_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IcM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6IcQ; else goto c6IcP;
       c6IcQ: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowLast_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6IcP: // global
           I64[Hp - 8] = sat_s6I2Q_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.860145641 UTC

[section ""data" . Data.Monoid.$fShowLast_closure" {
     Data.Monoid.$fShowLast_closure:
         const Data.Monoid.$fShowLast_info;
         const 0;
 },
 sat_s6I2U_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Id0,
                       label: sat_s6I2U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Id0: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fShowLast_$cshowList_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I2T_entry() //  [R1, R2]
         { info_tbl: [(c6Id8,
                       label: sat_s6I2T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Id8: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Monoid.$fShowLast_$cshow_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I2S_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Idg,
                       label: sat_s6I2S_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Idg: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fShowLast_$cshowsPrec_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fShowLast_entry() //  [R2]
         { info_tbl: [(c6Idk,
                       label: Data.Monoid.$fShowLast_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Idk: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6Ido; else goto c6Idn;
       c6Ido: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Monoid.$fShowLast_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Idn: // global
           I64[Hp - 72] = sat_s6I2U_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6I2T_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6I2S_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.861655403 UTC

[section ""cstring" . Data.Monoid.$fReadLast5_bytes" {
     Data.Monoid.$fReadLast5_bytes:
         I8[] [76,97,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.862456057 UTC

[section ""data" . Data.Monoid.$fReadLast4_closure" {
     Data.Monoid.$fReadLast4_closure:
         const Data.Monoid.$fReadLast4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadLast4_entry() //  [R1]
         { info_tbl: [(c6Idv,
                       label: Data.Monoid.$fReadLast4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Idv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Idw; else goto c6Idx;
       c6Idw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Idx: // global
           (_c6Ids::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6Ids::I64 == 0) goto c6Idu; else goto c6Idt;
       c6Idu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6Idt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6Ids::I64;
           R2 = Data.Monoid.$fReadLast5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.863405448 UTC

[section ""data" . Data.Monoid.$fReadLast_lexeme_closure" {
     Data.Monoid.$fReadLast_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Monoid.$fReadLast4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.86397981 UTC

[section ""cstring" . Data.Monoid.$fReadFirst9_bytes" {
     Data.Monoid.$fReadFirst9_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.864725835 UTC

[section ""data" . Data.Monoid.$fReadFirst8_closure" {
     Data.Monoid.$fReadFirst8_closure:
         const Data.Monoid.$fReadFirst8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadFirst8_entry() //  [R1]
         { info_tbl: [(c6IdE,
                       label: Data.Monoid.$fReadFirst8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IdE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IdF; else goto c6IdG;
       c6IdF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IdG: // global
           (_c6IdB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6IdB::I64 == 0) goto c6IdD; else goto c6IdC;
       c6IdD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6IdC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6IdB::I64;
           R2 = Data.Monoid.$fReadFirst9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.86574148 UTC

[section ""data" . Data.Monoid.$fReadFirst_lexeme_closure" {
     Data.Monoid.$fReadFirst_lexeme_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Monoid.$fReadFirst8_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.866295779 UTC

[section ""cstring" . Data.Monoid.$fReadLast3_bytes" {
     Data.Monoid.$fReadLast3_bytes:
         I8[] [103,101,116,76,97,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.867060199 UTC

[section ""data" . Data.Monoid.$fReadLast2_closure" {
     Data.Monoid.$fReadLast2_closure:
         const Data.Monoid.$fReadLast2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadLast2_entry() //  [R1]
         { info_tbl: [(c6IdN,
                       label: Data.Monoid.$fReadLast2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IdN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IdO; else goto c6IdP;
       c6IdO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IdP: // global
           (_c6IdK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6IdK::I64 == 0) goto c6IdM; else goto c6IdL;
       c6IdM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6IdL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6IdK::I64;
           R2 = Data.Monoid.$fReadLast3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.867992549 UTC

[section ""data" . Data.Monoid.$fReadFirst5_closure" {
     Data.Monoid.$fReadFirst5_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.868608354 UTC

[section ""data" . Data.Monoid.$fReadFirst2_closure" {
     Data.Monoid.$fReadFirst2_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Monoid.$fReadFirst3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.871017798 UTC

[section ""data" . Data.Monoid.$fReadLast1_closure" {
     Data.Monoid.$fReadLast1_closure:
         const Data.Monoid.$fReadLast1_info;
         const 0;
 },
 ds_s6I2Y_entry() //  [R1, R3]
         { info_tbl: [(c6IdZ,
                       label: ds_s6I2Y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IdZ: // global
           R4 = R3;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = P64[R1 + 6];
           call GHC.Read.$fReadMaybe1_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3a_entry() //  [R1]
         { info_tbl: [(c6IeA,
                       label: sat_s6I3a_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IeA: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3d_entry() //  [R1, R2]
         { info_tbl: [(c6IeG,
                       label: sat_s6I3d_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IeG: // global
           _s6I38::P64 = R2;
           _s6I3d::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6IeH; else goto c6IeI;
       c6IeI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IeK; else goto c6IeJ;
       c6IeK: // global
           HpAlloc = 24;
           goto c6IeH;
       c6IeH: // global
           R2 = _s6I38::P64;
           R1 = _s6I3d::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IeJ: // global
           _s6I32::P64 = P64[_s6I3d::P64 + 7];
           I64[Hp - 16] = sat_s6I3a_info;
           P64[Hp - 8] = _s6I32::P64;
           P64[Hp] = _s6I38::P64;
           I64[Sp - 8] = block_c6IeD_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadFirst2_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6IeD() //  [R1]
         { info_tbl: [(c6IeD,
                       label: block_c6IeD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IeD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6IeN; else goto c6IeM;
       c6IeN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6IeM: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3e_entry() //  [R1, R2]
         { info_tbl: [(c6IeO,
                       label: sat_s6I3e_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IeO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6IeS; else goto c6IeR;
       c6IeS: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IeR: // global
           _s6I2Y::P64 = P64[R1 + 7];
           _s6I32::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6I3d_info;
           P64[Hp] = _s6I32::P64;
           R5 = Hp - 7;
           R4 = Data.Monoid.$fReadFirst5_closure+1;
           R3 = _s6I2Y::P64;
           R2 = Data.Monoid.$fReadLast2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3h_entry() //  [R1, R2]
         { info_tbl: [(c6IeW,
                       label: sat_s6I3h_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IeW: // global
           _s6I36::P64 = R2;
           _s6I3h::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6IeX; else goto c6IeY;
       c6IeY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6If0; else goto c6IeZ;
       c6If0: // global
           HpAlloc = 24;
           goto c6IeX;
       c6IeX: // global
           R2 = _s6I36::P64;
           R1 = _s6I3h::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IeZ: // global
           _s6I2Y::P64 = P64[_s6I3h::P64 + 7];
           _s6I32::P64 = P64[_s6I3h::P64 + 15];
           I64[Hp - 16] = sat_s6I3e_info;
           P64[Hp - 8] = _s6I2Y::P64;
           P64[Hp] = _s6I32::P64;
           I64[Sp - 8] = block_c6IeT_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadFirst_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6IeT() //  [R1]
         { info_tbl: [(c6IeT,
                       label: block_c6IeT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IeT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6If3; else goto c6If2;
       c6If3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6If2: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3k_entry() //  [R1, R2, R3]
         { info_tbl: [(c6If4,
                       label: sat_s6I3k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6If4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6If5; else goto c6If6;
       c6If5: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6If6: // global
           I64[Sp - 24] = block_c6Ie7_info;
           _s6I2Y::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6I2Y::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6Ifj; else goto c6Ie8;
       u6Ifj: // global
           call _c6Ie7(R1) args: 0, res: 0, upd: 0;
       c6Ie8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Ie7() //  [R1]
         { info_tbl: [(c6Ie7,
                       label: block_c6Ie7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ie7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6If9; else goto c6If8;
       c6If9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6If8: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6Ifb; else goto c6Iff;
       c6Ifb: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6Iff: // global
           I64[Hp - 16] = sat_s6I3h_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6Ifc_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadLast_lexeme_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Ifc() //  [R1]
         { info_tbl: [(c6Ifc,
                       label: block_c6Ifc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ifc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Ifi; else goto c6Ifh;
       c6Ifi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Ifh: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadLast1_entry() //  [R2, R3, R4]
         { info_tbl: [(c6Ifk,
                       label: Data.Monoid.$fReadLast1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ifk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Ifo; else goto c6Ifn;
       c6Ifo: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fReadLast1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Ifn: // global
           I64[Hp - 24] = ds_s6I2Y_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6I3k_info;
           P64[Hp] = Hp - 22;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.875311285 UTC

[section ""data" . Data.Monoid.$fReadLast_$creadsPrec_closure" {
     Data.Monoid.$fReadLast_$creadsPrec_closure:
         const Data.Monoid.$fReadLast_$creadsPrec_info;
         const 0;
 },
 sat_s6I3n_entry() //  [R1]
         { info_tbl: [(c6Ifx,
                       label: sat_s6I3n_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ifx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Ify; else goto c6Ifz;
       c6Ify: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Ifz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadLast1_entry(R4,
                                              R3,
                                              R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fReadLast_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c6IfA,
                       label: Data.Monoid.$fReadLast_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IfA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6IfE; else goto c6IfD;
       c6IfE: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fReadLast_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6IfD: // global
           I64[Hp - 24] = sat_s6I3n_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.876766923 UTC

[section ""data" . Data.Monoid.$fReadLast_$creadListPrec_closure" {
     Data.Monoid.$fReadLast_$creadListPrec_closure:
         const Data.Monoid.$fReadLast_$creadListPrec_info;
         const 0;
 },
 sat_s6I3p_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IfO,
                       label: sat_s6I3p_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IfO: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadLast1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadLast_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6IfR,
                       label: Data.Monoid.$fReadLast_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IfR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6IfV; else goto c6IfU;
       c6IfV: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Monoid.$fReadLast_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IfU: // global
           I64[Hp - 8] = sat_s6I3p_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.878411878 UTC

[section ""data" . Data.Monoid.$fReadLast_$creadList_closure" {
     Data.Monoid.$fReadLast_$creadList_closure:
         const Data.Monoid.$fReadLast_$creadList_info;
         const 0;
 },
 sat_s6I3r_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Ig9,
                       label: sat_s6I3r_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ig9: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadLast1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3s_entry() //  [R1]
         { info_tbl: [(c6Igc,
                       label: sat_s6I3s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Igc: // global
           _s6I3s::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6Igd; else goto c6Ige;
       c6Ige: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Igg; else goto c6Igf;
       c6Igg: // global
           HpAlloc = 16;
           goto c6Igd;
       c6Igd: // global
           R1 = _s6I3s::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Igf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I3s::P64;
           _s6I3q::P64 = P64[_s6I3s::P64 + 16];
           I64[Hp - 8] = sat_s6I3r_info;
           P64[Hp] = _s6I3q::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fReadLast_$creadList_entry() //  [R2]
         { info_tbl: [(c6Igh,
                       label: Data.Monoid.$fReadLast_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Igh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Igl; else goto c6Igk;
       c6Igl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Monoid.$fReadLast_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Igk: // global
           I64[Hp - 16] = sat_s6I3s_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.880462956 UTC

[section ""data" . Data.Monoid.$fReadLast_closure" {
     Data.Monoid.$fReadLast_closure:
         const Data.Monoid.$fReadLast_info;
         const 0;
 },
 sat_s6I3x_entry() //  [R1]
         { info_tbl: [(c6Igu,
                       label: sat_s6I3x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Igu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Igv; else goto c6Igw;
       c6Igv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Igw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadLast_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I3w_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IgC,
                       label: sat_s6I3w_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IgC: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadLast1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3v_entry() //  [R1]
         { info_tbl: [(c6IgJ,
                       label: sat_s6I3v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IgJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IgK; else goto c6IgL;
       c6IgK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IgL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadLast_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I3u_entry() //  [R1, R2]
         { info_tbl: [(c6IgR,
                       label: sat_s6I3u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IgR: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Monoid.$fReadLast_$creadsPrec_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadLast_entry() //  [R2]
         { info_tbl: [(c6IgV,
                       label: Data.Monoid.$fReadLast_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IgV: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c6IgZ; else goto c6IgY;
       c6IgZ: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Monoid.$fReadLast_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IgY: // global
           I64[Hp - 112] = sat_s6I3x_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6I3w_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s6I3v_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s6I3u_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 112;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.883067159 UTC

[section ""data" . Data.Monoid.$fEqLast_closure" {
     Data.Monoid.$fEqLast_closure:
         const Data.Monoid.$fEqLast_info;
 },
 sat_s6I3A_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Ih9,
                       label: sat_s6I3A_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ih9: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c/=_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3z_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Ihh,
                       label: sat_s6I3z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ihh: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fEqLast_entry() //  [R2]
         { info_tbl: [(c6Ihl,
                       label: Data.Monoid.$fEqLast_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ihl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6Ihp; else goto c6Iho;
       c6Ihp: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Monoid.$fEqLast_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Iho: // global
           I64[Hp - 48] = sat_s6I3A_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s6I3z_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.884642051 UTC

[section ""data" . Data.Monoid.$fOrdLast_$cp1Ord_closure" {
     Data.Monoid.$fOrdLast_$cp1Ord_closure:
         const Data.Monoid.$fOrdLast_$cp1Ord_info;
 },
 sat_s6I3C_entry() //  [R1]
         { info_tbl: [(c6Ihy,
                       label: sat_s6I3C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ihy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Ihz; else goto c6IhA;
       c6Ihz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IhA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fOrdLast_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6IhB,
                       label: Data.Monoid.$fOrdLast_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IhB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IhF; else goto c6IhE;
       c6IhF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Monoid.$fOrdLast_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IhE: // global
           I64[Hp - 16] = sat_s6I3C_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Monoid.$fEqLast_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.886931759 UTC

[section ""data" . Data.Monoid.$fOrdLast_closure" {
     Data.Monoid.$fOrdLast_closure:
         const Data.Monoid.$fOrdLast_info;
 },
 sat_s6I3N_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IhP,
                       label: sat_s6I3N_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IhP: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmin_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3M_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IhX,
                       label: sat_s6I3M_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IhX: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmax_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3L_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Ii5,
                       label: sat_s6I3L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ii5: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c>=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3K_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Iid,
                       label: sat_s6I3K_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iid: // global
           R4 = R2;
           R3 = R3;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3H_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Iil,
                       label: sat_s6I3H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iil: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3G_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Iit,
                       label: sat_s6I3G_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iit: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3F_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IiB,
                       label: sat_s6I3F_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IiB: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3E_entry() //  [R1]
         { info_tbl: [(c6IiI,
                       label: sat_s6I3E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IiI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IiJ; else goto c6IiK;
       c6IiJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IiK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fOrdLast_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fOrdLast_entry() //  [R2]
         { info_tbl: [(c6IiM,
                       label: Data.Monoid.$fOrdLast_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IiM: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto c6IiQ; else goto c6IiP;
       c6IiQ: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = Data.Monoid.$fOrdLast_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IiP: // global
           I64[Hp - 200] = sat_s6I3N_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6I3M_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s6I3L_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s6I3K_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6I3H_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s6I3G_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6I3F_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6I3E_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.889583371 UTC

[section ""data" . Data.Monoid.$fFunctorFirst_closure" {
     Data.Monoid.$fFunctorFirst_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fApplicativeMaybe_$cfmap_closure+2;
         const GHC.Base.$fFunctorMaybe_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.890239668 UTC

[section ""data" . Data.Monoid.$fApplicativeFirst_closure" {
     Data.Monoid.$fApplicativeFirst_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Monoid.$fFunctorFirst_closure+1;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fApplicativeMaybe_$c<*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$cliftA2_closure+3;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c<*_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.89086921 UTC

[section ""data" . Data.Monoid.$fMonadFirst_closure" {
     Data.Monoid.$fMonadFirst_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Monoid.$fApplicativeFirst_closure+1;
         const GHC.Base.$fMonadMaybe_$c>>=_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fMonadMaybe_$cfail_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.891660684 UTC

[section ""data" . Data.Monoid.$fGeneric1First1_closure" {
     Data.Monoid.$fGeneric1First1_closure:
         const Data.Monoid.$fGeneric1First1_info;
 },
 Data.Monoid.$fGeneric1First1_entry() //  [R2]
         { info_tbl: [(c6IiV,
                       label: Data.Monoid.$fGeneric1First1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IiV: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.892550808 UTC

[section ""data" . Data.Monoid.$fGeneric1First2_closure" {
     Data.Monoid.$fGeneric1First2_closure:
         const Data.Monoid.$fGeneric1First2_info;
 },
 Data.Monoid.$fGeneric1First2_entry() //  [R2]
         { info_tbl: [(c6Ij2,
                       label: Data.Monoid.$fGeneric1First2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ij2: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.893570478 UTC

[section ""data" . Data.Monoid.$fGeneric1First_closure" {
     Data.Monoid.$fGeneric1First_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Monoid.$fGeneric1First2_closure+1;
         const Data.Monoid.$fGeneric1First1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.894321443 UTC

[section ""data" . Data.Monoid.$fGenericFirst1_closure" {
     Data.Monoid.$fGenericFirst1_closure:
         const Data.Monoid.$fGenericFirst1_info;
 },
 Data.Monoid.$fGenericFirst1_entry() //  [R2]
         { info_tbl: [(c6Ij9,
                       label: Data.Monoid.$fGenericFirst1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ij9: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.895182228 UTC

[section ""data" . Data.Monoid.$fGenericFirst2_closure" {
     Data.Monoid.$fGenericFirst2_closure:
         const Data.Monoid.$fGenericFirst2_info;
 },
 Data.Monoid.$fGenericFirst2_entry() //  [R2]
         { info_tbl: [(c6Ijg,
                       label: Data.Monoid.$fGenericFirst2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ijg: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.895992355 UTC

[section ""data" . Data.Monoid.$fGenericFirst_closure" {
     Data.Monoid.$fGenericFirst_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Monoid.$fGenericFirst2_closure+1;
         const Data.Monoid.$fGenericFirst1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.896629371 UTC

[section ""cstring" . Data.Monoid.$fShowFirst3_bytes" {
     Data.Monoid.$fShowFirst3_bytes:
         I8[] [70,105,114,115,116,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.897220616 UTC

[section ""cstring" . Data.Monoid.$fShowFirst2_bytes" {
     Data.Monoid.$fShowFirst2_bytes:
         I8[] [103,101,116,70,105,114,115,116,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.899760681 UTC

[section ""data" . Data.Monoid.$w$cshowsPrec_closure" {
     Data.Monoid.$w$cshowsPrec_closure:
         const Data.Monoid.$w$cshowsPrec_info;
         const 0;
 },
 f_s6I3V_entry() //  [R1]
         { info_tbl: [(c6Ijr,
                       label: f_s6I3V_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ijr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Ijs; else goto c6Ijt;
       c6Ijs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Ijt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = Data.Monoid.$fShowFirst1_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.$fShowMaybe_$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I3Y_entry() //  [R1]
         { info_tbl: [(c6IjO,
                       label: sat_s6I3Y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IjO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IjP; else goto c6IjQ;
       c6IjP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IjQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Monoid.$fReadFirst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I3Z_entry() //  [R1]
         { info_tbl: [(c6IjR,
                       label: sat_s6I3Z_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IjR: // global
           _s6I3Z::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IjS; else goto c6IjT;
       c6IjT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IjV; else goto c6IjU;
       c6IjV: // global
           HpAlloc = 24;
           goto c6IjS;
       c6IjS: // global
           R1 = _s6I3Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IjU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I3Z::P64;
           _s6I3V::P64 = P64[_s6I3Z::P64 + 16];
           _s6I3X::P64 = P64[_s6I3Z::P64 + 24];
           I64[Hp - 16] = sat_s6I3Y_info;
           P64[Hp] = _s6I3X::P64;
           R2 = Hp - 16;
           R1 = _s6I3V::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I40_entry() //  [R1]
         { info_tbl: [(c6IjW,
                       label: sat_s6I40_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IjW: // global
           _s6I40::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IjX; else goto c6IjY;
       c6IjY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Ik0; else goto c6IjZ;
       c6Ik0: // global
           HpAlloc = 32;
           goto c6IjX;
       c6IjX: // global
           R1 = _s6I40::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IjZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I40::P64;
           _s6I3V::P64 = P64[_s6I40::P64 + 16];
           _s6I3X::P64 = P64[_s6I40::P64 + 24];
           I64[Hp - 24] = sat_s6I3Z_info;
           P64[Hp - 8] = _s6I3V::P64;
           P64[Hp] = _s6I3X::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I41_entry() //  [R1, R2]
         { info_tbl: [(c6Ik1,
                       label: sat_s6I41_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ik1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Ik5; else goto c6Ik4;
       c6Ik5: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Ik4: // global
           _s6I3V::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6I40_info;
           P64[Hp - 8] = _s6I3V::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I44_entry() //  [R1]
         { info_tbl: [(c6Ikt,
                       label: sat_s6I44_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ikt: // global
           _s6I44::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6Iku; else goto c6Ikv;
       c6Ikv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Ikx; else goto c6Ikw;
       c6Ikx: // global
           HpAlloc = 24;
           goto c6Iku;
       c6Iku: // global
           R1 = _s6I44::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Ikw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I44::P64;
           _s6I42::P64 = P64[_s6I44::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6I42::P64;
           R3 = Hp - 14;
           R2 = Data.Monoid.$fReadFirst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I45_entry() //  [R1]
         { info_tbl: [(c6Iky,
                       label: sat_s6I45_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iky: // global
           _s6I45::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6Ikz; else goto c6IkA;
       c6IkA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IkC; else goto c6IkB;
       c6IkC: // global
           HpAlloc = 24;
           goto c6Ikz;
       c6Ikz: // global
           R1 = _s6I45::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IkB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I45::P64;
           _s6I3V::P64 = P64[_s6I45::P64 + 16];
           _s6I42::P64 = P64[_s6I45::P64 + 24];
           I64[Hp - 16] = sat_s6I44_info;
           P64[Hp] = _s6I42::P64;
           R2 = Hp - 16;
           R1 = _s6I3V::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I46_entry() //  [R1]
         { info_tbl: [(c6IkD,
                       label: sat_s6I46_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IkD: // global
           _s6I46::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IkE; else goto c6IkF;
       c6IkF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6IkH; else goto c6IkG;
       c6IkH: // global
           HpAlloc = 32;
           goto c6IkE;
       c6IkE: // global
           R1 = _s6I46::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IkG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I46::P64;
           _s6I3V::P64 = P64[_s6I46::P64 + 16];
           _s6I42::P64 = P64[_s6I46::P64 + 24];
           I64[Hp - 24] = sat_s6I45_info;
           P64[Hp - 8] = _s6I3V::P64;
           P64[Hp] = _s6I42::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I47_entry() //  [R1]
         { info_tbl: [(c6IkI,
                       label: sat_s6I47_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IkI: // global
           _s6I47::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IkJ; else goto c6IkK;
       c6IkK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6IkM; else goto c6IkL;
       c6IkM: // global
           HpAlloc = 32;
           goto c6IkJ;
       c6IkJ: // global
           R1 = _s6I47::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IkL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I47::P64;
           _s6I3V::P64 = P64[_s6I47::P64 + 16];
           _s6I42::P64 = P64[_s6I47::P64 + 24];
           I64[Hp - 24] = sat_s6I46_info;
           P64[Hp - 8] = _s6I3V::P64;
           P64[Hp] = _s6I42::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I48_entry() //  [R1, R2]
         { info_tbl: [(c6IkO,
                       label: sat_s6I48_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IkO: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6IkS; else goto c6IkR;
       c6IkS: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IkR: // global
           _s6I3V::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6I47_info;
           P64[Hp - 32] = _s6I3V::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c6IkW,
                       label: Data.Monoid.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IkW: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6Il0; else goto c6IkZ;
       c6Il0: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6IkZ: // global
           I64[Hp - 40] = f_s6I3V_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6Ijn::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6IkU; else goto c6IkV;
       c6IkU: // global
           I64[Hp - 8] = sat_s6I41_info;
           P64[Hp] = _c6Ijn::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6IkV: // global
           I64[Hp - 8] = sat_s6I48_info;
           P64[Hp] = _c6Ijn::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.907274029 UTC

[section ""data" . Data.Monoid.$fShowFirst_$cshowsPrec_closure" {
     Data.Monoid.$fShowFirst_$cshowsPrec_closure:
         const Data.Monoid.$fShowFirst_$cshowsPrec_info;
         const 0;
 },
 Data.Monoid.$fShowFirst_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c6Il8,
                       label: Data.Monoid.$fShowFirst_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Il8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6Il9; else goto c6Ila;
       c6Il9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowFirst_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Ila: // global
           I64[Sp - 24] = block_c6Il5_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6Ile; else goto c6Il6;
       u6Ile: // global
           call _c6Il5(R1) args: 0, res: 0, upd: 0;
       c6Il6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Il5() //  [R1]
         { info_tbl: [(c6Il5,
                       label: block_c6Il5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Il5: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Monoid.$w$cshowsPrec_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.909356103 UTC

[section ""data" . Data.Monoid.$fShowFirst_$cshow_closure" {
     Data.Monoid.$fShowFirst_$cshow_closure:
         const Data.Monoid.$fShowFirst_$cshow_info;
         const 0;
 },
 sat_s6I4i_entry() //  [R1]
         { info_tbl: [(c6IlB,
                       label: sat_s6I4i_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IlB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6IlC; else goto c6IlD;
       c6IlC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IlD: // global
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Show.appPrec1_closure;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = Data.Monoid.$fReadFirst3_closure;
           Sp = Sp - 32;
           call GHC.Show.showsPrec_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_s6I4j_entry() //  [R1]
         { info_tbl: [(c6IlI,
                       label: sat_s6I4j_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IlI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6IlJ; else goto c6IlK;
       c6IlJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IlK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6Ilr_info;
           _s6I4e::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s6I4e::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6IlQ; else goto c6Ils;
       u6IlQ: // global
           call _c6Ilr(R1) args: 0, res: 0, upd: 0;
       c6Ils: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6Ilr() //  [R1]
         { info_tbl: [(c6Ilr,
                       label: block_c6Ilr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ilr: // global
           if (R1 & 7 == 1) goto c6IlF; else goto c6IlG;
       c6IlF: // global
           R1 = Data.Monoid.$fShowFirst4_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c6IlG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6IlP; else goto c6IlO;
       c6IlP: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6IlO: // global
           _s6I4h::P64 = P64[R1 + 6];
           I64[Hp - 24] = sat_s6I4i_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _s6I4h::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.$fShowMaybe1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I4k_entry() //  [R1]
         { info_tbl: [(c6IlR,
                       label: sat_s6I4k_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IlR: // global
           _s6I4k::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IlS; else goto c6IlT;
       c6IlT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6IlV; else goto c6IlU;
       c6IlV: // global
           HpAlloc = 32;
           goto c6IlS;
       c6IlS: // global
           R1 = _s6I4k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IlU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I4k::P64;
           _s6I4e::P64 = P64[_s6I4k::P64 + 16];
           _s6I4f::P64 = P64[_s6I4k::P64 + 24];
           I64[Hp - 24] = sat_s6I4j_info;
           P64[Hp - 8] = _s6I4e::P64;
           P64[Hp] = _s6I4f::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fShowFirst_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6IlW,
                       label: Data.Monoid.$fShowFirst_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IlW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Im0; else goto c6IlZ;
       c6Im0: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowFirst_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6IlZ: // global
           I64[Hp - 24] = sat_s6I4k_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.911923165 UTC

[section ""data" . Data.Monoid.$fShowFirst_$cshowList_closure" {
     Data.Monoid.$fShowFirst_$cshowList_closure:
         const Data.Monoid.$fShowFirst_$cshowList_info;
         const 0;
 },
 sat_s6I4p_entry() //  [R1, R2]
         { info_tbl: [(c6Ima,
                       label: sat_s6I4p_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ima: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Monoid.$w$cshowsPrec_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fShowFirst_$cshowList_entry() //  [R2, R3, R4]
         { info_tbl: [(c6Imd,
                       label: Data.Monoid.$fShowFirst_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Imd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Imh; else goto c6Img;
       c6Imh: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowFirst_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Img: // global
           I64[Hp - 8] = sat_s6I4p_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.913585616 UTC

[section ""data" . Data.Monoid.$fShowFirst_closure" {
     Data.Monoid.$fShowFirst_closure:
         const Data.Monoid.$fShowFirst_info;
         const 0;
 },
 sat_s6I4t_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Imr,
                       label: sat_s6I4t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Imr: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fShowFirst_$cshowList_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I4s_entry() //  [R1, R2]
         { info_tbl: [(c6Imz,
                       label: sat_s6I4s_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Imz: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Monoid.$fShowFirst_$cshow_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I4r_entry() //  [R1, R2, R3]
         { info_tbl: [(c6ImH,
                       label: sat_s6I4r_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ImH: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fShowFirst_$cshowsPrec_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fShowFirst_entry() //  [R2]
         { info_tbl: [(c6ImL,
                       label: Data.Monoid.$fShowFirst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ImL: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6ImP; else goto c6ImO;
       c6ImP: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Monoid.$fShowFirst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6ImO: // global
           I64[Hp - 72] = sat_s6I4t_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6I4s_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6I4r_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.915042172 UTC

[section ""cstring" . Data.Monoid.$fReadFirst11_bytes" {
     Data.Monoid.$fReadFirst11_bytes:
         I8[] [70,105,114,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.915830323 UTC

[section ""data" . Data.Monoid.$fReadFirst10_closure" {
     Data.Monoid.$fReadFirst10_closure:
         const Data.Monoid.$fReadFirst10_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadFirst10_entry() //  [R1]
         { info_tbl: [(c6ImW,
                       label: Data.Monoid.$fReadFirst10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ImW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ImX; else goto c6ImY;
       c6ImX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ImY: // global
           (_c6ImT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6ImT::I64 == 0) goto c6ImV; else goto c6ImU;
       c6ImV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6ImU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6ImT::I64;
           R2 = Data.Monoid.$fReadFirst11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.916769266 UTC

[section ""data" . Data.Monoid.$fReadFirst_lexeme1_closure" {
     Data.Monoid.$fReadFirst_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Monoid.$fReadFirst10_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.917398641 UTC

[section ""cstring" . Data.Monoid.$fReadFirst7_bytes" {
     Data.Monoid.$fReadFirst7_bytes:
         I8[] [103,101,116,70,105,114,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.918147229 UTC

[section ""data" . Data.Monoid.$fReadFirst6_closure" {
     Data.Monoid.$fReadFirst6_closure:
         const Data.Monoid.$fReadFirst6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadFirst6_entry() //  [R1]
         { info_tbl: [(c6In5,
                       label: Data.Monoid.$fReadFirst6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6In5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6In6; else goto c6In7;
       c6In6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6In7: // global
           (_c6In2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6In2::I64 == 0) goto c6In4; else goto c6In3;
       c6In4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6In3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6In2::I64;
           R2 = Data.Monoid.$fReadFirst7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.920817145 UTC

[section ""data" . Data.Monoid.$fReadFirst1_closure" {
     Data.Monoid.$fReadFirst1_closure:
         const Data.Monoid.$fReadFirst1_info;
         const 0;
 },
 ds_s6I4x_entry() //  [R1, R3]
         { info_tbl: [(c6Inh,
                       label: ds_s6I4x_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Inh: // global
           R4 = R3;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = P64[R1 + 6];
           call GHC.Read.$fReadMaybe1_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I4J_entry() //  [R1]
         { info_tbl: [(c6InS,
                       label: sat_s6I4J_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6InS: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I4M_entry() //  [R1, R2]
         { info_tbl: [(c6InY,
                       label: sat_s6I4M_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6InY: // global
           _s6I4H::P64 = R2;
           _s6I4M::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6InZ; else goto c6Io0;
       c6Io0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Io2; else goto c6Io1;
       c6Io2: // global
           HpAlloc = 24;
           goto c6InZ;
       c6InZ: // global
           R2 = _s6I4H::P64;
           R1 = _s6I4M::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Io1: // global
           _s6I4B::P64 = P64[_s6I4M::P64 + 7];
           I64[Hp - 16] = sat_s6I4J_info;
           P64[Hp - 8] = _s6I4B::P64;
           P64[Hp] = _s6I4H::P64;
           I64[Sp - 8] = block_c6InV_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadFirst2_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6InV() //  [R1]
         { info_tbl: [(c6InV,
                       label: block_c6InV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6InV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Io5; else goto c6Io4;
       c6Io5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Io4: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I4N_entry() //  [R1, R2]
         { info_tbl: [(c6Io6,
                       label: sat_s6I4N_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Io6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Ioa; else goto c6Io9;
       c6Ioa: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Io9: // global
           _s6I4x::P64 = P64[R1 + 7];
           _s6I4B::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6I4M_info;
           P64[Hp] = _s6I4B::P64;
           R5 = Hp - 7;
           R4 = Data.Monoid.$fReadFirst5_closure+1;
           R3 = _s6I4x::P64;
           R2 = Data.Monoid.$fReadFirst6_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I4Q_entry() //  [R1, R2]
         { info_tbl: [(c6Ioe,
                       label: sat_s6I4Q_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ioe: // global
           _s6I4F::P64 = R2;
           _s6I4Q::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6Iof; else goto c6Iog;
       c6Iog: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Ioi; else goto c6Ioh;
       c6Ioi: // global
           HpAlloc = 24;
           goto c6Iof;
       c6Iof: // global
           R2 = _s6I4F::P64;
           R1 = _s6I4Q::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Ioh: // global
           _s6I4x::P64 = P64[_s6I4Q::P64 + 7];
           _s6I4B::P64 = P64[_s6I4Q::P64 + 15];
           I64[Hp - 16] = sat_s6I4N_info;
           P64[Hp - 8] = _s6I4x::P64;
           P64[Hp] = _s6I4B::P64;
           I64[Sp - 8] = block_c6Iob_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadFirst_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Iob() //  [R1]
         { info_tbl: [(c6Iob,
                       label: block_c6Iob_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iob: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Iol; else goto c6Iok;
       c6Iol: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Iok: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I4T_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Iom,
                       label: sat_s6I4T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iom: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6Ion; else goto c6Ioo;
       c6Ion: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Ioo: // global
           I64[Sp - 24] = block_c6Inp_info;
           _s6I4x::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6I4x::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6IoB; else goto c6Inq;
       u6IoB: // global
           call _c6Inp(R1) args: 0, res: 0, upd: 0;
       c6Inq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Inp() //  [R1]
         { info_tbl: [(c6Inp,
                       label: block_c6Inp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Inp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Ior; else goto c6Ioq;
       c6Ior: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Ioq: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6Iot; else goto c6Iox;
       c6Iot: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6Iox: // global
           I64[Hp - 16] = sat_s6I4Q_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6Iou_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadFirst_lexeme1_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Iou() //  [R1]
         { info_tbl: [(c6Iou,
                       label: block_c6Iou_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iou: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6IoA; else goto c6Ioz;
       c6IoA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Ioz: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadFirst1_entry() //  [R2, R3, R4]
         { info_tbl: [(c6IoC,
                       label: Data.Monoid.$fReadFirst1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IoC: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6IoG; else goto c6IoF;
       c6IoG: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fReadFirst1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6IoF: // global
           I64[Hp - 24] = ds_s6I4x_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6I4T_info;
           P64[Hp] = Hp - 22;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.925387032 UTC

[section ""data" . Data.Monoid.$fReadFirst_$creadsPrec_closure" {
     Data.Monoid.$fReadFirst_$creadsPrec_closure:
         const Data.Monoid.$fReadFirst_$creadsPrec_info;
         const 0;
 },
 sat_s6I4W_entry() //  [R1]
         { info_tbl: [(c6IoP,
                       label: sat_s6I4W_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IoP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IoQ; else goto c6IoR;
       c6IoQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IoR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadFirst1_entry(R4,
                                               R3,
                                               R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fReadFirst_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c6IoS,
                       label: Data.Monoid.$fReadFirst_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IoS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6IoW; else goto c6IoV;
       c6IoW: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fReadFirst_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6IoV: // global
           I64[Hp - 24] = sat_s6I4W_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.926799882 UTC

[section ""data" . Data.Monoid.$fReadFirst_$creadListPrec_closure" {
     Data.Monoid.$fReadFirst_$creadListPrec_closure:
         const Data.Monoid.$fReadFirst_$creadListPrec_info;
         const 0;
 },
 sat_s6I4Y_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Ip6,
                       label: sat_s6I4Y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ip6: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadFirst1_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadFirst_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6Ip9,
                       label: Data.Monoid.$fReadFirst_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ip9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Ipd; else goto c6Ipc;
       c6Ipd: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Monoid.$fReadFirst_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Ipc: // global
           I64[Hp - 8] = sat_s6I4Y_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.928232563 UTC

[section ""data" . Data.Monoid.$fReadFirst_$creadList_closure" {
     Data.Monoid.$fReadFirst_$creadList_closure:
         const Data.Monoid.$fReadFirst_$creadList_info;
         const 0;
 },
 sat_s6I50_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Ipr,
                       label: sat_s6I50_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ipr: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadFirst1_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I51_entry() //  [R1]
         { info_tbl: [(c6Ipu,
                       label: sat_s6I51_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ipu: // global
           _s6I51::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6Ipv; else goto c6Ipw;
       c6Ipw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Ipy; else goto c6Ipx;
       c6Ipy: // global
           HpAlloc = 16;
           goto c6Ipv;
       c6Ipv: // global
           R1 = _s6I51::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Ipx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I51::P64;
           _s6I4Z::P64 = P64[_s6I51::P64 + 16];
           I64[Hp - 8] = sat_s6I50_info;
           P64[Hp] = _s6I4Z::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fReadFirst_$creadList_entry() //  [R2]
         { info_tbl: [(c6Ipz,
                       label: Data.Monoid.$fReadFirst_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ipz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IpD; else goto c6IpC;
       c6IpD: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Monoid.$fReadFirst_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IpC: // global
           I64[Hp - 16] = sat_s6I51_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.930219267 UTC

[section ""data" . Data.Monoid.$fReadFirst_closure" {
     Data.Monoid.$fReadFirst_closure:
         const Data.Monoid.$fReadFirst_info;
         const 0;
 },
 sat_s6I56_entry() //  [R1]
         { info_tbl: [(c6IpM,
                       label: sat_s6I56_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IpM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IpN; else goto c6IpO;
       c6IpN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IpO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadFirst_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I55_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IpU,
                       label: sat_s6I55_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IpU: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadFirst1_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I54_entry() //  [R1]
         { info_tbl: [(c6Iq1,
                       label: sat_s6I54_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iq1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Iq2; else goto c6Iq3;
       c6Iq2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Iq3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadFirst_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I53_entry() //  [R1, R2]
         { info_tbl: [(c6Iq9,
                       label: sat_s6I53_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iq9: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Monoid.$fReadFirst_$creadsPrec_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadFirst_entry() //  [R2]
         { info_tbl: [(c6Iqd,
                       label: Data.Monoid.$fReadFirst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iqd: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c6Iqh; else goto c6Iqg;
       c6Iqh: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Monoid.$fReadFirst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Iqg: // global
           I64[Hp - 112] = sat_s6I56_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6I55_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s6I54_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s6I53_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 112;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.932260625 UTC

[section ""data" . Data.Monoid.$fEqFirst_closure" {
     Data.Monoid.$fEqFirst_closure:
         const Data.Monoid.$fEqFirst_info;
 },
 sat_s6I59_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Iqr,
                       label: sat_s6I59_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iqr: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c/=_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I58_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Iqz,
                       label: sat_s6I58_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iqz: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fEqFirst_entry() //  [R2]
         { info_tbl: [(c6IqD,
                       label: Data.Monoid.$fEqFirst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IqD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6IqH; else goto c6IqG;
       c6IqH: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Monoid.$fEqFirst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IqG: // global
           I64[Hp - 48] = sat_s6I59_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s6I58_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.933715003 UTC

[section ""data" . Data.Monoid.$fOrdFirst_$cp1Ord_closure" {
     Data.Monoid.$fOrdFirst_$cp1Ord_closure:
         const Data.Monoid.$fOrdFirst_$cp1Ord_info;
 },
 sat_s6I5b_entry() //  [R1]
         { info_tbl: [(c6IqQ,
                       label: sat_s6I5b_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IqQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IqR; else goto c6IqS;
       c6IqR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IqS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fOrdFirst_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6IqT,
                       label: Data.Monoid.$fOrdFirst_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IqT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IqX; else goto c6IqW;
       c6IqX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Monoid.$fOrdFirst_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IqW: // global
           I64[Hp - 16] = sat_s6I5b_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Monoid.$fEqFirst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.935837675 UTC

[section ""data" . Data.Monoid.$fOrdFirst_closure" {
     Data.Monoid.$fOrdFirst_closure:
         const Data.Monoid.$fOrdFirst_info;
 },
 sat_s6I5m_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Ir7,
                       label: sat_s6I5m_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ir7: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmin_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I5l_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Irf,
                       label: sat_s6I5l_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Irf: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmax_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I5k_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Irn,
                       label: sat_s6I5k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Irn: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c>=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I5j_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Irv,
                       label: sat_s6I5j_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Irv: // global
           R4 = R2;
           R3 = R3;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I5g_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IrD,
                       label: sat_s6I5g_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IrD: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I5f_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IrL,
                       label: sat_s6I5f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IrL: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I5e_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IrT,
                       label: sat_s6I5e_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IrT: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I5d_entry() //  [R1]
         { info_tbl: [(c6Is0,
                       label: sat_s6I5d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Is0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Is1; else goto c6Is2;
       c6Is1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Is2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fOrdFirst_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fOrdFirst_entry() //  [R2]
         { info_tbl: [(c6Is4,
                       label: Data.Monoid.$fOrdFirst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Is4: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto c6Is8; else goto c6Is7;
       c6Is8: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = Data.Monoid.$fOrdFirst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Is7: // global
           I64[Hp - 200] = sat_s6I5m_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6I5l_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s6I5k_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s6I5j_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6I5g_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s6I5f_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6I5e_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6I5d_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.93832396 UTC

[section ""data" . Data.Monoid.getFirst_closure" {
     Data.Monoid.getFirst_closure:
         const Data.Monoid.getFirst_info;
 },
 Data.Monoid.getFirst_entry() //  [R2]
         { info_tbl: [(c6Isd,
                       label: Data.Monoid.getFirst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Isd: // global
           R2 = R2;
           call Data.Monoid.$fGeneric1First2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.939095594 UTC

[section ""data" . Data.Monoid.getLast_closure" {
     Data.Monoid.getLast_closure:
         const Data.Monoid.getLast_info;
 },
 Data.Monoid.getLast_entry() //  [R2]
         { info_tbl: [(c6Isk,
                       label: Data.Monoid.getLast_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Isk: // global
           R2 = R2;
           call Data.Monoid.$fGeneric1Last2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.939809915 UTC

[section ""cstring" . Data.Monoid.$trModule4_bytes" {
     Data.Monoid.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.940363581 UTC

[section ""data" . Data.Monoid.$trModule3_closure" {
     Data.Monoid.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.940927832 UTC

[section ""cstring" . Data.Monoid.$trModule2_bytes" {
     Data.Monoid.$trModule2_bytes:
         I8[] [68,97,116,97,46,77,111,110,111,105,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.941581804 UTC

[section ""data" . Data.Monoid.$trModule1_closure" {
     Data.Monoid.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.942148331 UTC

[section ""data" . Data.Monoid.$trModule_closure" {
     Data.Monoid.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Monoid.$trModule3_closure+1;
         const Data.Monoid.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.942726197 UTC

[section ""data" . $krep_r6I1r_closure" {
     $krep_r6I1r_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.943310773 UTC

[section ""data" . $krep1_r6I1s_closure" {
     $krep1_r6I1s_closure:
         const :_con_info;
         const $krep_r6I1r_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.943897453 UTC

[section ""data" . $krep2_r6I1t_closure" {
     $krep2_r6I1t_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep1_r6I1s_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.944493232 UTC

[section ""data" . Data.Monoid.$tcFirst1_closure" {
     Data.Monoid.$tcFirst1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$fReadFirst11_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.945009445 UTC

[section ""data" . Data.Monoid.$tcFirst_closure" {
     Data.Monoid.$tcFirst_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Monoid.$trModule_closure+1;
         const Data.Monoid.$tcFirst1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 12072287807032806756;
         const 12788244796562536401;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.945656497 UTC

[section ""data" . $krep3_r6I1u_closure" {
     $krep3_r6I1u_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Monoid.$tcFirst_closure+1;
         const $krep1_r6I1s_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.946219045 UTC

[section ""data" . Data.Monoid.$tc'First1_closure" {
     Data.Monoid.$tc'First1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r6I1t_closure+1;
         const $krep3_r6I1u_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.946799865 UTC

[section ""cstring" . Data.Monoid.$tc'First3_bytes" {
     Data.Monoid.$tc'First3_bytes:
         I8[] [39,70,105,114,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.947383922 UTC

[section ""data" . Data.Monoid.$tc'First2_closure" {
     Data.Monoid.$tc'First2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$tc'First3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.947951285 UTC

[section ""data" . Data.Monoid.$tc'First_closure" {
     Data.Monoid.$tc'First_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Monoid.$trModule_closure+1;
         const Data.Monoid.$tc'First2_closure+1;
         const Data.Monoid.$tc'First1_closure+4;
         const 7752528083504400280;
         const 15965132804789246607;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.948536334 UTC

[section ""data" . Data.Monoid.$tcLast1_closure" {
     Data.Monoid.$tcLast1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$fReadLast5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.949102195 UTC

[section ""data" . Data.Monoid.$tcLast_closure" {
     Data.Monoid.$tcLast_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Monoid.$trModule_closure+1;
         const Data.Monoid.$tcLast1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 6920195955404695016;
         const 2388797855174213212;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.949714878 UTC

[section ""data" . $krep4_r6I1v_closure" {
     $krep4_r6I1v_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Monoid.$tcLast_closure+1;
         const $krep1_r6I1s_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.950248934 UTC

[section ""data" . Data.Monoid.$tc'Last1_closure" {
     Data.Monoid.$tc'Last1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r6I1t_closure+1;
         const $krep4_r6I1v_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.950810937 UTC

[section ""cstring" . Data.Monoid.$tc'Last3_bytes" {
     Data.Monoid.$tc'Last3_bytes:
         I8[] [39,76,97,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.951347004 UTC

[section ""data" . Data.Monoid.$tc'Last2_closure" {
     Data.Monoid.$tc'Last2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$tc'Last3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.951890651 UTC

[section ""data" . Data.Monoid.$tc'Last_closure" {
     Data.Monoid.$tc'Last_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Monoid.$trModule_closure+1;
         const Data.Monoid.$tc'Last2_closure+1;
         const Data.Monoid.$tc'Last1_closure+4;
         const 5411164464353425083;
         const 12998161994081761510;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.952528878 UTC

[section ""relreadonly" . S6I7j_srt" {
     S6I7j_srt:
         const Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
         const Data.Monoid.$fMonoidFirst_closure;
         const Data.Monoid.$fMonoidLast_closure;
         const GHC.Show.$fShowMaybe_$cshowsPrec_closure;
         const Data.Monoid.$w$cshowsPrec1_closure;
         const Data.Monoid.$fShowLast_$cshowsPrec_closure;
         const GHC.Show.$fShowMaybe4_closure;
         const Data.Monoid.$fReadFirst3_closure;
         const GHC.Show.$fShowMaybe1_closure;
         const Data.Monoid.$fShowFirst4_closure;
         const Data.Monoid.$fShowLast_$cshow_closure;
         const Data.Monoid.$fShowLast_$cshowList_closure;
         const Data.Monoid.$fShowLast_closure;
         const GHC.Read.$fReadMaybe1_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Monoid.$fReadFirst2_closure;
         const GHC.Read.readField_closure;
         const Data.Monoid.$fReadLast2_closure;
         const Data.Monoid.$fReadFirst_lexeme_closure;
         const Data.Monoid.$fReadLast_lexeme_closure;
         const GHC.Read.list3_closure;
         const Data.Monoid.$fReadLast1_closure;
         const Data.Monoid.$fReadLast_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Monoid.$fReadLast_$creadListPrec_closure;
         const Data.Monoid.$fReadLast_$creadList_closure;
         const Data.Monoid.$fReadLast_closure;
         const Data.Monoid.$w$cshowsPrec_closure;
         const Data.Monoid.$fShowFirst_$cshowsPrec_closure;
         const Data.Monoid.$fShowFirst_$cshow_closure;
         const Data.Monoid.$fShowFirst_$cshowList_closure;
         const Data.Monoid.$fShowFirst_closure;
         const Data.Monoid.$fReadFirst6_closure;
         const Data.Monoid.$fReadFirst_lexeme1_closure;
         const Data.Monoid.$fReadFirst1_closure;
         const Data.Monoid.$fReadFirst_$creadsPrec_closure;
         const Data.Monoid.$fReadFirst_$creadListPrec_closure;
         const Data.Monoid.$fReadFirst_$creadList_closure;
         const Data.Monoid.$fReadFirst_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.953562049 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:01:56.956089035 UTC

[section ""data" . Data.Monoid.$fMonoidFirst_$c<>_closure" {
     Data.Monoid.$fMonoidFirst_$c<>_closure:
         const Data.Monoid.$fMonoidFirst_$c<>_info;
 },
 Data.Monoid.$fMonoidFirst_$c<>_entry() //  [R2, R3]
         { info_tbl: [(c6Isy,
                       label: Data.Monoid.$fMonoidFirst_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Isy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Isz; else goto c6IsA;
       c6Isz: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fMonoidFirst_$c<>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6IsA: // global
           I64[Sp - 16] = block_c6Isr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6IsH; else goto c6Iss;
       u6IsH: // global
           call _c6Isr(R1) args: 0, res: 0, upd: 0;
       c6Iss: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Isr() //  [R1]
         { info_tbl: [(c6Isr,
                       label: block_c6Isr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Isr: // global
           if (R1 & 7 == 1) goto c6Isv; else goto c6Isw;
       c6Isv: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6Isw: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.95777531 UTC

[section ""data" . Data.Monoid.$fSemigroupFirst1_closure" {
     Data.Monoid.$fSemigroupFirst1_closure:
         const Data.Monoid.$fSemigroupFirst1_info;
 },
 Data.Monoid.$fSemigroupFirst1_entry() //  [R2, R3]
         { info_tbl: [(c6IsT,
                       label: Data.Monoid.$fSemigroupFirst1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IsT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6IsU; else goto u6Itf;
       c6IsU: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fSemigroupFirst1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u6Itf: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c6IsJ() args: 0, res: 0, upd: 0;
     }
 },
 _c6IsJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IsJ: // global
           I64[Sp - 8] = block_c6IsM_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6Ith; else goto c6IsN;
       u6Ith: // global
           call _c6IsM(R1) args: 0, res: 0, upd: 0;
       c6IsN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6IsM() //  [R1]
         { info_tbl: [(c6IsM,
                       label: block_c6IsM_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IsM: // global
           _s6I1B::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6IsQ; else goto c6IsR;
       c6IsQ: // global
           R1 = _s6I1B::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6IsR: // global
           I64[Sp] = block_c6It1_info;
           _s6I1E::P64 = P64[R1 + 6];
           _s6I1F::P64 = P64[R1 + 14];
           R1 = _s6I1B::P64;
           P64[Sp + 8] = _s6I1F::P64;
           P64[Sp + 16] = _s6I1E::P64;
           if (R1 & 7 != 0) goto u6Iti; else goto c6It3;
       u6Iti: // global
           call _c6It1(R1) args: 0, res: 0, upd: 0;
       c6It3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6It1() //  [R1]
         { info_tbl: [(c6It1,
                       label: block_c6It1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6It1: // global
           if (R1 & 7 == 1) goto c6It9; else goto c6Itd;
       c6It9: // global
           _s6I1C::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s6I1C::P64;
           Sp = Sp + 8;
           call _c6IsJ() args: 0, res: 0, upd: 0;
       c6Itd: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.95991419 UTC

[section ""data" . Data.Monoid.$fSemigroupFirst_$csconcat_closure" {
     Data.Monoid.$fSemigroupFirst_$csconcat_closure:
         const Data.Monoid.$fSemigroupFirst_$csconcat_info;
 },
 Data.Monoid.$fSemigroupFirst_$csconcat_entry() //  [R2]
         { info_tbl: [(c6Its,
                       label: Data.Monoid.$fSemigroupFirst_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Its: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6Itt; else goto c6Itu;
       c6Itt: // global
           R2 = R2;
           R1 = Data.Monoid.$fSemigroupFirst_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Itu: // global
           I64[Sp - 8] = block_c6Itp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6Ity; else goto c6Itq;
       u6Ity: // global
           call _c6Itp(R1) args: 0, res: 0, upd: 0;
       c6Itq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Itp() //  [R1]
         { info_tbl: [(c6Itp,
                       label: block_c6Itp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Itp: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Monoid.$fSemigroupFirst1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.961483118 UTC

[section ""data" . Data.Monoid.$fMonoidFirst_go_closure" {
     Data.Monoid.$fMonoidFirst_go_closure:
         const Data.Monoid.$fMonoidFirst_go_info;
 },
 Data.Monoid.$fMonoidFirst_go_entry() //  [R2]
         { info_tbl: [(c6ItK,
                       label: Data.Monoid.$fMonoidFirst_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ItK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ItL; else goto u6Iu6;
       c6ItL: // global
           R2 = R2;
           R1 = Data.Monoid.$fMonoidFirst_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u6Iu6: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c6ItA() args: 0, res: 0, upd: 0;
     }
 },
 _c6ItA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ItA: // global
           _s6I1M::P64 = P64[Sp];
           I64[Sp] = block_c6ItD_info;
           R1 = _s6I1M::P64;
           if (R1 & 7 != 0) goto u6Iu8; else goto c6ItE;
       u6Iu8: // global
           call _c6ItD(R1) args: 0, res: 0, upd: 0;
       c6ItE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6ItD() //  [R1]
         { info_tbl: [(c6ItD,
                       label: block_c6ItD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ItD: // global
           if (R1 & 7 == 1) goto c6ItH; else goto c6ItI;
       c6ItH: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6ItI: // global
           I64[Sp - 8] = block_c6ItS_info;
           _s6I1P::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s6I1P::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6Iu9; else goto c6ItU;
       u6Iu9: // global
           call _c6ItS(R1) args: 0, res: 0, upd: 0;
       c6ItU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6ItS() //  [R1]
         { info_tbl: [(c6ItS,
                       label: block_c6ItS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ItS: // global
           if (R1 & 7 == 1) goto c6Iu0; else goto c6Iu4;
       c6Iu0: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c6ItA() args: 0, res: 0, upd: 0;
       c6Iu4: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.963053298 UTC

[section ""data" . Data.Monoid.$fSemigroupFirst_closure" {
     Data.Monoid.$fSemigroupFirst_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Monoid.$fMonoidFirst_$c<>_closure+2;
         const Data.Monoid.$fSemigroupFirst_$csconcat_closure+1;
         const Data.Monoid.$fSemigroupFirst_$cstimes_closure+3;
         const 0;
 },
 section ""data" . Data.Monoid.$fMonoidFirst_closure" {
     Data.Monoid.$fMonoidFirst_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Monoid.$fSemigroupFirst_closure+1;
         const GHC.Base.Nothing_closure+1;
         const Data.Monoid.$fMonoidFirst_$c<>_closure+2;
         const Data.Monoid.$fMonoidFirst_go_closure+1;
         const 0;
 },
 section ""data" . Data.Monoid.$fSemigroupFirst_$cstimes_closure" {
     Data.Monoid.$fSemigroupFirst_$cstimes_closure:
         const Data.Monoid.$fSemigroupFirst_$cstimes_info;
         const 0;
 },
 Data.Monoid.$fSemigroupFirst_$cstimes_entry() //  [R2, R3, R4]
         { info_tbl: [(c6Iug,
                       label: Data.Monoid.$fSemigroupFirst_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iug: // global
           R5 = R4;
           R4 = R3;
           R3 = Data.Monoid.$fMonoidFirst_closure+1;
           R2 = R2;
           call Data.Semigroup.Internal.stimesIdempotentMonoid_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.964317094 UTC

[section ""data" . Data.Monoid.$fMonoidLast_$c<>_closure" {
     Data.Monoid.$fMonoidLast_$c<>_closure:
         const Data.Monoid.$fMonoidLast_$c<>_info;
 },
 Data.Monoid.$fMonoidLast_$c<>_entry() //  [R2, R3]
         { info_tbl: [(c6Iuu,
                       label: Data.Monoid.$fMonoidLast_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iuu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Iuv; else goto c6Iuw;
       c6Iuv: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fMonoidLast_$c<>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Iuw: // global
           I64[Sp - 16] = block_c6Iun_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6IuD; else goto c6Iuo;
       u6IuD: // global
           call _c6Iun(R1) args: 0, res: 0, upd: 0;
       c6Iuo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Iun() //  [R1]
         { info_tbl: [(c6Iun,
                       label: block_c6Iun_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iun: // global
           if (R1 & 7 == 1) goto c6Iur; else goto c6Ius;
       c6Iur: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6Ius: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.96592192 UTC

[section ""data" . Data.Monoid.$fSemigroupLast1_closure" {
     Data.Monoid.$fSemigroupLast1_closure:
         const Data.Monoid.$fSemigroupLast1_info;
 },
 Data.Monoid.$fSemigroupLast1_entry() //  [R2, R3]
         { info_tbl: [(c6IuP,
                       label: Data.Monoid.$fSemigroupLast1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IuP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IuQ; else goto c6IuR;
       c6IuQ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fSemigroupLast1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6IuR: // global
           I64[Sp - 16] = block_c6IuI_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6Ivd; else goto c6IuJ;
       u6Ivd: // global
           call _c6IuI(R1) args: 0, res: 0, upd: 0;
       c6IuJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6IuI() //  [R1]
         { info_tbl: [(c6IuI,
                       label: block_c6IuI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IuI: // global
           if (R1 & 7 == 1) goto u6Iva; else goto c6IuN;
       u6Iva: // global
           Sp = Sp + 8;
           call _c6Iv4() args: 0, res: 0, upd: 0;
       c6IuN: // global
           I64[Sp] = block_c6IuX_info;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Monoid.$fSemigroupLast1_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6IuX() //  [R1]
         { info_tbl: [(c6IuX,
                       label: block_c6IuX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IuX: // global
           if (R1 & 7 == 1) goto u6Ivb; else goto c6Iv8;
       u6Ivb: // global
           Sp = Sp + 8;
           call _c6Iv4() args: 0, res: 0, upd: 0;
       c6Iv8: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6Iv4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iv4: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.967499921 UTC

[section ""data" . Data.Monoid.$fSemigroupLast_$csconcat_closure" {
     Data.Monoid.$fSemigroupLast_$csconcat_closure:
         const Data.Monoid.$fSemigroupLast_$csconcat_info;
 },
 Data.Monoid.$fSemigroupLast_$csconcat_entry() //  [R2]
         { info_tbl: [(c6Ivm,
                       label: Data.Monoid.$fSemigroupLast_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ivm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6Ivn; else goto c6Ivo;
       c6Ivn: // global
           R2 = R2;
           R1 = Data.Monoid.$fSemigroupLast_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Ivo: // global
           I64[Sp - 8] = block_c6Ivj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6Ivs; else goto c6Ivk;
       u6Ivs: // global
           call _c6Ivj(R1) args: 0, res: 0, upd: 0;
       c6Ivk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Ivj() //  [R1]
         { info_tbl: [(c6Ivj,
                       label: block_c6Ivj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ivj: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Monoid.$fSemigroupLast1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.968871768 UTC

[section ""data" . Data.Monoid.$fMonoidLast_go_closure" {
     Data.Monoid.$fMonoidLast_go_closure:
         const Data.Monoid.$fMonoidLast_go_info;
 },
 Data.Monoid.$fMonoidLast_go_entry() //  [R2]
         { info_tbl: [(c6IvE,
                       label: Data.Monoid.$fMonoidLast_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IvE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IvF; else goto c6IvG;
       c6IvF: // global
           R2 = R2;
           R1 = Data.Monoid.$fMonoidLast_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IvG: // global
           I64[Sp - 8] = block_c6Ivx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6IvZ; else goto c6Ivy;
       u6IvZ: // global
           call _c6Ivx(R1) args: 0, res: 0, upd: 0;
       c6Ivy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Ivx() //  [R1]
         { info_tbl: [(c6Ivx,
                       label: block_c6Ivx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ivx: // global
           if (R1 & 7 == 1) goto c6IvB; else goto c6IvC;
       c6IvB: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6IvC: // global
           I64[Sp - 8] = block_c6IvM_info;
           R2 = P64[R1 + 14];
           P64[Sp] = P64[R1 + 6];
           Sp = Sp - 8;
           call Data.Monoid.$fMonoidLast_go_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6IvM() //  [R1]
         { info_tbl: [(c6IvM,
                       label: block_c6IvM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IvM: // global
           if (R1 & 7 == 1) goto c6IvT; else goto c6IvX;
       c6IvT: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6IvX: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.970356675 UTC

[section ""data" . Data.Monoid.$fSemigroupLast_closure" {
     Data.Monoid.$fSemigroupLast_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Monoid.$fMonoidLast_$c<>_closure+2;
         const Data.Monoid.$fSemigroupLast_$csconcat_closure+1;
         const Data.Monoid.$fSemigroupLast_$cstimes_closure+3;
         const 0;
 },
 section ""data" . Data.Monoid.$fMonoidLast_closure" {
     Data.Monoid.$fMonoidLast_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Monoid.$fSemigroupLast_closure+1;
         const GHC.Base.Nothing_closure+1;
         const Data.Monoid.$fMonoidLast_$c<>_closure+2;
         const Data.Monoid.$fMonoidLast_go_closure+1;
         const 0;
 },
 section ""data" . Data.Monoid.$fSemigroupLast_$cstimes_closure" {
     Data.Monoid.$fSemigroupLast_$cstimes_closure:
         const Data.Monoid.$fSemigroupLast_$cstimes_info;
         const 0;
 },
 Data.Monoid.$fSemigroupLast_$cstimes_entry() //  [R2, R3, R4]
         { info_tbl: [(c6Iw4,
                       label: Data.Monoid.$fSemigroupLast_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iw4: // global
           R5 = R4;
           R4 = R3;
           R3 = Data.Monoid.$fMonoidLast_closure+1;
           R2 = R2;
           call Data.Semigroup.Internal.stimesIdempotentMonoid_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.971321448 UTC

[section ""data" . Data.Monoid.$fFunctorLast_closure" {
     Data.Monoid.$fFunctorLast_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fApplicativeMaybe_$cfmap_closure+2;
         const GHC.Base.$fFunctorMaybe_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.971961128 UTC

[section ""data" . Data.Monoid.$fApplicativeLast_closure" {
     Data.Monoid.$fApplicativeLast_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Monoid.$fFunctorLast_closure+1;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fApplicativeMaybe_$c<*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$cliftA2_closure+3;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c<*_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.972566694 UTC

[section ""data" . Data.Monoid.$fMonadLast_closure" {
     Data.Monoid.$fMonadLast_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Monoid.$fApplicativeLast_closure+1;
         const GHC.Base.$fMonadMaybe_$c>>=_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fMonadMaybe_$cfail_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.973347809 UTC

[section ""data" . Data.Monoid.$fGeneric1Last1_closure" {
     Data.Monoid.$fGeneric1Last1_closure:
         const Data.Monoid.$fGeneric1Last1_info;
 },
 Data.Monoid.$fGeneric1Last1_entry() //  [R2]
         { info_tbl: [(c6Iwb,
                       label: Data.Monoid.$fGeneric1Last1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iwb: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.974182229 UTC

[section ""data" . Data.Monoid.$fGeneric1Last2_closure" {
     Data.Monoid.$fGeneric1Last2_closure:
         const Data.Monoid.$fGeneric1Last2_info;
 },
 Data.Monoid.$fGeneric1Last2_entry() //  [R2]
         { info_tbl: [(c6Iwi,
                       label: Data.Monoid.$fGeneric1Last2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iwi: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.974872042 UTC

[section ""data" . Data.Monoid.$fGeneric1Last_closure" {
     Data.Monoid.$fGeneric1Last_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Monoid.$fGeneric1Last2_closure+1;
         const Data.Monoid.$fGeneric1Last1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.975553913 UTC

[section ""data" . Data.Monoid.$fGenericLast1_closure" {
     Data.Monoid.$fGenericLast1_closure:
         const Data.Monoid.$fGenericLast1_info;
 },
 Data.Monoid.$fGenericLast1_entry() //  [R2]
         { info_tbl: [(c6Iwp,
                       label: Data.Monoid.$fGenericLast1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iwp: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.976399252 UTC

[section ""data" . Data.Monoid.$fGenericLast2_closure" {
     Data.Monoid.$fGenericLast2_closure:
         const Data.Monoid.$fGenericLast2_info;
 },
 Data.Monoid.$fGenericLast2_entry() //  [R2]
         { info_tbl: [(c6Iww,
                       label: Data.Monoid.$fGenericLast2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iww: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.977171175 UTC

[section ""data" . Data.Monoid.$fGenericLast_closure" {
     Data.Monoid.$fGenericLast_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Monoid.$fGenericLast2_closure+1;
         const Data.Monoid.$fGenericLast1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.977813823 UTC

[section ""data" . Data.Monoid.$fShowFirst1_closure" {
     Data.Monoid.$fShowFirst1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.978383839 UTC

[section ""cstring" . Data.Monoid.$fShowLast2_bytes" {
     Data.Monoid.$fShowLast2_bytes:
         I8[] [76,97,115,116,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.978959476 UTC

[section ""cstring" . Data.Monoid.$fShowLast1_bytes" {
     Data.Monoid.$fShowLast1_bytes:
         I8[] [103,101,116,76,97,115,116,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.979529962 UTC

[section ""cstring" . Data.Monoid.$fReadFirst4_bytes" {
     Data.Monoid.$fReadFirst4_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.982028184 UTC

[section ""data" . Data.Monoid.$w$cshowsPrec1_closure" {
     Data.Monoid.$w$cshowsPrec1_closure:
         const Data.Monoid.$w$cshowsPrec1_info;
         const 0;
 },
 f_s6I2m_entry() //  [R1]
         { info_tbl: [(c6IwH,
                       label: f_s6I2m_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IwH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IwI; else goto c6IwJ;
       c6IwI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IwJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = Data.Monoid.$fShowFirst1_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.$fShowMaybe_$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2p_entry() //  [R1]
         { info_tbl: [(c6Ix4,
                       label: sat_s6I2p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ix4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Ix5; else goto c6Ix6;
       c6Ix5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Ix6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Monoid.$fReadFirst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2q_entry() //  [R1]
         { info_tbl: [(c6Ix7,
                       label: sat_s6I2q_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ix7: // global
           _s6I2q::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6Ix8; else goto c6Ix9;
       c6Ix9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Ixb; else goto c6Ixa;
       c6Ixb: // global
           HpAlloc = 24;
           goto c6Ix8;
       c6Ix8: // global
           R1 = _s6I2q::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Ixa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I2q::P64;
           _s6I2m::P64 = P64[_s6I2q::P64 + 16];
           _s6I2o::P64 = P64[_s6I2q::P64 + 24];
           I64[Hp - 16] = sat_s6I2p_info;
           P64[Hp] = _s6I2o::P64;
           R2 = Hp - 16;
           R1 = _s6I2m::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2r_entry() //  [R1]
         { info_tbl: [(c6Ixc,
                       label: sat_s6I2r_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ixc: // global
           _s6I2r::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6Ixd; else goto c6Ixe;
       c6Ixe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Ixg; else goto c6Ixf;
       c6Ixg: // global
           HpAlloc = 32;
           goto c6Ixd;
       c6Ixd: // global
           R1 = _s6I2r::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Ixf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I2r::P64;
           _s6I2m::P64 = P64[_s6I2r::P64 + 16];
           _s6I2o::P64 = P64[_s6I2r::P64 + 24];
           I64[Hp - 24] = sat_s6I2q_info;
           P64[Hp - 8] = _s6I2m::P64;
           P64[Hp] = _s6I2o::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2s_entry() //  [R1, R2]
         { info_tbl: [(c6Ixh,
                       label: sat_s6I2s_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ixh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Ixl; else goto c6Ixk;
       c6Ixl: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Ixk: // global
           _s6I2m::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6I2r_info;
           P64[Hp - 8] = _s6I2m::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I2v_entry() //  [R1]
         { info_tbl: [(c6IxJ,
                       label: sat_s6I2v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IxJ: // global
           _s6I2v::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IxK; else goto c6IxL;
       c6IxL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IxN; else goto c6IxM;
       c6IxN: // global
           HpAlloc = 24;
           goto c6IxK;
       c6IxK: // global
           R1 = _s6I2v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IxM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I2v::P64;
           _s6I2t::P64 = P64[_s6I2v::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6I2t::P64;
           R3 = Hp - 14;
           R2 = Data.Monoid.$fReadFirst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2w_entry() //  [R1]
         { info_tbl: [(c6IxO,
                       label: sat_s6I2w_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IxO: // global
           _s6I2w::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IxP; else goto c6IxQ;
       c6IxQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IxS; else goto c6IxR;
       c6IxS: // global
           HpAlloc = 24;
           goto c6IxP;
       c6IxP: // global
           R1 = _s6I2w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IxR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I2w::P64;
           _s6I2m::P64 = P64[_s6I2w::P64 + 16];
           _s6I2t::P64 = P64[_s6I2w::P64 + 24];
           I64[Hp - 16] = sat_s6I2v_info;
           P64[Hp] = _s6I2t::P64;
           R2 = Hp - 16;
           R1 = _s6I2m::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2x_entry() //  [R1]
         { info_tbl: [(c6IxT,
                       label: sat_s6I2x_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IxT: // global
           _s6I2x::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IxU; else goto c6IxV;
       c6IxV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6IxX; else goto c6IxW;
       c6IxX: // global
           HpAlloc = 32;
           goto c6IxU;
       c6IxU: // global
           R1 = _s6I2x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IxW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I2x::P64;
           _s6I2m::P64 = P64[_s6I2x::P64 + 16];
           _s6I2t::P64 = P64[_s6I2x::P64 + 24];
           I64[Hp - 24] = sat_s6I2w_info;
           P64[Hp - 8] = _s6I2m::P64;
           P64[Hp] = _s6I2t::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2y_entry() //  [R1]
         { info_tbl: [(c6IxY,
                       label: sat_s6I2y_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IxY: // global
           _s6I2y::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IxZ; else goto c6Iy0;
       c6Iy0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Iy2; else goto c6Iy1;
       c6Iy2: // global
           HpAlloc = 32;
           goto c6IxZ;
       c6IxZ: // global
           R1 = _s6I2y::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Iy1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I2y::P64;
           _s6I2m::P64 = P64[_s6I2y::P64 + 16];
           _s6I2t::P64 = P64[_s6I2y::P64 + 24];
           I64[Hp - 24] = sat_s6I2x_info;
           P64[Hp - 8] = _s6I2m::P64;
           P64[Hp] = _s6I2t::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2z_entry() //  [R1, R2]
         { info_tbl: [(c6Iy4,
                       label: sat_s6I2z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iy4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6Iy8; else goto c6Iy7;
       c6Iy8: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Iy7: // global
           _s6I2m::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6I2y_info;
           P64[Hp - 32] = _s6I2m::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$w$cshowsPrec1_entry() //  [R2, R3, R4]
         { info_tbl: [(c6Iyc,
                       label: Data.Monoid.$w$cshowsPrec1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iyc: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6Iyg; else goto c6Iyf;
       c6Iyg: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$w$cshowsPrec1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Iyf: // global
           I64[Hp - 40] = f_s6I2m_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6IwD::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6Iya; else goto c6Iyb;
       c6Iya: // global
           I64[Hp - 8] = sat_s6I2s_info;
           P64[Hp] = _c6IwD::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6Iyb: // global
           I64[Hp - 8] = sat_s6I2z_info;
           P64[Hp] = _c6IwD::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.986928596 UTC

[section ""data" . Data.Monoid.$fShowLast_$cshowsPrec_closure" {
     Data.Monoid.$fShowLast_$cshowsPrec_closure:
         const Data.Monoid.$fShowLast_$cshowsPrec_info;
         const 0;
 },
 Data.Monoid.$fShowLast_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c6Iyo,
                       label: Data.Monoid.$fShowLast_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iyo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6Iyp; else goto c6Iyq;
       c6Iyp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowLast_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Iyq: // global
           I64[Sp - 24] = block_c6Iyl_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6Iyu; else goto c6Iym;
       u6Iyu: // global
           call _c6Iyl(R1) args: 0, res: 0, upd: 0;
       c6Iym: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Iyl() //  [R1]
         { info_tbl: [(c6Iyl,
                       label: block_c6Iyl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iyl: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Monoid.$w$cshowsPrec1_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.988252841 UTC

[section ""data" . Data.Monoid.$fReadFirst3_closure" {
     Data.Monoid.$fReadFirst3_closure:
         const Data.Monoid.$fReadFirst3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadFirst3_entry() //  [R1]
         { info_tbl: [(c6IyB,
                       label: Data.Monoid.$fReadFirst3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IyB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IyC; else goto c6IyD;
       c6IyC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IyD: // global
           (_c6Iyy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6Iyy::I64 == 0) goto c6IyA; else goto c6Iyz;
       c6IyA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6Iyz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6Iyy::I64;
           R2 = Data.Monoid.$fReadFirst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.989366601 UTC

[section ""data" . Data.Monoid.$fShowFirst4_closure" {
     Data.Monoid.$fShowFirst4_closure:
         const Data.Monoid.$fShowFirst4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fShowFirst4_entry() //  [R1]
         { info_tbl: [(c6IyK,
                       label: Data.Monoid.$fShowFirst4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IyK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IyL; else goto c6IyM;
       c6IyL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IyM: // global
           (_c6IyH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6IyH::I64 == 0) goto c6IyJ; else goto c6IyI;
       c6IyJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6IyI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6IyH::I64;
           R3 = Data.Monoid.$fReadFirst3_closure;
           R2 = GHC.Show.$fShowMaybe4_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.991180757 UTC

[section ""data" . Data.Monoid.$fShowLast_$cshow_closure" {
     Data.Monoid.$fShowLast_$cshow_closure:
         const Data.Monoid.$fShowLast_$cshow_info;
         const 0;
 },
 sat_s6I2J_entry() //  [R1]
         { info_tbl: [(c6Iz9,
                       label: sat_s6I2J_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Iz9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6Iza; else goto c6Izb;
       c6Iza: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Izb: // global
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Show.appPrec1_closure;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = Data.Monoid.$fReadFirst3_closure;
           Sp = Sp - 32;
           call GHC.Show.showsPrec_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_s6I2K_entry() //  [R1]
         { info_tbl: [(c6Izg,
                       label: sat_s6I2K_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Izg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6Izh; else goto c6Izi;
       c6Izh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Izi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6IyZ_info;
           _s6I2F::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s6I2F::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6Izo; else goto c6Iz0;
       u6Izo: // global
           call _c6IyZ(R1) args: 0, res: 0, upd: 0;
       c6Iz0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6IyZ() //  [R1]
         { info_tbl: [(c6IyZ,
                       label: block_c6IyZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IyZ: // global
           if (R1 & 7 == 1) goto c6Izd; else goto c6Ize;
       c6Izd: // global
           R1 = Data.Monoid.$fShowFirst4_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c6Ize: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Izn; else goto c6Izm;
       c6Izn: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6Izm: // global
           _s6I2I::P64 = P64[R1 + 6];
           I64[Hp - 24] = sat_s6I2J_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _s6I2I::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.$fShowMaybe1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2L_entry() //  [R1]
         { info_tbl: [(c6Izp,
                       label: sat_s6I2L_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Izp: // global
           _s6I2L::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6Izq; else goto c6Izr;
       c6Izr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Izt; else goto c6Izs;
       c6Izt: // global
           HpAlloc = 32;
           goto c6Izq;
       c6Izq: // global
           R1 = _s6I2L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Izs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I2L::P64;
           _s6I2F::P64 = P64[_s6I2L::P64 + 16];
           _s6I2G::P64 = P64[_s6I2L::P64 + 24];
           I64[Hp - 24] = sat_s6I2K_info;
           P64[Hp - 8] = _s6I2F::P64;
           P64[Hp] = _s6I2G::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fShowLast_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6Izu,
                       label: Data.Monoid.$fShowLast_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Izu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Izy; else goto c6Izx;
       c6Izy: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowLast_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Izx: // global
           I64[Hp - 24] = sat_s6I2L_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.993765563 UTC

[section ""data" . Data.Monoid.$fShowLast_$cshowList_closure" {
     Data.Monoid.$fShowLast_$cshowList_closure:
         const Data.Monoid.$fShowLast_$cshowList_info;
         const 0;
 },
 sat_s6I2Q_entry() //  [R1, R2]
         { info_tbl: [(c6IzI,
                       label: sat_s6I2Q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IzI: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Monoid.$w$cshowsPrec1_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fShowLast_$cshowList_entry() //  [R2, R3, R4]
         { info_tbl: [(c6IzL,
                       label: Data.Monoid.$fShowLast_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IzL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6IzP; else goto c6IzO;
       c6IzP: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowLast_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6IzO: // global
           I64[Hp - 8] = sat_s6I2Q_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.995375101 UTC

[section ""data" . Data.Monoid.$fShowLast_closure" {
     Data.Monoid.$fShowLast_closure:
         const Data.Monoid.$fShowLast_info;
         const 0;
 },
 sat_s6I2U_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IzZ,
                       label: sat_s6I2U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IzZ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fShowLast_$cshowList_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I2T_entry() //  [R1, R2]
         { info_tbl: [(c6IA7,
                       label: sat_s6I2T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IA7: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Monoid.$fShowLast_$cshow_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I2S_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IAf,
                       label: sat_s6I2S_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IAf: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fShowLast_$cshowsPrec_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fShowLast_entry() //  [R2]
         { info_tbl: [(c6IAj,
                       label: Data.Monoid.$fShowLast_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IAj: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6IAn; else goto c6IAm;
       c6IAn: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Monoid.$fShowLast_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IAm: // global
           I64[Hp - 72] = sat_s6I2U_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6I2T_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6I2S_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.996839151 UTC

[section ""cstring" . Data.Monoid.$fReadLast5_bytes" {
     Data.Monoid.$fReadLast5_bytes:
         I8[] [76,97,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.997932451 UTC

[section ""data" . Data.Monoid.$fReadLast4_closure" {
     Data.Monoid.$fReadLast4_closure:
         const Data.Monoid.$fReadLast4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadLast4_entry() //  [R1]
         { info_tbl: [(c6IAu,
                       label: Data.Monoid.$fReadLast4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IAu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IAv; else goto c6IAw;
       c6IAv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IAw: // global
           (_c6IAr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6IAr::I64 == 0) goto c6IAt; else goto c6IAs;
       c6IAt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6IAs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6IAr::I64;
           R2 = Data.Monoid.$fReadLast5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.998843429 UTC

[section ""data" . Data.Monoid.$fReadLast_lexeme_closure" {
     Data.Monoid.$fReadLast_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Monoid.$fReadLast4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.999420944 UTC

[section ""cstring" . Data.Monoid.$fReadFirst9_bytes" {
     Data.Monoid.$fReadFirst9_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.000111412 UTC

[section ""data" . Data.Monoid.$fReadFirst8_closure" {
     Data.Monoid.$fReadFirst8_closure:
         const Data.Monoid.$fReadFirst8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadFirst8_entry() //  [R1]
         { info_tbl: [(c6IAD,
                       label: Data.Monoid.$fReadFirst8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IAD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IAE; else goto c6IAF;
       c6IAE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IAF: // global
           (_c6IAA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6IAA::I64 == 0) goto c6IAC; else goto c6IAB;
       c6IAC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6IAB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6IAA::I64;
           R2 = Data.Monoid.$fReadFirst9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.000996274 UTC

[section ""data" . Data.Monoid.$fReadFirst_lexeme_closure" {
     Data.Monoid.$fReadFirst_lexeme_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Monoid.$fReadFirst8_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.001580982 UTC

[section ""cstring" . Data.Monoid.$fReadLast3_bytes" {
     Data.Monoid.$fReadLast3_bytes:
         I8[] [103,101,116,76,97,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.002272825 UTC

[section ""data" . Data.Monoid.$fReadLast2_closure" {
     Data.Monoid.$fReadLast2_closure:
         const Data.Monoid.$fReadLast2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadLast2_entry() //  [R1]
         { info_tbl: [(c6IAM,
                       label: Data.Monoid.$fReadLast2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IAM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IAN; else goto c6IAO;
       c6IAN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IAO: // global
           (_c6IAJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6IAJ::I64 == 0) goto c6IAL; else goto c6IAK;
       c6IAL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6IAK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6IAJ::I64;
           R2 = Data.Monoid.$fReadLast3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.003149091 UTC

[section ""data" . Data.Monoid.$fReadFirst5_closure" {
     Data.Monoid.$fReadFirst5_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.003757777 UTC

[section ""data" . Data.Monoid.$fReadFirst2_closure" {
     Data.Monoid.$fReadFirst2_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Monoid.$fReadFirst3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.006140685 UTC

[section ""data" . Data.Monoid.$fReadLast1_closure" {
     Data.Monoid.$fReadLast1_closure:
         const Data.Monoid.$fReadLast1_info;
         const 0;
 },
 ds_s6I2Y_entry() //  [R1, R3]
         { info_tbl: [(c6IAY,
                       label: ds_s6I2Y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IAY: // global
           R4 = R3;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = P64[R1 + 6];
           call GHC.Read.$fReadMaybe1_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3a_entry() //  [R1]
         { info_tbl: [(c6IBz,
                       label: sat_s6I3a_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IBz: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3d_entry() //  [R1, R2]
         { info_tbl: [(c6IBF,
                       label: sat_s6I3d_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IBF: // global
           _s6I38::P64 = R2;
           _s6I3d::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6IBG; else goto c6IBH;
       c6IBH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IBJ; else goto c6IBI;
       c6IBJ: // global
           HpAlloc = 24;
           goto c6IBG;
       c6IBG: // global
           R2 = _s6I38::P64;
           R1 = _s6I3d::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IBI: // global
           _s6I32::P64 = P64[_s6I3d::P64 + 7];
           I64[Hp - 16] = sat_s6I3a_info;
           P64[Hp - 8] = _s6I32::P64;
           P64[Hp] = _s6I38::P64;
           I64[Sp - 8] = block_c6IBC_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadFirst2_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6IBC() //  [R1]
         { info_tbl: [(c6IBC,
                       label: block_c6IBC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IBC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6IBM; else goto c6IBL;
       c6IBM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6IBL: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3e_entry() //  [R1, R2]
         { info_tbl: [(c6IBN,
                       label: sat_s6I3e_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IBN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6IBR; else goto c6IBQ;
       c6IBR: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IBQ: // global
           _s6I2Y::P64 = P64[R1 + 7];
           _s6I32::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6I3d_info;
           P64[Hp] = _s6I32::P64;
           R5 = Hp - 7;
           R4 = Data.Monoid.$fReadFirst5_closure+1;
           R3 = _s6I2Y::P64;
           R2 = Data.Monoid.$fReadLast2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3h_entry() //  [R1, R2]
         { info_tbl: [(c6IBV,
                       label: sat_s6I3h_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IBV: // global
           _s6I36::P64 = R2;
           _s6I3h::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6IBW; else goto c6IBX;
       c6IBX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IBZ; else goto c6IBY;
       c6IBZ: // global
           HpAlloc = 24;
           goto c6IBW;
       c6IBW: // global
           R2 = _s6I36::P64;
           R1 = _s6I3h::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IBY: // global
           _s6I2Y::P64 = P64[_s6I3h::P64 + 7];
           _s6I32::P64 = P64[_s6I3h::P64 + 15];
           I64[Hp - 16] = sat_s6I3e_info;
           P64[Hp - 8] = _s6I2Y::P64;
           P64[Hp] = _s6I32::P64;
           I64[Sp - 8] = block_c6IBS_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadFirst_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6IBS() //  [R1]
         { info_tbl: [(c6IBS,
                       label: block_c6IBS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IBS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6IC2; else goto c6IC1;
       c6IC2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6IC1: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3k_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IC3,
                       label: sat_s6I3k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IC3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6IC4; else goto c6IC5;
       c6IC4: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6IC5: // global
           I64[Sp - 24] = block_c6IB6_info;
           _s6I2Y::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6I2Y::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6ICi; else goto c6IB7;
       u6ICi: // global
           call _c6IB6(R1) args: 0, res: 0, upd: 0;
       c6IB7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6IB6() //  [R1]
         { info_tbl: [(c6IB6,
                       label: block_c6IB6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IB6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IC8; else goto c6IC7;
       c6IC8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6IC7: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6ICa; else goto c6ICe;
       c6ICa: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6ICe: // global
           I64[Hp - 16] = sat_s6I3h_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6ICb_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadLast_lexeme_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6ICb() //  [R1]
         { info_tbl: [(c6ICb,
                       label: block_c6ICb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ICb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6ICh; else goto c6ICg;
       c6ICh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ICg: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadLast1_entry() //  [R2, R3, R4]
         { info_tbl: [(c6ICj,
                       label: Data.Monoid.$fReadLast1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ICj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6ICn; else goto c6ICm;
       c6ICn: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fReadLast1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ICm: // global
           I64[Hp - 24] = ds_s6I2Y_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6I3k_info;
           P64[Hp] = Hp - 22;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.010490431 UTC

[section ""data" . Data.Monoid.$fReadLast_$creadsPrec_closure" {
     Data.Monoid.$fReadLast_$creadsPrec_closure:
         const Data.Monoid.$fReadLast_$creadsPrec_info;
         const 0;
 },
 sat_s6I3n_entry() //  [R1]
         { info_tbl: [(c6ICw,
                       label: sat_s6I3n_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ICw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ICx; else goto c6ICy;
       c6ICx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ICy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadLast1_entry(R4,
                                              R3,
                                              R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fReadLast_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c6ICz,
                       label: Data.Monoid.$fReadLast_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ICz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6ICD; else goto c6ICC;
       c6ICD: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fReadLast_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ICC: // global
           I64[Hp - 24] = sat_s6I3n_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.012005411 UTC

[section ""data" . Data.Monoid.$fReadLast_$creadListPrec_closure" {
     Data.Monoid.$fReadLast_$creadListPrec_closure:
         const Data.Monoid.$fReadLast_$creadListPrec_info;
         const 0;
 },
 sat_s6I3p_entry() //  [R1, R2, R3]
         { info_tbl: [(c6ICN,
                       label: sat_s6I3p_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ICN: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadLast1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadLast_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6ICQ,
                       label: Data.Monoid.$fReadLast_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ICQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6ICU; else goto c6ICT;
       c6ICU: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Monoid.$fReadLast_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6ICT: // global
           I64[Hp - 8] = sat_s6I3p_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.015818813 UTC

[section ""data" . Data.Monoid.$fReadLast_$creadList_closure" {
     Data.Monoid.$fReadLast_$creadList_closure:
         const Data.Monoid.$fReadLast_$creadList_info;
         const 0;
 },
 sat_s6I3r_entry() //  [R1, R2, R3]
         { info_tbl: [(c6ID8,
                       label: sat_s6I3r_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ID8: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadLast1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3s_entry() //  [R1]
         { info_tbl: [(c6IDb,
                       label: sat_s6I3s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IDb: // global
           _s6I3s::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6IDc; else goto c6IDd;
       c6IDd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6IDf; else goto c6IDe;
       c6IDf: // global
           HpAlloc = 16;
           goto c6IDc;
       c6IDc: // global
           R1 = _s6I3s::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IDe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I3s::P64;
           _s6I3q::P64 = P64[_s6I3s::P64 + 16];
           I64[Hp - 8] = sat_s6I3r_info;
           P64[Hp] = _s6I3q::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fReadLast_$creadList_entry() //  [R2]
         { info_tbl: [(c6IDg,
                       label: Data.Monoid.$fReadLast_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IDg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IDk; else goto c6IDj;
       c6IDk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Monoid.$fReadLast_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IDj: // global
           I64[Hp - 16] = sat_s6I3s_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.01793001 UTC

[section ""data" . Data.Monoid.$fReadLast_closure" {
     Data.Monoid.$fReadLast_closure:
         const Data.Monoid.$fReadLast_info;
         const 0;
 },
 sat_s6I3x_entry() //  [R1]
         { info_tbl: [(c6IDt,
                       label: sat_s6I3x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IDt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IDu; else goto c6IDv;
       c6IDu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IDv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadLast_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I3w_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IDB,
                       label: sat_s6I3w_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IDB: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadLast1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3v_entry() //  [R1]
         { info_tbl: [(c6IDI,
                       label: sat_s6I3v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IDI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IDJ; else goto c6IDK;
       c6IDJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IDK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadLast_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I3u_entry() //  [R1, R2]
         { info_tbl: [(c6IDQ,
                       label: sat_s6I3u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IDQ: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Monoid.$fReadLast_$creadsPrec_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadLast_entry() //  [R2]
         { info_tbl: [(c6IDU,
                       label: Data.Monoid.$fReadLast_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IDU: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c6IDY; else goto c6IDX;
       c6IDY: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Monoid.$fReadLast_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IDX: // global
           I64[Hp - 112] = sat_s6I3x_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6I3w_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s6I3v_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s6I3u_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 112;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.020103643 UTC

[section ""data" . Data.Monoid.$fEqLast_closure" {
     Data.Monoid.$fEqLast_closure:
         const Data.Monoid.$fEqLast_info;
 },
 sat_s6I3A_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IE8,
                       label: sat_s6I3A_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IE8: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c/=_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3z_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IEg,
                       label: sat_s6I3z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IEg: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fEqLast_entry() //  [R2]
         { info_tbl: [(c6IEk,
                       label: Data.Monoid.$fEqLast_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IEk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6IEo; else goto c6IEn;
       c6IEo: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Monoid.$fEqLast_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IEn: // global
           I64[Hp - 48] = sat_s6I3A_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s6I3z_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.021729363 UTC

[section ""data" . Data.Monoid.$fOrdLast_$cp1Ord_closure" {
     Data.Monoid.$fOrdLast_$cp1Ord_closure:
         const Data.Monoid.$fOrdLast_$cp1Ord_info;
 },
 sat_s6I3C_entry() //  [R1]
         { info_tbl: [(c6IEx,
                       label: sat_s6I3C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IEx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IEy; else goto c6IEz;
       c6IEy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IEz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fOrdLast_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6IEA,
                       label: Data.Monoid.$fOrdLast_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IEA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IEE; else goto c6IED;
       c6IEE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Monoid.$fOrdLast_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IED: // global
           I64[Hp - 16] = sat_s6I3C_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Monoid.$fEqLast_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.023920154 UTC

[section ""data" . Data.Monoid.$fOrdLast_closure" {
     Data.Monoid.$fOrdLast_closure:
         const Data.Monoid.$fOrdLast_info;
 },
 sat_s6I3N_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IEO,
                       label: sat_s6I3N_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IEO: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmin_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3M_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IEW,
                       label: sat_s6I3M_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IEW: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmax_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3L_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IF4,
                       label: sat_s6I3L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IF4: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c>=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3K_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IFc,
                       label: sat_s6I3K_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IFc: // global
           R4 = R2;
           R3 = R3;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3H_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IFk,
                       label: sat_s6I3H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IFk: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3G_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IFs,
                       label: sat_s6I3G_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IFs: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3F_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IFA,
                       label: sat_s6I3F_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IFA: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3E_entry() //  [R1]
         { info_tbl: [(c6IFH,
                       label: sat_s6I3E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IFH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IFI; else goto c6IFJ;
       c6IFI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IFJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fOrdLast_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fOrdLast_entry() //  [R2]
         { info_tbl: [(c6IFL,
                       label: Data.Monoid.$fOrdLast_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IFL: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto c6IFP; else goto c6IFO;
       c6IFP: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = Data.Monoid.$fOrdLast_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IFO: // global
           I64[Hp - 200] = sat_s6I3N_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6I3M_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s6I3L_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s6I3K_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6I3H_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s6I3G_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6I3F_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6I3E_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.026468327 UTC

[section ""data" . Data.Monoid.$fFunctorFirst_closure" {
     Data.Monoid.$fFunctorFirst_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fApplicativeMaybe_$cfmap_closure+2;
         const GHC.Base.$fFunctorMaybe_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.027144122 UTC

[section ""data" . Data.Monoid.$fApplicativeFirst_closure" {
     Data.Monoid.$fApplicativeFirst_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Monoid.$fFunctorFirst_closure+1;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fApplicativeMaybe_$c<*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$cliftA2_closure+3;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c<*_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.027797609 UTC

[section ""data" . Data.Monoid.$fMonadFirst_closure" {
     Data.Monoid.$fMonadFirst_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Monoid.$fApplicativeFirst_closure+1;
         const GHC.Base.$fMonadMaybe_$c>>=_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fMonadMaybe_$cfail_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.028546738 UTC

[section ""data" . Data.Monoid.$fGeneric1First1_closure" {
     Data.Monoid.$fGeneric1First1_closure:
         const Data.Monoid.$fGeneric1First1_info;
 },
 Data.Monoid.$fGeneric1First1_entry() //  [R2]
         { info_tbl: [(c6IFU,
                       label: Data.Monoid.$fGeneric1First1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IFU: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.029532407 UTC

[section ""data" . Data.Monoid.$fGeneric1First2_closure" {
     Data.Monoid.$fGeneric1First2_closure:
         const Data.Monoid.$fGeneric1First2_info;
 },
 Data.Monoid.$fGeneric1First2_entry() //  [R2]
         { info_tbl: [(c6IG1,
                       label: Data.Monoid.$fGeneric1First2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IG1: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.030508409 UTC

[section ""data" . Data.Monoid.$fGeneric1First_closure" {
     Data.Monoid.$fGeneric1First_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Monoid.$fGeneric1First2_closure+1;
         const Data.Monoid.$fGeneric1First1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.031405015 UTC

[section ""data" . Data.Monoid.$fGenericFirst1_closure" {
     Data.Monoid.$fGenericFirst1_closure:
         const Data.Monoid.$fGenericFirst1_info;
 },
 Data.Monoid.$fGenericFirst1_entry() //  [R2]
         { info_tbl: [(c6IG8,
                       label: Data.Monoid.$fGenericFirst1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IG8: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.032454605 UTC

[section ""data" . Data.Monoid.$fGenericFirst2_closure" {
     Data.Monoid.$fGenericFirst2_closure:
         const Data.Monoid.$fGenericFirst2_info;
 },
 Data.Monoid.$fGenericFirst2_entry() //  [R2]
         { info_tbl: [(c6IGf,
                       label: Data.Monoid.$fGenericFirst2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IGf: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.033464107 UTC

[section ""data" . Data.Monoid.$fGenericFirst_closure" {
     Data.Monoid.$fGenericFirst_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Monoid.$fGenericFirst2_closure+1;
         const Data.Monoid.$fGenericFirst1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.034281419 UTC

[section ""cstring" . Data.Monoid.$fShowFirst3_bytes" {
     Data.Monoid.$fShowFirst3_bytes:
         I8[] [70,105,114,115,116,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.035075238 UTC

[section ""cstring" . Data.Monoid.$fShowFirst2_bytes" {
     Data.Monoid.$fShowFirst2_bytes:
         I8[] [103,101,116,70,105,114,115,116,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.037651393 UTC

[section ""data" . Data.Monoid.$w$cshowsPrec_closure" {
     Data.Monoid.$w$cshowsPrec_closure:
         const Data.Monoid.$w$cshowsPrec_info;
         const 0;
 },
 f_s6I3V_entry() //  [R1]
         { info_tbl: [(c6IGq,
                       label: f_s6I3V_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IGq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IGr; else goto c6IGs;
       c6IGr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IGs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = Data.Monoid.$fShowFirst1_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.$fShowMaybe_$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I3Y_entry() //  [R1]
         { info_tbl: [(c6IGN,
                       label: sat_s6I3Y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IGN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IGO; else goto c6IGP;
       c6IGO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IGP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Monoid.$fReadFirst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I3Z_entry() //  [R1]
         { info_tbl: [(c6IGQ,
                       label: sat_s6I3Z_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IGQ: // global
           _s6I3Z::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IGR; else goto c6IGS;
       c6IGS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IGU; else goto c6IGT;
       c6IGU: // global
           HpAlloc = 24;
           goto c6IGR;
       c6IGR: // global
           R1 = _s6I3Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IGT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I3Z::P64;
           _s6I3V::P64 = P64[_s6I3Z::P64 + 16];
           _s6I3X::P64 = P64[_s6I3Z::P64 + 24];
           I64[Hp - 16] = sat_s6I3Y_info;
           P64[Hp] = _s6I3X::P64;
           R2 = Hp - 16;
           R1 = _s6I3V::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I40_entry() //  [R1]
         { info_tbl: [(c6IGV,
                       label: sat_s6I40_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IGV: // global
           _s6I40::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IGW; else goto c6IGX;
       c6IGX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6IGZ; else goto c6IGY;
       c6IGZ: // global
           HpAlloc = 32;
           goto c6IGW;
       c6IGW: // global
           R1 = _s6I40::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IGY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I40::P64;
           _s6I3V::P64 = P64[_s6I40::P64 + 16];
           _s6I3X::P64 = P64[_s6I40::P64 + 24];
           I64[Hp - 24] = sat_s6I3Z_info;
           P64[Hp - 8] = _s6I3V::P64;
           P64[Hp] = _s6I3X::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I41_entry() //  [R1, R2]
         { info_tbl: [(c6IH0,
                       label: sat_s6I41_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IH0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6IH4; else goto c6IH3;
       c6IH4: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IH3: // global
           _s6I3V::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6I40_info;
           P64[Hp - 8] = _s6I3V::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I44_entry() //  [R1]
         { info_tbl: [(c6IHs,
                       label: sat_s6I44_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IHs: // global
           _s6I44::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IHt; else goto c6IHu;
       c6IHu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IHw; else goto c6IHv;
       c6IHw: // global
           HpAlloc = 24;
           goto c6IHt;
       c6IHt: // global
           R1 = _s6I44::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IHv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I44::P64;
           _s6I42::P64 = P64[_s6I44::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6I42::P64;
           R3 = Hp - 14;
           R2 = Data.Monoid.$fReadFirst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I45_entry() //  [R1]
         { info_tbl: [(c6IHx,
                       label: sat_s6I45_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IHx: // global
           _s6I45::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IHy; else goto c6IHz;
       c6IHz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IHB; else goto c6IHA;
       c6IHB: // global
           HpAlloc = 24;
           goto c6IHy;
       c6IHy: // global
           R1 = _s6I45::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IHA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I45::P64;
           _s6I3V::P64 = P64[_s6I45::P64 + 16];
           _s6I42::P64 = P64[_s6I45::P64 + 24];
           I64[Hp - 16] = sat_s6I44_info;
           P64[Hp] = _s6I42::P64;
           R2 = Hp - 16;
           R1 = _s6I3V::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I46_entry() //  [R1]
         { info_tbl: [(c6IHC,
                       label: sat_s6I46_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IHC: // global
           _s6I46::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IHD; else goto c6IHE;
       c6IHE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6IHG; else goto c6IHF;
       c6IHG: // global
           HpAlloc = 32;
           goto c6IHD;
       c6IHD: // global
           R1 = _s6I46::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IHF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I46::P64;
           _s6I3V::P64 = P64[_s6I46::P64 + 16];
           _s6I42::P64 = P64[_s6I46::P64 + 24];
           I64[Hp - 24] = sat_s6I45_info;
           P64[Hp - 8] = _s6I3V::P64;
           P64[Hp] = _s6I42::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I47_entry() //  [R1]
         { info_tbl: [(c6IHH,
                       label: sat_s6I47_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IHH: // global
           _s6I47::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IHI; else goto c6IHJ;
       c6IHJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6IHL; else goto c6IHK;
       c6IHL: // global
           HpAlloc = 32;
           goto c6IHI;
       c6IHI: // global
           R1 = _s6I47::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IHK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I47::P64;
           _s6I3V::P64 = P64[_s6I47::P64 + 16];
           _s6I42::P64 = P64[_s6I47::P64 + 24];
           I64[Hp - 24] = sat_s6I46_info;
           P64[Hp - 8] = _s6I3V::P64;
           P64[Hp] = _s6I42::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I48_entry() //  [R1, R2]
         { info_tbl: [(c6IHN,
                       label: sat_s6I48_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IHN: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6IHR; else goto c6IHQ;
       c6IHR: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IHQ: // global
           _s6I3V::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6I47_info;
           P64[Hp - 32] = _s6I3V::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c6IHV,
                       label: Data.Monoid.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IHV: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6IHZ; else goto c6IHY;
       c6IHZ: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6IHY: // global
           I64[Hp - 40] = f_s6I3V_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6IGm::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6IHT; else goto c6IHU;
       c6IHT: // global
           I64[Hp - 8] = sat_s6I41_info;
           P64[Hp] = _c6IGm::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6IHU: // global
           I64[Hp - 8] = sat_s6I48_info;
           P64[Hp] = _c6IGm::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.042360718 UTC

[section ""data" . Data.Monoid.$fShowFirst_$cshowsPrec_closure" {
     Data.Monoid.$fShowFirst_$cshowsPrec_closure:
         const Data.Monoid.$fShowFirst_$cshowsPrec_info;
         const 0;
 },
 Data.Monoid.$fShowFirst_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c6II7,
                       label: Data.Monoid.$fShowFirst_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6II7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6II8; else goto c6II9;
       c6II8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowFirst_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6II9: // global
           I64[Sp - 24] = block_c6II4_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6IId; else goto c6II5;
       u6IId: // global
           call _c6II4(R1) args: 0, res: 0, upd: 0;
       c6II5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6II4() //  [R1]
         { info_tbl: [(c6II4,
                       label: block_c6II4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6II4: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Monoid.$w$cshowsPrec_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.044354333 UTC

[section ""data" . Data.Monoid.$fShowFirst_$cshow_closure" {
     Data.Monoid.$fShowFirst_$cshow_closure:
         const Data.Monoid.$fShowFirst_$cshow_info;
         const 0;
 },
 sat_s6I4i_entry() //  [R1]
         { info_tbl: [(c6IIA,
                       label: sat_s6I4i_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IIA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6IIB; else goto c6IIC;
       c6IIB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IIC: // global
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Show.appPrec1_closure;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = Data.Monoid.$fReadFirst3_closure;
           Sp = Sp - 32;
           call GHC.Show.showsPrec_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_s6I4j_entry() //  [R1]
         { info_tbl: [(c6IIH,
                       label: sat_s6I4j_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IIH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6III; else goto c6IIJ;
       c6III: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IIJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6IIq_info;
           _s6I4e::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s6I4e::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6IIP; else goto c6IIr;
       u6IIP: // global
           call _c6IIq(R1) args: 0, res: 0, upd: 0;
       c6IIr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6IIq() //  [R1]
         { info_tbl: [(c6IIq,
                       label: block_c6IIq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IIq: // global
           if (R1 & 7 == 1) goto c6IIE; else goto c6IIF;
       c6IIE: // global
           R1 = Data.Monoid.$fShowFirst4_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c6IIF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6IIO; else goto c6IIN;
       c6IIO: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6IIN: // global
           _s6I4h::P64 = P64[R1 + 6];
           I64[Hp - 24] = sat_s6I4i_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _s6I4h::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.$fShowMaybe1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I4k_entry() //  [R1]
         { info_tbl: [(c6IIQ,
                       label: sat_s6I4k_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IIQ: // global
           _s6I4k::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IIR; else goto c6IIS;
       c6IIS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6IIU; else goto c6IIT;
       c6IIU: // global
           HpAlloc = 32;
           goto c6IIR;
       c6IIR: // global
           R1 = _s6I4k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IIT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I4k::P64;
           _s6I4e::P64 = P64[_s6I4k::P64 + 16];
           _s6I4f::P64 = P64[_s6I4k::P64 + 24];
           I64[Hp - 24] = sat_s6I4j_info;
           P64[Hp - 8] = _s6I4e::P64;
           P64[Hp] = _s6I4f::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fShowFirst_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6IIV,
                       label: Data.Monoid.$fShowFirst_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IIV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6IIZ; else goto c6IIY;
       c6IIZ: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowFirst_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6IIY: // global
           I64[Hp - 24] = sat_s6I4k_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.046910813 UTC

[section ""data" . Data.Monoid.$fShowFirst_$cshowList_closure" {
     Data.Monoid.$fShowFirst_$cshowList_closure:
         const Data.Monoid.$fShowFirst_$cshowList_info;
         const 0;
 },
 sat_s6I4p_entry() //  [R1, R2]
         { info_tbl: [(c6IJ9,
                       label: sat_s6I4p_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IJ9: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Monoid.$w$cshowsPrec_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fShowFirst_$cshowList_entry() //  [R2, R3, R4]
         { info_tbl: [(c6IJc,
                       label: Data.Monoid.$fShowFirst_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IJc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6IJg; else goto c6IJf;
       c6IJg: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowFirst_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6IJf: // global
           I64[Hp - 8] = sat_s6I4p_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.048516467 UTC

[section ""data" . Data.Monoid.$fShowFirst_closure" {
     Data.Monoid.$fShowFirst_closure:
         const Data.Monoid.$fShowFirst_info;
         const 0;
 },
 sat_s6I4t_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IJq,
                       label: sat_s6I4t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IJq: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fShowFirst_$cshowList_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I4s_entry() //  [R1, R2]
         { info_tbl: [(c6IJy,
                       label: sat_s6I4s_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IJy: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Monoid.$fShowFirst_$cshow_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I4r_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IJG,
                       label: sat_s6I4r_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IJG: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fShowFirst_$cshowsPrec_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fShowFirst_entry() //  [R2]
         { info_tbl: [(c6IJK,
                       label: Data.Monoid.$fShowFirst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IJK: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6IJO; else goto c6IJN;
       c6IJO: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Monoid.$fShowFirst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IJN: // global
           I64[Hp - 72] = sat_s6I4t_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6I4s_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6I4r_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.050029179 UTC

[section ""cstring" . Data.Monoid.$fReadFirst11_bytes" {
     Data.Monoid.$fReadFirst11_bytes:
         I8[] [70,105,114,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.050807282 UTC

[section ""data" . Data.Monoid.$fReadFirst10_closure" {
     Data.Monoid.$fReadFirst10_closure:
         const Data.Monoid.$fReadFirst10_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadFirst10_entry() //  [R1]
         { info_tbl: [(c6IJV,
                       label: Data.Monoid.$fReadFirst10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IJV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IJW; else goto c6IJX;
       c6IJW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IJX: // global
           (_c6IJS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6IJS::I64 == 0) goto c6IJU; else goto c6IJT;
       c6IJU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6IJT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6IJS::I64;
           R2 = Data.Monoid.$fReadFirst11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.051787265 UTC

[section ""data" . Data.Monoid.$fReadFirst_lexeme1_closure" {
     Data.Monoid.$fReadFirst_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Monoid.$fReadFirst10_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.05238085 UTC

[section ""cstring" . Data.Monoid.$fReadFirst7_bytes" {
     Data.Monoid.$fReadFirst7_bytes:
         I8[] [103,101,116,70,105,114,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.053128562 UTC

[section ""data" . Data.Monoid.$fReadFirst6_closure" {
     Data.Monoid.$fReadFirst6_closure:
         const Data.Monoid.$fReadFirst6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadFirst6_entry() //  [R1]
         { info_tbl: [(c6IK4,
                       label: Data.Monoid.$fReadFirst6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IK4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IK5; else goto c6IK6;
       c6IK5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IK6: // global
           (_c6IK1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6IK1::I64 == 0) goto c6IK3; else goto c6IK2;
       c6IK3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6IK2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6IK1::I64;
           R2 = Data.Monoid.$fReadFirst7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.055814399 UTC

[section ""data" . Data.Monoid.$fReadFirst1_closure" {
     Data.Monoid.$fReadFirst1_closure:
         const Data.Monoid.$fReadFirst1_info;
         const 0;
 },
 ds_s6I4x_entry() //  [R1, R3]
         { info_tbl: [(c6IKg,
                       label: ds_s6I4x_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IKg: // global
           R4 = R3;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = P64[R1 + 6];
           call GHC.Read.$fReadMaybe1_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I4J_entry() //  [R1]
         { info_tbl: [(c6IKR,
                       label: sat_s6I4J_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IKR: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I4M_entry() //  [R1, R2]
         { info_tbl: [(c6IKX,
                       label: sat_s6I4M_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IKX: // global
           _s6I4H::P64 = R2;
           _s6I4M::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6IKY; else goto c6IKZ;
       c6IKZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IL1; else goto c6IL0;
       c6IL1: // global
           HpAlloc = 24;
           goto c6IKY;
       c6IKY: // global
           R2 = _s6I4H::P64;
           R1 = _s6I4M::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IL0: // global
           _s6I4B::P64 = P64[_s6I4M::P64 + 7];
           I64[Hp - 16] = sat_s6I4J_info;
           P64[Hp - 8] = _s6I4B::P64;
           P64[Hp] = _s6I4H::P64;
           I64[Sp - 8] = block_c6IKU_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadFirst2_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6IKU() //  [R1]
         { info_tbl: [(c6IKU,
                       label: block_c6IKU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IKU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6IL4; else goto c6IL3;
       c6IL4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6IL3: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I4N_entry() //  [R1, R2]
         { info_tbl: [(c6IL5,
                       label: sat_s6I4N_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IL5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6IL9; else goto c6IL8;
       c6IL9: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IL8: // global
           _s6I4x::P64 = P64[R1 + 7];
           _s6I4B::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6I4M_info;
           P64[Hp] = _s6I4B::P64;
           R5 = Hp - 7;
           R4 = Data.Monoid.$fReadFirst5_closure+1;
           R3 = _s6I4x::P64;
           R2 = Data.Monoid.$fReadFirst6_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I4Q_entry() //  [R1, R2]
         { info_tbl: [(c6ILd,
                       label: sat_s6I4Q_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ILd: // global
           _s6I4F::P64 = R2;
           _s6I4Q::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6ILe; else goto c6ILf;
       c6ILf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6ILh; else goto c6ILg;
       c6ILh: // global
           HpAlloc = 24;
           goto c6ILe;
       c6ILe: // global
           R2 = _s6I4F::P64;
           R1 = _s6I4Q::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6ILg: // global
           _s6I4x::P64 = P64[_s6I4Q::P64 + 7];
           _s6I4B::P64 = P64[_s6I4Q::P64 + 15];
           I64[Hp - 16] = sat_s6I4N_info;
           P64[Hp - 8] = _s6I4x::P64;
           P64[Hp] = _s6I4B::P64;
           I64[Sp - 8] = block_c6ILa_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadFirst_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6ILa() //  [R1]
         { info_tbl: [(c6ILa,
                       label: block_c6ILa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ILa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6ILk; else goto c6ILj;
       c6ILk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ILj: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I4T_entry() //  [R1, R2, R3]
         { info_tbl: [(c6ILl,
                       label: sat_s6I4T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ILl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6ILm; else goto c6ILn;
       c6ILm: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ILn: // global
           I64[Sp - 24] = block_c6IKo_info;
           _s6I4x::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6I4x::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6ILA; else goto c6IKp;
       u6ILA: // global
           call _c6IKo(R1) args: 0, res: 0, upd: 0;
       c6IKp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6IKo() //  [R1]
         { info_tbl: [(c6IKo,
                       label: block_c6IKo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IKo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6ILq; else goto c6ILp;
       c6ILq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ILp: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6ILs; else goto c6ILw;
       c6ILs: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6ILw: // global
           I64[Hp - 16] = sat_s6I4Q_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6ILt_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadFirst_lexeme1_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6ILt() //  [R1]
         { info_tbl: [(c6ILt,
                       label: block_c6ILt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ILt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6ILz; else goto c6ILy;
       c6ILz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ILy: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadFirst1_entry() //  [R2, R3, R4]
         { info_tbl: [(c6ILB,
                       label: Data.Monoid.$fReadFirst1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ILB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6ILF; else goto c6ILE;
       c6ILF: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fReadFirst1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ILE: // global
           I64[Hp - 24] = ds_s6I4x_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6I4T_info;
           P64[Hp] = Hp - 22;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.060291324 UTC

[section ""data" . Data.Monoid.$fReadFirst_$creadsPrec_closure" {
     Data.Monoid.$fReadFirst_$creadsPrec_closure:
         const Data.Monoid.$fReadFirst_$creadsPrec_info;
         const 0;
 },
 sat_s6I4W_entry() //  [R1]
         { info_tbl: [(c6ILO,
                       label: sat_s6I4W_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ILO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ILP; else goto c6ILQ;
       c6ILP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ILQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadFirst1_entry(R4,
                                               R3,
                                               R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fReadFirst_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c6ILR,
                       label: Data.Monoid.$fReadFirst_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ILR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6ILV; else goto c6ILU;
       c6ILV: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fReadFirst_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ILU: // global
           I64[Hp - 24] = sat_s6I4W_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.06181743 UTC

[section ""data" . Data.Monoid.$fReadFirst_$creadListPrec_closure" {
     Data.Monoid.$fReadFirst_$creadListPrec_closure:
         const Data.Monoid.$fReadFirst_$creadListPrec_info;
         const 0;
 },
 sat_s6I4Y_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IM5,
                       label: sat_s6I4Y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IM5: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadFirst1_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadFirst_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6IM8,
                       label: Data.Monoid.$fReadFirst_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IM8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6IMc; else goto c6IMb;
       c6IMc: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Monoid.$fReadFirst_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IMb: // global
           I64[Hp - 8] = sat_s6I4Y_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.063358001 UTC

[section ""data" . Data.Monoid.$fReadFirst_$creadList_closure" {
     Data.Monoid.$fReadFirst_$creadList_closure:
         const Data.Monoid.$fReadFirst_$creadList_info;
         const 0;
 },
 sat_s6I50_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IMq,
                       label: sat_s6I50_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IMq: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadFirst1_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I51_entry() //  [R1]
         { info_tbl: [(c6IMt,
                       label: sat_s6I51_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IMt: // global
           _s6I51::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6IMu; else goto c6IMv;
       c6IMv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6IMx; else goto c6IMw;
       c6IMx: // global
           HpAlloc = 16;
           goto c6IMu;
       c6IMu: // global
           R1 = _s6I51::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IMw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I51::P64;
           _s6I4Z::P64 = P64[_s6I51::P64 + 16];
           I64[Hp - 8] = sat_s6I50_info;
           P64[Hp] = _s6I4Z::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fReadFirst_$creadList_entry() //  [R2]
         { info_tbl: [(c6IMy,
                       label: Data.Monoid.$fReadFirst_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IMy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IMC; else goto c6IMB;
       c6IMC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Monoid.$fReadFirst_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IMB: // global
           I64[Hp - 16] = sat_s6I51_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.065546746 UTC

[section ""data" . Data.Monoid.$fReadFirst_closure" {
     Data.Monoid.$fReadFirst_closure:
         const Data.Monoid.$fReadFirst_info;
         const 0;
 },
 sat_s6I56_entry() //  [R1]
         { info_tbl: [(c6IML,
                       label: sat_s6I56_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IML: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IMM; else goto c6IMN;
       c6IMM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IMN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadFirst_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I55_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IMT,
                       label: sat_s6I55_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IMT: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadFirst1_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I54_entry() //  [R1]
         { info_tbl: [(c6IN0,
                       label: sat_s6I54_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IN0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IN1; else goto c6IN2;
       c6IN1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IN2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadFirst_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I53_entry() //  [R1, R2]
         { info_tbl: [(c6IN8,
                       label: sat_s6I53_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IN8: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Monoid.$fReadFirst_$creadsPrec_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadFirst_entry() //  [R2]
         { info_tbl: [(c6INc,
                       label: Data.Monoid.$fReadFirst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6INc: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c6INg; else goto c6INf;
       c6INg: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Monoid.$fReadFirst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6INf: // global
           I64[Hp - 112] = sat_s6I56_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6I55_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s6I54_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s6I53_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 112;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.067755089 UTC

[section ""data" . Data.Monoid.$fEqFirst_closure" {
     Data.Monoid.$fEqFirst_closure:
         const Data.Monoid.$fEqFirst_info;
 },
 sat_s6I59_entry() //  [R1, R2, R3]
         { info_tbl: [(c6INq,
                       label: sat_s6I59_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6INq: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c/=_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I58_entry() //  [R1, R2, R3]
         { info_tbl: [(c6INy,
                       label: sat_s6I58_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6INy: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fEqFirst_entry() //  [R2]
         { info_tbl: [(c6INC,
                       label: Data.Monoid.$fEqFirst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6INC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6ING; else goto c6INF;
       c6ING: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Monoid.$fEqFirst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6INF: // global
           I64[Hp - 48] = sat_s6I59_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s6I58_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.06951311 UTC

[section ""data" . Data.Monoid.$fOrdFirst_$cp1Ord_closure" {
     Data.Monoid.$fOrdFirst_$cp1Ord_closure:
         const Data.Monoid.$fOrdFirst_$cp1Ord_info;
 },
 sat_s6I5b_entry() //  [R1]
         { info_tbl: [(c6INP,
                       label: sat_s6I5b_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6INP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6INQ; else goto c6INR;
       c6INQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6INR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fOrdFirst_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6INS,
                       label: Data.Monoid.$fOrdFirst_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6INS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6INW; else goto c6INV;
       c6INW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Monoid.$fOrdFirst_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6INV: // global
           I64[Hp - 16] = sat_s6I5b_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Monoid.$fEqFirst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.071807853 UTC

[section ""data" . Data.Monoid.$fOrdFirst_closure" {
     Data.Monoid.$fOrdFirst_closure:
         const Data.Monoid.$fOrdFirst_info;
 },
 sat_s6I5m_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IO6,
                       label: sat_s6I5m_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IO6: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmin_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I5l_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IOe,
                       label: sat_s6I5l_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IOe: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmax_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I5k_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IOm,
                       label: sat_s6I5k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IOm: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c>=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I5j_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IOu,
                       label: sat_s6I5j_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IOu: // global
           R4 = R2;
           R3 = R3;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I5g_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IOC,
                       label: sat_s6I5g_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IOC: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I5f_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IOK,
                       label: sat_s6I5f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IOK: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I5e_entry() //  [R1, R2, R3]
         { info_tbl: [(c6IOS,
                       label: sat_s6I5e_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IOS: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I5d_entry() //  [R1]
         { info_tbl: [(c6IOZ,
                       label: sat_s6I5d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IOZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IP0; else goto c6IP1;
       c6IP0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IP1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fOrdFirst_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fOrdFirst_entry() //  [R2]
         { info_tbl: [(c6IP3,
                       label: Data.Monoid.$fOrdFirst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IP3: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto c6IP7; else goto c6IP6;
       c6IP7: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = Data.Monoid.$fOrdFirst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IP6: // global
           I64[Hp - 200] = sat_s6I5m_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6I5l_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s6I5k_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s6I5j_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6I5g_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s6I5f_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6I5e_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6I5d_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.074593987 UTC

[section ""data" . Data.Monoid.getFirst_closure" {
     Data.Monoid.getFirst_closure:
         const Data.Monoid.getFirst_info;
 },
 Data.Monoid.getFirst_entry() //  [R2]
         { info_tbl: [(c6IPc,
                       label: Data.Monoid.getFirst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IPc: // global
           R2 = R2;
           call Data.Monoid.$fGeneric1First2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.075497418 UTC

[section ""data" . Data.Monoid.getLast_closure" {
     Data.Monoid.getLast_closure:
         const Data.Monoid.getLast_info;
 },
 Data.Monoid.getLast_entry() //  [R2]
         { info_tbl: [(c6IPj,
                       label: Data.Monoid.getLast_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IPj: // global
           R2 = R2;
           call Data.Monoid.$fGeneric1Last2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.076243886 UTC

[section ""cstring" . Data.Monoid.$trModule4_bytes" {
     Data.Monoid.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.076848218 UTC

[section ""data" . Data.Monoid.$trModule3_closure" {
     Data.Monoid.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.077453264 UTC

[section ""cstring" . Data.Monoid.$trModule2_bytes" {
     Data.Monoid.$trModule2_bytes:
         I8[] [68,97,116,97,46,77,111,110,111,105,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.078071301 UTC

[section ""data" . Data.Monoid.$trModule1_closure" {
     Data.Monoid.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.07877457 UTC

[section ""data" . Data.Monoid.$trModule_closure" {
     Data.Monoid.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Monoid.$trModule3_closure+1;
         const Data.Monoid.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.079409343 UTC

[section ""data" . $krep_r6I1r_closure" {
     $krep_r6I1r_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.082743963 UTC

[section ""data" . $krep1_r6I1s_closure" {
     $krep1_r6I1s_closure:
         const :_con_info;
         const $krep_r6I1r_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.083406749 UTC

[section ""data" . $krep2_r6I1t_closure" {
     $krep2_r6I1t_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep1_r6I1s_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.084022591 UTC

[section ""data" . Data.Monoid.$tcFirst1_closure" {
     Data.Monoid.$tcFirst1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$fReadFirst11_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.084628617 UTC

[section ""data" . Data.Monoid.$tcFirst_closure" {
     Data.Monoid.$tcFirst_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Monoid.$trModule_closure+1;
         const Data.Monoid.$tcFirst1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 12072287807032806756;
         const 12788244796562536401;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.085309174 UTC

[section ""data" . $krep3_r6I1u_closure" {
     $krep3_r6I1u_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Monoid.$tcFirst_closure+1;
         const $krep1_r6I1s_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.085936742 UTC

[section ""data" . Data.Monoid.$tc'First1_closure" {
     Data.Monoid.$tc'First1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r6I1t_closure+1;
         const $krep3_r6I1u_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.086535851 UTC

[section ""cstring" . Data.Monoid.$tc'First3_bytes" {
     Data.Monoid.$tc'First3_bytes:
         I8[] [39,70,105,114,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.0871053 UTC

[section ""data" . Data.Monoid.$tc'First2_closure" {
     Data.Monoid.$tc'First2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$tc'First3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.087693933 UTC

[section ""data" . Data.Monoid.$tc'First_closure" {
     Data.Monoid.$tc'First_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Monoid.$trModule_closure+1;
         const Data.Monoid.$tc'First2_closure+1;
         const Data.Monoid.$tc'First1_closure+4;
         const 7752528083504400280;
         const 15965132804789246607;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.088316721 UTC

[section ""data" . Data.Monoid.$tcLast1_closure" {
     Data.Monoid.$tcLast1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$fReadLast5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.088916435 UTC

[section ""data" . Data.Monoid.$tcLast_closure" {
     Data.Monoid.$tcLast_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Monoid.$trModule_closure+1;
         const Data.Monoid.$tcLast1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 6920195955404695016;
         const 2388797855174213212;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.089768877 UTC

[section ""data" . $krep4_r6I1v_closure" {
     $krep4_r6I1v_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Monoid.$tcLast_closure+1;
         const $krep1_r6I1s_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.090400543 UTC

[section ""data" . Data.Monoid.$tc'Last1_closure" {
     Data.Monoid.$tc'Last1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r6I1t_closure+1;
         const $krep4_r6I1v_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.091035427 UTC

[section ""cstring" . Data.Monoid.$tc'Last3_bytes" {
     Data.Monoid.$tc'Last3_bytes:
         I8[] [39,76,97,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.091603214 UTC

[section ""data" . Data.Monoid.$tc'Last2_closure" {
     Data.Monoid.$tc'Last2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$tc'Last3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.092159599 UTC

[section ""data" . Data.Monoid.$tc'Last_closure" {
     Data.Monoid.$tc'Last_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Monoid.$trModule_closure+1;
         const Data.Monoid.$tc'Last2_closure+1;
         const Data.Monoid.$tc'Last1_closure+4;
         const 5411164464353425083;
         const 12998161994081761510;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.092805465 UTC

[section ""relreadonly" . S6I7j_srt" {
     S6I7j_srt:
         const Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
         const Data.Monoid.$fMonoidFirst_closure;
         const Data.Monoid.$fMonoidLast_closure;
         const GHC.Show.$fShowMaybe_$cshowsPrec_closure;
         const Data.Monoid.$w$cshowsPrec1_closure;
         const Data.Monoid.$fShowLast_$cshowsPrec_closure;
         const GHC.Show.$fShowMaybe4_closure;
         const Data.Monoid.$fReadFirst3_closure;
         const GHC.Show.$fShowMaybe1_closure;
         const Data.Monoid.$fShowFirst4_closure;
         const Data.Monoid.$fShowLast_$cshow_closure;
         const Data.Monoid.$fShowLast_$cshowList_closure;
         const Data.Monoid.$fShowLast_closure;
         const GHC.Read.$fReadMaybe1_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Monoid.$fReadFirst2_closure;
         const GHC.Read.readField_closure;
         const Data.Monoid.$fReadLast2_closure;
         const Data.Monoid.$fReadFirst_lexeme_closure;
         const Data.Monoid.$fReadLast_lexeme_closure;
         const GHC.Read.list3_closure;
         const Data.Monoid.$fReadLast1_closure;
         const Data.Monoid.$fReadLast_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Monoid.$fReadLast_$creadListPrec_closure;
         const Data.Monoid.$fReadLast_$creadList_closure;
         const Data.Monoid.$fReadLast_closure;
         const Data.Monoid.$w$cshowsPrec_closure;
         const Data.Monoid.$fShowFirst_$cshowsPrec_closure;
         const Data.Monoid.$fShowFirst_$cshow_closure;
         const Data.Monoid.$fShowFirst_$cshowList_closure;
         const Data.Monoid.$fShowFirst_closure;
         const Data.Monoid.$fReadFirst6_closure;
         const Data.Monoid.$fReadFirst_lexeme1_closure;
         const Data.Monoid.$fReadFirst1_closure;
         const Data.Monoid.$fReadFirst_$creadsPrec_closure;
         const Data.Monoid.$fReadFirst_$creadListPrec_closure;
         const Data.Monoid.$fReadFirst_$creadList_closure;
         const Data.Monoid.$fReadFirst_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.093926495 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:01:57.095718486 UTC

[section ""data" . Data.Monoid.$fMonoidFirst_$c<>_closure" {
     Data.Monoid.$fMonoidFirst_$c<>_closure:
         const Data.Monoid.$fMonoidFirst_$c<>_info;
 },
 Data.Monoid.$fMonoidFirst_$c<>_entry() //  [R2, R3]
         { info_tbl: [(c6IPx,
                       label: Data.Monoid.$fMonoidFirst_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IPx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IPy; else goto c6IPz;
       c6IPy: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fMonoidFirst_$c<>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6IPz: // global
           I64[Sp - 16] = block_c6IPq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6IPG; else goto c6IPr;
       u6IPG: // global
           call _c6IPq(R1) args: 0, res: 0, upd: 0;
       c6IPr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6IPq() //  [R1]
         { info_tbl: [(c6IPq,
                       label: block_c6IPq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IPq: // global
           if (R1 & 7 == 1) goto c6IPu; else goto c6IPv;
       c6IPu: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6IPv: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.102411302 UTC

[section ""data" . Data.Monoid.$fSemigroupFirst1_closure" {
     Data.Monoid.$fSemigroupFirst1_closure:
         const Data.Monoid.$fSemigroupFirst1_info;
 },
 Data.Monoid.$fSemigroupFirst1_entry() //  [R2, R3]
         { info_tbl: [(c6IQ7,
                       label: Data.Monoid.$fSemigroupFirst1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IQ7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6IQ8; else goto u6IQt;
       c6IQ8: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fSemigroupFirst1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u6IQt: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c6IPX() args: 0, res: 0, upd: 0;
     }
 },
 _c6IPX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IPX: // global
           I64[Sp - 8] = block_c6IQ0_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6IQv; else goto c6IQ1;
       u6IQv: // global
           call _c6IQ0(R1) args: 0, res: 0, upd: 0;
       c6IQ1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6IQ0() //  [R1]
         { info_tbl: [(c6IQ0,
                       label: block_c6IQ0_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IQ0: // global
           _s6I1B::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6IQ4; else goto c6IQ5;
       c6IQ4: // global
           R1 = _s6I1B::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6IQ5: // global
           I64[Sp] = block_c6IQf_info;
           _s6I1E::P64 = P64[R1 + 6];
           _s6I1F::P64 = P64[R1 + 14];
           R1 = _s6I1B::P64;
           P64[Sp + 8] = _s6I1F::P64;
           P64[Sp + 16] = _s6I1E::P64;
           if (R1 & 7 != 0) goto u6IQw; else goto c6IQh;
       u6IQw: // global
           call _c6IQf(R1) args: 0, res: 0, upd: 0;
       c6IQh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6IQf() //  [R1]
         { info_tbl: [(c6IQf,
                       label: block_c6IQf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IQf: // global
           if (R1 & 7 == 1) goto c6IQn; else goto c6IQr;
       c6IQn: // global
           _s6I1C::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s6I1C::P64;
           Sp = Sp + 8;
           call _c6IPX() args: 0, res: 0, upd: 0;
       c6IQr: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.111804341 UTC

[section ""data" . Data.Monoid.$fSemigroupFirst_$csconcat_closure" {
     Data.Monoid.$fSemigroupFirst_$csconcat_closure:
         const Data.Monoid.$fSemigroupFirst_$csconcat_info;
 },
 Data.Monoid.$fSemigroupFirst_$csconcat_entry() //  [R2]
         { info_tbl: [(c6IR4,
                       label: Data.Monoid.$fSemigroupFirst_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IR4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6IR5; else goto c6IR6;
       c6IR5: // global
           R2 = R2;
           R1 = Data.Monoid.$fSemigroupFirst_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IR6: // global
           I64[Sp - 8] = block_c6IR1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6IRa; else goto c6IR2;
       u6IRa: // global
           call _c6IR1(R1) args: 0, res: 0, upd: 0;
       c6IR2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6IR1() //  [R1]
         { info_tbl: [(c6IR1,
                       label: block_c6IR1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IR1: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Monoid.$fSemigroupFirst1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.119150813 UTC

[section ""data" . Data.Monoid.$fMonoidFirst_go_closure" {
     Data.Monoid.$fMonoidFirst_go_closure:
         const Data.Monoid.$fMonoidFirst_go_info;
 },
 Data.Monoid.$fMonoidFirst_go_entry() //  [R2]
         { info_tbl: [(c6IRv,
                       label: Data.Monoid.$fMonoidFirst_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IRv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IRw; else goto u6IRR;
       c6IRw: // global
           R2 = R2;
           R1 = Data.Monoid.$fMonoidFirst_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u6IRR: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c6IRl() args: 0, res: 0, upd: 0;
     }
 },
 _c6IRl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IRl: // global
           _s6I1M::P64 = P64[Sp];
           I64[Sp] = block_c6IRo_info;
           R1 = _s6I1M::P64;
           if (R1 & 7 != 0) goto u6IRT; else goto c6IRp;
       u6IRT: // global
           call _c6IRo(R1) args: 0, res: 0, upd: 0;
       c6IRp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6IRo() //  [R1]
         { info_tbl: [(c6IRo,
                       label: block_c6IRo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IRo: // global
           if (R1 & 7 == 1) goto c6IRs; else goto c6IRt;
       c6IRs: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6IRt: // global
           I64[Sp - 8] = block_c6IRD_info;
           _s6I1P::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s6I1P::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6IRU; else goto c6IRF;
       u6IRU: // global
           call _c6IRD(R1) args: 0, res: 0, upd: 0;
       c6IRF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6IRD() //  [R1]
         { info_tbl: [(c6IRD,
                       label: block_c6IRD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IRD: // global
           if (R1 & 7 == 1) goto c6IRL; else goto c6IRP;
       c6IRL: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c6IRl() args: 0, res: 0, upd: 0;
       c6IRP: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.12799751 UTC

[section ""data" . Data.Monoid.$fSemigroupFirst_closure" {
     Data.Monoid.$fSemigroupFirst_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Monoid.$fMonoidFirst_$c<>_closure+2;
         const Data.Monoid.$fSemigroupFirst_$csconcat_closure+1;
         const Data.Monoid.$fSemigroupFirst_$cstimes_closure+3;
         const 0;
 },
 section ""data" . Data.Monoid.$fMonoidFirst_closure" {
     Data.Monoid.$fMonoidFirst_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Monoid.$fSemigroupFirst_closure+1;
         const GHC.Base.Nothing_closure+1;
         const Data.Monoid.$fMonoidFirst_$c<>_closure+2;
         const Data.Monoid.$fMonoidFirst_go_closure+1;
         const 0;
 },
 section ""data" . Data.Monoid.$fSemigroupFirst_$cstimes_closure" {
     Data.Monoid.$fSemigroupFirst_$cstimes_closure:
         const Data.Monoid.$fSemigroupFirst_$cstimes_info;
         const 0;
 },
 Data.Monoid.$fSemigroupFirst_$cstimes_entry() //  [R2, R3, R4]
         { info_tbl: [(c6ISo,
                       label: Data.Monoid.$fSemigroupFirst_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ISo: // global
           R5 = R4;
           R4 = R3;
           R3 = Data.Monoid.$fMonoidFirst_closure+1;
           R2 = R2;
           call Data.Semigroup.Internal.stimesIdempotentMonoid_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.133603384 UTC

[section ""data" . Data.Monoid.$fMonoidLast_$c<>_closure" {
     Data.Monoid.$fMonoidLast_$c<>_closure:
         const Data.Monoid.$fMonoidLast_$c<>_info;
 },
 Data.Monoid.$fMonoidLast_$c<>_entry() //  [R2, R3]
         { info_tbl: [(c6ISI,
                       label: Data.Monoid.$fMonoidLast_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ISI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ISJ; else goto c6ISK;
       c6ISJ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fMonoidLast_$c<>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ISK: // global
           I64[Sp - 16] = block_c6ISB_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6ISR; else goto c6ISC;
       u6ISR: // global
           call _c6ISB(R1) args: 0, res: 0, upd: 0;
       c6ISC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6ISB() //  [R1]
         { info_tbl: [(c6ISB,
                       label: block_c6ISB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ISB: // global
           if (R1 & 7 == 1) goto c6ISF; else goto c6ISG;
       c6ISF: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6ISG: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.140465743 UTC

[section ""data" . Data.Monoid.$fSemigroupLast1_closure" {
     Data.Monoid.$fSemigroupLast1_closure:
         const Data.Monoid.$fSemigroupLast1_info;
 },
 Data.Monoid.$fSemigroupLast1_entry() //  [R2, R3]
         { info_tbl: [(c6ITi,
                       label: Data.Monoid.$fSemigroupLast1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ITi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ITj; else goto c6ITk;
       c6ITj: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fSemigroupLast1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ITk: // global
           I64[Sp - 16] = block_c6ITb_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6ITG; else goto c6ITc;
       u6ITG: // global
           call _c6ITb(R1) args: 0, res: 0, upd: 0;
       c6ITc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6ITb() //  [R1]
         { info_tbl: [(c6ITb,
                       label: block_c6ITb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ITb: // global
           if (R1 & 7 == 1) goto u6ITD; else goto c6ITg;
       u6ITD: // global
           Sp = Sp + 8;
           call _c6ITx() args: 0, res: 0, upd: 0;
       c6ITg: // global
           I64[Sp] = block_c6ITq_info;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Monoid.$fSemigroupLast1_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6ITq() //  [R1]
         { info_tbl: [(c6ITq,
                       label: block_c6ITq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ITq: // global
           if (R1 & 7 == 1) goto u6ITE; else goto c6ITB;
       u6ITE: // global
           Sp = Sp + 8;
           call _c6ITx() args: 0, res: 0, upd: 0;
       c6ITB: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6ITx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ITx: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.149047384 UTC

[section ""data" . Data.Monoid.$fSemigroupLast_$csconcat_closure" {
     Data.Monoid.$fSemigroupLast_$csconcat_closure:
         const Data.Monoid.$fSemigroupLast_$csconcat_info;
 },
 Data.Monoid.$fSemigroupLast_$csconcat_entry() //  [R2]
         { info_tbl: [(c6IUb,
                       label: Data.Monoid.$fSemigroupLast_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IUb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6IUc; else goto c6IUd;
       c6IUc: // global
           R2 = R2;
           R1 = Data.Monoid.$fSemigroupLast_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IUd: // global
           I64[Sp - 8] = block_c6IU8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6IUh; else goto c6IU9;
       u6IUh: // global
           call _c6IU8(R1) args: 0, res: 0, upd: 0;
       c6IU9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6IU8() //  [R1]
         { info_tbl: [(c6IU8,
                       label: block_c6IU8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IU8: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Monoid.$fSemigroupLast1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.155436612 UTC

[section ""data" . Data.Monoid.$fMonoidLast_go_closure" {
     Data.Monoid.$fMonoidLast_go_closure:
         const Data.Monoid.$fMonoidLast_go_info;
 },
 Data.Monoid.$fMonoidLast_go_entry() //  [R2]
         { info_tbl: [(c6IUC,
                       label: Data.Monoid.$fMonoidLast_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IUC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IUD; else goto c6IUE;
       c6IUD: // global
           R2 = R2;
           R1 = Data.Monoid.$fMonoidLast_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IUE: // global
           I64[Sp - 8] = block_c6IUv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6IUX; else goto c6IUw;
       u6IUX: // global
           call _c6IUv(R1) args: 0, res: 0, upd: 0;
       c6IUw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6IUv() //  [R1]
         { info_tbl: [(c6IUv,
                       label: block_c6IUv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IUv: // global
           if (R1 & 7 == 1) goto c6IUz; else goto c6IUA;
       c6IUz: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6IUA: // global
           I64[Sp - 8] = block_c6IUK_info;
           R2 = P64[R1 + 14];
           P64[Sp] = P64[R1 + 6];
           Sp = Sp - 8;
           call Data.Monoid.$fMonoidLast_go_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6IUK() //  [R1]
         { info_tbl: [(c6IUK,
                       label: block_c6IUK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IUK: // global
           if (R1 & 7 == 1) goto c6IUR; else goto c6IUV;
       c6IUR: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6IUV: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.164046021 UTC

[section ""data" . Data.Monoid.$fSemigroupLast_closure" {
     Data.Monoid.$fSemigroupLast_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Monoid.$fMonoidLast_$c<>_closure+2;
         const Data.Monoid.$fSemigroupLast_$csconcat_closure+1;
         const Data.Monoid.$fSemigroupLast_$cstimes_closure+3;
         const 0;
 },
 section ""data" . Data.Monoid.$fMonoidLast_closure" {
     Data.Monoid.$fMonoidLast_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Monoid.$fSemigroupLast_closure+1;
         const GHC.Base.Nothing_closure+1;
         const Data.Monoid.$fMonoidLast_$c<>_closure+2;
         const Data.Monoid.$fMonoidLast_go_closure+1;
         const 0;
 },
 section ""data" . Data.Monoid.$fSemigroupLast_$cstimes_closure" {
     Data.Monoid.$fSemigroupLast_$cstimes_closure:
         const Data.Monoid.$fSemigroupLast_$cstimes_info;
         const 0;
 },
 Data.Monoid.$fSemigroupLast_$cstimes_entry() //  [R2, R3, R4]
         { info_tbl: [(c6IVo,
                       label: Data.Monoid.$fSemigroupLast_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IVo: // global
           R5 = R4;
           R4 = R3;
           R3 = Data.Monoid.$fMonoidLast_closure+1;
           R2 = R2;
           call Data.Semigroup.Internal.stimesIdempotentMonoid_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.169501063 UTC

[section ""data" . Data.Monoid.$fFunctorLast_closure" {
     Data.Monoid.$fFunctorLast_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fApplicativeMaybe_$cfmap_closure+2;
         const GHC.Base.$fFunctorMaybe_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.171481007 UTC

[section ""data" . Data.Monoid.$fApplicativeLast_closure" {
     Data.Monoid.$fApplicativeLast_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Monoid.$fFunctorLast_closure+1;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fApplicativeMaybe_$c<*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$cliftA2_closure+3;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c<*_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.173349881 UTC

[section ""data" . Data.Monoid.$fMonadLast_closure" {
     Data.Monoid.$fMonadLast_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Monoid.$fApplicativeLast_closure+1;
         const GHC.Base.$fMonadMaybe_$c>>=_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fMonadMaybe_$cfail_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.175357042 UTC

[section ""data" . Data.Monoid.$fGeneric1Last1_closure" {
     Data.Monoid.$fGeneric1Last1_closure:
         const Data.Monoid.$fGeneric1Last1_info;
 },
 Data.Monoid.$fGeneric1Last1_entry() //  [R2]
         { info_tbl: [(c6IVE,
                       label: Data.Monoid.$fGeneric1Last1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IVE: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.178722973 UTC

[section ""data" . Data.Monoid.$fGeneric1Last2_closure" {
     Data.Monoid.$fGeneric1Last2_closure:
         const Data.Monoid.$fGeneric1Last2_info;
 },
 Data.Monoid.$fGeneric1Last2_entry() //  [R2]
         { info_tbl: [(c6IVP,
                       label: Data.Monoid.$fGeneric1Last2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IVP: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.181950553 UTC

[section ""data" . Data.Monoid.$fGeneric1Last_closure" {
     Data.Monoid.$fGeneric1Last_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Monoid.$fGeneric1Last2_closure+1;
         const Data.Monoid.$fGeneric1Last1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.183756837 UTC

[section ""data" . Data.Monoid.$fGenericLast1_closure" {
     Data.Monoid.$fGenericLast1_closure:
         const Data.Monoid.$fGenericLast1_info;
 },
 Data.Monoid.$fGenericLast1_entry() //  [R2]
         { info_tbl: [(c6IW3,
                       label: Data.Monoid.$fGenericLast1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IW3: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.186994292 UTC

[section ""data" . Data.Monoid.$fGenericLast2_closure" {
     Data.Monoid.$fGenericLast2_closure:
         const Data.Monoid.$fGenericLast2_info;
 },
 Data.Monoid.$fGenericLast2_entry() //  [R2]
         { info_tbl: [(c6IWe,
                       label: Data.Monoid.$fGenericLast2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IWe: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.191018612 UTC

[section ""data" . Data.Monoid.$fGenericLast_closure" {
     Data.Monoid.$fGenericLast_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Monoid.$fGenericLast2_closure+1;
         const Data.Monoid.$fGenericLast1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.19283354 UTC

[section ""data" . Data.Monoid.$fShowFirst1_closure" {
     Data.Monoid.$fShowFirst1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.194642432 UTC

[section ""cstring" . Data.Monoid.$fShowLast2_bytes" {
     Data.Monoid.$fShowLast2_bytes:
         I8[] [76,97,115,116,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.196332083 UTC

[section ""cstring" . Data.Monoid.$fShowLast1_bytes" {
     Data.Monoid.$fShowLast1_bytes:
         I8[] [103,101,116,76,97,115,116,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.198126083 UTC

[section ""cstring" . Data.Monoid.$fReadFirst4_bytes" {
     Data.Monoid.$fReadFirst4_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.201991923 UTC

[section ""data" . Data.Monoid.$w$cshowsPrec1_closure" {
     Data.Monoid.$w$cshowsPrec1_closure:
         const Data.Monoid.$w$cshowsPrec1_info;
         const 0;
 },
 f_s6I2m_entry() //  [R1]
         { info_tbl: [(c6IWA,
                       label: f_s6I2m_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IWA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IWB; else goto c6IWC;
       c6IWB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IWC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = Data.Monoid.$fShowFirst1_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.$fShowMaybe_$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2p_entry() //  [R1]
         { info_tbl: [(c6IWX,
                       label: sat_s6I2p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IWX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IWY; else goto c6IWZ;
       c6IWY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IWZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Monoid.$fReadFirst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2q_entry() //  [R1]
         { info_tbl: [(c6IX0,
                       label: sat_s6I2q_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IX0: // global
           _s6I2q::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IX1; else goto c6IX2;
       c6IX2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IX4; else goto c6IX3;
       c6IX4: // global
           HpAlloc = 24;
           goto c6IX1;
       c6IX1: // global
           R1 = _s6I2q::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IX3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I2q::P64;
           _s6I2m::P64 = P64[_s6I2q::P64 + 16];
           _s6I2o::P64 = P64[_s6I2q::P64 + 24];
           I64[Hp - 16] = sat_s6I2p_info;
           P64[Hp] = _s6I2o::P64;
           R2 = Hp - 16;
           R1 = _s6I2m::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2r_entry() //  [R1]
         { info_tbl: [(c6IX5,
                       label: sat_s6I2r_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IX5: // global
           _s6I2r::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IX6; else goto c6IX7;
       c6IX7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6IX9; else goto c6IX8;
       c6IX9: // global
           HpAlloc = 32;
           goto c6IX6;
       c6IX6: // global
           R1 = _s6I2r::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IX8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I2r::P64;
           _s6I2m::P64 = P64[_s6I2r::P64 + 16];
           _s6I2o::P64 = P64[_s6I2r::P64 + 24];
           I64[Hp - 24] = sat_s6I2q_info;
           P64[Hp - 8] = _s6I2m::P64;
           P64[Hp] = _s6I2o::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2s_entry() //  [R1, R2]
         { info_tbl: [(c6IXa,
                       label: sat_s6I2s_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IXa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6IXe; else goto c6IXd;
       c6IXe: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IXd: // global
           _s6I2m::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6I2r_info;
           P64[Hp - 8] = _s6I2m::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I2v_entry() //  [R1]
         { info_tbl: [(c6IXC,
                       label: sat_s6I2v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IXC: // global
           _s6I2v::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IXD; else goto c6IXE;
       c6IXE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IXG; else goto c6IXF;
       c6IXG: // global
           HpAlloc = 24;
           goto c6IXD;
       c6IXD: // global
           R1 = _s6I2v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IXF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I2v::P64;
           _s6I2t::P64 = P64[_s6I2v::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6I2t::P64;
           R3 = Hp - 14;
           R2 = Data.Monoid.$fReadFirst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2w_entry() //  [R1]
         { info_tbl: [(c6IXH,
                       label: sat_s6I2w_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IXH: // global
           _s6I2w::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IXI; else goto c6IXJ;
       c6IXJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6IXL; else goto c6IXK;
       c6IXL: // global
           HpAlloc = 24;
           goto c6IXI;
       c6IXI: // global
           R1 = _s6I2w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IXK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I2w::P64;
           _s6I2m::P64 = P64[_s6I2w::P64 + 16];
           _s6I2t::P64 = P64[_s6I2w::P64 + 24];
           I64[Hp - 16] = sat_s6I2v_info;
           P64[Hp] = _s6I2t::P64;
           R2 = Hp - 16;
           R1 = _s6I2m::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2x_entry() //  [R1]
         { info_tbl: [(c6IXM,
                       label: sat_s6I2x_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IXM: // global
           _s6I2x::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IXN; else goto c6IXO;
       c6IXO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6IXQ; else goto c6IXP;
       c6IXQ: // global
           HpAlloc = 32;
           goto c6IXN;
       c6IXN: // global
           R1 = _s6I2x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IXP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I2x::P64;
           _s6I2m::P64 = P64[_s6I2x::P64 + 16];
           _s6I2t::P64 = P64[_s6I2x::P64 + 24];
           I64[Hp - 24] = sat_s6I2w_info;
           P64[Hp - 8] = _s6I2m::P64;
           P64[Hp] = _s6I2t::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2y_entry() //  [R1]
         { info_tbl: [(c6IXR,
                       label: sat_s6I2y_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IXR: // global
           _s6I2y::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6IXS; else goto c6IXT;
       c6IXT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6IXV; else goto c6IXU;
       c6IXV: // global
           HpAlloc = 32;
           goto c6IXS;
       c6IXS: // global
           R1 = _s6I2y::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IXU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I2y::P64;
           _s6I2m::P64 = P64[_s6I2y::P64 + 16];
           _s6I2t::P64 = P64[_s6I2y::P64 + 24];
           I64[Hp - 24] = sat_s6I2x_info;
           P64[Hp - 8] = _s6I2m::P64;
           P64[Hp] = _s6I2t::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2z_entry() //  [R1, R2]
         { info_tbl: [(c6IXX,
                       label: sat_s6I2z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IXX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6IY1; else goto c6IY0;
       c6IY1: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6IY0: // global
           _s6I2m::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6I2y_info;
           P64[Hp - 32] = _s6I2m::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$w$cshowsPrec1_entry() //  [R2, R3, R4]
         { info_tbl: [(c6IY5,
                       label: Data.Monoid.$w$cshowsPrec1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IY5: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6IY9; else goto c6IY8;
       c6IY9: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$w$cshowsPrec1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6IY8: // global
           I64[Hp - 40] = f_s6I2m_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6IWw::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6IY3; else goto c6IY4;
       c6IY3: // global
           I64[Hp - 8] = sat_s6I2s_info;
           P64[Hp] = _c6IWw::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6IY4: // global
           I64[Hp - 8] = sat_s6I2z_info;
           P64[Hp] = _c6IWw::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.22988696 UTC

[section ""data" . Data.Monoid.$fShowLast_$cshowsPrec_closure" {
     Data.Monoid.$fShowLast_$cshowsPrec_closure:
         const Data.Monoid.$fShowLast_$cshowsPrec_info;
         const 0;
 },
 Data.Monoid.$fShowLast_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c6IZ1,
                       label: Data.Monoid.$fShowLast_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IZ1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6IZ2; else goto c6IZ3;
       c6IZ2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowLast_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6IZ3: // global
           I64[Sp - 24] = block_c6IYY_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6IZ7; else goto c6IYZ;
       u6IZ7: // global
           call _c6IYY(R1) args: 0, res: 0, upd: 0;
       c6IYZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6IYY() //  [R1]
         { info_tbl: [(c6IYY,
                       label: block_c6IYY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IYY: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Monoid.$w$cshowsPrec1_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.235825592 UTC

[section ""data" . Data.Monoid.$fReadFirst3_closure" {
     Data.Monoid.$fReadFirst3_closure:
         const Data.Monoid.$fReadFirst3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadFirst3_entry() //  [R1]
         { info_tbl: [(c6IZn,
                       label: Data.Monoid.$fReadFirst3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IZn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IZo; else goto c6IZp;
       c6IZo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IZp: // global
           (_c6IZk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6IZk::I64 == 0) goto c6IZm; else goto c6IZl;
       c6IZm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6IZl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6IZk::I64;
           R2 = Data.Monoid.$fReadFirst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.240178455 UTC

[section ""data" . Data.Monoid.$fShowFirst4_closure" {
     Data.Monoid.$fShowFirst4_closure:
         const Data.Monoid.$fShowFirst4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fShowFirst4_entry() //  [R1]
         { info_tbl: [(c6IZD,
                       label: Data.Monoid.$fShowFirst4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IZD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6IZE; else goto c6IZF;
       c6IZE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6IZF: // global
           (_c6IZA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6IZA::I64 == 0) goto c6IZC; else goto c6IZB;
       c6IZC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6IZB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6IZA::I64;
           R3 = Data.Monoid.$fReadFirst3_closure;
           R2 = GHC.Show.$fShowMaybe4_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.245572263 UTC

[section ""data" . Data.Monoid.$fShowLast_$cshow_closure" {
     Data.Monoid.$fShowLast_$cshow_closure:
         const Data.Monoid.$fShowLast_$cshow_info;
         const 0;
 },
 sat_s6I2J_entry() //  [R1]
         { info_tbl: [(c6J09,
                       label: sat_s6I2J_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J09: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6J0a; else goto c6J0b;
       c6J0a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6J0b: // global
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Show.appPrec1_closure;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = Data.Monoid.$fReadFirst3_closure;
           Sp = Sp - 32;
           call GHC.Show.showsPrec_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_s6I2K_entry() //  [R1]
         { info_tbl: [(c6J0g,
                       label: sat_s6I2K_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J0g: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6J0h; else goto c6J0i;
       c6J0h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6J0i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6IZZ_info;
           _s6I2F::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s6I2F::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6J0o; else goto c6J00;
       u6J0o: // global
           call _c6IZZ(R1) args: 0, res: 0, upd: 0;
       c6J00: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6IZZ() //  [R1]
         { info_tbl: [(c6IZZ,
                       label: block_c6IZZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6IZZ: // global
           if (R1 & 7 == 1) goto c6J0d; else goto c6J0e;
       c6J0d: // global
           R1 = Data.Monoid.$fShowFirst4_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c6J0e: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6J0n; else goto c6J0m;
       c6J0n: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6J0m: // global
           _s6I2I::P64 = P64[R1 + 6];
           I64[Hp - 24] = sat_s6I2J_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _s6I2I::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.$fShowMaybe1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I2L_entry() //  [R1]
         { info_tbl: [(c6J0p,
                       label: sat_s6I2L_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J0p: // global
           _s6I2L::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6J0q; else goto c6J0r;
       c6J0r: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6J0t; else goto c6J0s;
       c6J0t: // global
           HpAlloc = 32;
           goto c6J0q;
       c6J0q: // global
           R1 = _s6I2L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6J0s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I2L::P64;
           _s6I2F::P64 = P64[_s6I2L::P64 + 16];
           _s6I2G::P64 = P64[_s6I2L::P64 + 24];
           I64[Hp - 24] = sat_s6I2K_info;
           P64[Hp - 8] = _s6I2F::P64;
           P64[Hp] = _s6I2G::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fShowLast_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6J0u,
                       label: Data.Monoid.$fShowLast_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J0u: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6J0y; else goto c6J0x;
       c6J0y: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowLast_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6J0x: // global
           I64[Hp - 24] = sat_s6I2L_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.257927934 UTC

[section ""data" . Data.Monoid.$fShowLast_$cshowList_closure" {
     Data.Monoid.$fShowLast_$cshowList_closure:
         const Data.Monoid.$fShowLast_$cshowList_info;
         const 0;
 },
 sat_s6I2Q_entry() //  [R1, R2]
         { info_tbl: [(c6J17,
                       label: sat_s6I2Q_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J17: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Monoid.$w$cshowsPrec1_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fShowLast_$cshowList_entry() //  [R2, R3, R4]
         { info_tbl: [(c6J1a,
                       label: Data.Monoid.$fShowLast_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J1a: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6J1e; else goto c6J1d;
       c6J1e: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowLast_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6J1d: // global
           I64[Hp - 8] = sat_s6I2Q_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.263721696 UTC

[section ""data" . Data.Monoid.$fShowLast_closure" {
     Data.Monoid.$fShowLast_closure:
         const Data.Monoid.$fShowLast_info;
         const 0;
 },
 sat_s6I2U_entry() //  [R1, R2, R3]
         { info_tbl: [(c6J1v,
                       label: sat_s6I2U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J1v: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fShowLast_$cshowList_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I2T_entry() //  [R1, R2]
         { info_tbl: [(c6J1D,
                       label: sat_s6I2T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J1D: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Monoid.$fShowLast_$cshow_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I2S_entry() //  [R1, R2, R3]
         { info_tbl: [(c6J1L,
                       label: sat_s6I2S_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J1L: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fShowLast_$cshowsPrec_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fShowLast_entry() //  [R2]
         { info_tbl: [(c6J1P,
                       label: Data.Monoid.$fShowLast_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J1P: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6J1T; else goto c6J1S;
       c6J1T: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Monoid.$fShowLast_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6J1S: // global
           I64[Hp - 72] = sat_s6I2U_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6I2T_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6I2S_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.273443634 UTC

[section ""cstring" . Data.Monoid.$fReadLast5_bytes" {
     Data.Monoid.$fReadLast5_bytes:
         I8[] [76,97,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.275524805 UTC

[section ""data" . Data.Monoid.$fReadLast4_closure" {
     Data.Monoid.$fReadLast4_closure:
         const Data.Monoid.$fReadLast4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadLast4_entry() //  [R1]
         { info_tbl: [(c6J2i,
                       label: Data.Monoid.$fReadLast4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J2i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6J2j; else goto c6J2k;
       c6J2j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6J2k: // global
           (_c6J2f::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6J2f::I64 == 0) goto c6J2h; else goto c6J2g;
       c6J2h: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6J2g: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6J2f::I64;
           R2 = Data.Monoid.$fReadLast5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.279778798 UTC

[section ""data" . Data.Monoid.$fReadLast_lexeme_closure" {
     Data.Monoid.$fReadLast_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Monoid.$fReadLast4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.281638691 UTC

[section ""cstring" . Data.Monoid.$fReadFirst9_bytes" {
     Data.Monoid.$fReadFirst9_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.283622396 UTC

[section ""data" . Data.Monoid.$fReadFirst8_closure" {
     Data.Monoid.$fReadFirst8_closure:
         const Data.Monoid.$fReadFirst8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadFirst8_entry() //  [R1]
         { info_tbl: [(c6J2A,
                       label: Data.Monoid.$fReadFirst8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J2A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6J2B; else goto c6J2C;
       c6J2B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6J2C: // global
           (_c6J2x::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6J2x::I64 == 0) goto c6J2z; else goto c6J2y;
       c6J2z: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6J2y: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6J2x::I64;
           R2 = Data.Monoid.$fReadFirst9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.287812137 UTC

[section ""data" . Data.Monoid.$fReadFirst_lexeme_closure" {
     Data.Monoid.$fReadFirst_lexeme_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Monoid.$fReadFirst8_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.28963865 UTC

[section ""cstring" . Data.Monoid.$fReadLast3_bytes" {
     Data.Monoid.$fReadLast3_bytes:
         I8[] [103,101,116,76,97,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.291681584 UTC

[section ""data" . Data.Monoid.$fReadLast2_closure" {
     Data.Monoid.$fReadLast2_closure:
         const Data.Monoid.$fReadLast2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadLast2_entry() //  [R1]
         { info_tbl: [(c6J2S,
                       label: Data.Monoid.$fReadLast2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J2S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6J2T; else goto c6J2U;
       c6J2T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6J2U: // global
           (_c6J2P::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6J2P::I64 == 0) goto c6J2R; else goto c6J2Q;
       c6J2R: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6J2Q: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6J2P::I64;
           R2 = Data.Monoid.$fReadLast3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.295730952 UTC

[section ""data" . Data.Monoid.$fReadFirst5_closure" {
     Data.Monoid.$fReadFirst5_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.297521931 UTC

[section ""data" . Data.Monoid.$fReadFirst2_closure" {
     Data.Monoid.$fReadFirst2_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Monoid.$fReadFirst3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.30228366 UTC

[section ""data" . Data.Monoid.$fReadLast1_closure" {
     Data.Monoid.$fReadLast1_closure:
         const Data.Monoid.$fReadLast1_info;
         const 0;
 },
 ds_s6I2Y_entry() //  [R1, R3]
         { info_tbl: [(c6J3d,
                       label: ds_s6I2Y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J3d: // global
           R4 = R3;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = P64[R1 + 6];
           call GHC.Read.$fReadMaybe1_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3a_entry() //  [R1]
         { info_tbl: [(c6J3O,
                       label: sat_s6I3a_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J3O: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3d_entry() //  [R1, R2]
         { info_tbl: [(c6J3U,
                       label: sat_s6I3d_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J3U: // global
           _s6I38::P64 = R2;
           _s6I3d::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6J3V; else goto c6J3W;
       c6J3W: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6J3Y; else goto c6J3X;
       c6J3Y: // global
           HpAlloc = 24;
           goto c6J3V;
       c6J3V: // global
           R2 = _s6I38::P64;
           R1 = _s6I3d::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6J3X: // global
           _s6I32::P64 = P64[_s6I3d::P64 + 7];
           I64[Hp - 16] = sat_s6I3a_info;
           P64[Hp - 8] = _s6I32::P64;
           P64[Hp] = _s6I38::P64;
           I64[Sp - 8] = block_c6J3R_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadFirst2_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6J3R() //  [R1]
         { info_tbl: [(c6J3R,
                       label: block_c6J3R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J3R: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6J41; else goto c6J40;
       c6J41: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6J40: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3e_entry() //  [R1, R2]
         { info_tbl: [(c6J42,
                       label: sat_s6I3e_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J42: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6J46; else goto c6J45;
       c6J46: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6J45: // global
           _s6I2Y::P64 = P64[R1 + 7];
           _s6I32::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6I3d_info;
           P64[Hp] = _s6I32::P64;
           R5 = Hp - 7;
           R4 = Data.Monoid.$fReadFirst5_closure+1;
           R3 = _s6I2Y::P64;
           R2 = Data.Monoid.$fReadLast2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3h_entry() //  [R1, R2]
         { info_tbl: [(c6J4a,
                       label: sat_s6I3h_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J4a: // global
           _s6I36::P64 = R2;
           _s6I3h::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6J4b; else goto c6J4c;
       c6J4c: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6J4e; else goto c6J4d;
       c6J4e: // global
           HpAlloc = 24;
           goto c6J4b;
       c6J4b: // global
           R2 = _s6I36::P64;
           R1 = _s6I3h::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6J4d: // global
           _s6I2Y::P64 = P64[_s6I3h::P64 + 7];
           _s6I32::P64 = P64[_s6I3h::P64 + 15];
           I64[Hp - 16] = sat_s6I3e_info;
           P64[Hp - 8] = _s6I2Y::P64;
           P64[Hp] = _s6I32::P64;
           I64[Sp - 8] = block_c6J47_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadFirst_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6J47() //  [R1]
         { info_tbl: [(c6J47,
                       label: block_c6J47_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J47: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6J4h; else goto c6J4g;
       c6J4h: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6J4g: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3k_entry() //  [R1, R2, R3]
         { info_tbl: [(c6J4i,
                       label: sat_s6I3k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J4i: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6J4j; else goto c6J4k;
       c6J4j: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6J4k: // global
           I64[Sp - 24] = block_c6J3l_info;
           _s6I2Y::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6I2Y::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6J4x; else goto c6J3m;
       u6J4x: // global
           call _c6J3l(R1) args: 0, res: 0, upd: 0;
       c6J3m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6J3l() //  [R1]
         { info_tbl: [(c6J3l,
                       label: block_c6J3l_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J3l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6J4n; else goto c6J4m;
       c6J4n: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6J4m: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6J4p; else goto c6J4t;
       c6J4p: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6J4t: // global
           I64[Hp - 16] = sat_s6I3h_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6J4q_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadLast_lexeme_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6J4q() //  [R1]
         { info_tbl: [(c6J4q,
                       label: block_c6J4q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J4q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6J4w; else goto c6J4v;
       c6J4w: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6J4v: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadLast1_entry() //  [R2, R3, R4]
         { info_tbl: [(c6J4y,
                       label: Data.Monoid.$fReadLast1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J4y: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6J4C; else goto c6J4B;
       c6J4C: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fReadLast1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6J4B: // global
           I64[Hp - 24] = ds_s6I2Y_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6I3k_info;
           P64[Hp] = Hp - 22;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.327348596 UTC

[section ""data" . Data.Monoid.$fReadLast_$creadsPrec_closure" {
     Data.Monoid.$fReadLast_$creadsPrec_closure:
         const Data.Monoid.$fReadLast_$creadsPrec_info;
         const 0;
 },
 sat_s6I3n_entry() //  [R1]
         { info_tbl: [(c6J5u,
                       label: sat_s6I3n_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J5u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6J5v; else goto c6J5w;
       c6J5v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6J5w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadLast1_entry(R4,
                                              R3,
                                              R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fReadLast_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c6J5x,
                       label: Data.Monoid.$fReadLast_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J5x: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6J5B; else goto c6J5A;
       c6J5B: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fReadLast_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6J5A: // global
           I64[Hp - 24] = sat_s6I3n_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.333791579 UTC

[section ""data" . Data.Monoid.$fReadLast_$creadListPrec_closure" {
     Data.Monoid.$fReadLast_$creadListPrec_closure:
         const Data.Monoid.$fReadLast_$creadListPrec_info;
         const 0;
 },
 sat_s6I3p_entry() //  [R1, R2, R3]
         { info_tbl: [(c6J5T,
                       label: sat_s6I3p_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J5T: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadLast1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadLast_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6J5W,
                       label: Data.Monoid.$fReadLast_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J5W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6J60; else goto c6J5Z;
       c6J60: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Monoid.$fReadLast_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6J5Z: // global
           I64[Hp - 8] = sat_s6I3p_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.339725253 UTC

[section ""data" . Data.Monoid.$fReadLast_$creadList_closure" {
     Data.Monoid.$fReadLast_$creadList_closure:
         const Data.Monoid.$fReadLast_$creadList_info;
         const 0;
 },
 sat_s6I3r_entry() //  [R1, R2, R3]
         { info_tbl: [(c6J6l,
                       label: sat_s6I3r_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J6l: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadLast1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3s_entry() //  [R1]
         { info_tbl: [(c6J6o,
                       label: sat_s6I3s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J6o: // global
           _s6I3s::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6J6p; else goto c6J6q;
       c6J6q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6J6s; else goto c6J6r;
       c6J6s: // global
           HpAlloc = 16;
           goto c6J6p;
       c6J6p: // global
           R1 = _s6I3s::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6J6r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I3s::P64;
           _s6I3q::P64 = P64[_s6I3s::P64 + 16];
           I64[Hp - 8] = sat_s6I3r_info;
           P64[Hp] = _s6I3q::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fReadLast_$creadList_entry() //  [R2]
         { info_tbl: [(c6J6t,
                       label: Data.Monoid.$fReadLast_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J6t: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6J6x; else goto c6J6w;
       c6J6x: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Monoid.$fReadLast_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6J6w: // global
           I64[Hp - 16] = sat_s6I3s_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.349436707 UTC

[section ""data" . Data.Monoid.$fReadLast_closure" {
     Data.Monoid.$fReadLast_closure:
         const Data.Monoid.$fReadLast_info;
         const 0;
 },
 sat_s6I3x_entry() //  [R1]
         { info_tbl: [(c6J6R,
                       label: sat_s6I3x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J6R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6J6S; else goto c6J6T;
       c6J6S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6J6T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadLast_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I3w_entry() //  [R1, R2, R3]
         { info_tbl: [(c6J6Z,
                       label: sat_s6I3w_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J6Z: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadLast1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3v_entry() //  [R1]
         { info_tbl: [(c6J76,
                       label: sat_s6I3v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J76: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6J77; else goto c6J78;
       c6J77: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6J78: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadLast_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I3u_entry() //  [R1, R2]
         { info_tbl: [(c6J7e,
                       label: sat_s6I3u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J7e: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Monoid.$fReadLast_$creadsPrec_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadLast_entry() //  [R2]
         { info_tbl: [(c6J7i,
                       label: Data.Monoid.$fReadLast_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J7i: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c6J7m; else goto c6J7l;
       c6J7m: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Monoid.$fReadLast_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6J7l: // global
           I64[Hp - 112] = sat_s6I3x_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6I3w_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s6I3v_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s6I3u_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 112;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.361556812 UTC

[section ""data" . Data.Monoid.$fEqLast_closure" {
     Data.Monoid.$fEqLast_closure:
         const Data.Monoid.$fEqLast_info;
 },
 sat_s6I3A_entry() //  [R1, R2, R3]
         { info_tbl: [(c6J7T,
                       label: sat_s6I3A_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J7T: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c/=_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3z_entry() //  [R1, R2, R3]
         { info_tbl: [(c6J81,
                       label: sat_s6I3z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J81: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fEqLast_entry() //  [R2]
         { info_tbl: [(c6J85,
                       label: Data.Monoid.$fEqLast_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J85: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6J89; else goto c6J88;
       c6J89: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Monoid.$fEqLast_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6J88: // global
           I64[Hp - 48] = sat_s6I3A_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s6I3z_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.369143221 UTC

[section ""data" . Data.Monoid.$fOrdLast_$cp1Ord_closure" {
     Data.Monoid.$fOrdLast_$cp1Ord_closure:
         const Data.Monoid.$fOrdLast_$cp1Ord_info;
 },
 sat_s6I3C_entry() //  [R1]
         { info_tbl: [(c6J8v,
                       label: sat_s6I3C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J8v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6J8w; else goto c6J8x;
       c6J8w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6J8x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fOrdLast_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6J8y,
                       label: Data.Monoid.$fOrdLast_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J8y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6J8C; else goto c6J8B;
       c6J8C: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Monoid.$fOrdLast_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6J8B: // global
           I64[Hp - 16] = sat_s6I3C_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Monoid.$fEqLast_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.376362756 UTC

[section ""data" . Data.Monoid.$fOrdLast_closure" {
     Data.Monoid.$fOrdLast_closure:
         const Data.Monoid.$fOrdLast_info;
 },
 sat_s6I3N_entry() //  [R1, R2, R3]
         { info_tbl: [(c6J8U,
                       label: sat_s6I3N_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J8U: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmin_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3M_entry() //  [R1, R2, R3]
         { info_tbl: [(c6J92,
                       label: sat_s6I3M_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J92: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmax_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3L_entry() //  [R1, R2, R3]
         { info_tbl: [(c6J9a,
                       label: sat_s6I3L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J9a: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c>=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3K_entry() //  [R1, R2, R3]
         { info_tbl: [(c6J9i,
                       label: sat_s6I3K_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J9i: // global
           R4 = R2;
           R3 = R3;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3H_entry() //  [R1, R2, R3]
         { info_tbl: [(c6J9q,
                       label: sat_s6I3H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J9q: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3G_entry() //  [R1, R2, R3]
         { info_tbl: [(c6J9y,
                       label: sat_s6I3G_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J9y: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3F_entry() //  [R1, R2, R3]
         { info_tbl: [(c6J9G,
                       label: sat_s6I3F_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J9G: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I3E_entry() //  [R1]
         { info_tbl: [(c6J9N,
                       label: sat_s6I3E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J9N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6J9O; else goto c6J9P;
       c6J9O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6J9P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fOrdLast_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fOrdLast_entry() //  [R2]
         { info_tbl: [(c6J9R,
                       label: Data.Monoid.$fOrdLast_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6J9R: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto c6J9V; else goto c6J9U;
       c6J9V: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = Data.Monoid.$fOrdLast_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6J9U: // global
           I64[Hp - 200] = sat_s6I3N_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6I3M_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s6I3L_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s6I3K_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6I3H_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s6I3G_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6I3F_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6I3E_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.395636311 UTC

[section ""data" . Data.Monoid.$fFunctorFirst_closure" {
     Data.Monoid.$fFunctorFirst_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fApplicativeMaybe_$cfmap_closure+2;
         const GHC.Base.$fFunctorMaybe_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.397516599 UTC

[section ""data" . Data.Monoid.$fApplicativeFirst_closure" {
     Data.Monoid.$fApplicativeFirst_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Monoid.$fFunctorFirst_closure+1;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fApplicativeMaybe_$c<*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$cliftA2_closure+3;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c<*_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.399404699 UTC

[section ""data" . Data.Monoid.$fMonadFirst_closure" {
     Data.Monoid.$fMonadFirst_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Monoid.$fApplicativeFirst_closure+1;
         const GHC.Base.$fMonadMaybe_$c>>=_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fMonadMaybe_$cfail_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.401552422 UTC

[section ""data" . Data.Monoid.$fGeneric1First1_closure" {
     Data.Monoid.$fGeneric1First1_closure:
         const Data.Monoid.$fGeneric1First1_info;
 },
 Data.Monoid.$fGeneric1First1_entry() //  [R2]
         { info_tbl: [(c6JaF,
                       label: Data.Monoid.$fGeneric1First1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JaF: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.405101419 UTC

[section ""data" . Data.Monoid.$fGeneric1First2_closure" {
     Data.Monoid.$fGeneric1First2_closure:
         const Data.Monoid.$fGeneric1First2_info;
 },
 Data.Monoid.$fGeneric1First2_entry() //  [R2]
         { info_tbl: [(c6JaQ,
                       label: Data.Monoid.$fGeneric1First2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JaQ: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.40887221 UTC

[section ""data" . Data.Monoid.$fGeneric1First_closure" {
     Data.Monoid.$fGeneric1First_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Monoid.$fGeneric1First2_closure+1;
         const Data.Monoid.$fGeneric1First1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.410889174 UTC

[section ""data" . Data.Monoid.$fGenericFirst1_closure" {
     Data.Monoid.$fGenericFirst1_closure:
         const Data.Monoid.$fGenericFirst1_info;
 },
 Data.Monoid.$fGenericFirst1_entry() //  [R2]
         { info_tbl: [(c6Jb4,
                       label: Data.Monoid.$fGenericFirst1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jb4: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.414372676 UTC

[section ""data" . Data.Monoid.$fGenericFirst2_closure" {
     Data.Monoid.$fGenericFirst2_closure:
         const Data.Monoid.$fGenericFirst2_info;
 },
 Data.Monoid.$fGenericFirst2_entry() //  [R2]
         { info_tbl: [(c6Jbf,
                       label: Data.Monoid.$fGenericFirst2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jbf: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.418566922 UTC

[section ""data" . Data.Monoid.$fGenericFirst_closure" {
     Data.Monoid.$fGenericFirst_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Monoid.$fGenericFirst2_closure+1;
         const Data.Monoid.$fGenericFirst1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.420410114 UTC

[section ""cstring" . Data.Monoid.$fShowFirst3_bytes" {
     Data.Monoid.$fShowFirst3_bytes:
         I8[] [70,105,114,115,116,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.422374488 UTC

[section ""cstring" . Data.Monoid.$fShowFirst2_bytes" {
     Data.Monoid.$fShowFirst2_bytes:
         I8[] [103,101,116,70,105,114,115,116,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.426265309 UTC

[section ""data" . Data.Monoid.$w$cshowsPrec_closure" {
     Data.Monoid.$w$cshowsPrec_closure:
         const Data.Monoid.$w$cshowsPrec_info;
         const 0;
 },
 f_s6I3V_entry() //  [R1]
         { info_tbl: [(c6Jbz,
                       label: f_s6I3V_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jbz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JbA; else goto c6JbB;
       c6JbA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JbB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = Data.Monoid.$fShowFirst1_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.$fShowMaybe_$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I3Y_entry() //  [R1]
         { info_tbl: [(c6JbW,
                       label: sat_s6I3Y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JbW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JbX; else goto c6JbY;
       c6JbX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JbY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Monoid.$fReadFirst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I3Z_entry() //  [R1]
         { info_tbl: [(c6JbZ,
                       label: sat_s6I3Z_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JbZ: // global
           _s6I3Z::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6Jc0; else goto c6Jc1;
       c6Jc1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Jc3; else goto c6Jc2;
       c6Jc3: // global
           HpAlloc = 24;
           goto c6Jc0;
       c6Jc0: // global
           R1 = _s6I3Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Jc2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I3Z::P64;
           _s6I3V::P64 = P64[_s6I3Z::P64 + 16];
           _s6I3X::P64 = P64[_s6I3Z::P64 + 24];
           I64[Hp - 16] = sat_s6I3Y_info;
           P64[Hp] = _s6I3X::P64;
           R2 = Hp - 16;
           R1 = _s6I3V::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I40_entry() //  [R1]
         { info_tbl: [(c6Jc4,
                       label: sat_s6I40_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jc4: // global
           _s6I40::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6Jc5; else goto c6Jc6;
       c6Jc6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Jc8; else goto c6Jc7;
       c6Jc8: // global
           HpAlloc = 32;
           goto c6Jc5;
       c6Jc5: // global
           R1 = _s6I40::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Jc7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I40::P64;
           _s6I3V::P64 = P64[_s6I40::P64 + 16];
           _s6I3X::P64 = P64[_s6I40::P64 + 24];
           I64[Hp - 24] = sat_s6I3Z_info;
           P64[Hp - 8] = _s6I3V::P64;
           P64[Hp] = _s6I3X::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I41_entry() //  [R1, R2]
         { info_tbl: [(c6Jc9,
                       label: sat_s6I41_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jc9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Jcd; else goto c6Jcc;
       c6Jcd: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Jcc: // global
           _s6I3V::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6I40_info;
           P64[Hp - 8] = _s6I3V::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I44_entry() //  [R1]
         { info_tbl: [(c6JcB,
                       label: sat_s6I44_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JcB: // global
           _s6I44::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6JcC; else goto c6JcD;
       c6JcD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6JcF; else goto c6JcE;
       c6JcF: // global
           HpAlloc = 24;
           goto c6JcC;
       c6JcC: // global
           R1 = _s6I44::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JcE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I44::P64;
           _s6I42::P64 = P64[_s6I44::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6I42::P64;
           R3 = Hp - 14;
           R2 = Data.Monoid.$fReadFirst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I45_entry() //  [R1]
         { info_tbl: [(c6JcG,
                       label: sat_s6I45_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JcG: // global
           _s6I45::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6JcH; else goto c6JcI;
       c6JcI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6JcK; else goto c6JcJ;
       c6JcK: // global
           HpAlloc = 24;
           goto c6JcH;
       c6JcH: // global
           R1 = _s6I45::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JcJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I45::P64;
           _s6I3V::P64 = P64[_s6I45::P64 + 16];
           _s6I42::P64 = P64[_s6I45::P64 + 24];
           I64[Hp - 16] = sat_s6I44_info;
           P64[Hp] = _s6I42::P64;
           R2 = Hp - 16;
           R1 = _s6I3V::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I46_entry() //  [R1]
         { info_tbl: [(c6JcL,
                       label: sat_s6I46_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JcL: // global
           _s6I46::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6JcM; else goto c6JcN;
       c6JcN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JcP; else goto c6JcO;
       c6JcP: // global
           HpAlloc = 32;
           goto c6JcM;
       c6JcM: // global
           R1 = _s6I46::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JcO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I46::P64;
           _s6I3V::P64 = P64[_s6I46::P64 + 16];
           _s6I42::P64 = P64[_s6I46::P64 + 24];
           I64[Hp - 24] = sat_s6I45_info;
           P64[Hp - 8] = _s6I3V::P64;
           P64[Hp] = _s6I42::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I47_entry() //  [R1]
         { info_tbl: [(c6JcQ,
                       label: sat_s6I47_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JcQ: // global
           _s6I47::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6JcR; else goto c6JcS;
       c6JcS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JcU; else goto c6JcT;
       c6JcU: // global
           HpAlloc = 32;
           goto c6JcR;
       c6JcR: // global
           R1 = _s6I47::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JcT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I47::P64;
           _s6I3V::P64 = P64[_s6I47::P64 + 16];
           _s6I42::P64 = P64[_s6I47::P64 + 24];
           I64[Hp - 24] = sat_s6I46_info;
           P64[Hp - 8] = _s6I3V::P64;
           P64[Hp] = _s6I42::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I48_entry() //  [R1, R2]
         { info_tbl: [(c6JcW,
                       label: sat_s6I48_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JcW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6Jd0; else goto c6JcZ;
       c6Jd0: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6JcZ: // global
           _s6I3V::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6I47_info;
           P64[Hp - 32] = _s6I3V::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c6Jd4,
                       label: Data.Monoid.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jd4: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6Jd8; else goto c6Jd7;
       c6Jd8: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Jd7: // global
           I64[Hp - 40] = f_s6I3V_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6Jbv::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6Jd2; else goto c6Jd3;
       c6Jd2: // global
           I64[Hp - 8] = sat_s6I41_info;
           P64[Hp] = _c6Jbv::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6Jd3: // global
           I64[Hp - 8] = sat_s6I48_info;
           P64[Hp] = _c6Jbv::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.453001559 UTC

[section ""data" . Data.Monoid.$fShowFirst_$cshowsPrec_closure" {
     Data.Monoid.$fShowFirst_$cshowsPrec_closure:
         const Data.Monoid.$fShowFirst_$cshowsPrec_info;
         const 0;
 },
 Data.Monoid.$fShowFirst_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c6Je0,
                       label: Data.Monoid.$fShowFirst_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Je0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6Je1; else goto c6Je2;
       c6Je1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowFirst_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Je2: // global
           I64[Sp - 24] = block_c6JdX_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6Je6; else goto c6JdY;
       u6Je6: // global
           call _c6JdX(R1) args: 0, res: 0, upd: 0;
       c6JdY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6JdX() //  [R1]
         { info_tbl: [(c6JdX,
                       label: block_c6JdX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JdX: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Monoid.$w$cshowsPrec_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.460865336 UTC

[section ""data" . Data.Monoid.$fShowFirst_$cshow_closure" {
     Data.Monoid.$fShowFirst_$cshow_closure:
         const Data.Monoid.$fShowFirst_$cshow_info;
         const 0;
 },
 sat_s6I4i_entry() //  [R1]
         { info_tbl: [(c6JeC,
                       label: sat_s6I4i_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JeC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6JeD; else goto c6JeE;
       c6JeD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JeE: // global
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Show.appPrec1_closure;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = Data.Monoid.$fReadFirst3_closure;
           Sp = Sp - 32;
           call GHC.Show.showsPrec_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_s6I4j_entry() //  [R1]
         { info_tbl: [(c6JeJ,
                       label: sat_s6I4j_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JeJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6JeK; else goto c6JeL;
       c6JeK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JeL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6Jes_info;
           _s6I4e::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s6I4e::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6JeR; else goto c6Jet;
       u6JeR: // global
           call _c6Jes(R1) args: 0, res: 0, upd: 0;
       c6Jet: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6Jes() //  [R1]
         { info_tbl: [(c6Jes,
                       label: block_c6Jes_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jes: // global
           if (R1 & 7 == 1) goto c6JeG; else goto c6JeH;
       c6JeG: // global
           R1 = Data.Monoid.$fShowFirst4_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c6JeH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JeQ; else goto c6JeP;
       c6JeQ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6JeP: // global
           _s6I4h::P64 = P64[R1 + 6];
           I64[Hp - 24] = sat_s6I4i_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _s6I4h::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.$fShowMaybe1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I4k_entry() //  [R1]
         { info_tbl: [(c6JeS,
                       label: sat_s6I4k_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JeS: // global
           _s6I4k::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6JeT; else goto c6JeU;
       c6JeU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JeW; else goto c6JeV;
       c6JeW: // global
           HpAlloc = 32;
           goto c6JeT;
       c6JeT: // global
           R1 = _s6I4k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JeV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I4k::P64;
           _s6I4e::P64 = P64[_s6I4k::P64 + 16];
           _s6I4f::P64 = P64[_s6I4k::P64 + 24];
           I64[Hp - 24] = sat_s6I4j_info;
           P64[Hp - 8] = _s6I4e::P64;
           P64[Hp] = _s6I4f::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fShowFirst_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6JeX,
                       label: Data.Monoid.$fShowFirst_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JeX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Jf1; else goto c6Jf0;
       c6Jf1: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowFirst_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Jf0: // global
           I64[Hp - 24] = sat_s6I4k_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.474823875 UTC

[section ""data" . Data.Monoid.$fShowFirst_$cshowList_closure" {
     Data.Monoid.$fShowFirst_$cshowList_closure:
         const Data.Monoid.$fShowFirst_$cshowList_info;
         const 0;
 },
 sat_s6I4p_entry() //  [R1, R2]
         { info_tbl: [(c6JfA,
                       label: sat_s6I4p_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JfA: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Monoid.$w$cshowsPrec_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fShowFirst_$cshowList_entry() //  [R2, R3, R4]
         { info_tbl: [(c6JfD,
                       label: Data.Monoid.$fShowFirst_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JfD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6JfH; else goto c6JfG;
       c6JfH: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowFirst_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6JfG: // global
           I64[Hp - 8] = sat_s6I4p_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.481105963 UTC

[section ""data" . Data.Monoid.$fShowFirst_closure" {
     Data.Monoid.$fShowFirst_closure:
         const Data.Monoid.$fShowFirst_info;
         const 0;
 },
 sat_s6I4t_entry() //  [R1, R2, R3]
         { info_tbl: [(c6JfY,
                       label: sat_s6I4t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JfY: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fShowFirst_$cshowList_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I4s_entry() //  [R1, R2]
         { info_tbl: [(c6Jg6,
                       label: sat_s6I4s_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jg6: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Monoid.$fShowFirst_$cshow_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I4r_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Jge,
                       label: sat_s6I4r_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jge: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fShowFirst_$cshowsPrec_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fShowFirst_entry() //  [R2]
         { info_tbl: [(c6Jgi,
                       label: Data.Monoid.$fShowFirst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jgi: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6Jgm; else goto c6Jgl;
       c6Jgm: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Monoid.$fShowFirst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Jgl: // global
           I64[Hp - 72] = sat_s6I4t_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6I4s_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6I4r_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.490550308 UTC

[section ""cstring" . Data.Monoid.$fReadFirst11_bytes" {
     Data.Monoid.$fReadFirst11_bytes:
         I8[] [70,105,114,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.492878313 UTC

[section ""data" . Data.Monoid.$fReadFirst10_closure" {
     Data.Monoid.$fReadFirst10_closure:
         const Data.Monoid.$fReadFirst10_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadFirst10_entry() //  [R1]
         { info_tbl: [(c6JgL,
                       label: Data.Monoid.$fReadFirst10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JgL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JgM; else goto c6JgN;
       c6JgM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JgN: // global
           (_c6JgI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6JgI::I64 == 0) goto c6JgK; else goto c6JgJ;
       c6JgK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6JgJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6JgI::I64;
           R2 = Data.Monoid.$fReadFirst11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.497772625 UTC

[section ""data" . Data.Monoid.$fReadFirst_lexeme1_closure" {
     Data.Monoid.$fReadFirst_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Monoid.$fReadFirst10_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.500587389 UTC

[section ""cstring" . Data.Monoid.$fReadFirst7_bytes" {
     Data.Monoid.$fReadFirst7_bytes:
         I8[] [103,101,116,70,105,114,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.502937559 UTC

[section ""data" . Data.Monoid.$fReadFirst6_closure" {
     Data.Monoid.$fReadFirst6_closure:
         const Data.Monoid.$fReadFirst6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadFirst6_entry() //  [R1]
         { info_tbl: [(c6Jh3,
                       label: Data.Monoid.$fReadFirst6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jh3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Jh4; else goto c6Jh5;
       c6Jh4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Jh5: // global
           (_c6Jh0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6Jh0::I64 == 0) goto c6Jh2; else goto c6Jh1;
       c6Jh2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6Jh1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6Jh0::I64;
           R2 = Data.Monoid.$fReadFirst7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.508937647 UTC

[section ""data" . Data.Monoid.$fReadFirst1_closure" {
     Data.Monoid.$fReadFirst1_closure:
         const Data.Monoid.$fReadFirst1_info;
         const 0;
 },
 ds_s6I4x_entry() //  [R1, R3]
         { info_tbl: [(c6Jhm,
                       label: ds_s6I4x_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jhm: // global
           R4 = R3;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = P64[R1 + 6];
           call GHC.Read.$fReadMaybe1_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I4J_entry() //  [R1]
         { info_tbl: [(c6JhX,
                       label: sat_s6I4J_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JhX: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I4M_entry() //  [R1, R2]
         { info_tbl: [(c6Ji3,
                       label: sat_s6I4M_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ji3: // global
           _s6I4H::P64 = R2;
           _s6I4M::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6Ji4; else goto c6Ji5;
       c6Ji5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Ji7; else goto c6Ji6;
       c6Ji7: // global
           HpAlloc = 24;
           goto c6Ji4;
       c6Ji4: // global
           R2 = _s6I4H::P64;
           R1 = _s6I4M::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Ji6: // global
           _s6I4B::P64 = P64[_s6I4M::P64 + 7];
           I64[Hp - 16] = sat_s6I4J_info;
           P64[Hp - 8] = _s6I4B::P64;
           P64[Hp] = _s6I4H::P64;
           I64[Sp - 8] = block_c6Ji0_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadFirst2_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Ji0() //  [R1]
         { info_tbl: [(c6Ji0,
                       label: block_c6Ji0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ji0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Jia; else goto c6Ji9;
       c6Jia: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Ji9: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I4N_entry() //  [R1, R2]
         { info_tbl: [(c6Jib,
                       label: sat_s6I4N_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jib: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Jif; else goto c6Jie;
       c6Jif: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Jie: // global
           _s6I4x::P64 = P64[R1 + 7];
           _s6I4B::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6I4M_info;
           P64[Hp] = _s6I4B::P64;
           R5 = Hp - 7;
           R4 = Data.Monoid.$fReadFirst5_closure+1;
           R3 = _s6I4x::P64;
           R2 = Data.Monoid.$fReadFirst6_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I4Q_entry() //  [R1, R2]
         { info_tbl: [(c6Jij,
                       label: sat_s6I4Q_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jij: // global
           _s6I4F::P64 = R2;
           _s6I4Q::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6Jik; else goto c6Jil;
       c6Jil: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Jin; else goto c6Jim;
       c6Jin: // global
           HpAlloc = 24;
           goto c6Jik;
       c6Jik: // global
           R2 = _s6I4F::P64;
           R1 = _s6I4Q::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Jim: // global
           _s6I4x::P64 = P64[_s6I4Q::P64 + 7];
           _s6I4B::P64 = P64[_s6I4Q::P64 + 15];
           I64[Hp - 16] = sat_s6I4N_info;
           P64[Hp - 8] = _s6I4x::P64;
           P64[Hp] = _s6I4B::P64;
           I64[Sp - 8] = block_c6Jig_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadFirst_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Jig() //  [R1]
         { info_tbl: [(c6Jig,
                       label: block_c6Jig_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jig: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Jiq; else goto c6Jip;
       c6Jiq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Jip: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I4T_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Jir,
                       label: sat_s6I4T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jir: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6Jis; else goto c6Jit;
       c6Jis: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Jit: // global
           I64[Sp - 24] = block_c6Jhu_info;
           _s6I4x::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6I4x::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6JiG; else goto c6Jhv;
       u6JiG: // global
           call _c6Jhu(R1) args: 0, res: 0, upd: 0;
       c6Jhv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Jhu() //  [R1]
         { info_tbl: [(c6Jhu,
                       label: block_c6Jhu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jhu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Jiw; else goto c6Jiv;
       c6Jiw: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Jiv: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6Jiy; else goto c6JiC;
       c6Jiy: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6JiC: // global
           I64[Hp - 16] = sat_s6I4Q_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6Jiz_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadFirst_lexeme1_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Jiz() //  [R1]
         { info_tbl: [(c6Jiz,
                       label: block_c6Jiz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jiz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6JiF; else goto c6JiE;
       c6JiF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6JiE: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadFirst1_entry() //  [R2, R3, R4]
         { info_tbl: [(c6JiH,
                       label: Data.Monoid.$fReadFirst1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JiH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JiL; else goto c6JiK;
       c6JiL: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fReadFirst1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6JiK: // global
           I64[Hp - 24] = ds_s6I4x_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6I4T_info;
           P64[Hp] = Hp - 22;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.534084843 UTC

[section ""data" . Data.Monoid.$fReadFirst_$creadsPrec_closure" {
     Data.Monoid.$fReadFirst_$creadsPrec_closure:
         const Data.Monoid.$fReadFirst_$creadsPrec_info;
         const 0;
 },
 sat_s6I4W_entry() //  [R1]
         { info_tbl: [(c6JjD,
                       label: sat_s6I4W_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JjD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JjE; else goto c6JjF;
       c6JjE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JjF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadFirst1_entry(R4,
                                               R3,
                                               R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fReadFirst_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c6JjG,
                       label: Data.Monoid.$fReadFirst_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JjG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JjK; else goto c6JjJ;
       c6JjK: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fReadFirst_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6JjJ: // global
           I64[Hp - 24] = sat_s6I4W_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.540455127 UTC

[section ""data" . Data.Monoid.$fReadFirst_$creadListPrec_closure" {
     Data.Monoid.$fReadFirst_$creadListPrec_closure:
         const Data.Monoid.$fReadFirst_$creadListPrec_info;
         const 0;
 },
 sat_s6I4Y_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Jk2,
                       label: sat_s6I4Y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jk2: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadFirst1_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadFirst_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6Jk5,
                       label: Data.Monoid.$fReadFirst_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jk5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Jk9; else goto c6Jk8;
       c6Jk9: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Monoid.$fReadFirst_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Jk8: // global
           I64[Hp - 8] = sat_s6I4Y_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.547785235 UTC

[section ""data" . Data.Monoid.$fReadFirst_$creadList_closure" {
     Data.Monoid.$fReadFirst_$creadList_closure:
         const Data.Monoid.$fReadFirst_$creadList_info;
         const 0;
 },
 sat_s6I50_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Jku,
                       label: sat_s6I50_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jku: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadFirst1_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I51_entry() //  [R1]
         { info_tbl: [(c6Jkx,
                       label: sat_s6I51_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jkx: // global
           _s6I51::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6Jky; else goto c6Jkz;
       c6Jkz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6JkB; else goto c6JkA;
       c6JkB: // global
           HpAlloc = 16;
           goto c6Jky;
       c6Jky: // global
           R1 = _s6I51::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JkA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6I51::P64;
           _s6I4Z::P64 = P64[_s6I51::P64 + 16];
           I64[Hp - 8] = sat_s6I50_info;
           P64[Hp] = _s6I4Z::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fReadFirst_$creadList_entry() //  [R2]
         { info_tbl: [(c6JkC,
                       label: Data.Monoid.$fReadFirst_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JkC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6JkG; else goto c6JkF;
       c6JkG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Monoid.$fReadFirst_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6JkF: // global
           I64[Hp - 16] = sat_s6I51_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.556888738 UTC

[section ""data" . Data.Monoid.$fReadFirst_closure" {
     Data.Monoid.$fReadFirst_closure:
         const Data.Monoid.$fReadFirst_info;
         const 0;
 },
 sat_s6I56_entry() //  [R1]
         { info_tbl: [(c6Jl0,
                       label: sat_s6I56_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jl0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Jl1; else goto c6Jl2;
       c6Jl1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Jl2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadFirst_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I55_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Jl8,
                       label: sat_s6I55_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jl8: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadFirst1_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I54_entry() //  [R1]
         { info_tbl: [(c6Jlf,
                       label: sat_s6I54_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jlf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Jlg; else goto c6Jlh;
       c6Jlg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Jlh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadFirst_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6I53_entry() //  [R1, R2]
         { info_tbl: [(c6Jln,
                       label: sat_s6I53_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jln: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Monoid.$fReadFirst_$creadsPrec_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadFirst_entry() //  [R2]
         { info_tbl: [(c6Jlr,
                       label: Data.Monoid.$fReadFirst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jlr: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c6Jlv; else goto c6Jlu;
       c6Jlv: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Monoid.$fReadFirst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Jlu: // global
           I64[Hp - 112] = sat_s6I56_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6I55_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s6I54_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s6I53_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 112;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.569089553 UTC

[section ""data" . Data.Monoid.$fEqFirst_closure" {
     Data.Monoid.$fEqFirst_closure:
         const Data.Monoid.$fEqFirst_info;
 },
 sat_s6I59_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Jm2,
                       label: sat_s6I59_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jm2: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c/=_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I58_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Jma,
                       label: sat_s6I58_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jma: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fEqFirst_entry() //  [R2]
         { info_tbl: [(c6Jme,
                       label: Data.Monoid.$fEqFirst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jme: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6Jmi; else goto c6Jmh;
       c6Jmi: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Monoid.$fEqFirst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Jmh: // global
           I64[Hp - 48] = sat_s6I59_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s6I58_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.577167816 UTC

[section ""data" . Data.Monoid.$fOrdFirst_$cp1Ord_closure" {
     Data.Monoid.$fOrdFirst_$cp1Ord_closure:
         const Data.Monoid.$fOrdFirst_$cp1Ord_info;
 },
 sat_s6I5b_entry() //  [R1]
         { info_tbl: [(c6JmE,
                       label: sat_s6I5b_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JmE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JmF; else goto c6JmG;
       c6JmF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JmG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fOrdFirst_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6JmH,
                       label: Data.Monoid.$fOrdFirst_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JmH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6JmL; else goto c6JmK;
       c6JmL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Monoid.$fOrdFirst_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6JmK: // global
           I64[Hp - 16] = sat_s6I5b_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Monoid.$fEqFirst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.585064585 UTC

[section ""data" . Data.Monoid.$fOrdFirst_closure" {
     Data.Monoid.$fOrdFirst_closure:
         const Data.Monoid.$fOrdFirst_info;
 },
 sat_s6I5m_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Jn3,
                       label: sat_s6I5m_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jn3: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmin_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I5l_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Jnb,
                       label: sat_s6I5l_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jnb: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmax_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I5k_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Jnj,
                       label: sat_s6I5k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jnj: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c>=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I5j_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Jnr,
                       label: sat_s6I5j_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jnr: // global
           R4 = R2;
           R3 = R3;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I5g_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Jnz,
                       label: sat_s6I5g_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jnz: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I5f_entry() //  [R1, R2, R3]
         { info_tbl: [(c6JnH,
                       label: sat_s6I5f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JnH: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I5e_entry() //  [R1, R2, R3]
         { info_tbl: [(c6JnP,
                       label: sat_s6I5e_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JnP: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6I5d_entry() //  [R1]
         { info_tbl: [(c6JnW,
                       label: sat_s6I5d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JnW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JnX; else goto c6JnY;
       c6JnX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JnY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fOrdFirst_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fOrdFirst_entry() //  [R2]
         { info_tbl: [(c6Jo0,
                       label: Data.Monoid.$fOrdFirst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jo0: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto c6Jo4; else goto c6Jo3;
       c6Jo4: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = Data.Monoid.$fOrdFirst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Jo3: // global
           I64[Hp - 200] = sat_s6I5m_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6I5l_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s6I5k_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s6I5j_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6I5g_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s6I5f_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6I5e_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6I5d_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.60333207 UTC

[section ""data" . Data.Monoid.getFirst_closure" {
     Data.Monoid.getFirst_closure:
         const Data.Monoid.getFirst_info;
 },
 Data.Monoid.getFirst_entry() //  [R2]
         { info_tbl: [(c6JoL,
                       label: Data.Monoid.getFirst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JoL: // global
           R2 = R2;
           call Data.Monoid.$fGeneric1First2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.606948062 UTC

[section ""data" . Data.Monoid.getLast_closure" {
     Data.Monoid.getLast_closure:
         const Data.Monoid.getLast_info;
 },
 Data.Monoid.getLast_entry() //  [R2]
         { info_tbl: [(c6JoW,
                       label: Data.Monoid.getLast_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JoW: // global
           R2 = R2;
           call Data.Monoid.$fGeneric1Last2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.610265759 UTC

[section ""cstring" . Data.Monoid.$trModule4_bytes" {
     Data.Monoid.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.612080766 UTC

[section ""data" . Data.Monoid.$trModule3_closure" {
     Data.Monoid.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.61383152 UTC

[section ""cstring" . Data.Monoid.$trModule2_bytes" {
     Data.Monoid.$trModule2_bytes:
         I8[] [68,97,116,97,46,77,111,110,111,105,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.61553593 UTC

[section ""data" . Data.Monoid.$trModule1_closure" {
     Data.Monoid.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.618394653 UTC

[section ""data" . Data.Monoid.$trModule_closure" {
     Data.Monoid.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Monoid.$trModule3_closure+1;
         const Data.Monoid.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.620347462 UTC

[section ""data" . $krep_r6I1r_closure" {
     $krep_r6I1r_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.6221106 UTC

[section ""data" . $krep1_r6I1s_closure" {
     $krep1_r6I1s_closure:
         const :_con_info;
         const $krep_r6I1r_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.623916101 UTC

[section ""data" . $krep2_r6I1t_closure" {
     $krep2_r6I1t_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep1_r6I1s_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.625977553 UTC

[section ""data" . Data.Monoid.$tcFirst1_closure" {
     Data.Monoid.$tcFirst1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$fReadFirst11_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.627713583 UTC

[section ""data" . Data.Monoid.$tcFirst_closure" {
     Data.Monoid.$tcFirst_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Monoid.$trModule_closure+1;
         const Data.Monoid.$tcFirst1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 12072287807032806756;
         const 12788244796562536401;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.629583723 UTC

[section ""data" . $krep3_r6I1u_closure" {
     $krep3_r6I1u_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Monoid.$tcFirst_closure+1;
         const $krep1_r6I1s_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.631851546 UTC

[section ""data" . Data.Monoid.$tc'First1_closure" {
     Data.Monoid.$tc'First1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r6I1t_closure+1;
         const $krep3_r6I1u_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.634356936 UTC

[section ""cstring" . Data.Monoid.$tc'First3_bytes" {
     Data.Monoid.$tc'First3_bytes:
         I8[] [39,70,105,114,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.636296188 UTC

[section ""data" . Data.Monoid.$tc'First2_closure" {
     Data.Monoid.$tc'First2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$tc'First3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.638635942 UTC

[section ""data" . Data.Monoid.$tc'First_closure" {
     Data.Monoid.$tc'First_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Monoid.$trModule_closure+1;
         const Data.Monoid.$tc'First2_closure+1;
         const Data.Monoid.$tc'First1_closure+4;
         const 7752528083504400280;
         const 15965132804789246607;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.641150843 UTC

[section ""data" . Data.Monoid.$tcLast1_closure" {
     Data.Monoid.$tcLast1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$fReadLast5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.643546682 UTC

[section ""data" . Data.Monoid.$tcLast_closure" {
     Data.Monoid.$tcLast_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Monoid.$trModule_closure+1;
         const Data.Monoid.$tcLast1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 6920195955404695016;
         const 2388797855174213212;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.646128221 UTC

[section ""data" . $krep4_r6I1v_closure" {
     $krep4_r6I1v_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Monoid.$tcLast_closure+1;
         const $krep1_r6I1s_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.648473453 UTC

[section ""data" . Data.Monoid.$tc'Last1_closure" {
     Data.Monoid.$tc'Last1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r6I1t_closure+1;
         const $krep4_r6I1v_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.651540327 UTC

[section ""cstring" . Data.Monoid.$tc'Last3_bytes" {
     Data.Monoid.$tc'Last3_bytes:
         I8[] [39,76,97,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.653892468 UTC

[section ""data" . Data.Monoid.$tc'Last2_closure" {
     Data.Monoid.$tc'Last2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$tc'Last3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.656103659 UTC

[section ""data" . Data.Monoid.$tc'Last_closure" {
     Data.Monoid.$tc'Last_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Monoid.$trModule_closure+1;
         const Data.Monoid.$tc'Last2_closure+1;
         const Data.Monoid.$tc'Last1_closure+4;
         const 5411164464353425083;
         const 12998161994081761510;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:57.659192181 UTC

[section ""relreadonly" . S6I7j_srt" {
     S6I7j_srt:
         const Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
         const Data.Monoid.$fMonoidFirst_closure;
         const Data.Monoid.$fMonoidLast_closure;
         const GHC.Show.$fShowMaybe_$cshowsPrec_closure;
         const Data.Monoid.$w$cshowsPrec1_closure;
         const Data.Monoid.$fShowLast_$cshowsPrec_closure;
         const GHC.Show.$fShowMaybe4_closure;
         const Data.Monoid.$fReadFirst3_closure;
         const GHC.Show.$fShowMaybe1_closure;
         const Data.Monoid.$fShowFirst4_closure;
         const Data.Monoid.$fShowLast_$cshow_closure;
         const Data.Monoid.$fShowLast_$cshowList_closure;
         const Data.Monoid.$fShowLast_closure;
         const GHC.Read.$fReadMaybe1_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Monoid.$fReadFirst2_closure;
         const GHC.Read.readField_closure;
         const Data.Monoid.$fReadLast2_closure;
         const Data.Monoid.$fReadFirst_lexeme_closure;
         const Data.Monoid.$fReadLast_lexeme_closure;
         const GHC.Read.list3_closure;
         const Data.Monoid.$fReadLast1_closure;
         const Data.Monoid.$fReadLast_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Monoid.$fReadLast_$creadListPrec_closure;
         const Data.Monoid.$fReadLast_$creadList_closure;
         const Data.Monoid.$fReadLast_closure;
         const Data.Monoid.$w$cshowsPrec_closure;
         const Data.Monoid.$fShowFirst_$cshowsPrec_closure;
         const Data.Monoid.$fShowFirst_$cshow_closure;
         const Data.Monoid.$fShowFirst_$cshowList_closure;
         const Data.Monoid.$fShowFirst_closure;
         const Data.Monoid.$fReadFirst6_closure;
         const Data.Monoid.$fReadFirst_lexeme1_closure;
         const Data.Monoid.$fReadFirst1_closure;
         const Data.Monoid.$fReadFirst_$creadsPrec_closure;
         const Data.Monoid.$fReadFirst_$creadListPrec_closure;
         const Data.Monoid.$fReadFirst_$creadList_closure;
         const Data.Monoid.$fReadFirst_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.161087691 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:01:59.162895559 UTC

[section ""data" . Data.Monoid.$fMonoidFirst_$c<>_closure" {
     Data.Monoid.$fMonoidFirst_$c<>_closure:
         const Data.Monoid.$fMonoidFirst_$c<>_info;
 },
 Data.Monoid.$fMonoidFirst_$c<>_entry() //  [R2, R3]
         { info_tbl: [(c6Jtr,
                       label: Data.Monoid.$fMonoidFirst_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jtr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Jts; else goto c6Jtt;
       c6Jts: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fMonoidFirst_$c<>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Jtt: // global
           I64[Sp - 16] = block_c6Jtk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6JtA; else goto c6Jtl;
       u6JtA: // global
           call _c6Jtk(R1) args: 0, res: 0, upd: 0;
       c6Jtl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Jtk() //  [R1]
         { info_tbl: [(c6Jtk,
                       label: block_c6Jtk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jtk: // global
           if (R1 & 7 == 1) goto c6Jto; else goto c6Jtp;
       c6Jto: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6Jtp: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.169701595 UTC

[section ""data" . Data.Monoid.$fSemigroupFirst1_closure" {
     Data.Monoid.$fSemigroupFirst1_closure:
         const Data.Monoid.$fSemigroupFirst1_info;
 },
 Data.Monoid.$fSemigroupFirst1_entry() //  [R2, R3]
         { info_tbl: [(c6Ju2,
                       label: Data.Monoid.$fSemigroupFirst1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ju2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6Ju3; else goto u6Juo;
       c6Ju3: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fSemigroupFirst1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u6Juo: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c6JtS() args: 0, res: 0, upd: 0;
     }
 },
 _c6JtS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JtS: // global
           I64[Sp - 8] = block_c6JtV_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6Juq; else goto c6JtW;
       u6Juq: // global
           call _c6JtV(R1) args: 0, res: 0, upd: 0;
       c6JtW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6JtV() //  [R1]
         { info_tbl: [(c6JtV,
                       label: block_c6JtV_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JtV: // global
           _s6Jpu::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6JtZ; else goto c6Ju0;
       c6JtZ: // global
           R1 = _s6Jpu::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6Ju0: // global
           I64[Sp] = block_c6Jua_info;
           _s6Jpx::P64 = P64[R1 + 6];
           _s6Jpy::P64 = P64[R1 + 14];
           R1 = _s6Jpu::P64;
           P64[Sp + 8] = _s6Jpy::P64;
           P64[Sp + 16] = _s6Jpx::P64;
           if (R1 & 7 != 0) goto u6Jur; else goto c6Juc;
       u6Jur: // global
           call _c6Jua(R1) args: 0, res: 0, upd: 0;
       c6Juc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Jua() //  [R1]
         { info_tbl: [(c6Jua,
                       label: block_c6Jua_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jua: // global
           if (R1 & 7 == 1) goto c6Jui; else goto c6Jum;
       c6Jui: // global
           _s6Jpv::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s6Jpv::P64;
           Sp = Sp + 8;
           call _c6JtS() args: 0, res: 0, upd: 0;
       c6Jum: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.179275428 UTC

[section ""data" . Data.Monoid.$fSemigroupFirst_$csconcat_closure" {
     Data.Monoid.$fSemigroupFirst_$csconcat_closure:
         const Data.Monoid.$fSemigroupFirst_$csconcat_info;
 },
 Data.Monoid.$fSemigroupFirst_$csconcat_entry() //  [R2]
         { info_tbl: [(c6Jv1,
                       label: Data.Monoid.$fSemigroupFirst_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jv1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6Jv2; else goto c6Jv3;
       c6Jv2: // global
           R2 = R2;
           R1 = Data.Monoid.$fSemigroupFirst_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Jv3: // global
           I64[Sp - 8] = block_c6JuY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6Jv7; else goto c6JuZ;
       u6Jv7: // global
           call _c6JuY(R1) args: 0, res: 0, upd: 0;
       c6JuZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6JuY() //  [R1]
         { info_tbl: [(c6JuY,
                       label: block_c6JuY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JuY: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Monoid.$fSemigroupFirst1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.185829932 UTC

[section ""data" . Data.Monoid.$fMonoidFirst_go_closure" {
     Data.Monoid.$fMonoidFirst_go_closure:
         const Data.Monoid.$fMonoidFirst_go_info;
 },
 Data.Monoid.$fMonoidFirst_go_entry() //  [R2]
         { info_tbl: [(c6Jvt,
                       label: Data.Monoid.$fMonoidFirst_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jvt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Jvu; else goto u6JvP;
       c6Jvu: // global
           R2 = R2;
           R1 = Data.Monoid.$fMonoidFirst_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u6JvP: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c6Jvj() args: 0, res: 0, upd: 0;
     }
 },
 _c6Jvj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jvj: // global
           _s6JpF::P64 = P64[Sp];
           I64[Sp] = block_c6Jvm_info;
           R1 = _s6JpF::P64;
           if (R1 & 7 != 0) goto u6JvR; else goto c6Jvn;
       u6JvR: // global
           call _c6Jvm(R1) args: 0, res: 0, upd: 0;
       c6Jvn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Jvm() //  [R1]
         { info_tbl: [(c6Jvm,
                       label: block_c6Jvm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jvm: // global
           if (R1 & 7 == 1) goto c6Jvq; else goto c6Jvr;
       c6Jvq: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6Jvr: // global
           I64[Sp - 8] = block_c6JvB_info;
           _s6JpI::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s6JpI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6JvS; else goto c6JvD;
       u6JvS: // global
           call _c6JvB(R1) args: 0, res: 0, upd: 0;
       c6JvD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6JvB() //  [R1]
         { info_tbl: [(c6JvB,
                       label: block_c6JvB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JvB: // global
           if (R1 & 7 == 1) goto c6JvJ; else goto c6JvN;
       c6JvJ: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c6Jvj() args: 0, res: 0, upd: 0;
       c6JvN: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.195348962 UTC

[section ""data" . Data.Monoid.$fSemigroupFirst_closure" {
     Data.Monoid.$fSemigroupFirst_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Monoid.$fMonoidFirst_$c<>_closure+2;
         const Data.Monoid.$fSemigroupFirst_$csconcat_closure+1;
         const Data.Monoid.$fSemigroupFirst_$cstimes_closure+3;
         const 0;
 },
 section ""data" . Data.Monoid.$fMonoidFirst_closure" {
     Data.Monoid.$fMonoidFirst_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Monoid.$fSemigroupFirst_closure+1;
         const GHC.Base.Nothing_closure+1;
         const Data.Monoid.$fMonoidFirst_$c<>_closure+2;
         const Data.Monoid.$fMonoidFirst_go_closure+1;
         const 0;
 },
 section ""data" . Data.Monoid.$fSemigroupFirst_$cstimes_closure" {
     Data.Monoid.$fSemigroupFirst_$cstimes_closure:
         const Data.Monoid.$fSemigroupFirst_$cstimes_info;
         const 0;
 },
 Data.Monoid.$fSemigroupFirst_$cstimes_entry() //  [R2, R3, R4]
         { info_tbl: [(c6Jwp,
                       label: Data.Monoid.$fSemigroupFirst_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jwp: // global
           R5 = R4;
           R4 = R3;
           R3 = Data.Monoid.$fMonoidFirst_closure+1;
           R2 = R2;
           call Data.Semigroup.Internal.stimesIdempotentMonoid_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.202145259 UTC

[section ""data" . Data.Monoid.$fMonoidLast_$c<>_closure" {
     Data.Monoid.$fMonoidLast_$c<>_closure:
         const Data.Monoid.$fMonoidLast_$c<>_info;
 },
 Data.Monoid.$fMonoidLast_$c<>_entry() //  [R2, R3]
         { info_tbl: [(c6JwK,
                       label: Data.Monoid.$fMonoidLast_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JwK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JwL; else goto c6JwM;
       c6JwL: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fMonoidLast_$c<>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6JwM: // global
           I64[Sp - 16] = block_c6JwD_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6JwT; else goto c6JwE;
       u6JwT: // global
           call _c6JwD(R1) args: 0, res: 0, upd: 0;
       c6JwE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6JwD() //  [R1]
         { info_tbl: [(c6JwD,
                       label: block_c6JwD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JwD: // global
           if (R1 & 7 == 1) goto c6JwH; else goto c6JwI;
       c6JwH: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6JwI: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.208819147 UTC

[section ""data" . Data.Monoid.$fSemigroupLast1_closure" {
     Data.Monoid.$fSemigroupLast1_closure:
         const Data.Monoid.$fSemigroupLast1_info;
 },
 Data.Monoid.$fSemigroupLast1_entry() //  [R2, R3]
         { info_tbl: [(c6Jxl,
                       label: Data.Monoid.$fSemigroupLast1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jxl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Jxm; else goto c6Jxn;
       c6Jxm: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fSemigroupLast1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Jxn: // global
           I64[Sp - 16] = block_c6Jxe_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6JxJ; else goto c6Jxf;
       u6JxJ: // global
           call _c6Jxe(R1) args: 0, res: 0, upd: 0;
       c6Jxf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Jxe() //  [R1]
         { info_tbl: [(c6Jxe,
                       label: block_c6Jxe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jxe: // global
           if (R1 & 7 == 1) goto u6JxG; else goto c6Jxj;
       u6JxG: // global
           Sp = Sp + 8;
           call _c6JxA() args: 0, res: 0, upd: 0;
       c6Jxj: // global
           I64[Sp] = block_c6Jxt_info;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Monoid.$fSemigroupLast1_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Jxt() //  [R1]
         { info_tbl: [(c6Jxt,
                       label: block_c6Jxt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jxt: // global
           if (R1 & 7 == 1) goto u6JxH; else goto c6JxE;
       u6JxH: // global
           Sp = Sp + 8;
           call _c6JxA() args: 0, res: 0, upd: 0;
       c6JxE: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6JxA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JxA: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.218353847 UTC

[section ""data" . Data.Monoid.$fSemigroupLast_$csconcat_closure" {
     Data.Monoid.$fSemigroupLast_$csconcat_closure:
         const Data.Monoid.$fSemigroupLast_$csconcat_info;
 },
 Data.Monoid.$fSemigroupLast_$csconcat_entry() //  [R2]
         { info_tbl: [(c6Jyg,
                       label: Data.Monoid.$fSemigroupLast_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jyg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6Jyh; else goto c6Jyi;
       c6Jyh: // global
           R2 = R2;
           R1 = Data.Monoid.$fSemigroupLast_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Jyi: // global
           I64[Sp - 8] = block_c6Jyd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6Jym; else goto c6Jye;
       u6Jym: // global
           call _c6Jyd(R1) args: 0, res: 0, upd: 0;
       c6Jye: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Jyd() //  [R1]
         { info_tbl: [(c6Jyd,
                       label: block_c6Jyd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jyd: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Monoid.$fSemigroupLast1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.224659968 UTC

[section ""data" . Data.Monoid.$fMonoidLast_go_closure" {
     Data.Monoid.$fMonoidLast_go_closure:
         const Data.Monoid.$fMonoidLast_go_info;
 },
 Data.Monoid.$fMonoidLast_go_entry() //  [R2]
         { info_tbl: [(c6JyI,
                       label: Data.Monoid.$fMonoidLast_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JyI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JyJ; else goto c6JyK;
       c6JyJ: // global
           R2 = R2;
           R1 = Data.Monoid.$fMonoidLast_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6JyK: // global
           I64[Sp - 8] = block_c6JyB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6Jz3; else goto c6JyC;
       u6Jz3: // global
           call _c6JyB(R1) args: 0, res: 0, upd: 0;
       c6JyC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6JyB() //  [R1]
         { info_tbl: [(c6JyB,
                       label: block_c6JyB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JyB: // global
           if (R1 & 7 == 1) goto c6JyF; else goto c6JyG;
       c6JyF: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6JyG: // global
           I64[Sp - 8] = block_c6JyQ_info;
           R2 = P64[R1 + 14];
           P64[Sp] = P64[R1 + 6];
           Sp = Sp - 8;
           call Data.Monoid.$fMonoidLast_go_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6JyQ() //  [R1]
         { info_tbl: [(c6JyQ,
                       label: block_c6JyQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JyQ: // global
           if (R1 & 7 == 1) goto c6JyX; else goto c6Jz1;
       c6JyX: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6Jz1: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.232679279 UTC

[section ""data" . Data.Monoid.$fSemigroupLast_closure" {
     Data.Monoid.$fSemigroupLast_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Monoid.$fMonoidLast_$c<>_closure+2;
         const Data.Monoid.$fSemigroupLast_$csconcat_closure+1;
         const Data.Monoid.$fSemigroupLast_$cstimes_closure+3;
         const 0;
 },
 section ""data" . Data.Monoid.$fMonoidLast_closure" {
     Data.Monoid.$fMonoidLast_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Monoid.$fSemigroupLast_closure+1;
         const GHC.Base.Nothing_closure+1;
         const Data.Monoid.$fMonoidLast_$c<>_closure+2;
         const Data.Monoid.$fMonoidLast_go_closure+1;
         const 0;
 },
 section ""data" . Data.Monoid.$fSemigroupLast_$cstimes_closure" {
     Data.Monoid.$fSemigroupLast_$cstimes_closure:
         const Data.Monoid.$fSemigroupLast_$cstimes_info;
         const 0;
 },
 Data.Monoid.$fSemigroupLast_$cstimes_entry() //  [R2, R3, R4]
         { info_tbl: [(c6Jzx,
                       label: Data.Monoid.$fSemigroupLast_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Jzx: // global
           R5 = R4;
           R4 = R3;
           R3 = Data.Monoid.$fMonoidLast_closure+1;
           R2 = R2;
           call Data.Semigroup.Internal.stimesIdempotentMonoid_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.237404734 UTC

[section ""data" . Data.Monoid.$fFunctorLast_closure" {
     Data.Monoid.$fFunctorLast_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fApplicativeMaybe_$cfmap_closure+2;
         const GHC.Base.$fFunctorMaybe_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.239640647 UTC

[section ""data" . Data.Monoid.$fApplicativeLast_closure" {
     Data.Monoid.$fApplicativeLast_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Monoid.$fFunctorLast_closure+1;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fApplicativeMaybe_$c<*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$cliftA2_closure+3;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c<*_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.241457473 UTC

[section ""data" . Data.Monoid.$fMonadLast_closure" {
     Data.Monoid.$fMonadLast_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Monoid.$fApplicativeLast_closure+1;
         const GHC.Base.$fMonadMaybe_$c>>=_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fMonadMaybe_$cfail_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.243394315 UTC

[section ""data" . Data.Monoid.$fGeneric1Last1_closure" {
     Data.Monoid.$fGeneric1Last1_closure:
         const Data.Monoid.$fGeneric1Last1_info;
 },
 Data.Monoid.$fGeneric1Last1_entry() //  [R2]
         { info_tbl: [(c6JzN,
                       label: Data.Monoid.$fGeneric1Last1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JzN: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.246655821 UTC

[section ""data" . Data.Monoid.$fGeneric1Last2_closure" {
     Data.Monoid.$fGeneric1Last2_closure:
         const Data.Monoid.$fGeneric1Last2_info;
 },
 Data.Monoid.$fGeneric1Last2_entry() //  [R2]
         { info_tbl: [(c6JzY,
                       label: Data.Monoid.$fGeneric1Last2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JzY: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.249951256 UTC

[section ""data" . Data.Monoid.$fGeneric1Last_closure" {
     Data.Monoid.$fGeneric1Last_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Monoid.$fGeneric1Last2_closure+1;
         const Data.Monoid.$fGeneric1Last1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.251653961 UTC

[section ""data" . Data.Monoid.$fGenericLast1_closure" {
     Data.Monoid.$fGenericLast1_closure:
         const Data.Monoid.$fGenericLast1_info;
 },
 Data.Monoid.$fGenericLast1_entry() //  [R2]
         { info_tbl: [(c6JAc,
                       label: Data.Monoid.$fGenericLast1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JAc: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.254827945 UTC

[section ""data" . Data.Monoid.$fGenericLast2_closure" {
     Data.Monoid.$fGenericLast2_closure:
         const Data.Monoid.$fGenericLast2_info;
 },
 Data.Monoid.$fGenericLast2_entry() //  [R2]
         { info_tbl: [(c6JAn,
                       label: Data.Monoid.$fGenericLast2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JAn: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.257926864 UTC

[section ""data" . Data.Monoid.$fGenericLast_closure" {
     Data.Monoid.$fGenericLast_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Monoid.$fGenericLast2_closure+1;
         const Data.Monoid.$fGenericLast1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.25953436 UTC

[section ""data" . Data.Monoid.$fShowFirst1_closure" {
     Data.Monoid.$fShowFirst1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.261078658 UTC

[section ""cstring" . Data.Monoid.$fShowLast2_bytes" {
     Data.Monoid.$fShowLast2_bytes:
         I8[] [76,97,115,116,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.262687717 UTC

[section ""cstring" . Data.Monoid.$fShowLast1_bytes" {
     Data.Monoid.$fShowLast1_bytes:
         I8[] [103,101,116,76,97,115,116,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.264684258 UTC

[section ""cstring" . Data.Monoid.$fReadFirst4_bytes" {
     Data.Monoid.$fReadFirst4_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.268742007 UTC

[section ""data" . Data.Monoid.$w$cshowsPrec1_closure" {
     Data.Monoid.$w$cshowsPrec1_closure:
         const Data.Monoid.$w$cshowsPrec1_info;
         const 0;
 },
 f_s6Jqf_entry() //  [R1]
         { info_tbl: [(c6JAJ,
                       label: f_s6Jqf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JAJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JAK; else goto c6JAL;
       c6JAK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JAL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = Data.Monoid.$fShowFirst1_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.$fShowMaybe_$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6Jqi_entry() //  [R1]
         { info_tbl: [(c6JB6,
                       label: sat_s6Jqi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JB6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JB7; else goto c6JB8;
       c6JB7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JB8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Monoid.$fReadFirst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6Jqj_entry() //  [R1]
         { info_tbl: [(c6JB9,
                       label: sat_s6Jqj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JB9: // global
           _s6Jqj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6JBa; else goto c6JBb;
       c6JBb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6JBd; else goto c6JBc;
       c6JBd: // global
           HpAlloc = 24;
           goto c6JBa;
       c6JBa: // global
           R1 = _s6Jqj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JBc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6Jqj::P64;
           _s6Jqf::P64 = P64[_s6Jqj::P64 + 16];
           _s6Jqh::P64 = P64[_s6Jqj::P64 + 24];
           I64[Hp - 16] = sat_s6Jqi_info;
           P64[Hp] = _s6Jqh::P64;
           R2 = Hp - 16;
           R1 = _s6Jqf::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6Jqk_entry() //  [R1]
         { info_tbl: [(c6JBe,
                       label: sat_s6Jqk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JBe: // global
           _s6Jqk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6JBf; else goto c6JBg;
       c6JBg: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JBi; else goto c6JBh;
       c6JBi: // global
           HpAlloc = 32;
           goto c6JBf;
       c6JBf: // global
           R1 = _s6Jqk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JBh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6Jqk::P64;
           _s6Jqf::P64 = P64[_s6Jqk::P64 + 16];
           _s6Jqh::P64 = P64[_s6Jqk::P64 + 24];
           I64[Hp - 24] = sat_s6Jqj_info;
           P64[Hp - 8] = _s6Jqf::P64;
           P64[Hp] = _s6Jqh::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6Jql_entry() //  [R1, R2]
         { info_tbl: [(c6JBj,
                       label: sat_s6Jql_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JBj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JBn; else goto c6JBm;
       c6JBn: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6JBm: // global
           _s6Jqf::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6Jqk_info;
           P64[Hp - 8] = _s6Jqf::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6Jqo_entry() //  [R1]
         { info_tbl: [(c6JBL,
                       label: sat_s6Jqo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JBL: // global
           _s6Jqo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6JBM; else goto c6JBN;
       c6JBN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6JBP; else goto c6JBO;
       c6JBP: // global
           HpAlloc = 24;
           goto c6JBM;
       c6JBM: // global
           R1 = _s6Jqo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JBO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6Jqo::P64;
           _s6Jqm::P64 = P64[_s6Jqo::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6Jqm::P64;
           R3 = Hp - 14;
           R2 = Data.Monoid.$fReadFirst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6Jqp_entry() //  [R1]
         { info_tbl: [(c6JBQ,
                       label: sat_s6Jqp_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JBQ: // global
           _s6Jqp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6JBR; else goto c6JBS;
       c6JBS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6JBU; else goto c6JBT;
       c6JBU: // global
           HpAlloc = 24;
           goto c6JBR;
       c6JBR: // global
           R1 = _s6Jqp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JBT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6Jqp::P64;
           _s6Jqf::P64 = P64[_s6Jqp::P64 + 16];
           _s6Jqm::P64 = P64[_s6Jqp::P64 + 24];
           I64[Hp - 16] = sat_s6Jqo_info;
           P64[Hp] = _s6Jqm::P64;
           R2 = Hp - 16;
           R1 = _s6Jqf::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6Jqq_entry() //  [R1]
         { info_tbl: [(c6JBV,
                       label: sat_s6Jqq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JBV: // global
           _s6Jqq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6JBW; else goto c6JBX;
       c6JBX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JBZ; else goto c6JBY;
       c6JBZ: // global
           HpAlloc = 32;
           goto c6JBW;
       c6JBW: // global
           R1 = _s6Jqq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JBY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6Jqq::P64;
           _s6Jqf::P64 = P64[_s6Jqq::P64 + 16];
           _s6Jqm::P64 = P64[_s6Jqq::P64 + 24];
           I64[Hp - 24] = sat_s6Jqp_info;
           P64[Hp - 8] = _s6Jqf::P64;
           P64[Hp] = _s6Jqm::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6Jqr_entry() //  [R1]
         { info_tbl: [(c6JC0,
                       label: sat_s6Jqr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JC0: // global
           _s6Jqr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6JC1; else goto c6JC2;
       c6JC2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JC4; else goto c6JC3;
       c6JC4: // global
           HpAlloc = 32;
           goto c6JC1;
       c6JC1: // global
           R1 = _s6Jqr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JC3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6Jqr::P64;
           _s6Jqf::P64 = P64[_s6Jqr::P64 + 16];
           _s6Jqm::P64 = P64[_s6Jqr::P64 + 24];
           I64[Hp - 24] = sat_s6Jqq_info;
           P64[Hp - 8] = _s6Jqf::P64;
           P64[Hp] = _s6Jqm::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6Jqs_entry() //  [R1, R2]
         { info_tbl: [(c6JC6,
                       label: sat_s6Jqs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JC6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6JCa; else goto c6JC9;
       c6JCa: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6JC9: // global
           _s6Jqf::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6Jqr_info;
           P64[Hp - 32] = _s6Jqf::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$w$cshowsPrec1_entry() //  [R2, R3, R4]
         { info_tbl: [(c6JCe,
                       label: Data.Monoid.$w$cshowsPrec1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JCe: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6JCi; else goto c6JCh;
       c6JCi: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$w$cshowsPrec1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6JCh: // global
           I64[Hp - 40] = f_s6Jqf_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6JAF::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6JCc; else goto c6JCd;
       c6JCc: // global
           I64[Hp - 8] = sat_s6Jql_info;
           P64[Hp] = _c6JAF::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6JCd: // global
           I64[Hp - 8] = sat_s6Jqs_info;
           P64[Hp] = _c6JAF::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.295265553 UTC

[section ""data" . Data.Monoid.$fShowLast_$cshowsPrec_closure" {
     Data.Monoid.$fShowLast_$cshowsPrec_closure:
         const Data.Monoid.$fShowLast_$cshowsPrec_info;
         const 0;
 },
 Data.Monoid.$fShowLast_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c6JDw,
                       label: Data.Monoid.$fShowLast_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JDw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6JDx; else goto c6JDy;
       c6JDx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowLast_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6JDy: // global
           I64[Sp - 24] = block_c6JDt_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6JDC; else goto c6JDu;
       u6JDC: // global
           call _c6JDt(R1) args: 0, res: 0, upd: 0;
       c6JDu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6JDt() //  [R1]
         { info_tbl: [(c6JDt,
                       label: block_c6JDt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JDt: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Monoid.$w$cshowsPrec1_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.301560879 UTC

[section ""data" . Data.Monoid.$fReadFirst3_closure" {
     Data.Monoid.$fReadFirst3_closure:
         const Data.Monoid.$fReadFirst3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadFirst3_entry() //  [R1]
         { info_tbl: [(c6JDT,
                       label: Data.Monoid.$fReadFirst3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JDT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JDU; else goto c6JDV;
       c6JDU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JDV: // global
           (_c6JDQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6JDQ::I64 == 0) goto c6JDS; else goto c6JDR;
       c6JDS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6JDR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6JDQ::I64;
           R2 = Data.Monoid.$fReadFirst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.305918724 UTC

[section ""data" . Data.Monoid.$fShowFirst4_closure" {
     Data.Monoid.$fShowFirst4_closure:
         const Data.Monoid.$fShowFirst4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fShowFirst4_entry() //  [R1]
         { info_tbl: [(c6JEa,
                       label: Data.Monoid.$fShowFirst4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JEa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JEb; else goto c6JEc;
       c6JEb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JEc: // global
           (_c6JE7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6JE7::I64 == 0) goto c6JE9; else goto c6JE8;
       c6JE9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6JE8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6JE7::I64;
           R3 = Data.Monoid.$fReadFirst3_closure;
           R2 = GHC.Show.$fShowMaybe4_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.311730123 UTC

[section ""data" . Data.Monoid.$fShowLast_$cshow_closure" {
     Data.Monoid.$fShowLast_$cshow_closure:
         const Data.Monoid.$fShowLast_$cshow_info;
         const 0;
 },
 sat_s6JqC_entry() //  [R1]
         { info_tbl: [(c6JEH,
                       label: sat_s6JqC_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JEH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6JEI; else goto c6JEJ;
       c6JEI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JEJ: // global
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Show.appPrec1_closure;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = Data.Monoid.$fReadFirst3_closure;
           Sp = Sp - 32;
           call GHC.Show.showsPrec_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_s6JqD_entry() //  [R1]
         { info_tbl: [(c6JEO,
                       label: sat_s6JqD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JEO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6JEP; else goto c6JEQ;
       c6JEP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JEQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6JEx_info;
           _s6Jqy::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s6Jqy::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6JEW; else goto c6JEy;
       u6JEW: // global
           call _c6JEx(R1) args: 0, res: 0, upd: 0;
       c6JEy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6JEx() //  [R1]
         { info_tbl: [(c6JEx,
                       label: block_c6JEx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JEx: // global
           if (R1 & 7 == 1) goto c6JEL; else goto c6JEM;
       c6JEL: // global
           R1 = Data.Monoid.$fShowFirst4_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c6JEM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JEV; else goto c6JEU;
       c6JEV: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6JEU: // global
           _s6JqB::P64 = P64[R1 + 6];
           I64[Hp - 24] = sat_s6JqC_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _s6JqB::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.$fShowMaybe1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6JqE_entry() //  [R1]
         { info_tbl: [(c6JEX,
                       label: sat_s6JqE_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JEX: // global
           _s6JqE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6JEY; else goto c6JEZ;
       c6JEZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JF1; else goto c6JF0;
       c6JF1: // global
           HpAlloc = 32;
           goto c6JEY;
       c6JEY: // global
           R1 = _s6JqE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JF0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6JqE::P64;
           _s6Jqy::P64 = P64[_s6JqE::P64 + 16];
           _s6Jqz::P64 = P64[_s6JqE::P64 + 24];
           I64[Hp - 24] = sat_s6JqD_info;
           P64[Hp - 8] = _s6Jqy::P64;
           P64[Hp] = _s6Jqz::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fShowLast_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6JF2,
                       label: Data.Monoid.$fShowLast_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JF2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JF6; else goto c6JF5;
       c6JF6: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowLast_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6JF5: // global
           I64[Hp - 24] = sat_s6JqE_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowLast2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.325145421 UTC

[section ""data" . Data.Monoid.$fShowLast_$cshowList_closure" {
     Data.Monoid.$fShowLast_$cshowList_closure:
         const Data.Monoid.$fShowLast_$cshowList_info;
         const 0;
 },
 sat_s6JqJ_entry() //  [R1, R2]
         { info_tbl: [(c6JFO,
                       label: sat_s6JqJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JFO: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Monoid.$w$cshowsPrec1_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fShowLast_$cshowList_entry() //  [R2, R3, R4]
         { info_tbl: [(c6JFR,
                       label: Data.Monoid.$fShowLast_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JFR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6JFV; else goto c6JFU;
       c6JFV: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowLast_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6JFU: // global
           I64[Hp - 8] = sat_s6JqJ_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.331474322 UTC

[section ""data" . Data.Monoid.$fShowLast_closure" {
     Data.Monoid.$fShowLast_closure:
         const Data.Monoid.$fShowLast_info;
         const 0;
 },
 sat_s6JqN_entry() //  [R1, R2, R3]
         { info_tbl: [(c6JGd,
                       label: sat_s6JqN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JGd: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fShowLast_$cshowList_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6JqM_entry() //  [R1, R2]
         { info_tbl: [(c6JGl,
                       label: sat_s6JqM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JGl: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Monoid.$fShowLast_$cshow_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6JqL_entry() //  [R1, R2, R3]
         { info_tbl: [(c6JGt,
                       label: sat_s6JqL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JGt: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fShowLast_$cshowsPrec_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fShowLast_entry() //  [R2]
         { info_tbl: [(c6JGx,
                       label: Data.Monoid.$fShowLast_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JGx: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6JGB; else goto c6JGA;
       c6JGB: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Monoid.$fShowLast_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6JGA: // global
           I64[Hp - 72] = sat_s6JqN_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6JqM_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6JqL_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.340283809 UTC

[section ""cstring" . Data.Monoid.$fReadLast5_bytes" {
     Data.Monoid.$fReadLast5_bytes:
         I8[] [76,97,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.342315574 UTC

[section ""data" . Data.Monoid.$fReadLast4_closure" {
     Data.Monoid.$fReadLast4_closure:
         const Data.Monoid.$fReadLast4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadLast4_entry() //  [R1]
         { info_tbl: [(c6JH4,
                       label: Data.Monoid.$fReadLast4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JH4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JH5; else goto c6JH6;
       c6JH5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JH6: // global
           (_c6JH1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6JH1::I64 == 0) goto c6JH3; else goto c6JH2;
       c6JH3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6JH2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6JH1::I64;
           R2 = Data.Monoid.$fReadLast5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.346392302 UTC

[section ""data" . Data.Monoid.$fReadLast_lexeme_closure" {
     Data.Monoid.$fReadLast_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Monoid.$fReadLast4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.348857085 UTC

[section ""cstring" . Data.Monoid.$fReadFirst9_bytes" {
     Data.Monoid.$fReadFirst9_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.351325084 UTC

[section ""data" . Data.Monoid.$fReadFirst8_closure" {
     Data.Monoid.$fReadFirst8_closure:
         const Data.Monoid.$fReadFirst8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadFirst8_entry() //  [R1]
         { info_tbl: [(c6JHn,
                       label: Data.Monoid.$fReadFirst8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JHn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JHo; else goto c6JHp;
       c6JHo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JHp: // global
           (_c6JHk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6JHk::I64 == 0) goto c6JHm; else goto c6JHl;
       c6JHm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6JHl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6JHk::I64;
           R2 = Data.Monoid.$fReadFirst9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.355562845 UTC

[section ""data" . Data.Monoid.$fReadFirst_lexeme_closure" {
     Data.Monoid.$fReadFirst_lexeme_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Monoid.$fReadFirst8_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.357350505 UTC

[section ""cstring" . Data.Monoid.$fReadLast3_bytes" {
     Data.Monoid.$fReadLast3_bytes:
         I8[] [103,101,116,76,97,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.359336165 UTC

[section ""data" . Data.Monoid.$fReadLast2_closure" {
     Data.Monoid.$fReadLast2_closure:
         const Data.Monoid.$fReadLast2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadLast2_entry() //  [R1]
         { info_tbl: [(c6JHG,
                       label: Data.Monoid.$fReadLast2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JHG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JHH; else goto c6JHI;
       c6JHH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JHI: // global
           (_c6JHD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6JHD::I64 == 0) goto c6JHF; else goto c6JHE;
       c6JHF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6JHE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6JHD::I64;
           R2 = Data.Monoid.$fReadLast3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.363969404 UTC

[section ""data" . Data.Monoid.$fReadFirst5_closure" {
     Data.Monoid.$fReadFirst5_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.36583467 UTC

[section ""data" . Data.Monoid.$fReadFirst2_closure" {
     Data.Monoid.$fReadFirst2_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Monoid.$fReadFirst3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.369496897 UTC

[section ""data" . Data.Monoid.$fReadLast1_closure" {
     Data.Monoid.$fReadLast1_closure:
         const Data.Monoid.$fReadLast1_info;
         const 0;
 },
 ds_s6JqR_entry() //  [R1, R3]
         { info_tbl: [(c6JI2,
                       label: ds_s6JqR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JI2: // global
           R4 = R3;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = P64[R1 + 6];
           call GHC.Read.$fReadMaybe1_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6Jr3_entry() //  [R1]
         { info_tbl: [(c6JID,
                       label: sat_s6Jr3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JID: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6Jr6_entry() //  [R1, R2]
         { info_tbl: [(c6JIJ,
                       label: sat_s6Jr6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JIJ: // global
           _s6Jr1::P64 = R2;
           _s6Jr6::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6JIK; else goto c6JIL;
       c6JIL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6JIN; else goto c6JIM;
       c6JIN: // global
           HpAlloc = 24;
           goto c6JIK;
       c6JIK: // global
           R2 = _s6Jr1::P64;
           R1 = _s6Jr6::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6JIM: // global
           _s6JqV::P64 = P64[_s6Jr6::P64 + 7];
           I64[Hp - 16] = sat_s6Jr3_info;
           P64[Hp - 8] = _s6JqV::P64;
           P64[Hp] = _s6Jr1::P64;
           I64[Sp - 8] = block_c6JIG_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadFirst2_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6JIG() //  [R1]
         { info_tbl: [(c6JIG,
                       label: block_c6JIG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JIG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6JIQ; else goto c6JIP;
       c6JIQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6JIP: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6Jr7_entry() //  [R1, R2]
         { info_tbl: [(c6JIR,
                       label: sat_s6Jr7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JIR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6JIV; else goto c6JIU;
       c6JIV: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6JIU: // global
           _s6JqR::P64 = P64[R1 + 7];
           _s6JqV::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6Jr6_info;
           P64[Hp] = _s6JqV::P64;
           R5 = Hp - 7;
           R4 = Data.Monoid.$fReadFirst5_closure+1;
           R3 = _s6JqR::P64;
           R2 = Data.Monoid.$fReadLast2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6Jra_entry() //  [R1, R2]
         { info_tbl: [(c6JIZ,
                       label: sat_s6Jra_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JIZ: // global
           _s6JqZ::P64 = R2;
           _s6Jra::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6JJ0; else goto c6JJ1;
       c6JJ1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6JJ3; else goto c6JJ2;
       c6JJ3: // global
           HpAlloc = 24;
           goto c6JJ0;
       c6JJ0: // global
           R2 = _s6JqZ::P64;
           R1 = _s6Jra::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6JJ2: // global
           _s6JqR::P64 = P64[_s6Jra::P64 + 7];
           _s6JqV::P64 = P64[_s6Jra::P64 + 15];
           I64[Hp - 16] = sat_s6Jr7_info;
           P64[Hp - 8] = _s6JqR::P64;
           P64[Hp] = _s6JqV::P64;
           I64[Sp - 8] = block_c6JIW_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadFirst_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6JIW() //  [R1]
         { info_tbl: [(c6JIW,
                       label: block_c6JIW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JIW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6JJ6; else goto c6JJ5;
       c6JJ6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6JJ5: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6Jrd_entry() //  [R1, R2, R3]
         { info_tbl: [(c6JJ7,
                       label: sat_s6Jrd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JJ7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6JJ8; else goto c6JJ9;
       c6JJ8: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6JJ9: // global
           I64[Sp - 24] = block_c6JIa_info;
           _s6JqR::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6JqR::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6JJm; else goto c6JIb;
       u6JJm: // global
           call _c6JIa(R1) args: 0, res: 0, upd: 0;
       c6JIb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6JIa() //  [R1]
         { info_tbl: [(c6JIa,
                       label: block_c6JIa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JIa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6JJc; else goto c6JJb;
       c6JJc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6JJb: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6JJe; else goto c6JJi;
       c6JJe: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6JJi: // global
           I64[Hp - 16] = sat_s6Jra_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6JJf_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadLast_lexeme_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6JJf() //  [R1]
         { info_tbl: [(c6JJf,
                       label: block_c6JJf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JJf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6JJl; else goto c6JJk;
       c6JJl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6JJk: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadLast1_entry() //  [R2, R3, R4]
         { info_tbl: [(c6JJn,
                       label: Data.Monoid.$fReadLast1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JJn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JJr; else goto c6JJq;
       c6JJr: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fReadLast1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6JJq: // global
           I64[Hp - 24] = ds_s6JqR_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6Jrd_info;
           P64[Hp] = Hp - 22;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.401821513 UTC

[section ""data" . Data.Monoid.$fReadLast_$creadsPrec_closure" {
     Data.Monoid.$fReadLast_$creadsPrec_closure:
         const Data.Monoid.$fReadLast_$creadsPrec_info;
         const 0;
 },
 sat_s6Jrg_entry() //  [R1]
         { info_tbl: [(c6JKx,
                       label: sat_s6Jrg_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JKx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JKy; else goto c6JKz;
       c6JKy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JKz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadLast1_entry(R4,
                                              R3,
                                              R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fReadLast_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c6JKA,
                       label: Data.Monoid.$fReadLast_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JKA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JKE; else goto c6JKD;
       c6JKE: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fReadLast_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6JKD: // global
           I64[Hp - 24] = sat_s6Jrg_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.408652729 UTC

[section ""data" . Data.Monoid.$fReadLast_$creadListPrec_closure" {
     Data.Monoid.$fReadLast_$creadListPrec_closure:
         const Data.Monoid.$fReadLast_$creadListPrec_info;
         const 0;
 },
 sat_s6Jri_entry() //  [R1, R2, R3]
         { info_tbl: [(c6JL0,
                       label: sat_s6Jri_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JL0: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadLast1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadLast_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6JL3,
                       label: Data.Monoid.$fReadLast_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JL3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6JL7; else goto c6JL6;
       c6JL7: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Monoid.$fReadLast_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6JL6: // global
           I64[Hp - 8] = sat_s6Jri_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.415098848 UTC

[section ""data" . Data.Monoid.$fReadLast_$creadList_closure" {
     Data.Monoid.$fReadLast_$creadList_closure:
         const Data.Monoid.$fReadLast_$creadList_info;
         const 0;
 },
 sat_s6Jrk_entry() //  [R1, R2, R3]
         { info_tbl: [(c6JLt,
                       label: sat_s6Jrk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JLt: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadLast1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6Jrl_entry() //  [R1]
         { info_tbl: [(c6JLw,
                       label: sat_s6Jrl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JLw: // global
           _s6Jrl::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6JLx; else goto c6JLy;
       c6JLy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6JLA; else goto c6JLz;
       c6JLA: // global
           HpAlloc = 16;
           goto c6JLx;
       c6JLx: // global
           R1 = _s6Jrl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JLz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6Jrl::P64;
           _s6Jrj::P64 = P64[_s6Jrl::P64 + 16];
           I64[Hp - 8] = sat_s6Jrk_info;
           P64[Hp] = _s6Jrj::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fReadLast_$creadList_entry() //  [R2]
         { info_tbl: [(c6JLB,
                       label: Data.Monoid.$fReadLast_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JLB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6JLF; else goto c6JLE;
       c6JLF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Monoid.$fReadLast_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6JLE: // global
           I64[Hp - 16] = sat_s6Jrl_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.424156326 UTC

[section ""data" . Data.Monoid.$fReadLast_closure" {
     Data.Monoid.$fReadLast_closure:
         const Data.Monoid.$fReadLast_info;
         const 0;
 },
 sat_s6Jrq_entry() //  [R1]
         { info_tbl: [(c6JM7,
                       label: sat_s6Jrq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JM7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JM8; else goto c6JM9;
       c6JM8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JM9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadLast_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6Jrp_entry() //  [R1, R2, R3]
         { info_tbl: [(c6JMf,
                       label: sat_s6Jrp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JMf: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadLast1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6Jro_entry() //  [R1]
         { info_tbl: [(c6JMm,
                       label: sat_s6Jro_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JMm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JMn; else goto c6JMo;
       c6JMn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JMo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadLast_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6Jrn_entry() //  [R1, R2]
         { info_tbl: [(c6JMu,
                       label: sat_s6Jrn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JMu: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Monoid.$fReadLast_$creadsPrec_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadLast_entry() //  [R2]
         { info_tbl: [(c6JMy,
                       label: Data.Monoid.$fReadLast_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JMy: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c6JMC; else goto c6JMB;
       c6JMC: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Monoid.$fReadLast_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6JMB: // global
           I64[Hp - 112] = sat_s6Jrq_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6Jrp_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s6Jro_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s6Jrn_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 112;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.436491898 UTC

[section ""data" . Data.Monoid.$fEqLast_closure" {
     Data.Monoid.$fEqLast_closure:
         const Data.Monoid.$fEqLast_info;
 },
 sat_s6Jrt_entry() //  [R1, R2, R3]
         { info_tbl: [(c6JNg,
                       label: sat_s6Jrt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JNg: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c/=_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6Jrs_entry() //  [R1, R2, R3]
         { info_tbl: [(c6JNo,
                       label: sat_s6Jrs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JNo: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fEqLast_entry() //  [R2]
         { info_tbl: [(c6JNs,
                       label: Data.Monoid.$fEqLast_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JNs: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6JNw; else goto c6JNv;
       c6JNw: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Monoid.$fEqLast_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6JNv: // global
           I64[Hp - 48] = sat_s6Jrt_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s6Jrs_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.444555823 UTC

[section ""data" . Data.Monoid.$fOrdLast_$cp1Ord_closure" {
     Data.Monoid.$fOrdLast_$cp1Ord_closure:
         const Data.Monoid.$fOrdLast_$cp1Ord_info;
 },
 sat_s6Jrv_entry() //  [R1]
         { info_tbl: [(c6JNV,
                       label: sat_s6Jrv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JNV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JNW; else goto c6JNX;
       c6JNW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JNX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fOrdLast_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6JNY,
                       label: Data.Monoid.$fOrdLast_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JNY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6JO2; else goto c6JO1;
       c6JO2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Monoid.$fOrdLast_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6JO1: // global
           I64[Hp - 16] = sat_s6Jrv_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Monoid.$fEqLast_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.45111228 UTC

[section ""data" . Data.Monoid.$fOrdLast_closure" {
     Data.Monoid.$fOrdLast_closure:
         const Data.Monoid.$fOrdLast_info;
 },
 sat_s6JrG_entry() //  [R1, R2, R3]
         { info_tbl: [(c6JOm,
                       label: sat_s6JrG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JOm: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmin_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6JrF_entry() //  [R1, R2, R3]
         { info_tbl: [(c6JOu,
                       label: sat_s6JrF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JOu: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmax_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6JrE_entry() //  [R1, R2, R3]
         { info_tbl: [(c6JOC,
                       label: sat_s6JrE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JOC: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c>=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6JrD_entry() //  [R1, R2, R3]
         { info_tbl: [(c6JOK,
                       label: sat_s6JrD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JOK: // global
           R4 = R2;
           R3 = R3;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6JrA_entry() //  [R1, R2, R3]
         { info_tbl: [(c6JOS,
                       label: sat_s6JrA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JOS: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6Jrz_entry() //  [R1, R2, R3]
         { info_tbl: [(c6JP0,
                       label: sat_s6Jrz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JP0: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6Jry_entry() //  [R1, R2, R3]
         { info_tbl: [(c6JP8,
                       label: sat_s6Jry_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JP8: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6Jrx_entry() //  [R1]
         { info_tbl: [(c6JPf,
                       label: sat_s6Jrx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JPf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JPg; else goto c6JPh;
       c6JPg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JPh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fOrdLast_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fOrdLast_entry() //  [R2]
         { info_tbl: [(c6JPj,
                       label: Data.Monoid.$fOrdLast_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JPj: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto c6JPn; else goto c6JPm;
       c6JPn: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = Data.Monoid.$fOrdLast_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6JPm: // global
           I64[Hp - 200] = sat_s6JrG_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6JrF_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s6JrE_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s6JrD_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6JrA_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s6Jrz_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6Jry_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6Jrx_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.467435406 UTC

[section ""data" . Data.Monoid.$fFunctorFirst_closure" {
     Data.Monoid.$fFunctorFirst_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fApplicativeMaybe_$cfmap_closure+2;
         const GHC.Base.$fFunctorMaybe_$c<$_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.469671594 UTC

[section ""data" . Data.Monoid.$fApplicativeFirst_closure" {
     Data.Monoid.$fApplicativeFirst_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Monoid.$fFunctorFirst_closure+1;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fApplicativeMaybe_$c<*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$cliftA2_closure+3;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c<*_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.471857189 UTC

[section ""data" . Data.Monoid.$fMonadFirst_closure" {
     Data.Monoid.$fMonadFirst_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Monoid.$fApplicativeFirst_closure+1;
         const GHC.Base.$fMonadMaybe_$c>>=_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fMonadMaybe_$cfail_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.474262675 UTC

[section ""data" . Data.Monoid.$fGeneric1First1_closure" {
     Data.Monoid.$fGeneric1First1_closure:
         const Data.Monoid.$fGeneric1First1_info;
 },
 Data.Monoid.$fGeneric1First1_entry() //  [R2]
         { info_tbl: [(c6JQh,
                       label: Data.Monoid.$fGeneric1First1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JQh: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.477828684 UTC

[section ""data" . Data.Monoid.$fGeneric1First2_closure" {
     Data.Monoid.$fGeneric1First2_closure:
         const Data.Monoid.$fGeneric1First2_info;
 },
 Data.Monoid.$fGeneric1First2_entry() //  [R2]
         { info_tbl: [(c6JQs,
                       label: Data.Monoid.$fGeneric1First2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JQs: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.48117036 UTC

[section ""data" . Data.Monoid.$fGeneric1First_closure" {
     Data.Monoid.$fGeneric1First_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Monoid.$fGeneric1First2_closure+1;
         const Data.Monoid.$fGeneric1First1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.483309492 UTC

[section ""data" . Data.Monoid.$fGenericFirst1_closure" {
     Data.Monoid.$fGenericFirst1_closure:
         const Data.Monoid.$fGenericFirst1_info;
 },
 Data.Monoid.$fGenericFirst1_entry() //  [R2]
         { info_tbl: [(c6JQG,
                       label: Data.Monoid.$fGenericFirst1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JQG: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.48687776 UTC

[section ""data" . Data.Monoid.$fGenericFirst2_closure" {
     Data.Monoid.$fGenericFirst2_closure:
         const Data.Monoid.$fGenericFirst2_info;
 },
 Data.Monoid.$fGenericFirst2_entry() //  [R2]
         { info_tbl: [(c6JQR,
                       label: Data.Monoid.$fGenericFirst2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JQR: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.490241454 UTC

[section ""data" . Data.Monoid.$fGenericFirst_closure" {
     Data.Monoid.$fGenericFirst_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Monoid.$fGenericFirst2_closure+1;
         const Data.Monoid.$fGenericFirst1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.492078519 UTC

[section ""cstring" . Data.Monoid.$fShowFirst3_bytes" {
     Data.Monoid.$fShowFirst3_bytes:
         I8[] [70,105,114,115,116,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.493919958 UTC

[section ""cstring" . Data.Monoid.$fShowFirst2_bytes" {
     Data.Monoid.$fShowFirst2_bytes:
         I8[] [103,101,116,70,105,114,115,116,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.49763549 UTC

[section ""data" . Data.Monoid.$w$cshowsPrec_closure" {
     Data.Monoid.$w$cshowsPrec_closure:
         const Data.Monoid.$w$cshowsPrec_info;
         const 0;
 },
 f_s6JrO_entry() //  [R1]
         { info_tbl: [(c6JRb,
                       label: f_s6JrO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JRb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JRc; else goto c6JRd;
       c6JRc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JRd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 24];
           R3 = Data.Monoid.$fShowFirst1_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Show.$fShowMaybe_$cshowsPrec_entry(R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6JrR_entry() //  [R1]
         { info_tbl: [(c6JRy,
                       label: sat_s6JrR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JRy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JRz; else goto c6JRA;
       c6JRz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JRA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Monoid.$fReadFirst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6JrS_entry() //  [R1]
         { info_tbl: [(c6JRB,
                       label: sat_s6JrS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JRB: // global
           _s6JrS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6JRC; else goto c6JRD;
       c6JRD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6JRF; else goto c6JRE;
       c6JRF: // global
           HpAlloc = 24;
           goto c6JRC;
       c6JRC: // global
           R1 = _s6JrS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JRE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6JrS::P64;
           _s6JrO::P64 = P64[_s6JrS::P64 + 16];
           _s6JrQ::P64 = P64[_s6JrS::P64 + 24];
           I64[Hp - 16] = sat_s6JrR_info;
           P64[Hp] = _s6JrQ::P64;
           R2 = Hp - 16;
           R1 = _s6JrO::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6JrT_entry() //  [R1]
         { info_tbl: [(c6JRG,
                       label: sat_s6JrT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JRG: // global
           _s6JrT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6JRH; else goto c6JRI;
       c6JRI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JRK; else goto c6JRJ;
       c6JRK: // global
           HpAlloc = 32;
           goto c6JRH;
       c6JRH: // global
           R1 = _s6JrT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JRJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6JrT::P64;
           _s6JrO::P64 = P64[_s6JrT::P64 + 16];
           _s6JrQ::P64 = P64[_s6JrT::P64 + 24];
           I64[Hp - 24] = sat_s6JrS_info;
           P64[Hp - 8] = _s6JrO::P64;
           P64[Hp] = _s6JrQ::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6JrU_entry() //  [R1, R2]
         { info_tbl: [(c6JRL,
                       label: sat_s6JrU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JRL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JRP; else goto c6JRO;
       c6JRP: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6JRO: // global
           _s6JrO::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6JrT_info;
           P64[Hp - 8] = _s6JrO::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6JrX_entry() //  [R1]
         { info_tbl: [(c6JSd,
                       label: sat_s6JrX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JSd: // global
           _s6JrX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6JSe; else goto c6JSf;
       c6JSf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6JSh; else goto c6JSg;
       c6JSh: // global
           HpAlloc = 24;
           goto c6JSe;
       c6JSe: // global
           R1 = _s6JrX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JSg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6JrX::P64;
           _s6JrV::P64 = P64[_s6JrX::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6JrV::P64;
           R3 = Hp - 14;
           R2 = Data.Monoid.$fReadFirst4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6JrY_entry() //  [R1]
         { info_tbl: [(c6JSi,
                       label: sat_s6JrY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JSi: // global
           _s6JrY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6JSj; else goto c6JSk;
       c6JSk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6JSm; else goto c6JSl;
       c6JSm: // global
           HpAlloc = 24;
           goto c6JSj;
       c6JSj: // global
           R1 = _s6JrY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JSl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6JrY::P64;
           _s6JrO::P64 = P64[_s6JrY::P64 + 16];
           _s6JrV::P64 = P64[_s6JrY::P64 + 24];
           I64[Hp - 16] = sat_s6JrX_info;
           P64[Hp] = _s6JrV::P64;
           R2 = Hp - 16;
           R1 = _s6JrO::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6JrZ_entry() //  [R1]
         { info_tbl: [(c6JSn,
                       label: sat_s6JrZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JSn: // global
           _s6JrZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6JSo; else goto c6JSp;
       c6JSp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JSr; else goto c6JSq;
       c6JSr: // global
           HpAlloc = 32;
           goto c6JSo;
       c6JSo: // global
           R1 = _s6JrZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JSq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6JrZ::P64;
           _s6JrO::P64 = P64[_s6JrZ::P64 + 16];
           _s6JrV::P64 = P64[_s6JrZ::P64 + 24];
           I64[Hp - 24] = sat_s6JrY_info;
           P64[Hp - 8] = _s6JrO::P64;
           P64[Hp] = _s6JrV::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6Js0_entry() //  [R1]
         { info_tbl: [(c6JSs,
                       label: sat_s6Js0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JSs: // global
           _s6Js0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6JSt; else goto c6JSu;
       c6JSu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JSw; else goto c6JSv;
       c6JSw: // global
           HpAlloc = 32;
           goto c6JSt;
       c6JSt: // global
           R1 = _s6Js0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JSv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6Js0::P64;
           _s6JrO::P64 = P64[_s6Js0::P64 + 16];
           _s6JrV::P64 = P64[_s6Js0::P64 + 24];
           I64[Hp - 24] = sat_s6JrZ_info;
           P64[Hp - 8] = _s6JrO::P64;
           P64[Hp] = _s6JrV::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6Js1_entry() //  [R1, R2]
         { info_tbl: [(c6JSy,
                       label: sat_s6Js1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JSy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6JSC; else goto c6JSB;
       c6JSC: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6JSB: // global
           _s6JrO::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6Js0_info;
           P64[Hp - 32] = _s6JrO::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c6JSG,
                       label: Data.Monoid.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JSG: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6JSK; else goto c6JSJ;
       c6JSK: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6JSJ: // global
           I64[Hp - 40] = f_s6JrO_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6JR7::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6JSE; else goto c6JSF;
       c6JSE: // global
           I64[Hp - 8] = sat_s6JrU_info;
           P64[Hp] = _c6JR7::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6JSF: // global
           I64[Hp - 8] = sat_s6Js1_info;
           P64[Hp] = _c6JR7::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.524769035 UTC

[section ""data" . Data.Monoid.$fShowFirst_$cshowsPrec_closure" {
     Data.Monoid.$fShowFirst_$cshowsPrec_closure:
         const Data.Monoid.$fShowFirst_$cshowsPrec_info;
         const 0;
 },
 Data.Monoid.$fShowFirst_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c6JTY,
                       label: Data.Monoid.$fShowFirst_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JTY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6JTZ; else goto c6JU0;
       c6JTZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowFirst_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6JU0: // global
           I64[Sp - 24] = block_c6JTV_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6JU4; else goto c6JTW;
       u6JU4: // global
           call _c6JTV(R1) args: 0, res: 0, upd: 0;
       c6JTW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6JTV() //  [R1]
         { info_tbl: [(c6JTV,
                       label: block_c6JTV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JTV: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Monoid.$w$cshowsPrec_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.531694666 UTC

[section ""data" . Data.Monoid.$fShowFirst_$cshow_closure" {
     Data.Monoid.$fShowFirst_$cshow_closure:
         const Data.Monoid.$fShowFirst_$cshow_info;
         const 0;
 },
 sat_s6Jsb_entry() //  [R1]
         { info_tbl: [(c6JUB,
                       label: sat_s6Jsb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JUB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6JUC; else goto c6JUD;
       c6JUC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JUD: // global
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = GHC.Show.appPrec1_closure;
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = Data.Monoid.$fReadFirst3_closure;
           Sp = Sp - 32;
           call GHC.Show.showsPrec_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_s6Jsc_entry() //  [R1]
         { info_tbl: [(c6JUI,
                       label: sat_s6Jsc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JUI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6JUJ; else goto c6JUK;
       c6JUJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JUK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6JUr_info;
           _s6Js7::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s6Js7::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6JUQ; else goto c6JUs;
       u6JUQ: // global
           call _c6JUr(R1) args: 0, res: 0, upd: 0;
       c6JUs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6JUr() //  [R1]
         { info_tbl: [(c6JUr,
                       label: block_c6JUr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JUr: // global
           if (R1 & 7 == 1) goto c6JUF; else goto c6JUG;
       c6JUF: // global
           R1 = Data.Monoid.$fShowFirst4_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c6JUG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JUP; else goto c6JUO;
       c6JUP: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6JUO: // global
           _s6Jsa::P64 = P64[R1 + 6];
           I64[Hp - 24] = sat_s6Jsb_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _s6Jsa::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.$fShowMaybe1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6Jsd_entry() //  [R1]
         { info_tbl: [(c6JUR,
                       label: sat_s6Jsd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JUR: // global
           _s6Jsd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6JUS; else goto c6JUT;
       c6JUT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JUV; else goto c6JUU;
       c6JUV: // global
           HpAlloc = 32;
           goto c6JUS;
       c6JUS: // global
           R1 = _s6Jsd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JUU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6Jsd::P64;
           _s6Js7::P64 = P64[_s6Jsd::P64 + 16];
           _s6Js8::P64 = P64[_s6Jsd::P64 + 24];
           I64[Hp - 24] = sat_s6Jsc_info;
           P64[Hp - 8] = _s6Js7::P64;
           P64[Hp] = _s6Js8::P64;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fShowFirst_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6JUW,
                       label: Data.Monoid.$fShowFirst_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JUW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JV0; else goto c6JUZ;
       c6JV0: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowFirst_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6JUZ: // global
           I64[Hp - 24] = sat_s6Jsd_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Monoid.$fShowFirst3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.54603355 UTC

[section ""data" . Data.Monoid.$fShowFirst_$cshowList_closure" {
     Data.Monoid.$fShowFirst_$cshowList_closure:
         const Data.Monoid.$fShowFirst_$cshowList_info;
         const 0;
 },
 sat_s6Jsi_entry() //  [R1, R2]
         { info_tbl: [(c6JVI,
                       label: sat_s6Jsi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JVI: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Monoid.$w$cshowsPrec_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fShowFirst_$cshowList_entry() //  [R2, R3, R4]
         { info_tbl: [(c6JVL,
                       label: Data.Monoid.$fShowFirst_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JVL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6JVP; else goto c6JVO;
       c6JVP: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fShowFirst_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6JVO: // global
           I64[Hp - 8] = sat_s6Jsi_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.553049357 UTC

[section ""data" . Data.Monoid.$fShowFirst_closure" {
     Data.Monoid.$fShowFirst_closure:
         const Data.Monoid.$fShowFirst_info;
         const 0;
 },
 sat_s6Jsm_entry() //  [R1, R2, R3]
         { info_tbl: [(c6JW7,
                       label: sat_s6Jsm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JW7: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fShowFirst_$cshowList_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6Jsl_entry() //  [R1, R2]
         { info_tbl: [(c6JWf,
                       label: sat_s6Jsl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JWf: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Monoid.$fShowFirst_$cshow_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6Jsk_entry() //  [R1, R2, R3]
         { info_tbl: [(c6JWn,
                       label: sat_s6Jsk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JWn: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fShowFirst_$cshowsPrec_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fShowFirst_entry() //  [R2]
         { info_tbl: [(c6JWr,
                       label: Data.Monoid.$fShowFirst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JWr: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6JWv; else goto c6JWu;
       c6JWv: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Monoid.$fShowFirst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6JWu: // global
           I64[Hp - 72] = sat_s6Jsm_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6Jsl_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6Jsk_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.562626246 UTC

[section ""cstring" . Data.Monoid.$fReadFirst11_bytes" {
     Data.Monoid.$fReadFirst11_bytes:
         I8[] [70,105,114,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.564722505 UTC

[section ""data" . Data.Monoid.$fReadFirst10_closure" {
     Data.Monoid.$fReadFirst10_closure:
         const Data.Monoid.$fReadFirst10_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadFirst10_entry() //  [R1]
         { info_tbl: [(c6JWY,
                       label: Data.Monoid.$fReadFirst10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JWY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JWZ; else goto c6JX0;
       c6JWZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JX0: // global
           (_c6JWV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6JWV::I64 == 0) goto c6JWX; else goto c6JWW;
       c6JWX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6JWW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6JWV::I64;
           R2 = Data.Monoid.$fReadFirst11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.5689164 UTC

[section ""data" . Data.Monoid.$fReadFirst_lexeme1_closure" {
     Data.Monoid.$fReadFirst_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Monoid.$fReadFirst10_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.570831325 UTC

[section ""cstring" . Data.Monoid.$fReadFirst7_bytes" {
     Data.Monoid.$fReadFirst7_bytes:
         I8[] [103,101,116,70,105,114,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.57268545 UTC

[section ""data" . Data.Monoid.$fReadFirst6_closure" {
     Data.Monoid.$fReadFirst6_closure:
         const Data.Monoid.$fReadFirst6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Monoid.$fReadFirst6_entry() //  [R1]
         { info_tbl: [(c6JXh,
                       label: Data.Monoid.$fReadFirst6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JXh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6JXi; else goto c6JXj;
       c6JXi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6JXj: // global
           (_c6JXe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6JXe::I64 == 0) goto c6JXg; else goto c6JXf;
       c6JXg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6JXf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6JXe::I64;
           R2 = Data.Monoid.$fReadFirst7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.578310141 UTC

[section ""data" . Data.Monoid.$fReadFirst1_closure" {
     Data.Monoid.$fReadFirst1_closure:
         const Data.Monoid.$fReadFirst1_info;
         const 0;
 },
 ds_s6Jsq_entry() //  [R1, R3]
         { info_tbl: [(c6JXB,
                       label: ds_s6Jsq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JXB: // global
           R4 = R3;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = P64[R1 + 6];
           call GHC.Read.$fReadMaybe1_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6JsC_entry() //  [R1]
         { info_tbl: [(c6JYc,
                       label: sat_s6JsC_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JYc: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6JsF_entry() //  [R1, R2]
         { info_tbl: [(c6JYi,
                       label: sat_s6JsF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JYi: // global
           _s6JsA::P64 = R2;
           _s6JsF::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6JYj; else goto c6JYk;
       c6JYk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6JYm; else goto c6JYl;
       c6JYm: // global
           HpAlloc = 24;
           goto c6JYj;
       c6JYj: // global
           R2 = _s6JsA::P64;
           R1 = _s6JsF::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6JYl: // global
           _s6Jsu::P64 = P64[_s6JsF::P64 + 7];
           I64[Hp - 16] = sat_s6JsC_info;
           P64[Hp - 8] = _s6Jsu::P64;
           P64[Hp] = _s6JsA::P64;
           I64[Sp - 8] = block_c6JYf_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadFirst2_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6JYf() //  [R1]
         { info_tbl: [(c6JYf,
                       label: block_c6JYf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JYf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6JYp; else goto c6JYo;
       c6JYp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6JYo: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6JsG_entry() //  [R1, R2]
         { info_tbl: [(c6JYq,
                       label: sat_s6JsG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JYq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6JYu; else goto c6JYt;
       c6JYu: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6JYt: // global
           _s6Jsq::P64 = P64[R1 + 7];
           _s6Jsu::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6JsF_info;
           P64[Hp] = _s6Jsu::P64;
           R5 = Hp - 7;
           R4 = Data.Monoid.$fReadFirst5_closure+1;
           R3 = _s6Jsq::P64;
           R2 = Data.Monoid.$fReadFirst6_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6JsJ_entry() //  [R1, R2]
         { info_tbl: [(c6JYy,
                       label: sat_s6JsJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JYy: // global
           _s6Jsy::P64 = R2;
           _s6JsJ::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6JYz; else goto c6JYA;
       c6JYA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6JYC; else goto c6JYB;
       c6JYC: // global
           HpAlloc = 24;
           goto c6JYz;
       c6JYz: // global
           R2 = _s6Jsy::P64;
           R1 = _s6JsJ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6JYB: // global
           _s6Jsq::P64 = P64[_s6JsJ::P64 + 7];
           _s6Jsu::P64 = P64[_s6JsJ::P64 + 15];
           I64[Hp - 16] = sat_s6JsG_info;
           P64[Hp - 8] = _s6Jsq::P64;
           P64[Hp] = _s6Jsu::P64;
           I64[Sp - 8] = block_c6JYv_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadFirst_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6JYv() //  [R1]
         { info_tbl: [(c6JYv,
                       label: block_c6JYv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JYv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6JYF; else goto c6JYE;
       c6JYF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6JYE: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6JsM_entry() //  [R1, R2, R3]
         { info_tbl: [(c6JYG,
                       label: sat_s6JsM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JYG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6JYH; else goto c6JYI;
       c6JYH: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6JYI: // global
           I64[Sp - 24] = block_c6JXJ_info;
           _s6Jsq::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6Jsq::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6JYV; else goto c6JXK;
       u6JYV: // global
           call _c6JXJ(R1) args: 0, res: 0, upd: 0;
       c6JXK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6JXJ() //  [R1]
         { info_tbl: [(c6JXJ,
                       label: block_c6JXJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JXJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6JYL; else goto c6JYK;
       c6JYL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6JYK: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6JYN; else goto c6JYR;
       c6JYN: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6JYR: // global
           I64[Hp - 16] = sat_s6JsJ_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6JYO_info;
           R3 = Hp - 15;
           R2 = Data.Monoid.$fReadFirst_lexeme1_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6JYO() //  [R1]
         { info_tbl: [(c6JYO,
                       label: block_c6JYO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JYO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6JYU; else goto c6JYT;
       c6JYU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6JYT: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadFirst1_entry() //  [R2, R3, R4]
         { info_tbl: [(c6JYW,
                       label: Data.Monoid.$fReadFirst1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6JYW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6JZ0; else goto c6JYZ;
       c6JZ0: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fReadFirst1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6JYZ: // global
           I64[Hp - 24] = ds_s6Jsq_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6JsM_info;
           P64[Hp] = Hp - 22;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 6;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.602531502 UTC

[section ""data" . Data.Monoid.$fReadFirst_$creadsPrec_closure" {
     Data.Monoid.$fReadFirst_$creadsPrec_closure:
         const Data.Monoid.$fReadFirst_$creadsPrec_info;
         const 0;
 },
 sat_s6JsP_entry() //  [R1]
         { info_tbl: [(c6K06,
                       label: sat_s6JsP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K06: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6K07; else goto c6K08;
       c6K07: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6K08: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadFirst1_entry(R4,
                                               R3,
                                               R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fReadFirst_$creadsPrec_entry() //  [R2, R3]
         { info_tbl: [(c6K09,
                       label: Data.Monoid.$fReadFirst_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K09: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6K0d; else goto c6K0c;
       c6K0d: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Monoid.$fReadFirst_$creadsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6K0c: // global
           I64[Hp - 24] = sat_s6JsP_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.60871267 UTC

[section ""data" . Data.Monoid.$fReadFirst_$creadListPrec_closure" {
     Data.Monoid.$fReadFirst_$creadListPrec_closure:
         const Data.Monoid.$fReadFirst_$creadListPrec_info;
         const 0;
 },
 sat_s6JsR_entry() //  [R1, R2, R3]
         { info_tbl: [(c6K0z,
                       label: sat_s6JsR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K0z: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadFirst1_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadFirst_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6K0C,
                       label: Data.Monoid.$fReadFirst_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K0C: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6K0G; else goto c6K0F;
       c6K0G: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = Data.Monoid.$fReadFirst_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6K0F: // global
           I64[Hp - 8] = sat_s6JsR_info;
           P64[Hp] = R2;
           R2 = Hp - 6;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.614330199 UTC

[section ""data" . Data.Monoid.$fReadFirst_$creadList_closure" {
     Data.Monoid.$fReadFirst_$creadList_closure:
         const Data.Monoid.$fReadFirst_$creadList_info;
         const 0;
 },
 sat_s6JsT_entry() //  [R1, R2, R3]
         { info_tbl: [(c6K12,
                       label: sat_s6JsT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K12: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadFirst1_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6JsU_entry() //  [R1]
         { info_tbl: [(c6K15,
                       label: sat_s6JsU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K15: // global
           _s6JsU::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6K16; else goto c6K17;
       c6K17: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6K19; else goto c6K18;
       c6K19: // global
           HpAlloc = 16;
           goto c6K16;
       c6K16: // global
           R1 = _s6JsU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6K18: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6JsU::P64;
           _s6JsS::P64 = P64[_s6JsU::P64 + 16];
           I64[Hp - 8] = sat_s6JsT_info;
           P64[Hp] = _s6JsS::P64;
           R2 = Hp - 6;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fReadFirst_$creadList_entry() //  [R2]
         { info_tbl: [(c6K1a,
                       label: Data.Monoid.$fReadFirst_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K1a: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6K1e; else goto c6K1d;
       c6K1e: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Monoid.$fReadFirst_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6K1d: // global
           I64[Hp - 16] = sat_s6JsU_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.622644743 UTC

[section ""data" . Data.Monoid.$fReadFirst_closure" {
     Data.Monoid.$fReadFirst_closure:
         const Data.Monoid.$fReadFirst_info;
         const 0;
 },
 sat_s6JsZ_entry() //  [R1]
         { info_tbl: [(c6K1G,
                       label: sat_s6JsZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K1G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6K1H; else goto c6K1I;
       c6K1H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6K1I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadFirst_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6JsY_entry() //  [R1, R2, R3]
         { info_tbl: [(c6K1O,
                       label: sat_s6JsY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K1O: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Monoid.$fReadFirst1_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6JsX_entry() //  [R1]
         { info_tbl: [(c6K1V,
                       label: sat_s6JsX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K1V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6K1W; else goto c6K1X;
       c6K1W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6K1X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fReadFirst_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6JsW_entry() //  [R1, R2]
         { info_tbl: [(c6K23,
                       label: sat_s6JsW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K23: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Monoid.$fReadFirst_$creadsPrec_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fReadFirst_entry() //  [R2]
         { info_tbl: [(c6K27,
                       label: Data.Monoid.$fReadFirst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K27: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c6K2b; else goto c6K2a;
       c6K2b: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Monoid.$fReadFirst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6K2a: // global
           I64[Hp - 112] = sat_s6JsZ_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6JsY_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s6JsX_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s6JsW_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 86;
           P64[Hp] = Hp - 112;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.634977136 UTC

[section ""data" . Data.Monoid.$fEqFirst_closure" {
     Data.Monoid.$fEqFirst_closure:
         const Data.Monoid.$fEqFirst_info;
 },
 sat_s6Jt2_entry() //  [R1, R2, R3]
         { info_tbl: [(c6K2P,
                       label: sat_s6Jt2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K2P: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c/=_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6Jt1_entry() //  [R1, R2, R3]
         { info_tbl: [(c6K2X,
                       label: sat_s6Jt1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K2X: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Monoid.$fEqFirst_entry() //  [R2]
         { info_tbl: [(c6K31,
                       label: Data.Monoid.$fEqFirst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K31: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6K35; else goto c6K34;
       c6K35: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Monoid.$fEqFirst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6K34: // global
           I64[Hp - 48] = sat_s6Jt2_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s6Jt1_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.642423803 UTC

[section ""data" . Data.Monoid.$fOrdFirst_$cp1Ord_closure" {
     Data.Monoid.$fOrdFirst_$cp1Ord_closure:
         const Data.Monoid.$fOrdFirst_$cp1Ord_info;
 },
 sat_s6Jt4_entry() //  [R1]
         { info_tbl: [(c6K3u,
                       label: sat_s6Jt4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K3u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6K3v; else goto c6K3w;
       c6K3v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6K3w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fOrdFirst_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6K3x,
                       label: Data.Monoid.$fOrdFirst_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K3x: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6K3B; else goto c6K3A;
       c6K3B: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Monoid.$fOrdFirst_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6K3A: // global
           I64[Hp - 16] = sat_s6Jt4_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Monoid.$fEqFirst_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.648894627 UTC

[section ""data" . Data.Monoid.$fOrdFirst_closure" {
     Data.Monoid.$fOrdFirst_closure:
         const Data.Monoid.$fOrdFirst_info;
 },
 sat_s6Jtf_entry() //  [R1, R2, R3]
         { info_tbl: [(c6K3V,
                       label: sat_s6Jtf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K3V: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmin_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6Jte_entry() //  [R1, R2, R3]
         { info_tbl: [(c6K43,
                       label: sat_s6Jte_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K43: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmax_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6Jtd_entry() //  [R1, R2, R3]
         { info_tbl: [(c6K4b,
                       label: sat_s6Jtd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K4b: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c>=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6Jtc_entry() //  [R1, R2, R3]
         { info_tbl: [(c6K4j,
                       label: sat_s6Jtc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K4j: // global
           R4 = R2;
           R3 = R3;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6Jt9_entry() //  [R1, R2, R3]
         { info_tbl: [(c6K4r,
                       label: sat_s6Jt9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K4r: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6Jt8_entry() //  [R1, R2, R3]
         { info_tbl: [(c6K4z,
                       label: sat_s6Jt8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K4z: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6Jt7_entry() //  [R1, R2, R3]
         { info_tbl: [(c6K4H,
                       label: sat_s6Jt7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K4H: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6Jt6_entry() //  [R1]
         { info_tbl: [(c6K4O,
                       label: sat_s6Jt6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K4O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6K4P; else goto c6K4Q;
       c6K4P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6K4Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Monoid.$fOrdFirst_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Monoid.$fOrdFirst_entry() //  [R2]
         { info_tbl: [(c6K4S,
                       label: Data.Monoid.$fOrdFirst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K4S: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto c6K4W; else goto c6K4V;
       c6K4W: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = Data.Monoid.$fOrdFirst_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6K4V: // global
           I64[Hp - 200] = sat_s6Jtf_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6Jte_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s6Jtd_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s6Jtc_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6Jt9_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s6Jt8_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6Jt7_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6Jt6_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.666889387 UTC

[section ""data" . Data.Monoid.getFirst_closure" {
     Data.Monoid.getFirst_closure:
         const Data.Monoid.getFirst_info;
 },
 Data.Monoid.getFirst_entry() //  [R2]
         { info_tbl: [(c6K5N,
                       label: Data.Monoid.getFirst_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K5N: // global
           R2 = R2;
           call Data.Monoid.$fGeneric1First2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.670227801 UTC

[section ""data" . Data.Monoid.getLast_closure" {
     Data.Monoid.getLast_closure:
         const Data.Monoid.getLast_info;
 },
 Data.Monoid.getLast_entry() //  [R2]
         { info_tbl: [(c6K5Y,
                       label: Data.Monoid.getLast_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6K5Y: // global
           R2 = R2;
           call Data.Monoid.$fGeneric1Last2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.673214996 UTC

[section ""cstring" . Data.Monoid.$trModule4_bytes" {
     Data.Monoid.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.674843324 UTC

[section ""data" . Data.Monoid.$trModule3_closure" {
     Data.Monoid.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.676501161 UTC

[section ""cstring" . Data.Monoid.$trModule2_bytes" {
     Data.Monoid.$trModule2_bytes:
         I8[] [68,97,116,97,46,77,111,110,111,105,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.678501245 UTC

[section ""data" . Data.Monoid.$trModule1_closure" {
     Data.Monoid.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.679943477 UTC

[section ""data" . Data.Monoid.$trModule_closure" {
     Data.Monoid.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Monoid.$trModule3_closure+1;
         const Data.Monoid.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.681636266 UTC

[section ""data" . $krep_r6I1r_closure" {
     $krep_r6I1r_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.683319076 UTC

[section ""data" . $krep1_r6I1s_closure" {
     $krep1_r6I1s_closure:
         const :_con_info;
         const $krep_r6I1r_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.684989754 UTC

[section ""data" . $krep2_r6I1t_closure" {
     $krep2_r6I1t_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep1_r6I1s_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.686699885 UTC

[section ""data" . Data.Monoid.$tcFirst1_closure" {
     Data.Monoid.$tcFirst1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$fReadFirst11_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.688302067 UTC

[section ""data" . Data.Monoid.$tcFirst_closure" {
     Data.Monoid.$tcFirst_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Monoid.$trModule_closure+1;
         const Data.Monoid.$tcFirst1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 12072287807032806756;
         const 12788244796562536401;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.690753943 UTC

[section ""data" . $krep3_r6I1u_closure" {
     $krep3_r6I1u_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Monoid.$tcFirst_closure+1;
         const $krep1_r6I1s_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.692498279 UTC

[section ""data" . Data.Monoid.$tc'First1_closure" {
     Data.Monoid.$tc'First1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r6I1t_closure+1;
         const $krep3_r6I1u_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.694439779 UTC

[section ""cstring" . Data.Monoid.$tc'First3_bytes" {
     Data.Monoid.$tc'First3_bytes:
         I8[] [39,70,105,114,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.696130021 UTC

[section ""data" . Data.Monoid.$tc'First2_closure" {
     Data.Monoid.$tc'First2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$tc'First3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.697939686 UTC

[section ""data" . Data.Monoid.$tc'First_closure" {
     Data.Monoid.$tc'First_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Monoid.$trModule_closure+1;
         const Data.Monoid.$tc'First2_closure+1;
         const Data.Monoid.$tc'First1_closure+4;
         const 7752528083504400280;
         const 15965132804789246607;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.699819884 UTC

[section ""data" . Data.Monoid.$tcLast1_closure" {
     Data.Monoid.$tcLast1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$fReadLast5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.701575002 UTC

[section ""data" . Data.Monoid.$tcLast_closure" {
     Data.Monoid.$tcLast_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Monoid.$trModule_closure+1;
         const Data.Monoid.$tcLast1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 6920195955404695016;
         const 2388797855174213212;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.703554184 UTC

[section ""data" . $krep4_r6I1v_closure" {
     $krep4_r6I1v_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Monoid.$tcLast_closure+1;
         const $krep1_r6I1s_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.705514072 UTC

[section ""data" . Data.Monoid.$tc'Last1_closure" {
     Data.Monoid.$tc'Last1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r6I1t_closure+1;
         const $krep4_r6I1v_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.707271067 UTC

[section ""cstring" . Data.Monoid.$tc'Last3_bytes" {
     Data.Monoid.$tc'Last3_bytes:
         I8[] [39,76,97,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.70902574 UTC

[section ""data" . Data.Monoid.$tc'Last2_closure" {
     Data.Monoid.$tc'Last2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Monoid.$tc'Last3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.710848383 UTC

[section ""data" . Data.Monoid.$tc'Last_closure" {
     Data.Monoid.$tc'Last_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Monoid.$trModule_closure+1;
         const Data.Monoid.$tc'Last2_closure+1;
         const Data.Monoid.$tc'Last1_closure+4;
         const 5411164464353425083;
         const 12998161994081761510;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:59.712730938 UTC

[section ""relreadonly" . S6Jws_srt" {
     S6Jws_srt:
         const Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
         const Data.Monoid.$fMonoidFirst_closure;
         const Data.Monoid.$fMonoidLast_closure;
         const GHC.Show.$fShowMaybe_$cshowsPrec_closure;
         const Data.Monoid.$w$cshowsPrec1_closure;
         const Data.Monoid.$fShowLast_$cshowsPrec_closure;
         const GHC.Show.$fShowMaybe4_closure;
         const Data.Monoid.$fReadFirst3_closure;
         const GHC.Show.$fShowMaybe1_closure;
         const Data.Monoid.$fShowFirst4_closure;
         const Data.Monoid.$fShowLast_$cshow_closure;
         const Data.Monoid.$fShowLast_$cshowList_closure;
         const Data.Monoid.$fShowLast_closure;
         const GHC.Read.$fReadMaybe1_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Monoid.$fReadFirst2_closure;
         const GHC.Read.readField_closure;
         const Data.Monoid.$fReadLast2_closure;
         const Data.Monoid.$fReadFirst_lexeme_closure;
         const Data.Monoid.$fReadLast_lexeme_closure;
         const GHC.Read.list3_closure;
         const Data.Monoid.$fReadLast1_closure;
         const Data.Monoid.$fReadLast_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Monoid.$fReadLast_$creadListPrec_closure;
         const Data.Monoid.$fReadLast_$creadList_closure;
         const Data.Monoid.$fReadLast_closure;
         const Data.Monoid.$w$cshowsPrec_closure;
         const Data.Monoid.$fShowFirst_$cshowsPrec_closure;
         const Data.Monoid.$fShowFirst_$cshow_closure;
         const Data.Monoid.$fShowFirst_$cshowList_closure;
         const Data.Monoid.$fShowFirst_closure;
         const Data.Monoid.$fReadFirst6_closure;
         const Data.Monoid.$fReadFirst_lexeme1_closure;
         const Data.Monoid.$fReadFirst1_closure;
         const Data.Monoid.$fReadFirst_$creadsPrec_closure;
         const Data.Monoid.$fReadFirst_$creadListPrec_closure;
         const Data.Monoid.$fReadFirst_$creadList_closure;
         const Data.Monoid.$fReadFirst_closure;
 }]

