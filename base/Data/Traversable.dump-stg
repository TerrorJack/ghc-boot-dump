
==================== Pre unarise: ====================
2018-03-16 16:06:49.735904789 UTC

Data.Traversable.$p1Traversable
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     GHC.Base.Functor t
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLL),U(U,A,A,A,A,A)>] =
    [] \r [v_sbWTZ]
        case v_sbWTZ of {
          Data.Traversable.C:Traversable v_sbWU1 [Occ=Once]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead] ->
              v_sbWU1;
        };

Data.Traversable.$p2Traversable
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     Data.Foldable.Foldable t
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLL),U(A,U,A,A,A,A)>] =
    [] \r [v_sbWU7]
        case v_sbWU7 of {
          Data.Traversable.C:Traversable _ [Occ=Dead]
                                         v_sbWUa [Occ=Once]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead] ->
              v_sbWUa;
        };

Data.Traversable.traverse
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> t a -> f (t b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLL),U(A,A,U,A,A,A)>] =
    [] \r [v_sbWUf]
        case v_sbWUf of {
          Data.Traversable.C:Traversable _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         v_sbWUj [Occ=Once]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead] ->
              v_sbWUj;
        };

Data.Traversable.sequenceA
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     t (f a) -> f (t a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLL),U(A,A,A,U,A,A)>] =
    [] \r [v_sbWUn]
        case v_sbWUn of {
          Data.Traversable.C:Traversable _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         v_sbWUs [Occ=Once]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead] ->
              v_sbWUs;
        };

Data.Traversable.mapM
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> t a -> m (t b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSL),U(A,A,A,A,U,A)>] =
    [] \r [v_sbWUv]
        case v_sbWUv of {
          Data.Traversable.C:Traversable _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         v_sbWUB [Occ=Once]
                                         _ [Occ=Dead] ->
              v_sbWUB;
        };

Data.Traversable.sequence
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (m :: * -> *) a. GHC.Base.Monad m => t (m a) -> m (t a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLS),U(A,A,A,A,A,U)>] =
    [] \r [v_sbWUD]
        case v_sbWUD of {
          Data.Traversable.C:Traversable _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         v_sbWUK [Occ=Once] ->
              v_sbWUK;
        };

Data.Traversable.$fTraversableFirst_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Base.Maybe a -> f (GHC.Base.Maybe b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWUL eta_sbWUM eta1_sbWUN]
        case eta1_sbWUN of {
          GHC.Base.Nothing ->
              GHC.Base.pure $dApplicative_sbWUL GHC.Base.Nothing;
          GHC.Base.Just x_sbWUP [Occ=Once] ->
              let {
                sat_sbWUR [Occ=Once] :: f_abW15 b_abW17
                [LclId] =
                    [eta_sbWUM x_sbWUP] \u [] eta_sbWUM x_sbWUP;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbWUL of sat_sbWUQ {
                  __DEFAULT -> GHC.Base.fmap sat_sbWUQ GHC.Base.Just sat_sbWUR;
                };
        };

Data.Traversable.$fTraversable[]_$ctraverse [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> [a] -> f [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*C1(U),A,C(C1(C1(U))),A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWUS f1_sbWUT]
        let {
          z_sbWUU [Occ=OnceL] :: f_abVZK [b_abVZM]
          [LclId] =
              [$dApplicative_sbWUS] \u []
                  GHC.Base.pure $dApplicative_sbWUS GHC.Types.[]; } in
        let {
          go_sbWUV [Occ=LoopBreaker] :: [a_abVZL] -> f_abVZK [b_abVZM]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [$dApplicative_sbWUS f1_sbWUT z_sbWUU go_sbWUV] \r [ds_sbWUW]
                  case ds_sbWUW of {
                    [] -> z_sbWUU;
                    : y_sbWUY [Occ=Once] ys_sbWUZ [Occ=Once] ->
                        let {
                          sat_sbWV1 [Occ=Once] :: f_abVZK [b_abVZM]
                          [LclId] =
                              [go_sbWUV ys_sbWUZ] \u [] go_sbWUV ys_sbWUZ; } in
                        let {
                          sat_sbWV0 [Occ=Once] :: f_abVZK b_abVZM
                          [LclId] =
                              [f1_sbWUT y_sbWUY] \u [] f1_sbWUT y_sbWUY;
                        } in 
                          GHC.Base.liftA2
                              $dApplicative_sbWUS GHC.Types.: sat_sbWV0 sat_sbWV1;
                  };
        } in  go_sbWUV;

Data.Traversable.$fTraversableEither_$ctraverse
  :: forall a1 (f :: * -> *) a2 b.
     GHC.Base.Applicative f =>
     (a2 -> f b)
     -> Data.Either.Either a1 a2 -> f (Data.Either.Either a1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWV2 eta_sbWV3 eta1_sbWV4]
        case eta1_sbWV4 of {
          Data.Either.Left x_sbWV6 [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWV2 wild_sbWV5;
          Data.Either.Right y_sbWV8 [Occ=Once] ->
              let {
                sat_sbWVa [Occ=Once] :: f_abVXx b_abVXz
                [LclId] =
                    [eta_sbWV3 y_sbWV8] \u [] eta_sbWV3 y_sbWV8;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbWV2 of sat_sbWV9 {
                  __DEFAULT -> GHC.Base.fmap sat_sbWV9 Data.Either.Right sat_sbWVa;
                };
        };

Data.Traversable.$fTraversable(,)_$ctraverse
  :: forall a1 (f :: * -> *) a2 b.
     GHC.Base.Applicative f =>
     (a2 -> f b) -> (a1, a2) -> f (a1, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWVb eta_sbWVc eta1_sbWVd]
        case eta1_sbWVd of {
          (,) x_sbWVf [Occ=OnceL] y_sbWVg [Occ=Once] ->
              let {
                sat_sbWVj [Occ=Once] :: f_abVWv b_abVWx
                [LclId] =
                    [eta_sbWVc y_sbWVg] \u [] eta_sbWVc y_sbWVg; } in
              let {
                sat_sbWVi [Occ=Once] :: b_abVWx -> (a_abVWj, b_abVWx)
                [LclId] =
                    [x_sbWVf] \r [eta_B1] (,) [x_sbWVf eta_B1];
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbWVb of sat_sbWVh {
                  __DEFAULT -> GHC.Base.fmap sat_sbWVh sat_sbWVi sat_sbWVj;
                };
        };

Data.Traversable.$fTraversableProxy_$csequence [InlPrag=INLINE (sat-args=1)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Proxy.Proxy (m a) -> m (Data.Proxy.Proxy a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWVk eta_sbWVl]
        case GHC.Base.$p1Monad $dMonad_sbWVk of sat_sbWVm {
          __DEFAULT -> GHC.Base.pure sat_sbWVm Data.Proxy.Proxy;
        };

Data.Traversable.$fTraversableProxy_$cmapM [InlPrag=INLINE (sat-args=2)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Proxy.Proxy a -> m (Data.Proxy.Proxy b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWVn eta_sbWVo eta1_sbWVp]
        case GHC.Base.$p1Monad $dMonad_sbWVn of sat_sbWVq {
          __DEFAULT -> GHC.Base.pure sat_sbWVq Data.Proxy.Proxy;
        };

Data.Traversable.$fTraversableProxy_$csequenceA [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Proxy.Proxy (f a) -> f (Data.Proxy.Proxy a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWVr ds_sbWVs]
        GHC.Base.pure $dApplicative_sbWVr Data.Proxy.Proxy;

Data.Traversable.$fTraversableProxy_$ctraverse [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Proxy.Proxy a -> f (Data.Proxy.Proxy b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWVt eta_sbWVu ds_sbWVv]
        GHC.Base.pure $dApplicative_sbWVt Data.Proxy.Proxy;

Data.Traversable.$fTraversableProxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Proxy.Proxy
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Proxy.$fFunctorProxy
                                                   Data.Foldable.$fFoldableProxy
                                                   Data.Traversable.$fTraversableProxy_$ctraverse
                                                   Data.Traversable.$fTraversableProxy_$csequenceA
                                                   Data.Traversable.$fTraversableProxy_$cmapM
                                                   Data.Traversable.$fTraversableProxy_$csequence];

Data.Traversable.$fTraversableConst_$ctraverse
  :: forall m (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Functor.Const.Const m a -> f (Data.Functor.Const.Const m b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWVw ds_sbWVx ds1_sbWVy]
        GHC.Base.pure $dApplicative_sbWVw ds1_sbWVy;

Data.Traversable.$fTraversableDual1 :: forall b. b -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbWVz] v_sbWVz;

Data.Traversable.$fTraversableDual_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Semigroup.Internal.Dual a
     -> f (Data.Semigroup.Internal.Dual b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWVA eta_sbWVB eta1_sbWVC]
        let {
          sat_sbWVE [Occ=Once] :: f_abVS2 b_abVS4
          [LclId] =
              [eta_sbWVB eta1_sbWVC] \u [] eta_sbWVB eta1_sbWVC;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbWVA of sat_sbWVD {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sbWVD Data.Traversable.$fTraversableDual1 sat_sbWVE;
          };

Data.Traversable.$fTraversableSum_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Semigroup.Internal.Sum a
     -> f (Data.Semigroup.Internal.Sum b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWVF eta_sbWVG eta1_sbWVH]
        let {
          sat_sbWVJ [Occ=Once] :: f_abVR2 b_abVR4
          [LclId] =
              [eta_sbWVG eta1_sbWVH] \u [] eta_sbWVG eta1_sbWVH;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbWVF of sat_sbWVI {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sbWVI Data.Traversable.$fTraversableDual1 sat_sbWVJ;
          };

Data.Traversable.$fTraversableProduct_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Semigroup.Internal.Product a
     -> f (Data.Semigroup.Internal.Product b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWVK eta_sbWVL eta1_sbWVM]
        let {
          sat_sbWVO [Occ=Once] :: f_abVQ2 b_abVQ4
          [LclId] =
              [eta_sbWVL eta1_sbWVM] \u [] eta_sbWVL eta1_sbWVM;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbWVK of sat_sbWVN {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sbWVN Data.Traversable.$fTraversableDual1 sat_sbWVO;
          };

Data.Traversable.$fTraversableU1_$csequence [InlPrag=INLINE (sat-args=1)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.U1 (m a) -> m (GHC.Generics.U1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWVP eta_sbWVQ]
        case GHC.Base.$p1Monad $dMonad_sbWVP of sat_sbWVR {
          __DEFAULT -> GHC.Base.pure sat_sbWVR GHC.Generics.U1;
        };

Data.Traversable.$fTraversableU1_$cmapM [InlPrag=INLINE (sat-args=2)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Generics.U1 a -> m (GHC.Generics.U1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWVS eta_sbWVT eta1_sbWVU]
        case GHC.Base.$p1Monad $dMonad_sbWVS of sat_sbWVV {
          __DEFAULT -> GHC.Base.pure sat_sbWVV GHC.Generics.U1;
        };

Data.Traversable.$fTraversableU1_$csequenceA [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.U1 (f a) -> f (GHC.Generics.U1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWVW ds_sbWVX]
        GHC.Base.pure $dApplicative_sbWVW GHC.Generics.U1;

Data.Traversable.$fTraversableU1_$ctraverse [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Generics.U1 a -> f (GHC.Generics.U1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWVY eta_sbWVZ ds_sbWW0]
        GHC.Base.pure $dApplicative_sbWVY GHC.Generics.U1;

Data.Traversable.$fTraversableU1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable GHC.Generics.U1
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorU1
                                                   Data.Foldable.$fFoldableU1
                                                   Data.Traversable.$fTraversableU1_$ctraverse
                                                   Data.Traversable.$fTraversableU1_$csequenceA
                                                   Data.Traversable.$fTraversableU1_$cmapM
                                                   Data.Traversable.$fTraversableU1_$csequence];

Data.Traversable.$fTraversableIdentity_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Functor.Identity.Identity a
     -> f (Data.Functor.Identity.Identity b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWW1 eta_sbWW2 eta1_sbWW3]
        let {
          sat_sbWW5 [Occ=Once] :: f_abVKI b_abVKK
          [LclId] =
              [eta_sbWW2 eta1_sbWW3] \u [] eta_sbWW2 eta1_sbWW3;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbWW1 of sat_sbWW4 {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sbWW4 Data.Traversable.$fTraversableDual1 sat_sbWW5;
          };

Data.Traversable.$fTraversableV1_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Generics.V1 a -> f (GHC.Generics.V1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWW6 ds_sbWW7 z_sbWW8]
        GHC.Base.pure $dApplicative_sbWW6 z_sbWW8;

Data.Traversable.$fTraversablePar1_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Generics.Par1 a -> f (GHC.Generics.Par1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWW9 eta_sbWWa eta1_sbWWb]
        let {
          sat_sbWWd [Occ=Once] :: f_abVIH b_abVIJ
          [LclId] =
              [eta_sbWWa eta1_sbWWb] \u [] eta_sbWWa eta1_sbWWb;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbWW9 of sat_sbWWc {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sbWWc Data.Traversable.$fTraversableDual1 sat_sbWWd;
          };

Data.Traversable.$fTraversableM2
  :: forall (f :: * -> *) b. f b -> f b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [b1_sbWWe] b1_sbWWe;

Data.Traversable.$fTraversableRec1_$ctraverse
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b) -> GHC.Generics.Rec1 f a -> f1 (GHC.Generics.Rec1 f b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWWf
           $dApplicative_sbWWg
           eta_sbWWh
           eta1_sbWWi]
        let {
          sat_sbWWk [Occ=Once] :: f1_abVHz (f_abVHm b_abVHB)
          [LclId] =
              [$dTraversable_sbWWf
               $dApplicative_sbWWg
               eta_sbWWh
               eta1_sbWWi] \u []
                  Data.Traversable.traverse
                      $dTraversable_sbWWf $dApplicative_sbWWg eta_sbWWh eta1_sbWWi;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbWWg of sat_sbWWj {
            __DEFAULT ->
                GHC.Base.fmap sat_sbWWj Data.Traversable.$fTraversableM2 sat_sbWWk;
          };

Data.Traversable.$fTraversableRec1_$cp2Traversable
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     Data.Foldable.Foldable (GHC.Generics.Rec1 f)
[GblId,
 Arity=1,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWWl]
        let {
          sat_sbWWm [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_abVHm
          [LclId] =
              [$dTraversable_sbWWl] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sbWWl;
        } in  Data.Foldable.$fFoldableRec1 sat_sbWWm;

Data.Traversable.$fTraversableRec1_$cp1Traversable
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     GHC.Base.Functor (GHC.Generics.Rec1 f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWWn]
        let {
          sat_sbWWo [Occ=Once, Dmd=<L,U(1*U,1*U)>]
            :: GHC.Base.Functor f_abVHm
          [LclId] =
              [$dTraversable_sbWWn] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sbWWn;
        } in  GHC.Generics.$fFunctorRec1 sat_sbWWo;

Data.Traversable.$fTraversableK1_$ctraverse
  :: forall i c (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Generics.K1 i c a -> f (GHC.Generics.K1 i c b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWWp ds_sbWWq z_sbWWr]
        GHC.Base.pure $dApplicative_sbWWp z_sbWWr;

Data.Traversable.$fTraversableM1_$ctraverse
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> GHC.Generics.M1 i c f a -> f1 (GHC.Generics.M1 i c f b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWWs
           $dApplicative_sbWWt
           eta_sbWWu
           eta1_sbWWv]
        let {
          sat_sbWWx [Occ=Once] :: f1_abVFk (f_abVF5 b_abVFm)
          [LclId] =
              [$dTraversable_sbWWs
               $dApplicative_sbWWt
               eta_sbWWu
               eta1_sbWWv] \u []
                  Data.Traversable.traverse
                      $dTraversable_sbWWs $dApplicative_sbWWt eta_sbWWu eta1_sbWWv;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbWWt of sat_sbWWw {
            __DEFAULT ->
                GHC.Base.fmap sat_sbWWw Data.Traversable.$fTraversableM2 sat_sbWWx;
          };

Data.Traversable.$fTraversableM1_$cp2Traversable
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     Data.Foldable.Foldable (GHC.Generics.M1 i c f)
[GblId,
 Arity=1,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWWy]
        let {
          sat_sbWWz [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_abVF5
          [LclId] =
              [$dTraversable_sbWWy] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sbWWy;
        } in  Data.Foldable.$fFoldableM1 sat_sbWWz;

Data.Traversable.$fTraversableM1_$cp1Traversable
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     GHC.Base.Functor (GHC.Generics.M1 i c f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWWA]
        let {
          sat_sbWWB [Occ=Once, Dmd=<L,U(1*U,1*U)>]
            :: GHC.Base.Functor f_abVF5
          [LclId] =
              [$dTraversable_sbWWA] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sbWWA;
        } in  GHC.Generics.$fFunctorM1 sat_sbWWB;

Data.Traversable.$fTraversable:+:_$ctraverse
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> (GHC.Generics.:+:) f g a -> f1 ((GHC.Generics.:+:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWWC
           $dTraversable1_sbWWD
           $dApplicative_sbWWE
           eta_sbWWF
           eta1_sbWWG]
        case eta1_sbWWG of {
          GHC.Generics.L1 a1_sbWWI [Occ=Once] ->
              let {
                sat_sbWWK [Occ=Once] :: f1_abVDT (f_abVDE b_abVDV)
                [LclId] =
                    [$dTraversable_sbWWC $dApplicative_sbWWE eta_sbWWF a1_sbWWI] \u []
                        Data.Traversable.traverse
                            $dTraversable_sbWWC $dApplicative_sbWWE eta_sbWWF a1_sbWWI;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbWWE of sat_sbWWJ {
                  __DEFAULT -> GHC.Base.fmap sat_sbWWJ GHC.Generics.L1 sat_sbWWK;
                };
          GHC.Generics.R1 a1_sbWWL [Occ=Once] ->
              let {
                sat_sbWWN [Occ=Once] :: f1_abVDT (g_abVDF b_abVDV)
                [LclId] =
                    [$dTraversable1_sbWWD $dApplicative_sbWWE eta_sbWWF a1_sbWWL] \u []
                        Data.Traversable.traverse
                            $dTraversable1_sbWWD $dApplicative_sbWWE eta_sbWWF a1_sbWWL;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbWWE of sat_sbWWM {
                  __DEFAULT -> GHC.Base.fmap sat_sbWWM GHC.Generics.R1 sat_sbWWN;
                };
        };

Data.Traversable.$fTraversable:+:_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:+: g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWWO $dTraversable1_sbWWP]
        let {
          sat_sbWWR [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_abVDF
          [LclId] =
              [$dTraversable1_sbWWP] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sbWWP; } in
        let {
          sat_sbWWQ [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_abVDE
          [LclId] =
              [$dTraversable_sbWWO] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sbWWO;
        } in  Data.Foldable.$fFoldable:+: sat_sbWWQ sat_sbWWR;

Data.Traversable.$fTraversable:+:_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (f GHC.Generics.:+: g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),C(C1(U))),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),C(C1(U))),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWWS $dTraversable1_sbWWT]
        let {
          sat_sbWWV [Occ=Once, Dmd=<L,U(C(C1(U)),C(C1(U)))>]
            :: GHC.Base.Functor g_abVDF
          [LclId] =
              [$dTraversable1_sbWWT] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sbWWT; } in
        let {
          sat_sbWWU [Occ=Once, Dmd=<L,U(C(C1(U)),C(C1(U)))>]
            :: GHC.Base.Functor f_abVDE
          [LclId] =
              [$dTraversable_sbWWS] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sbWWS;
        } in  GHC.Generics.$fFunctor:+: sat_sbWWU sat_sbWWV;

Data.Traversable.$w$ctraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b) -> f a -> g a -> f1 ((GHC.Generics.:*:) f g b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbWWW w1_sbWWX w2_sbWWY w3_sbWWZ ww_sbWX0 ww1_sbWX1]
        let {
          sat_sbWX3 [Occ=Once] :: f1_sbWKB (g_sbWKy b_sbWKD)
          [LclId] =
              [w1_sbWWX w2_sbWWY w3_sbWWZ ww1_sbWX1] \u []
                  Data.Traversable.traverse
                      w1_sbWWX w2_sbWWY w3_sbWWZ ww1_sbWX1; } in
        let {
          sat_sbWX2 [Occ=Once] :: f1_sbWKB (f_sbWKx b_sbWKD)
          [LclId] =
              [w_sbWWW w2_sbWWY w3_sbWWZ ww_sbWX0] \u []
                  Data.Traversable.traverse w_sbWWW w2_sbWWY w3_sbWWZ ww_sbWX0;
        } in 
          GHC.Base.liftA2 w2_sbWWY GHC.Generics.:*: sat_sbWX2 sat_sbWX3;

Data.Traversable.$fTraversable:*:_$ctraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> (GHC.Generics.:*:) f g a -> f1 ((GHC.Generics.:*:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sbWX4 w1_sbWX5 w2_sbWX6 w3_sbWX7 w4_sbWX8]
        case w4_sbWX8 of {
          GHC.Generics.:*: ww1_sbWXa [Occ=Once] ww2_sbWXb [Occ=Once] ->
              Data.Traversable.$w$ctraverse
                  w_sbWX4 w1_sbWX5 w2_sbWX6 w3_sbWX7 ww1_sbWXa ww2_sbWXb;
        };

Data.Traversable.$fTraversable:*:_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:*: g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWXc $dTraversable1_sbWXd]
        let {
          sat_sbWXf [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_abVCl
          [LclId] =
              [$dTraversable1_sbWXd] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sbWXd; } in
        let {
          sat_sbWXe [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_abVCk
          [LclId] =
              [$dTraversable_sbWXc] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sbWXc;
        } in  Data.Foldable.$fFoldable:*: sat_sbWXe sat_sbWXf;

Data.Traversable.$fTraversable:*:_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (f GHC.Generics.:*: g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),C(C1(U))),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),C(C1(U))),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWXg $dTraversable1_sbWXh]
        let {
          sat_sbWXj [Occ=Once, Dmd=<L,U(C(C1(U)),C(C1(U)))>]
            :: GHC.Base.Functor g_abVCl
          [LclId] =
              [$dTraversable1_sbWXh] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sbWXh; } in
        let {
          sat_sbWXi [Occ=Once, Dmd=<L,U(C(C1(U)),C(C1(U)))>]
            :: GHC.Base.Functor f_abVCk
          [LclId] =
              [$dTraversable_sbWXg] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sbWXg;
        } in  GHC.Generics.$fFunctor:*: sat_sbWXi sat_sbWXj;

Data.Traversable.$fTraversable:.:1
  :: forall (f :: * -> *) (g :: * -> *) b. f (g b) -> f (g b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [b1_sbWXk] b1_sbWXk;

Data.Traversable.$fTraversable:.:_$ctraverse
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> (GHC.Generics.:.:) f g a -> f1 ((GHC.Generics.:.:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWXl
           $dTraversable1_sbWXm
           $dApplicative_sbWXn
           eta_sbWXo
           eta1_sbWXp]
        let {
          sat_sbWXs [Occ=Once] :: f1_abVBf (f_abVB0 (g_abVB1 b_abVBh))
          [LclId] =
              [$dTraversable_sbWXl
               $dTraversable1_sbWXm
               $dApplicative_sbWXn
               eta_sbWXo
               eta1_sbWXp] \u []
                  let {
                    sat_sbWXr [Occ=Once]
                      :: g_abVB1 a_abVBg -> f1_abVBf (g_abVB1 b_abVBh)
                    [LclId] =
                        [$dTraversable1_sbWXm $dApplicative_sbWXn eta_sbWXo] \u []
                            Data.Traversable.traverse
                                $dTraversable1_sbWXm $dApplicative_sbWXn eta_sbWXo;
                  } in 
                    Data.Traversable.traverse
                        $dTraversable_sbWXl $dApplicative_sbWXn sat_sbWXr eta1_sbWXp;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbWXn of sat_sbWXq {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sbWXq Data.Traversable.$fTraversable:.:1 sat_sbWXs;
          };

Data.Traversable.$fTraversable:.:_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:.: g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(U)),C(C1(C1(U))),A,A,A,A,A,A,U,A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWXt $dTraversable1_sbWXu]
        let {
          sat_sbWXw [Occ=Once,
                     Dmd=<L,U(A,C(C1(U)),C(C1(C1(U))),A,A,A,A,A,A,U,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_abVB1
          [LclId] =
              [$dTraversable1_sbWXu] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sbWXu; } in
        let {
          sat_sbWXv [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_abVB0
          [LclId] =
              [$dTraversable_sbWXt] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sbWXt;
        } in  Data.Foldable.$fFoldable:.: sat_sbWXv sat_sbWXw;

Data.Traversable.$fTraversable:.:_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (f GHC.Generics.:.: g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(U),C(U)),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWXx $dTraversable1_sbWXy]
        let {
          sat_sbWXA [Occ=Once, Dmd=<L,U(C(U),C(U))>]
            :: GHC.Base.Functor g_abVB1
          [LclId] =
              [$dTraversable1_sbWXy] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sbWXy; } in
        let {
          sat_sbWXz [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_abVB0
          [LclId] =
              [$dTraversable_sbWXx] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sbWXx;
        } in  GHC.Generics.$fFunctor:.: sat_sbWXz sat_sbWXA;

Data.Traversable.$fTraversableURec4_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a
     -> f (GHC.Generics.URec (GHC.Ptr.Ptr ()) b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWXB f1_sbWXC ds_sbWXD]
        case ds_sbWXD of {
          GHC.Generics.UAddr a1_sbWXF [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWXB wild_sbWXE;
        };

Data.Traversable.$fTraversableURec3_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec GHC.Types.Char a
     -> f (GHC.Generics.URec GHC.Types.Char b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWXH f1_sbWXI ds_sbWXJ]
        case ds_sbWXJ of {
          GHC.Generics.UChar a1_sbWXL [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWXH wild_sbWXK;
        };

Data.Traversable.$fTraversableURec2_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec GHC.Types.Double a
     -> f (GHC.Generics.URec GHC.Types.Double b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWXN f1_sbWXO ds_sbWXP]
        case ds_sbWXP of {
          GHC.Generics.UDouble a1_sbWXR [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWXN wild_sbWXQ;
        };

Data.Traversable.$fTraversableURec1_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec GHC.Types.Float a
     -> f (GHC.Generics.URec GHC.Types.Float b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWXT f1_sbWXU ds_sbWXV]
        case ds_sbWXV of {
          GHC.Generics.UFloat a1_sbWXX [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWXT wild_sbWXW;
        };

Data.Traversable.$fTraversableURec0_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec GHC.Types.Int a
     -> f (GHC.Generics.URec GHC.Types.Int b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWXZ f1_sbWY0 ds_sbWY1]
        case ds_sbWY1 of {
          GHC.Generics.UInt a1_sbWY3 [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWXZ wild_sbWY2;
        };

Data.Traversable.$fTraversableURec_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec GHC.Types.Word a
     -> f (GHC.Generics.URec GHC.Types.Word b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWY5 f1_sbWY6 ds_sbWY7]
        case ds_sbWY7 of {
          GHC.Generics.UWord a1_sbWY9 [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWY5 wild_sbWY8;
        };

Data.Traversable.$dmsequence [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (m :: * -> *) a. GHC.Base.Monad m => t (m a) -> m (t a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LL),1*U(A,A,A,1*C1(U),A,A)><L,1*U(1*U,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWYb $dMonad_sbWYc]
        let {
          sat_sbWYd [Occ=Once] :: GHC.Base.Applicative m_abVux
          [LclId] =
              [$dMonad_sbWYc] \u [] GHC.Base.$p1Monad $dMonad_sbWYc;
        } in  Data.Traversable.sequenceA $dTraversable_sbWYb sat_sbWYd;

Data.Traversable.$dmmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> t a -> m (t b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)><L,1*U(1*U,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWYe $dMonad_sbWYf]
        let {
          sat_sbWYg [Occ=Once] :: GHC.Base.Applicative m_abVuj
          [LclId] =
              [$dMonad_sbWYf] \u [] GHC.Base.$p1Monad $dMonad_sbWYf;
        } in  Data.Traversable.traverse $dTraversable_sbWYe sat_sbWYg;

Data.Traversable.$dmsequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     t (f a) -> f (t a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),1*U(A,A,1*C1(C1(U)),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWYh $dApplicative_sbWYi]
        Data.Traversable.traverse
            $dTraversable_sbWYh $dApplicative_sbWYi GHC.Base.id;

Data.Traversable.$fTraversableURec_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec GHC.Types.Word (f a)
     -> f (GHC.Generics.URec GHC.Types.Word a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWYj ds_sbWYk]
        case ds_sbWYk of {
          GHC.Generics.UWord a1_sbWYm [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWYj wild_sbWYl;
        };

Data.Traversable.$fTraversableURec_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec GHC.Types.Word a
     -> m (GHC.Generics.URec GHC.Types.Word b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWYo eta_sbWYp eta1_sbWYq]
        case eta1_sbWYq of {
          GHC.Generics.UWord a1_sbWYs [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWYo of sat_sbWYt {
                __DEFAULT -> GHC.Base.pure sat_sbWYt wild_sbWYr;
              };
        };

Data.Traversable.$fTraversableURec_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec GHC.Types.Word (m a)
     -> m (GHC.Generics.URec GHC.Types.Word a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWYv eta_sbWYw]
        case eta_sbWYw of {
          GHC.Generics.UWord a1_sbWYy [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWYv of sat_sbWYz {
                __DEFAULT -> GHC.Base.pure sat_sbWYz wild_sbWYx;
              };
        };

Data.Traversable.$fTraversableURec [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Word)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec
                                                   Data.Foldable.$fFoldableURec
                                                   Data.Traversable.$fTraversableURec_$ctraverse
                                                   Data.Traversable.$fTraversableURec_$csequenceA
                                                   Data.Traversable.$fTraversableURec_$cmapM
                                                   Data.Traversable.$fTraversableURec_$csequence];

Data.Traversable.$fTraversableURec0_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec GHC.Types.Int (f a)
     -> f (GHC.Generics.URec GHC.Types.Int a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWYB ds_sbWYC]
        case ds_sbWYC of {
          GHC.Generics.UInt a1_sbWYE [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWYB wild_sbWYD;
        };

Data.Traversable.$fTraversableURec0_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec GHC.Types.Int a
     -> m (GHC.Generics.URec GHC.Types.Int b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWYG eta_sbWYH eta1_sbWYI]
        case eta1_sbWYI of {
          GHC.Generics.UInt a1_sbWYK [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWYG of sat_sbWYL {
                __DEFAULT -> GHC.Base.pure sat_sbWYL wild_sbWYJ;
              };
        };

Data.Traversable.$fTraversableURec0_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec GHC.Types.Int (m a)
     -> m (GHC.Generics.URec GHC.Types.Int a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWYN eta_sbWYO]
        case eta_sbWYO of {
          GHC.Generics.UInt a1_sbWYQ [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWYN of sat_sbWYR {
                __DEFAULT -> GHC.Base.pure sat_sbWYR wild_sbWYP;
              };
        };

Data.Traversable.$fTraversableURec0 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Int)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec0
                                                   Data.Foldable.$fFoldableURec0
                                                   Data.Traversable.$fTraversableURec0_$ctraverse
                                                   Data.Traversable.$fTraversableURec0_$csequenceA
                                                   Data.Traversable.$fTraversableURec0_$cmapM
                                                   Data.Traversable.$fTraversableURec0_$csequence];

Data.Traversable.$fTraversableURec1_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec GHC.Types.Float (f a)
     -> f (GHC.Generics.URec GHC.Types.Float a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWYT ds_sbWYU]
        case ds_sbWYU of {
          GHC.Generics.UFloat a1_sbWYW [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWYT wild_sbWYV;
        };

Data.Traversable.$fTraversableURec1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec GHC.Types.Float a
     -> m (GHC.Generics.URec GHC.Types.Float b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWYY eta_sbWYZ eta1_sbWZ0]
        case eta1_sbWZ0 of {
          GHC.Generics.UFloat a1_sbWZ2 [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWYY of sat_sbWZ3 {
                __DEFAULT -> GHC.Base.pure sat_sbWZ3 wild_sbWZ1;
              };
        };

Data.Traversable.$fTraversableURec1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec GHC.Types.Float (m a)
     -> m (GHC.Generics.URec GHC.Types.Float a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWZ5 eta_sbWZ6]
        case eta_sbWZ6 of {
          GHC.Generics.UFloat a1_sbWZ8 [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWZ5 of sat_sbWZ9 {
                __DEFAULT -> GHC.Base.pure sat_sbWZ9 wild_sbWZ7;
              };
        };

Data.Traversable.$fTraversableURec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Float)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec1
                                                   Data.Foldable.$fFoldableURec1
                                                   Data.Traversable.$fTraversableURec1_$ctraverse
                                                   Data.Traversable.$fTraversableURec1_$csequenceA
                                                   Data.Traversable.$fTraversableURec1_$cmapM
                                                   Data.Traversable.$fTraversableURec1_$csequence];

Data.Traversable.$fTraversableURec2_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec GHC.Types.Double (f a)
     -> f (GHC.Generics.URec GHC.Types.Double a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWZb ds_sbWZc]
        case ds_sbWZc of {
          GHC.Generics.UDouble a1_sbWZe [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWZb wild_sbWZd;
        };

Data.Traversable.$fTraversableURec2_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec GHC.Types.Double a
     -> m (GHC.Generics.URec GHC.Types.Double b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWZg eta_sbWZh eta1_sbWZi]
        case eta1_sbWZi of {
          GHC.Generics.UDouble a1_sbWZk [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWZg of sat_sbWZl {
                __DEFAULT -> GHC.Base.pure sat_sbWZl wild_sbWZj;
              };
        };

Data.Traversable.$fTraversableURec2_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec GHC.Types.Double (m a)
     -> m (GHC.Generics.URec GHC.Types.Double a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWZn eta_sbWZo]
        case eta_sbWZo of {
          GHC.Generics.UDouble a1_sbWZq [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWZn of sat_sbWZr {
                __DEFAULT -> GHC.Base.pure sat_sbWZr wild_sbWZp;
              };
        };

Data.Traversable.$fTraversableURec2 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable
       (GHC.Generics.URec GHC.Types.Double)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec2
                                                   Data.Foldable.$fFoldableURec2
                                                   Data.Traversable.$fTraversableURec2_$ctraverse
                                                   Data.Traversable.$fTraversableURec2_$csequenceA
                                                   Data.Traversable.$fTraversableURec2_$cmapM
                                                   Data.Traversable.$fTraversableURec2_$csequence];

Data.Traversable.$fTraversableURec3_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec GHC.Types.Char (f a)
     -> f (GHC.Generics.URec GHC.Types.Char a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWZt ds_sbWZu]
        case ds_sbWZu of {
          GHC.Generics.UChar a1_sbWZw [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWZt wild_sbWZv;
        };

Data.Traversable.$fTraversableURec3_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec GHC.Types.Char a
     -> m (GHC.Generics.URec GHC.Types.Char b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWZy eta_sbWZz eta1_sbWZA]
        case eta1_sbWZA of {
          GHC.Generics.UChar a1_sbWZC [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWZy of sat_sbWZD {
                __DEFAULT -> GHC.Base.pure sat_sbWZD wild_sbWZB;
              };
        };

Data.Traversable.$fTraversableURec3_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec GHC.Types.Char (m a)
     -> m (GHC.Generics.URec GHC.Types.Char a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWZF eta_sbWZG]
        case eta_sbWZG of {
          GHC.Generics.UChar a1_sbWZI [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWZF of sat_sbWZJ {
                __DEFAULT -> GHC.Base.pure sat_sbWZJ wild_sbWZH;
              };
        };

Data.Traversable.$fTraversableURec3 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Char)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec3
                                                   Data.Foldable.$fFoldableURec3
                                                   Data.Traversable.$fTraversableURec3_$ctraverse
                                                   Data.Traversable.$fTraversableURec3_$csequenceA
                                                   Data.Traversable.$fTraversableURec3_$cmapM
                                                   Data.Traversable.$fTraversableURec3_$csequence];

Data.Traversable.$fTraversableURec4_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) (f a)
     -> f (GHC.Generics.URec (GHC.Ptr.Ptr ()) a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWZL ds_sbWZM]
        case ds_sbWZM of {
          GHC.Generics.UAddr a1_sbWZO [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWZL wild_sbWZN;
        };

Data.Traversable.$fTraversableURec4_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a
     -> m (GHC.Generics.URec (GHC.Ptr.Ptr ()) b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWZQ eta_sbWZR eta1_sbWZS]
        case eta1_sbWZS of {
          GHC.Generics.UAddr a1_sbWZU [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWZQ of sat_sbWZV {
                __DEFAULT -> GHC.Base.pure sat_sbWZV wild_sbWZT;
              };
        };

Data.Traversable.$fTraversableURec4_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) (m a)
     -> m (GHC.Generics.URec (GHC.Ptr.Ptr ()) a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWZX eta_sbWZY]
        case eta_sbWZY of {
          GHC.Generics.UAddr a1_sbX00 [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWZX of sat_sbX01 {
                __DEFAULT -> GHC.Base.pure sat_sbX01 wild_sbWZZ;
              };
        };

Data.Traversable.$fTraversableURec4 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable
       (GHC.Generics.URec (GHC.Ptr.Ptr ()))
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec4
                                                   Data.Foldable.$fFoldableURec4
                                                   Data.Traversable.$fTraversableURec4_$ctraverse
                                                   Data.Traversable.$fTraversableURec4_$csequenceA
                                                   Data.Traversable.$fTraversableURec4_$cmapM
                                                   Data.Traversable.$fTraversableURec4_$csequence];

Data.Traversable.$fTraversable:.:_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     (GHC.Generics.:.:) f g (f1 a) -> f1 ((GHC.Generics.:.:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(A,A,C(C1(U)),A,A,A)><L,U(U(U,U),U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX03
           $dTraversable1_sbX04
           $dApplicative_sbX05
           eta_B1]
        Data.Traversable.$fTraversable:.:_$ctraverse
            $dTraversable_sbX03
            $dTraversable1_sbX04
            $dApplicative_sbX05
            GHC.Base.id
            eta_B1;

Data.Traversable.$fTraversable:.:_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> (GHC.Generics.:.:) f g a -> m ((GHC.Generics.:.:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX06
           $dTraversable1_sbX07
           $dMonad_sbX08
           eta_sbX09
           eta1_sbX0a]
        case GHC.Base.$p1Monad $dMonad_sbX08 of sat_sbX0b {
          __DEFAULT ->
              Data.Traversable.$fTraversable:.:_$ctraverse
                  $dTraversable_sbX06
                  $dTraversable1_sbX07
                  sat_sbX0b
                  eta_sbX09
                  eta1_sbX0a;
        };

Data.Traversable.$fTraversable:.:_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     (GHC.Generics.:.:) f g (m a) -> m ((GHC.Generics.:.:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX0c
           $dTraversable1_sbX0d
           $dMonad_sbX0e
           eta_sbX0f]
        case GHC.Base.$p1Monad $dMonad_sbX0e of sat_sbX0g {
          __DEFAULT ->
              Data.Traversable.$fTraversable:.:_$ctraverse
                  $dTraversable_sbX0c
                  $dTraversable1_sbX0d
                  sat_sbX0g
                  GHC.Base.id
                  eta_sbX0f;
        };

Data.Traversable.$fTraversable:.: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (f GHC.Generics.:.: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(U),C(U)),1*U(A,C(C1(U)),C(C1(C1(U))),A,A,A,A,A,A,U,A,A,A,A,A,A),C(C1(U)),A,A,A)>m] =
    [] \r [$dTraversable_sbX0h $dTraversable1_sbX0i]
        let {
          sat_sbX0o [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               (GHC.Generics.:.:) f_abVB0 g_abVB1 (m a)
               -> m ((GHC.Generics.:.:) f_abVB0 g_abVB1 a)
          [LclId] =
              [$dTraversable_sbX0h $dTraversable1_sbX0i] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:.:_$csequence
                      $dTraversable_sbX0h $dTraversable1_sbX0i eta_B2 eta_B1; } in
        let {
          sat_sbX0n [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> (GHC.Generics.:.:) f_abVB0 g_abVB1 a
               -> m ((GHC.Generics.:.:) f_abVB0 g_abVB1 b)
          [LclId] =
              [$dTraversable_sbX0h $dTraversable1_sbX0i] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:.:_$cmapM
                      $dTraversable_sbX0h $dTraversable1_sbX0i eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbX0m [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               (GHC.Generics.:.:) f_abVB0 g_abVB1 (f a)
               -> f ((GHC.Generics.:.:) f_abVB0 g_abVB1 a)
          [LclId] =
              [$dTraversable_sbX0h $dTraversable1_sbX0i] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:.:_$csequenceA
                      $dTraversable_sbX0h $dTraversable1_sbX0i eta_B2 eta_B1; } in
        let {
          sat_sbX0l [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> (GHC.Generics.:.:) f_abVB0 g_abVB1 a
               -> f ((GHC.Generics.:.:) f_abVB0 g_abVB1 b)
          [LclId] =
              [$dTraversable_sbX0h $dTraversable1_sbX0i] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:.:_$ctraverse
                      $dTraversable_sbX0h $dTraversable1_sbX0i eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbX0k [Occ=Once]
            :: Data.Foldable.Foldable (f_abVB0 GHC.Generics.:.: g_abVB1)
          [LclId] =
              [$dTraversable_sbX0h $dTraversable1_sbX0i] \u []
                  Data.Traversable.$fTraversable:.:_$cp2Traversable
                      $dTraversable_sbX0h $dTraversable1_sbX0i; } in
        let {
          sat_sbX0j [Occ=Once]
            :: GHC.Base.Functor (f_abVB0 GHC.Generics.:.: g_abVB1)
          [LclId] =
              [$dTraversable_sbX0h $dTraversable1_sbX0i] \u []
                  Data.Traversable.$fTraversable:.:_$cp1Traversable
                      $dTraversable_sbX0h $dTraversable1_sbX0i;
        } in 
          Data.Traversable.C:Traversable [sat_sbX0j
                                          sat_sbX0k
                                          sat_sbX0l
                                          sat_sbX0m
                                          sat_sbX0n
                                          sat_sbX0o];

Data.Traversable.$fTraversable:*:_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     (GHC.Generics.:*:) f g (f1 a) -> f1 ((GHC.Generics.:*:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX0p
           $dTraversable1_sbX0q
           $dApplicative_sbX0r
           w_sbX0s]
        case w_sbX0s of {
          GHC.Generics.:*: ww1_sbX0u [Occ=Once] ww2_sbX0v [Occ=Once] ->
              Data.Traversable.$w$ctraverse
                  $dTraversable_sbX0p
                  $dTraversable1_sbX0q
                  $dApplicative_sbX0r
                  GHC.Base.id
                  ww1_sbX0u
                  ww2_sbX0v;
        };

Data.Traversable.$fTraversable:*:_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> (GHC.Generics.:*:) f g a -> m ((GHC.Generics.:*:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(U,U,U,U,U,U),A,A,A,A)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX0w
           $dTraversable1_sbX0x
           $dMonad_sbX0y
           eta_sbX0z
           eta1_sbX0A]
        case eta1_sbX0A of {
          GHC.Generics.:*: ww1_sbX0C [Occ=Once] ww2_sbX0D [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbX0y of sat_sbX0E {
                __DEFAULT ->
                    Data.Traversable.$w$ctraverse
                        $dTraversable_sbX0w
                        $dTraversable1_sbX0x
                        sat_sbX0E
                        eta_sbX0z
                        ww1_sbX0C
                        ww2_sbX0D;
              };
        };

Data.Traversable.$fTraversable:*:_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     (GHC.Generics.:*:) f g (m a) -> m ((GHC.Generics.:*:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(U,U,U,U,U,U),A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX0F
           $dTraversable1_sbX0G
           $dMonad_sbX0H
           eta_sbX0I]
        case eta_sbX0I of {
          GHC.Generics.:*: ww1_sbX0K [Occ=Once] ww2_sbX0L [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbX0H of sat_sbX0M {
                __DEFAULT ->
                    Data.Traversable.$w$ctraverse
                        $dTraversable_sbX0F
                        $dTraversable1_sbX0G
                        sat_sbX0M
                        GHC.Base.id
                        ww1_sbX0K
                        ww2_sbX0L;
              };
        };

Data.Traversable.$fTraversable:*: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (f GHC.Generics.:*: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),C(C1(U))),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(C1(U)),C(C1(U))),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sbX0N $dTraversable1_sbX0O]
        let {
          sat_sbX0U [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               (GHC.Generics.:*:) f_abVCk g_abVCl (m a)
               -> m ((GHC.Generics.:*:) f_abVCk g_abVCl a)
          [LclId] =
              [$dTraversable_sbX0N $dTraversable1_sbX0O] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:*:_$csequence
                      $dTraversable_sbX0N $dTraversable1_sbX0O eta_B2 eta_B1; } in
        let {
          sat_sbX0T [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> (GHC.Generics.:*:) f_abVCk g_abVCl a
               -> m ((GHC.Generics.:*:) f_abVCk g_abVCl b)
          [LclId] =
              [$dTraversable_sbX0N $dTraversable1_sbX0O] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:*:_$cmapM
                      $dTraversable_sbX0N $dTraversable1_sbX0O eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbX0S [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               (GHC.Generics.:*:) f_abVCk g_abVCl (f a)
               -> f ((GHC.Generics.:*:) f_abVCk g_abVCl a)
          [LclId] =
              [$dTraversable_sbX0N $dTraversable1_sbX0O] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:*:_$csequenceA
                      $dTraversable_sbX0N $dTraversable1_sbX0O eta_B2 eta_B1; } in
        let {
          sat_sbX0R [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> (GHC.Generics.:*:) f_abVCk g_abVCl a
               -> f ((GHC.Generics.:*:) f_abVCk g_abVCl b)
          [LclId] =
              [$dTraversable_sbX0N $dTraversable1_sbX0O] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:*:_$ctraverse
                      $dTraversable_sbX0N $dTraversable1_sbX0O eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbX0Q [Occ=Once]
            :: Data.Foldable.Foldable (f_abVCk GHC.Generics.:*: g_abVCl)
          [LclId] =
              [$dTraversable_sbX0N $dTraversable1_sbX0O] \u []
                  Data.Traversable.$fTraversable:*:_$cp2Traversable
                      $dTraversable_sbX0N $dTraversable1_sbX0O; } in
        let {
          sat_sbX0P [Occ=Once]
            :: GHC.Base.Functor (f_abVCk GHC.Generics.:*: g_abVCl)
          [LclId] =
              [$dTraversable_sbX0N $dTraversable1_sbX0O] \u []
                  Data.Traversable.$fTraversable:*:_$cp1Traversable
                      $dTraversable_sbX0N $dTraversable1_sbX0O;
        } in 
          Data.Traversable.C:Traversable [sat_sbX0P
                                          sat_sbX0Q
                                          sat_sbX0R
                                          sat_sbX0S
                                          sat_sbX0T
                                          sat_sbX0U];

Data.Traversable.$fTraversable:+:_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     (GHC.Generics.:+:) f g (f1 a) -> f1 ((GHC.Generics.:+:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(U(U,U),U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX0V
           $dTraversable1_sbX0W
           $dApplicative_sbX0X
           eta_B1]
        Data.Traversable.$fTraversable:+:_$ctraverse
            $dTraversable_sbX0V
            $dTraversable1_sbX0W
            $dApplicative_sbX0X
            GHC.Base.id
            eta_B1;

Data.Traversable.$fTraversable:+:_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> (GHC.Generics.:+:) f g a -> m ((GHC.Generics.:+:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX0Y
           $dTraversable1_sbX0Z
           $dMonad_sbX10
           eta_sbX11
           eta1_sbX12]
        case GHC.Base.$p1Monad $dMonad_sbX10 of sat_sbX13 {
          __DEFAULT ->
              Data.Traversable.$fTraversable:+:_$ctraverse
                  $dTraversable_sbX0Y
                  $dTraversable1_sbX0Z
                  sat_sbX13
                  eta_sbX11
                  eta1_sbX12;
        };

Data.Traversable.$fTraversable:+:_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     (GHC.Generics.:+:) f g (m a) -> m ((GHC.Generics.:+:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX14
           $dTraversable1_sbX15
           $dMonad_sbX16
           eta_sbX17]
        case GHC.Base.$p1Monad $dMonad_sbX16 of sat_sbX18 {
          __DEFAULT ->
              Data.Traversable.$fTraversable:+:_$ctraverse
                  $dTraversable_sbX14
                  $dTraversable1_sbX15
                  sat_sbX18
                  GHC.Base.id
                  eta_sbX17;
        };

Data.Traversable.$fTraversable:+: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (f GHC.Generics.:+: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),C(C1(U))),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(C1(U)),C(C1(U))),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sbX19 $dTraversable1_sbX1a]
        let {
          sat_sbX1g [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               (GHC.Generics.:+:) f_abVDE g_abVDF (m a)
               -> m ((GHC.Generics.:+:) f_abVDE g_abVDF a)
          [LclId] =
              [$dTraversable_sbX19 $dTraversable1_sbX1a] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:+:_$csequence
                      $dTraversable_sbX19 $dTraversable1_sbX1a eta_B2 eta_B1; } in
        let {
          sat_sbX1f [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> (GHC.Generics.:+:) f_abVDE g_abVDF a
               -> m ((GHC.Generics.:+:) f_abVDE g_abVDF b)
          [LclId] =
              [$dTraversable_sbX19 $dTraversable1_sbX1a] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:+:_$cmapM
                      $dTraversable_sbX19 $dTraversable1_sbX1a eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbX1e [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               (GHC.Generics.:+:) f_abVDE g_abVDF (f a)
               -> f ((GHC.Generics.:+:) f_abVDE g_abVDF a)
          [LclId] =
              [$dTraversable_sbX19 $dTraversable1_sbX1a] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:+:_$csequenceA
                      $dTraversable_sbX19 $dTraversable1_sbX1a eta_B2 eta_B1; } in
        let {
          sat_sbX1d [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> (GHC.Generics.:+:) f_abVDE g_abVDF a
               -> f ((GHC.Generics.:+:) f_abVDE g_abVDF b)
          [LclId] =
              [$dTraversable_sbX19 $dTraversable1_sbX1a] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:+:_$ctraverse
                      $dTraversable_sbX19 $dTraversable1_sbX1a eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbX1c [Occ=Once]
            :: Data.Foldable.Foldable (f_abVDE GHC.Generics.:+: g_abVDF)
          [LclId] =
              [$dTraversable_sbX19 $dTraversable1_sbX1a] \u []
                  Data.Traversable.$fTraversable:+:_$cp2Traversable
                      $dTraversable_sbX19 $dTraversable1_sbX1a; } in
        let {
          sat_sbX1b [Occ=Once]
            :: GHC.Base.Functor (f_abVDE GHC.Generics.:+: g_abVDF)
          [LclId] =
              [$dTraversable_sbX19 $dTraversable1_sbX1a] \u []
                  Data.Traversable.$fTraversable:+:_$cp1Traversable
                      $dTraversable_sbX19 $dTraversable1_sbX1a;
        } in 
          Data.Traversable.C:Traversable [sat_sbX1b
                                          sat_sbX1c
                                          sat_sbX1d
                                          sat_sbX1e
                                          sat_sbX1f
                                          sat_sbX1g];

Data.Traversable.$fTraversableM1_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     GHC.Generics.M1 i c f (f1 a) -> f1 (GHC.Generics.M1 i c f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX1h $dApplicative_sbX1i eta_sbX1j]
        let {
          sat_sbX1l [Occ=Once] :: f1_abVFI (f_abVF5 a_abVFJ)
          [LclId] =
              [$dTraversable_sbX1h $dApplicative_sbX1i eta_sbX1j] \u []
                  Data.Traversable.traverse
                      $dTraversable_sbX1h $dApplicative_sbX1i GHC.Base.id eta_sbX1j;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbX1i of sat_sbX1k {
            __DEFAULT ->
                GHC.Base.fmap sat_sbX1k Data.Traversable.$fTraversableM2 sat_sbX1l;
          };

Data.Traversable.$fTraversableM1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.M1 i c f a -> m (GHC.Generics.M1 i c f b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX1m $dMonad_sbX1n eta_sbX1o eta1_sbX1p]
        case
            GHC.Base.$p1Monad $dMonad_sbX1n
        of
        $dApplicative_sbX1q [Dmd=<S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)>]
        { __DEFAULT ->
              let {
                sat_sbX1s [Occ=Once] :: m_abVFU (f_abVF5 b_abVFW)
                [LclId] =
                    [$dTraversable_sbX1m
                     eta_sbX1o
                     eta1_sbX1p
                     $dApplicative_sbX1q] \u []
                        Data.Traversable.traverse
                            $dTraversable_sbX1m $dApplicative_sbX1q eta_sbX1o eta1_sbX1p;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbX1q of sat_sbX1r {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sbX1r Data.Traversable.$fTraversableM2 sat_sbX1s;
                };
        };

Data.Traversable.$fTraversableM1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.M1 i c f (m a) -> m (GHC.Generics.M1 i c f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX1t $dMonad_sbX1u eta_sbX1v]
        case
            GHC.Base.$p1Monad $dMonad_sbX1u
        of
        $dApplicative_sbX1w [Dmd=<S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)>]
        { __DEFAULT ->
              let {
                sat_sbX1y [Occ=Once] :: m_abVG8 (f_abVF5 a_abVG9)
                [LclId] =
                    [$dTraversable_sbX1t eta_sbX1v $dApplicative_sbX1w] \u []
                        Data.Traversable.traverse
                            $dTraversable_sbX1t $dApplicative_sbX1w GHC.Base.id eta_sbX1v;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbX1w of sat_sbX1x {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sbX1x Data.Traversable.$fTraversableM2 sat_sbX1y;
                };
        };

Data.Traversable.$fTraversableM1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     Data.Traversable.Traversable (GHC.Generics.M1 i c f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(1*U(1*U,1*U),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sbX1z]
        let {
          sat_sbX1F [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 (m a)
               -> m (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 a)
          [LclId] =
              [$dTraversable_sbX1z] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableM1_$csequence
                      $dTraversable_sbX1z eta_B2 eta_B1; } in
        let {
          sat_sbX1E [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 a
               -> m (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 b)
          [LclId] =
              [$dTraversable_sbX1z] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableM1_$cmapM
                      $dTraversable_sbX1z eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbX1D [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 (f a)
               -> f (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 a)
          [LclId] =
              [$dTraversable_sbX1z] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableM1_$csequenceA
                      $dTraversable_sbX1z eta_B2 eta_B1; } in
        let {
          sat_sbX1C [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 a
               -> f (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 b)
          [LclId] =
              [$dTraversable_sbX1z] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableM1_$ctraverse
                      $dTraversable_sbX1z eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbX1B [Occ=Once]
            :: Data.Foldable.Foldable (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5)
          [LclId] =
              [$dTraversable_sbX1z] \u []
                  Data.Traversable.$fTraversableM1_$cp2Traversable
                      $dTraversable_sbX1z; } in
        let {
          sat_sbX1A [Occ=Once]
            :: GHC.Base.Functor (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5)
          [LclId] =
              [$dTraversable_sbX1z] \u []
                  Data.Traversable.$fTraversableM1_$cp1Traversable
                      $dTraversable_sbX1z;
        } in 
          Data.Traversable.C:Traversable [sat_sbX1A
                                          sat_sbX1B
                                          sat_sbX1C
                                          sat_sbX1D
                                          sat_sbX1E
                                          sat_sbX1F];

Data.Traversable.$fTraversableK1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall i c (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Generics.K1 i c a -> m (GHC.Generics.K1 i c b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX1G eta_sbX1H eta1_sbX1I]
        case GHC.Base.$p1Monad $dMonad_sbX1G of sat_sbX1J {
          __DEFAULT -> GHC.Base.pure sat_sbX1J eta1_sbX1I;
        };

Data.Traversable.$fTraversableK1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall i c (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.K1 i c (m a) -> m (GHC.Generics.K1 i c a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX1K eta_sbX1L]
        case GHC.Base.$p1Monad $dMonad_sbX1K of sat_sbX1M {
          __DEFAULT -> GHC.Base.pure sat_sbX1M eta_sbX1L;
        };

$fTraversableK2_rbWTS
  :: forall c i (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.K1 i c (f a) -> f (GHC.Generics.K1 i c a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX1N z_sbX1O]
        GHC.Base.pure $dApplicative_sbX1N z_sbX1O;

Data.Traversable.$fTraversableK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i c. Data.Traversable.Traversable (GHC.Generics.K1 i c)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorK1
                                                   Data.Foldable.$fFoldableK1
                                                   Data.Traversable.$fTraversableK1_$ctraverse
                                                   $fTraversableK2_rbWTS
                                                   Data.Traversable.$fTraversableK1_$cmapM
                                                   Data.Traversable.$fTraversableK1_$csequence];

Data.Traversable.$fTraversableRec1_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     GHC.Generics.Rec1 f (f1 a) -> f1 (GHC.Generics.Rec1 f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX1P $dApplicative_sbX1Q eta_sbX1R]
        let {
          sat_sbX1T [Occ=Once] :: f1_abVHV (f_abVHm a_abVHW)
          [LclId] =
              [$dTraversable_sbX1P $dApplicative_sbX1Q eta_sbX1R] \u []
                  Data.Traversable.traverse
                      $dTraversable_sbX1P $dApplicative_sbX1Q GHC.Base.id eta_sbX1R;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbX1Q of sat_sbX1S {
            __DEFAULT ->
                GHC.Base.fmap sat_sbX1S Data.Traversable.$fTraversableM2 sat_sbX1T;
          };

Data.Traversable.$fTraversableRec1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Generics.Rec1 f a -> m (GHC.Generics.Rec1 f b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX1U $dMonad_sbX1V eta_sbX1W eta1_sbX1X]
        case
            GHC.Base.$p1Monad $dMonad_sbX1V
        of
        $dApplicative_sbX1Y [Dmd=<S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)>]
        { __DEFAULT ->
              let {
                sat_sbX20 [Occ=Once] :: m_abVI7 (f_abVHm b_abVI9)
                [LclId] =
                    [$dTraversable_sbX1U
                     eta_sbX1W
                     eta1_sbX1X
                     $dApplicative_sbX1Y] \u []
                        Data.Traversable.traverse
                            $dTraversable_sbX1U $dApplicative_sbX1Y eta_sbX1W eta1_sbX1X;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbX1Y of sat_sbX1Z {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sbX1Z Data.Traversable.$fTraversableM2 sat_sbX20;
                };
        };

Data.Traversable.$fTraversableRec1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.Rec1 f (m a) -> m (GHC.Generics.Rec1 f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX21 $dMonad_sbX22 eta_sbX23]
        case
            GHC.Base.$p1Monad $dMonad_sbX22
        of
        $dApplicative_sbX24 [Dmd=<S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)>]
        { __DEFAULT ->
              let {
                sat_sbX26 [Occ=Once] :: m_abVIl (f_abVHm a_abVIm)
                [LclId] =
                    [$dTraversable_sbX21 eta_sbX23 $dApplicative_sbX24] \u []
                        Data.Traversable.traverse
                            $dTraversable_sbX21 $dApplicative_sbX24 GHC.Base.id eta_sbX23;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbX24 of sat_sbX25 {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sbX25 Data.Traversable.$fTraversableM2 sat_sbX26;
                };
        };

Data.Traversable.$fTraversableRec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     Data.Traversable.Traversable (GHC.Generics.Rec1 f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(1*U(1*U,1*U),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sbX27]
        let {
          sat_sbX2d [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               GHC.Generics.Rec1 f_abVHm (m a) -> m (GHC.Generics.Rec1 f_abVHm a)
          [LclId] =
              [$dTraversable_sbX27] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableRec1_$csequence
                      $dTraversable_sbX27 eta_B2 eta_B1; } in
        let {
          sat_sbX2c [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> GHC.Generics.Rec1 f_abVHm a -> m (GHC.Generics.Rec1 f_abVHm b)
          [LclId] =
              [$dTraversable_sbX27] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableRec1_$cmapM
                      $dTraversable_sbX27 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbX2b [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               GHC.Generics.Rec1 f_abVHm (f a) -> f (GHC.Generics.Rec1 f_abVHm a)
          [LclId] =
              [$dTraversable_sbX27] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableRec1_$csequenceA
                      $dTraversable_sbX27 eta_B2 eta_B1; } in
        let {
          sat_sbX2a [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> GHC.Generics.Rec1 f_abVHm a -> f (GHC.Generics.Rec1 f_abVHm b)
          [LclId] =
              [$dTraversable_sbX27] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableRec1_$ctraverse
                      $dTraversable_sbX27 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbX29 [Occ=Once]
            :: Data.Foldable.Foldable (GHC.Generics.Rec1 f_abVHm)
          [LclId] =
              [$dTraversable_sbX27] \u []
                  Data.Traversable.$fTraversableRec1_$cp2Traversable
                      $dTraversable_sbX27; } in
        let {
          sat_sbX28 [Occ=Once]
            :: GHC.Base.Functor (GHC.Generics.Rec1 f_abVHm)
          [LclId] =
              [$dTraversable_sbX27] \u []
                  Data.Traversable.$fTraversableRec1_$cp1Traversable
                      $dTraversable_sbX27;
        } in 
          Data.Traversable.C:Traversable [sat_sbX28
                                          sat_sbX29
                                          sat_sbX2a
                                          sat_sbX2b
                                          sat_sbX2c
                                          sat_sbX2d];

Data.Traversable.$fTraversablePar1_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.Par1 (f a) -> f (GHC.Generics.Par1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX2e eta_sbX2f]
        case GHC.Base.$p1Applicative $dApplicative_sbX2e of sat_sbX2g {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sbX2g Data.Traversable.$fTraversableDual1 eta_sbX2f;
        };

Data.Traversable.$fTraversablePar1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Generics.Par1 a -> m (GHC.Generics.Par1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX2h eta_sbX2i eta1_sbX2j]
        let {
          sat_sbX2m [Occ=Once] :: m_abVJ7 b_abVJ9
          [LclId] =
              [eta_sbX2i eta1_sbX2j] \u [] eta_sbX2i eta1_sbX2j;
        } in 
          case GHC.Base.$p1Monad $dMonad_sbX2h of sat_sbX2k {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sbX2k of sat_sbX2l {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sbX2l Data.Traversable.$fTraversableDual1 sat_sbX2m;
                };
          };

Data.Traversable.$fTraversablePar1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.Par1 (m a) -> m (GHC.Generics.Par1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX2n eta_sbX2o]
        case GHC.Base.$p1Monad $dMonad_sbX2n of sat_sbX2p {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sbX2p of sat_sbX2q {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sbX2q Data.Traversable.$fTraversableDual1 eta_sbX2o;
              };
        };

Data.Traversable.$fTraversablePar1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable GHC.Generics.Par1
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorPar1
                                                   Data.Foldable.$fFoldablePar1
                                                   Data.Traversable.$fTraversablePar1_$ctraverse
                                                   Data.Traversable.$fTraversablePar1_$csequenceA
                                                   Data.Traversable.$fTraversablePar1_$cmapM
                                                   Data.Traversable.$fTraversablePar1_$csequence];

Data.Traversable.$fTraversableV1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Generics.V1 a -> m (GHC.Generics.V1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX2r eta_sbX2s eta1_sbX2t]
        case GHC.Base.$p1Monad $dMonad_sbX2r of sat_sbX2u {
          __DEFAULT -> GHC.Base.pure sat_sbX2u eta1_sbX2t;
        };

Data.Traversable.$fTraversableV1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.V1 (m a) -> m (GHC.Generics.V1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX2v eta_sbX2w]
        case GHC.Base.$p1Monad $dMonad_sbX2v of sat_sbX2x {
          __DEFAULT -> GHC.Base.pure sat_sbX2x eta_sbX2w;
        };

$fTraversableV2_rbWTT
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.V1 (f a) -> f (GHC.Generics.V1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX2y z_sbX2z]
        GHC.Base.pure $dApplicative_sbX2y z_sbX2z;

Data.Traversable.$fTraversableV1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable GHC.Generics.V1
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorV1
                                                   Data.Foldable.$fFoldableV1
                                                   Data.Traversable.$fTraversableV1_$ctraverse
                                                   $fTraversableV2_rbWTT
                                                   Data.Traversable.$fTraversableV1_$cmapM
                                                   Data.Traversable.$fTraversableV1_$csequence];

Data.Traversable.$fTraversableIdentity_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Functor.Identity.Identity (f a)
     -> f (Data.Functor.Identity.Identity a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX2A eta_sbX2B]
        case GHC.Base.$p1Applicative $dApplicative_sbX2A of sat_sbX2C {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sbX2C Data.Traversable.$fTraversableDual1 eta_sbX2B;
        };

Data.Traversable.$fTraversableIdentity_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Functor.Identity.Identity a
     -> m (Data.Functor.Identity.Identity b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX2D eta_sbX2E eta1_sbX2F]
        let {
          sat_sbX2I [Occ=Once] :: m_abVL8 b_abVLa
          [LclId] =
              [eta_sbX2E eta1_sbX2F] \u [] eta_sbX2E eta1_sbX2F;
        } in 
          case GHC.Base.$p1Monad $dMonad_sbX2D of sat_sbX2G {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sbX2G of sat_sbX2H {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sbX2H Data.Traversable.$fTraversableDual1 sat_sbX2I;
                };
          };

Data.Traversable.$fTraversableIdentity_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Functor.Identity.Identity (m a)
     -> m (Data.Functor.Identity.Identity a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX2J eta_sbX2K]
        case GHC.Base.$p1Monad $dMonad_sbX2J of sat_sbX2L {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sbX2L of sat_sbX2M {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sbX2M Data.Traversable.$fTraversableDual1 eta_sbX2K;
              };
        };

Data.Traversable.$fTraversableIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Functor.Identity.$fFunctorIdentity
                                                   Data.Functor.Identity.$fFoldableIdentity
                                                   Data.Traversable.$fTraversableIdentity_$ctraverse
                                                   Data.Traversable.$fTraversableIdentity_$csequenceA
                                                   Data.Traversable.$fTraversableIdentity_$cmapM
                                                   Data.Traversable.$fTraversableIdentity_$csequence];

Data.Traversable.$fTraversableProduct_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Internal.Product (f a)
     -> f (Data.Semigroup.Internal.Product a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX2N eta_sbX2O]
        case GHC.Base.$p1Applicative $dApplicative_sbX2N of sat_sbX2P {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sbX2P Data.Traversable.$fTraversableDual1 eta_sbX2O;
        };

Data.Traversable.$fTraversableProduct_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Semigroup.Internal.Product a
     -> m (Data.Semigroup.Internal.Product b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX2Q eta_sbX2R eta1_sbX2S]
        let {
          sat_sbX2V [Occ=Once] :: m_abVQs b_abVQu
          [LclId] =
              [eta_sbX2R eta1_sbX2S] \u [] eta_sbX2R eta1_sbX2S;
        } in 
          case GHC.Base.$p1Monad $dMonad_sbX2Q of sat_sbX2T {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sbX2T of sat_sbX2U {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sbX2U Data.Traversable.$fTraversableDual1 sat_sbX2V;
                };
          };

Data.Traversable.$fTraversableProduct_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Internal.Product (m a)
     -> m (Data.Semigroup.Internal.Product a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX2W eta_sbX2X]
        case GHC.Base.$p1Monad $dMonad_sbX2W of sat_sbX2Y {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sbX2Y of sat_sbX2Z {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sbX2Z Data.Traversable.$fTraversableDual1 eta_sbX2X;
              };
        };

Data.Traversable.$fTraversableProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Internal.Product
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.Internal.$fFunctorProduct
                                                   Data.Foldable.$fFoldableProduct
                                                   Data.Traversable.$fTraversableProduct_$ctraverse
                                                   Data.Traversable.$fTraversableProduct_$csequenceA
                                                   Data.Traversable.$fTraversableProduct_$cmapM
                                                   Data.Traversable.$fTraversableProduct_$csequence];

Data.Traversable.$fTraversableSum_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Internal.Sum (f a)
     -> f (Data.Semigroup.Internal.Sum a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX30 eta_sbX31]
        case GHC.Base.$p1Applicative $dApplicative_sbX30 of sat_sbX32 {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sbX32 Data.Traversable.$fTraversableDual1 eta_sbX31;
        };

Data.Traversable.$fTraversableSum_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Semigroup.Internal.Sum a
     -> m (Data.Semigroup.Internal.Sum b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX33 eta_sbX34 eta1_sbX35]
        let {
          sat_sbX38 [Occ=Once] :: m_abVRs b_abVRu
          [LclId] =
              [eta_sbX34 eta1_sbX35] \u [] eta_sbX34 eta1_sbX35;
        } in 
          case GHC.Base.$p1Monad $dMonad_sbX33 of sat_sbX36 {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sbX36 of sat_sbX37 {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sbX37 Data.Traversable.$fTraversableDual1 sat_sbX38;
                };
          };

Data.Traversable.$fTraversableSum_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Internal.Sum (m a)
     -> m (Data.Semigroup.Internal.Sum a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX39 eta_sbX3a]
        case GHC.Base.$p1Monad $dMonad_sbX39 of sat_sbX3b {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sbX3b of sat_sbX3c {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sbX3c Data.Traversable.$fTraversableDual1 eta_sbX3a;
              };
        };

Data.Traversable.$fTraversableSum [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Internal.Sum
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.Internal.$fFunctorSum
                                                   Data.Foldable.$fFoldableSum
                                                   Data.Traversable.$fTraversableSum_$ctraverse
                                                   Data.Traversable.$fTraversableSum_$csequenceA
                                                   Data.Traversable.$fTraversableSum_$cmapM
                                                   Data.Traversable.$fTraversableSum_$csequence];

Data.Traversable.$fTraversableDual_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Internal.Dual (f a)
     -> f (Data.Semigroup.Internal.Dual a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX3d eta_sbX3e]
        case GHC.Base.$p1Applicative $dApplicative_sbX3d of sat_sbX3f {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sbX3f Data.Traversable.$fTraversableDual1 eta_sbX3e;
        };

Data.Traversable.$fTraversableDual_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Semigroup.Internal.Dual a
     -> m (Data.Semigroup.Internal.Dual b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX3g eta_sbX3h eta1_sbX3i]
        let {
          sat_sbX3l [Occ=Once] :: m_abVSs b_abVSu
          [LclId] =
              [eta_sbX3h eta1_sbX3i] \u [] eta_sbX3h eta1_sbX3i;
        } in 
          case GHC.Base.$p1Monad $dMonad_sbX3g of sat_sbX3j {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sbX3j of sat_sbX3k {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sbX3k Data.Traversable.$fTraversableDual1 sat_sbX3l;
                };
          };

Data.Traversable.$fTraversableDual_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Internal.Dual (m a)
     -> m (Data.Semigroup.Internal.Dual a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX3m eta_sbX3n]
        case GHC.Base.$p1Monad $dMonad_sbX3m of sat_sbX3o {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sbX3o of sat_sbX3p {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sbX3p Data.Traversable.$fTraversableDual1 eta_sbX3n;
              };
        };

Data.Traversable.$fTraversableDual [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Internal.Dual
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.Internal.$fFunctorDual
                                                   Data.Foldable.$fFoldableDual
                                                   Data.Traversable.$fTraversableDual_$ctraverse
                                                   Data.Traversable.$fTraversableDual_$csequenceA
                                                   Data.Traversable.$fTraversableDual_$cmapM
                                                   Data.Traversable.$fTraversableDual_$csequence];

Data.Traversable.$fTraversableConst_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall m1 (m2 :: * -> *) a b.
     GHC.Base.Monad m2 =>
     (a -> m2 b)
     -> Data.Functor.Const.Const m1 a
     -> m2 (Data.Functor.Const.Const m1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX3q eta_sbX3r eta1_sbX3s]
        case GHC.Base.$p1Monad $dMonad_sbX3q of sat_sbX3t {
          __DEFAULT -> GHC.Base.pure sat_sbX3t eta1_sbX3s;
        };

Data.Traversable.$fTraversableConst_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall m1 (m2 :: * -> *) a.
     GHC.Base.Monad m2 =>
     Data.Functor.Const.Const m1 (m2 a)
     -> m2 (Data.Functor.Const.Const m1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX3u eta_sbX3v]
        case GHC.Base.$p1Monad $dMonad_sbX3u of sat_sbX3w {
          __DEFAULT -> GHC.Base.pure sat_sbX3w eta_sbX3v;
        };

$fTraversableConst1_rbWTU
  :: forall m (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Functor.Const.Const m (f a)
     -> f (Data.Functor.Const.Const m a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX3x ds_sbX3y]
        GHC.Base.pure $dApplicative_sbX3x ds_sbX3y;

Data.Traversable.$fTraversableConst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     Data.Traversable.Traversable (Data.Functor.Const.Const m)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Functor.Const.$fFunctorConst
                                                   Data.Functor.Const.$fFoldableConst
                                                   Data.Traversable.$fTraversableConst_$ctraverse
                                                   $fTraversableConst1_rbWTU
                                                   Data.Traversable.$fTraversableConst_$cmapM
                                                   Data.Traversable.$fTraversableConst_$csequence];

Data.Traversable.$fTraversable(,)_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (f :: * -> *) a2.
     GHC.Base.Applicative f =>
     (a1, f a2) -> f (a1, a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX3z eta_sbX3A]
        case eta_sbX3A of {
          (,) x_sbX3C [Occ=OnceL] y_sbX3D [Occ=Once] ->
              let {
                sat_sbX3F [Occ=Once] :: a1_abVWL -> (a_abVWj, a1_abVWL)
                [LclId] =
                    [x_sbX3C] \r [eta_B1] (,) [x_sbX3C eta_B1];
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbX3z of sat_sbX3E {
                  __DEFAULT -> GHC.Base.fmap sat_sbX3E sat_sbX3F y_sbX3D;
                };
        };

Data.Traversable.$fTraversable(,)_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2 b.
     GHC.Base.Monad m =>
     (a2 -> m b) -> (a1, a2) -> m (a1, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX3G eta_sbX3H eta1_sbX3I]
        case eta1_sbX3I of {
          (,) x_sbX3K [Occ=OnceL] y_sbX3L [Occ=Once] ->
              let {
                sat_sbX3P [Occ=Once] :: m_abVWW b_abVWY
                [LclId] =
                    [eta_sbX3H y_sbX3L] \u [] eta_sbX3H y_sbX3L; } in
              let {
                sat_sbX3O [Occ=Once] :: b_abVWY -> (a_abVWj, b_abVWY)
                [LclId] =
                    [x_sbX3K] \r [eta_B1] (,) [x_sbX3K eta_B1];
              } in 
                case GHC.Base.$p1Monad $dMonad_sbX3G of sat_sbX3M {
                  __DEFAULT ->
                      case GHC.Base.$p1Applicative sat_sbX3M of sat_sbX3N {
                        __DEFAULT -> GHC.Base.fmap sat_sbX3N sat_sbX3O sat_sbX3P;
                      };
                };
        };

Data.Traversable.$fTraversable(,)_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2.
     GHC.Base.Monad m =>
     (a1, m a2) -> m (a1, a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX3Q eta_sbX3R]
        case eta_sbX3R of {
          (,) x_sbX3T [Occ=OnceL] y_sbX3U [Occ=Once] ->
              let {
                sat_sbX3X [Occ=Once] :: a1_abVXb -> (a_abVWj, a1_abVXb)
                [LclId] =
                    [x_sbX3T] \r [eta_B1] (,) [x_sbX3T eta_B1];
              } in 
                case GHC.Base.$p1Monad $dMonad_sbX3Q of sat_sbX3V {
                  __DEFAULT ->
                      case GHC.Base.$p1Applicative sat_sbX3V of sat_sbX3W {
                        __DEFAULT -> GHC.Base.fmap sat_sbX3W sat_sbX3X y_sbX3U;
                      };
                };
        };

Data.Traversable.$fTraversable(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Traversable.Traversable ((,) a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Base.$fFunctor(,)
                                                   Data.Foldable.$fFoldable(,)
                                                   Data.Traversable.$fTraversable(,)_$ctraverse
                                                   Data.Traversable.$fTraversable(,)_$csequenceA
                                                   Data.Traversable.$fTraversable(,)_$cmapM
                                                   Data.Traversable.$fTraversable(,)_$csequence];

Data.Traversable.$fTraversableEither_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (f :: * -> *) a2.
     GHC.Base.Applicative f =>
     Data.Either.Either a1 (f a2) -> f (Data.Either.Either a1 a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX3Y eta_sbX3Z]
        case eta_sbX3Z of {
          Data.Either.Left x_sbX41 [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbX3Y wild_sbX40;
          Data.Either.Right y_sbX43 [Occ=Once] ->
              case GHC.Base.$p1Applicative $dApplicative_sbX3Y of sat_sbX44 {
                __DEFAULT -> GHC.Base.fmap sat_sbX44 Data.Either.Right y_sbX43;
              };
        };

Data.Traversable.$fTraversableEither_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2 b.
     GHC.Base.Monad m =>
     (a2 -> m b)
     -> Data.Either.Either a1 a2 -> m (Data.Either.Either a1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX45 eta_sbX46 eta1_sbX47]
        case GHC.Base.$p1Monad $dMonad_sbX45 of sat_sbX48 {
          __DEFAULT ->
              Data.Traversable.$fTraversableEither_$ctraverse
                  sat_sbX48 eta_sbX46 eta1_sbX47;
        };

Data.Traversable.$fTraversableEither_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2.
     GHC.Base.Monad m =>
     Data.Either.Either a1 (m a2) -> m (Data.Either.Either a1 a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX49 eta_sbX4a]
        case eta_sbX4a of {
          Data.Either.Left x_sbX4c [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbX49 of sat_sbX4d {
                __DEFAULT -> GHC.Base.pure sat_sbX4d wild_sbX4b;
              };
          Data.Either.Right y_sbX4f [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbX49 of sat_sbX4g {
                __DEFAULT ->
                    case GHC.Base.$p1Applicative sat_sbX4g of sat_sbX4h {
                      __DEFAULT -> GHC.Base.fmap sat_sbX4h Data.Either.Right y_sbX4f;
                    };
              };
        };

Data.Traversable.$fTraversableEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Traversable.Traversable (Data.Either.Either a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Either.$fFunctorEither
                                                   Data.Foldable.$fFoldableEither
                                                   Data.Traversable.$fTraversableEither_$ctraverse
                                                   Data.Traversable.$fTraversableEither_$csequenceA
                                                   Data.Traversable.$fTraversableEither_$cmapM
                                                   Data.Traversable.$fTraversableEither_$csequence];

Data.Traversable.$fTraversable[]_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a. GHC.Base.Applicative f => [f a] -> f [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,1*C1(U),A,C(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX4i]
        let {
          z_sbX4j [Occ=OnceL] :: f_abW0j [a_abW0k]
          [LclId] =
              [$dApplicative_sbX4i] \u []
                  GHC.Base.pure $dApplicative_sbX4i GHC.Types.[]; } in
        let {
          go_sbX4k [Occ=LoopBreaker]
            :: [f_abW0j a_abW0k] -> f_abW0j [a_abW0k]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [$dApplicative_sbX4i z_sbX4j go_sbX4k] \r [ds_sbX4l]
                  case ds_sbX4l of {
                    [] -> z_sbX4j;
                    : y_sbX4n [Occ=Once] ys_sbX4o [Occ=Once] ->
                        let {
                          sat_sbX4p [Occ=Once] :: f_abW0j [a_abW0k]
                          [LclId] =
                              [go_sbX4k ys_sbX4o] \u [] go_sbX4k ys_sbX4o;
                        } in 
                          GHC.Base.liftA2 $dApplicative_sbX4i GHC.Types.: y_sbX4n sat_sbX4p;
                  };
        } in  go_sbX4k;

Data.Traversable.$fTraversable[]_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> [a] -> m [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX4q eta_sbX4r]
        let {
          $dApplicative_sbX4s [Dmd=<L,U(A,1*C1(U),A,C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative m_abW0v
          [LclId] =
              [$dMonad_sbX4q] \u [] GHC.Base.$p1Monad $dMonad_sbX4q; } in
        let {
          z_sbX4t [Occ=OnceL] :: m_abW0v [b_abW0x]
          [LclId] =
              [$dApplicative_sbX4s] \u []
                  GHC.Base.pure $dApplicative_sbX4s GHC.Types.[]; } in
        let {
          go_sbX4u [Occ=LoopBreaker] :: [a_abW0w] -> m_abW0v [b_abW0x]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [eta_sbX4r $dApplicative_sbX4s z_sbX4t go_sbX4u] \r [ds_sbX4v]
                  case ds_sbX4v of {
                    [] -> z_sbX4t;
                    : y_sbX4x [Occ=Once] ys_sbX4y [Occ=Once] ->
                        let {
                          sat_sbX4A [Occ=Once] :: m_abW0v [b_abW0x]
                          [LclId] =
                              [go_sbX4u ys_sbX4y] \u [] go_sbX4u ys_sbX4y; } in
                        let {
                          sat_sbX4z [Occ=Once] :: m_abW0v b_abW0x
                          [LclId] =
                              [eta_sbX4r y_sbX4x] \u [] eta_sbX4r y_sbX4x;
                        } in 
                          GHC.Base.liftA2
                              $dApplicative_sbX4s GHC.Types.: sat_sbX4z sat_sbX4A;
                  };
        } in  go_sbX4u;

Data.Traversable.$fTraversable[]_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a. GHC.Base.Monad m => [m a] -> m [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX4B]
        let {
          $dApplicative_sbX4C [Dmd=<L,U(A,1*C1(U),A,C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative m_abW0J
          [LclId] =
              [$dMonad_sbX4B] \u [] GHC.Base.$p1Monad $dMonad_sbX4B; } in
        let {
          z_sbX4D [Occ=OnceL] :: m_abW0J [a_abW0K]
          [LclId] =
              [$dApplicative_sbX4C] \u []
                  GHC.Base.pure $dApplicative_sbX4C GHC.Types.[]; } in
        let {
          go_sbX4E [Occ=LoopBreaker]
            :: [m_abW0J a_abW0K] -> m_abW0J [a_abW0K]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [$dApplicative_sbX4C z_sbX4D go_sbX4E] \r [ds_sbX4F]
                  case ds_sbX4F of {
                    [] -> z_sbX4D;
                    : y_sbX4H [Occ=Once] ys_sbX4I [Occ=Once] ->
                        let {
                          sat_sbX4J [Occ=Once] :: m_abW0J [a_abW0K]
                          [LclId] =
                              [go_sbX4E ys_sbX4I] \u [] go_sbX4E ys_sbX4I;
                        } in 
                          GHC.Base.liftA2 $dApplicative_sbX4C GHC.Types.: y_sbX4H sat_sbX4J;
                  };
        } in  go_sbX4E;

Data.Traversable.$fTraversable[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable []
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Base.$fFunctor[]
                                                   Data.Foldable.$fFoldable[]
                                                   Data.Traversable.$fTraversable[]_$ctraverse
                                                   Data.Traversable.$fTraversable[]_$csequenceA
                                                   Data.Traversable.$fTraversable[]_$cmapM
                                                   Data.Traversable.$fTraversable[]_$csequence];

Data.Traversable.$fTraversableZipList1 :: forall b. [b] -> [b]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbX4K] v_sbX4K;

Data.Traversable.$fTraversableZipList_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Control.Applicative.ZipList a
     -> f (Control.Applicative.ZipList b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A)><L,C(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX4L eta_sbX4M eta1_sbX4N]
        let {
          sat_sbX4X [Occ=Once] :: f_abVMK [b_abVMM]
          [LclId] =
              [$dApplicative_sbX4L eta_sbX4M eta1_sbX4N] \u []
                  let {
                    z_sbX4P [Occ=OnceL] :: f_abVMK [b_abVMM]
                    [LclId] =
                        [$dApplicative_sbX4L] \u []
                            GHC.Base.pure $dApplicative_sbX4L GHC.Types.[]; } in
                  let {
                    go_sbX4Q [Occ=LoopBreaker] :: [a_abVML] -> f_abVMK [b_abVMM]
                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                        sat-only [$dApplicative_sbX4L
                                  eta_sbX4M
                                  z_sbX4P
                                  go_sbX4Q] \r [ds_sbX4R]
                            case ds_sbX4R of {
                              [] -> z_sbX4P;
                              : y_sbX4T [Occ=Once] ys_sbX4U [Occ=Once] ->
                                  let {
                                    sat_sbX4W [Occ=Once] :: f_abVMK [b_abVMM]
                                    [LclId] =
                                        [go_sbX4Q ys_sbX4U] \u [] go_sbX4Q ys_sbX4U; } in
                                  let {
                                    sat_sbX4V [Occ=Once] :: f_abVMK b_abVMM
                                    [LclId] =
                                        [eta_sbX4M y_sbX4T] \u [] eta_sbX4M y_sbX4T;
                                  } in 
                                    GHC.Base.liftA2
                                        $dApplicative_sbX4L GHC.Types.: sat_sbX4V sat_sbX4W;
                            };
                  } in  go_sbX4Q eta1_sbX4N;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbX4L of sat_sbX4O {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sbX4O Data.Traversable.$fTraversableZipList1 sat_sbX4X;
          };

Data.Traversable.$fTraversableZipList_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Control.Applicative.ZipList (f a)
     -> f (Control.Applicative.ZipList a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX4Y eta_B1]
        Data.Traversable.$fTraversableZipList_$ctraverse
            $dApplicative_sbX4Y GHC.Base.id eta_B1;

Data.Traversable.$fTraversableZipList_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Control.Applicative.ZipList a
     -> m (Control.Applicative.ZipList b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX4Z eta_sbX50 eta1_sbX51]
        case GHC.Base.$p1Monad $dMonad_sbX4Z of sat_sbX52 {
          __DEFAULT ->
              Data.Traversable.$fTraversableZipList_$ctraverse
                  sat_sbX52 eta_sbX50 eta1_sbX51;
        };

Data.Traversable.$fTraversableZipList_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Control.Applicative.ZipList (m a)
     -> m (Control.Applicative.ZipList a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX53 eta_sbX54]
        case GHC.Base.$p1Monad $dMonad_sbX53 of sat_sbX55 {
          __DEFAULT ->
              Data.Traversable.$fTraversableZipList_$ctraverse
                  sat_sbX55 GHC.Base.id eta_sbX54;
        };

Data.Traversable.$fTraversableZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Control.Applicative.ZipList
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Control.Applicative.$fFunctorZipList
                                                   Control.Applicative.$fFoldableZipList
                                                   Data.Traversable.$fTraversableZipList_$ctraverse
                                                   Data.Traversable.$fTraversableZipList_$csequenceA
                                                   Data.Traversable.$fTraversableZipList_$cmapM
                                                   Data.Traversable.$fTraversableZipList_$csequence];

Data.Traversable.$fTraversableArray_$ctraverse
  :: forall i.
     GHC.Arr.Ix i =>
     forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Arr.Array i a -> f (GHC.Arr.Array i b)
[GblId,
 Arity=4,
 Str=<L,U(A,A,A,A,A,C(U(U)),A)><S(S(C(C(S))L)LLLLL),U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A)><L,C(U)><L,U(U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIx_sbX56 $dApplicative_sbX57 eta_sbX58 eta1_sbX59]
        let {
          sat_sbX5u [Occ=Once] :: f_abVVc [b_abVVe]
          [LclId] =
              [$dApplicative_sbX57 eta_sbX58 eta1_sbX59] \u []
                  case eta1_sbX59 of {
                    GHC.Arr.Array _ [Occ=Dead]
                                  _ [Occ=Dead]
                                  dt_sbX5g [Occ=Once]
                                  ds2_sbX5h [Occ=OnceL] ->
                        case -# [dt_sbX5g 1#] of y_sbX5i [Dmd=<S,U>] {
                          __DEFAULT ->
                              let {
                                n_sbX5j [Occ=OnceL*] :: f_abVVc [b_abVVe]
                                [LclId] =
                                    [$dApplicative_sbX57] \u []
                                        GHC.Base.pure $dApplicative_sbX57 GHC.Types.[];
                              } in 
                                case ># [0# y_sbX5i] of {
                                  __DEFAULT ->
                                      let {
                                        go_sbX5l [Occ=LoopBreaker]
                                          :: GHC.Prim.Int# -> f_abVVc [b_abVVe]
                                        [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                                            sat-only [$dApplicative_sbX57
                                                      eta_sbX58
                                                      ds2_sbX5h
                                                      y_sbX5i
                                                      n_sbX5j
                                                      go_sbX5l] \r [x_sbX5m]
                                                let {
                                                  sat_sbX5t [Occ=Once] :: f_abVVc [b_abVVe]
                                                  [LclId] =
                                                      [y_sbX5i n_sbX5j go_sbX5l x_sbX5m] \u []
                                                          case ==# [x_sbX5m y_sbX5i] of {
                                                            __DEFAULT ->
                                                                case +# [x_sbX5m 1#] of sat_sbX5s {
                                                                  __DEFAULT -> go_sbX5l sat_sbX5s;
                                                                };
                                                            1# -> n_sbX5j;
                                                          }; } in
                                                let {
                                                  sat_sbX5q [Occ=Once] :: f_abVVc b_abVVe
                                                  [LclId] =
                                                      [eta_sbX58 ds2_sbX5h x_sbX5m] \u []
                                                          let {
                                                            sat_sbX5p [Occ=Once] :: a_abVVd
                                                            [LclId] =
                                                                [ds2_sbX5h x_sbX5m] \u []
                                                                    case
                                                                        indexArray# [ds2_sbX5h
                                                                                     x_sbX5m]
                                                                    of
                                                                    { Unit# ipv_sbX5o [Occ=Once] ->
                                                                          ipv_sbX5o;
                                                                    };
                                                          } in  eta_sbX58 sat_sbX5p;
                                                } in 
                                                  GHC.Base.liftA2
                                                      $dApplicative_sbX57
                                                      GHC.Types.:
                                                      sat_sbX5q
                                                      sat_sbX5t;
                                      } in  go_sbX5l 0#;
                                  1# -> n_sbX5j;
                                };
                        };
                  }; } in
        let {
          sat_sbX5b [Occ=OnceL] :: (i_abVUZ, i_abVUZ)
          [LclId] =
              [eta1_sbX59] \u [] GHC.Arr.bounds eta1_sbX59; } in
        let {
          sat_sbX5c [Occ=Once] :: [b_abVVe] -> GHC.Arr.Array i_abVUZ b_abVVe
          [LclId] =
              [$dIx_sbX56 sat_sbX5b] \r [eta_B1]
                  GHC.Arr.listArray $dIx_sbX56 sat_sbX5b eta_B1;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbX57 of sat_sbX5a {
            __DEFAULT -> GHC.Base.fmap sat_sbX5a sat_sbX5c sat_sbX5u;
          };

Data.Traversable.$fTraversableArray_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall i.
     GHC.Arr.Ix i =>
     forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Arr.Array i (f a) -> f (GHC.Arr.Array i a)
[GblId,
 Arity=3,
 Str=<L,U(A,A,A,A,A,C(U(U)),A)><L,U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIx_sbX5v $dApplicative_sbX5w eta_B1]
        Data.Traversable.$fTraversableArray_$ctraverse
            $dIx_sbX5v $dApplicative_sbX5w GHC.Base.id eta_B1;

Data.Traversable.$fTraversableArray_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall i.
     GHC.Arr.Ix i =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Arr.Array i a -> m (GHC.Arr.Array i b)
[GblId,
 Arity=4,
 Str=<L,U(A,A,A,A,A,C(U(U)),A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><L,U(U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIx_sbX5x $dMonad_sbX5y eta_sbX5z eta1_sbX5A]
        case GHC.Base.$p1Monad $dMonad_sbX5y of sat_sbX5B {
          __DEFAULT ->
              Data.Traversable.$fTraversableArray_$ctraverse
                  $dIx_sbX5x sat_sbX5B eta_sbX5z eta1_sbX5A;
        };

Data.Traversable.$fTraversableArray_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall i.
     GHC.Arr.Ix i =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Arr.Array i (m a) -> m (GHC.Arr.Array i a)
[GblId,
 Arity=3,
 Str=<L,U(A,A,A,A,A,C(U(U)),A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,U(U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIx_sbX5C $dMonad_sbX5D eta_sbX5E]
        case GHC.Base.$p1Monad $dMonad_sbX5D of sat_sbX5F {
          __DEFAULT ->
              Data.Traversable.$fTraversableArray_$ctraverse
                  $dIx_sbX5C sat_sbX5F GHC.Base.id eta_sbX5E;
        };

Data.Traversable.$fTraversableArray [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i.
     GHC.Arr.Ix i =>
     Data.Traversable.Traversable (GHC.Arr.Array i)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,A,A,C(U(U)),A)>m] =
    [] \r [$dIx_sbX5G]
        let {
          sat_sbX5K [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               GHC.Arr.Array i_abVUZ (m a) -> m (GHC.Arr.Array i_abVUZ a)
          [LclId] =
              [$dIx_sbX5G] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableArray_$csequence
                      $dIx_sbX5G eta_B2 eta_B1; } in
        let {
          sat_sbX5J [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> GHC.Arr.Array i_abVUZ a -> m (GHC.Arr.Array i_abVUZ b)
          [LclId] =
              [$dIx_sbX5G] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableArray_$cmapM
                      $dIx_sbX5G eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbX5I [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               GHC.Arr.Array i_abVUZ (f a) -> f (GHC.Arr.Array i_abVUZ a)
          [LclId] =
              [$dIx_sbX5G] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableArray_$csequenceA
                      $dIx_sbX5G eta_B2 eta_B1; } in
        let {
          sat_sbX5H [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> GHC.Arr.Array i_abVUZ a -> f (GHC.Arr.Array i_abVUZ b)
          [LclId] =
              [$dIx_sbX5G] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableArray_$ctraverse
                      $dIx_sbX5G eta_B3 eta_B2 eta_B1;
        } in 
          Data.Traversable.C:Traversable [GHC.Arr.$fFunctorArray
                                          Data.Foldable.$fFoldableArray
                                          sat_sbX5H
                                          sat_sbX5I
                                          sat_sbX5J
                                          sat_sbX5K];

Data.Traversable.$fTraversableNonEmpty_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Base.NonEmpty a -> f (GHC.Base.NonEmpty b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),U(A,1*C1(U),A,C(C1(C1(U))),A,A)><L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX5L f1_sbX5M ds_sbX5N]
        let {
          sat_sbX64 [Occ=Once] :: f_abVYD [b_abVYF]
          [LclId] =
              [$dApplicative_sbX5L f1_sbX5M ds_sbX5N] \u []
                  case ds_sbX5N of {
                    GHC.Base.:| _ [Occ=Dead] as_sbX5V [Occ=Once] ->
                        let {
                          z_sbX5W [Occ=OnceL] :: f_abVYD [b_abVYF]
                          [LclId] =
                              [$dApplicative_sbX5L] \u []
                                  GHC.Base.pure $dApplicative_sbX5L GHC.Types.[]; } in
                        let {
                          go_sbX5X [Occ=LoopBreaker] :: [a_abVYE] -> f_abVYD [b_abVYF]
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [$dApplicative_sbX5L
                                        f1_sbX5M
                                        z_sbX5W
                                        go_sbX5X] \r [ds1_sbX5Y]
                                  case ds1_sbX5Y of {
                                    [] -> z_sbX5W;
                                    : y_sbX60 [Occ=Once] ys_sbX61 [Occ=Once] ->
                                        let {
                                          sat_sbX63 [Occ=Once] :: f_abVYD [b_abVYF]
                                          [LclId] =
                                              [go_sbX5X ys_sbX61] \u [] go_sbX5X ys_sbX61; } in
                                        let {
                                          sat_sbX62 [Occ=Once] :: f_abVYD b_abVYF
                                          [LclId] =
                                              [f1_sbX5M y_sbX60] \u [] f1_sbX5M y_sbX60;
                                        } in 
                                          GHC.Base.liftA2
                                              $dApplicative_sbX5L GHC.Types.: sat_sbX62 sat_sbX63;
                                  };
                        } in  go_sbX5X as_sbX5V;
                  }; } in
        let {
          sat_sbX5S [Occ=Once] :: f_abVYD b_abVYF
          [LclId] =
              [f1_sbX5M ds_sbX5N] \u []
                  let {
                    sat_sbX5R [Occ=Once] :: a_abVYE
                    [LclId] =
                        [ds_sbX5N] \u []
                            case ds_sbX5N of {
                              GHC.Base.:| a1_sbX5P [Occ=Once] _ [Occ=Dead] -> a1_sbX5P;
                            };
                  } in  f1_sbX5M sat_sbX5R;
        } in 
          GHC.Base.liftA2
              $dApplicative_sbX5L GHC.Base.:| sat_sbX5S sat_sbX64;

Data.Traversable.$fTraversableNonEmpty_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Base.NonEmpty (f a) -> f (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,C(U),A,C(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX65 eta_B1]
        Data.Traversable.$fTraversableNonEmpty_$ctraverse
            $dApplicative_sbX65 GHC.Base.id eta_B1;

Data.Traversable.$fTraversableNonEmpty_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Base.NonEmpty a -> m (GHC.Base.NonEmpty b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(A,1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX66 eta_sbX67 eta1_sbX68]
        case GHC.Base.$p1Monad $dMonad_sbX66 of sat_sbX69 {
          __DEFAULT ->
              Data.Traversable.$fTraversableNonEmpty_$ctraverse
                  sat_sbX69 eta_sbX67 eta1_sbX68;
        };

Data.Traversable.$fTraversableNonEmpty_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Base.NonEmpty (m a) -> m (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(A,1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX6a eta_sbX6b]
        case GHC.Base.$p1Monad $dMonad_sbX6a of sat_sbX6c {
          __DEFAULT ->
              Data.Traversable.$fTraversableNonEmpty_$ctraverse
                  sat_sbX6c GHC.Base.id eta_sbX6b;
        };

Data.Traversable.$fTraversableNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable GHC.Base.NonEmpty
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Base.$fFunctorNonEmpty
                                                   Data.Foldable.$fFoldableNonEmpty
                                                   Data.Traversable.$fTraversableNonEmpty_$ctraverse
                                                   Data.Traversable.$fTraversableNonEmpty_$csequenceA
                                                   Data.Traversable.$fTraversableNonEmpty_$cmapM
                                                   Data.Traversable.$fTraversableNonEmpty_$csequence];

Data.Traversable.$fTraversableMaybe_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Base.Maybe (f a) -> f (GHC.Base.Maybe a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX6d eta_sbX6e]
        case eta_sbX6e of {
          GHC.Base.Nothing ->
              GHC.Base.pure $dApplicative_sbX6d GHC.Base.Nothing;
          GHC.Base.Just x_sbX6g [Occ=Once] ->
              case GHC.Base.$p1Applicative $dApplicative_sbX6d of sat_sbX6h {
                __DEFAULT -> GHC.Base.fmap sat_sbX6h GHC.Base.Just x_sbX6g;
              };
        };

Data.Traversable.$fTraversableMaybe_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Base.Maybe a -> m (GHC.Base.Maybe b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX6i eta_sbX6j eta1_sbX6k]
        case GHC.Base.$p1Monad $dMonad_sbX6i of sat_sbX6l {
          __DEFAULT ->
              Data.Traversable.$fTraversableFirst_$ctraverse
                  sat_sbX6l eta_sbX6j eta1_sbX6k;
        };

Data.Traversable.$fTraversableMaybe_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Base.Maybe (m a) -> m (GHC.Base.Maybe a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX6m eta_sbX6n]
        case eta_sbX6n of {
          GHC.Base.Nothing ->
              case GHC.Base.$p1Monad $dMonad_sbX6m of sat_sbX6p {
                __DEFAULT -> GHC.Base.pure sat_sbX6p GHC.Base.Nothing;
              };
          GHC.Base.Just x_sbX6q [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbX6m of sat_sbX6r {
                __DEFAULT ->
                    case GHC.Base.$p1Applicative sat_sbX6r of sat_sbX6s {
                      __DEFAULT -> GHC.Base.fmap sat_sbX6s GHC.Base.Just x_sbX6q;
                    };
              };
        };

Data.Traversable.$fTraversableMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable GHC.Base.Maybe
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Base.$fFunctorMaybe
                                                   Data.Foldable.$fFoldableMaybe
                                                   Data.Traversable.$fTraversableFirst_$ctraverse
                                                   Data.Traversable.$fTraversableMaybe_$csequenceA
                                                   Data.Traversable.$fTraversableMaybe_$cmapM
                                                   Data.Traversable.$fTraversableMaybe_$csequence];

Data.Traversable.$fTraversableFirst1
  :: forall b. GHC.Base.Maybe b -> GHC.Base.Maybe b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbX6t] v_sbX6t;

Data.Traversable.$fTraversableLast_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Monoid.Last a -> f (Data.Monoid.Last b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX6u eta_sbX6v eta1_sbX6w]
        let {
          sat_sbX6y [Occ=Once] :: f_abVNQ (GHC.Base.Maybe b_abVNS)
          [LclId] =
              [$dApplicative_sbX6u eta_sbX6v eta1_sbX6w] \u []
                  Data.Traversable.$fTraversableFirst_$ctraverse
                      $dApplicative_sbX6u eta_sbX6v eta1_sbX6w;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbX6u of sat_sbX6x {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sbX6x Data.Traversable.$fTraversableFirst1 sat_sbX6y;
          };

Data.Traversable.$fTraversableLast_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Monoid.Last (f a) -> f (Data.Monoid.Last a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX6z eta_sbX6A]
        let {
          sat_sbX6F [Occ=Once] :: f_abVOa (GHC.Base.Maybe a_abVOb)
          [LclId] =
              [$dApplicative_sbX6z eta_sbX6A] \u []
                  case eta_sbX6A of {
                    GHC.Base.Nothing ->
                        GHC.Base.pure $dApplicative_sbX6z GHC.Base.Nothing;
                    GHC.Base.Just x_sbX6D [Occ=Once] ->
                        case GHC.Base.$p1Applicative $dApplicative_sbX6z of sat_sbX6E {
                          __DEFAULT -> GHC.Base.fmap sat_sbX6E GHC.Base.Just x_sbX6D;
                        };
                  };
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbX6z of sat_sbX6B {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sbX6B Data.Traversable.$fTraversableFirst1 sat_sbX6F;
          };

Data.Traversable.$fTraversableLast_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Monoid.Last a -> m (Data.Monoid.Last b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(C(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX6G eta_sbX6H eta1_sbX6I]
        case
            GHC.Base.$p1Monad $dMonad_sbX6G
        of
        $dApplicative_sbX6J [Dmd=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              let {
                sat_sbX6L [Occ=Once] :: m_abVOm (GHC.Base.Maybe b_abVOo)
                [LclId] =
                    [eta_sbX6H eta1_sbX6I $dApplicative_sbX6J] \u []
                        Data.Traversable.$fTraversableFirst_$ctraverse
                            $dApplicative_sbX6J eta_sbX6H eta1_sbX6I;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbX6J of sat_sbX6K {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sbX6K Data.Traversable.$fTraversableFirst1 sat_sbX6L;
                };
        };

Data.Traversable.$fTraversableLast_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Monoid.Last (m a) -> m (Data.Monoid.Last a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(C(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX6M eta_sbX6N]
        case
            GHC.Base.$p1Monad $dMonad_sbX6M
        of
        $dApplicative_sbX6O [Dmd=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              let {
                sat_sbX6T [Occ=Once] :: m_abVOA (GHC.Base.Maybe a_abVOB)
                [LclId] =
                    [eta_sbX6N $dApplicative_sbX6O] \u []
                        case eta_sbX6N of {
                          GHC.Base.Nothing ->
                              GHC.Base.pure $dApplicative_sbX6O GHC.Base.Nothing;
                          GHC.Base.Just x_sbX6R [Occ=Once] ->
                              case GHC.Base.$p1Applicative $dApplicative_sbX6O of sat_sbX6S {
                                __DEFAULT -> GHC.Base.fmap sat_sbX6S GHC.Base.Just x_sbX6R;
                              };
                        };
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbX6O of sat_sbX6P {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sbX6P Data.Traversable.$fTraversableFirst1 sat_sbX6T;
                };
        };

Data.Traversable.$fTraversableLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Monoid.Last
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Monoid.$fFunctorLast
                                                   Data.Foldable.$fFoldableLast
                                                   Data.Traversable.$fTraversableLast_$ctraverse
                                                   Data.Traversable.$fTraversableLast_$csequenceA
                                                   Data.Traversable.$fTraversableLast_$cmapM
                                                   Data.Traversable.$fTraversableLast_$csequence];

Data.Traversable.$fTraversableFirst_$ctraverse1
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Monoid.First a -> f (Data.Monoid.First b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX6U eta_sbX6V eta1_sbX6W]
        let {
          sat_sbX6Y [Occ=Once] :: f_abVOW (GHC.Base.Maybe b_abVOY)
          [LclId] =
              [$dApplicative_sbX6U eta_sbX6V eta1_sbX6W] \u []
                  Data.Traversable.$fTraversableFirst_$ctraverse
                      $dApplicative_sbX6U eta_sbX6V eta1_sbX6W;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbX6U of sat_sbX6X {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sbX6X Data.Traversable.$fTraversableFirst1 sat_sbX6Y;
          };

Data.Traversable.$fTraversableFirst_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Monoid.First (f a) -> f (Data.Monoid.First a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX6Z eta_sbX70]
        let {
          sat_sbX75 [Occ=Once] :: f_abVPg (GHC.Base.Maybe a_abVPh)
          [LclId] =
              [$dApplicative_sbX6Z eta_sbX70] \u []
                  case eta_sbX70 of {
                    GHC.Base.Nothing ->
                        GHC.Base.pure $dApplicative_sbX6Z GHC.Base.Nothing;
                    GHC.Base.Just x_sbX73 [Occ=Once] ->
                        case GHC.Base.$p1Applicative $dApplicative_sbX6Z of sat_sbX74 {
                          __DEFAULT -> GHC.Base.fmap sat_sbX74 GHC.Base.Just x_sbX73;
                        };
                  };
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbX6Z of sat_sbX71 {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sbX71 Data.Traversable.$fTraversableFirst1 sat_sbX75;
          };

Data.Traversable.$fTraversableFirst_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Monoid.First a -> m (Data.Monoid.First b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(C(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX76 eta_sbX77 eta1_sbX78]
        case
            GHC.Base.$p1Monad $dMonad_sbX76
        of
        $dApplicative_sbX79 [Dmd=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              let {
                sat_sbX7b [Occ=Once] :: m_abVPs (GHC.Base.Maybe b_abVPu)
                [LclId] =
                    [eta_sbX77 eta1_sbX78 $dApplicative_sbX79] \u []
                        Data.Traversable.$fTraversableFirst_$ctraverse
                            $dApplicative_sbX79 eta_sbX77 eta1_sbX78;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbX79 of sat_sbX7a {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sbX7a Data.Traversable.$fTraversableFirst1 sat_sbX7b;
                };
        };

Data.Traversable.$fTraversableFirst_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Monoid.First (m a) -> m (Data.Monoid.First a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(C(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX7c eta_sbX7d]
        case
            GHC.Base.$p1Monad $dMonad_sbX7c
        of
        $dApplicative_sbX7e [Dmd=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              let {
                sat_sbX7j [Occ=Once] :: m_abVPG (GHC.Base.Maybe a_abVPH)
                [LclId] =
                    [eta_sbX7d $dApplicative_sbX7e] \u []
                        case eta_sbX7d of {
                          GHC.Base.Nothing ->
                              GHC.Base.pure $dApplicative_sbX7e GHC.Base.Nothing;
                          GHC.Base.Just x_sbX7h [Occ=Once] ->
                              case GHC.Base.$p1Applicative $dApplicative_sbX7e of sat_sbX7i {
                                __DEFAULT -> GHC.Base.fmap sat_sbX7i GHC.Base.Just x_sbX7h;
                              };
                        };
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbX7e of sat_sbX7f {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sbX7f Data.Traversable.$fTraversableFirst1 sat_sbX7j;
                };
        };

Data.Traversable.$fTraversableFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Monoid.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Monoid.$fFunctorFirst
                                                   Data.Foldable.$fFoldableFirst
                                                   Data.Traversable.$fTraversableFirst_$ctraverse1
                                                   Data.Traversable.$fTraversableFirst_$csequenceA
                                                   Data.Traversable.$fTraversableFirst_$cmapM
                                                   Data.Traversable.$fTraversableFirst_$csequence];

Data.Traversable.$dmtraverse [InlPrag=INLINE (sat-args=1)]
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> t a -> f (t b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*C1(C(U)),A),A,A,1*C1(C(U)),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX7k eta_sbX7l eta1_sbX7m]
        let {
          f1_sbX7n [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_abVfw (f_abVtL b_abVtN) -> f_abVtL (t_abVfw b_abVtN)
          [LclId] =
              [$dTraversable_sbX7k eta_sbX7l] \u []
                  Data.Traversable.sequenceA $dTraversable_sbX7k eta_sbX7l; } in
        let {
          g_sbX7o [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_abVfw a_abVtM -> t_abVfw (f_abVtL b_abVtN)
          [LclId] =
              [$dTraversable_sbX7k eta1_sbX7m] \u []
                  case
                      Data.Traversable.$p1Traversable $dTraversable_sbX7k
                  of
                  sat_sbX7p
                  { __DEFAULT -> GHC.Base.fmap sat_sbX7p eta1_sbX7m;
                  }; } in
        let {
          sat_sbX7s [Occ=OnceT[0]]
            :: t_abVfw a_abVtM -> f_abVtL (t_abVfw b_abVtN)
          [LclId] =
              [f1_sbX7n g_sbX7o] \r [x_sbX7q]
                  let {
                    sat_sbX7r [Occ=Once] :: t_abVfw (f_abVtL b_abVtN)
                    [LclId] =
                        [g_sbX7o x_sbX7q] \u [] g_sbX7o x_sbX7q;
                  } in  f1_sbX7n sat_sbX7r;
        } in  sat_sbX7s;

Data.Traversable.for [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (f :: * -> *) a b.
     (Data.Traversable.Traversable t, GHC.Base.Applicative f) =>
     t a -> (a -> f b) -> f (t b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C(C1(U))),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX7t $dApplicative_sbX7u]
        let {
          f1_sbX7v [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: (a_abVtu -> f_abVtt b_abVtv)
               -> t_abVts a_abVtu -> f_abVtt (t_abVts b_abVtv)
          [LclId] =
              [$dTraversable_sbX7t $dApplicative_sbX7u] \u []
                  Data.Traversable.traverse
                      $dTraversable_sbX7t $dApplicative_sbX7u; } in
        let {
          sat_sbX7y [Occ=OnceT[0]]
            :: t_abVts a_abVtu
               -> (a_abVtu -> f_abVtt b_abVtv) -> f_abVtt (t_abVts b_abVtv)
          [LclId] =
              [f1_sbX7v] \r [x_sbX7w y_sbX7x] f1_sbX7v y_sbX7x x_sbX7w;
        } in  sat_sbX7y;

Data.Traversable.forM [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (m :: * -> *) a b.
     (Data.Traversable.Traversable t, GHC.Base.Monad m) =>
     t a -> (a -> m b) -> m (t b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,1*C1(C(C1(U))),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX7z $dMonad_sbX7A]
        let {
          f_sbX7B [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: (a_abVtd -> m_abVtc b_abVte)
               -> t_abVtb a_abVtd -> m_abVtc (t_abVtb b_abVte)
          [LclId] =
              [$dTraversable_sbX7z $dMonad_sbX7A] \u []
                  Data.Traversable.mapM $dTraversable_sbX7z $dMonad_sbX7A; } in
        let {
          sat_sbX7E [Occ=OnceT[0]]
            :: t_abVtb a_abVtd
               -> (a_abVtd -> m_abVtc b_abVte) -> m_abVtc (t_abVtb b_abVte)
          [LclId] =
              [f_sbX7B] \r [x_sbX7C y_sbX7D] f_sbX7B y_sbX7D x_sbX7C;
        } in  sat_sbX7E;

Data.Traversable.mapAccumL
  :: forall (t :: * -> *) a b c.
     Data.Traversable.Traversable t =>
     (a -> b -> (a, c)) -> a -> t b -> (a, t c)
[GblId,
 Arity=4,
 Str=<S(LLC(C(C(S)))LLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX7F f_sbX7G s_sbX7H t1_sbX7I]
        let {
          sat_sbX7L [Occ=Once]
            :: b_abVsM -> Data.Functor.Utils.StateL a_abVsL c_abVsN
          [LclId] =
              [f_sbX7G] \r [x_sbX7J y_sbX7K] f_sbX7G y_sbX7K x_sbX7J;
        } in 
          Data.Traversable.traverse
              $dTraversable_sbX7F
              Data.Functor.Utils.$fApplicativeStateL
              sat_sbX7L
              t1_sbX7I
              s_sbX7H;

Data.Traversable.mapAccumR
  :: forall (t :: * -> *) a b c.
     Data.Traversable.Traversable t =>
     (a -> b -> (a, c)) -> a -> t b -> (a, t c)
[GblId,
 Arity=4,
 Str=<S(LLC(C(C(S)))LLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX7M f_sbX7N s_sbX7O t1_sbX7P]
        let {
          sat_sbX7S [Occ=Once]
            :: b_abVsl -> Data.Functor.Utils.StateR a_abVsk c_abVsm
          [LclId] =
              [f_sbX7N] \r [x_sbX7Q y_sbX7R] f_sbX7N y_sbX7R x_sbX7Q;
        } in 
          Data.Traversable.traverse
              $dTraversable_sbX7M
              Data.Functor.Utils.$fApplicativeStateR
              sat_sbX7S
              t1_sbX7P
              s_sbX7O;

fmapDefault1_rbWTV
  :: forall (t :: * -> *) a b.
     Data.Traversable.Traversable t =>
     (a -> Data.Functor.Identity.Identity b)
     -> t a -> Data.Functor.Identity.Identity (t b)
[GblId,
 Arity=1,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)>,
 Unf=OtherCon []] =
    sat-only [] \r [$dTraversable_sbX7T]
        Data.Traversable.traverse
            $dTraversable_sbX7T Data.Functor.Identity.$fApplicativeIdentity;

Data.Traversable.fmapDefault [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) a b.
     Data.Traversable.Traversable t =>
     (a -> b) -> t a -> t b
[GblId,
 Arity=1,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] fmapDefault1_rbWTV eta_B1;

foldMapDefault1_rbWTW
  :: forall (t :: * -> *) m a.
     (Data.Traversable.Traversable t, GHC.Base.Monoid m) =>
     (a -> Data.Functor.Const.Const m ())
     -> t a -> Data.Functor.Const.Const m (t ())
[GblId,
 Arity=2,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)><L,U(A,U,U,A)>,
 Unf=OtherCon []] =
    sat-only [] \r [$dTraversable_sbX7U $dMonoid_sbX7V]
        let {
          sat_sbX7W [Occ=Once]
            :: GHC.Base.Applicative (Data.Functor.Const.Const m_abVrr)
          [LclId] =
              [$dMonoid_sbX7V] \u []
                  Data.Functor.Const.$fApplicativeConst $dMonoid_sbX7V;
        } in  Data.Traversable.traverse $dTraversable_sbX7U sat_sbX7W;

Data.Traversable.foldMapDefault [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) m a.
     (Data.Traversable.Traversable t, GHC.Base.Monoid m) =>
     (a -> m) -> t a -> m
[GblId,
 Arity=2,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)><L,U(A,U,U,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] foldMapDefault1_rbWTW eta_B2 eta_B1;

Data.Traversable.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Traversable.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Traversable.$trModule4];

Data.Traversable.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Traversable"#;

Data.Traversable.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Traversable.$trModule2];

Data.Traversable.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Traversable.$trModule3
                                     Data.Traversable.$trModule1];

$krep_rbWTX :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Traversable.$tcTraversable1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep_rbWTX];

Data.Traversable.$tcTraversable3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Traversable"#;

Data.Traversable.$tcTraversable2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Traversable.$tcTraversable3];

Data.Traversable.$tcTraversable :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9002450311536760373##
                                    4172295783860716183##
                                    Data.Traversable.$trModule
                                    Data.Traversable.$tcTraversable2
                                    0#
                                    Data.Traversable.$tcTraversable1];

Data.Traversable.C:Traversable
  :: forall (t :: * -> *).
     (GHC.Base.Functor t, Data.Foldable.Foldable t) =>
     (forall (f :: * -> *) a b.
      GHC.Base.Applicative f =>
      (a -> f b) -> t a -> f (t b))
     -> (forall (f :: * -> *) a.
         GHC.Base.Applicative f =>
         t (f a) -> f (t a))
     -> (forall (m :: * -> *) a b.
         GHC.Base.Monad m =>
         (a -> m b) -> t a -> m (t b))
     -> (forall (m :: * -> *) a. GHC.Base.Monad m => t (m a) -> m (t a))
     -> Data.Traversable.Traversable t
[GblId[DataCon],
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Traversable.C:Traversable [eta_B6
                                        eta_B5
                                        eta_B4
                                        eta_B3
                                        eta_B2
                                        eta_B1];


==================== STG syntax: ====================
2018-03-16 16:06:49.800284327 UTC

Data.Traversable.$p1Traversable
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     GHC.Base.Functor t
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLL),U(U,A,A,A,A,A)>] =
    [] \r [v_sbWTZ]
        case v_sbWTZ of {
          Data.Traversable.C:Traversable v_sbWU1 [Occ=Once]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead] ->
              v_sbWU1;
        };

Data.Traversable.$p2Traversable
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     Data.Foldable.Foldable t
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLL),U(A,U,A,A,A,A)>] =
    [] \r [v_sbWU7]
        case v_sbWU7 of {
          Data.Traversable.C:Traversable _ [Occ=Dead]
                                         v_sbWUa [Occ=Once]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead] ->
              v_sbWUa;
        };

Data.Traversable.traverse
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> t a -> f (t b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLL),U(A,A,U,A,A,A)>] =
    [] \r [v_sbWUf]
        case v_sbWUf of {
          Data.Traversable.C:Traversable _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         v_sbWUj [Occ=Once]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead] ->
              v_sbWUj;
        };

Data.Traversable.sequenceA
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     t (f a) -> f (t a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLL),U(A,A,A,U,A,A)>] =
    [] \r [v_sbWUn]
        case v_sbWUn of {
          Data.Traversable.C:Traversable _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         v_sbWUs [Occ=Once]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead] ->
              v_sbWUs;
        };

Data.Traversable.mapM
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> t a -> m (t b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSL),U(A,A,A,A,U,A)>] =
    [] \r [v_sbWUv]
        case v_sbWUv of {
          Data.Traversable.C:Traversable _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         v_sbWUB [Occ=Once]
                                         _ [Occ=Dead] ->
              v_sbWUB;
        };

Data.Traversable.sequence
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (m :: * -> *) a. GHC.Base.Monad m => t (m a) -> m (t a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLS),U(A,A,A,A,A,U)>] =
    [] \r [v_sbWUD]
        case v_sbWUD of {
          Data.Traversable.C:Traversable _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         v_sbWUK [Occ=Once] ->
              v_sbWUK;
        };

Data.Traversable.$fTraversableFirst_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Base.Maybe a -> f (GHC.Base.Maybe b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWUL eta_sbWUM eta1_sbWUN]
        case eta1_sbWUN of {
          GHC.Base.Nothing ->
              GHC.Base.pure $dApplicative_sbWUL GHC.Base.Nothing;
          GHC.Base.Just x_sbWUP [Occ=Once] ->
              let {
                sat_sbWUR [Occ=Once] :: f_abW15 b_abW17
                [LclId] =
                    [eta_sbWUM x_sbWUP] \u [] eta_sbWUM x_sbWUP;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbWUL of sat_sbWUQ {
                  __DEFAULT -> GHC.Base.fmap sat_sbWUQ GHC.Base.Just sat_sbWUR;
                };
        };

Data.Traversable.$fTraversable[]_$ctraverse [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> [a] -> f [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*C1(U),A,C(C1(C1(U))),A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWUS f1_sbWUT]
        let {
          z_sbWUU [Occ=OnceL] :: f_abVZK [b_abVZM]
          [LclId] =
              [$dApplicative_sbWUS] \u []
                  GHC.Base.pure $dApplicative_sbWUS GHC.Types.[]; } in
        let {
          go_sbWUV [Occ=LoopBreaker] :: [a_abVZL] -> f_abVZK [b_abVZM]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [$dApplicative_sbWUS f1_sbWUT z_sbWUU go_sbWUV] \r [ds_sbWUW]
                  case ds_sbWUW of {
                    [] -> z_sbWUU;
                    : y_sbWUY [Occ=Once] ys_sbWUZ [Occ=Once] ->
                        let {
                          sat_sbWV1 [Occ=Once] :: f_abVZK [b_abVZM]
                          [LclId] =
                              [go_sbWUV ys_sbWUZ] \u [] go_sbWUV ys_sbWUZ; } in
                        let {
                          sat_sbWV0 [Occ=Once] :: f_abVZK b_abVZM
                          [LclId] =
                              [f1_sbWUT y_sbWUY] \u [] f1_sbWUT y_sbWUY;
                        } in 
                          GHC.Base.liftA2
                              $dApplicative_sbWUS GHC.Types.: sat_sbWV0 sat_sbWV1;
                  };
        } in  go_sbWUV;

Data.Traversable.$fTraversableEither_$ctraverse
  :: forall a1 (f :: * -> *) a2 b.
     GHC.Base.Applicative f =>
     (a2 -> f b)
     -> Data.Either.Either a1 a2 -> f (Data.Either.Either a1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWV2 eta_sbWV3 eta1_sbWV4]
        case eta1_sbWV4 of {
          Data.Either.Left x_sbWV6 [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWV2 wild_sbWV5;
          Data.Either.Right y_sbWV8 [Occ=Once] ->
              let {
                sat_sbWVa [Occ=Once] :: f_abVXx b_abVXz
                [LclId] =
                    [eta_sbWV3 y_sbWV8] \u [] eta_sbWV3 y_sbWV8;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbWV2 of sat_sbWV9 {
                  __DEFAULT -> GHC.Base.fmap sat_sbWV9 Data.Either.Right sat_sbWVa;
                };
        };

Data.Traversable.$fTraversable(,)_$ctraverse
  :: forall a1 (f :: * -> *) a2 b.
     GHC.Base.Applicative f =>
     (a2 -> f b) -> (a1, a2) -> f (a1, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWVb eta_sbWVc eta1_sbWVd]
        case eta1_sbWVd of {
          (,) x_sbWVf [Occ=OnceL] y_sbWVg [Occ=Once] ->
              let {
                sat_sbWVj [Occ=Once] :: f_abVWv b_abVWx
                [LclId] =
                    [eta_sbWVc y_sbWVg] \u [] eta_sbWVc y_sbWVg; } in
              let {
                sat_sbWVi [Occ=Once] :: b_abVWx -> (a_abVWj, b_abVWx)
                [LclId] =
                    [x_sbWVf] \r [eta_B1] (,) [x_sbWVf eta_B1];
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbWVb of sat_sbWVh {
                  __DEFAULT -> GHC.Base.fmap sat_sbWVh sat_sbWVi sat_sbWVj;
                };
        };

Data.Traversable.$fTraversableProxy_$csequence [InlPrag=INLINE (sat-args=1)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Proxy.Proxy (m a) -> m (Data.Proxy.Proxy a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWVk eta_sbWVl]
        case GHC.Base.$p1Monad $dMonad_sbWVk of sat_sbWVm {
          __DEFAULT -> GHC.Base.pure sat_sbWVm Data.Proxy.Proxy;
        };

Data.Traversable.$fTraversableProxy_$cmapM [InlPrag=INLINE (sat-args=2)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Proxy.Proxy a -> m (Data.Proxy.Proxy b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWVn eta_sbWVo eta1_sbWVp]
        case GHC.Base.$p1Monad $dMonad_sbWVn of sat_sbWVq {
          __DEFAULT -> GHC.Base.pure sat_sbWVq Data.Proxy.Proxy;
        };

Data.Traversable.$fTraversableProxy_$csequenceA [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Proxy.Proxy (f a) -> f (Data.Proxy.Proxy a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWVr ds_sbWVs]
        GHC.Base.pure $dApplicative_sbWVr Data.Proxy.Proxy;

Data.Traversable.$fTraversableProxy_$ctraverse [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Proxy.Proxy a -> f (Data.Proxy.Proxy b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWVt eta_sbWVu ds_sbWVv]
        GHC.Base.pure $dApplicative_sbWVt Data.Proxy.Proxy;

Data.Traversable.$fTraversableProxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Proxy.Proxy
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Proxy.$fFunctorProxy
                                                   Data.Foldable.$fFoldableProxy
                                                   Data.Traversable.$fTraversableProxy_$ctraverse
                                                   Data.Traversable.$fTraversableProxy_$csequenceA
                                                   Data.Traversable.$fTraversableProxy_$cmapM
                                                   Data.Traversable.$fTraversableProxy_$csequence];

Data.Traversable.$fTraversableConst_$ctraverse
  :: forall m (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Functor.Const.Const m a -> f (Data.Functor.Const.Const m b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWVw ds_sbWVx ds1_sbWVy]
        GHC.Base.pure $dApplicative_sbWVw ds1_sbWVy;

Data.Traversable.$fTraversableDual1 :: forall b. b -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbWVz] v_sbWVz;

Data.Traversable.$fTraversableDual_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Semigroup.Internal.Dual a
     -> f (Data.Semigroup.Internal.Dual b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWVA eta_sbWVB eta1_sbWVC]
        let {
          sat_sbWVE [Occ=Once] :: f_abVS2 b_abVS4
          [LclId] =
              [eta_sbWVB eta1_sbWVC] \u [] eta_sbWVB eta1_sbWVC;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbWVA of sat_sbWVD {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sbWVD Data.Traversable.$fTraversableDual1 sat_sbWVE;
          };

Data.Traversable.$fTraversableSum_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Semigroup.Internal.Sum a
     -> f (Data.Semigroup.Internal.Sum b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWVF eta_sbWVG eta1_sbWVH]
        let {
          sat_sbWVJ [Occ=Once] :: f_abVR2 b_abVR4
          [LclId] =
              [eta_sbWVG eta1_sbWVH] \u [] eta_sbWVG eta1_sbWVH;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbWVF of sat_sbWVI {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sbWVI Data.Traversable.$fTraversableDual1 sat_sbWVJ;
          };

Data.Traversable.$fTraversableProduct_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Semigroup.Internal.Product a
     -> f (Data.Semigroup.Internal.Product b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWVK eta_sbWVL eta1_sbWVM]
        let {
          sat_sbWVO [Occ=Once] :: f_abVQ2 b_abVQ4
          [LclId] =
              [eta_sbWVL eta1_sbWVM] \u [] eta_sbWVL eta1_sbWVM;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbWVK of sat_sbWVN {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sbWVN Data.Traversable.$fTraversableDual1 sat_sbWVO;
          };

Data.Traversable.$fTraversableU1_$csequence [InlPrag=INLINE (sat-args=1)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.U1 (m a) -> m (GHC.Generics.U1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWVP eta_sbWVQ]
        case GHC.Base.$p1Monad $dMonad_sbWVP of sat_sbWVR {
          __DEFAULT -> GHC.Base.pure sat_sbWVR GHC.Generics.U1;
        };

Data.Traversable.$fTraversableU1_$cmapM [InlPrag=INLINE (sat-args=2)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Generics.U1 a -> m (GHC.Generics.U1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWVS eta_sbWVT eta1_sbWVU]
        case GHC.Base.$p1Monad $dMonad_sbWVS of sat_sbWVV {
          __DEFAULT -> GHC.Base.pure sat_sbWVV GHC.Generics.U1;
        };

Data.Traversable.$fTraversableU1_$csequenceA [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.U1 (f a) -> f (GHC.Generics.U1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWVW ds_sbWVX]
        GHC.Base.pure $dApplicative_sbWVW GHC.Generics.U1;

Data.Traversable.$fTraversableU1_$ctraverse [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Generics.U1 a -> f (GHC.Generics.U1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWVY eta_sbWVZ ds_sbWW0]
        GHC.Base.pure $dApplicative_sbWVY GHC.Generics.U1;

Data.Traversable.$fTraversableU1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable GHC.Generics.U1
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorU1
                                                   Data.Foldable.$fFoldableU1
                                                   Data.Traversable.$fTraversableU1_$ctraverse
                                                   Data.Traversable.$fTraversableU1_$csequenceA
                                                   Data.Traversable.$fTraversableU1_$cmapM
                                                   Data.Traversable.$fTraversableU1_$csequence];

Data.Traversable.$fTraversableIdentity_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Functor.Identity.Identity a
     -> f (Data.Functor.Identity.Identity b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWW1 eta_sbWW2 eta1_sbWW3]
        let {
          sat_sbWW5 [Occ=Once] :: f_abVKI b_abVKK
          [LclId] =
              [eta_sbWW2 eta1_sbWW3] \u [] eta_sbWW2 eta1_sbWW3;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbWW1 of sat_sbWW4 {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sbWW4 Data.Traversable.$fTraversableDual1 sat_sbWW5;
          };

Data.Traversable.$fTraversableV1_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Generics.V1 a -> f (GHC.Generics.V1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWW6 ds_sbWW7 z_sbWW8]
        GHC.Base.pure $dApplicative_sbWW6 z_sbWW8;

Data.Traversable.$fTraversablePar1_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Generics.Par1 a -> f (GHC.Generics.Par1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWW9 eta_sbWWa eta1_sbWWb]
        let {
          sat_sbWWd [Occ=Once] :: f_abVIH b_abVIJ
          [LclId] =
              [eta_sbWWa eta1_sbWWb] \u [] eta_sbWWa eta1_sbWWb;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbWW9 of sat_sbWWc {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sbWWc Data.Traversable.$fTraversableDual1 sat_sbWWd;
          };

Data.Traversable.$fTraversableM2
  :: forall (f :: * -> *) b. f b -> f b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [b1_sbWWe] b1_sbWWe;

Data.Traversable.$fTraversableRec1_$ctraverse
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b) -> GHC.Generics.Rec1 f a -> f1 (GHC.Generics.Rec1 f b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWWf
           $dApplicative_sbWWg
           eta_sbWWh
           eta1_sbWWi]
        let {
          sat_sbWWk [Occ=Once] :: f1_abVHz (f_abVHm b_abVHB)
          [LclId] =
              [$dTraversable_sbWWf
               $dApplicative_sbWWg
               eta_sbWWh
               eta1_sbWWi] \u []
                  Data.Traversable.traverse
                      $dTraversable_sbWWf $dApplicative_sbWWg eta_sbWWh eta1_sbWWi;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbWWg of sat_sbWWj {
            __DEFAULT ->
                GHC.Base.fmap sat_sbWWj Data.Traversable.$fTraversableM2 sat_sbWWk;
          };

Data.Traversable.$fTraversableRec1_$cp2Traversable
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     Data.Foldable.Foldable (GHC.Generics.Rec1 f)
[GblId,
 Arity=1,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWWl]
        let {
          sat_sbWWm [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_abVHm
          [LclId] =
              [$dTraversable_sbWWl] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sbWWl;
        } in  Data.Foldable.$fFoldableRec1 sat_sbWWm;

Data.Traversable.$fTraversableRec1_$cp1Traversable
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     GHC.Base.Functor (GHC.Generics.Rec1 f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWWn]
        let {
          sat_sbWWo [Occ=Once, Dmd=<L,U(1*U,1*U)>]
            :: GHC.Base.Functor f_abVHm
          [LclId] =
              [$dTraversable_sbWWn] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sbWWn;
        } in  GHC.Generics.$fFunctorRec1 sat_sbWWo;

Data.Traversable.$fTraversableK1_$ctraverse
  :: forall i c (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Generics.K1 i c a -> f (GHC.Generics.K1 i c b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWWp ds_sbWWq z_sbWWr]
        GHC.Base.pure $dApplicative_sbWWp z_sbWWr;

Data.Traversable.$fTraversableM1_$ctraverse
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> GHC.Generics.M1 i c f a -> f1 (GHC.Generics.M1 i c f b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWWs
           $dApplicative_sbWWt
           eta_sbWWu
           eta1_sbWWv]
        let {
          sat_sbWWx [Occ=Once] :: f1_abVFk (f_abVF5 b_abVFm)
          [LclId] =
              [$dTraversable_sbWWs
               $dApplicative_sbWWt
               eta_sbWWu
               eta1_sbWWv] \u []
                  Data.Traversable.traverse
                      $dTraversable_sbWWs $dApplicative_sbWWt eta_sbWWu eta1_sbWWv;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbWWt of sat_sbWWw {
            __DEFAULT ->
                GHC.Base.fmap sat_sbWWw Data.Traversable.$fTraversableM2 sat_sbWWx;
          };

Data.Traversable.$fTraversableM1_$cp2Traversable
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     Data.Foldable.Foldable (GHC.Generics.M1 i c f)
[GblId,
 Arity=1,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWWy]
        let {
          sat_sbWWz [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_abVF5
          [LclId] =
              [$dTraversable_sbWWy] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sbWWy;
        } in  Data.Foldable.$fFoldableM1 sat_sbWWz;

Data.Traversable.$fTraversableM1_$cp1Traversable
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     GHC.Base.Functor (GHC.Generics.M1 i c f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWWA]
        let {
          sat_sbWWB [Occ=Once, Dmd=<L,U(1*U,1*U)>]
            :: GHC.Base.Functor f_abVF5
          [LclId] =
              [$dTraversable_sbWWA] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sbWWA;
        } in  GHC.Generics.$fFunctorM1 sat_sbWWB;

Data.Traversable.$fTraversable:+:_$ctraverse
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> (GHC.Generics.:+:) f g a -> f1 ((GHC.Generics.:+:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWWC
           $dTraversable1_sbWWD
           $dApplicative_sbWWE
           eta_sbWWF
           eta1_sbWWG]
        case eta1_sbWWG of {
          GHC.Generics.L1 a1_sbWWI [Occ=Once] ->
              let {
                sat_sbWWK [Occ=Once] :: f1_abVDT (f_abVDE b_abVDV)
                [LclId] =
                    [$dTraversable_sbWWC $dApplicative_sbWWE eta_sbWWF a1_sbWWI] \u []
                        Data.Traversable.traverse
                            $dTraversable_sbWWC $dApplicative_sbWWE eta_sbWWF a1_sbWWI;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbWWE of sat_sbWWJ {
                  __DEFAULT -> GHC.Base.fmap sat_sbWWJ GHC.Generics.L1 sat_sbWWK;
                };
          GHC.Generics.R1 a1_sbWWL [Occ=Once] ->
              let {
                sat_sbWWN [Occ=Once] :: f1_abVDT (g_abVDF b_abVDV)
                [LclId] =
                    [$dTraversable1_sbWWD $dApplicative_sbWWE eta_sbWWF a1_sbWWL] \u []
                        Data.Traversable.traverse
                            $dTraversable1_sbWWD $dApplicative_sbWWE eta_sbWWF a1_sbWWL;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbWWE of sat_sbWWM {
                  __DEFAULT -> GHC.Base.fmap sat_sbWWM GHC.Generics.R1 sat_sbWWN;
                };
        };

Data.Traversable.$fTraversable:+:_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:+: g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWWO $dTraversable1_sbWWP]
        let {
          sat_sbWWR [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_abVDF
          [LclId] =
              [$dTraversable1_sbWWP] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sbWWP; } in
        let {
          sat_sbWWQ [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_abVDE
          [LclId] =
              [$dTraversable_sbWWO] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sbWWO;
        } in  Data.Foldable.$fFoldable:+: sat_sbWWQ sat_sbWWR;

Data.Traversable.$fTraversable:+:_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (f GHC.Generics.:+: g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),C(C1(U))),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),C(C1(U))),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWWS $dTraversable1_sbWWT]
        let {
          sat_sbWWV [Occ=Once, Dmd=<L,U(C(C1(U)),C(C1(U)))>]
            :: GHC.Base.Functor g_abVDF
          [LclId] =
              [$dTraversable1_sbWWT] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sbWWT; } in
        let {
          sat_sbWWU [Occ=Once, Dmd=<L,U(C(C1(U)),C(C1(U)))>]
            :: GHC.Base.Functor f_abVDE
          [LclId] =
              [$dTraversable_sbWWS] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sbWWS;
        } in  GHC.Generics.$fFunctor:+: sat_sbWWU sat_sbWWV;

Data.Traversable.$w$ctraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b) -> f a -> g a -> f1 ((GHC.Generics.:*:) f g b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sbWWW w1_sbWWX w2_sbWWY w3_sbWWZ ww_sbWX0 ww1_sbWX1]
        let {
          sat_sbWX3 [Occ=Once] :: f1_sbWKB (g_sbWKy b_sbWKD)
          [LclId] =
              [w1_sbWWX w2_sbWWY w3_sbWWZ ww1_sbWX1] \u []
                  Data.Traversable.traverse
                      w1_sbWWX w2_sbWWY w3_sbWWZ ww1_sbWX1; } in
        let {
          sat_sbWX2 [Occ=Once] :: f1_sbWKB (f_sbWKx b_sbWKD)
          [LclId] =
              [w_sbWWW w2_sbWWY w3_sbWWZ ww_sbWX0] \u []
                  Data.Traversable.traverse w_sbWWW w2_sbWWY w3_sbWWZ ww_sbWX0;
        } in 
          GHC.Base.liftA2 w2_sbWWY GHC.Generics.:*: sat_sbWX2 sat_sbWX3;

Data.Traversable.$fTraversable:*:_$ctraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> (GHC.Generics.:*:) f g a -> f1 ((GHC.Generics.:*:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sbWX4 w1_sbWX5 w2_sbWX6 w3_sbWX7 w4_sbWX8]
        case w4_sbWX8 of {
          GHC.Generics.:*: ww1_sbWXa [Occ=Once] ww2_sbWXb [Occ=Once] ->
              Data.Traversable.$w$ctraverse
                  w_sbWX4 w1_sbWX5 w2_sbWX6 w3_sbWX7 ww1_sbWXa ww2_sbWXb;
        };

Data.Traversable.$fTraversable:*:_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:*: g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWXc $dTraversable1_sbWXd]
        let {
          sat_sbWXf [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_abVCl
          [LclId] =
              [$dTraversable1_sbWXd] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sbWXd; } in
        let {
          sat_sbWXe [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_abVCk
          [LclId] =
              [$dTraversable_sbWXc] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sbWXc;
        } in  Data.Foldable.$fFoldable:*: sat_sbWXe sat_sbWXf;

Data.Traversable.$fTraversable:*:_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (f GHC.Generics.:*: g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),C(C1(U))),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),C(C1(U))),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWXg $dTraversable1_sbWXh]
        let {
          sat_sbWXj [Occ=Once, Dmd=<L,U(C(C1(U)),C(C1(U)))>]
            :: GHC.Base.Functor g_abVCl
          [LclId] =
              [$dTraversable1_sbWXh] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sbWXh; } in
        let {
          sat_sbWXi [Occ=Once, Dmd=<L,U(C(C1(U)),C(C1(U)))>]
            :: GHC.Base.Functor f_abVCk
          [LclId] =
              [$dTraversable_sbWXg] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sbWXg;
        } in  GHC.Generics.$fFunctor:*: sat_sbWXi sat_sbWXj;

Data.Traversable.$fTraversable:.:1
  :: forall (f :: * -> *) (g :: * -> *) b. f (g b) -> f (g b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [b1_sbWXk] b1_sbWXk;

Data.Traversable.$fTraversable:.:_$ctraverse
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> (GHC.Generics.:.:) f g a -> f1 ((GHC.Generics.:.:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWXl
           $dTraversable1_sbWXm
           $dApplicative_sbWXn
           eta_sbWXo
           eta1_sbWXp]
        let {
          sat_sbWXs [Occ=Once] :: f1_abVBf (f_abVB0 (g_abVB1 b_abVBh))
          [LclId] =
              [$dTraversable_sbWXl
               $dTraversable1_sbWXm
               $dApplicative_sbWXn
               eta_sbWXo
               eta1_sbWXp] \u []
                  let {
                    sat_sbWXr [Occ=Once]
                      :: g_abVB1 a_abVBg -> f1_abVBf (g_abVB1 b_abVBh)
                    [LclId] =
                        [$dTraversable1_sbWXm $dApplicative_sbWXn eta_sbWXo] \u []
                            Data.Traversable.traverse
                                $dTraversable1_sbWXm $dApplicative_sbWXn eta_sbWXo;
                  } in 
                    Data.Traversable.traverse
                        $dTraversable_sbWXl $dApplicative_sbWXn sat_sbWXr eta1_sbWXp;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbWXn of sat_sbWXq {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sbWXq Data.Traversable.$fTraversable:.:1 sat_sbWXs;
          };

Data.Traversable.$fTraversable:.:_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:.: g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(U)),C(C1(C1(U))),A,A,A,A,A,A,U,A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWXt $dTraversable1_sbWXu]
        let {
          sat_sbWXw [Occ=Once,
                     Dmd=<L,U(A,C(C1(U)),C(C1(C1(U))),A,A,A,A,A,A,U,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_abVB1
          [LclId] =
              [$dTraversable1_sbWXu] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sbWXu; } in
        let {
          sat_sbWXv [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_abVB0
          [LclId] =
              [$dTraversable_sbWXt] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sbWXt;
        } in  Data.Foldable.$fFoldable:.: sat_sbWXv sat_sbWXw;

Data.Traversable.$fTraversable:.:_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (f GHC.Generics.:.: g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(U),C(U)),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWXx $dTraversable1_sbWXy]
        let {
          sat_sbWXA [Occ=Once, Dmd=<L,U(C(U),C(U))>]
            :: GHC.Base.Functor g_abVB1
          [LclId] =
              [$dTraversable1_sbWXy] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sbWXy; } in
        let {
          sat_sbWXz [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_abVB0
          [LclId] =
              [$dTraversable_sbWXx] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sbWXx;
        } in  GHC.Generics.$fFunctor:.: sat_sbWXz sat_sbWXA;

Data.Traversable.$fTraversableURec4_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a
     -> f (GHC.Generics.URec (GHC.Ptr.Ptr ()) b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWXB f1_sbWXC ds_sbWXD]
        case ds_sbWXD of {
          GHC.Generics.UAddr a1_sbWXF [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWXB wild_sbWXE;
        };

Data.Traversable.$fTraversableURec3_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec GHC.Types.Char a
     -> f (GHC.Generics.URec GHC.Types.Char b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWXH f1_sbWXI ds_sbWXJ]
        case ds_sbWXJ of {
          GHC.Generics.UChar a1_sbWXL [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWXH wild_sbWXK;
        };

Data.Traversable.$fTraversableURec2_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec GHC.Types.Double a
     -> f (GHC.Generics.URec GHC.Types.Double b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWXN f1_sbWXO ds_sbWXP]
        case ds_sbWXP of {
          GHC.Generics.UDouble a1_sbWXR [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWXN wild_sbWXQ;
        };

Data.Traversable.$fTraversableURec1_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec GHC.Types.Float a
     -> f (GHC.Generics.URec GHC.Types.Float b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWXT f1_sbWXU ds_sbWXV]
        case ds_sbWXV of {
          GHC.Generics.UFloat a1_sbWXX [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWXT wild_sbWXW;
        };

Data.Traversable.$fTraversableURec0_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec GHC.Types.Int a
     -> f (GHC.Generics.URec GHC.Types.Int b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWXZ f1_sbWY0 ds_sbWY1]
        case ds_sbWY1 of {
          GHC.Generics.UInt a1_sbWY3 [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWXZ wild_sbWY2;
        };

Data.Traversable.$fTraversableURec_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec GHC.Types.Word a
     -> f (GHC.Generics.URec GHC.Types.Word b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWY5 f1_sbWY6 ds_sbWY7]
        case ds_sbWY7 of {
          GHC.Generics.UWord a1_sbWY9 [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWY5 wild_sbWY8;
        };

Data.Traversable.$dmsequence [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (m :: * -> *) a. GHC.Base.Monad m => t (m a) -> m (t a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LL),1*U(A,A,A,1*C1(U),A,A)><L,1*U(1*U,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWYb $dMonad_sbWYc]
        let {
          sat_sbWYd [Occ=Once] :: GHC.Base.Applicative m_abVux
          [LclId] =
              [$dMonad_sbWYc] \u [] GHC.Base.$p1Monad $dMonad_sbWYc;
        } in  Data.Traversable.sequenceA $dTraversable_sbWYb sat_sbWYd;

Data.Traversable.$dmmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> t a -> m (t b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)><L,1*U(1*U,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWYe $dMonad_sbWYf]
        let {
          sat_sbWYg [Occ=Once] :: GHC.Base.Applicative m_abVuj
          [LclId] =
              [$dMonad_sbWYf] \u [] GHC.Base.$p1Monad $dMonad_sbWYf;
        } in  Data.Traversable.traverse $dTraversable_sbWYe sat_sbWYg;

Data.Traversable.$dmsequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     t (f a) -> f (t a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),1*U(A,A,1*C1(C1(U)),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbWYh $dApplicative_sbWYi]
        Data.Traversable.traverse
            $dTraversable_sbWYh $dApplicative_sbWYi GHC.Base.id;

Data.Traversable.$fTraversableURec_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec GHC.Types.Word (f a)
     -> f (GHC.Generics.URec GHC.Types.Word a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWYj ds_sbWYk]
        case ds_sbWYk of {
          GHC.Generics.UWord a1_sbWYm [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWYj wild_sbWYl;
        };

Data.Traversable.$fTraversableURec_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec GHC.Types.Word a
     -> m (GHC.Generics.URec GHC.Types.Word b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWYo eta_sbWYp eta1_sbWYq]
        case eta1_sbWYq of {
          GHC.Generics.UWord a1_sbWYs [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWYo of sat_sbWYt {
                __DEFAULT -> GHC.Base.pure sat_sbWYt wild_sbWYr;
              };
        };

Data.Traversable.$fTraversableURec_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec GHC.Types.Word (m a)
     -> m (GHC.Generics.URec GHC.Types.Word a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWYv eta_sbWYw]
        case eta_sbWYw of {
          GHC.Generics.UWord a1_sbWYy [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWYv of sat_sbWYz {
                __DEFAULT -> GHC.Base.pure sat_sbWYz wild_sbWYx;
              };
        };

Data.Traversable.$fTraversableURec [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Word)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec
                                                   Data.Foldable.$fFoldableURec
                                                   Data.Traversable.$fTraversableURec_$ctraverse
                                                   Data.Traversable.$fTraversableURec_$csequenceA
                                                   Data.Traversable.$fTraversableURec_$cmapM
                                                   Data.Traversable.$fTraversableURec_$csequence];

Data.Traversable.$fTraversableURec0_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec GHC.Types.Int (f a)
     -> f (GHC.Generics.URec GHC.Types.Int a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWYB ds_sbWYC]
        case ds_sbWYC of {
          GHC.Generics.UInt a1_sbWYE [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWYB wild_sbWYD;
        };

Data.Traversable.$fTraversableURec0_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec GHC.Types.Int a
     -> m (GHC.Generics.URec GHC.Types.Int b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWYG eta_sbWYH eta1_sbWYI]
        case eta1_sbWYI of {
          GHC.Generics.UInt a1_sbWYK [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWYG of sat_sbWYL {
                __DEFAULT -> GHC.Base.pure sat_sbWYL wild_sbWYJ;
              };
        };

Data.Traversable.$fTraversableURec0_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec GHC.Types.Int (m a)
     -> m (GHC.Generics.URec GHC.Types.Int a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWYN eta_sbWYO]
        case eta_sbWYO of {
          GHC.Generics.UInt a1_sbWYQ [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWYN of sat_sbWYR {
                __DEFAULT -> GHC.Base.pure sat_sbWYR wild_sbWYP;
              };
        };

Data.Traversable.$fTraversableURec0 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Int)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec0
                                                   Data.Foldable.$fFoldableURec0
                                                   Data.Traversable.$fTraversableURec0_$ctraverse
                                                   Data.Traversable.$fTraversableURec0_$csequenceA
                                                   Data.Traversable.$fTraversableURec0_$cmapM
                                                   Data.Traversable.$fTraversableURec0_$csequence];

Data.Traversable.$fTraversableURec1_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec GHC.Types.Float (f a)
     -> f (GHC.Generics.URec GHC.Types.Float a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWYT ds_sbWYU]
        case ds_sbWYU of {
          GHC.Generics.UFloat a1_sbWYW [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWYT wild_sbWYV;
        };

Data.Traversable.$fTraversableURec1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec GHC.Types.Float a
     -> m (GHC.Generics.URec GHC.Types.Float b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWYY eta_sbWYZ eta1_sbWZ0]
        case eta1_sbWZ0 of {
          GHC.Generics.UFloat a1_sbWZ2 [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWYY of sat_sbWZ3 {
                __DEFAULT -> GHC.Base.pure sat_sbWZ3 wild_sbWZ1;
              };
        };

Data.Traversable.$fTraversableURec1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec GHC.Types.Float (m a)
     -> m (GHC.Generics.URec GHC.Types.Float a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWZ5 eta_sbWZ6]
        case eta_sbWZ6 of {
          GHC.Generics.UFloat a1_sbWZ8 [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWZ5 of sat_sbWZ9 {
                __DEFAULT -> GHC.Base.pure sat_sbWZ9 wild_sbWZ7;
              };
        };

Data.Traversable.$fTraversableURec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Float)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec1
                                                   Data.Foldable.$fFoldableURec1
                                                   Data.Traversable.$fTraversableURec1_$ctraverse
                                                   Data.Traversable.$fTraversableURec1_$csequenceA
                                                   Data.Traversable.$fTraversableURec1_$cmapM
                                                   Data.Traversable.$fTraversableURec1_$csequence];

Data.Traversable.$fTraversableURec2_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec GHC.Types.Double (f a)
     -> f (GHC.Generics.URec GHC.Types.Double a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWZb ds_sbWZc]
        case ds_sbWZc of {
          GHC.Generics.UDouble a1_sbWZe [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWZb wild_sbWZd;
        };

Data.Traversable.$fTraversableURec2_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec GHC.Types.Double a
     -> m (GHC.Generics.URec GHC.Types.Double b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWZg eta_sbWZh eta1_sbWZi]
        case eta1_sbWZi of {
          GHC.Generics.UDouble a1_sbWZk [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWZg of sat_sbWZl {
                __DEFAULT -> GHC.Base.pure sat_sbWZl wild_sbWZj;
              };
        };

Data.Traversable.$fTraversableURec2_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec GHC.Types.Double (m a)
     -> m (GHC.Generics.URec GHC.Types.Double a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWZn eta_sbWZo]
        case eta_sbWZo of {
          GHC.Generics.UDouble a1_sbWZq [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWZn of sat_sbWZr {
                __DEFAULT -> GHC.Base.pure sat_sbWZr wild_sbWZp;
              };
        };

Data.Traversable.$fTraversableURec2 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable
       (GHC.Generics.URec GHC.Types.Double)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec2
                                                   Data.Foldable.$fFoldableURec2
                                                   Data.Traversable.$fTraversableURec2_$ctraverse
                                                   Data.Traversable.$fTraversableURec2_$csequenceA
                                                   Data.Traversable.$fTraversableURec2_$cmapM
                                                   Data.Traversable.$fTraversableURec2_$csequence];

Data.Traversable.$fTraversableURec3_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec GHC.Types.Char (f a)
     -> f (GHC.Generics.URec GHC.Types.Char a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWZt ds_sbWZu]
        case ds_sbWZu of {
          GHC.Generics.UChar a1_sbWZw [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWZt wild_sbWZv;
        };

Data.Traversable.$fTraversableURec3_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec GHC.Types.Char a
     -> m (GHC.Generics.URec GHC.Types.Char b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWZy eta_sbWZz eta1_sbWZA]
        case eta1_sbWZA of {
          GHC.Generics.UChar a1_sbWZC [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWZy of sat_sbWZD {
                __DEFAULT -> GHC.Base.pure sat_sbWZD wild_sbWZB;
              };
        };

Data.Traversable.$fTraversableURec3_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec GHC.Types.Char (m a)
     -> m (GHC.Generics.URec GHC.Types.Char a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWZF eta_sbWZG]
        case eta_sbWZG of {
          GHC.Generics.UChar a1_sbWZI [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWZF of sat_sbWZJ {
                __DEFAULT -> GHC.Base.pure sat_sbWZJ wild_sbWZH;
              };
        };

Data.Traversable.$fTraversableURec3 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Char)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec3
                                                   Data.Foldable.$fFoldableURec3
                                                   Data.Traversable.$fTraversableURec3_$ctraverse
                                                   Data.Traversable.$fTraversableURec3_$csequenceA
                                                   Data.Traversable.$fTraversableURec3_$cmapM
                                                   Data.Traversable.$fTraversableURec3_$csequence];

Data.Traversable.$fTraversableURec4_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) (f a)
     -> f (GHC.Generics.URec (GHC.Ptr.Ptr ()) a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbWZL ds_sbWZM]
        case ds_sbWZM of {
          GHC.Generics.UAddr a1_sbWZO [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbWZL wild_sbWZN;
        };

Data.Traversable.$fTraversableURec4_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a
     -> m (GHC.Generics.URec (GHC.Ptr.Ptr ()) b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWZQ eta_sbWZR eta1_sbWZS]
        case eta1_sbWZS of {
          GHC.Generics.UAddr a1_sbWZU [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWZQ of sat_sbWZV {
                __DEFAULT -> GHC.Base.pure sat_sbWZV wild_sbWZT;
              };
        };

Data.Traversable.$fTraversableURec4_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) (m a)
     -> m (GHC.Generics.URec (GHC.Ptr.Ptr ()) a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbWZX eta_sbWZY]
        case eta_sbWZY of {
          GHC.Generics.UAddr a1_sbX00 [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbWZX of sat_sbX01 {
                __DEFAULT -> GHC.Base.pure sat_sbX01 wild_sbWZZ;
              };
        };

Data.Traversable.$fTraversableURec4 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable
       (GHC.Generics.URec (GHC.Ptr.Ptr ()))
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec4
                                                   Data.Foldable.$fFoldableURec4
                                                   Data.Traversable.$fTraversableURec4_$ctraverse
                                                   Data.Traversable.$fTraversableURec4_$csequenceA
                                                   Data.Traversable.$fTraversableURec4_$cmapM
                                                   Data.Traversable.$fTraversableURec4_$csequence];

Data.Traversable.$fTraversable:.:_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     (GHC.Generics.:.:) f g (f1 a) -> f1 ((GHC.Generics.:.:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(A,A,C(C1(U)),A,A,A)><L,U(U(U,U),U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX03
           $dTraversable1_sbX04
           $dApplicative_sbX05
           eta_B1]
        Data.Traversable.$fTraversable:.:_$ctraverse
            $dTraversable_sbX03
            $dTraversable1_sbX04
            $dApplicative_sbX05
            GHC.Base.id
            eta_B1;

Data.Traversable.$fTraversable:.:_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> (GHC.Generics.:.:) f g a -> m ((GHC.Generics.:.:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX06
           $dTraversable1_sbX07
           $dMonad_sbX08
           eta_sbX09
           eta1_sbX0a]
        case GHC.Base.$p1Monad $dMonad_sbX08 of sat_sbX0b {
          __DEFAULT ->
              Data.Traversable.$fTraversable:.:_$ctraverse
                  $dTraversable_sbX06
                  $dTraversable1_sbX07
                  sat_sbX0b
                  eta_sbX09
                  eta1_sbX0a;
        };

Data.Traversable.$fTraversable:.:_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     (GHC.Generics.:.:) f g (m a) -> m ((GHC.Generics.:.:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX0c
           $dTraversable1_sbX0d
           $dMonad_sbX0e
           eta_sbX0f]
        case GHC.Base.$p1Monad $dMonad_sbX0e of sat_sbX0g {
          __DEFAULT ->
              Data.Traversable.$fTraversable:.:_$ctraverse
                  $dTraversable_sbX0c
                  $dTraversable1_sbX0d
                  sat_sbX0g
                  GHC.Base.id
                  eta_sbX0f;
        };

Data.Traversable.$fTraversable:.: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (f GHC.Generics.:.: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(U),C(U)),1*U(A,C(C1(U)),C(C1(C1(U))),A,A,A,A,A,A,U,A,A,A,A,A,A),C(C1(U)),A,A,A)>m] =
    [] \r [$dTraversable_sbX0h $dTraversable1_sbX0i]
        let {
          sat_sbX0o [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               (GHC.Generics.:.:) f_abVB0 g_abVB1 (m a)
               -> m ((GHC.Generics.:.:) f_abVB0 g_abVB1 a)
          [LclId] =
              [$dTraversable_sbX0h $dTraversable1_sbX0i] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:.:_$csequence
                      $dTraversable_sbX0h $dTraversable1_sbX0i eta_B2 eta_B1; } in
        let {
          sat_sbX0n [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> (GHC.Generics.:.:) f_abVB0 g_abVB1 a
               -> m ((GHC.Generics.:.:) f_abVB0 g_abVB1 b)
          [LclId] =
              [$dTraversable_sbX0h $dTraversable1_sbX0i] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:.:_$cmapM
                      $dTraversable_sbX0h $dTraversable1_sbX0i eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbX0m [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               (GHC.Generics.:.:) f_abVB0 g_abVB1 (f a)
               -> f ((GHC.Generics.:.:) f_abVB0 g_abVB1 a)
          [LclId] =
              [$dTraversable_sbX0h $dTraversable1_sbX0i] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:.:_$csequenceA
                      $dTraversable_sbX0h $dTraversable1_sbX0i eta_B2 eta_B1; } in
        let {
          sat_sbX0l [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> (GHC.Generics.:.:) f_abVB0 g_abVB1 a
               -> f ((GHC.Generics.:.:) f_abVB0 g_abVB1 b)
          [LclId] =
              [$dTraversable_sbX0h $dTraversable1_sbX0i] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:.:_$ctraverse
                      $dTraversable_sbX0h $dTraversable1_sbX0i eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbX0k [Occ=Once]
            :: Data.Foldable.Foldable (f_abVB0 GHC.Generics.:.: g_abVB1)
          [LclId] =
              [$dTraversable_sbX0h $dTraversable1_sbX0i] \u []
                  Data.Traversable.$fTraversable:.:_$cp2Traversable
                      $dTraversable_sbX0h $dTraversable1_sbX0i; } in
        let {
          sat_sbX0j [Occ=Once]
            :: GHC.Base.Functor (f_abVB0 GHC.Generics.:.: g_abVB1)
          [LclId] =
              [$dTraversable_sbX0h $dTraversable1_sbX0i] \u []
                  Data.Traversable.$fTraversable:.:_$cp1Traversable
                      $dTraversable_sbX0h $dTraversable1_sbX0i;
        } in 
          Data.Traversable.C:Traversable [sat_sbX0j
                                          sat_sbX0k
                                          sat_sbX0l
                                          sat_sbX0m
                                          sat_sbX0n
                                          sat_sbX0o];

Data.Traversable.$fTraversable:*:_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     (GHC.Generics.:*:) f g (f1 a) -> f1 ((GHC.Generics.:*:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX0p
           $dTraversable1_sbX0q
           $dApplicative_sbX0r
           w_sbX0s]
        case w_sbX0s of {
          GHC.Generics.:*: ww1_sbX0u [Occ=Once] ww2_sbX0v [Occ=Once] ->
              Data.Traversable.$w$ctraverse
                  $dTraversable_sbX0p
                  $dTraversable1_sbX0q
                  $dApplicative_sbX0r
                  GHC.Base.id
                  ww1_sbX0u
                  ww2_sbX0v;
        };

Data.Traversable.$fTraversable:*:_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> (GHC.Generics.:*:) f g a -> m ((GHC.Generics.:*:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(U,U,U,U,U,U),A,A,A,A)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX0w
           $dTraversable1_sbX0x
           $dMonad_sbX0y
           eta_sbX0z
           eta1_sbX0A]
        case eta1_sbX0A of {
          GHC.Generics.:*: ww1_sbX0C [Occ=Once] ww2_sbX0D [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbX0y of sat_sbX0E {
                __DEFAULT ->
                    Data.Traversable.$w$ctraverse
                        $dTraversable_sbX0w
                        $dTraversable1_sbX0x
                        sat_sbX0E
                        eta_sbX0z
                        ww1_sbX0C
                        ww2_sbX0D;
              };
        };

Data.Traversable.$fTraversable:*:_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     (GHC.Generics.:*:) f g (m a) -> m ((GHC.Generics.:*:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(U,U,U,U,U,U),A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX0F
           $dTraversable1_sbX0G
           $dMonad_sbX0H
           eta_sbX0I]
        case eta_sbX0I of {
          GHC.Generics.:*: ww1_sbX0K [Occ=Once] ww2_sbX0L [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbX0H of sat_sbX0M {
                __DEFAULT ->
                    Data.Traversable.$w$ctraverse
                        $dTraversable_sbX0F
                        $dTraversable1_sbX0G
                        sat_sbX0M
                        GHC.Base.id
                        ww1_sbX0K
                        ww2_sbX0L;
              };
        };

Data.Traversable.$fTraversable:*: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (f GHC.Generics.:*: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),C(C1(U))),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(C1(U)),C(C1(U))),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sbX0N $dTraversable1_sbX0O]
        let {
          sat_sbX0U [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               (GHC.Generics.:*:) f_abVCk g_abVCl (m a)
               -> m ((GHC.Generics.:*:) f_abVCk g_abVCl a)
          [LclId] =
              [$dTraversable_sbX0N $dTraversable1_sbX0O] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:*:_$csequence
                      $dTraversable_sbX0N $dTraversable1_sbX0O eta_B2 eta_B1; } in
        let {
          sat_sbX0T [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> (GHC.Generics.:*:) f_abVCk g_abVCl a
               -> m ((GHC.Generics.:*:) f_abVCk g_abVCl b)
          [LclId] =
              [$dTraversable_sbX0N $dTraversable1_sbX0O] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:*:_$cmapM
                      $dTraversable_sbX0N $dTraversable1_sbX0O eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbX0S [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               (GHC.Generics.:*:) f_abVCk g_abVCl (f a)
               -> f ((GHC.Generics.:*:) f_abVCk g_abVCl a)
          [LclId] =
              [$dTraversable_sbX0N $dTraversable1_sbX0O] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:*:_$csequenceA
                      $dTraversable_sbX0N $dTraversable1_sbX0O eta_B2 eta_B1; } in
        let {
          sat_sbX0R [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> (GHC.Generics.:*:) f_abVCk g_abVCl a
               -> f ((GHC.Generics.:*:) f_abVCk g_abVCl b)
          [LclId] =
              [$dTraversable_sbX0N $dTraversable1_sbX0O] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:*:_$ctraverse
                      $dTraversable_sbX0N $dTraversable1_sbX0O eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbX0Q [Occ=Once]
            :: Data.Foldable.Foldable (f_abVCk GHC.Generics.:*: g_abVCl)
          [LclId] =
              [$dTraversable_sbX0N $dTraversable1_sbX0O] \u []
                  Data.Traversable.$fTraversable:*:_$cp2Traversable
                      $dTraversable_sbX0N $dTraversable1_sbX0O; } in
        let {
          sat_sbX0P [Occ=Once]
            :: GHC.Base.Functor (f_abVCk GHC.Generics.:*: g_abVCl)
          [LclId] =
              [$dTraversable_sbX0N $dTraversable1_sbX0O] \u []
                  Data.Traversable.$fTraversable:*:_$cp1Traversable
                      $dTraversable_sbX0N $dTraversable1_sbX0O;
        } in 
          Data.Traversable.C:Traversable [sat_sbX0P
                                          sat_sbX0Q
                                          sat_sbX0R
                                          sat_sbX0S
                                          sat_sbX0T
                                          sat_sbX0U];

Data.Traversable.$fTraversable:+:_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     (GHC.Generics.:+:) f g (f1 a) -> f1 ((GHC.Generics.:+:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(U(U,U),U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX0V
           $dTraversable1_sbX0W
           $dApplicative_sbX0X
           eta_B1]
        Data.Traversable.$fTraversable:+:_$ctraverse
            $dTraversable_sbX0V
            $dTraversable1_sbX0W
            $dApplicative_sbX0X
            GHC.Base.id
            eta_B1;

Data.Traversable.$fTraversable:+:_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> (GHC.Generics.:+:) f g a -> m ((GHC.Generics.:+:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX0Y
           $dTraversable1_sbX0Z
           $dMonad_sbX10
           eta_sbX11
           eta1_sbX12]
        case GHC.Base.$p1Monad $dMonad_sbX10 of sat_sbX13 {
          __DEFAULT ->
              Data.Traversable.$fTraversable:+:_$ctraverse
                  $dTraversable_sbX0Y
                  $dTraversable1_sbX0Z
                  sat_sbX13
                  eta_sbX11
                  eta1_sbX12;
        };

Data.Traversable.$fTraversable:+:_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     (GHC.Generics.:+:) f g (m a) -> m ((GHC.Generics.:+:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX14
           $dTraversable1_sbX15
           $dMonad_sbX16
           eta_sbX17]
        case GHC.Base.$p1Monad $dMonad_sbX16 of sat_sbX18 {
          __DEFAULT ->
              Data.Traversable.$fTraversable:+:_$ctraverse
                  $dTraversable_sbX14
                  $dTraversable1_sbX15
                  sat_sbX18
                  GHC.Base.id
                  eta_sbX17;
        };

Data.Traversable.$fTraversable:+: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (f GHC.Generics.:+: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),C(C1(U))),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(C1(U)),C(C1(U))),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sbX19 $dTraversable1_sbX1a]
        let {
          sat_sbX1g [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               (GHC.Generics.:+:) f_abVDE g_abVDF (m a)
               -> m ((GHC.Generics.:+:) f_abVDE g_abVDF a)
          [LclId] =
              [$dTraversable_sbX19 $dTraversable1_sbX1a] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:+:_$csequence
                      $dTraversable_sbX19 $dTraversable1_sbX1a eta_B2 eta_B1; } in
        let {
          sat_sbX1f [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> (GHC.Generics.:+:) f_abVDE g_abVDF a
               -> m ((GHC.Generics.:+:) f_abVDE g_abVDF b)
          [LclId] =
              [$dTraversable_sbX19 $dTraversable1_sbX1a] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:+:_$cmapM
                      $dTraversable_sbX19 $dTraversable1_sbX1a eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbX1e [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               (GHC.Generics.:+:) f_abVDE g_abVDF (f a)
               -> f ((GHC.Generics.:+:) f_abVDE g_abVDF a)
          [LclId] =
              [$dTraversable_sbX19 $dTraversable1_sbX1a] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:+:_$csequenceA
                      $dTraversable_sbX19 $dTraversable1_sbX1a eta_B2 eta_B1; } in
        let {
          sat_sbX1d [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> (GHC.Generics.:+:) f_abVDE g_abVDF a
               -> f ((GHC.Generics.:+:) f_abVDE g_abVDF b)
          [LclId] =
              [$dTraversable_sbX19 $dTraversable1_sbX1a] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:+:_$ctraverse
                      $dTraversable_sbX19 $dTraversable1_sbX1a eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbX1c [Occ=Once]
            :: Data.Foldable.Foldable (f_abVDE GHC.Generics.:+: g_abVDF)
          [LclId] =
              [$dTraversable_sbX19 $dTraversable1_sbX1a] \u []
                  Data.Traversable.$fTraversable:+:_$cp2Traversable
                      $dTraversable_sbX19 $dTraversable1_sbX1a; } in
        let {
          sat_sbX1b [Occ=Once]
            :: GHC.Base.Functor (f_abVDE GHC.Generics.:+: g_abVDF)
          [LclId] =
              [$dTraversable_sbX19 $dTraversable1_sbX1a] \u []
                  Data.Traversable.$fTraversable:+:_$cp1Traversable
                      $dTraversable_sbX19 $dTraversable1_sbX1a;
        } in 
          Data.Traversable.C:Traversable [sat_sbX1b
                                          sat_sbX1c
                                          sat_sbX1d
                                          sat_sbX1e
                                          sat_sbX1f
                                          sat_sbX1g];

Data.Traversable.$fTraversableM1_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     GHC.Generics.M1 i c f (f1 a) -> f1 (GHC.Generics.M1 i c f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX1h $dApplicative_sbX1i eta_sbX1j]
        let {
          sat_sbX1l [Occ=Once] :: f1_abVFI (f_abVF5 a_abVFJ)
          [LclId] =
              [$dTraversable_sbX1h $dApplicative_sbX1i eta_sbX1j] \u []
                  Data.Traversable.traverse
                      $dTraversable_sbX1h $dApplicative_sbX1i GHC.Base.id eta_sbX1j;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbX1i of sat_sbX1k {
            __DEFAULT ->
                GHC.Base.fmap sat_sbX1k Data.Traversable.$fTraversableM2 sat_sbX1l;
          };

Data.Traversable.$fTraversableM1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.M1 i c f a -> m (GHC.Generics.M1 i c f b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX1m $dMonad_sbX1n eta_sbX1o eta1_sbX1p]
        case
            GHC.Base.$p1Monad $dMonad_sbX1n
        of
        $dApplicative_sbX1q [Dmd=<S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)>]
        { __DEFAULT ->
              let {
                sat_sbX1s [Occ=Once] :: m_abVFU (f_abVF5 b_abVFW)
                [LclId] =
                    [$dTraversable_sbX1m
                     eta_sbX1o
                     eta1_sbX1p
                     $dApplicative_sbX1q] \u []
                        Data.Traversable.traverse
                            $dTraversable_sbX1m $dApplicative_sbX1q eta_sbX1o eta1_sbX1p;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbX1q of sat_sbX1r {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sbX1r Data.Traversable.$fTraversableM2 sat_sbX1s;
                };
        };

Data.Traversable.$fTraversableM1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.M1 i c f (m a) -> m (GHC.Generics.M1 i c f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX1t $dMonad_sbX1u eta_sbX1v]
        case
            GHC.Base.$p1Monad $dMonad_sbX1u
        of
        $dApplicative_sbX1w [Dmd=<S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)>]
        { __DEFAULT ->
              let {
                sat_sbX1y [Occ=Once] :: m_abVG8 (f_abVF5 a_abVG9)
                [LclId] =
                    [$dTraversable_sbX1t eta_sbX1v $dApplicative_sbX1w] \u []
                        Data.Traversable.traverse
                            $dTraversable_sbX1t $dApplicative_sbX1w GHC.Base.id eta_sbX1v;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbX1w of sat_sbX1x {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sbX1x Data.Traversable.$fTraversableM2 sat_sbX1y;
                };
        };

Data.Traversable.$fTraversableM1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     Data.Traversable.Traversable (GHC.Generics.M1 i c f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(1*U(1*U,1*U),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sbX1z]
        let {
          sat_sbX1F [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 (m a)
               -> m (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 a)
          [LclId] =
              [$dTraversable_sbX1z] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableM1_$csequence
                      $dTraversable_sbX1z eta_B2 eta_B1; } in
        let {
          sat_sbX1E [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 a
               -> m (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 b)
          [LclId] =
              [$dTraversable_sbX1z] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableM1_$cmapM
                      $dTraversable_sbX1z eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbX1D [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 (f a)
               -> f (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 a)
          [LclId] =
              [$dTraversable_sbX1z] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableM1_$csequenceA
                      $dTraversable_sbX1z eta_B2 eta_B1; } in
        let {
          sat_sbX1C [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 a
               -> f (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 b)
          [LclId] =
              [$dTraversable_sbX1z] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableM1_$ctraverse
                      $dTraversable_sbX1z eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbX1B [Occ=Once]
            :: Data.Foldable.Foldable (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5)
          [LclId] =
              [$dTraversable_sbX1z] \u []
                  Data.Traversable.$fTraversableM1_$cp2Traversable
                      $dTraversable_sbX1z; } in
        let {
          sat_sbX1A [Occ=Once]
            :: GHC.Base.Functor (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5)
          [LclId] =
              [$dTraversable_sbX1z] \u []
                  Data.Traversable.$fTraversableM1_$cp1Traversable
                      $dTraversable_sbX1z;
        } in 
          Data.Traversable.C:Traversable [sat_sbX1A
                                          sat_sbX1B
                                          sat_sbX1C
                                          sat_sbX1D
                                          sat_sbX1E
                                          sat_sbX1F];

Data.Traversable.$fTraversableK1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall i c (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Generics.K1 i c a -> m (GHC.Generics.K1 i c b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX1G eta_sbX1H eta1_sbX1I]
        case GHC.Base.$p1Monad $dMonad_sbX1G of sat_sbX1J {
          __DEFAULT -> GHC.Base.pure sat_sbX1J eta1_sbX1I;
        };

Data.Traversable.$fTraversableK1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall i c (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.K1 i c (m a) -> m (GHC.Generics.K1 i c a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX1K eta_sbX1L]
        case GHC.Base.$p1Monad $dMonad_sbX1K of sat_sbX1M {
          __DEFAULT -> GHC.Base.pure sat_sbX1M eta_sbX1L;
        };

$fTraversableK2_rbWTS
  :: forall c i (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.K1 i c (f a) -> f (GHC.Generics.K1 i c a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX1N z_sbX1O]
        GHC.Base.pure $dApplicative_sbX1N z_sbX1O;

Data.Traversable.$fTraversableK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i c. Data.Traversable.Traversable (GHC.Generics.K1 i c)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorK1
                                                   Data.Foldable.$fFoldableK1
                                                   Data.Traversable.$fTraversableK1_$ctraverse
                                                   $fTraversableK2_rbWTS
                                                   Data.Traversable.$fTraversableK1_$cmapM
                                                   Data.Traversable.$fTraversableK1_$csequence];

Data.Traversable.$fTraversableRec1_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     GHC.Generics.Rec1 f (f1 a) -> f1 (GHC.Generics.Rec1 f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX1P $dApplicative_sbX1Q eta_sbX1R]
        let {
          sat_sbX1T [Occ=Once] :: f1_abVHV (f_abVHm a_abVHW)
          [LclId] =
              [$dTraversable_sbX1P $dApplicative_sbX1Q eta_sbX1R] \u []
                  Data.Traversable.traverse
                      $dTraversable_sbX1P $dApplicative_sbX1Q GHC.Base.id eta_sbX1R;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbX1Q of sat_sbX1S {
            __DEFAULT ->
                GHC.Base.fmap sat_sbX1S Data.Traversable.$fTraversableM2 sat_sbX1T;
          };

Data.Traversable.$fTraversableRec1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Generics.Rec1 f a -> m (GHC.Generics.Rec1 f b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX1U $dMonad_sbX1V eta_sbX1W eta1_sbX1X]
        case
            GHC.Base.$p1Monad $dMonad_sbX1V
        of
        $dApplicative_sbX1Y [Dmd=<S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)>]
        { __DEFAULT ->
              let {
                sat_sbX20 [Occ=Once] :: m_abVI7 (f_abVHm b_abVI9)
                [LclId] =
                    [$dTraversable_sbX1U
                     eta_sbX1W
                     eta1_sbX1X
                     $dApplicative_sbX1Y] \u []
                        Data.Traversable.traverse
                            $dTraversable_sbX1U $dApplicative_sbX1Y eta_sbX1W eta1_sbX1X;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbX1Y of sat_sbX1Z {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sbX1Z Data.Traversable.$fTraversableM2 sat_sbX20;
                };
        };

Data.Traversable.$fTraversableRec1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.Rec1 f (m a) -> m (GHC.Generics.Rec1 f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX21 $dMonad_sbX22 eta_sbX23]
        case
            GHC.Base.$p1Monad $dMonad_sbX22
        of
        $dApplicative_sbX24 [Dmd=<S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)>]
        { __DEFAULT ->
              let {
                sat_sbX26 [Occ=Once] :: m_abVIl (f_abVHm a_abVIm)
                [LclId] =
                    [$dTraversable_sbX21 eta_sbX23 $dApplicative_sbX24] \u []
                        Data.Traversable.traverse
                            $dTraversable_sbX21 $dApplicative_sbX24 GHC.Base.id eta_sbX23;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbX24 of sat_sbX25 {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sbX25 Data.Traversable.$fTraversableM2 sat_sbX26;
                };
        };

Data.Traversable.$fTraversableRec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     Data.Traversable.Traversable (GHC.Generics.Rec1 f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(1*U(1*U,1*U),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sbX27]
        let {
          sat_sbX2d [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               GHC.Generics.Rec1 f_abVHm (m a) -> m (GHC.Generics.Rec1 f_abVHm a)
          [LclId] =
              [$dTraversable_sbX27] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableRec1_$csequence
                      $dTraversable_sbX27 eta_B2 eta_B1; } in
        let {
          sat_sbX2c [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> GHC.Generics.Rec1 f_abVHm a -> m (GHC.Generics.Rec1 f_abVHm b)
          [LclId] =
              [$dTraversable_sbX27] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableRec1_$cmapM
                      $dTraversable_sbX27 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbX2b [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               GHC.Generics.Rec1 f_abVHm (f a) -> f (GHC.Generics.Rec1 f_abVHm a)
          [LclId] =
              [$dTraversable_sbX27] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableRec1_$csequenceA
                      $dTraversable_sbX27 eta_B2 eta_B1; } in
        let {
          sat_sbX2a [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> GHC.Generics.Rec1 f_abVHm a -> f (GHC.Generics.Rec1 f_abVHm b)
          [LclId] =
              [$dTraversable_sbX27] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableRec1_$ctraverse
                      $dTraversable_sbX27 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbX29 [Occ=Once]
            :: Data.Foldable.Foldable (GHC.Generics.Rec1 f_abVHm)
          [LclId] =
              [$dTraversable_sbX27] \u []
                  Data.Traversable.$fTraversableRec1_$cp2Traversable
                      $dTraversable_sbX27; } in
        let {
          sat_sbX28 [Occ=Once]
            :: GHC.Base.Functor (GHC.Generics.Rec1 f_abVHm)
          [LclId] =
              [$dTraversable_sbX27] \u []
                  Data.Traversable.$fTraversableRec1_$cp1Traversable
                      $dTraversable_sbX27;
        } in 
          Data.Traversable.C:Traversable [sat_sbX28
                                          sat_sbX29
                                          sat_sbX2a
                                          sat_sbX2b
                                          sat_sbX2c
                                          sat_sbX2d];

Data.Traversable.$fTraversablePar1_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.Par1 (f a) -> f (GHC.Generics.Par1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX2e eta_sbX2f]
        case GHC.Base.$p1Applicative $dApplicative_sbX2e of sat_sbX2g {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sbX2g Data.Traversable.$fTraversableDual1 eta_sbX2f;
        };

Data.Traversable.$fTraversablePar1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Generics.Par1 a -> m (GHC.Generics.Par1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX2h eta_sbX2i eta1_sbX2j]
        let {
          sat_sbX2m [Occ=Once] :: m_abVJ7 b_abVJ9
          [LclId] =
              [eta_sbX2i eta1_sbX2j] \u [] eta_sbX2i eta1_sbX2j;
        } in 
          case GHC.Base.$p1Monad $dMonad_sbX2h of sat_sbX2k {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sbX2k of sat_sbX2l {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sbX2l Data.Traversable.$fTraversableDual1 sat_sbX2m;
                };
          };

Data.Traversable.$fTraversablePar1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.Par1 (m a) -> m (GHC.Generics.Par1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX2n eta_sbX2o]
        case GHC.Base.$p1Monad $dMonad_sbX2n of sat_sbX2p {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sbX2p of sat_sbX2q {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sbX2q Data.Traversable.$fTraversableDual1 eta_sbX2o;
              };
        };

Data.Traversable.$fTraversablePar1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable GHC.Generics.Par1
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorPar1
                                                   Data.Foldable.$fFoldablePar1
                                                   Data.Traversable.$fTraversablePar1_$ctraverse
                                                   Data.Traversable.$fTraversablePar1_$csequenceA
                                                   Data.Traversable.$fTraversablePar1_$cmapM
                                                   Data.Traversable.$fTraversablePar1_$csequence];

Data.Traversable.$fTraversableV1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Generics.V1 a -> m (GHC.Generics.V1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX2r eta_sbX2s eta1_sbX2t]
        case GHC.Base.$p1Monad $dMonad_sbX2r of sat_sbX2u {
          __DEFAULT -> GHC.Base.pure sat_sbX2u eta1_sbX2t;
        };

Data.Traversable.$fTraversableV1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.V1 (m a) -> m (GHC.Generics.V1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX2v eta_sbX2w]
        case GHC.Base.$p1Monad $dMonad_sbX2v of sat_sbX2x {
          __DEFAULT -> GHC.Base.pure sat_sbX2x eta_sbX2w;
        };

$fTraversableV2_rbWTT
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.V1 (f a) -> f (GHC.Generics.V1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX2y z_sbX2z]
        GHC.Base.pure $dApplicative_sbX2y z_sbX2z;

Data.Traversable.$fTraversableV1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable GHC.Generics.V1
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorV1
                                                   Data.Foldable.$fFoldableV1
                                                   Data.Traversable.$fTraversableV1_$ctraverse
                                                   $fTraversableV2_rbWTT
                                                   Data.Traversable.$fTraversableV1_$cmapM
                                                   Data.Traversable.$fTraversableV1_$csequence];

Data.Traversable.$fTraversableIdentity_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Functor.Identity.Identity (f a)
     -> f (Data.Functor.Identity.Identity a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX2A eta_sbX2B]
        case GHC.Base.$p1Applicative $dApplicative_sbX2A of sat_sbX2C {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sbX2C Data.Traversable.$fTraversableDual1 eta_sbX2B;
        };

Data.Traversable.$fTraversableIdentity_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Functor.Identity.Identity a
     -> m (Data.Functor.Identity.Identity b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX2D eta_sbX2E eta1_sbX2F]
        let {
          sat_sbX2I [Occ=Once] :: m_abVL8 b_abVLa
          [LclId] =
              [eta_sbX2E eta1_sbX2F] \u [] eta_sbX2E eta1_sbX2F;
        } in 
          case GHC.Base.$p1Monad $dMonad_sbX2D of sat_sbX2G {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sbX2G of sat_sbX2H {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sbX2H Data.Traversable.$fTraversableDual1 sat_sbX2I;
                };
          };

Data.Traversable.$fTraversableIdentity_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Functor.Identity.Identity (m a)
     -> m (Data.Functor.Identity.Identity a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX2J eta_sbX2K]
        case GHC.Base.$p1Monad $dMonad_sbX2J of sat_sbX2L {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sbX2L of sat_sbX2M {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sbX2M Data.Traversable.$fTraversableDual1 eta_sbX2K;
              };
        };

Data.Traversable.$fTraversableIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Functor.Identity.$fFunctorIdentity
                                                   Data.Functor.Identity.$fFoldableIdentity
                                                   Data.Traversable.$fTraversableIdentity_$ctraverse
                                                   Data.Traversable.$fTraversableIdentity_$csequenceA
                                                   Data.Traversable.$fTraversableIdentity_$cmapM
                                                   Data.Traversable.$fTraversableIdentity_$csequence];

Data.Traversable.$fTraversableProduct_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Internal.Product (f a)
     -> f (Data.Semigroup.Internal.Product a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX2N eta_sbX2O]
        case GHC.Base.$p1Applicative $dApplicative_sbX2N of sat_sbX2P {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sbX2P Data.Traversable.$fTraversableDual1 eta_sbX2O;
        };

Data.Traversable.$fTraversableProduct_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Semigroup.Internal.Product a
     -> m (Data.Semigroup.Internal.Product b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX2Q eta_sbX2R eta1_sbX2S]
        let {
          sat_sbX2V [Occ=Once] :: m_abVQs b_abVQu
          [LclId] =
              [eta_sbX2R eta1_sbX2S] \u [] eta_sbX2R eta1_sbX2S;
        } in 
          case GHC.Base.$p1Monad $dMonad_sbX2Q of sat_sbX2T {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sbX2T of sat_sbX2U {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sbX2U Data.Traversable.$fTraversableDual1 sat_sbX2V;
                };
          };

Data.Traversable.$fTraversableProduct_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Internal.Product (m a)
     -> m (Data.Semigroup.Internal.Product a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX2W eta_sbX2X]
        case GHC.Base.$p1Monad $dMonad_sbX2W of sat_sbX2Y {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sbX2Y of sat_sbX2Z {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sbX2Z Data.Traversable.$fTraversableDual1 eta_sbX2X;
              };
        };

Data.Traversable.$fTraversableProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Internal.Product
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.Internal.$fFunctorProduct
                                                   Data.Foldable.$fFoldableProduct
                                                   Data.Traversable.$fTraversableProduct_$ctraverse
                                                   Data.Traversable.$fTraversableProduct_$csequenceA
                                                   Data.Traversable.$fTraversableProduct_$cmapM
                                                   Data.Traversable.$fTraversableProduct_$csequence];

Data.Traversable.$fTraversableSum_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Internal.Sum (f a)
     -> f (Data.Semigroup.Internal.Sum a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX30 eta_sbX31]
        case GHC.Base.$p1Applicative $dApplicative_sbX30 of sat_sbX32 {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sbX32 Data.Traversable.$fTraversableDual1 eta_sbX31;
        };

Data.Traversable.$fTraversableSum_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Semigroup.Internal.Sum a
     -> m (Data.Semigroup.Internal.Sum b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX33 eta_sbX34 eta1_sbX35]
        let {
          sat_sbX38 [Occ=Once] :: m_abVRs b_abVRu
          [LclId] =
              [eta_sbX34 eta1_sbX35] \u [] eta_sbX34 eta1_sbX35;
        } in 
          case GHC.Base.$p1Monad $dMonad_sbX33 of sat_sbX36 {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sbX36 of sat_sbX37 {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sbX37 Data.Traversable.$fTraversableDual1 sat_sbX38;
                };
          };

Data.Traversable.$fTraversableSum_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Internal.Sum (m a)
     -> m (Data.Semigroup.Internal.Sum a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX39 eta_sbX3a]
        case GHC.Base.$p1Monad $dMonad_sbX39 of sat_sbX3b {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sbX3b of sat_sbX3c {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sbX3c Data.Traversable.$fTraversableDual1 eta_sbX3a;
              };
        };

Data.Traversable.$fTraversableSum [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Internal.Sum
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.Internal.$fFunctorSum
                                                   Data.Foldable.$fFoldableSum
                                                   Data.Traversable.$fTraversableSum_$ctraverse
                                                   Data.Traversable.$fTraversableSum_$csequenceA
                                                   Data.Traversable.$fTraversableSum_$cmapM
                                                   Data.Traversable.$fTraversableSum_$csequence];

Data.Traversable.$fTraversableDual_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Internal.Dual (f a)
     -> f (Data.Semigroup.Internal.Dual a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX3d eta_sbX3e]
        case GHC.Base.$p1Applicative $dApplicative_sbX3d of sat_sbX3f {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sbX3f Data.Traversable.$fTraversableDual1 eta_sbX3e;
        };

Data.Traversable.$fTraversableDual_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Semigroup.Internal.Dual a
     -> m (Data.Semigroup.Internal.Dual b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX3g eta_sbX3h eta1_sbX3i]
        let {
          sat_sbX3l [Occ=Once] :: m_abVSs b_abVSu
          [LclId] =
              [eta_sbX3h eta1_sbX3i] \u [] eta_sbX3h eta1_sbX3i;
        } in 
          case GHC.Base.$p1Monad $dMonad_sbX3g of sat_sbX3j {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sbX3j of sat_sbX3k {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sbX3k Data.Traversable.$fTraversableDual1 sat_sbX3l;
                };
          };

Data.Traversable.$fTraversableDual_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Internal.Dual (m a)
     -> m (Data.Semigroup.Internal.Dual a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX3m eta_sbX3n]
        case GHC.Base.$p1Monad $dMonad_sbX3m of sat_sbX3o {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sbX3o of sat_sbX3p {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sbX3p Data.Traversable.$fTraversableDual1 eta_sbX3n;
              };
        };

Data.Traversable.$fTraversableDual [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Internal.Dual
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.Internal.$fFunctorDual
                                                   Data.Foldable.$fFoldableDual
                                                   Data.Traversable.$fTraversableDual_$ctraverse
                                                   Data.Traversable.$fTraversableDual_$csequenceA
                                                   Data.Traversable.$fTraversableDual_$cmapM
                                                   Data.Traversable.$fTraversableDual_$csequence];

Data.Traversable.$fTraversableConst_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall m1 (m2 :: * -> *) a b.
     GHC.Base.Monad m2 =>
     (a -> m2 b)
     -> Data.Functor.Const.Const m1 a
     -> m2 (Data.Functor.Const.Const m1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX3q eta_sbX3r eta1_sbX3s]
        case GHC.Base.$p1Monad $dMonad_sbX3q of sat_sbX3t {
          __DEFAULT -> GHC.Base.pure sat_sbX3t eta1_sbX3s;
        };

Data.Traversable.$fTraversableConst_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall m1 (m2 :: * -> *) a.
     GHC.Base.Monad m2 =>
     Data.Functor.Const.Const m1 (m2 a)
     -> m2 (Data.Functor.Const.Const m1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX3u eta_sbX3v]
        case GHC.Base.$p1Monad $dMonad_sbX3u of sat_sbX3w {
          __DEFAULT -> GHC.Base.pure sat_sbX3w eta_sbX3v;
        };

$fTraversableConst1_rbWTU
  :: forall m (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Functor.Const.Const m (f a)
     -> f (Data.Functor.Const.Const m a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX3x ds_sbX3y]
        GHC.Base.pure $dApplicative_sbX3x ds_sbX3y;

Data.Traversable.$fTraversableConst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     Data.Traversable.Traversable (Data.Functor.Const.Const m)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Functor.Const.$fFunctorConst
                                                   Data.Functor.Const.$fFoldableConst
                                                   Data.Traversable.$fTraversableConst_$ctraverse
                                                   $fTraversableConst1_rbWTU
                                                   Data.Traversable.$fTraversableConst_$cmapM
                                                   Data.Traversable.$fTraversableConst_$csequence];

Data.Traversable.$fTraversable(,)_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (f :: * -> *) a2.
     GHC.Base.Applicative f =>
     (a1, f a2) -> f (a1, a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX3z eta_sbX3A]
        case eta_sbX3A of {
          (,) x_sbX3C [Occ=OnceL] y_sbX3D [Occ=Once] ->
              let {
                sat_sbX3F [Occ=Once] :: a1_abVWL -> (a_abVWj, a1_abVWL)
                [LclId] =
                    [x_sbX3C] \r [eta_B1] (,) [x_sbX3C eta_B1];
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbX3z of sat_sbX3E {
                  __DEFAULT -> GHC.Base.fmap sat_sbX3E sat_sbX3F y_sbX3D;
                };
        };

Data.Traversable.$fTraversable(,)_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2 b.
     GHC.Base.Monad m =>
     (a2 -> m b) -> (a1, a2) -> m (a1, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX3G eta_sbX3H eta1_sbX3I]
        case eta1_sbX3I of {
          (,) x_sbX3K [Occ=OnceL] y_sbX3L [Occ=Once] ->
              let {
                sat_sbX3P [Occ=Once] :: m_abVWW b_abVWY
                [LclId] =
                    [eta_sbX3H y_sbX3L] \u [] eta_sbX3H y_sbX3L; } in
              let {
                sat_sbX3O [Occ=Once] :: b_abVWY -> (a_abVWj, b_abVWY)
                [LclId] =
                    [x_sbX3K] \r [eta_B1] (,) [x_sbX3K eta_B1];
              } in 
                case GHC.Base.$p1Monad $dMonad_sbX3G of sat_sbX3M {
                  __DEFAULT ->
                      case GHC.Base.$p1Applicative sat_sbX3M of sat_sbX3N {
                        __DEFAULT -> GHC.Base.fmap sat_sbX3N sat_sbX3O sat_sbX3P;
                      };
                };
        };

Data.Traversable.$fTraversable(,)_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2.
     GHC.Base.Monad m =>
     (a1, m a2) -> m (a1, a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX3Q eta_sbX3R]
        case eta_sbX3R of {
          (,) x_sbX3T [Occ=OnceL] y_sbX3U [Occ=Once] ->
              let {
                sat_sbX3X [Occ=Once] :: a1_abVXb -> (a_abVWj, a1_abVXb)
                [LclId] =
                    [x_sbX3T] \r [eta_B1] (,) [x_sbX3T eta_B1];
              } in 
                case GHC.Base.$p1Monad $dMonad_sbX3Q of sat_sbX3V {
                  __DEFAULT ->
                      case GHC.Base.$p1Applicative sat_sbX3V of sat_sbX3W {
                        __DEFAULT -> GHC.Base.fmap sat_sbX3W sat_sbX3X y_sbX3U;
                      };
                };
        };

Data.Traversable.$fTraversable(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Traversable.Traversable ((,) a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Base.$fFunctor(,)
                                                   Data.Foldable.$fFoldable(,)
                                                   Data.Traversable.$fTraversable(,)_$ctraverse
                                                   Data.Traversable.$fTraversable(,)_$csequenceA
                                                   Data.Traversable.$fTraversable(,)_$cmapM
                                                   Data.Traversable.$fTraversable(,)_$csequence];

Data.Traversable.$fTraversableEither_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (f :: * -> *) a2.
     GHC.Base.Applicative f =>
     Data.Either.Either a1 (f a2) -> f (Data.Either.Either a1 a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX3Y eta_sbX3Z]
        case eta_sbX3Z of {
          Data.Either.Left x_sbX41 [Occ=Once] ->
              GHC.Base.pure $dApplicative_sbX3Y wild_sbX40;
          Data.Either.Right y_sbX43 [Occ=Once] ->
              case GHC.Base.$p1Applicative $dApplicative_sbX3Y of sat_sbX44 {
                __DEFAULT -> GHC.Base.fmap sat_sbX44 Data.Either.Right y_sbX43;
              };
        };

Data.Traversable.$fTraversableEither_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2 b.
     GHC.Base.Monad m =>
     (a2 -> m b)
     -> Data.Either.Either a1 a2 -> m (Data.Either.Either a1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX45 eta_sbX46 eta1_sbX47]
        case GHC.Base.$p1Monad $dMonad_sbX45 of sat_sbX48 {
          __DEFAULT ->
              Data.Traversable.$fTraversableEither_$ctraverse
                  sat_sbX48 eta_sbX46 eta1_sbX47;
        };

Data.Traversable.$fTraversableEither_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2.
     GHC.Base.Monad m =>
     Data.Either.Either a1 (m a2) -> m (Data.Either.Either a1 a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX49 eta_sbX4a]
        case eta_sbX4a of {
          Data.Either.Left x_sbX4c [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbX49 of sat_sbX4d {
                __DEFAULT -> GHC.Base.pure sat_sbX4d wild_sbX4b;
              };
          Data.Either.Right y_sbX4f [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbX49 of sat_sbX4g {
                __DEFAULT ->
                    case GHC.Base.$p1Applicative sat_sbX4g of sat_sbX4h {
                      __DEFAULT -> GHC.Base.fmap sat_sbX4h Data.Either.Right y_sbX4f;
                    };
              };
        };

Data.Traversable.$fTraversableEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Traversable.Traversable (Data.Either.Either a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Either.$fFunctorEither
                                                   Data.Foldable.$fFoldableEither
                                                   Data.Traversable.$fTraversableEither_$ctraverse
                                                   Data.Traversable.$fTraversableEither_$csequenceA
                                                   Data.Traversable.$fTraversableEither_$cmapM
                                                   Data.Traversable.$fTraversableEither_$csequence];

Data.Traversable.$fTraversable[]_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a. GHC.Base.Applicative f => [f a] -> f [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,1*C1(U),A,C(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX4i]
        let {
          z_sbX4j [Occ=OnceL] :: f_abW0j [a_abW0k]
          [LclId] =
              [$dApplicative_sbX4i] \u []
                  GHC.Base.pure $dApplicative_sbX4i GHC.Types.[]; } in
        let {
          go_sbX4k [Occ=LoopBreaker]
            :: [f_abW0j a_abW0k] -> f_abW0j [a_abW0k]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [$dApplicative_sbX4i z_sbX4j go_sbX4k] \r [ds_sbX4l]
                  case ds_sbX4l of {
                    [] -> z_sbX4j;
                    : y_sbX4n [Occ=Once] ys_sbX4o [Occ=Once] ->
                        let {
                          sat_sbX4p [Occ=Once] :: f_abW0j [a_abW0k]
                          [LclId] =
                              [go_sbX4k ys_sbX4o] \u [] go_sbX4k ys_sbX4o;
                        } in 
                          GHC.Base.liftA2 $dApplicative_sbX4i GHC.Types.: y_sbX4n sat_sbX4p;
                  };
        } in  go_sbX4k;

Data.Traversable.$fTraversable[]_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> [a] -> m [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX4q eta_sbX4r]
        let {
          $dApplicative_sbX4s [Dmd=<L,U(A,1*C1(U),A,C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative m_abW0v
          [LclId] =
              [$dMonad_sbX4q] \u [] GHC.Base.$p1Monad $dMonad_sbX4q; } in
        let {
          z_sbX4t [Occ=OnceL] :: m_abW0v [b_abW0x]
          [LclId] =
              [$dApplicative_sbX4s] \u []
                  GHC.Base.pure $dApplicative_sbX4s GHC.Types.[]; } in
        let {
          go_sbX4u [Occ=LoopBreaker] :: [a_abW0w] -> m_abW0v [b_abW0x]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [eta_sbX4r $dApplicative_sbX4s z_sbX4t go_sbX4u] \r [ds_sbX4v]
                  case ds_sbX4v of {
                    [] -> z_sbX4t;
                    : y_sbX4x [Occ=Once] ys_sbX4y [Occ=Once] ->
                        let {
                          sat_sbX4A [Occ=Once] :: m_abW0v [b_abW0x]
                          [LclId] =
                              [go_sbX4u ys_sbX4y] \u [] go_sbX4u ys_sbX4y; } in
                        let {
                          sat_sbX4z [Occ=Once] :: m_abW0v b_abW0x
                          [LclId] =
                              [eta_sbX4r y_sbX4x] \u [] eta_sbX4r y_sbX4x;
                        } in 
                          GHC.Base.liftA2
                              $dApplicative_sbX4s GHC.Types.: sat_sbX4z sat_sbX4A;
                  };
        } in  go_sbX4u;

Data.Traversable.$fTraversable[]_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a. GHC.Base.Monad m => [m a] -> m [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX4B]
        let {
          $dApplicative_sbX4C [Dmd=<L,U(A,1*C1(U),A,C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative m_abW0J
          [LclId] =
              [$dMonad_sbX4B] \u [] GHC.Base.$p1Monad $dMonad_sbX4B; } in
        let {
          z_sbX4D [Occ=OnceL] :: m_abW0J [a_abW0K]
          [LclId] =
              [$dApplicative_sbX4C] \u []
                  GHC.Base.pure $dApplicative_sbX4C GHC.Types.[]; } in
        let {
          go_sbX4E [Occ=LoopBreaker]
            :: [m_abW0J a_abW0K] -> m_abW0J [a_abW0K]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [$dApplicative_sbX4C z_sbX4D go_sbX4E] \r [ds_sbX4F]
                  case ds_sbX4F of {
                    [] -> z_sbX4D;
                    : y_sbX4H [Occ=Once] ys_sbX4I [Occ=Once] ->
                        let {
                          sat_sbX4J [Occ=Once] :: m_abW0J [a_abW0K]
                          [LclId] =
                              [go_sbX4E ys_sbX4I] \u [] go_sbX4E ys_sbX4I;
                        } in 
                          GHC.Base.liftA2 $dApplicative_sbX4C GHC.Types.: y_sbX4H sat_sbX4J;
                  };
        } in  go_sbX4E;

Data.Traversable.$fTraversable[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable []
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Base.$fFunctor[]
                                                   Data.Foldable.$fFoldable[]
                                                   Data.Traversable.$fTraversable[]_$ctraverse
                                                   Data.Traversable.$fTraversable[]_$csequenceA
                                                   Data.Traversable.$fTraversable[]_$cmapM
                                                   Data.Traversable.$fTraversable[]_$csequence];

Data.Traversable.$fTraversableZipList1 :: forall b. [b] -> [b]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbX4K] v_sbX4K;

Data.Traversable.$fTraversableZipList_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Control.Applicative.ZipList a
     -> f (Control.Applicative.ZipList b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A)><L,C(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX4L eta_sbX4M eta1_sbX4N]
        let {
          sat_sbX4X [Occ=Once] :: f_abVMK [b_abVMM]
          [LclId] =
              [$dApplicative_sbX4L eta_sbX4M eta1_sbX4N] \u []
                  let {
                    z_sbX4P [Occ=OnceL] :: f_abVMK [b_abVMM]
                    [LclId] =
                        [$dApplicative_sbX4L] \u []
                            GHC.Base.pure $dApplicative_sbX4L GHC.Types.[]; } in
                  let {
                    go_sbX4Q [Occ=LoopBreaker] :: [a_abVML] -> f_abVMK [b_abVMM]
                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                        sat-only [$dApplicative_sbX4L
                                  eta_sbX4M
                                  z_sbX4P
                                  go_sbX4Q] \r [ds_sbX4R]
                            case ds_sbX4R of {
                              [] -> z_sbX4P;
                              : y_sbX4T [Occ=Once] ys_sbX4U [Occ=Once] ->
                                  let {
                                    sat_sbX4W [Occ=Once] :: f_abVMK [b_abVMM]
                                    [LclId] =
                                        [go_sbX4Q ys_sbX4U] \u [] go_sbX4Q ys_sbX4U; } in
                                  let {
                                    sat_sbX4V [Occ=Once] :: f_abVMK b_abVMM
                                    [LclId] =
                                        [eta_sbX4M y_sbX4T] \u [] eta_sbX4M y_sbX4T;
                                  } in 
                                    GHC.Base.liftA2
                                        $dApplicative_sbX4L GHC.Types.: sat_sbX4V sat_sbX4W;
                            };
                  } in  go_sbX4Q eta1_sbX4N;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbX4L of sat_sbX4O {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sbX4O Data.Traversable.$fTraversableZipList1 sat_sbX4X;
          };

Data.Traversable.$fTraversableZipList_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Control.Applicative.ZipList (f a)
     -> f (Control.Applicative.ZipList a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX4Y eta_B1]
        Data.Traversable.$fTraversableZipList_$ctraverse
            $dApplicative_sbX4Y GHC.Base.id eta_B1;

Data.Traversable.$fTraversableZipList_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Control.Applicative.ZipList a
     -> m (Control.Applicative.ZipList b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX4Z eta_sbX50 eta1_sbX51]
        case GHC.Base.$p1Monad $dMonad_sbX4Z of sat_sbX52 {
          __DEFAULT ->
              Data.Traversable.$fTraversableZipList_$ctraverse
                  sat_sbX52 eta_sbX50 eta1_sbX51;
        };

Data.Traversable.$fTraversableZipList_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Control.Applicative.ZipList (m a)
     -> m (Control.Applicative.ZipList a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX53 eta_sbX54]
        case GHC.Base.$p1Monad $dMonad_sbX53 of sat_sbX55 {
          __DEFAULT ->
              Data.Traversable.$fTraversableZipList_$ctraverse
                  sat_sbX55 GHC.Base.id eta_sbX54;
        };

Data.Traversable.$fTraversableZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Control.Applicative.ZipList
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Control.Applicative.$fFunctorZipList
                                                   Control.Applicative.$fFoldableZipList
                                                   Data.Traversable.$fTraversableZipList_$ctraverse
                                                   Data.Traversable.$fTraversableZipList_$csequenceA
                                                   Data.Traversable.$fTraversableZipList_$cmapM
                                                   Data.Traversable.$fTraversableZipList_$csequence];

Data.Traversable.$fTraversableArray_$ctraverse
  :: forall i.
     GHC.Arr.Ix i =>
     forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Arr.Array i a -> f (GHC.Arr.Array i b)
[GblId,
 Arity=4,
 Str=<L,U(A,A,A,A,A,C(U(U)),A)><S(S(C(C(S))L)LLLLL),U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A)><L,C(U)><L,U(U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIx_sbX56 $dApplicative_sbX57 eta_sbX58 eta1_sbX59]
        let {
          sat_sbX5u [Occ=Once] :: f_abVVc [b_abVVe]
          [LclId] =
              [$dApplicative_sbX57 eta_sbX58 eta1_sbX59] \u []
                  case eta1_sbX59 of {
                    GHC.Arr.Array _ [Occ=Dead]
                                  _ [Occ=Dead]
                                  dt_sbX5g [Occ=Once]
                                  ds2_sbX5h [Occ=OnceL] ->
                        case -# [dt_sbX5g 1#] of y_sbX5i [Dmd=<S,U>] {
                          __DEFAULT ->
                              let {
                                n_sbX5j [Occ=OnceL*] :: f_abVVc [b_abVVe]
                                [LclId] =
                                    [$dApplicative_sbX57] \u []
                                        GHC.Base.pure $dApplicative_sbX57 GHC.Types.[];
                              } in 
                                case ># [0# y_sbX5i] of {
                                  __DEFAULT ->
                                      let {
                                        go_sbX5l [Occ=LoopBreaker]
                                          :: GHC.Prim.Int# -> f_abVVc [b_abVVe]
                                        [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                                            sat-only [$dApplicative_sbX57
                                                      eta_sbX58
                                                      ds2_sbX5h
                                                      y_sbX5i
                                                      n_sbX5j
                                                      go_sbX5l] \r [x_sbX5m]
                                                let {
                                                  sat_sbX5t [Occ=Once] :: f_abVVc [b_abVVe]
                                                  [LclId] =
                                                      [y_sbX5i n_sbX5j go_sbX5l x_sbX5m] \u []
                                                          case ==# [x_sbX5m y_sbX5i] of {
                                                            __DEFAULT ->
                                                                case +# [x_sbX5m 1#] of sat_sbX5s {
                                                                  __DEFAULT -> go_sbX5l sat_sbX5s;
                                                                };
                                                            1# -> n_sbX5j;
                                                          }; } in
                                                let {
                                                  sat_sbX5q [Occ=Once] :: f_abVVc b_abVVe
                                                  [LclId] =
                                                      [eta_sbX58 ds2_sbX5h x_sbX5m] \u []
                                                          let {
                                                            sat_sbX5p [Occ=Once] :: a_abVVd
                                                            [LclId] =
                                                                [ds2_sbX5h x_sbX5m] \u []
                                                                    case
                                                                        indexArray# [ds2_sbX5h
                                                                                     x_sbX5m]
                                                                    of
                                                                    { Unit# ipv_sbX5o [Occ=Once] ->
                                                                          ipv_sbX5o;
                                                                    };
                                                          } in  eta_sbX58 sat_sbX5p;
                                                } in 
                                                  GHC.Base.liftA2
                                                      $dApplicative_sbX57
                                                      GHC.Types.:
                                                      sat_sbX5q
                                                      sat_sbX5t;
                                      } in  go_sbX5l 0#;
                                  1# -> n_sbX5j;
                                };
                        };
                  }; } in
        let {
          sat_sbX5b [Occ=OnceL] :: (i_abVUZ, i_abVUZ)
          [LclId] =
              [eta1_sbX59] \u [] GHC.Arr.bounds eta1_sbX59; } in
        let {
          sat_sbX5c [Occ=Once] :: [b_abVVe] -> GHC.Arr.Array i_abVUZ b_abVVe
          [LclId] =
              [$dIx_sbX56 sat_sbX5b] \r [eta_B1]
                  GHC.Arr.listArray $dIx_sbX56 sat_sbX5b eta_B1;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbX57 of sat_sbX5a {
            __DEFAULT -> GHC.Base.fmap sat_sbX5a sat_sbX5c sat_sbX5u;
          };

Data.Traversable.$fTraversableArray_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall i.
     GHC.Arr.Ix i =>
     forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Arr.Array i (f a) -> f (GHC.Arr.Array i a)
[GblId,
 Arity=3,
 Str=<L,U(A,A,A,A,A,C(U(U)),A)><L,U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIx_sbX5v $dApplicative_sbX5w eta_B1]
        Data.Traversable.$fTraversableArray_$ctraverse
            $dIx_sbX5v $dApplicative_sbX5w GHC.Base.id eta_B1;

Data.Traversable.$fTraversableArray_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall i.
     GHC.Arr.Ix i =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Arr.Array i a -> m (GHC.Arr.Array i b)
[GblId,
 Arity=4,
 Str=<L,U(A,A,A,A,A,C(U(U)),A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><L,U(U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIx_sbX5x $dMonad_sbX5y eta_sbX5z eta1_sbX5A]
        case GHC.Base.$p1Monad $dMonad_sbX5y of sat_sbX5B {
          __DEFAULT ->
              Data.Traversable.$fTraversableArray_$ctraverse
                  $dIx_sbX5x sat_sbX5B eta_sbX5z eta1_sbX5A;
        };

Data.Traversable.$fTraversableArray_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall i.
     GHC.Arr.Ix i =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Arr.Array i (m a) -> m (GHC.Arr.Array i a)
[GblId,
 Arity=3,
 Str=<L,U(A,A,A,A,A,C(U(U)),A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,U(U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIx_sbX5C $dMonad_sbX5D eta_sbX5E]
        case GHC.Base.$p1Monad $dMonad_sbX5D of sat_sbX5F {
          __DEFAULT ->
              Data.Traversable.$fTraversableArray_$ctraverse
                  $dIx_sbX5C sat_sbX5F GHC.Base.id eta_sbX5E;
        };

Data.Traversable.$fTraversableArray [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i.
     GHC.Arr.Ix i =>
     Data.Traversable.Traversable (GHC.Arr.Array i)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,A,A,C(U(U)),A)>m] =
    [] \r [$dIx_sbX5G]
        let {
          sat_sbX5K [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               GHC.Arr.Array i_abVUZ (m a) -> m (GHC.Arr.Array i_abVUZ a)
          [LclId] =
              [$dIx_sbX5G] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableArray_$csequence
                      $dIx_sbX5G eta_B2 eta_B1; } in
        let {
          sat_sbX5J [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> GHC.Arr.Array i_abVUZ a -> m (GHC.Arr.Array i_abVUZ b)
          [LclId] =
              [$dIx_sbX5G] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableArray_$cmapM
                      $dIx_sbX5G eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sbX5I [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               GHC.Arr.Array i_abVUZ (f a) -> f (GHC.Arr.Array i_abVUZ a)
          [LclId] =
              [$dIx_sbX5G] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableArray_$csequenceA
                      $dIx_sbX5G eta_B2 eta_B1; } in
        let {
          sat_sbX5H [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> GHC.Arr.Array i_abVUZ a -> f (GHC.Arr.Array i_abVUZ b)
          [LclId] =
              [$dIx_sbX5G] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableArray_$ctraverse
                      $dIx_sbX5G eta_B3 eta_B2 eta_B1;
        } in 
          Data.Traversable.C:Traversable [GHC.Arr.$fFunctorArray
                                          Data.Foldable.$fFoldableArray
                                          sat_sbX5H
                                          sat_sbX5I
                                          sat_sbX5J
                                          sat_sbX5K];

Data.Traversable.$fTraversableNonEmpty_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Base.NonEmpty a -> f (GHC.Base.NonEmpty b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),U(A,1*C1(U),A,C(C1(C1(U))),A,A)><L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX5L f1_sbX5M ds_sbX5N]
        let {
          sat_sbX64 [Occ=Once] :: f_abVYD [b_abVYF]
          [LclId] =
              [$dApplicative_sbX5L f1_sbX5M ds_sbX5N] \u []
                  case ds_sbX5N of {
                    GHC.Base.:| _ [Occ=Dead] as_sbX5V [Occ=Once] ->
                        let {
                          z_sbX5W [Occ=OnceL] :: f_abVYD [b_abVYF]
                          [LclId] =
                              [$dApplicative_sbX5L] \u []
                                  GHC.Base.pure $dApplicative_sbX5L GHC.Types.[]; } in
                        let {
                          go_sbX5X [Occ=LoopBreaker] :: [a_abVYE] -> f_abVYD [b_abVYF]
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [$dApplicative_sbX5L
                                        f1_sbX5M
                                        z_sbX5W
                                        go_sbX5X] \r [ds1_sbX5Y]
                                  case ds1_sbX5Y of {
                                    [] -> z_sbX5W;
                                    : y_sbX60 [Occ=Once] ys_sbX61 [Occ=Once] ->
                                        let {
                                          sat_sbX63 [Occ=Once] :: f_abVYD [b_abVYF]
                                          [LclId] =
                                              [go_sbX5X ys_sbX61] \u [] go_sbX5X ys_sbX61; } in
                                        let {
                                          sat_sbX62 [Occ=Once] :: f_abVYD b_abVYF
                                          [LclId] =
                                              [f1_sbX5M y_sbX60] \u [] f1_sbX5M y_sbX60;
                                        } in 
                                          GHC.Base.liftA2
                                              $dApplicative_sbX5L GHC.Types.: sat_sbX62 sat_sbX63;
                                  };
                        } in  go_sbX5X as_sbX5V;
                  }; } in
        let {
          sat_sbX5S [Occ=Once] :: f_abVYD b_abVYF
          [LclId] =
              [f1_sbX5M ds_sbX5N] \u []
                  let {
                    sat_sbX5R [Occ=Once] :: a_abVYE
                    [LclId] =
                        [ds_sbX5N] \u []
                            case ds_sbX5N of {
                              GHC.Base.:| a1_sbX5P [Occ=Once] _ [Occ=Dead] -> a1_sbX5P;
                            };
                  } in  f1_sbX5M sat_sbX5R;
        } in 
          GHC.Base.liftA2
              $dApplicative_sbX5L GHC.Base.:| sat_sbX5S sat_sbX64;

Data.Traversable.$fTraversableNonEmpty_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Base.NonEmpty (f a) -> f (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,C(U),A,C(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX65 eta_B1]
        Data.Traversable.$fTraversableNonEmpty_$ctraverse
            $dApplicative_sbX65 GHC.Base.id eta_B1;

Data.Traversable.$fTraversableNonEmpty_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Base.NonEmpty a -> m (GHC.Base.NonEmpty b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(A,1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX66 eta_sbX67 eta1_sbX68]
        case GHC.Base.$p1Monad $dMonad_sbX66 of sat_sbX69 {
          __DEFAULT ->
              Data.Traversable.$fTraversableNonEmpty_$ctraverse
                  sat_sbX69 eta_sbX67 eta1_sbX68;
        };

Data.Traversable.$fTraversableNonEmpty_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Base.NonEmpty (m a) -> m (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(A,1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX6a eta_sbX6b]
        case GHC.Base.$p1Monad $dMonad_sbX6a of sat_sbX6c {
          __DEFAULT ->
              Data.Traversable.$fTraversableNonEmpty_$ctraverse
                  sat_sbX6c GHC.Base.id eta_sbX6b;
        };

Data.Traversable.$fTraversableNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable GHC.Base.NonEmpty
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Base.$fFunctorNonEmpty
                                                   Data.Foldable.$fFoldableNonEmpty
                                                   Data.Traversable.$fTraversableNonEmpty_$ctraverse
                                                   Data.Traversable.$fTraversableNonEmpty_$csequenceA
                                                   Data.Traversable.$fTraversableNonEmpty_$cmapM
                                                   Data.Traversable.$fTraversableNonEmpty_$csequence];

Data.Traversable.$fTraversableMaybe_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Base.Maybe (f a) -> f (GHC.Base.Maybe a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX6d eta_sbX6e]
        case eta_sbX6e of {
          GHC.Base.Nothing ->
              GHC.Base.pure $dApplicative_sbX6d GHC.Base.Nothing;
          GHC.Base.Just x_sbX6g [Occ=Once] ->
              case GHC.Base.$p1Applicative $dApplicative_sbX6d of sat_sbX6h {
                __DEFAULT -> GHC.Base.fmap sat_sbX6h GHC.Base.Just x_sbX6g;
              };
        };

Data.Traversable.$fTraversableMaybe_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Base.Maybe a -> m (GHC.Base.Maybe b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX6i eta_sbX6j eta1_sbX6k]
        case GHC.Base.$p1Monad $dMonad_sbX6i of sat_sbX6l {
          __DEFAULT ->
              Data.Traversable.$fTraversableFirst_$ctraverse
                  sat_sbX6l eta_sbX6j eta1_sbX6k;
        };

Data.Traversable.$fTraversableMaybe_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Base.Maybe (m a) -> m (GHC.Base.Maybe a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX6m eta_sbX6n]
        case eta_sbX6n of {
          GHC.Base.Nothing ->
              case GHC.Base.$p1Monad $dMonad_sbX6m of sat_sbX6p {
                __DEFAULT -> GHC.Base.pure sat_sbX6p GHC.Base.Nothing;
              };
          GHC.Base.Just x_sbX6q [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sbX6m of sat_sbX6r {
                __DEFAULT ->
                    case GHC.Base.$p1Applicative sat_sbX6r of sat_sbX6s {
                      __DEFAULT -> GHC.Base.fmap sat_sbX6s GHC.Base.Just x_sbX6q;
                    };
              };
        };

Data.Traversable.$fTraversableMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable GHC.Base.Maybe
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Base.$fFunctorMaybe
                                                   Data.Foldable.$fFoldableMaybe
                                                   Data.Traversable.$fTraversableFirst_$ctraverse
                                                   Data.Traversable.$fTraversableMaybe_$csequenceA
                                                   Data.Traversable.$fTraversableMaybe_$cmapM
                                                   Data.Traversable.$fTraversableMaybe_$csequence];

Data.Traversable.$fTraversableFirst1
  :: forall b. GHC.Base.Maybe b -> GHC.Base.Maybe b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sbX6t] v_sbX6t;

Data.Traversable.$fTraversableLast_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Monoid.Last a -> f (Data.Monoid.Last b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX6u eta_sbX6v eta1_sbX6w]
        let {
          sat_sbX6y [Occ=Once] :: f_abVNQ (GHC.Base.Maybe b_abVNS)
          [LclId] =
              [$dApplicative_sbX6u eta_sbX6v eta1_sbX6w] \u []
                  Data.Traversable.$fTraversableFirst_$ctraverse
                      $dApplicative_sbX6u eta_sbX6v eta1_sbX6w;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbX6u of sat_sbX6x {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sbX6x Data.Traversable.$fTraversableFirst1 sat_sbX6y;
          };

Data.Traversable.$fTraversableLast_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Monoid.Last (f a) -> f (Data.Monoid.Last a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX6z eta_sbX6A]
        let {
          sat_sbX6F [Occ=Once] :: f_abVOa (GHC.Base.Maybe a_abVOb)
          [LclId] =
              [$dApplicative_sbX6z eta_sbX6A] \u []
                  case eta_sbX6A of {
                    GHC.Base.Nothing ->
                        GHC.Base.pure $dApplicative_sbX6z GHC.Base.Nothing;
                    GHC.Base.Just x_sbX6D [Occ=Once] ->
                        case GHC.Base.$p1Applicative $dApplicative_sbX6z of sat_sbX6E {
                          __DEFAULT -> GHC.Base.fmap sat_sbX6E GHC.Base.Just x_sbX6D;
                        };
                  };
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbX6z of sat_sbX6B {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sbX6B Data.Traversable.$fTraversableFirst1 sat_sbX6F;
          };

Data.Traversable.$fTraversableLast_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Monoid.Last a -> m (Data.Monoid.Last b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(C(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX6G eta_sbX6H eta1_sbX6I]
        case
            GHC.Base.$p1Monad $dMonad_sbX6G
        of
        $dApplicative_sbX6J [Dmd=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              let {
                sat_sbX6L [Occ=Once] :: m_abVOm (GHC.Base.Maybe b_abVOo)
                [LclId] =
                    [eta_sbX6H eta1_sbX6I $dApplicative_sbX6J] \u []
                        Data.Traversable.$fTraversableFirst_$ctraverse
                            $dApplicative_sbX6J eta_sbX6H eta1_sbX6I;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbX6J of sat_sbX6K {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sbX6K Data.Traversable.$fTraversableFirst1 sat_sbX6L;
                };
        };

Data.Traversable.$fTraversableLast_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Monoid.Last (m a) -> m (Data.Monoid.Last a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(C(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX6M eta_sbX6N]
        case
            GHC.Base.$p1Monad $dMonad_sbX6M
        of
        $dApplicative_sbX6O [Dmd=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              let {
                sat_sbX6T [Occ=Once] :: m_abVOA (GHC.Base.Maybe a_abVOB)
                [LclId] =
                    [eta_sbX6N $dApplicative_sbX6O] \u []
                        case eta_sbX6N of {
                          GHC.Base.Nothing ->
                              GHC.Base.pure $dApplicative_sbX6O GHC.Base.Nothing;
                          GHC.Base.Just x_sbX6R [Occ=Once] ->
                              case GHC.Base.$p1Applicative $dApplicative_sbX6O of sat_sbX6S {
                                __DEFAULT -> GHC.Base.fmap sat_sbX6S GHC.Base.Just x_sbX6R;
                              };
                        };
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbX6O of sat_sbX6P {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sbX6P Data.Traversable.$fTraversableFirst1 sat_sbX6T;
                };
        };

Data.Traversable.$fTraversableLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Monoid.Last
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Monoid.$fFunctorLast
                                                   Data.Foldable.$fFoldableLast
                                                   Data.Traversable.$fTraversableLast_$ctraverse
                                                   Data.Traversable.$fTraversableLast_$csequenceA
                                                   Data.Traversable.$fTraversableLast_$cmapM
                                                   Data.Traversable.$fTraversableLast_$csequence];

Data.Traversable.$fTraversableFirst_$ctraverse1
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Monoid.First a -> f (Data.Monoid.First b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX6U eta_sbX6V eta1_sbX6W]
        let {
          sat_sbX6Y [Occ=Once] :: f_abVOW (GHC.Base.Maybe b_abVOY)
          [LclId] =
              [$dApplicative_sbX6U eta_sbX6V eta1_sbX6W] \u []
                  Data.Traversable.$fTraversableFirst_$ctraverse
                      $dApplicative_sbX6U eta_sbX6V eta1_sbX6W;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbX6U of sat_sbX6X {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sbX6X Data.Traversable.$fTraversableFirst1 sat_sbX6Y;
          };

Data.Traversable.$fTraversableFirst_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Monoid.First (f a) -> f (Data.Monoid.First a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sbX6Z eta_sbX70]
        let {
          sat_sbX75 [Occ=Once] :: f_abVPg (GHC.Base.Maybe a_abVPh)
          [LclId] =
              [$dApplicative_sbX6Z eta_sbX70] \u []
                  case eta_sbX70 of {
                    GHC.Base.Nothing ->
                        GHC.Base.pure $dApplicative_sbX6Z GHC.Base.Nothing;
                    GHC.Base.Just x_sbX73 [Occ=Once] ->
                        case GHC.Base.$p1Applicative $dApplicative_sbX6Z of sat_sbX74 {
                          __DEFAULT -> GHC.Base.fmap sat_sbX74 GHC.Base.Just x_sbX73;
                        };
                  };
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sbX6Z of sat_sbX71 {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sbX71 Data.Traversable.$fTraversableFirst1 sat_sbX75;
          };

Data.Traversable.$fTraversableFirst_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Monoid.First a -> m (Data.Monoid.First b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(C(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX76 eta_sbX77 eta1_sbX78]
        case
            GHC.Base.$p1Monad $dMonad_sbX76
        of
        $dApplicative_sbX79 [Dmd=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              let {
                sat_sbX7b [Occ=Once] :: m_abVPs (GHC.Base.Maybe b_abVPu)
                [LclId] =
                    [eta_sbX77 eta1_sbX78 $dApplicative_sbX79] \u []
                        Data.Traversable.$fTraversableFirst_$ctraverse
                            $dApplicative_sbX79 eta_sbX77 eta1_sbX78;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbX79 of sat_sbX7a {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sbX7a Data.Traversable.$fTraversableFirst1 sat_sbX7b;
                };
        };

Data.Traversable.$fTraversableFirst_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Monoid.First (m a) -> m (Data.Monoid.First a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(C(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sbX7c eta_sbX7d]
        case
            GHC.Base.$p1Monad $dMonad_sbX7c
        of
        $dApplicative_sbX7e [Dmd=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              let {
                sat_sbX7j [Occ=Once] :: m_abVPG (GHC.Base.Maybe a_abVPH)
                [LclId] =
                    [eta_sbX7d $dApplicative_sbX7e] \u []
                        case eta_sbX7d of {
                          GHC.Base.Nothing ->
                              GHC.Base.pure $dApplicative_sbX7e GHC.Base.Nothing;
                          GHC.Base.Just x_sbX7h [Occ=Once] ->
                              case GHC.Base.$p1Applicative $dApplicative_sbX7e of sat_sbX7i {
                                __DEFAULT -> GHC.Base.fmap sat_sbX7i GHC.Base.Just x_sbX7h;
                              };
                        };
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sbX7e of sat_sbX7f {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sbX7f Data.Traversable.$fTraversableFirst1 sat_sbX7j;
                };
        };

Data.Traversable.$fTraversableFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Monoid.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Monoid.$fFunctorFirst
                                                   Data.Foldable.$fFoldableFirst
                                                   Data.Traversable.$fTraversableFirst_$ctraverse1
                                                   Data.Traversable.$fTraversableFirst_$csequenceA
                                                   Data.Traversable.$fTraversableFirst_$cmapM
                                                   Data.Traversable.$fTraversableFirst_$csequence];

Data.Traversable.$dmtraverse [InlPrag=INLINE (sat-args=1)]
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> t a -> f (t b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*C1(C(U)),A),A,A,1*C1(C(U)),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX7k eta_sbX7l eta1_sbX7m]
        let {
          f1_sbX7n [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_abVfw (f_abVtL b_abVtN) -> f_abVtL (t_abVfw b_abVtN)
          [LclId] =
              [$dTraversable_sbX7k eta_sbX7l] \u []
                  Data.Traversable.sequenceA $dTraversable_sbX7k eta_sbX7l; } in
        let {
          g_sbX7o [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_abVfw a_abVtM -> t_abVfw (f_abVtL b_abVtN)
          [LclId] =
              [$dTraversable_sbX7k eta1_sbX7m] \u []
                  case
                      Data.Traversable.$p1Traversable $dTraversable_sbX7k
                  of
                  sat_sbX7p
                  { __DEFAULT -> GHC.Base.fmap sat_sbX7p eta1_sbX7m;
                  }; } in
        let {
          sat_sbX7s [Occ=OnceT[0]]
            :: t_abVfw a_abVtM -> f_abVtL (t_abVfw b_abVtN)
          [LclId] =
              [f1_sbX7n g_sbX7o] \r [x_sbX7q]
                  let {
                    sat_sbX7r [Occ=Once] :: t_abVfw (f_abVtL b_abVtN)
                    [LclId] =
                        [g_sbX7o x_sbX7q] \u [] g_sbX7o x_sbX7q;
                  } in  f1_sbX7n sat_sbX7r;
        } in  sat_sbX7s;

Data.Traversable.for [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (f :: * -> *) a b.
     (Data.Traversable.Traversable t, GHC.Base.Applicative f) =>
     t a -> (a -> f b) -> f (t b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C(C1(U))),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX7t $dApplicative_sbX7u]
        let {
          f1_sbX7v [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: (a_abVtu -> f_abVtt b_abVtv)
               -> t_abVts a_abVtu -> f_abVtt (t_abVts b_abVtv)
          [LclId] =
              [$dTraversable_sbX7t $dApplicative_sbX7u] \u []
                  Data.Traversable.traverse
                      $dTraversable_sbX7t $dApplicative_sbX7u; } in
        let {
          sat_sbX7y [Occ=OnceT[0]]
            :: t_abVts a_abVtu
               -> (a_abVtu -> f_abVtt b_abVtv) -> f_abVtt (t_abVts b_abVtv)
          [LclId] =
              [f1_sbX7v] \r [x_sbX7w y_sbX7x] f1_sbX7v y_sbX7x x_sbX7w;
        } in  sat_sbX7y;

Data.Traversable.forM [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (m :: * -> *) a b.
     (Data.Traversable.Traversable t, GHC.Base.Monad m) =>
     t a -> (a -> m b) -> m (t b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,1*C1(C(C1(U))),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX7z $dMonad_sbX7A]
        let {
          f_sbX7B [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: (a_abVtd -> m_abVtc b_abVte)
               -> t_abVtb a_abVtd -> m_abVtc (t_abVtb b_abVte)
          [LclId] =
              [$dTraversable_sbX7z $dMonad_sbX7A] \u []
                  Data.Traversable.mapM $dTraversable_sbX7z $dMonad_sbX7A; } in
        let {
          sat_sbX7E [Occ=OnceT[0]]
            :: t_abVtb a_abVtd
               -> (a_abVtd -> m_abVtc b_abVte) -> m_abVtc (t_abVtb b_abVte)
          [LclId] =
              [f_sbX7B] \r [x_sbX7C y_sbX7D] f_sbX7B y_sbX7D x_sbX7C;
        } in  sat_sbX7E;

Data.Traversable.mapAccumL
  :: forall (t :: * -> *) a b c.
     Data.Traversable.Traversable t =>
     (a -> b -> (a, c)) -> a -> t b -> (a, t c)
[GblId,
 Arity=4,
 Str=<S(LLC(C(C(S)))LLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX7F f_sbX7G s_sbX7H t1_sbX7I]
        let {
          sat_sbX7L [Occ=Once]
            :: b_abVsM -> Data.Functor.Utils.StateL a_abVsL c_abVsN
          [LclId] =
              [f_sbX7G] \r [x_sbX7J y_sbX7K] f_sbX7G y_sbX7K x_sbX7J;
        } in 
          Data.Traversable.traverse
              $dTraversable_sbX7F
              Data.Functor.Utils.$fApplicativeStateL
              sat_sbX7L
              t1_sbX7I
              s_sbX7H;

Data.Traversable.mapAccumR
  :: forall (t :: * -> *) a b c.
     Data.Traversable.Traversable t =>
     (a -> b -> (a, c)) -> a -> t b -> (a, t c)
[GblId,
 Arity=4,
 Str=<S(LLC(C(C(S)))LLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sbX7M f_sbX7N s_sbX7O t1_sbX7P]
        let {
          sat_sbX7S [Occ=Once]
            :: b_abVsl -> Data.Functor.Utils.StateR a_abVsk c_abVsm
          [LclId] =
              [f_sbX7N] \r [x_sbX7Q y_sbX7R] f_sbX7N y_sbX7R x_sbX7Q;
        } in 
          Data.Traversable.traverse
              $dTraversable_sbX7M
              Data.Functor.Utils.$fApplicativeStateR
              sat_sbX7S
              t1_sbX7P
              s_sbX7O;

fmapDefault1_rbWTV
  :: forall (t :: * -> *) a b.
     Data.Traversable.Traversable t =>
     (a -> Data.Functor.Identity.Identity b)
     -> t a -> Data.Functor.Identity.Identity (t b)
[GblId,
 Arity=1,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)>,
 Unf=OtherCon []] =
    sat-only [] \r [$dTraversable_sbX7T]
        Data.Traversable.traverse
            $dTraversable_sbX7T Data.Functor.Identity.$fApplicativeIdentity;

Data.Traversable.fmapDefault [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) a b.
     Data.Traversable.Traversable t =>
     (a -> b) -> t a -> t b
[GblId,
 Arity=1,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] fmapDefault1_rbWTV eta_B1;

foldMapDefault1_rbWTW
  :: forall (t :: * -> *) m a.
     (Data.Traversable.Traversable t, GHC.Base.Monoid m) =>
     (a -> Data.Functor.Const.Const m ())
     -> t a -> Data.Functor.Const.Const m (t ())
[GblId,
 Arity=2,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)><L,U(A,U,U,A)>,
 Unf=OtherCon []] =
    sat-only [] \r [$dTraversable_sbX7U $dMonoid_sbX7V]
        let {
          sat_sbX7W [Occ=Once]
            :: GHC.Base.Applicative (Data.Functor.Const.Const m_abVrr)
          [LclId] =
              [$dMonoid_sbX7V] \u []
                  Data.Functor.Const.$fApplicativeConst $dMonoid_sbX7V;
        } in  Data.Traversable.traverse $dTraversable_sbX7U sat_sbX7W;

Data.Traversable.foldMapDefault [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) m a.
     (Data.Traversable.Traversable t, GHC.Base.Monoid m) =>
     (a -> m) -> t a -> m
[GblId,
 Arity=2,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)><L,U(A,U,U,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] foldMapDefault1_rbWTW eta_B2 eta_B1;

Data.Traversable.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Traversable.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Traversable.$trModule4];

Data.Traversable.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Traversable"#;

Data.Traversable.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Traversable.$trModule2];

Data.Traversable.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Traversable.$trModule3
                                     Data.Traversable.$trModule1];

$krep_rbWTX :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Traversable.$tcTraversable1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep_rbWTX];

Data.Traversable.$tcTraversable3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Traversable"#;

Data.Traversable.$tcTraversable2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Traversable.$tcTraversable3];

Data.Traversable.$tcTraversable :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9002450311536760373##
                                    4172295783860716183##
                                    Data.Traversable.$trModule
                                    Data.Traversable.$tcTraversable2
                                    0#
                                    Data.Traversable.$tcTraversable1];

Data.Traversable.C:Traversable
  :: forall (t :: * -> *).
     (GHC.Base.Functor t, Data.Foldable.Foldable t) =>
     (forall (f :: * -> *) a b.
      GHC.Base.Applicative f =>
      (a -> f b) -> t a -> f (t b))
     -> (forall (f :: * -> *) a.
         GHC.Base.Applicative f =>
         t (f a) -> f (t a))
     -> (forall (m :: * -> *) a b.
         GHC.Base.Monad m =>
         (a -> m b) -> t a -> m (t b))
     -> (forall (m :: * -> *) a. GHC.Base.Monad m => t (m a) -> m (t a))
     -> Data.Traversable.Traversable t
[GblId[DataCon],
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Traversable.C:Traversable [eta_B6
                                        eta_B5
                                        eta_B4
                                        eta_B3
                                        eta_B2
                                        eta_B1];


==================== Pre unarise: ====================
2018-03-16 16:06:54.659185162 UTC

Data.Traversable.$p1Traversable
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     GHC.Base.Functor t
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLL),U(U,A,A,A,A,A)>] =
    [] \r [v_sc0bs]
        case v_sc0bs of {
          Data.Traversable.C:Traversable v_sc0bu [Occ=Once]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead] ->
              v_sc0bu;
        };

Data.Traversable.$p2Traversable
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     Data.Foldable.Foldable t
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLL),U(A,U,A,A,A,A)>] =
    [] \r [v_sc0bA]
        case v_sc0bA of {
          Data.Traversable.C:Traversable _ [Occ=Dead]
                                         v_sc0bD [Occ=Once]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead] ->
              v_sc0bD;
        };

Data.Traversable.traverse
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> t a -> f (t b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLL),U(A,A,U,A,A,A)>] =
    [] \r [v_sc0bI]
        case v_sc0bI of {
          Data.Traversable.C:Traversable _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         v_sc0bM [Occ=Once]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead] ->
              v_sc0bM;
        };

Data.Traversable.sequenceA
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     t (f a) -> f (t a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLL),U(A,A,A,U,A,A)>] =
    [] \r [v_sc0bQ]
        case v_sc0bQ of {
          Data.Traversable.C:Traversable _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         v_sc0bV [Occ=Once]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead] ->
              v_sc0bV;
        };

Data.Traversable.mapM
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> t a -> m (t b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSL),U(A,A,A,A,U,A)>] =
    [] \r [v_sc0bY]
        case v_sc0bY of {
          Data.Traversable.C:Traversable _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         v_sc0c4 [Occ=Once]
                                         _ [Occ=Dead] ->
              v_sc0c4;
        };

Data.Traversable.sequence
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (m :: * -> *) a. GHC.Base.Monad m => t (m a) -> m (t a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLS),U(A,A,A,A,A,U)>] =
    [] \r [v_sc0c6]
        case v_sc0c6 of {
          Data.Traversable.C:Traversable _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         v_sc0cd [Occ=Once] ->
              v_sc0cd;
        };

Data.Traversable.$fTraversableFirst_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Base.Maybe a -> f (GHC.Base.Maybe b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0ce eta_sc0cf eta1_sc0cg]
        case eta1_sc0cg of {
          GHC.Base.Nothing ->
              GHC.Base.pure $dApplicative_sc0ce GHC.Base.Nothing;
          GHC.Base.Just x_sc0ci [Occ=Once] ->
              let {
                sat_sc0ck [Occ=Once] :: f_abW15 b_abW17
                [LclId] =
                    [eta_sc0cf x_sc0ci] \u [] eta_sc0cf x_sc0ci;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0ce of sat_sc0cj {
                  __DEFAULT -> GHC.Base.fmap sat_sc0cj GHC.Base.Just sat_sc0ck;
                };
        };

Data.Traversable.$fTraversable[]_$ctraverse [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> [a] -> f [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*C1(U),A,C(C1(C1(U))),A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0cl f1_sc0cm]
        let {
          z_sc0cn [Occ=OnceL] :: f_abVZK [b_abVZM]
          [LclId] =
              [$dApplicative_sc0cl] \u []
                  GHC.Base.pure $dApplicative_sc0cl GHC.Types.[]; } in
        let {
          go_sc0co [Occ=LoopBreaker] :: [a_abVZL] -> f_abVZK [b_abVZM]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [$dApplicative_sc0cl f1_sc0cm z_sc0cn go_sc0co] \r [ds_sc0cp]
                  case ds_sc0cp of {
                    [] -> z_sc0cn;
                    : y_sc0cr [Occ=Once] ys_sc0cs [Occ=Once] ->
                        let {
                          sat_sc0cu [Occ=Once] :: f_abVZK [b_abVZM]
                          [LclId] =
                              [go_sc0co ys_sc0cs] \u [] go_sc0co ys_sc0cs; } in
                        let {
                          sat_sc0ct [Occ=Once] :: f_abVZK b_abVZM
                          [LclId] =
                              [f1_sc0cm y_sc0cr] \u [] f1_sc0cm y_sc0cr;
                        } in 
                          GHC.Base.liftA2
                              $dApplicative_sc0cl GHC.Types.: sat_sc0ct sat_sc0cu;
                  };
        } in  go_sc0co;

Data.Traversable.$fTraversableEither_$ctraverse
  :: forall a1 (f :: * -> *) a2 b.
     GHC.Base.Applicative f =>
     (a2 -> f b)
     -> Data.Either.Either a1 a2 -> f (Data.Either.Either a1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0cv eta_sc0cw eta1_sc0cx]
        case eta1_sc0cx of {
          Data.Either.Left x_sc0cz [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0cv wild_sc0cy;
          Data.Either.Right y_sc0cB [Occ=Once] ->
              let {
                sat_sc0cD [Occ=Once] :: f_abVXx b_abVXz
                [LclId] =
                    [eta_sc0cw y_sc0cB] \u [] eta_sc0cw y_sc0cB;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0cv of sat_sc0cC {
                  __DEFAULT -> GHC.Base.fmap sat_sc0cC Data.Either.Right sat_sc0cD;
                };
        };

Data.Traversable.$fTraversable(,)_$ctraverse
  :: forall a1 (f :: * -> *) a2 b.
     GHC.Base.Applicative f =>
     (a2 -> f b) -> (a1, a2) -> f (a1, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0cE eta_sc0cF eta1_sc0cG]
        case eta1_sc0cG of {
          (,) x_sc0cI [Occ=OnceL] y_sc0cJ [Occ=Once] ->
              let {
                sat_sc0cM [Occ=Once] :: f_abVWv b_abVWx
                [LclId] =
                    [eta_sc0cF y_sc0cJ] \u [] eta_sc0cF y_sc0cJ; } in
              let {
                sat_sc0cL [Occ=Once] :: b_abVWx -> (a_abVWj, b_abVWx)
                [LclId] =
                    [x_sc0cI] \r [eta_B1] (,) [x_sc0cI eta_B1];
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0cE of sat_sc0cK {
                  __DEFAULT -> GHC.Base.fmap sat_sc0cK sat_sc0cL sat_sc0cM;
                };
        };

Data.Traversable.$fTraversableProxy_$csequence [InlPrag=INLINE (sat-args=1)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Proxy.Proxy (m a) -> m (Data.Proxy.Proxy a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0cN eta_sc0cO]
        case GHC.Base.$p1Monad $dMonad_sc0cN of sat_sc0cP {
          __DEFAULT -> GHC.Base.pure sat_sc0cP Data.Proxy.Proxy;
        };

Data.Traversable.$fTraversableProxy_$cmapM [InlPrag=INLINE (sat-args=2)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Proxy.Proxy a -> m (Data.Proxy.Proxy b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0cQ eta_sc0cR eta1_sc0cS]
        case GHC.Base.$p1Monad $dMonad_sc0cQ of sat_sc0cT {
          __DEFAULT -> GHC.Base.pure sat_sc0cT Data.Proxy.Proxy;
        };

Data.Traversable.$fTraversableProxy_$csequenceA [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Proxy.Proxy (f a) -> f (Data.Proxy.Proxy a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0cU ds_sc0cV]
        GHC.Base.pure $dApplicative_sc0cU Data.Proxy.Proxy;

Data.Traversable.$fTraversableProxy_$ctraverse [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Proxy.Proxy a -> f (Data.Proxy.Proxy b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0cW eta_sc0cX ds_sc0cY]
        GHC.Base.pure $dApplicative_sc0cW Data.Proxy.Proxy;

Data.Traversable.$fTraversableProxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Proxy.Proxy
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Proxy.$fFunctorProxy
                                                   Data.Foldable.$fFoldableProxy
                                                   Data.Traversable.$fTraversableProxy_$ctraverse
                                                   Data.Traversable.$fTraversableProxy_$csequenceA
                                                   Data.Traversable.$fTraversableProxy_$cmapM
                                                   Data.Traversable.$fTraversableProxy_$csequence];

Data.Traversable.$fTraversableConst_$ctraverse
  :: forall m (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Functor.Const.Const m a -> f (Data.Functor.Const.Const m b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0cZ ds_sc0d0 ds1_sc0d1]
        GHC.Base.pure $dApplicative_sc0cZ ds1_sc0d1;

Data.Traversable.$fTraversableDual1 :: forall b. b -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sc0d2] v_sc0d2;

Data.Traversable.$fTraversableDual_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Semigroup.Internal.Dual a
     -> f (Data.Semigroup.Internal.Dual b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0d3 eta_sc0d4 eta1_sc0d5]
        let {
          sat_sc0d7 [Occ=Once] :: f_abVS2 b_abVS4
          [LclId] =
              [eta_sc0d4 eta1_sc0d5] \u [] eta_sc0d4 eta1_sc0d5;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0d3 of sat_sc0d6 {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sc0d6 Data.Traversable.$fTraversableDual1 sat_sc0d7;
          };

Data.Traversable.$fTraversableSum_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Semigroup.Internal.Sum a
     -> f (Data.Semigroup.Internal.Sum b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0d8 eta_sc0d9 eta1_sc0da]
        let {
          sat_sc0dc [Occ=Once] :: f_abVR2 b_abVR4
          [LclId] =
              [eta_sc0d9 eta1_sc0da] \u [] eta_sc0d9 eta1_sc0da;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0d8 of sat_sc0db {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sc0db Data.Traversable.$fTraversableDual1 sat_sc0dc;
          };

Data.Traversable.$fTraversableProduct_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Semigroup.Internal.Product a
     -> f (Data.Semigroup.Internal.Product b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0dd eta_sc0de eta1_sc0df]
        let {
          sat_sc0dh [Occ=Once] :: f_abVQ2 b_abVQ4
          [LclId] =
              [eta_sc0de eta1_sc0df] \u [] eta_sc0de eta1_sc0df;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0dd of sat_sc0dg {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sc0dg Data.Traversable.$fTraversableDual1 sat_sc0dh;
          };

Data.Traversable.$fTraversableU1_$csequence [InlPrag=INLINE (sat-args=1)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.U1 (m a) -> m (GHC.Generics.U1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0di eta_sc0dj]
        case GHC.Base.$p1Monad $dMonad_sc0di of sat_sc0dk {
          __DEFAULT -> GHC.Base.pure sat_sc0dk GHC.Generics.U1;
        };

Data.Traversable.$fTraversableU1_$cmapM [InlPrag=INLINE (sat-args=2)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Generics.U1 a -> m (GHC.Generics.U1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0dl eta_sc0dm eta1_sc0dn]
        case GHC.Base.$p1Monad $dMonad_sc0dl of sat_sc0do {
          __DEFAULT -> GHC.Base.pure sat_sc0do GHC.Generics.U1;
        };

Data.Traversable.$fTraversableU1_$csequenceA [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.U1 (f a) -> f (GHC.Generics.U1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0dp ds_sc0dq]
        GHC.Base.pure $dApplicative_sc0dp GHC.Generics.U1;

Data.Traversable.$fTraversableU1_$ctraverse [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Generics.U1 a -> f (GHC.Generics.U1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0dr eta_sc0ds ds_sc0dt]
        GHC.Base.pure $dApplicative_sc0dr GHC.Generics.U1;

Data.Traversable.$fTraversableU1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable GHC.Generics.U1
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorU1
                                                   Data.Foldable.$fFoldableU1
                                                   Data.Traversable.$fTraversableU1_$ctraverse
                                                   Data.Traversable.$fTraversableU1_$csequenceA
                                                   Data.Traversable.$fTraversableU1_$cmapM
                                                   Data.Traversable.$fTraversableU1_$csequence];

Data.Traversable.$fTraversableIdentity_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Functor.Identity.Identity a
     -> f (Data.Functor.Identity.Identity b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0du eta_sc0dv eta1_sc0dw]
        let {
          sat_sc0dy [Occ=Once] :: f_abVKI b_abVKK
          [LclId] =
              [eta_sc0dv eta1_sc0dw] \u [] eta_sc0dv eta1_sc0dw;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0du of sat_sc0dx {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sc0dx Data.Traversable.$fTraversableDual1 sat_sc0dy;
          };

Data.Traversable.$fTraversableV1_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Generics.V1 a -> f (GHC.Generics.V1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0dz ds_sc0dA z_sc0dB]
        GHC.Base.pure $dApplicative_sc0dz z_sc0dB;

Data.Traversable.$fTraversablePar1_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Generics.Par1 a -> f (GHC.Generics.Par1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0dC eta_sc0dD eta1_sc0dE]
        let {
          sat_sc0dG [Occ=Once] :: f_abVIH b_abVIJ
          [LclId] =
              [eta_sc0dD eta1_sc0dE] \u [] eta_sc0dD eta1_sc0dE;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0dC of sat_sc0dF {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sc0dF Data.Traversable.$fTraversableDual1 sat_sc0dG;
          };

Data.Traversable.$fTraversableM2
  :: forall (f :: * -> *) b. f b -> f b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [b1_sc0dH] b1_sc0dH;

Data.Traversable.$fTraversableRec1_$ctraverse
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b) -> GHC.Generics.Rec1 f a -> f1 (GHC.Generics.Rec1 f b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0dI
           $dApplicative_sc0dJ
           eta_sc0dK
           eta1_sc0dL]
        let {
          sat_sc0dN [Occ=Once] :: f1_abVHz (f_abVHm b_abVHB)
          [LclId] =
              [$dTraversable_sc0dI
               $dApplicative_sc0dJ
               eta_sc0dK
               eta1_sc0dL] \u []
                  Data.Traversable.traverse
                      $dTraversable_sc0dI $dApplicative_sc0dJ eta_sc0dK eta1_sc0dL;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0dJ of sat_sc0dM {
            __DEFAULT ->
                GHC.Base.fmap sat_sc0dM Data.Traversable.$fTraversableM2 sat_sc0dN;
          };

Data.Traversable.$fTraversableRec1_$cp2Traversable
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     Data.Foldable.Foldable (GHC.Generics.Rec1 f)
[GblId,
 Arity=1,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0dO]
        let {
          sat_sc0dP [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_abVHm
          [LclId] =
              [$dTraversable_sc0dO] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sc0dO;
        } in  Data.Foldable.$fFoldableRec1 sat_sc0dP;

Data.Traversable.$fTraversableRec1_$cp1Traversable
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     GHC.Base.Functor (GHC.Generics.Rec1 f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0dQ]
        let {
          sat_sc0dR [Occ=Once, Dmd=<L,U(1*U,1*U)>]
            :: GHC.Base.Functor f_abVHm
          [LclId] =
              [$dTraversable_sc0dQ] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sc0dQ;
        } in  GHC.Generics.$fFunctorRec1 sat_sc0dR;

Data.Traversable.$fTraversableK1_$ctraverse
  :: forall i c (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Generics.K1 i c a -> f (GHC.Generics.K1 i c b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0dS ds_sc0dT z_sc0dU]
        GHC.Base.pure $dApplicative_sc0dS z_sc0dU;

Data.Traversable.$fTraversableM1_$ctraverse
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> GHC.Generics.M1 i c f a -> f1 (GHC.Generics.M1 i c f b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0dV
           $dApplicative_sc0dW
           eta_sc0dX
           eta1_sc0dY]
        let {
          sat_sc0e0 [Occ=Once] :: f1_abVFk (f_abVF5 b_abVFm)
          [LclId] =
              [$dTraversable_sc0dV
               $dApplicative_sc0dW
               eta_sc0dX
               eta1_sc0dY] \u []
                  Data.Traversable.traverse
                      $dTraversable_sc0dV $dApplicative_sc0dW eta_sc0dX eta1_sc0dY;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0dW of sat_sc0dZ {
            __DEFAULT ->
                GHC.Base.fmap sat_sc0dZ Data.Traversable.$fTraversableM2 sat_sc0e0;
          };

Data.Traversable.$fTraversableM1_$cp2Traversable
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     Data.Foldable.Foldable (GHC.Generics.M1 i c f)
[GblId,
 Arity=1,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0e1]
        let {
          sat_sc0e2 [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_abVF5
          [LclId] =
              [$dTraversable_sc0e1] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sc0e1;
        } in  Data.Foldable.$fFoldableM1 sat_sc0e2;

Data.Traversable.$fTraversableM1_$cp1Traversable
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     GHC.Base.Functor (GHC.Generics.M1 i c f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0e3]
        let {
          sat_sc0e4 [Occ=Once, Dmd=<L,U(1*U,1*U)>]
            :: GHC.Base.Functor f_abVF5
          [LclId] =
              [$dTraversable_sc0e3] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sc0e3;
        } in  GHC.Generics.$fFunctorM1 sat_sc0e4;

Data.Traversable.$fTraversable:+:_$ctraverse
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> (GHC.Generics.:+:) f g a -> f1 ((GHC.Generics.:+:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0e5
           $dTraversable1_sc0e6
           $dApplicative_sc0e7
           eta_sc0e8
           eta1_sc0e9]
        case eta1_sc0e9 of {
          GHC.Generics.L1 a1_sc0eb [Occ=Once] ->
              let {
                sat_sc0ed [Occ=Once] :: f1_abVDT (f_abVDE b_abVDV)
                [LclId] =
                    [$dTraversable_sc0e5 $dApplicative_sc0e7 eta_sc0e8 a1_sc0eb] \u []
                        Data.Traversable.traverse
                            $dTraversable_sc0e5 $dApplicative_sc0e7 eta_sc0e8 a1_sc0eb;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0e7 of sat_sc0ec {
                  __DEFAULT -> GHC.Base.fmap sat_sc0ec GHC.Generics.L1 sat_sc0ed;
                };
          GHC.Generics.R1 a1_sc0ee [Occ=Once] ->
              let {
                sat_sc0eg [Occ=Once] :: f1_abVDT (g_abVDF b_abVDV)
                [LclId] =
                    [$dTraversable1_sc0e6 $dApplicative_sc0e7 eta_sc0e8 a1_sc0ee] \u []
                        Data.Traversable.traverse
                            $dTraversable1_sc0e6 $dApplicative_sc0e7 eta_sc0e8 a1_sc0ee;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0e7 of sat_sc0ef {
                  __DEFAULT -> GHC.Base.fmap sat_sc0ef GHC.Generics.R1 sat_sc0eg;
                };
        };

Data.Traversable.$fTraversable:+:_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:+: g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0eh $dTraversable1_sc0ei]
        let {
          sat_sc0ek [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_abVDF
          [LclId] =
              [$dTraversable1_sc0ei] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sc0ei; } in
        let {
          sat_sc0ej [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_abVDE
          [LclId] =
              [$dTraversable_sc0eh] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sc0eh;
        } in  Data.Foldable.$fFoldable:+: sat_sc0ej sat_sc0ek;

Data.Traversable.$fTraversable:+:_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (f GHC.Generics.:+: g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),C(C1(U))),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),C(C1(U))),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0el $dTraversable1_sc0em]
        let {
          sat_sc0eo [Occ=Once, Dmd=<L,U(C(C1(U)),C(C1(U)))>]
            :: GHC.Base.Functor g_abVDF
          [LclId] =
              [$dTraversable1_sc0em] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sc0em; } in
        let {
          sat_sc0en [Occ=Once, Dmd=<L,U(C(C1(U)),C(C1(U)))>]
            :: GHC.Base.Functor f_abVDE
          [LclId] =
              [$dTraversable_sc0el] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sc0el;
        } in  GHC.Generics.$fFunctor:+: sat_sc0en sat_sc0eo;

Data.Traversable.$w$ctraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b) -> f a -> g a -> f1 ((GHC.Generics.:*:) f g b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sc0ep w1_sc0eq w2_sc0er w3_sc0es ww_sc0et ww1_sc0eu]
        let {
          sat_sc0ew [Occ=Once] :: f1_sbWKB (g_sbWKy b_sbWKD)
          [LclId] =
              [w1_sc0eq w2_sc0er w3_sc0es ww1_sc0eu] \u []
                  Data.Traversable.traverse
                      w1_sc0eq w2_sc0er w3_sc0es ww1_sc0eu; } in
        let {
          sat_sc0ev [Occ=Once] :: f1_sbWKB (f_sbWKx b_sbWKD)
          [LclId] =
              [w_sc0ep w2_sc0er w3_sc0es ww_sc0et] \u []
                  Data.Traversable.traverse w_sc0ep w2_sc0er w3_sc0es ww_sc0et;
        } in 
          GHC.Base.liftA2 w2_sc0er GHC.Generics.:*: sat_sc0ev sat_sc0ew;

Data.Traversable.$fTraversable:*:_$ctraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> (GHC.Generics.:*:) f g a -> f1 ((GHC.Generics.:*:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sc0ex w1_sc0ey w2_sc0ez w3_sc0eA w4_sc0eB]
        case w4_sc0eB of {
          GHC.Generics.:*: ww1_sc0eD [Occ=Once] ww2_sc0eE [Occ=Once] ->
              Data.Traversable.$w$ctraverse
                  w_sc0ex w1_sc0ey w2_sc0ez w3_sc0eA ww1_sc0eD ww2_sc0eE;
        };

Data.Traversable.$fTraversable:*:_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:*: g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0eF $dTraversable1_sc0eG]
        let {
          sat_sc0eI [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_abVCl
          [LclId] =
              [$dTraversable1_sc0eG] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sc0eG; } in
        let {
          sat_sc0eH [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_abVCk
          [LclId] =
              [$dTraversable_sc0eF] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sc0eF;
        } in  Data.Foldable.$fFoldable:*: sat_sc0eH sat_sc0eI;

Data.Traversable.$fTraversable:*:_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (f GHC.Generics.:*: g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),C(C1(U))),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),C(C1(U))),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0eJ $dTraversable1_sc0eK]
        let {
          sat_sc0eM [Occ=Once, Dmd=<L,U(C(C1(U)),C(C1(U)))>]
            :: GHC.Base.Functor g_abVCl
          [LclId] =
              [$dTraversable1_sc0eK] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sc0eK; } in
        let {
          sat_sc0eL [Occ=Once, Dmd=<L,U(C(C1(U)),C(C1(U)))>]
            :: GHC.Base.Functor f_abVCk
          [LclId] =
              [$dTraversable_sc0eJ] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sc0eJ;
        } in  GHC.Generics.$fFunctor:*: sat_sc0eL sat_sc0eM;

Data.Traversable.$fTraversable:.:1
  :: forall (f :: * -> *) (g :: * -> *) b. f (g b) -> f (g b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [b1_sc0eN] b1_sc0eN;

Data.Traversable.$fTraversable:.:_$ctraverse
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> (GHC.Generics.:.:) f g a -> f1 ((GHC.Generics.:.:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0eO
           $dTraversable1_sc0eP
           $dApplicative_sc0eQ
           eta_sc0eR
           eta1_sc0eS]
        let {
          sat_sc0eV [Occ=Once] :: f1_abVBf (f_abVB0 (g_abVB1 b_abVBh))
          [LclId] =
              [$dTraversable_sc0eO
               $dTraversable1_sc0eP
               $dApplicative_sc0eQ
               eta_sc0eR
               eta1_sc0eS] \u []
                  let {
                    sat_sc0eU [Occ=Once]
                      :: g_abVB1 a_abVBg -> f1_abVBf (g_abVB1 b_abVBh)
                    [LclId] =
                        [$dTraversable1_sc0eP $dApplicative_sc0eQ eta_sc0eR] \u []
                            Data.Traversable.traverse
                                $dTraversable1_sc0eP $dApplicative_sc0eQ eta_sc0eR;
                  } in 
                    Data.Traversable.traverse
                        $dTraversable_sc0eO $dApplicative_sc0eQ sat_sc0eU eta1_sc0eS;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0eQ of sat_sc0eT {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sc0eT Data.Traversable.$fTraversable:.:1 sat_sc0eV;
          };

Data.Traversable.$fTraversable:.:_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:.: g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(U)),C(C1(C1(U))),A,A,A,A,A,A,U,A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0eW $dTraversable1_sc0eX]
        let {
          sat_sc0eZ [Occ=Once,
                     Dmd=<L,U(A,C(C1(U)),C(C1(C1(U))),A,A,A,A,A,A,U,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_abVB1
          [LclId] =
              [$dTraversable1_sc0eX] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sc0eX; } in
        let {
          sat_sc0eY [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_abVB0
          [LclId] =
              [$dTraversable_sc0eW] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sc0eW;
        } in  Data.Foldable.$fFoldable:.: sat_sc0eY sat_sc0eZ;

Data.Traversable.$fTraversable:.:_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (f GHC.Generics.:.: g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(U),C(U)),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0f0 $dTraversable1_sc0f1]
        let {
          sat_sc0f3 [Occ=Once, Dmd=<L,U(C(U),C(U))>]
            :: GHC.Base.Functor g_abVB1
          [LclId] =
              [$dTraversable1_sc0f1] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sc0f1; } in
        let {
          sat_sc0f2 [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_abVB0
          [LclId] =
              [$dTraversable_sc0f0] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sc0f0;
        } in  GHC.Generics.$fFunctor:.: sat_sc0f2 sat_sc0f3;

Data.Traversable.$fTraversableURec4_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a
     -> f (GHC.Generics.URec (GHC.Ptr.Ptr ()) b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0f4 f1_sc0f5 ds_sc0f6]
        case ds_sc0f6 of {
          GHC.Generics.UAddr a1_sc0f8 [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0f4 wild_sc0f7;
        };

Data.Traversable.$fTraversableURec3_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec GHC.Types.Char a
     -> f (GHC.Generics.URec GHC.Types.Char b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0fa f1_sc0fb ds_sc0fc]
        case ds_sc0fc of {
          GHC.Generics.UChar a1_sc0fe [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0fa wild_sc0fd;
        };

Data.Traversable.$fTraversableURec2_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec GHC.Types.Double a
     -> f (GHC.Generics.URec GHC.Types.Double b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0fg f1_sc0fh ds_sc0fi]
        case ds_sc0fi of {
          GHC.Generics.UDouble a1_sc0fk [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0fg wild_sc0fj;
        };

Data.Traversable.$fTraversableURec1_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec GHC.Types.Float a
     -> f (GHC.Generics.URec GHC.Types.Float b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0fm f1_sc0fn ds_sc0fo]
        case ds_sc0fo of {
          GHC.Generics.UFloat a1_sc0fq [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0fm wild_sc0fp;
        };

Data.Traversable.$fTraversableURec0_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec GHC.Types.Int a
     -> f (GHC.Generics.URec GHC.Types.Int b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0fs f1_sc0ft ds_sc0fu]
        case ds_sc0fu of {
          GHC.Generics.UInt a1_sc0fw [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0fs wild_sc0fv;
        };

Data.Traversable.$fTraversableURec_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec GHC.Types.Word a
     -> f (GHC.Generics.URec GHC.Types.Word b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0fy f1_sc0fz ds_sc0fA]
        case ds_sc0fA of {
          GHC.Generics.UWord a1_sc0fC [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0fy wild_sc0fB;
        };

Data.Traversable.$dmsequence [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (m :: * -> *) a. GHC.Base.Monad m => t (m a) -> m (t a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LL),1*U(A,A,A,1*C1(U),A,A)><L,1*U(1*U,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0fE $dMonad_sc0fF]
        let {
          sat_sc0fG [Occ=Once] :: GHC.Base.Applicative m_abVux
          [LclId] =
              [$dMonad_sc0fF] \u [] GHC.Base.$p1Monad $dMonad_sc0fF;
        } in  Data.Traversable.sequenceA $dTraversable_sc0fE sat_sc0fG;

Data.Traversable.$dmmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> t a -> m (t b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)><L,1*U(1*U,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0fH $dMonad_sc0fI]
        let {
          sat_sc0fJ [Occ=Once] :: GHC.Base.Applicative m_abVuj
          [LclId] =
              [$dMonad_sc0fI] \u [] GHC.Base.$p1Monad $dMonad_sc0fI;
        } in  Data.Traversable.traverse $dTraversable_sc0fH sat_sc0fJ;

Data.Traversable.$dmsequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     t (f a) -> f (t a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),1*U(A,A,1*C1(C1(U)),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0fK $dApplicative_sc0fL]
        Data.Traversable.traverse
            $dTraversable_sc0fK $dApplicative_sc0fL GHC.Base.id;

Data.Traversable.$fTraversableURec_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec GHC.Types.Word (f a)
     -> f (GHC.Generics.URec GHC.Types.Word a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0fM ds_sc0fN]
        case ds_sc0fN of {
          GHC.Generics.UWord a1_sc0fP [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0fM wild_sc0fO;
        };

Data.Traversable.$fTraversableURec_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec GHC.Types.Word a
     -> m (GHC.Generics.URec GHC.Types.Word b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0fR eta_sc0fS eta1_sc0fT]
        case eta1_sc0fT of {
          GHC.Generics.UWord a1_sc0fV [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0fR of sat_sc0fW {
                __DEFAULT -> GHC.Base.pure sat_sc0fW wild_sc0fU;
              };
        };

Data.Traversable.$fTraversableURec_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec GHC.Types.Word (m a)
     -> m (GHC.Generics.URec GHC.Types.Word a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0fY eta_sc0fZ]
        case eta_sc0fZ of {
          GHC.Generics.UWord a1_sc0g1 [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0fY of sat_sc0g2 {
                __DEFAULT -> GHC.Base.pure sat_sc0g2 wild_sc0g0;
              };
        };

Data.Traversable.$fTraversableURec [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Word)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec
                                                   Data.Foldable.$fFoldableURec
                                                   Data.Traversable.$fTraversableURec_$ctraverse
                                                   Data.Traversable.$fTraversableURec_$csequenceA
                                                   Data.Traversable.$fTraversableURec_$cmapM
                                                   Data.Traversable.$fTraversableURec_$csequence];

Data.Traversable.$fTraversableURec0_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec GHC.Types.Int (f a)
     -> f (GHC.Generics.URec GHC.Types.Int a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0g4 ds_sc0g5]
        case ds_sc0g5 of {
          GHC.Generics.UInt a1_sc0g7 [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0g4 wild_sc0g6;
        };

Data.Traversable.$fTraversableURec0_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec GHC.Types.Int a
     -> m (GHC.Generics.URec GHC.Types.Int b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0g9 eta_sc0ga eta1_sc0gb]
        case eta1_sc0gb of {
          GHC.Generics.UInt a1_sc0gd [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0g9 of sat_sc0ge {
                __DEFAULT -> GHC.Base.pure sat_sc0ge wild_sc0gc;
              };
        };

Data.Traversable.$fTraversableURec0_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec GHC.Types.Int (m a)
     -> m (GHC.Generics.URec GHC.Types.Int a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0gg eta_sc0gh]
        case eta_sc0gh of {
          GHC.Generics.UInt a1_sc0gj [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0gg of sat_sc0gk {
                __DEFAULT -> GHC.Base.pure sat_sc0gk wild_sc0gi;
              };
        };

Data.Traversable.$fTraversableURec0 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Int)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec0
                                                   Data.Foldable.$fFoldableURec0
                                                   Data.Traversable.$fTraversableURec0_$ctraverse
                                                   Data.Traversable.$fTraversableURec0_$csequenceA
                                                   Data.Traversable.$fTraversableURec0_$cmapM
                                                   Data.Traversable.$fTraversableURec0_$csequence];

Data.Traversable.$fTraversableURec1_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec GHC.Types.Float (f a)
     -> f (GHC.Generics.URec GHC.Types.Float a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0gm ds_sc0gn]
        case ds_sc0gn of {
          GHC.Generics.UFloat a1_sc0gp [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0gm wild_sc0go;
        };

Data.Traversable.$fTraversableURec1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec GHC.Types.Float a
     -> m (GHC.Generics.URec GHC.Types.Float b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0gr eta_sc0gs eta1_sc0gt]
        case eta1_sc0gt of {
          GHC.Generics.UFloat a1_sc0gv [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0gr of sat_sc0gw {
                __DEFAULT -> GHC.Base.pure sat_sc0gw wild_sc0gu;
              };
        };

Data.Traversable.$fTraversableURec1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec GHC.Types.Float (m a)
     -> m (GHC.Generics.URec GHC.Types.Float a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0gy eta_sc0gz]
        case eta_sc0gz of {
          GHC.Generics.UFloat a1_sc0gB [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0gy of sat_sc0gC {
                __DEFAULT -> GHC.Base.pure sat_sc0gC wild_sc0gA;
              };
        };

Data.Traversable.$fTraversableURec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Float)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec1
                                                   Data.Foldable.$fFoldableURec1
                                                   Data.Traversable.$fTraversableURec1_$ctraverse
                                                   Data.Traversable.$fTraversableURec1_$csequenceA
                                                   Data.Traversable.$fTraversableURec1_$cmapM
                                                   Data.Traversable.$fTraversableURec1_$csequence];

Data.Traversable.$fTraversableURec2_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec GHC.Types.Double (f a)
     -> f (GHC.Generics.URec GHC.Types.Double a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0gE ds_sc0gF]
        case ds_sc0gF of {
          GHC.Generics.UDouble a1_sc0gH [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0gE wild_sc0gG;
        };

Data.Traversable.$fTraversableURec2_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec GHC.Types.Double a
     -> m (GHC.Generics.URec GHC.Types.Double b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0gJ eta_sc0gK eta1_sc0gL]
        case eta1_sc0gL of {
          GHC.Generics.UDouble a1_sc0gN [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0gJ of sat_sc0gO {
                __DEFAULT -> GHC.Base.pure sat_sc0gO wild_sc0gM;
              };
        };

Data.Traversable.$fTraversableURec2_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec GHC.Types.Double (m a)
     -> m (GHC.Generics.URec GHC.Types.Double a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0gQ eta_sc0gR]
        case eta_sc0gR of {
          GHC.Generics.UDouble a1_sc0gT [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0gQ of sat_sc0gU {
                __DEFAULT -> GHC.Base.pure sat_sc0gU wild_sc0gS;
              };
        };

Data.Traversable.$fTraversableURec2 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable
       (GHC.Generics.URec GHC.Types.Double)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec2
                                                   Data.Foldable.$fFoldableURec2
                                                   Data.Traversable.$fTraversableURec2_$ctraverse
                                                   Data.Traversable.$fTraversableURec2_$csequenceA
                                                   Data.Traversable.$fTraversableURec2_$cmapM
                                                   Data.Traversable.$fTraversableURec2_$csequence];

Data.Traversable.$fTraversableURec3_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec GHC.Types.Char (f a)
     -> f (GHC.Generics.URec GHC.Types.Char a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0gW ds_sc0gX]
        case ds_sc0gX of {
          GHC.Generics.UChar a1_sc0gZ [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0gW wild_sc0gY;
        };

Data.Traversable.$fTraversableURec3_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec GHC.Types.Char a
     -> m (GHC.Generics.URec GHC.Types.Char b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0h1 eta_sc0h2 eta1_sc0h3]
        case eta1_sc0h3 of {
          GHC.Generics.UChar a1_sc0h5 [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0h1 of sat_sc0h6 {
                __DEFAULT -> GHC.Base.pure sat_sc0h6 wild_sc0h4;
              };
        };

Data.Traversable.$fTraversableURec3_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec GHC.Types.Char (m a)
     -> m (GHC.Generics.URec GHC.Types.Char a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0h8 eta_sc0h9]
        case eta_sc0h9 of {
          GHC.Generics.UChar a1_sc0hb [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0h8 of sat_sc0hc {
                __DEFAULT -> GHC.Base.pure sat_sc0hc wild_sc0ha;
              };
        };

Data.Traversable.$fTraversableURec3 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Char)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec3
                                                   Data.Foldable.$fFoldableURec3
                                                   Data.Traversable.$fTraversableURec3_$ctraverse
                                                   Data.Traversable.$fTraversableURec3_$csequenceA
                                                   Data.Traversable.$fTraversableURec3_$cmapM
                                                   Data.Traversable.$fTraversableURec3_$csequence];

Data.Traversable.$fTraversableURec4_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) (f a)
     -> f (GHC.Generics.URec (GHC.Ptr.Ptr ()) a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0he ds_sc0hf]
        case ds_sc0hf of {
          GHC.Generics.UAddr a1_sc0hh [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0he wild_sc0hg;
        };

Data.Traversable.$fTraversableURec4_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a
     -> m (GHC.Generics.URec (GHC.Ptr.Ptr ()) b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0hj eta_sc0hk eta1_sc0hl]
        case eta1_sc0hl of {
          GHC.Generics.UAddr a1_sc0hn [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0hj of sat_sc0ho {
                __DEFAULT -> GHC.Base.pure sat_sc0ho wild_sc0hm;
              };
        };

Data.Traversable.$fTraversableURec4_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) (m a)
     -> m (GHC.Generics.URec (GHC.Ptr.Ptr ()) a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0hq eta_sc0hr]
        case eta_sc0hr of {
          GHC.Generics.UAddr a1_sc0ht [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0hq of sat_sc0hu {
                __DEFAULT -> GHC.Base.pure sat_sc0hu wild_sc0hs;
              };
        };

Data.Traversable.$fTraversableURec4 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable
       (GHC.Generics.URec (GHC.Ptr.Ptr ()))
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec4
                                                   Data.Foldable.$fFoldableURec4
                                                   Data.Traversable.$fTraversableURec4_$ctraverse
                                                   Data.Traversable.$fTraversableURec4_$csequenceA
                                                   Data.Traversable.$fTraversableURec4_$cmapM
                                                   Data.Traversable.$fTraversableURec4_$csequence];

Data.Traversable.$fTraversable:.:_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     (GHC.Generics.:.:) f g (f1 a) -> f1 ((GHC.Generics.:.:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(A,A,C(C1(U)),A,A,A)><L,U(U(U,U),U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0hw
           $dTraversable1_sc0hx
           $dApplicative_sc0hy
           eta_B1]
        Data.Traversable.$fTraversable:.:_$ctraverse
            $dTraversable_sc0hw
            $dTraversable1_sc0hx
            $dApplicative_sc0hy
            GHC.Base.id
            eta_B1;

Data.Traversable.$fTraversable:.:_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> (GHC.Generics.:.:) f g a -> m ((GHC.Generics.:.:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0hz
           $dTraversable1_sc0hA
           $dMonad_sc0hB
           eta_sc0hC
           eta1_sc0hD]
        case GHC.Base.$p1Monad $dMonad_sc0hB of sat_sc0hE {
          __DEFAULT ->
              Data.Traversable.$fTraversable:.:_$ctraverse
                  $dTraversable_sc0hz
                  $dTraversable1_sc0hA
                  sat_sc0hE
                  eta_sc0hC
                  eta1_sc0hD;
        };

Data.Traversable.$fTraversable:.:_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     (GHC.Generics.:.:) f g (m a) -> m ((GHC.Generics.:.:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0hF
           $dTraversable1_sc0hG
           $dMonad_sc0hH
           eta_sc0hI]
        case GHC.Base.$p1Monad $dMonad_sc0hH of sat_sc0hJ {
          __DEFAULT ->
              Data.Traversable.$fTraversable:.:_$ctraverse
                  $dTraversable_sc0hF
                  $dTraversable1_sc0hG
                  sat_sc0hJ
                  GHC.Base.id
                  eta_sc0hI;
        };

Data.Traversable.$fTraversable:.: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (f GHC.Generics.:.: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(U),C(U)),1*U(A,C(C1(U)),C(C1(C1(U))),A,A,A,A,A,A,U,A,A,A,A,A,A),C(C1(U)),A,A,A)>m] =
    [] \r [$dTraversable_sc0hK $dTraversable1_sc0hL]
        let {
          sat_sc0hR [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               (GHC.Generics.:.:) f_abVB0 g_abVB1 (m a)
               -> m ((GHC.Generics.:.:) f_abVB0 g_abVB1 a)
          [LclId] =
              [$dTraversable_sc0hK $dTraversable1_sc0hL] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:.:_$csequence
                      $dTraversable_sc0hK $dTraversable1_sc0hL eta_B2 eta_B1; } in
        let {
          sat_sc0hQ [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> (GHC.Generics.:.:) f_abVB0 g_abVB1 a
               -> m ((GHC.Generics.:.:) f_abVB0 g_abVB1 b)
          [LclId] =
              [$dTraversable_sc0hK $dTraversable1_sc0hL] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:.:_$cmapM
                      $dTraversable_sc0hK $dTraversable1_sc0hL eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sc0hP [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               (GHC.Generics.:.:) f_abVB0 g_abVB1 (f a)
               -> f ((GHC.Generics.:.:) f_abVB0 g_abVB1 a)
          [LclId] =
              [$dTraversable_sc0hK $dTraversable1_sc0hL] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:.:_$csequenceA
                      $dTraversable_sc0hK $dTraversable1_sc0hL eta_B2 eta_B1; } in
        let {
          sat_sc0hO [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> (GHC.Generics.:.:) f_abVB0 g_abVB1 a
               -> f ((GHC.Generics.:.:) f_abVB0 g_abVB1 b)
          [LclId] =
              [$dTraversable_sc0hK $dTraversable1_sc0hL] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:.:_$ctraverse
                      $dTraversable_sc0hK $dTraversable1_sc0hL eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sc0hN [Occ=Once]
            :: Data.Foldable.Foldable (f_abVB0 GHC.Generics.:.: g_abVB1)
          [LclId] =
              [$dTraversable_sc0hK $dTraversable1_sc0hL] \u []
                  Data.Traversable.$fTraversable:.:_$cp2Traversable
                      $dTraversable_sc0hK $dTraversable1_sc0hL; } in
        let {
          sat_sc0hM [Occ=Once]
            :: GHC.Base.Functor (f_abVB0 GHC.Generics.:.: g_abVB1)
          [LclId] =
              [$dTraversable_sc0hK $dTraversable1_sc0hL] \u []
                  Data.Traversable.$fTraversable:.:_$cp1Traversable
                      $dTraversable_sc0hK $dTraversable1_sc0hL;
        } in 
          Data.Traversable.C:Traversable [sat_sc0hM
                                          sat_sc0hN
                                          sat_sc0hO
                                          sat_sc0hP
                                          sat_sc0hQ
                                          sat_sc0hR];

Data.Traversable.$fTraversable:*:_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     (GHC.Generics.:*:) f g (f1 a) -> f1 ((GHC.Generics.:*:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0hS
           $dTraversable1_sc0hT
           $dApplicative_sc0hU
           w_sc0hV]
        case w_sc0hV of {
          GHC.Generics.:*: ww1_sc0hX [Occ=Once] ww2_sc0hY [Occ=Once] ->
              Data.Traversable.$w$ctraverse
                  $dTraversable_sc0hS
                  $dTraversable1_sc0hT
                  $dApplicative_sc0hU
                  GHC.Base.id
                  ww1_sc0hX
                  ww2_sc0hY;
        };

Data.Traversable.$fTraversable:*:_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> (GHC.Generics.:*:) f g a -> m ((GHC.Generics.:*:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(U,U,U,U,U,U),A,A,A,A)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0hZ
           $dTraversable1_sc0i0
           $dMonad_sc0i1
           eta_sc0i2
           eta1_sc0i3]
        case eta1_sc0i3 of {
          GHC.Generics.:*: ww1_sc0i5 [Occ=Once] ww2_sc0i6 [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0i1 of sat_sc0i7 {
                __DEFAULT ->
                    Data.Traversable.$w$ctraverse
                        $dTraversable_sc0hZ
                        $dTraversable1_sc0i0
                        sat_sc0i7
                        eta_sc0i2
                        ww1_sc0i5
                        ww2_sc0i6;
              };
        };

Data.Traversable.$fTraversable:*:_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     (GHC.Generics.:*:) f g (m a) -> m ((GHC.Generics.:*:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(U,U,U,U,U,U),A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0i8
           $dTraversable1_sc0i9
           $dMonad_sc0ia
           eta_sc0ib]
        case eta_sc0ib of {
          GHC.Generics.:*: ww1_sc0id [Occ=Once] ww2_sc0ie [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0ia of sat_sc0if {
                __DEFAULT ->
                    Data.Traversable.$w$ctraverse
                        $dTraversable_sc0i8
                        $dTraversable1_sc0i9
                        sat_sc0if
                        GHC.Base.id
                        ww1_sc0id
                        ww2_sc0ie;
              };
        };

Data.Traversable.$fTraversable:*: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (f GHC.Generics.:*: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),C(C1(U))),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(C1(U)),C(C1(U))),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sc0ig $dTraversable1_sc0ih]
        let {
          sat_sc0in [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               (GHC.Generics.:*:) f_abVCk g_abVCl (m a)
               -> m ((GHC.Generics.:*:) f_abVCk g_abVCl a)
          [LclId] =
              [$dTraversable_sc0ig $dTraversable1_sc0ih] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:*:_$csequence
                      $dTraversable_sc0ig $dTraversable1_sc0ih eta_B2 eta_B1; } in
        let {
          sat_sc0im [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> (GHC.Generics.:*:) f_abVCk g_abVCl a
               -> m ((GHC.Generics.:*:) f_abVCk g_abVCl b)
          [LclId] =
              [$dTraversable_sc0ig $dTraversable1_sc0ih] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:*:_$cmapM
                      $dTraversable_sc0ig $dTraversable1_sc0ih eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sc0il [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               (GHC.Generics.:*:) f_abVCk g_abVCl (f a)
               -> f ((GHC.Generics.:*:) f_abVCk g_abVCl a)
          [LclId] =
              [$dTraversable_sc0ig $dTraversable1_sc0ih] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:*:_$csequenceA
                      $dTraversable_sc0ig $dTraversable1_sc0ih eta_B2 eta_B1; } in
        let {
          sat_sc0ik [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> (GHC.Generics.:*:) f_abVCk g_abVCl a
               -> f ((GHC.Generics.:*:) f_abVCk g_abVCl b)
          [LclId] =
              [$dTraversable_sc0ig $dTraversable1_sc0ih] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:*:_$ctraverse
                      $dTraversable_sc0ig $dTraversable1_sc0ih eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sc0ij [Occ=Once]
            :: Data.Foldable.Foldable (f_abVCk GHC.Generics.:*: g_abVCl)
          [LclId] =
              [$dTraversable_sc0ig $dTraversable1_sc0ih] \u []
                  Data.Traversable.$fTraversable:*:_$cp2Traversable
                      $dTraversable_sc0ig $dTraversable1_sc0ih; } in
        let {
          sat_sc0ii [Occ=Once]
            :: GHC.Base.Functor (f_abVCk GHC.Generics.:*: g_abVCl)
          [LclId] =
              [$dTraversable_sc0ig $dTraversable1_sc0ih] \u []
                  Data.Traversable.$fTraversable:*:_$cp1Traversable
                      $dTraversable_sc0ig $dTraversable1_sc0ih;
        } in 
          Data.Traversable.C:Traversable [sat_sc0ii
                                          sat_sc0ij
                                          sat_sc0ik
                                          sat_sc0il
                                          sat_sc0im
                                          sat_sc0in];

Data.Traversable.$fTraversable:+:_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     (GHC.Generics.:+:) f g (f1 a) -> f1 ((GHC.Generics.:+:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(U(U,U),U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0io
           $dTraversable1_sc0ip
           $dApplicative_sc0iq
           eta_B1]
        Data.Traversable.$fTraversable:+:_$ctraverse
            $dTraversable_sc0io
            $dTraversable1_sc0ip
            $dApplicative_sc0iq
            GHC.Base.id
            eta_B1;

Data.Traversable.$fTraversable:+:_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> (GHC.Generics.:+:) f g a -> m ((GHC.Generics.:+:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0ir
           $dTraversable1_sc0is
           $dMonad_sc0it
           eta_sc0iu
           eta1_sc0iv]
        case GHC.Base.$p1Monad $dMonad_sc0it of sat_sc0iw {
          __DEFAULT ->
              Data.Traversable.$fTraversable:+:_$ctraverse
                  $dTraversable_sc0ir
                  $dTraversable1_sc0is
                  sat_sc0iw
                  eta_sc0iu
                  eta1_sc0iv;
        };

Data.Traversable.$fTraversable:+:_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     (GHC.Generics.:+:) f g (m a) -> m ((GHC.Generics.:+:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0ix
           $dTraversable1_sc0iy
           $dMonad_sc0iz
           eta_sc0iA]
        case GHC.Base.$p1Monad $dMonad_sc0iz of sat_sc0iB {
          __DEFAULT ->
              Data.Traversable.$fTraversable:+:_$ctraverse
                  $dTraversable_sc0ix
                  $dTraversable1_sc0iy
                  sat_sc0iB
                  GHC.Base.id
                  eta_sc0iA;
        };

Data.Traversable.$fTraversable:+: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (f GHC.Generics.:+: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),C(C1(U))),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(C1(U)),C(C1(U))),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sc0iC $dTraversable1_sc0iD]
        let {
          sat_sc0iJ [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               (GHC.Generics.:+:) f_abVDE g_abVDF (m a)
               -> m ((GHC.Generics.:+:) f_abVDE g_abVDF a)
          [LclId] =
              [$dTraversable_sc0iC $dTraversable1_sc0iD] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:+:_$csequence
                      $dTraversable_sc0iC $dTraversable1_sc0iD eta_B2 eta_B1; } in
        let {
          sat_sc0iI [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> (GHC.Generics.:+:) f_abVDE g_abVDF a
               -> m ((GHC.Generics.:+:) f_abVDE g_abVDF b)
          [LclId] =
              [$dTraversable_sc0iC $dTraversable1_sc0iD] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:+:_$cmapM
                      $dTraversable_sc0iC $dTraversable1_sc0iD eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sc0iH [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               (GHC.Generics.:+:) f_abVDE g_abVDF (f a)
               -> f ((GHC.Generics.:+:) f_abVDE g_abVDF a)
          [LclId] =
              [$dTraversable_sc0iC $dTraversable1_sc0iD] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:+:_$csequenceA
                      $dTraversable_sc0iC $dTraversable1_sc0iD eta_B2 eta_B1; } in
        let {
          sat_sc0iG [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> (GHC.Generics.:+:) f_abVDE g_abVDF a
               -> f ((GHC.Generics.:+:) f_abVDE g_abVDF b)
          [LclId] =
              [$dTraversable_sc0iC $dTraversable1_sc0iD] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:+:_$ctraverse
                      $dTraversable_sc0iC $dTraversable1_sc0iD eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sc0iF [Occ=Once]
            :: Data.Foldable.Foldable (f_abVDE GHC.Generics.:+: g_abVDF)
          [LclId] =
              [$dTraversable_sc0iC $dTraversable1_sc0iD] \u []
                  Data.Traversable.$fTraversable:+:_$cp2Traversable
                      $dTraversable_sc0iC $dTraversable1_sc0iD; } in
        let {
          sat_sc0iE [Occ=Once]
            :: GHC.Base.Functor (f_abVDE GHC.Generics.:+: g_abVDF)
          [LclId] =
              [$dTraversable_sc0iC $dTraversable1_sc0iD] \u []
                  Data.Traversable.$fTraversable:+:_$cp1Traversable
                      $dTraversable_sc0iC $dTraversable1_sc0iD;
        } in 
          Data.Traversable.C:Traversable [sat_sc0iE
                                          sat_sc0iF
                                          sat_sc0iG
                                          sat_sc0iH
                                          sat_sc0iI
                                          sat_sc0iJ];

Data.Traversable.$fTraversableM1_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     GHC.Generics.M1 i c f (f1 a) -> f1 (GHC.Generics.M1 i c f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0iK $dApplicative_sc0iL eta_sc0iM]
        let {
          sat_sc0iO [Occ=Once] :: f1_abVFI (f_abVF5 a_abVFJ)
          [LclId] =
              [$dTraversable_sc0iK $dApplicative_sc0iL eta_sc0iM] \u []
                  Data.Traversable.traverse
                      $dTraversable_sc0iK $dApplicative_sc0iL GHC.Base.id eta_sc0iM;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0iL of sat_sc0iN {
            __DEFAULT ->
                GHC.Base.fmap sat_sc0iN Data.Traversable.$fTraversableM2 sat_sc0iO;
          };

Data.Traversable.$fTraversableM1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.M1 i c f a -> m (GHC.Generics.M1 i c f b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0iP $dMonad_sc0iQ eta_sc0iR eta1_sc0iS]
        case
            GHC.Base.$p1Monad $dMonad_sc0iQ
        of
        $dApplicative_sc0iT [Dmd=<S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)>]
        { __DEFAULT ->
              let {
                sat_sc0iV [Occ=Once] :: m_abVFU (f_abVF5 b_abVFW)
                [LclId] =
                    [$dTraversable_sc0iP
                     eta_sc0iR
                     eta1_sc0iS
                     $dApplicative_sc0iT] \u []
                        Data.Traversable.traverse
                            $dTraversable_sc0iP $dApplicative_sc0iT eta_sc0iR eta1_sc0iS;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0iT of sat_sc0iU {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sc0iU Data.Traversable.$fTraversableM2 sat_sc0iV;
                };
        };

Data.Traversable.$fTraversableM1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.M1 i c f (m a) -> m (GHC.Generics.M1 i c f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0iW $dMonad_sc0iX eta_sc0iY]
        case
            GHC.Base.$p1Monad $dMonad_sc0iX
        of
        $dApplicative_sc0iZ [Dmd=<S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)>]
        { __DEFAULT ->
              let {
                sat_sc0j1 [Occ=Once] :: m_abVG8 (f_abVF5 a_abVG9)
                [LclId] =
                    [$dTraversable_sc0iW eta_sc0iY $dApplicative_sc0iZ] \u []
                        Data.Traversable.traverse
                            $dTraversable_sc0iW $dApplicative_sc0iZ GHC.Base.id eta_sc0iY;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0iZ of sat_sc0j0 {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sc0j0 Data.Traversable.$fTraversableM2 sat_sc0j1;
                };
        };

Data.Traversable.$fTraversableM1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     Data.Traversable.Traversable (GHC.Generics.M1 i c f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(1*U(1*U,1*U),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sc0j2]
        let {
          sat_sc0j8 [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 (m a)
               -> m (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 a)
          [LclId] =
              [$dTraversable_sc0j2] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableM1_$csequence
                      $dTraversable_sc0j2 eta_B2 eta_B1; } in
        let {
          sat_sc0j7 [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 a
               -> m (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 b)
          [LclId] =
              [$dTraversable_sc0j2] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableM1_$cmapM
                      $dTraversable_sc0j2 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sc0j6 [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 (f a)
               -> f (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 a)
          [LclId] =
              [$dTraversable_sc0j2] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableM1_$csequenceA
                      $dTraversable_sc0j2 eta_B2 eta_B1; } in
        let {
          sat_sc0j5 [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 a
               -> f (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 b)
          [LclId] =
              [$dTraversable_sc0j2] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableM1_$ctraverse
                      $dTraversable_sc0j2 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sc0j4 [Occ=Once]
            :: Data.Foldable.Foldable (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5)
          [LclId] =
              [$dTraversable_sc0j2] \u []
                  Data.Traversable.$fTraversableM1_$cp2Traversable
                      $dTraversable_sc0j2; } in
        let {
          sat_sc0j3 [Occ=Once]
            :: GHC.Base.Functor (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5)
          [LclId] =
              [$dTraversable_sc0j2] \u []
                  Data.Traversable.$fTraversableM1_$cp1Traversable
                      $dTraversable_sc0j2;
        } in 
          Data.Traversable.C:Traversable [sat_sc0j3
                                          sat_sc0j4
                                          sat_sc0j5
                                          sat_sc0j6
                                          sat_sc0j7
                                          sat_sc0j8];

Data.Traversable.$fTraversableK1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall i c (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Generics.K1 i c a -> m (GHC.Generics.K1 i c b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0j9 eta_sc0ja eta1_sc0jb]
        case GHC.Base.$p1Monad $dMonad_sc0j9 of sat_sc0jc {
          __DEFAULT -> GHC.Base.pure sat_sc0jc eta1_sc0jb;
        };

Data.Traversable.$fTraversableK1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall i c (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.K1 i c (m a) -> m (GHC.Generics.K1 i c a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0jd eta_sc0je]
        case GHC.Base.$p1Monad $dMonad_sc0jd of sat_sc0jf {
          __DEFAULT -> GHC.Base.pure sat_sc0jf eta_sc0je;
        };

$fTraversableK2_rbWTS
  :: forall c i (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.K1 i c (f a) -> f (GHC.Generics.K1 i c a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0jg z_sc0jh]
        GHC.Base.pure $dApplicative_sc0jg z_sc0jh;

Data.Traversable.$fTraversableK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i c. Data.Traversable.Traversable (GHC.Generics.K1 i c)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorK1
                                                   Data.Foldable.$fFoldableK1
                                                   Data.Traversable.$fTraversableK1_$ctraverse
                                                   $fTraversableK2_rbWTS
                                                   Data.Traversable.$fTraversableK1_$cmapM
                                                   Data.Traversable.$fTraversableK1_$csequence];

Data.Traversable.$fTraversableRec1_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     GHC.Generics.Rec1 f (f1 a) -> f1 (GHC.Generics.Rec1 f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0ji $dApplicative_sc0jj eta_sc0jk]
        let {
          sat_sc0jm [Occ=Once] :: f1_abVHV (f_abVHm a_abVHW)
          [LclId] =
              [$dTraversable_sc0ji $dApplicative_sc0jj eta_sc0jk] \u []
                  Data.Traversable.traverse
                      $dTraversable_sc0ji $dApplicative_sc0jj GHC.Base.id eta_sc0jk;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0jj of sat_sc0jl {
            __DEFAULT ->
                GHC.Base.fmap sat_sc0jl Data.Traversable.$fTraversableM2 sat_sc0jm;
          };

Data.Traversable.$fTraversableRec1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Generics.Rec1 f a -> m (GHC.Generics.Rec1 f b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0jn $dMonad_sc0jo eta_sc0jp eta1_sc0jq]
        case
            GHC.Base.$p1Monad $dMonad_sc0jo
        of
        $dApplicative_sc0jr [Dmd=<S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)>]
        { __DEFAULT ->
              let {
                sat_sc0jt [Occ=Once] :: m_abVI7 (f_abVHm b_abVI9)
                [LclId] =
                    [$dTraversable_sc0jn
                     eta_sc0jp
                     eta1_sc0jq
                     $dApplicative_sc0jr] \u []
                        Data.Traversable.traverse
                            $dTraversable_sc0jn $dApplicative_sc0jr eta_sc0jp eta1_sc0jq;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0jr of sat_sc0js {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sc0js Data.Traversable.$fTraversableM2 sat_sc0jt;
                };
        };

Data.Traversable.$fTraversableRec1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.Rec1 f (m a) -> m (GHC.Generics.Rec1 f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0ju $dMonad_sc0jv eta_sc0jw]
        case
            GHC.Base.$p1Monad $dMonad_sc0jv
        of
        $dApplicative_sc0jx [Dmd=<S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)>]
        { __DEFAULT ->
              let {
                sat_sc0jz [Occ=Once] :: m_abVIl (f_abVHm a_abVIm)
                [LclId] =
                    [$dTraversable_sc0ju eta_sc0jw $dApplicative_sc0jx] \u []
                        Data.Traversable.traverse
                            $dTraversable_sc0ju $dApplicative_sc0jx GHC.Base.id eta_sc0jw;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0jx of sat_sc0jy {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sc0jy Data.Traversable.$fTraversableM2 sat_sc0jz;
                };
        };

Data.Traversable.$fTraversableRec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     Data.Traversable.Traversable (GHC.Generics.Rec1 f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(1*U(1*U,1*U),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sc0jA]
        let {
          sat_sc0jG [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               GHC.Generics.Rec1 f_abVHm (m a) -> m (GHC.Generics.Rec1 f_abVHm a)
          [LclId] =
              [$dTraversable_sc0jA] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableRec1_$csequence
                      $dTraversable_sc0jA eta_B2 eta_B1; } in
        let {
          sat_sc0jF [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> GHC.Generics.Rec1 f_abVHm a -> m (GHC.Generics.Rec1 f_abVHm b)
          [LclId] =
              [$dTraversable_sc0jA] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableRec1_$cmapM
                      $dTraversable_sc0jA eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sc0jE [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               GHC.Generics.Rec1 f_abVHm (f a) -> f (GHC.Generics.Rec1 f_abVHm a)
          [LclId] =
              [$dTraversable_sc0jA] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableRec1_$csequenceA
                      $dTraversable_sc0jA eta_B2 eta_B1; } in
        let {
          sat_sc0jD [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> GHC.Generics.Rec1 f_abVHm a -> f (GHC.Generics.Rec1 f_abVHm b)
          [LclId] =
              [$dTraversable_sc0jA] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableRec1_$ctraverse
                      $dTraversable_sc0jA eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sc0jC [Occ=Once]
            :: Data.Foldable.Foldable (GHC.Generics.Rec1 f_abVHm)
          [LclId] =
              [$dTraversable_sc0jA] \u []
                  Data.Traversable.$fTraversableRec1_$cp2Traversable
                      $dTraversable_sc0jA; } in
        let {
          sat_sc0jB [Occ=Once]
            :: GHC.Base.Functor (GHC.Generics.Rec1 f_abVHm)
          [LclId] =
              [$dTraversable_sc0jA] \u []
                  Data.Traversable.$fTraversableRec1_$cp1Traversable
                      $dTraversable_sc0jA;
        } in 
          Data.Traversable.C:Traversable [sat_sc0jB
                                          sat_sc0jC
                                          sat_sc0jD
                                          sat_sc0jE
                                          sat_sc0jF
                                          sat_sc0jG];

Data.Traversable.$fTraversablePar1_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.Par1 (f a) -> f (GHC.Generics.Par1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0jH eta_sc0jI]
        case GHC.Base.$p1Applicative $dApplicative_sc0jH of sat_sc0jJ {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sc0jJ Data.Traversable.$fTraversableDual1 eta_sc0jI;
        };

Data.Traversable.$fTraversablePar1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Generics.Par1 a -> m (GHC.Generics.Par1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0jK eta_sc0jL eta1_sc0jM]
        let {
          sat_sc0jP [Occ=Once] :: m_abVJ7 b_abVJ9
          [LclId] =
              [eta_sc0jL eta1_sc0jM] \u [] eta_sc0jL eta1_sc0jM;
        } in 
          case GHC.Base.$p1Monad $dMonad_sc0jK of sat_sc0jN {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sc0jN of sat_sc0jO {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sc0jO Data.Traversable.$fTraversableDual1 sat_sc0jP;
                };
          };

Data.Traversable.$fTraversablePar1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.Par1 (m a) -> m (GHC.Generics.Par1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0jQ eta_sc0jR]
        case GHC.Base.$p1Monad $dMonad_sc0jQ of sat_sc0jS {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sc0jS of sat_sc0jT {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sc0jT Data.Traversable.$fTraversableDual1 eta_sc0jR;
              };
        };

Data.Traversable.$fTraversablePar1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable GHC.Generics.Par1
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorPar1
                                                   Data.Foldable.$fFoldablePar1
                                                   Data.Traversable.$fTraversablePar1_$ctraverse
                                                   Data.Traversable.$fTraversablePar1_$csequenceA
                                                   Data.Traversable.$fTraversablePar1_$cmapM
                                                   Data.Traversable.$fTraversablePar1_$csequence];

Data.Traversable.$fTraversableV1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Generics.V1 a -> m (GHC.Generics.V1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0jU eta_sc0jV eta1_sc0jW]
        case GHC.Base.$p1Monad $dMonad_sc0jU of sat_sc0jX {
          __DEFAULT -> GHC.Base.pure sat_sc0jX eta1_sc0jW;
        };

Data.Traversable.$fTraversableV1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.V1 (m a) -> m (GHC.Generics.V1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0jY eta_sc0jZ]
        case GHC.Base.$p1Monad $dMonad_sc0jY of sat_sc0k0 {
          __DEFAULT -> GHC.Base.pure sat_sc0k0 eta_sc0jZ;
        };

$fTraversableV2_rbWTT
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.V1 (f a) -> f (GHC.Generics.V1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0k1 z_sc0k2]
        GHC.Base.pure $dApplicative_sc0k1 z_sc0k2;

Data.Traversable.$fTraversableV1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable GHC.Generics.V1
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorV1
                                                   Data.Foldable.$fFoldableV1
                                                   Data.Traversable.$fTraversableV1_$ctraverse
                                                   $fTraversableV2_rbWTT
                                                   Data.Traversable.$fTraversableV1_$cmapM
                                                   Data.Traversable.$fTraversableV1_$csequence];

Data.Traversable.$fTraversableIdentity_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Functor.Identity.Identity (f a)
     -> f (Data.Functor.Identity.Identity a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0k3 eta_sc0k4]
        case GHC.Base.$p1Applicative $dApplicative_sc0k3 of sat_sc0k5 {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sc0k5 Data.Traversable.$fTraversableDual1 eta_sc0k4;
        };

Data.Traversable.$fTraversableIdentity_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Functor.Identity.Identity a
     -> m (Data.Functor.Identity.Identity b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0k6 eta_sc0k7 eta1_sc0k8]
        let {
          sat_sc0kb [Occ=Once] :: m_abVL8 b_abVLa
          [LclId] =
              [eta_sc0k7 eta1_sc0k8] \u [] eta_sc0k7 eta1_sc0k8;
        } in 
          case GHC.Base.$p1Monad $dMonad_sc0k6 of sat_sc0k9 {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sc0k9 of sat_sc0ka {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sc0ka Data.Traversable.$fTraversableDual1 sat_sc0kb;
                };
          };

Data.Traversable.$fTraversableIdentity_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Functor.Identity.Identity (m a)
     -> m (Data.Functor.Identity.Identity a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0kc eta_sc0kd]
        case GHC.Base.$p1Monad $dMonad_sc0kc of sat_sc0ke {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sc0ke of sat_sc0kf {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sc0kf Data.Traversable.$fTraversableDual1 eta_sc0kd;
              };
        };

Data.Traversable.$fTraversableIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Functor.Identity.$fFunctorIdentity
                                                   Data.Functor.Identity.$fFoldableIdentity
                                                   Data.Traversable.$fTraversableIdentity_$ctraverse
                                                   Data.Traversable.$fTraversableIdentity_$csequenceA
                                                   Data.Traversable.$fTraversableIdentity_$cmapM
                                                   Data.Traversable.$fTraversableIdentity_$csequence];

Data.Traversable.$fTraversableProduct_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Internal.Product (f a)
     -> f (Data.Semigroup.Internal.Product a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0kg eta_sc0kh]
        case GHC.Base.$p1Applicative $dApplicative_sc0kg of sat_sc0ki {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sc0ki Data.Traversable.$fTraversableDual1 eta_sc0kh;
        };

Data.Traversable.$fTraversableProduct_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Semigroup.Internal.Product a
     -> m (Data.Semigroup.Internal.Product b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0kj eta_sc0kk eta1_sc0kl]
        let {
          sat_sc0ko [Occ=Once] :: m_abVQs b_abVQu
          [LclId] =
              [eta_sc0kk eta1_sc0kl] \u [] eta_sc0kk eta1_sc0kl;
        } in 
          case GHC.Base.$p1Monad $dMonad_sc0kj of sat_sc0km {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sc0km of sat_sc0kn {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sc0kn Data.Traversable.$fTraversableDual1 sat_sc0ko;
                };
          };

Data.Traversable.$fTraversableProduct_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Internal.Product (m a)
     -> m (Data.Semigroup.Internal.Product a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0kp eta_sc0kq]
        case GHC.Base.$p1Monad $dMonad_sc0kp of sat_sc0kr {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sc0kr of sat_sc0ks {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sc0ks Data.Traversable.$fTraversableDual1 eta_sc0kq;
              };
        };

Data.Traversable.$fTraversableProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Internal.Product
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.Internal.$fFunctorProduct
                                                   Data.Foldable.$fFoldableProduct
                                                   Data.Traversable.$fTraversableProduct_$ctraverse
                                                   Data.Traversable.$fTraversableProduct_$csequenceA
                                                   Data.Traversable.$fTraversableProduct_$cmapM
                                                   Data.Traversable.$fTraversableProduct_$csequence];

Data.Traversable.$fTraversableSum_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Internal.Sum (f a)
     -> f (Data.Semigroup.Internal.Sum a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0kt eta_sc0ku]
        case GHC.Base.$p1Applicative $dApplicative_sc0kt of sat_sc0kv {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sc0kv Data.Traversable.$fTraversableDual1 eta_sc0ku;
        };

Data.Traversable.$fTraversableSum_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Semigroup.Internal.Sum a
     -> m (Data.Semigroup.Internal.Sum b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0kw eta_sc0kx eta1_sc0ky]
        let {
          sat_sc0kB [Occ=Once] :: m_abVRs b_abVRu
          [LclId] =
              [eta_sc0kx eta1_sc0ky] \u [] eta_sc0kx eta1_sc0ky;
        } in 
          case GHC.Base.$p1Monad $dMonad_sc0kw of sat_sc0kz {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sc0kz of sat_sc0kA {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sc0kA Data.Traversable.$fTraversableDual1 sat_sc0kB;
                };
          };

Data.Traversable.$fTraversableSum_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Internal.Sum (m a)
     -> m (Data.Semigroup.Internal.Sum a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0kC eta_sc0kD]
        case GHC.Base.$p1Monad $dMonad_sc0kC of sat_sc0kE {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sc0kE of sat_sc0kF {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sc0kF Data.Traversable.$fTraversableDual1 eta_sc0kD;
              };
        };

Data.Traversable.$fTraversableSum [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Internal.Sum
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.Internal.$fFunctorSum
                                                   Data.Foldable.$fFoldableSum
                                                   Data.Traversable.$fTraversableSum_$ctraverse
                                                   Data.Traversable.$fTraversableSum_$csequenceA
                                                   Data.Traversable.$fTraversableSum_$cmapM
                                                   Data.Traversable.$fTraversableSum_$csequence];

Data.Traversable.$fTraversableDual_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Internal.Dual (f a)
     -> f (Data.Semigroup.Internal.Dual a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0kG eta_sc0kH]
        case GHC.Base.$p1Applicative $dApplicative_sc0kG of sat_sc0kI {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sc0kI Data.Traversable.$fTraversableDual1 eta_sc0kH;
        };

Data.Traversable.$fTraversableDual_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Semigroup.Internal.Dual a
     -> m (Data.Semigroup.Internal.Dual b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0kJ eta_sc0kK eta1_sc0kL]
        let {
          sat_sc0kO [Occ=Once] :: m_abVSs b_abVSu
          [LclId] =
              [eta_sc0kK eta1_sc0kL] \u [] eta_sc0kK eta1_sc0kL;
        } in 
          case GHC.Base.$p1Monad $dMonad_sc0kJ of sat_sc0kM {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sc0kM of sat_sc0kN {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sc0kN Data.Traversable.$fTraversableDual1 sat_sc0kO;
                };
          };

Data.Traversable.$fTraversableDual_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Internal.Dual (m a)
     -> m (Data.Semigroup.Internal.Dual a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0kP eta_sc0kQ]
        case GHC.Base.$p1Monad $dMonad_sc0kP of sat_sc0kR {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sc0kR of sat_sc0kS {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sc0kS Data.Traversable.$fTraversableDual1 eta_sc0kQ;
              };
        };

Data.Traversable.$fTraversableDual [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Internal.Dual
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.Internal.$fFunctorDual
                                                   Data.Foldable.$fFoldableDual
                                                   Data.Traversable.$fTraversableDual_$ctraverse
                                                   Data.Traversable.$fTraversableDual_$csequenceA
                                                   Data.Traversable.$fTraversableDual_$cmapM
                                                   Data.Traversable.$fTraversableDual_$csequence];

Data.Traversable.$fTraversableConst_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall m1 (m2 :: * -> *) a b.
     GHC.Base.Monad m2 =>
     (a -> m2 b)
     -> Data.Functor.Const.Const m1 a
     -> m2 (Data.Functor.Const.Const m1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0kT eta_sc0kU eta1_sc0kV]
        case GHC.Base.$p1Monad $dMonad_sc0kT of sat_sc0kW {
          __DEFAULT -> GHC.Base.pure sat_sc0kW eta1_sc0kV;
        };

Data.Traversable.$fTraversableConst_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall m1 (m2 :: * -> *) a.
     GHC.Base.Monad m2 =>
     Data.Functor.Const.Const m1 (m2 a)
     -> m2 (Data.Functor.Const.Const m1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0kX eta_sc0kY]
        case GHC.Base.$p1Monad $dMonad_sc0kX of sat_sc0kZ {
          __DEFAULT -> GHC.Base.pure sat_sc0kZ eta_sc0kY;
        };

$fTraversableConst1_rbWTU
  :: forall m (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Functor.Const.Const m (f a)
     -> f (Data.Functor.Const.Const m a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0l0 ds_sc0l1]
        GHC.Base.pure $dApplicative_sc0l0 ds_sc0l1;

Data.Traversable.$fTraversableConst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     Data.Traversable.Traversable (Data.Functor.Const.Const m)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Functor.Const.$fFunctorConst
                                                   Data.Functor.Const.$fFoldableConst
                                                   Data.Traversable.$fTraversableConst_$ctraverse
                                                   $fTraversableConst1_rbWTU
                                                   Data.Traversable.$fTraversableConst_$cmapM
                                                   Data.Traversable.$fTraversableConst_$csequence];

Data.Traversable.$fTraversable(,)_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (f :: * -> *) a2.
     GHC.Base.Applicative f =>
     (a1, f a2) -> f (a1, a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0l2 eta_sc0l3]
        case eta_sc0l3 of {
          (,) x_sc0l5 [Occ=OnceL] y_sc0l6 [Occ=Once] ->
              let {
                sat_sc0l8 [Occ=Once] :: a1_abVWL -> (a_abVWj, a1_abVWL)
                [LclId] =
                    [x_sc0l5] \r [eta_B1] (,) [x_sc0l5 eta_B1];
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0l2 of sat_sc0l7 {
                  __DEFAULT -> GHC.Base.fmap sat_sc0l7 sat_sc0l8 y_sc0l6;
                };
        };

Data.Traversable.$fTraversable(,)_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2 b.
     GHC.Base.Monad m =>
     (a2 -> m b) -> (a1, a2) -> m (a1, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0l9 eta_sc0la eta1_sc0lb]
        case eta1_sc0lb of {
          (,) x_sc0ld [Occ=OnceL] y_sc0le [Occ=Once] ->
              let {
                sat_sc0li [Occ=Once] :: m_abVWW b_abVWY
                [LclId] =
                    [eta_sc0la y_sc0le] \u [] eta_sc0la y_sc0le; } in
              let {
                sat_sc0lh [Occ=Once] :: b_abVWY -> (a_abVWj, b_abVWY)
                [LclId] =
                    [x_sc0ld] \r [eta_B1] (,) [x_sc0ld eta_B1];
              } in 
                case GHC.Base.$p1Monad $dMonad_sc0l9 of sat_sc0lf {
                  __DEFAULT ->
                      case GHC.Base.$p1Applicative sat_sc0lf of sat_sc0lg {
                        __DEFAULT -> GHC.Base.fmap sat_sc0lg sat_sc0lh sat_sc0li;
                      };
                };
        };

Data.Traversable.$fTraversable(,)_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2.
     GHC.Base.Monad m =>
     (a1, m a2) -> m (a1, a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0lj eta_sc0lk]
        case eta_sc0lk of {
          (,) x_sc0lm [Occ=OnceL] y_sc0ln [Occ=Once] ->
              let {
                sat_sc0lq [Occ=Once] :: a1_abVXb -> (a_abVWj, a1_abVXb)
                [LclId] =
                    [x_sc0lm] \r [eta_B1] (,) [x_sc0lm eta_B1];
              } in 
                case GHC.Base.$p1Monad $dMonad_sc0lj of sat_sc0lo {
                  __DEFAULT ->
                      case GHC.Base.$p1Applicative sat_sc0lo of sat_sc0lp {
                        __DEFAULT -> GHC.Base.fmap sat_sc0lp sat_sc0lq y_sc0ln;
                      };
                };
        };

Data.Traversable.$fTraversable(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Traversable.Traversable ((,) a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Base.$fFunctor(,)
                                                   Data.Foldable.$fFoldable(,)
                                                   Data.Traversable.$fTraversable(,)_$ctraverse
                                                   Data.Traversable.$fTraversable(,)_$csequenceA
                                                   Data.Traversable.$fTraversable(,)_$cmapM
                                                   Data.Traversable.$fTraversable(,)_$csequence];

Data.Traversable.$fTraversableEither_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (f :: * -> *) a2.
     GHC.Base.Applicative f =>
     Data.Either.Either a1 (f a2) -> f (Data.Either.Either a1 a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0lr eta_sc0ls]
        case eta_sc0ls of {
          Data.Either.Left x_sc0lu [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0lr wild_sc0lt;
          Data.Either.Right y_sc0lw [Occ=Once] ->
              case GHC.Base.$p1Applicative $dApplicative_sc0lr of sat_sc0lx {
                __DEFAULT -> GHC.Base.fmap sat_sc0lx Data.Either.Right y_sc0lw;
              };
        };

Data.Traversable.$fTraversableEither_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2 b.
     GHC.Base.Monad m =>
     (a2 -> m b)
     -> Data.Either.Either a1 a2 -> m (Data.Either.Either a1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0ly eta_sc0lz eta1_sc0lA]
        case GHC.Base.$p1Monad $dMonad_sc0ly of sat_sc0lB {
          __DEFAULT ->
              Data.Traversable.$fTraversableEither_$ctraverse
                  sat_sc0lB eta_sc0lz eta1_sc0lA;
        };

Data.Traversable.$fTraversableEither_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2.
     GHC.Base.Monad m =>
     Data.Either.Either a1 (m a2) -> m (Data.Either.Either a1 a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0lC eta_sc0lD]
        case eta_sc0lD of {
          Data.Either.Left x_sc0lF [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0lC of sat_sc0lG {
                __DEFAULT -> GHC.Base.pure sat_sc0lG wild_sc0lE;
              };
          Data.Either.Right y_sc0lI [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0lC of sat_sc0lJ {
                __DEFAULT ->
                    case GHC.Base.$p1Applicative sat_sc0lJ of sat_sc0lK {
                      __DEFAULT -> GHC.Base.fmap sat_sc0lK Data.Either.Right y_sc0lI;
                    };
              };
        };

Data.Traversable.$fTraversableEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Traversable.Traversable (Data.Either.Either a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Either.$fFunctorEither
                                                   Data.Foldable.$fFoldableEither
                                                   Data.Traversable.$fTraversableEither_$ctraverse
                                                   Data.Traversable.$fTraversableEither_$csequenceA
                                                   Data.Traversable.$fTraversableEither_$cmapM
                                                   Data.Traversable.$fTraversableEither_$csequence];

Data.Traversable.$fTraversable[]_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a. GHC.Base.Applicative f => [f a] -> f [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,1*C1(U),A,C(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0lL]
        let {
          z_sc0lM [Occ=OnceL] :: f_abW0j [a_abW0k]
          [LclId] =
              [$dApplicative_sc0lL] \u []
                  GHC.Base.pure $dApplicative_sc0lL GHC.Types.[]; } in
        let {
          go_sc0lN [Occ=LoopBreaker]
            :: [f_abW0j a_abW0k] -> f_abW0j [a_abW0k]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [$dApplicative_sc0lL z_sc0lM go_sc0lN] \r [ds_sc0lO]
                  case ds_sc0lO of {
                    [] -> z_sc0lM;
                    : y_sc0lQ [Occ=Once] ys_sc0lR [Occ=Once] ->
                        let {
                          sat_sc0lS [Occ=Once] :: f_abW0j [a_abW0k]
                          [LclId] =
                              [go_sc0lN ys_sc0lR] \u [] go_sc0lN ys_sc0lR;
                        } in 
                          GHC.Base.liftA2 $dApplicative_sc0lL GHC.Types.: y_sc0lQ sat_sc0lS;
                  };
        } in  go_sc0lN;

Data.Traversable.$fTraversable[]_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> [a] -> m [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0lT eta_sc0lU]
        let {
          $dApplicative_sc0lV [Dmd=<L,U(A,1*C1(U),A,C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative m_abW0v
          [LclId] =
              [$dMonad_sc0lT] \u [] GHC.Base.$p1Monad $dMonad_sc0lT; } in
        let {
          z_sc0lW [Occ=OnceL] :: m_abW0v [b_abW0x]
          [LclId] =
              [$dApplicative_sc0lV] \u []
                  GHC.Base.pure $dApplicative_sc0lV GHC.Types.[]; } in
        let {
          go_sc0lX [Occ=LoopBreaker] :: [a_abW0w] -> m_abW0v [b_abW0x]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [eta_sc0lU $dApplicative_sc0lV z_sc0lW go_sc0lX] \r [ds_sc0lY]
                  case ds_sc0lY of {
                    [] -> z_sc0lW;
                    : y_sc0m0 [Occ=Once] ys_sc0m1 [Occ=Once] ->
                        let {
                          sat_sc0m3 [Occ=Once] :: m_abW0v [b_abW0x]
                          [LclId] =
                              [go_sc0lX ys_sc0m1] \u [] go_sc0lX ys_sc0m1; } in
                        let {
                          sat_sc0m2 [Occ=Once] :: m_abW0v b_abW0x
                          [LclId] =
                              [eta_sc0lU y_sc0m0] \u [] eta_sc0lU y_sc0m0;
                        } in 
                          GHC.Base.liftA2
                              $dApplicative_sc0lV GHC.Types.: sat_sc0m2 sat_sc0m3;
                  };
        } in  go_sc0lX;

Data.Traversable.$fTraversable[]_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a. GHC.Base.Monad m => [m a] -> m [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0m4]
        let {
          $dApplicative_sc0m5 [Dmd=<L,U(A,1*C1(U),A,C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative m_abW0J
          [LclId] =
              [$dMonad_sc0m4] \u [] GHC.Base.$p1Monad $dMonad_sc0m4; } in
        let {
          z_sc0m6 [Occ=OnceL] :: m_abW0J [a_abW0K]
          [LclId] =
              [$dApplicative_sc0m5] \u []
                  GHC.Base.pure $dApplicative_sc0m5 GHC.Types.[]; } in
        let {
          go_sc0m7 [Occ=LoopBreaker]
            :: [m_abW0J a_abW0K] -> m_abW0J [a_abW0K]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [$dApplicative_sc0m5 z_sc0m6 go_sc0m7] \r [ds_sc0m8]
                  case ds_sc0m8 of {
                    [] -> z_sc0m6;
                    : y_sc0ma [Occ=Once] ys_sc0mb [Occ=Once] ->
                        let {
                          sat_sc0mc [Occ=Once] :: m_abW0J [a_abW0K]
                          [LclId] =
                              [go_sc0m7 ys_sc0mb] \u [] go_sc0m7 ys_sc0mb;
                        } in 
                          GHC.Base.liftA2 $dApplicative_sc0m5 GHC.Types.: y_sc0ma sat_sc0mc;
                  };
        } in  go_sc0m7;

Data.Traversable.$fTraversable[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable []
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Base.$fFunctor[]
                                                   Data.Foldable.$fFoldable[]
                                                   Data.Traversable.$fTraversable[]_$ctraverse
                                                   Data.Traversable.$fTraversable[]_$csequenceA
                                                   Data.Traversable.$fTraversable[]_$cmapM
                                                   Data.Traversable.$fTraversable[]_$csequence];

Data.Traversable.$fTraversableZipList1 :: forall b. [b] -> [b]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sc0md] v_sc0md;

Data.Traversable.$fTraversableZipList_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Control.Applicative.ZipList a
     -> f (Control.Applicative.ZipList b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A)><L,C(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0me eta_sc0mf eta1_sc0mg]
        let {
          sat_sc0mq [Occ=Once] :: f_abVMK [b_abVMM]
          [LclId] =
              [$dApplicative_sc0me eta_sc0mf eta1_sc0mg] \u []
                  let {
                    z_sc0mi [Occ=OnceL] :: f_abVMK [b_abVMM]
                    [LclId] =
                        [$dApplicative_sc0me] \u []
                            GHC.Base.pure $dApplicative_sc0me GHC.Types.[]; } in
                  let {
                    go_sc0mj [Occ=LoopBreaker] :: [a_abVML] -> f_abVMK [b_abVMM]
                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                        sat-only [$dApplicative_sc0me
                                  eta_sc0mf
                                  z_sc0mi
                                  go_sc0mj] \r [ds_sc0mk]
                            case ds_sc0mk of {
                              [] -> z_sc0mi;
                              : y_sc0mm [Occ=Once] ys_sc0mn [Occ=Once] ->
                                  let {
                                    sat_sc0mp [Occ=Once] :: f_abVMK [b_abVMM]
                                    [LclId] =
                                        [go_sc0mj ys_sc0mn] \u [] go_sc0mj ys_sc0mn; } in
                                  let {
                                    sat_sc0mo [Occ=Once] :: f_abVMK b_abVMM
                                    [LclId] =
                                        [eta_sc0mf y_sc0mm] \u [] eta_sc0mf y_sc0mm;
                                  } in 
                                    GHC.Base.liftA2
                                        $dApplicative_sc0me GHC.Types.: sat_sc0mo sat_sc0mp;
                            };
                  } in  go_sc0mj eta1_sc0mg;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0me of sat_sc0mh {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sc0mh Data.Traversable.$fTraversableZipList1 sat_sc0mq;
          };

Data.Traversable.$fTraversableZipList_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Control.Applicative.ZipList (f a)
     -> f (Control.Applicative.ZipList a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0mr eta_B1]
        Data.Traversable.$fTraversableZipList_$ctraverse
            $dApplicative_sc0mr GHC.Base.id eta_B1;

Data.Traversable.$fTraversableZipList_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Control.Applicative.ZipList a
     -> m (Control.Applicative.ZipList b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0ms eta_sc0mt eta1_sc0mu]
        case GHC.Base.$p1Monad $dMonad_sc0ms of sat_sc0mv {
          __DEFAULT ->
              Data.Traversable.$fTraversableZipList_$ctraverse
                  sat_sc0mv eta_sc0mt eta1_sc0mu;
        };

Data.Traversable.$fTraversableZipList_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Control.Applicative.ZipList (m a)
     -> m (Control.Applicative.ZipList a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0mw eta_sc0mx]
        case GHC.Base.$p1Monad $dMonad_sc0mw of sat_sc0my {
          __DEFAULT ->
              Data.Traversable.$fTraversableZipList_$ctraverse
                  sat_sc0my GHC.Base.id eta_sc0mx;
        };

Data.Traversable.$fTraversableZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Control.Applicative.ZipList
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Control.Applicative.$fFunctorZipList
                                                   Control.Applicative.$fFoldableZipList
                                                   Data.Traversable.$fTraversableZipList_$ctraverse
                                                   Data.Traversable.$fTraversableZipList_$csequenceA
                                                   Data.Traversable.$fTraversableZipList_$cmapM
                                                   Data.Traversable.$fTraversableZipList_$csequence];

Data.Traversable.$fTraversableArray_$ctraverse
  :: forall i.
     GHC.Arr.Ix i =>
     forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Arr.Array i a -> f (GHC.Arr.Array i b)
[GblId,
 Arity=4,
 Str=<L,U(A,A,A,A,A,C(U(U)),A)><S(S(C(C(S))L)LLLLL),U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A)><L,C(U)><L,U(U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIx_sc0mz $dApplicative_sc0mA eta_sc0mB eta1_sc0mC]
        let {
          sat_sc0mX [Occ=Once] :: f_abVVc [b_abVVe]
          [LclId] =
              [$dApplicative_sc0mA eta_sc0mB eta1_sc0mC] \u []
                  case eta1_sc0mC of {
                    GHC.Arr.Array _ [Occ=Dead]
                                  _ [Occ=Dead]
                                  dt_sc0mJ [Occ=Once]
                                  ds2_sc0mK [Occ=OnceL] ->
                        case -# [dt_sc0mJ 1#] of y_sc0mL [Dmd=<S,U>] {
                          __DEFAULT ->
                              let {
                                n_sc0mM [Occ=OnceL*] :: f_abVVc [b_abVVe]
                                [LclId] =
                                    [$dApplicative_sc0mA] \u []
                                        GHC.Base.pure $dApplicative_sc0mA GHC.Types.[];
                              } in 
                                case ># [0# y_sc0mL] of {
                                  __DEFAULT ->
                                      let {
                                        go_sc0mO [Occ=LoopBreaker]
                                          :: GHC.Prim.Int# -> f_abVVc [b_abVVe]
                                        [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                                            sat-only [$dApplicative_sc0mA
                                                      eta_sc0mB
                                                      ds2_sc0mK
                                                      y_sc0mL
                                                      n_sc0mM
                                                      go_sc0mO] \r [x_sc0mP]
                                                let {
                                                  sat_sc0mW [Occ=Once] :: f_abVVc [b_abVVe]
                                                  [LclId] =
                                                      [y_sc0mL n_sc0mM go_sc0mO x_sc0mP] \u []
                                                          case ==# [x_sc0mP y_sc0mL] of {
                                                            __DEFAULT ->
                                                                case +# [x_sc0mP 1#] of sat_sc0mV {
                                                                  __DEFAULT -> go_sc0mO sat_sc0mV;
                                                                };
                                                            1# -> n_sc0mM;
                                                          }; } in
                                                let {
                                                  sat_sc0mT [Occ=Once] :: f_abVVc b_abVVe
                                                  [LclId] =
                                                      [eta_sc0mB ds2_sc0mK x_sc0mP] \u []
                                                          let {
                                                            sat_sc0mS [Occ=Once] :: a_abVVd
                                                            [LclId] =
                                                                [ds2_sc0mK x_sc0mP] \u []
                                                                    case
                                                                        indexArray# [ds2_sc0mK
                                                                                     x_sc0mP]
                                                                    of
                                                                    { Unit# ipv_sc0mR [Occ=Once] ->
                                                                          ipv_sc0mR;
                                                                    };
                                                          } in  eta_sc0mB sat_sc0mS;
                                                } in 
                                                  GHC.Base.liftA2
                                                      $dApplicative_sc0mA
                                                      GHC.Types.:
                                                      sat_sc0mT
                                                      sat_sc0mW;
                                      } in  go_sc0mO 0#;
                                  1# -> n_sc0mM;
                                };
                        };
                  }; } in
        let {
          sat_sc0mE [Occ=OnceL] :: (i_abVUZ, i_abVUZ)
          [LclId] =
              [eta1_sc0mC] \u [] GHC.Arr.bounds eta1_sc0mC; } in
        let {
          sat_sc0mF [Occ=Once] :: [b_abVVe] -> GHC.Arr.Array i_abVUZ b_abVVe
          [LclId] =
              [$dIx_sc0mz sat_sc0mE] \r [eta_B1]
                  GHC.Arr.listArray $dIx_sc0mz sat_sc0mE eta_B1;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0mA of sat_sc0mD {
            __DEFAULT -> GHC.Base.fmap sat_sc0mD sat_sc0mF sat_sc0mX;
          };

Data.Traversable.$fTraversableArray_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall i.
     GHC.Arr.Ix i =>
     forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Arr.Array i (f a) -> f (GHC.Arr.Array i a)
[GblId,
 Arity=3,
 Str=<L,U(A,A,A,A,A,C(U(U)),A)><L,U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIx_sc0mY $dApplicative_sc0mZ eta_B1]
        Data.Traversable.$fTraversableArray_$ctraverse
            $dIx_sc0mY $dApplicative_sc0mZ GHC.Base.id eta_B1;

Data.Traversable.$fTraversableArray_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall i.
     GHC.Arr.Ix i =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Arr.Array i a -> m (GHC.Arr.Array i b)
[GblId,
 Arity=4,
 Str=<L,U(A,A,A,A,A,C(U(U)),A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><L,U(U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIx_sc0n0 $dMonad_sc0n1 eta_sc0n2 eta1_sc0n3]
        case GHC.Base.$p1Monad $dMonad_sc0n1 of sat_sc0n4 {
          __DEFAULT ->
              Data.Traversable.$fTraversableArray_$ctraverse
                  $dIx_sc0n0 sat_sc0n4 eta_sc0n2 eta1_sc0n3;
        };

Data.Traversable.$fTraversableArray_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall i.
     GHC.Arr.Ix i =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Arr.Array i (m a) -> m (GHC.Arr.Array i a)
[GblId,
 Arity=3,
 Str=<L,U(A,A,A,A,A,C(U(U)),A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,U(U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIx_sc0n5 $dMonad_sc0n6 eta_sc0n7]
        case GHC.Base.$p1Monad $dMonad_sc0n6 of sat_sc0n8 {
          __DEFAULT ->
              Data.Traversable.$fTraversableArray_$ctraverse
                  $dIx_sc0n5 sat_sc0n8 GHC.Base.id eta_sc0n7;
        };

Data.Traversable.$fTraversableArray [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i.
     GHC.Arr.Ix i =>
     Data.Traversable.Traversable (GHC.Arr.Array i)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,A,A,C(U(U)),A)>m] =
    [] \r [$dIx_sc0n9]
        let {
          sat_sc0nd [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               GHC.Arr.Array i_abVUZ (m a) -> m (GHC.Arr.Array i_abVUZ a)
          [LclId] =
              [$dIx_sc0n9] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableArray_$csequence
                      $dIx_sc0n9 eta_B2 eta_B1; } in
        let {
          sat_sc0nc [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> GHC.Arr.Array i_abVUZ a -> m (GHC.Arr.Array i_abVUZ b)
          [LclId] =
              [$dIx_sc0n9] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableArray_$cmapM
                      $dIx_sc0n9 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sc0nb [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               GHC.Arr.Array i_abVUZ (f a) -> f (GHC.Arr.Array i_abVUZ a)
          [LclId] =
              [$dIx_sc0n9] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableArray_$csequenceA
                      $dIx_sc0n9 eta_B2 eta_B1; } in
        let {
          sat_sc0na [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> GHC.Arr.Array i_abVUZ a -> f (GHC.Arr.Array i_abVUZ b)
          [LclId] =
              [$dIx_sc0n9] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableArray_$ctraverse
                      $dIx_sc0n9 eta_B3 eta_B2 eta_B1;
        } in 
          Data.Traversable.C:Traversable [GHC.Arr.$fFunctorArray
                                          Data.Foldable.$fFoldableArray
                                          sat_sc0na
                                          sat_sc0nb
                                          sat_sc0nc
                                          sat_sc0nd];

Data.Traversable.$fTraversableNonEmpty_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Base.NonEmpty a -> f (GHC.Base.NonEmpty b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),U(A,1*C1(U),A,C(C1(C1(U))),A,A)><L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0ne f1_sc0nf ds_sc0ng]
        let {
          sat_sc0nx [Occ=Once] :: f_abVYD [b_abVYF]
          [LclId] =
              [$dApplicative_sc0ne f1_sc0nf ds_sc0ng] \u []
                  case ds_sc0ng of {
                    GHC.Base.:| _ [Occ=Dead] as_sc0no [Occ=Once] ->
                        let {
                          z_sc0np [Occ=OnceL] :: f_abVYD [b_abVYF]
                          [LclId] =
                              [$dApplicative_sc0ne] \u []
                                  GHC.Base.pure $dApplicative_sc0ne GHC.Types.[]; } in
                        let {
                          go_sc0nq [Occ=LoopBreaker] :: [a_abVYE] -> f_abVYD [b_abVYF]
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [$dApplicative_sc0ne
                                        f1_sc0nf
                                        z_sc0np
                                        go_sc0nq] \r [ds1_sc0nr]
                                  case ds1_sc0nr of {
                                    [] -> z_sc0np;
                                    : y_sc0nt [Occ=Once] ys_sc0nu [Occ=Once] ->
                                        let {
                                          sat_sc0nw [Occ=Once] :: f_abVYD [b_abVYF]
                                          [LclId] =
                                              [go_sc0nq ys_sc0nu] \u [] go_sc0nq ys_sc0nu; } in
                                        let {
                                          sat_sc0nv [Occ=Once] :: f_abVYD b_abVYF
                                          [LclId] =
                                              [f1_sc0nf y_sc0nt] \u [] f1_sc0nf y_sc0nt;
                                        } in 
                                          GHC.Base.liftA2
                                              $dApplicative_sc0ne GHC.Types.: sat_sc0nv sat_sc0nw;
                                  };
                        } in  go_sc0nq as_sc0no;
                  }; } in
        let {
          sat_sc0nl [Occ=Once] :: f_abVYD b_abVYF
          [LclId] =
              [f1_sc0nf ds_sc0ng] \u []
                  let {
                    sat_sc0nk [Occ=Once] :: a_abVYE
                    [LclId] =
                        [ds_sc0ng] \u []
                            case ds_sc0ng of {
                              GHC.Base.:| a1_sc0ni [Occ=Once] _ [Occ=Dead] -> a1_sc0ni;
                            };
                  } in  f1_sc0nf sat_sc0nk;
        } in 
          GHC.Base.liftA2
              $dApplicative_sc0ne GHC.Base.:| sat_sc0nl sat_sc0nx;

Data.Traversable.$fTraversableNonEmpty_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Base.NonEmpty (f a) -> f (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,C(U),A,C(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0ny eta_B1]
        Data.Traversable.$fTraversableNonEmpty_$ctraverse
            $dApplicative_sc0ny GHC.Base.id eta_B1;

Data.Traversable.$fTraversableNonEmpty_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Base.NonEmpty a -> m (GHC.Base.NonEmpty b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(A,1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0nz eta_sc0nA eta1_sc0nB]
        case GHC.Base.$p1Monad $dMonad_sc0nz of sat_sc0nC {
          __DEFAULT ->
              Data.Traversable.$fTraversableNonEmpty_$ctraverse
                  sat_sc0nC eta_sc0nA eta1_sc0nB;
        };

Data.Traversable.$fTraversableNonEmpty_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Base.NonEmpty (m a) -> m (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(A,1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0nD eta_sc0nE]
        case GHC.Base.$p1Monad $dMonad_sc0nD of sat_sc0nF {
          __DEFAULT ->
              Data.Traversable.$fTraversableNonEmpty_$ctraverse
                  sat_sc0nF GHC.Base.id eta_sc0nE;
        };

Data.Traversable.$fTraversableNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable GHC.Base.NonEmpty
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Base.$fFunctorNonEmpty
                                                   Data.Foldable.$fFoldableNonEmpty
                                                   Data.Traversable.$fTraversableNonEmpty_$ctraverse
                                                   Data.Traversable.$fTraversableNonEmpty_$csequenceA
                                                   Data.Traversable.$fTraversableNonEmpty_$cmapM
                                                   Data.Traversable.$fTraversableNonEmpty_$csequence];

Data.Traversable.$fTraversableMaybe_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Base.Maybe (f a) -> f (GHC.Base.Maybe a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0nG eta_sc0nH]
        case eta_sc0nH of {
          GHC.Base.Nothing ->
              GHC.Base.pure $dApplicative_sc0nG GHC.Base.Nothing;
          GHC.Base.Just x_sc0nJ [Occ=Once] ->
              case GHC.Base.$p1Applicative $dApplicative_sc0nG of sat_sc0nK {
                __DEFAULT -> GHC.Base.fmap sat_sc0nK GHC.Base.Just x_sc0nJ;
              };
        };

Data.Traversable.$fTraversableMaybe_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Base.Maybe a -> m (GHC.Base.Maybe b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0nL eta_sc0nM eta1_sc0nN]
        case GHC.Base.$p1Monad $dMonad_sc0nL of sat_sc0nO {
          __DEFAULT ->
              Data.Traversable.$fTraversableFirst_$ctraverse
                  sat_sc0nO eta_sc0nM eta1_sc0nN;
        };

Data.Traversable.$fTraversableMaybe_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Base.Maybe (m a) -> m (GHC.Base.Maybe a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0nP eta_sc0nQ]
        case eta_sc0nQ of {
          GHC.Base.Nothing ->
              case GHC.Base.$p1Monad $dMonad_sc0nP of sat_sc0nS {
                __DEFAULT -> GHC.Base.pure sat_sc0nS GHC.Base.Nothing;
              };
          GHC.Base.Just x_sc0nT [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0nP of sat_sc0nU {
                __DEFAULT ->
                    case GHC.Base.$p1Applicative sat_sc0nU of sat_sc0nV {
                      __DEFAULT -> GHC.Base.fmap sat_sc0nV GHC.Base.Just x_sc0nT;
                    };
              };
        };

Data.Traversable.$fTraversableMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable GHC.Base.Maybe
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Base.$fFunctorMaybe
                                                   Data.Foldable.$fFoldableMaybe
                                                   Data.Traversable.$fTraversableFirst_$ctraverse
                                                   Data.Traversable.$fTraversableMaybe_$csequenceA
                                                   Data.Traversable.$fTraversableMaybe_$cmapM
                                                   Data.Traversable.$fTraversableMaybe_$csequence];

Data.Traversable.$fTraversableFirst1
  :: forall b. GHC.Base.Maybe b -> GHC.Base.Maybe b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sc0nW] v_sc0nW;

Data.Traversable.$fTraversableLast_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Monoid.Last a -> f (Data.Monoid.Last b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0nX eta_sc0nY eta1_sc0nZ]
        let {
          sat_sc0o1 [Occ=Once] :: f_abVNQ (GHC.Base.Maybe b_abVNS)
          [LclId] =
              [$dApplicative_sc0nX eta_sc0nY eta1_sc0nZ] \u []
                  Data.Traversable.$fTraversableFirst_$ctraverse
                      $dApplicative_sc0nX eta_sc0nY eta1_sc0nZ;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0nX of sat_sc0o0 {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sc0o0 Data.Traversable.$fTraversableFirst1 sat_sc0o1;
          };

Data.Traversable.$fTraversableLast_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Monoid.Last (f a) -> f (Data.Monoid.Last a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0o2 eta_sc0o3]
        let {
          sat_sc0o8 [Occ=Once] :: f_abVOa (GHC.Base.Maybe a_abVOb)
          [LclId] =
              [$dApplicative_sc0o2 eta_sc0o3] \u []
                  case eta_sc0o3 of {
                    GHC.Base.Nothing ->
                        GHC.Base.pure $dApplicative_sc0o2 GHC.Base.Nothing;
                    GHC.Base.Just x_sc0o6 [Occ=Once] ->
                        case GHC.Base.$p1Applicative $dApplicative_sc0o2 of sat_sc0o7 {
                          __DEFAULT -> GHC.Base.fmap sat_sc0o7 GHC.Base.Just x_sc0o6;
                        };
                  };
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0o2 of sat_sc0o4 {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sc0o4 Data.Traversable.$fTraversableFirst1 sat_sc0o8;
          };

Data.Traversable.$fTraversableLast_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Monoid.Last a -> m (Data.Monoid.Last b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(C(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0o9 eta_sc0oa eta1_sc0ob]
        case
            GHC.Base.$p1Monad $dMonad_sc0o9
        of
        $dApplicative_sc0oc [Dmd=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              let {
                sat_sc0oe [Occ=Once] :: m_abVOm (GHC.Base.Maybe b_abVOo)
                [LclId] =
                    [eta_sc0oa eta1_sc0ob $dApplicative_sc0oc] \u []
                        Data.Traversable.$fTraversableFirst_$ctraverse
                            $dApplicative_sc0oc eta_sc0oa eta1_sc0ob;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0oc of sat_sc0od {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sc0od Data.Traversable.$fTraversableFirst1 sat_sc0oe;
                };
        };

Data.Traversable.$fTraversableLast_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Monoid.Last (m a) -> m (Data.Monoid.Last a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(C(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0of eta_sc0og]
        case
            GHC.Base.$p1Monad $dMonad_sc0of
        of
        $dApplicative_sc0oh [Dmd=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              let {
                sat_sc0om [Occ=Once] :: m_abVOA (GHC.Base.Maybe a_abVOB)
                [LclId] =
                    [eta_sc0og $dApplicative_sc0oh] \u []
                        case eta_sc0og of {
                          GHC.Base.Nothing ->
                              GHC.Base.pure $dApplicative_sc0oh GHC.Base.Nothing;
                          GHC.Base.Just x_sc0ok [Occ=Once] ->
                              case GHC.Base.$p1Applicative $dApplicative_sc0oh of sat_sc0ol {
                                __DEFAULT -> GHC.Base.fmap sat_sc0ol GHC.Base.Just x_sc0ok;
                              };
                        };
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0oh of sat_sc0oi {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sc0oi Data.Traversable.$fTraversableFirst1 sat_sc0om;
                };
        };

Data.Traversable.$fTraversableLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Monoid.Last
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Monoid.$fFunctorLast
                                                   Data.Foldable.$fFoldableLast
                                                   Data.Traversable.$fTraversableLast_$ctraverse
                                                   Data.Traversable.$fTraversableLast_$csequenceA
                                                   Data.Traversable.$fTraversableLast_$cmapM
                                                   Data.Traversable.$fTraversableLast_$csequence];

Data.Traversable.$fTraversableFirst_$ctraverse1
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Monoid.First a -> f (Data.Monoid.First b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0on eta_sc0oo eta1_sc0op]
        let {
          sat_sc0or [Occ=Once] :: f_abVOW (GHC.Base.Maybe b_abVOY)
          [LclId] =
              [$dApplicative_sc0on eta_sc0oo eta1_sc0op] \u []
                  Data.Traversable.$fTraversableFirst_$ctraverse
                      $dApplicative_sc0on eta_sc0oo eta1_sc0op;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0on of sat_sc0oq {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sc0oq Data.Traversable.$fTraversableFirst1 sat_sc0or;
          };

Data.Traversable.$fTraversableFirst_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Monoid.First (f a) -> f (Data.Monoid.First a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0os eta_sc0ot]
        let {
          sat_sc0oy [Occ=Once] :: f_abVPg (GHC.Base.Maybe a_abVPh)
          [LclId] =
              [$dApplicative_sc0os eta_sc0ot] \u []
                  case eta_sc0ot of {
                    GHC.Base.Nothing ->
                        GHC.Base.pure $dApplicative_sc0os GHC.Base.Nothing;
                    GHC.Base.Just x_sc0ow [Occ=Once] ->
                        case GHC.Base.$p1Applicative $dApplicative_sc0os of sat_sc0ox {
                          __DEFAULT -> GHC.Base.fmap sat_sc0ox GHC.Base.Just x_sc0ow;
                        };
                  };
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0os of sat_sc0ou {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sc0ou Data.Traversable.$fTraversableFirst1 sat_sc0oy;
          };

Data.Traversable.$fTraversableFirst_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Monoid.First a -> m (Data.Monoid.First b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(C(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0oz eta_sc0oA eta1_sc0oB]
        case
            GHC.Base.$p1Monad $dMonad_sc0oz
        of
        $dApplicative_sc0oC [Dmd=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              let {
                sat_sc0oE [Occ=Once] :: m_abVPs (GHC.Base.Maybe b_abVPu)
                [LclId] =
                    [eta_sc0oA eta1_sc0oB $dApplicative_sc0oC] \u []
                        Data.Traversable.$fTraversableFirst_$ctraverse
                            $dApplicative_sc0oC eta_sc0oA eta1_sc0oB;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0oC of sat_sc0oD {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sc0oD Data.Traversable.$fTraversableFirst1 sat_sc0oE;
                };
        };

Data.Traversable.$fTraversableFirst_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Monoid.First (m a) -> m (Data.Monoid.First a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(C(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0oF eta_sc0oG]
        case
            GHC.Base.$p1Monad $dMonad_sc0oF
        of
        $dApplicative_sc0oH [Dmd=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              let {
                sat_sc0oM [Occ=Once] :: m_abVPG (GHC.Base.Maybe a_abVPH)
                [LclId] =
                    [eta_sc0oG $dApplicative_sc0oH] \u []
                        case eta_sc0oG of {
                          GHC.Base.Nothing ->
                              GHC.Base.pure $dApplicative_sc0oH GHC.Base.Nothing;
                          GHC.Base.Just x_sc0oK [Occ=Once] ->
                              case GHC.Base.$p1Applicative $dApplicative_sc0oH of sat_sc0oL {
                                __DEFAULT -> GHC.Base.fmap sat_sc0oL GHC.Base.Just x_sc0oK;
                              };
                        };
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0oH of sat_sc0oI {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sc0oI Data.Traversable.$fTraversableFirst1 sat_sc0oM;
                };
        };

Data.Traversable.$fTraversableFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Monoid.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Monoid.$fFunctorFirst
                                                   Data.Foldable.$fFoldableFirst
                                                   Data.Traversable.$fTraversableFirst_$ctraverse1
                                                   Data.Traversable.$fTraversableFirst_$csequenceA
                                                   Data.Traversable.$fTraversableFirst_$cmapM
                                                   Data.Traversable.$fTraversableFirst_$csequence];

Data.Traversable.$dmtraverse [InlPrag=INLINE (sat-args=1)]
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> t a -> f (t b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*C1(C(U)),A),A,A,1*C1(C(U)),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0oN eta_sc0oO eta1_sc0oP]
        let {
          f1_sc0oQ [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_abVfw (f_abVtL b_abVtN) -> f_abVtL (t_abVfw b_abVtN)
          [LclId] =
              [$dTraversable_sc0oN eta_sc0oO] \u []
                  Data.Traversable.sequenceA $dTraversable_sc0oN eta_sc0oO; } in
        let {
          g_sc0oR [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_abVfw a_abVtM -> t_abVfw (f_abVtL b_abVtN)
          [LclId] =
              [$dTraversable_sc0oN eta1_sc0oP] \u []
                  case
                      Data.Traversable.$p1Traversable $dTraversable_sc0oN
                  of
                  sat_sc0oS
                  { __DEFAULT -> GHC.Base.fmap sat_sc0oS eta1_sc0oP;
                  }; } in
        let {
          sat_sc0oV [Occ=OnceT[0]]
            :: t_abVfw a_abVtM -> f_abVtL (t_abVfw b_abVtN)
          [LclId] =
              [f1_sc0oQ g_sc0oR] \r [x_sc0oT]
                  let {
                    sat_sc0oU [Occ=Once] :: t_abVfw (f_abVtL b_abVtN)
                    [LclId] =
                        [g_sc0oR x_sc0oT] \u [] g_sc0oR x_sc0oT;
                  } in  f1_sc0oQ sat_sc0oU;
        } in  sat_sc0oV;

Data.Traversable.for [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (f :: * -> *) a b.
     (Data.Traversable.Traversable t, GHC.Base.Applicative f) =>
     t a -> (a -> f b) -> f (t b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C(C1(U))),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0oW $dApplicative_sc0oX]
        let {
          f1_sc0oY [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: (a_abVtu -> f_abVtt b_abVtv)
               -> t_abVts a_abVtu -> f_abVtt (t_abVts b_abVtv)
          [LclId] =
              [$dTraversable_sc0oW $dApplicative_sc0oX] \u []
                  Data.Traversable.traverse
                      $dTraversable_sc0oW $dApplicative_sc0oX; } in
        let {
          sat_sc0p1 [Occ=OnceT[0]]
            :: t_abVts a_abVtu
               -> (a_abVtu -> f_abVtt b_abVtv) -> f_abVtt (t_abVts b_abVtv)
          [LclId] =
              [f1_sc0oY] \r [x_sc0oZ y_sc0p0] f1_sc0oY y_sc0p0 x_sc0oZ;
        } in  sat_sc0p1;

Data.Traversable.forM [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (m :: * -> *) a b.
     (Data.Traversable.Traversable t, GHC.Base.Monad m) =>
     t a -> (a -> m b) -> m (t b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,1*C1(C(C1(U))),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0p2 $dMonad_sc0p3]
        let {
          f_sc0p4 [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: (a_abVtd -> m_abVtc b_abVte)
               -> t_abVtb a_abVtd -> m_abVtc (t_abVtb b_abVte)
          [LclId] =
              [$dTraversable_sc0p2 $dMonad_sc0p3] \u []
                  Data.Traversable.mapM $dTraversable_sc0p2 $dMonad_sc0p3; } in
        let {
          sat_sc0p7 [Occ=OnceT[0]]
            :: t_abVtb a_abVtd
               -> (a_abVtd -> m_abVtc b_abVte) -> m_abVtc (t_abVtb b_abVte)
          [LclId] =
              [f_sc0p4] \r [x_sc0p5 y_sc0p6] f_sc0p4 y_sc0p6 x_sc0p5;
        } in  sat_sc0p7;

Data.Traversable.mapAccumL
  :: forall (t :: * -> *) a b c.
     Data.Traversable.Traversable t =>
     (a -> b -> (a, c)) -> a -> t b -> (a, t c)
[GblId,
 Arity=4,
 Str=<S(LLC(C(C(S)))LLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0p8 f_sc0p9 s_sc0pa t1_sc0pb]
        let {
          sat_sc0pe [Occ=Once]
            :: b_abVsM -> Data.Functor.Utils.StateL a_abVsL c_abVsN
          [LclId] =
              [f_sc0p9] \r [x_sc0pc y_sc0pd] f_sc0p9 y_sc0pd x_sc0pc;
        } in 
          Data.Traversable.traverse
              $dTraversable_sc0p8
              Data.Functor.Utils.$fApplicativeStateL
              sat_sc0pe
              t1_sc0pb
              s_sc0pa;

Data.Traversable.mapAccumR
  :: forall (t :: * -> *) a b c.
     Data.Traversable.Traversable t =>
     (a -> b -> (a, c)) -> a -> t b -> (a, t c)
[GblId,
 Arity=4,
 Str=<S(LLC(C(C(S)))LLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0pf f_sc0pg s_sc0ph t1_sc0pi]
        let {
          sat_sc0pl [Occ=Once]
            :: b_abVsl -> Data.Functor.Utils.StateR a_abVsk c_abVsm
          [LclId] =
              [f_sc0pg] \r [x_sc0pj y_sc0pk] f_sc0pg y_sc0pk x_sc0pj;
        } in 
          Data.Traversable.traverse
              $dTraversable_sc0pf
              Data.Functor.Utils.$fApplicativeStateR
              sat_sc0pl
              t1_sc0pi
              s_sc0ph;

fmapDefault1_rbWTV
  :: forall (t :: * -> *) a b.
     Data.Traversable.Traversable t =>
     (a -> Data.Functor.Identity.Identity b)
     -> t a -> Data.Functor.Identity.Identity (t b)
[GblId,
 Arity=1,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)>,
 Unf=OtherCon []] =
    sat-only [] \r [$dTraversable_sc0pm]
        Data.Traversable.traverse
            $dTraversable_sc0pm Data.Functor.Identity.$fApplicativeIdentity;

Data.Traversable.fmapDefault [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) a b.
     Data.Traversable.Traversable t =>
     (a -> b) -> t a -> t b
[GblId,
 Arity=1,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] fmapDefault1_rbWTV eta_B1;

foldMapDefault1_rbWTW
  :: forall (t :: * -> *) m a.
     (Data.Traversable.Traversable t, GHC.Base.Monoid m) =>
     (a -> Data.Functor.Const.Const m ())
     -> t a -> Data.Functor.Const.Const m (t ())
[GblId,
 Arity=2,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)><L,U(A,U,U,A)>,
 Unf=OtherCon []] =
    sat-only [] \r [$dTraversable_sc0pn $dMonoid_sc0po]
        let {
          sat_sc0pp [Occ=Once]
            :: GHC.Base.Applicative (Data.Functor.Const.Const m_abVrr)
          [LclId] =
              [$dMonoid_sc0po] \u []
                  Data.Functor.Const.$fApplicativeConst $dMonoid_sc0po;
        } in  Data.Traversable.traverse $dTraversable_sc0pn sat_sc0pp;

Data.Traversable.foldMapDefault [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) m a.
     (Data.Traversable.Traversable t, GHC.Base.Monoid m) =>
     (a -> m) -> t a -> m
[GblId,
 Arity=2,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)><L,U(A,U,U,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] foldMapDefault1_rbWTW eta_B2 eta_B1;

Data.Traversable.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Traversable.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Traversable.$trModule4];

Data.Traversable.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Traversable"#;

Data.Traversable.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Traversable.$trModule2];

Data.Traversable.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Traversable.$trModule3
                                     Data.Traversable.$trModule1];

$krep_rbWTX :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Traversable.$tcTraversable1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep_rbWTX];

Data.Traversable.$tcTraversable3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Traversable"#;

Data.Traversable.$tcTraversable2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Traversable.$tcTraversable3];

Data.Traversable.$tcTraversable :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9002450311536760373##
                                    4172295783860716183##
                                    Data.Traversable.$trModule
                                    Data.Traversable.$tcTraversable2
                                    0#
                                    Data.Traversable.$tcTraversable1];

Data.Traversable.C:Traversable
  :: forall (t :: * -> *).
     (GHC.Base.Functor t, Data.Foldable.Foldable t) =>
     (forall (f :: * -> *) a b.
      GHC.Base.Applicative f =>
      (a -> f b) -> t a -> f (t b))
     -> (forall (f :: * -> *) a.
         GHC.Base.Applicative f =>
         t (f a) -> f (t a))
     -> (forall (m :: * -> *) a b.
         GHC.Base.Monad m =>
         (a -> m b) -> t a -> m (t b))
     -> (forall (m :: * -> *) a. GHC.Base.Monad m => t (m a) -> m (t a))
     -> Data.Traversable.Traversable t
[GblId[DataCon],
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Traversable.C:Traversable [eta_B6
                                        eta_B5
                                        eta_B4
                                        eta_B3
                                        eta_B2
                                        eta_B1];


==================== STG syntax: ====================
2018-03-16 16:06:54.746231758 UTC

Data.Traversable.$p1Traversable
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     GHC.Base.Functor t
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLL),U(U,A,A,A,A,A)>] =
    [] \r [v_sc0bs]
        case v_sc0bs of {
          Data.Traversable.C:Traversable v_sc0bu [Occ=Once]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead] ->
              v_sc0bu;
        };

Data.Traversable.$p2Traversable
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     Data.Foldable.Foldable t
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLL),U(A,U,A,A,A,A)>] =
    [] \r [v_sc0bA]
        case v_sc0bA of {
          Data.Traversable.C:Traversable _ [Occ=Dead]
                                         v_sc0bD [Occ=Once]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead] ->
              v_sc0bD;
        };

Data.Traversable.traverse
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> t a -> f (t b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLL),U(A,A,U,A,A,A)>] =
    [] \r [v_sc0bI]
        case v_sc0bI of {
          Data.Traversable.C:Traversable _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         v_sc0bM [Occ=Once]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead] ->
              v_sc0bM;
        };

Data.Traversable.sequenceA
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     t (f a) -> f (t a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLL),U(A,A,A,U,A,A)>] =
    [] \r [v_sc0bQ]
        case v_sc0bQ of {
          Data.Traversable.C:Traversable _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         v_sc0bV [Occ=Once]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead] ->
              v_sc0bV;
        };

Data.Traversable.mapM
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> t a -> m (t b)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSL),U(A,A,A,A,U,A)>] =
    [] \r [v_sc0bY]
        case v_sc0bY of {
          Data.Traversable.C:Traversable _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         v_sc0c4 [Occ=Once]
                                         _ [Occ=Dead] ->
              v_sc0c4;
        };

Data.Traversable.sequence
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (m :: * -> *) a. GHC.Base.Monad m => t (m a) -> m (t a)
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLS),U(A,A,A,A,A,U)>] =
    [] \r [v_sc0c6]
        case v_sc0c6 of {
          Data.Traversable.C:Traversable _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         _ [Occ=Dead]
                                         v_sc0cd [Occ=Once] ->
              v_sc0cd;
        };

Data.Traversable.$fTraversableFirst_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Base.Maybe a -> f (GHC.Base.Maybe b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0ce eta_sc0cf eta1_sc0cg]
        case eta1_sc0cg of {
          GHC.Base.Nothing ->
              GHC.Base.pure $dApplicative_sc0ce GHC.Base.Nothing;
          GHC.Base.Just x_sc0ci [Occ=Once] ->
              let {
                sat_sc0ck [Occ=Once] :: f_abW15 b_abW17
                [LclId] =
                    [eta_sc0cf x_sc0ci] \u [] eta_sc0cf x_sc0ci;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0ce of sat_sc0cj {
                  __DEFAULT -> GHC.Base.fmap sat_sc0cj GHC.Base.Just sat_sc0ck;
                };
        };

Data.Traversable.$fTraversable[]_$ctraverse [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> [a] -> f [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*C1(U),A,C(C1(C1(U))),A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0cl f1_sc0cm]
        let {
          z_sc0cn [Occ=OnceL] :: f_abVZK [b_abVZM]
          [LclId] =
              [$dApplicative_sc0cl] \u []
                  GHC.Base.pure $dApplicative_sc0cl GHC.Types.[]; } in
        let {
          go_sc0co [Occ=LoopBreaker] :: [a_abVZL] -> f_abVZK [b_abVZM]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [$dApplicative_sc0cl f1_sc0cm z_sc0cn go_sc0co] \r [ds_sc0cp]
                  case ds_sc0cp of {
                    [] -> z_sc0cn;
                    : y_sc0cr [Occ=Once] ys_sc0cs [Occ=Once] ->
                        let {
                          sat_sc0cu [Occ=Once] :: f_abVZK [b_abVZM]
                          [LclId] =
                              [go_sc0co ys_sc0cs] \u [] go_sc0co ys_sc0cs; } in
                        let {
                          sat_sc0ct [Occ=Once] :: f_abVZK b_abVZM
                          [LclId] =
                              [f1_sc0cm y_sc0cr] \u [] f1_sc0cm y_sc0cr;
                        } in 
                          GHC.Base.liftA2
                              $dApplicative_sc0cl GHC.Types.: sat_sc0ct sat_sc0cu;
                  };
        } in  go_sc0co;

Data.Traversable.$fTraversableEither_$ctraverse
  :: forall a1 (f :: * -> *) a2 b.
     GHC.Base.Applicative f =>
     (a2 -> f b)
     -> Data.Either.Either a1 a2 -> f (Data.Either.Either a1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0cv eta_sc0cw eta1_sc0cx]
        case eta1_sc0cx of {
          Data.Either.Left x_sc0cz [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0cv wild_sc0cy;
          Data.Either.Right y_sc0cB [Occ=Once] ->
              let {
                sat_sc0cD [Occ=Once] :: f_abVXx b_abVXz
                [LclId] =
                    [eta_sc0cw y_sc0cB] \u [] eta_sc0cw y_sc0cB;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0cv of sat_sc0cC {
                  __DEFAULT -> GHC.Base.fmap sat_sc0cC Data.Either.Right sat_sc0cD;
                };
        };

Data.Traversable.$fTraversable(,)_$ctraverse
  :: forall a1 (f :: * -> *) a2 b.
     GHC.Base.Applicative f =>
     (a2 -> f b) -> (a1, a2) -> f (a1, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0cE eta_sc0cF eta1_sc0cG]
        case eta1_sc0cG of {
          (,) x_sc0cI [Occ=OnceL] y_sc0cJ [Occ=Once] ->
              let {
                sat_sc0cM [Occ=Once] :: f_abVWv b_abVWx
                [LclId] =
                    [eta_sc0cF y_sc0cJ] \u [] eta_sc0cF y_sc0cJ; } in
              let {
                sat_sc0cL [Occ=Once] :: b_abVWx -> (a_abVWj, b_abVWx)
                [LclId] =
                    [x_sc0cI] \r [eta_B1] (,) [x_sc0cI eta_B1];
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0cE of sat_sc0cK {
                  __DEFAULT -> GHC.Base.fmap sat_sc0cK sat_sc0cL sat_sc0cM;
                };
        };

Data.Traversable.$fTraversableProxy_$csequence [InlPrag=INLINE (sat-args=1)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Proxy.Proxy (m a) -> m (Data.Proxy.Proxy a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0cN eta_sc0cO]
        case GHC.Base.$p1Monad $dMonad_sc0cN of sat_sc0cP {
          __DEFAULT -> GHC.Base.pure sat_sc0cP Data.Proxy.Proxy;
        };

Data.Traversable.$fTraversableProxy_$cmapM [InlPrag=INLINE (sat-args=2)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Proxy.Proxy a -> m (Data.Proxy.Proxy b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0cQ eta_sc0cR eta1_sc0cS]
        case GHC.Base.$p1Monad $dMonad_sc0cQ of sat_sc0cT {
          __DEFAULT -> GHC.Base.pure sat_sc0cT Data.Proxy.Proxy;
        };

Data.Traversable.$fTraversableProxy_$csequenceA [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Proxy.Proxy (f a) -> f (Data.Proxy.Proxy a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0cU ds_sc0cV]
        GHC.Base.pure $dApplicative_sc0cU Data.Proxy.Proxy;

Data.Traversable.$fTraversableProxy_$ctraverse [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Proxy.Proxy a -> f (Data.Proxy.Proxy b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0cW eta_sc0cX ds_sc0cY]
        GHC.Base.pure $dApplicative_sc0cW Data.Proxy.Proxy;

Data.Traversable.$fTraversableProxy [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Proxy.Proxy
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Proxy.$fFunctorProxy
                                                   Data.Foldable.$fFoldableProxy
                                                   Data.Traversable.$fTraversableProxy_$ctraverse
                                                   Data.Traversable.$fTraversableProxy_$csequenceA
                                                   Data.Traversable.$fTraversableProxy_$cmapM
                                                   Data.Traversable.$fTraversableProxy_$csequence];

Data.Traversable.$fTraversableConst_$ctraverse
  :: forall m (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Functor.Const.Const m a -> f (Data.Functor.Const.Const m b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0cZ ds_sc0d0 ds1_sc0d1]
        GHC.Base.pure $dApplicative_sc0cZ ds1_sc0d1;

Data.Traversable.$fTraversableDual1 :: forall b. b -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sc0d2] v_sc0d2;

Data.Traversable.$fTraversableDual_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Semigroup.Internal.Dual a
     -> f (Data.Semigroup.Internal.Dual b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0d3 eta_sc0d4 eta1_sc0d5]
        let {
          sat_sc0d7 [Occ=Once] :: f_abVS2 b_abVS4
          [LclId] =
              [eta_sc0d4 eta1_sc0d5] \u [] eta_sc0d4 eta1_sc0d5;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0d3 of sat_sc0d6 {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sc0d6 Data.Traversable.$fTraversableDual1 sat_sc0d7;
          };

Data.Traversable.$fTraversableSum_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Semigroup.Internal.Sum a
     -> f (Data.Semigroup.Internal.Sum b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0d8 eta_sc0d9 eta1_sc0da]
        let {
          sat_sc0dc [Occ=Once] :: f_abVR2 b_abVR4
          [LclId] =
              [eta_sc0d9 eta1_sc0da] \u [] eta_sc0d9 eta1_sc0da;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0d8 of sat_sc0db {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sc0db Data.Traversable.$fTraversableDual1 sat_sc0dc;
          };

Data.Traversable.$fTraversableProduct_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Semigroup.Internal.Product a
     -> f (Data.Semigroup.Internal.Product b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0dd eta_sc0de eta1_sc0df]
        let {
          sat_sc0dh [Occ=Once] :: f_abVQ2 b_abVQ4
          [LclId] =
              [eta_sc0de eta1_sc0df] \u [] eta_sc0de eta1_sc0df;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0dd of sat_sc0dg {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sc0dg Data.Traversable.$fTraversableDual1 sat_sc0dh;
          };

Data.Traversable.$fTraversableU1_$csequence [InlPrag=INLINE (sat-args=1)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.U1 (m a) -> m (GHC.Generics.U1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0di eta_sc0dj]
        case GHC.Base.$p1Monad $dMonad_sc0di of sat_sc0dk {
          __DEFAULT -> GHC.Base.pure sat_sc0dk GHC.Generics.U1;
        };

Data.Traversable.$fTraversableU1_$cmapM [InlPrag=INLINE (sat-args=2)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Generics.U1 a -> m (GHC.Generics.U1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0dl eta_sc0dm eta1_sc0dn]
        case GHC.Base.$p1Monad $dMonad_sc0dl of sat_sc0do {
          __DEFAULT -> GHC.Base.pure sat_sc0do GHC.Generics.U1;
        };

Data.Traversable.$fTraversableU1_$csequenceA [InlPrag=INLINE (sat-args=1)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.U1 (f a) -> f (GHC.Generics.U1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0dp ds_sc0dq]
        GHC.Base.pure $dApplicative_sc0dp GHC.Generics.U1;

Data.Traversable.$fTraversableU1_$ctraverse [InlPrag=INLINE (sat-args=2)]
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Generics.U1 a -> f (GHC.Generics.U1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0dr eta_sc0ds ds_sc0dt]
        GHC.Base.pure $dApplicative_sc0dr GHC.Generics.U1;

Data.Traversable.$fTraversableU1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable GHC.Generics.U1
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorU1
                                                   Data.Foldable.$fFoldableU1
                                                   Data.Traversable.$fTraversableU1_$ctraverse
                                                   Data.Traversable.$fTraversableU1_$csequenceA
                                                   Data.Traversable.$fTraversableU1_$cmapM
                                                   Data.Traversable.$fTraversableU1_$csequence];

Data.Traversable.$fTraversableIdentity_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Data.Functor.Identity.Identity a
     -> f (Data.Functor.Identity.Identity b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0du eta_sc0dv eta1_sc0dw]
        let {
          sat_sc0dy [Occ=Once] :: f_abVKI b_abVKK
          [LclId] =
              [eta_sc0dv eta1_sc0dw] \u [] eta_sc0dv eta1_sc0dw;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0du of sat_sc0dx {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sc0dx Data.Traversable.$fTraversableDual1 sat_sc0dy;
          };

Data.Traversable.$fTraversableV1_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Generics.V1 a -> f (GHC.Generics.V1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0dz ds_sc0dA z_sc0dB]
        GHC.Base.pure $dApplicative_sc0dz z_sc0dB;

Data.Traversable.$fTraversablePar1_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Generics.Par1 a -> f (GHC.Generics.Par1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0dC eta_sc0dD eta1_sc0dE]
        let {
          sat_sc0dG [Occ=Once] :: f_abVIH b_abVIJ
          [LclId] =
              [eta_sc0dD eta1_sc0dE] \u [] eta_sc0dD eta1_sc0dE;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0dC of sat_sc0dF {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sc0dF Data.Traversable.$fTraversableDual1 sat_sc0dG;
          };

Data.Traversable.$fTraversableM2
  :: forall (f :: * -> *) b. f b -> f b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [b1_sc0dH] b1_sc0dH;

Data.Traversable.$fTraversableRec1_$ctraverse
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b) -> GHC.Generics.Rec1 f a -> f1 (GHC.Generics.Rec1 f b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0dI
           $dApplicative_sc0dJ
           eta_sc0dK
           eta1_sc0dL]
        let {
          sat_sc0dN [Occ=Once] :: f1_abVHz (f_abVHm b_abVHB)
          [LclId] =
              [$dTraversable_sc0dI
               $dApplicative_sc0dJ
               eta_sc0dK
               eta1_sc0dL] \u []
                  Data.Traversable.traverse
                      $dTraversable_sc0dI $dApplicative_sc0dJ eta_sc0dK eta1_sc0dL;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0dJ of sat_sc0dM {
            __DEFAULT ->
                GHC.Base.fmap sat_sc0dM Data.Traversable.$fTraversableM2 sat_sc0dN;
          };

Data.Traversable.$fTraversableRec1_$cp2Traversable
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     Data.Foldable.Foldable (GHC.Generics.Rec1 f)
[GblId,
 Arity=1,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0dO]
        let {
          sat_sc0dP [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_abVHm
          [LclId] =
              [$dTraversable_sc0dO] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sc0dO;
        } in  Data.Foldable.$fFoldableRec1 sat_sc0dP;

Data.Traversable.$fTraversableRec1_$cp1Traversable
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     GHC.Base.Functor (GHC.Generics.Rec1 f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0dQ]
        let {
          sat_sc0dR [Occ=Once, Dmd=<L,U(1*U,1*U)>]
            :: GHC.Base.Functor f_abVHm
          [LclId] =
              [$dTraversable_sc0dQ] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sc0dQ;
        } in  GHC.Generics.$fFunctorRec1 sat_sc0dR;

Data.Traversable.$fTraversableK1_$ctraverse
  :: forall i c (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Generics.K1 i c a -> f (GHC.Generics.K1 i c b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0dS ds_sc0dT z_sc0dU]
        GHC.Base.pure $dApplicative_sc0dS z_sc0dU;

Data.Traversable.$fTraversableM1_$ctraverse
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> GHC.Generics.M1 i c f a -> f1 (GHC.Generics.M1 i c f b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0dV
           $dApplicative_sc0dW
           eta_sc0dX
           eta1_sc0dY]
        let {
          sat_sc0e0 [Occ=Once] :: f1_abVFk (f_abVF5 b_abVFm)
          [LclId] =
              [$dTraversable_sc0dV
               $dApplicative_sc0dW
               eta_sc0dX
               eta1_sc0dY] \u []
                  Data.Traversable.traverse
                      $dTraversable_sc0dV $dApplicative_sc0dW eta_sc0dX eta1_sc0dY;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0dW of sat_sc0dZ {
            __DEFAULT ->
                GHC.Base.fmap sat_sc0dZ Data.Traversable.$fTraversableM2 sat_sc0e0;
          };

Data.Traversable.$fTraversableM1_$cp2Traversable
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     Data.Foldable.Foldable (GHC.Generics.M1 i c f)
[GblId,
 Arity=1,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0e1]
        let {
          sat_sc0e2 [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_abVF5
          [LclId] =
              [$dTraversable_sc0e1] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sc0e1;
        } in  Data.Foldable.$fFoldableM1 sat_sc0e2;

Data.Traversable.$fTraversableM1_$cp1Traversable
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     GHC.Base.Functor (GHC.Generics.M1 i c f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0e3]
        let {
          sat_sc0e4 [Occ=Once, Dmd=<L,U(1*U,1*U)>]
            :: GHC.Base.Functor f_abVF5
          [LclId] =
              [$dTraversable_sc0e3] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sc0e3;
        } in  GHC.Generics.$fFunctorM1 sat_sc0e4;

Data.Traversable.$fTraversable:+:_$ctraverse
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> (GHC.Generics.:+:) f g a -> f1 ((GHC.Generics.:+:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0e5
           $dTraversable1_sc0e6
           $dApplicative_sc0e7
           eta_sc0e8
           eta1_sc0e9]
        case eta1_sc0e9 of {
          GHC.Generics.L1 a1_sc0eb [Occ=Once] ->
              let {
                sat_sc0ed [Occ=Once] :: f1_abVDT (f_abVDE b_abVDV)
                [LclId] =
                    [$dTraversable_sc0e5 $dApplicative_sc0e7 eta_sc0e8 a1_sc0eb] \u []
                        Data.Traversable.traverse
                            $dTraversable_sc0e5 $dApplicative_sc0e7 eta_sc0e8 a1_sc0eb;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0e7 of sat_sc0ec {
                  __DEFAULT -> GHC.Base.fmap sat_sc0ec GHC.Generics.L1 sat_sc0ed;
                };
          GHC.Generics.R1 a1_sc0ee [Occ=Once] ->
              let {
                sat_sc0eg [Occ=Once] :: f1_abVDT (g_abVDF b_abVDV)
                [LclId] =
                    [$dTraversable1_sc0e6 $dApplicative_sc0e7 eta_sc0e8 a1_sc0ee] \u []
                        Data.Traversable.traverse
                            $dTraversable1_sc0e6 $dApplicative_sc0e7 eta_sc0e8 a1_sc0ee;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0e7 of sat_sc0ef {
                  __DEFAULT -> GHC.Base.fmap sat_sc0ef GHC.Generics.R1 sat_sc0eg;
                };
        };

Data.Traversable.$fTraversable:+:_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:+: g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0eh $dTraversable1_sc0ei]
        let {
          sat_sc0ek [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_abVDF
          [LclId] =
              [$dTraversable1_sc0ei] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sc0ei; } in
        let {
          sat_sc0ej [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_abVDE
          [LclId] =
              [$dTraversable_sc0eh] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sc0eh;
        } in  Data.Foldable.$fFoldable:+: sat_sc0ej sat_sc0ek;

Data.Traversable.$fTraversable:+:_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (f GHC.Generics.:+: g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),C(C1(U))),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),C(C1(U))),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0el $dTraversable1_sc0em]
        let {
          sat_sc0eo [Occ=Once, Dmd=<L,U(C(C1(U)),C(C1(U)))>]
            :: GHC.Base.Functor g_abVDF
          [LclId] =
              [$dTraversable1_sc0em] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sc0em; } in
        let {
          sat_sc0en [Occ=Once, Dmd=<L,U(C(C1(U)),C(C1(U)))>]
            :: GHC.Base.Functor f_abVDE
          [LclId] =
              [$dTraversable_sc0el] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sc0el;
        } in  GHC.Generics.$fFunctor:+: sat_sc0en sat_sc0eo;

Data.Traversable.$w$ctraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b) -> f a -> g a -> f1 ((GHC.Generics.:*:) f g b)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sc0ep w1_sc0eq w2_sc0er w3_sc0es ww_sc0et ww1_sc0eu]
        let {
          sat_sc0ew [Occ=Once] :: f1_sbWKB (g_sbWKy b_sbWKD)
          [LclId] =
              [w1_sc0eq w2_sc0er w3_sc0es ww1_sc0eu] \u []
                  Data.Traversable.traverse
                      w1_sc0eq w2_sc0er w3_sc0es ww1_sc0eu; } in
        let {
          sat_sc0ev [Occ=Once] :: f1_sbWKB (f_sbWKx b_sbWKD)
          [LclId] =
              [w_sc0ep w2_sc0er w3_sc0es ww_sc0et] \u []
                  Data.Traversable.traverse w_sc0ep w2_sc0er w3_sc0es ww_sc0et;
        } in 
          GHC.Base.liftA2 w2_sc0er GHC.Generics.:*: sat_sc0ev sat_sc0ew;

Data.Traversable.$fTraversable:*:_$ctraverse [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> (GHC.Generics.:*:) f g a -> f1 ((GHC.Generics.:*:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sc0ex w1_sc0ey w2_sc0ez w3_sc0eA w4_sc0eB]
        case w4_sc0eB of {
          GHC.Generics.:*: ww1_sc0eD [Occ=Once] ww2_sc0eE [Occ=Once] ->
              Data.Traversable.$w$ctraverse
                  w_sc0ex w1_sc0ey w2_sc0ez w3_sc0eA ww1_sc0eD ww2_sc0eE;
        };

Data.Traversable.$fTraversable:*:_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:*: g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0eF $dTraversable1_sc0eG]
        let {
          sat_sc0eI [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_abVCl
          [LclId] =
              [$dTraversable1_sc0eG] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sc0eG; } in
        let {
          sat_sc0eH [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_abVCk
          [LclId] =
              [$dTraversable_sc0eF] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sc0eF;
        } in  Data.Foldable.$fFoldable:*: sat_sc0eH sat_sc0eI;

Data.Traversable.$fTraversable:*:_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (f GHC.Generics.:*: g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),C(C1(U))),A,A,A,A,A)><L,1*U(1*U(C(C1(U)),C(C1(U))),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0eJ $dTraversable1_sc0eK]
        let {
          sat_sc0eM [Occ=Once, Dmd=<L,U(C(C1(U)),C(C1(U)))>]
            :: GHC.Base.Functor g_abVCl
          [LclId] =
              [$dTraversable1_sc0eK] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sc0eK; } in
        let {
          sat_sc0eL [Occ=Once, Dmd=<L,U(C(C1(U)),C(C1(U)))>]
            :: GHC.Base.Functor f_abVCk
          [LclId] =
              [$dTraversable_sc0eJ] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sc0eJ;
        } in  GHC.Generics.$fFunctor:*: sat_sc0eL sat_sc0eM;

Data.Traversable.$fTraversable:.:1
  :: forall (f :: * -> *) (g :: * -> *) b. f (g b) -> f (g b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [b1_sc0eN] b1_sc0eN;

Data.Traversable.$fTraversable:.:_$ctraverse
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a b.
     GHC.Base.Applicative f1 =>
     (a -> f1 b)
     -> (GHC.Generics.:.:) f g a -> f1 ((GHC.Generics.:.:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0eO
           $dTraversable1_sc0eP
           $dApplicative_sc0eQ
           eta_sc0eR
           eta1_sc0eS]
        let {
          sat_sc0eV [Occ=Once] :: f1_abVBf (f_abVB0 (g_abVB1 b_abVBh))
          [LclId] =
              [$dTraversable_sc0eO
               $dTraversable1_sc0eP
               $dApplicative_sc0eQ
               eta_sc0eR
               eta1_sc0eS] \u []
                  let {
                    sat_sc0eU [Occ=Once]
                      :: g_abVB1 a_abVBg -> f1_abVBf (g_abVB1 b_abVBh)
                    [LclId] =
                        [$dTraversable1_sc0eP $dApplicative_sc0eQ eta_sc0eR] \u []
                            Data.Traversable.traverse
                                $dTraversable1_sc0eP $dApplicative_sc0eQ eta_sc0eR;
                  } in 
                    Data.Traversable.traverse
                        $dTraversable_sc0eO $dApplicative_sc0eQ sat_sc0eU eta1_sc0eS;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0eQ of sat_sc0eT {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sc0eT Data.Traversable.$fTraversable:.:1 sat_sc0eV;
          };

Data.Traversable.$fTraversable:.:_$cp2Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Foldable.Foldable (f GHC.Generics.:.: g)
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)><L,1*U(A,1*U(A,C(C1(U)),C(C1(C1(U))),A,A,A,A,A,A,U,A,A,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0eW $dTraversable1_sc0eX]
        let {
          sat_sc0eZ [Occ=Once,
                     Dmd=<L,U(A,C(C1(U)),C(C1(C1(U))),A,A,A,A,A,A,U,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable g_abVB1
          [LclId] =
              [$dTraversable1_sc0eX] \u []
                  Data.Traversable.$p2Traversable $dTraversable1_sc0eX; } in
        let {
          sat_sc0eY [Occ=Once,
                     Dmd=<L,U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)>]
            :: Data.Foldable.Foldable f_abVB0
          [LclId] =
              [$dTraversable_sc0eW] \u []
                  Data.Traversable.$p2Traversable $dTraversable_sc0eW;
        } in  Data.Foldable.$fFoldable:.: sat_sc0eY sat_sc0eZ;

Data.Traversable.$fTraversable:.:_$cp1Traversable
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     GHC.Base.Functor (f GHC.Generics.:.: g)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)><L,1*U(1*U(C(U),C(U)),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0f0 $dTraversable1_sc0f1]
        let {
          sat_sc0f3 [Occ=Once, Dmd=<L,U(C(U),C(U))>]
            :: GHC.Base.Functor g_abVB1
          [LclId] =
              [$dTraversable1_sc0f1] \u []
                  Data.Traversable.$p1Traversable $dTraversable1_sc0f1; } in
        let {
          sat_sc0f2 [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Base.Functor f_abVB0
          [LclId] =
              [$dTraversable_sc0f0] \u []
                  Data.Traversable.$p1Traversable $dTraversable_sc0f0;
        } in  GHC.Generics.$fFunctor:.: sat_sc0f2 sat_sc0f3;

Data.Traversable.$fTraversableURec4_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a
     -> f (GHC.Generics.URec (GHC.Ptr.Ptr ()) b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0f4 f1_sc0f5 ds_sc0f6]
        case ds_sc0f6 of {
          GHC.Generics.UAddr a1_sc0f8 [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0f4 wild_sc0f7;
        };

Data.Traversable.$fTraversableURec3_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec GHC.Types.Char a
     -> f (GHC.Generics.URec GHC.Types.Char b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0fa f1_sc0fb ds_sc0fc]
        case ds_sc0fc of {
          GHC.Generics.UChar a1_sc0fe [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0fa wild_sc0fd;
        };

Data.Traversable.$fTraversableURec2_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec GHC.Types.Double a
     -> f (GHC.Generics.URec GHC.Types.Double b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0fg f1_sc0fh ds_sc0fi]
        case ds_sc0fi of {
          GHC.Generics.UDouble a1_sc0fk [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0fg wild_sc0fj;
        };

Data.Traversable.$fTraversableURec1_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec GHC.Types.Float a
     -> f (GHC.Generics.URec GHC.Types.Float b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0fm f1_sc0fn ds_sc0fo]
        case ds_sc0fo of {
          GHC.Generics.UFloat a1_sc0fq [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0fm wild_sc0fp;
        };

Data.Traversable.$fTraversableURec0_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec GHC.Types.Int a
     -> f (GHC.Generics.URec GHC.Types.Int b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0fs f1_sc0ft ds_sc0fu]
        case ds_sc0fu of {
          GHC.Generics.UInt a1_sc0fw [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0fs wild_sc0fv;
        };

Data.Traversable.$fTraversableURec_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> GHC.Generics.URec GHC.Types.Word a
     -> f (GHC.Generics.URec GHC.Types.Word b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0fy f1_sc0fz ds_sc0fA]
        case ds_sc0fA of {
          GHC.Generics.UWord a1_sc0fC [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0fy wild_sc0fB;
        };

Data.Traversable.$dmsequence [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (m :: * -> *) a. GHC.Base.Monad m => t (m a) -> m (t a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LL),1*U(A,A,A,1*C1(U),A,A)><L,1*U(1*U,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0fE $dMonad_sc0fF]
        let {
          sat_sc0fG [Occ=Once] :: GHC.Base.Applicative m_abVux
          [LclId] =
              [$dMonad_sc0fF] \u [] GHC.Base.$p1Monad $dMonad_sc0fF;
        } in  Data.Traversable.sequenceA $dTraversable_sc0fE sat_sc0fG;

Data.Traversable.$dmmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> t a -> m (t b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)><L,1*U(1*U,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0fH $dMonad_sc0fI]
        let {
          sat_sc0fJ [Occ=Once] :: GHC.Base.Applicative m_abVuj
          [LclId] =
              [$dMonad_sc0fI] \u [] GHC.Base.$p1Monad $dMonad_sc0fI;
        } in  Data.Traversable.traverse $dTraversable_sc0fH sat_sc0fJ;

Data.Traversable.$dmsequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     t (f a) -> f (t a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),1*U(A,A,1*C1(C1(U)),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0fK $dApplicative_sc0fL]
        Data.Traversable.traverse
            $dTraversable_sc0fK $dApplicative_sc0fL GHC.Base.id;

Data.Traversable.$fTraversableURec_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec GHC.Types.Word (f a)
     -> f (GHC.Generics.URec GHC.Types.Word a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0fM ds_sc0fN]
        case ds_sc0fN of {
          GHC.Generics.UWord a1_sc0fP [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0fM wild_sc0fO;
        };

Data.Traversable.$fTraversableURec_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec GHC.Types.Word a
     -> m (GHC.Generics.URec GHC.Types.Word b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0fR eta_sc0fS eta1_sc0fT]
        case eta1_sc0fT of {
          GHC.Generics.UWord a1_sc0fV [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0fR of sat_sc0fW {
                __DEFAULT -> GHC.Base.pure sat_sc0fW wild_sc0fU;
              };
        };

Data.Traversable.$fTraversableURec_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec GHC.Types.Word (m a)
     -> m (GHC.Generics.URec GHC.Types.Word a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0fY eta_sc0fZ]
        case eta_sc0fZ of {
          GHC.Generics.UWord a1_sc0g1 [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0fY of sat_sc0g2 {
                __DEFAULT -> GHC.Base.pure sat_sc0g2 wild_sc0g0;
              };
        };

Data.Traversable.$fTraversableURec [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Word)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec
                                                   Data.Foldable.$fFoldableURec
                                                   Data.Traversable.$fTraversableURec_$ctraverse
                                                   Data.Traversable.$fTraversableURec_$csequenceA
                                                   Data.Traversable.$fTraversableURec_$cmapM
                                                   Data.Traversable.$fTraversableURec_$csequence];

Data.Traversable.$fTraversableURec0_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec GHC.Types.Int (f a)
     -> f (GHC.Generics.URec GHC.Types.Int a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0g4 ds_sc0g5]
        case ds_sc0g5 of {
          GHC.Generics.UInt a1_sc0g7 [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0g4 wild_sc0g6;
        };

Data.Traversable.$fTraversableURec0_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec GHC.Types.Int a
     -> m (GHC.Generics.URec GHC.Types.Int b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0g9 eta_sc0ga eta1_sc0gb]
        case eta1_sc0gb of {
          GHC.Generics.UInt a1_sc0gd [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0g9 of sat_sc0ge {
                __DEFAULT -> GHC.Base.pure sat_sc0ge wild_sc0gc;
              };
        };

Data.Traversable.$fTraversableURec0_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec GHC.Types.Int (m a)
     -> m (GHC.Generics.URec GHC.Types.Int a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0gg eta_sc0gh]
        case eta_sc0gh of {
          GHC.Generics.UInt a1_sc0gj [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0gg of sat_sc0gk {
                __DEFAULT -> GHC.Base.pure sat_sc0gk wild_sc0gi;
              };
        };

Data.Traversable.$fTraversableURec0 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Int)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec0
                                                   Data.Foldable.$fFoldableURec0
                                                   Data.Traversable.$fTraversableURec0_$ctraverse
                                                   Data.Traversable.$fTraversableURec0_$csequenceA
                                                   Data.Traversable.$fTraversableURec0_$cmapM
                                                   Data.Traversable.$fTraversableURec0_$csequence];

Data.Traversable.$fTraversableURec1_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec GHC.Types.Float (f a)
     -> f (GHC.Generics.URec GHC.Types.Float a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0gm ds_sc0gn]
        case ds_sc0gn of {
          GHC.Generics.UFloat a1_sc0gp [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0gm wild_sc0go;
        };

Data.Traversable.$fTraversableURec1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec GHC.Types.Float a
     -> m (GHC.Generics.URec GHC.Types.Float b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0gr eta_sc0gs eta1_sc0gt]
        case eta1_sc0gt of {
          GHC.Generics.UFloat a1_sc0gv [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0gr of sat_sc0gw {
                __DEFAULT -> GHC.Base.pure sat_sc0gw wild_sc0gu;
              };
        };

Data.Traversable.$fTraversableURec1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec GHC.Types.Float (m a)
     -> m (GHC.Generics.URec GHC.Types.Float a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0gy eta_sc0gz]
        case eta_sc0gz of {
          GHC.Generics.UFloat a1_sc0gB [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0gy of sat_sc0gC {
                __DEFAULT -> GHC.Base.pure sat_sc0gC wild_sc0gA;
              };
        };

Data.Traversable.$fTraversableURec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Float)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec1
                                                   Data.Foldable.$fFoldableURec1
                                                   Data.Traversable.$fTraversableURec1_$ctraverse
                                                   Data.Traversable.$fTraversableURec1_$csequenceA
                                                   Data.Traversable.$fTraversableURec1_$cmapM
                                                   Data.Traversable.$fTraversableURec1_$csequence];

Data.Traversable.$fTraversableURec2_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec GHC.Types.Double (f a)
     -> f (GHC.Generics.URec GHC.Types.Double a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0gE ds_sc0gF]
        case ds_sc0gF of {
          GHC.Generics.UDouble a1_sc0gH [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0gE wild_sc0gG;
        };

Data.Traversable.$fTraversableURec2_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec GHC.Types.Double a
     -> m (GHC.Generics.URec GHC.Types.Double b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0gJ eta_sc0gK eta1_sc0gL]
        case eta1_sc0gL of {
          GHC.Generics.UDouble a1_sc0gN [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0gJ of sat_sc0gO {
                __DEFAULT -> GHC.Base.pure sat_sc0gO wild_sc0gM;
              };
        };

Data.Traversable.$fTraversableURec2_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec GHC.Types.Double (m a)
     -> m (GHC.Generics.URec GHC.Types.Double a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0gQ eta_sc0gR]
        case eta_sc0gR of {
          GHC.Generics.UDouble a1_sc0gT [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0gQ of sat_sc0gU {
                __DEFAULT -> GHC.Base.pure sat_sc0gU wild_sc0gS;
              };
        };

Data.Traversable.$fTraversableURec2 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable
       (GHC.Generics.URec GHC.Types.Double)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec2
                                                   Data.Foldable.$fFoldableURec2
                                                   Data.Traversable.$fTraversableURec2_$ctraverse
                                                   Data.Traversable.$fTraversableURec2_$csequenceA
                                                   Data.Traversable.$fTraversableURec2_$cmapM
                                                   Data.Traversable.$fTraversableURec2_$csequence];

Data.Traversable.$fTraversableURec3_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec GHC.Types.Char (f a)
     -> f (GHC.Generics.URec GHC.Types.Char a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0gW ds_sc0gX]
        case ds_sc0gX of {
          GHC.Generics.UChar a1_sc0gZ [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0gW wild_sc0gY;
        };

Data.Traversable.$fTraversableURec3_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec GHC.Types.Char a
     -> m (GHC.Generics.URec GHC.Types.Char b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0h1 eta_sc0h2 eta1_sc0h3]
        case eta1_sc0h3 of {
          GHC.Generics.UChar a1_sc0h5 [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0h1 of sat_sc0h6 {
                __DEFAULT -> GHC.Base.pure sat_sc0h6 wild_sc0h4;
              };
        };

Data.Traversable.$fTraversableURec3_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec GHC.Types.Char (m a)
     -> m (GHC.Generics.URec GHC.Types.Char a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0h8 eta_sc0h9]
        case eta_sc0h9 of {
          GHC.Generics.UChar a1_sc0hb [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0h8 of sat_sc0hc {
                __DEFAULT -> GHC.Base.pure sat_sc0hc wild_sc0ha;
              };
        };

Data.Traversable.$fTraversableURec3 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Char)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec3
                                                   Data.Foldable.$fFoldableURec3
                                                   Data.Traversable.$fTraversableURec3_$ctraverse
                                                   Data.Traversable.$fTraversableURec3_$csequenceA
                                                   Data.Traversable.$fTraversableURec3_$cmapM
                                                   Data.Traversable.$fTraversableURec3_$csequence];

Data.Traversable.$fTraversableURec4_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) (f a)
     -> f (GHC.Generics.URec (GHC.Ptr.Ptr ()) a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0he ds_sc0hf]
        case ds_sc0hf of {
          GHC.Generics.UAddr a1_sc0hh [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0he wild_sc0hg;
        };

Data.Traversable.$fTraversableURec4_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.URec (GHC.Ptr.Ptr ()) a
     -> m (GHC.Generics.URec (GHC.Ptr.Ptr ()) b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0hj eta_sc0hk eta1_sc0hl]
        case eta1_sc0hl of {
          GHC.Generics.UAddr a1_sc0hn [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0hj of sat_sc0ho {
                __DEFAULT -> GHC.Base.pure sat_sc0ho wild_sc0hm;
              };
        };

Data.Traversable.$fTraversableURec4_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.URec (GHC.Ptr.Ptr ()) (m a)
     -> m (GHC.Generics.URec (GHC.Ptr.Ptr ()) a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0hq eta_sc0hr]
        case eta_sc0hr of {
          GHC.Generics.UAddr a1_sc0ht [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0hq of sat_sc0hu {
                __DEFAULT -> GHC.Base.pure sat_sc0hu wild_sc0hs;
              };
        };

Data.Traversable.$fTraversableURec4 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable
       (GHC.Generics.URec (GHC.Ptr.Ptr ()))
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorURec4
                                                   Data.Foldable.$fFoldableURec4
                                                   Data.Traversable.$fTraversableURec4_$ctraverse
                                                   Data.Traversable.$fTraversableURec4_$csequenceA
                                                   Data.Traversable.$fTraversableURec4_$cmapM
                                                   Data.Traversable.$fTraversableURec4_$csequence];

Data.Traversable.$fTraversable:.:_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     (GHC.Generics.:.:) f g (f1 a) -> f1 ((GHC.Generics.:.:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(A,A,C(C1(U)),A,A,A)><L,U(U(U,U),U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0hw
           $dTraversable1_sc0hx
           $dApplicative_sc0hy
           eta_B1]
        Data.Traversable.$fTraversable:.:_$ctraverse
            $dTraversable_sc0hw
            $dTraversable1_sc0hx
            $dApplicative_sc0hy
            GHC.Base.id
            eta_B1;

Data.Traversable.$fTraversable:.:_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> (GHC.Generics.:.:) f g a -> m ((GHC.Generics.:.:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0hz
           $dTraversable1_sc0hA
           $dMonad_sc0hB
           eta_sc0hC
           eta1_sc0hD]
        case GHC.Base.$p1Monad $dMonad_sc0hB of sat_sc0hE {
          __DEFAULT ->
              Data.Traversable.$fTraversable:.:_$ctraverse
                  $dTraversable_sc0hz
                  $dTraversable1_sc0hA
                  sat_sc0hE
                  eta_sc0hC
                  eta1_sc0hD;
        };

Data.Traversable.$fTraversable:.:_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     (GHC.Generics.:.:) f g (m a) -> m ((GHC.Generics.:.:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(U)),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0hF
           $dTraversable1_sc0hG
           $dMonad_sc0hH
           eta_sc0hI]
        case GHC.Base.$p1Monad $dMonad_sc0hH of sat_sc0hJ {
          __DEFAULT ->
              Data.Traversable.$fTraversable:.:_$ctraverse
                  $dTraversable_sc0hF
                  $dTraversable1_sc0hG
                  sat_sc0hJ
                  GHC.Base.id
                  eta_sc0hI;
        };

Data.Traversable.$fTraversable:.: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (f GHC.Generics.:.: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(U),C(U)),1*U(A,C(C1(U)),C(C1(C1(U))),A,A,A,A,A,A,U,A,A,A,A,A,A),C(C1(U)),A,A,A)>m] =
    [] \r [$dTraversable_sc0hK $dTraversable1_sc0hL]
        let {
          sat_sc0hR [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               (GHC.Generics.:.:) f_abVB0 g_abVB1 (m a)
               -> m ((GHC.Generics.:.:) f_abVB0 g_abVB1 a)
          [LclId] =
              [$dTraversable_sc0hK $dTraversable1_sc0hL] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:.:_$csequence
                      $dTraversable_sc0hK $dTraversable1_sc0hL eta_B2 eta_B1; } in
        let {
          sat_sc0hQ [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> (GHC.Generics.:.:) f_abVB0 g_abVB1 a
               -> m ((GHC.Generics.:.:) f_abVB0 g_abVB1 b)
          [LclId] =
              [$dTraversable_sc0hK $dTraversable1_sc0hL] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:.:_$cmapM
                      $dTraversable_sc0hK $dTraversable1_sc0hL eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sc0hP [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               (GHC.Generics.:.:) f_abVB0 g_abVB1 (f a)
               -> f ((GHC.Generics.:.:) f_abVB0 g_abVB1 a)
          [LclId] =
              [$dTraversable_sc0hK $dTraversable1_sc0hL] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:.:_$csequenceA
                      $dTraversable_sc0hK $dTraversable1_sc0hL eta_B2 eta_B1; } in
        let {
          sat_sc0hO [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> (GHC.Generics.:.:) f_abVB0 g_abVB1 a
               -> f ((GHC.Generics.:.:) f_abVB0 g_abVB1 b)
          [LclId] =
              [$dTraversable_sc0hK $dTraversable1_sc0hL] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:.:_$ctraverse
                      $dTraversable_sc0hK $dTraversable1_sc0hL eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sc0hN [Occ=Once]
            :: Data.Foldable.Foldable (f_abVB0 GHC.Generics.:.: g_abVB1)
          [LclId] =
              [$dTraversable_sc0hK $dTraversable1_sc0hL] \u []
                  Data.Traversable.$fTraversable:.:_$cp2Traversable
                      $dTraversable_sc0hK $dTraversable1_sc0hL; } in
        let {
          sat_sc0hM [Occ=Once]
            :: GHC.Base.Functor (f_abVB0 GHC.Generics.:.: g_abVB1)
          [LclId] =
              [$dTraversable_sc0hK $dTraversable1_sc0hL] \u []
                  Data.Traversable.$fTraversable:.:_$cp1Traversable
                      $dTraversable_sc0hK $dTraversable1_sc0hL;
        } in 
          Data.Traversable.C:Traversable [sat_sc0hM
                                          sat_sc0hN
                                          sat_sc0hO
                                          sat_sc0hP
                                          sat_sc0hQ
                                          sat_sc0hR];

Data.Traversable.$fTraversable:*:_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     (GHC.Generics.:*:) f g (f1 a) -> f1 ((GHC.Generics.:*:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLLC(C(C(S)))LL),U(U,U,U,U,U,U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0hS
           $dTraversable1_sc0hT
           $dApplicative_sc0hU
           w_sc0hV]
        case w_sc0hV of {
          GHC.Generics.:*: ww1_sc0hX [Occ=Once] ww2_sc0hY [Occ=Once] ->
              Data.Traversable.$w$ctraverse
                  $dTraversable_sc0hS
                  $dTraversable1_sc0hT
                  $dApplicative_sc0hU
                  GHC.Base.id
                  ww1_sc0hX
                  ww2_sc0hY;
        };

Data.Traversable.$fTraversable:*:_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> (GHC.Generics.:*:) f g a -> m ((GHC.Generics.:*:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(U,U,U,U,U,U),A,A,A,A)><L,U><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0hZ
           $dTraversable1_sc0i0
           $dMonad_sc0i1
           eta_sc0i2
           eta1_sc0i3]
        case eta1_sc0i3 of {
          GHC.Generics.:*: ww1_sc0i5 [Occ=Once] ww2_sc0i6 [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0i1 of sat_sc0i7 {
                __DEFAULT ->
                    Data.Traversable.$w$ctraverse
                        $dTraversable_sc0hZ
                        $dTraversable1_sc0i0
                        sat_sc0i7
                        eta_sc0i2
                        ww1_sc0i5
                        ww2_sc0i6;
              };
        };

Data.Traversable.$fTraversable:*:_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     (GHC.Generics.:*:) f g (m a) -> m ((GHC.Generics.:*:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(U,U,U,U,U,U),A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0i8
           $dTraversable1_sc0i9
           $dMonad_sc0ia
           eta_sc0ib]
        case eta_sc0ib of {
          GHC.Generics.:*: ww1_sc0id [Occ=Once] ww2_sc0ie [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0ia of sat_sc0if {
                __DEFAULT ->
                    Data.Traversable.$w$ctraverse
                        $dTraversable_sc0i8
                        $dTraversable1_sc0i9
                        sat_sc0if
                        GHC.Base.id
                        ww1_sc0id
                        ww2_sc0ie;
              };
        };

Data.Traversable.$fTraversable:*: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (f GHC.Generics.:*: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),C(C1(U))),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(C1(U)),C(C1(U))),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sc0ig $dTraversable1_sc0ih]
        let {
          sat_sc0in [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               (GHC.Generics.:*:) f_abVCk g_abVCl (m a)
               -> m ((GHC.Generics.:*:) f_abVCk g_abVCl a)
          [LclId] =
              [$dTraversable_sc0ig $dTraversable1_sc0ih] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:*:_$csequence
                      $dTraversable_sc0ig $dTraversable1_sc0ih eta_B2 eta_B1; } in
        let {
          sat_sc0im [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> (GHC.Generics.:*:) f_abVCk g_abVCl a
               -> m ((GHC.Generics.:*:) f_abVCk g_abVCl b)
          [LclId] =
              [$dTraversable_sc0ig $dTraversable1_sc0ih] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:*:_$cmapM
                      $dTraversable_sc0ig $dTraversable1_sc0ih eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sc0il [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               (GHC.Generics.:*:) f_abVCk g_abVCl (f a)
               -> f ((GHC.Generics.:*:) f_abVCk g_abVCl a)
          [LclId] =
              [$dTraversable_sc0ig $dTraversable1_sc0ih] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:*:_$csequenceA
                      $dTraversable_sc0ig $dTraversable1_sc0ih eta_B2 eta_B1; } in
        let {
          sat_sc0ik [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> (GHC.Generics.:*:) f_abVCk g_abVCl a
               -> f ((GHC.Generics.:*:) f_abVCk g_abVCl b)
          [LclId] =
              [$dTraversable_sc0ig $dTraversable1_sc0ih] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:*:_$ctraverse
                      $dTraversable_sc0ig $dTraversable1_sc0ih eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sc0ij [Occ=Once]
            :: Data.Foldable.Foldable (f_abVCk GHC.Generics.:*: g_abVCl)
          [LclId] =
              [$dTraversable_sc0ig $dTraversable1_sc0ih] \u []
                  Data.Traversable.$fTraversable:*:_$cp2Traversable
                      $dTraversable_sc0ig $dTraversable1_sc0ih; } in
        let {
          sat_sc0ii [Occ=Once]
            :: GHC.Base.Functor (f_abVCk GHC.Generics.:*: g_abVCl)
          [LclId] =
              [$dTraversable_sc0ig $dTraversable1_sc0ih] \u []
                  Data.Traversable.$fTraversable:*:_$cp1Traversable
                      $dTraversable_sc0ig $dTraversable1_sc0ih;
        } in 
          Data.Traversable.C:Traversable [sat_sc0ii
                                          sat_sc0ij
                                          sat_sc0ik
                                          sat_sc0il
                                          sat_sc0im
                                          sat_sc0in];

Data.Traversable.$fTraversable:+:_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     (GHC.Generics.:+:) f g (f1 a) -> f1 ((GHC.Generics.:+:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(A,A,C(C1(C1(U))),A,A,A)><L,U(U(U,U),U,U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0io
           $dTraversable1_sc0ip
           $dApplicative_sc0iq
           eta_B1]
        Data.Traversable.$fTraversable:+:_$ctraverse
            $dTraversable_sc0io
            $dTraversable1_sc0ip
            $dApplicative_sc0iq
            GHC.Base.id
            eta_B1;

Data.Traversable.$fTraversable:+:_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> (GHC.Generics.:+:) f g a -> m ((GHC.Generics.:+:) f g b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0ir
           $dTraversable1_sc0is
           $dMonad_sc0it
           eta_sc0iu
           eta1_sc0iv]
        case GHC.Base.$p1Monad $dMonad_sc0it of sat_sc0iw {
          __DEFAULT ->
              Data.Traversable.$fTraversable:+:_$ctraverse
                  $dTraversable_sc0ir
                  $dTraversable1_sc0is
                  sat_sc0iw
                  eta_sc0iu
                  eta1_sc0iv;
        };

Data.Traversable.$fTraversable:+:_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     (GHC.Generics.:+:) f g (m a) -> m ((GHC.Generics.:+:) f g a)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0ix
           $dTraversable1_sc0iy
           $dMonad_sc0iz
           eta_sc0iA]
        case GHC.Base.$p1Monad $dMonad_sc0iz of sat_sc0iB {
          __DEFAULT ->
              Data.Traversable.$fTraversable:+:_$ctraverse
                  $dTraversable_sc0ix
                  $dTraversable1_sc0iy
                  sat_sc0iB
                  GHC.Base.id
                  eta_sc0iA;
        };

Data.Traversable.$fTraversable:+: [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) (g :: * -> *).
     (Data.Traversable.Traversable f, Data.Traversable.Traversable g) =>
     Data.Traversable.Traversable (f GHC.Generics.:+: g)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(1*U(C(C1(U)),C(C1(U))),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)><L,U(1*U(C(C1(U)),C(C1(U))),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sc0iC $dTraversable1_sc0iD]
        let {
          sat_sc0iJ [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               (GHC.Generics.:+:) f_abVDE g_abVDF (m a)
               -> m ((GHC.Generics.:+:) f_abVDE g_abVDF a)
          [LclId] =
              [$dTraversable_sc0iC $dTraversable1_sc0iD] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:+:_$csequence
                      $dTraversable_sc0iC $dTraversable1_sc0iD eta_B2 eta_B1; } in
        let {
          sat_sc0iI [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> (GHC.Generics.:+:) f_abVDE g_abVDF a
               -> m ((GHC.Generics.:+:) f_abVDE g_abVDF b)
          [LclId] =
              [$dTraversable_sc0iC $dTraversable1_sc0iD] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:+:_$cmapM
                      $dTraversable_sc0iC $dTraversable1_sc0iD eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sc0iH [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               (GHC.Generics.:+:) f_abVDE g_abVDF (f a)
               -> f ((GHC.Generics.:+:) f_abVDE g_abVDF a)
          [LclId] =
              [$dTraversable_sc0iC $dTraversable1_sc0iD] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversable:+:_$csequenceA
                      $dTraversable_sc0iC $dTraversable1_sc0iD eta_B2 eta_B1; } in
        let {
          sat_sc0iG [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> (GHC.Generics.:+:) f_abVDE g_abVDF a
               -> f ((GHC.Generics.:+:) f_abVDE g_abVDF b)
          [LclId] =
              [$dTraversable_sc0iC $dTraversable1_sc0iD] \r [eta_B3
                                                             eta_B2
                                                             eta_B1]
                  Data.Traversable.$fTraversable:+:_$ctraverse
                      $dTraversable_sc0iC $dTraversable1_sc0iD eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sc0iF [Occ=Once]
            :: Data.Foldable.Foldable (f_abVDE GHC.Generics.:+: g_abVDF)
          [LclId] =
              [$dTraversable_sc0iC $dTraversable1_sc0iD] \u []
                  Data.Traversable.$fTraversable:+:_$cp2Traversable
                      $dTraversable_sc0iC $dTraversable1_sc0iD; } in
        let {
          sat_sc0iE [Occ=Once]
            :: GHC.Base.Functor (f_abVDE GHC.Generics.:+: g_abVDF)
          [LclId] =
              [$dTraversable_sc0iC $dTraversable1_sc0iD] \u []
                  Data.Traversable.$fTraversable:+:_$cp1Traversable
                      $dTraversable_sc0iC $dTraversable1_sc0iD;
        } in 
          Data.Traversable.C:Traversable [sat_sc0iE
                                          sat_sc0iF
                                          sat_sc0iG
                                          sat_sc0iH
                                          sat_sc0iI
                                          sat_sc0iJ];

Data.Traversable.$fTraversableM1_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     GHC.Generics.M1 i c f (f1 a) -> f1 (GHC.Generics.M1 i c f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0iK $dApplicative_sc0iL eta_sc0iM]
        let {
          sat_sc0iO [Occ=Once] :: f1_abVFI (f_abVF5 a_abVFJ)
          [LclId] =
              [$dTraversable_sc0iK $dApplicative_sc0iL eta_sc0iM] \u []
                  Data.Traversable.traverse
                      $dTraversable_sc0iK $dApplicative_sc0iL GHC.Base.id eta_sc0iM;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0iL of sat_sc0iN {
            __DEFAULT ->
                GHC.Base.fmap sat_sc0iN Data.Traversable.$fTraversableM2 sat_sc0iO;
          };

Data.Traversable.$fTraversableM1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> GHC.Generics.M1 i c f a -> m (GHC.Generics.M1 i c f b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0iP $dMonad_sc0iQ eta_sc0iR eta1_sc0iS]
        case
            GHC.Base.$p1Monad $dMonad_sc0iQ
        of
        $dApplicative_sc0iT [Dmd=<S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)>]
        { __DEFAULT ->
              let {
                sat_sc0iV [Occ=Once] :: m_abVFU (f_abVF5 b_abVFW)
                [LclId] =
                    [$dTraversable_sc0iP
                     eta_sc0iR
                     eta1_sc0iS
                     $dApplicative_sc0iT] \u []
                        Data.Traversable.traverse
                            $dTraversable_sc0iP $dApplicative_sc0iT eta_sc0iR eta1_sc0iS;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0iT of sat_sc0iU {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sc0iU Data.Traversable.$fTraversableM2 sat_sc0iV;
                };
        };

Data.Traversable.$fTraversableM1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.M1 i c f (m a) -> m (GHC.Generics.M1 i c f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0iW $dMonad_sc0iX eta_sc0iY]
        case
            GHC.Base.$p1Monad $dMonad_sc0iX
        of
        $dApplicative_sc0iZ [Dmd=<S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)>]
        { __DEFAULT ->
              let {
                sat_sc0j1 [Occ=Once] :: m_abVG8 (f_abVF5 a_abVG9)
                [LclId] =
                    [$dTraversable_sc0iW eta_sc0iY $dApplicative_sc0iZ] \u []
                        Data.Traversable.traverse
                            $dTraversable_sc0iW $dApplicative_sc0iZ GHC.Base.id eta_sc0iY;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0iZ of sat_sc0j0 {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sc0j0 Data.Traversable.$fTraversableM2 sat_sc0j1;
                };
        };

Data.Traversable.$fTraversableM1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) i (c :: GHC.Generics.Meta).
     Data.Traversable.Traversable f =>
     Data.Traversable.Traversable (GHC.Generics.M1 i c f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(1*U(1*U,1*U),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sc0j2]
        let {
          sat_sc0j8 [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 (m a)
               -> m (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 a)
          [LclId] =
              [$dTraversable_sc0j2] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableM1_$csequence
                      $dTraversable_sc0j2 eta_B2 eta_B1; } in
        let {
          sat_sc0j7 [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 a
               -> m (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 b)
          [LclId] =
              [$dTraversable_sc0j2] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableM1_$cmapM
                      $dTraversable_sc0j2 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sc0j6 [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 (f a)
               -> f (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 a)
          [LclId] =
              [$dTraversable_sc0j2] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableM1_$csequenceA
                      $dTraversable_sc0j2 eta_B2 eta_B1; } in
        let {
          sat_sc0j5 [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 a
               -> f (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5 b)
          [LclId] =
              [$dTraversable_sc0j2] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableM1_$ctraverse
                      $dTraversable_sc0j2 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sc0j4 [Occ=Once]
            :: Data.Foldable.Foldable (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5)
          [LclId] =
              [$dTraversable_sc0j2] \u []
                  Data.Traversable.$fTraversableM1_$cp2Traversable
                      $dTraversable_sc0j2; } in
        let {
          sat_sc0j3 [Occ=Once]
            :: GHC.Base.Functor (GHC.Generics.M1 i_abVF6 c_abVF7 f_abVF5)
          [LclId] =
              [$dTraversable_sc0j2] \u []
                  Data.Traversable.$fTraversableM1_$cp1Traversable
                      $dTraversable_sc0j2;
        } in 
          Data.Traversable.C:Traversable [sat_sc0j3
                                          sat_sc0j4
                                          sat_sc0j5
                                          sat_sc0j6
                                          sat_sc0j7
                                          sat_sc0j8];

Data.Traversable.$fTraversableK1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall i c (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Generics.K1 i c a -> m (GHC.Generics.K1 i c b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0j9 eta_sc0ja eta1_sc0jb]
        case GHC.Base.$p1Monad $dMonad_sc0j9 of sat_sc0jc {
          __DEFAULT -> GHC.Base.pure sat_sc0jc eta1_sc0jb;
        };

Data.Traversable.$fTraversableK1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall i c (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.K1 i c (m a) -> m (GHC.Generics.K1 i c a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0jd eta_sc0je]
        case GHC.Base.$p1Monad $dMonad_sc0jd of sat_sc0jf {
          __DEFAULT -> GHC.Base.pure sat_sc0jf eta_sc0je;
        };

$fTraversableK2_rbWTS
  :: forall c i (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.K1 i c (f a) -> f (GHC.Generics.K1 i c a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0jg z_sc0jh]
        GHC.Base.pure $dApplicative_sc0jg z_sc0jh;

Data.Traversable.$fTraversableK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i c. Data.Traversable.Traversable (GHC.Generics.K1 i c)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorK1
                                                   Data.Foldable.$fFoldableK1
                                                   Data.Traversable.$fTraversableK1_$ctraverse
                                                   $fTraversableK2_rbWTS
                                                   Data.Traversable.$fTraversableK1_$cmapM
                                                   Data.Traversable.$fTraversableK1_$csequence];

Data.Traversable.$fTraversableRec1_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     forall (f1 :: * -> *) a.
     GHC.Base.Applicative f1 =>
     GHC.Generics.Rec1 f (f1 a) -> f1 (GHC.Generics.Rec1 f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0ji $dApplicative_sc0jj eta_sc0jk]
        let {
          sat_sc0jm [Occ=Once] :: f1_abVHV (f_abVHm a_abVHW)
          [LclId] =
              [$dTraversable_sc0ji $dApplicative_sc0jj eta_sc0jk] \u []
                  Data.Traversable.traverse
                      $dTraversable_sc0ji $dApplicative_sc0jj GHC.Base.id eta_sc0jk;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0jj of sat_sc0jl {
            __DEFAULT ->
                GHC.Base.fmap sat_sc0jl Data.Traversable.$fTraversableM2 sat_sc0jm;
          };

Data.Traversable.$fTraversableRec1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Generics.Rec1 f a -> m (GHC.Generics.Rec1 f b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0jn $dMonad_sc0jo eta_sc0jp eta1_sc0jq]
        case
            GHC.Base.$p1Monad $dMonad_sc0jo
        of
        $dApplicative_sc0jr [Dmd=<S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)>]
        { __DEFAULT ->
              let {
                sat_sc0jt [Occ=Once] :: m_abVI7 (f_abVHm b_abVI9)
                [LclId] =
                    [$dTraversable_sc0jn
                     eta_sc0jp
                     eta1_sc0jq
                     $dApplicative_sc0jr] \u []
                        Data.Traversable.traverse
                            $dTraversable_sc0jn $dApplicative_sc0jr eta_sc0jp eta1_sc0jq;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0jr of sat_sc0js {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sc0js Data.Traversable.$fTraversableM2 sat_sc0jt;
                };
        };

Data.Traversable.$fTraversableRec1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.Rec1 f (m a) -> m (GHC.Generics.Rec1 f a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(U,U),U,U,U,U,U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0ju $dMonad_sc0jv eta_sc0jw]
        case
            GHC.Base.$p1Monad $dMonad_sc0jv
        of
        $dApplicative_sc0jx [Dmd=<S(S(C(C(S))L)LLLLL),U(U(U,U),U,U,U,U,U)>]
        { __DEFAULT ->
              let {
                sat_sc0jz [Occ=Once] :: m_abVIl (f_abVHm a_abVIm)
                [LclId] =
                    [$dTraversable_sc0ju eta_sc0jw $dApplicative_sc0jx] \u []
                        Data.Traversable.traverse
                            $dTraversable_sc0ju $dApplicative_sc0jx GHC.Base.id eta_sc0jw;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0jx of sat_sc0jy {
                  __DEFAULT ->
                      GHC.Base.fmap sat_sc0jy Data.Traversable.$fTraversableM2 sat_sc0jz;
                };
        };

Data.Traversable.$fTraversableRec1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     Data.Traversable.Traversable f =>
     Data.Traversable.Traversable (GHC.Generics.Rec1 f)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(1*U(1*U,1*U),1*U(A,C(C1(C1(U))),C(C1(C1(U))),A,A,A,A,A,A,C(U),A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m] =
    [] \r [$dTraversable_sc0jA]
        let {
          sat_sc0jG [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               GHC.Generics.Rec1 f_abVHm (m a) -> m (GHC.Generics.Rec1 f_abVHm a)
          [LclId] =
              [$dTraversable_sc0jA] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableRec1_$csequence
                      $dTraversable_sc0jA eta_B2 eta_B1; } in
        let {
          sat_sc0jF [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> GHC.Generics.Rec1 f_abVHm a -> m (GHC.Generics.Rec1 f_abVHm b)
          [LclId] =
              [$dTraversable_sc0jA] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableRec1_$cmapM
                      $dTraversable_sc0jA eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sc0jE [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               GHC.Generics.Rec1 f_abVHm (f a) -> f (GHC.Generics.Rec1 f_abVHm a)
          [LclId] =
              [$dTraversable_sc0jA] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableRec1_$csequenceA
                      $dTraversable_sc0jA eta_B2 eta_B1; } in
        let {
          sat_sc0jD [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> GHC.Generics.Rec1 f_abVHm a -> f (GHC.Generics.Rec1 f_abVHm b)
          [LclId] =
              [$dTraversable_sc0jA] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableRec1_$ctraverse
                      $dTraversable_sc0jA eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sc0jC [Occ=Once]
            :: Data.Foldable.Foldable (GHC.Generics.Rec1 f_abVHm)
          [LclId] =
              [$dTraversable_sc0jA] \u []
                  Data.Traversable.$fTraversableRec1_$cp2Traversable
                      $dTraversable_sc0jA; } in
        let {
          sat_sc0jB [Occ=Once]
            :: GHC.Base.Functor (GHC.Generics.Rec1 f_abVHm)
          [LclId] =
              [$dTraversable_sc0jA] \u []
                  Data.Traversable.$fTraversableRec1_$cp1Traversable
                      $dTraversable_sc0jA;
        } in 
          Data.Traversable.C:Traversable [sat_sc0jB
                                          sat_sc0jC
                                          sat_sc0jD
                                          sat_sc0jE
                                          sat_sc0jF
                                          sat_sc0jG];

Data.Traversable.$fTraversablePar1_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.Par1 (f a) -> f (GHC.Generics.Par1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0jH eta_sc0jI]
        case GHC.Base.$p1Applicative $dApplicative_sc0jH of sat_sc0jJ {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sc0jJ Data.Traversable.$fTraversableDual1 eta_sc0jI;
        };

Data.Traversable.$fTraversablePar1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Generics.Par1 a -> m (GHC.Generics.Par1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0jK eta_sc0jL eta1_sc0jM]
        let {
          sat_sc0jP [Occ=Once] :: m_abVJ7 b_abVJ9
          [LclId] =
              [eta_sc0jL eta1_sc0jM] \u [] eta_sc0jL eta1_sc0jM;
        } in 
          case GHC.Base.$p1Monad $dMonad_sc0jK of sat_sc0jN {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sc0jN of sat_sc0jO {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sc0jO Data.Traversable.$fTraversableDual1 sat_sc0jP;
                };
          };

Data.Traversable.$fTraversablePar1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.Par1 (m a) -> m (GHC.Generics.Par1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0jQ eta_sc0jR]
        case GHC.Base.$p1Monad $dMonad_sc0jQ of sat_sc0jS {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sc0jS of sat_sc0jT {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sc0jT Data.Traversable.$fTraversableDual1 eta_sc0jR;
              };
        };

Data.Traversable.$fTraversablePar1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable GHC.Generics.Par1
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorPar1
                                                   Data.Foldable.$fFoldablePar1
                                                   Data.Traversable.$fTraversablePar1_$ctraverse
                                                   Data.Traversable.$fTraversablePar1_$csequenceA
                                                   Data.Traversable.$fTraversablePar1_$cmapM
                                                   Data.Traversable.$fTraversablePar1_$csequence];

Data.Traversable.$fTraversableV1_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Generics.V1 a -> m (GHC.Generics.V1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0jU eta_sc0jV eta1_sc0jW]
        case GHC.Base.$p1Monad $dMonad_sc0jU of sat_sc0jX {
          __DEFAULT -> GHC.Base.pure sat_sc0jX eta1_sc0jW;
        };

Data.Traversable.$fTraversableV1_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Generics.V1 (m a) -> m (GHC.Generics.V1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0jY eta_sc0jZ]
        case GHC.Base.$p1Monad $dMonad_sc0jY of sat_sc0k0 {
          __DEFAULT -> GHC.Base.pure sat_sc0k0 eta_sc0jZ;
        };

$fTraversableV2_rbWTT
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Generics.V1 (f a) -> f (GHC.Generics.V1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0k1 z_sc0k2]
        GHC.Base.pure $dApplicative_sc0k1 z_sc0k2;

Data.Traversable.$fTraversableV1 [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable GHC.Generics.V1
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Generics.$fFunctorV1
                                                   Data.Foldable.$fFoldableV1
                                                   Data.Traversable.$fTraversableV1_$ctraverse
                                                   $fTraversableV2_rbWTT
                                                   Data.Traversable.$fTraversableV1_$cmapM
                                                   Data.Traversable.$fTraversableV1_$csequence];

Data.Traversable.$fTraversableIdentity_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Functor.Identity.Identity (f a)
     -> f (Data.Functor.Identity.Identity a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0k3 eta_sc0k4]
        case GHC.Base.$p1Applicative $dApplicative_sc0k3 of sat_sc0k5 {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sc0k5 Data.Traversable.$fTraversableDual1 eta_sc0k4;
        };

Data.Traversable.$fTraversableIdentity_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Functor.Identity.Identity a
     -> m (Data.Functor.Identity.Identity b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0k6 eta_sc0k7 eta1_sc0k8]
        let {
          sat_sc0kb [Occ=Once] :: m_abVL8 b_abVLa
          [LclId] =
              [eta_sc0k7 eta1_sc0k8] \u [] eta_sc0k7 eta1_sc0k8;
        } in 
          case GHC.Base.$p1Monad $dMonad_sc0k6 of sat_sc0k9 {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sc0k9 of sat_sc0ka {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sc0ka Data.Traversable.$fTraversableDual1 sat_sc0kb;
                };
          };

Data.Traversable.$fTraversableIdentity_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Functor.Identity.Identity (m a)
     -> m (Data.Functor.Identity.Identity a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0kc eta_sc0kd]
        case GHC.Base.$p1Monad $dMonad_sc0kc of sat_sc0ke {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sc0ke of sat_sc0kf {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sc0kf Data.Traversable.$fTraversableDual1 eta_sc0kd;
              };
        };

Data.Traversable.$fTraversableIdentity [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Functor.Identity.Identity
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Functor.Identity.$fFunctorIdentity
                                                   Data.Functor.Identity.$fFoldableIdentity
                                                   Data.Traversable.$fTraversableIdentity_$ctraverse
                                                   Data.Traversable.$fTraversableIdentity_$csequenceA
                                                   Data.Traversable.$fTraversableIdentity_$cmapM
                                                   Data.Traversable.$fTraversableIdentity_$csequence];

Data.Traversable.$fTraversableProduct_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Internal.Product (f a)
     -> f (Data.Semigroup.Internal.Product a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0kg eta_sc0kh]
        case GHC.Base.$p1Applicative $dApplicative_sc0kg of sat_sc0ki {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sc0ki Data.Traversable.$fTraversableDual1 eta_sc0kh;
        };

Data.Traversable.$fTraversableProduct_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Semigroup.Internal.Product a
     -> m (Data.Semigroup.Internal.Product b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0kj eta_sc0kk eta1_sc0kl]
        let {
          sat_sc0ko [Occ=Once] :: m_abVQs b_abVQu
          [LclId] =
              [eta_sc0kk eta1_sc0kl] \u [] eta_sc0kk eta1_sc0kl;
        } in 
          case GHC.Base.$p1Monad $dMonad_sc0kj of sat_sc0km {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sc0km of sat_sc0kn {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sc0kn Data.Traversable.$fTraversableDual1 sat_sc0ko;
                };
          };

Data.Traversable.$fTraversableProduct_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Internal.Product (m a)
     -> m (Data.Semigroup.Internal.Product a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0kp eta_sc0kq]
        case GHC.Base.$p1Monad $dMonad_sc0kp of sat_sc0kr {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sc0kr of sat_sc0ks {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sc0ks Data.Traversable.$fTraversableDual1 eta_sc0kq;
              };
        };

Data.Traversable.$fTraversableProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Internal.Product
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.Internal.$fFunctorProduct
                                                   Data.Foldable.$fFoldableProduct
                                                   Data.Traversable.$fTraversableProduct_$ctraverse
                                                   Data.Traversable.$fTraversableProduct_$csequenceA
                                                   Data.Traversable.$fTraversableProduct_$cmapM
                                                   Data.Traversable.$fTraversableProduct_$csequence];

Data.Traversable.$fTraversableSum_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Internal.Sum (f a)
     -> f (Data.Semigroup.Internal.Sum a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0kt eta_sc0ku]
        case GHC.Base.$p1Applicative $dApplicative_sc0kt of sat_sc0kv {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sc0kv Data.Traversable.$fTraversableDual1 eta_sc0ku;
        };

Data.Traversable.$fTraversableSum_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Semigroup.Internal.Sum a
     -> m (Data.Semigroup.Internal.Sum b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0kw eta_sc0kx eta1_sc0ky]
        let {
          sat_sc0kB [Occ=Once] :: m_abVRs b_abVRu
          [LclId] =
              [eta_sc0kx eta1_sc0ky] \u [] eta_sc0kx eta1_sc0ky;
        } in 
          case GHC.Base.$p1Monad $dMonad_sc0kw of sat_sc0kz {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sc0kz of sat_sc0kA {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sc0kA Data.Traversable.$fTraversableDual1 sat_sc0kB;
                };
          };

Data.Traversable.$fTraversableSum_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Internal.Sum (m a)
     -> m (Data.Semigroup.Internal.Sum a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0kC eta_sc0kD]
        case GHC.Base.$p1Monad $dMonad_sc0kC of sat_sc0kE {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sc0kE of sat_sc0kF {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sc0kF Data.Traversable.$fTraversableDual1 eta_sc0kD;
              };
        };

Data.Traversable.$fTraversableSum [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Internal.Sum
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.Internal.$fFunctorSum
                                                   Data.Foldable.$fFoldableSum
                                                   Data.Traversable.$fTraversableSum_$ctraverse
                                                   Data.Traversable.$fTraversableSum_$csequenceA
                                                   Data.Traversable.$fTraversableSum_$cmapM
                                                   Data.Traversable.$fTraversableSum_$csequence];

Data.Traversable.$fTraversableDual_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Semigroup.Internal.Dual (f a)
     -> f (Data.Semigroup.Internal.Dual a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0kG eta_sc0kH]
        case GHC.Base.$p1Applicative $dApplicative_sc0kG of sat_sc0kI {
          __DEFAULT ->
              GHC.Base.fmap
                  sat_sc0kI Data.Traversable.$fTraversableDual1 eta_sc0kH;
        };

Data.Traversable.$fTraversableDual_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Data.Semigroup.Internal.Dual a
     -> m (Data.Semigroup.Internal.Dual b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0kJ eta_sc0kK eta1_sc0kL]
        let {
          sat_sc0kO [Occ=Once] :: m_abVSs b_abVSu
          [LclId] =
              [eta_sc0kK eta1_sc0kL] \u [] eta_sc0kK eta1_sc0kL;
        } in 
          case GHC.Base.$p1Monad $dMonad_sc0kJ of sat_sc0kM {
            __DEFAULT ->
                case GHC.Base.$p1Applicative sat_sc0kM of sat_sc0kN {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sc0kN Data.Traversable.$fTraversableDual1 sat_sc0kO;
                };
          };

Data.Traversable.$fTraversableDual_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Semigroup.Internal.Dual (m a)
     -> m (Data.Semigroup.Internal.Dual a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0kP eta_sc0kQ]
        case GHC.Base.$p1Monad $dMonad_sc0kP of sat_sc0kR {
          __DEFAULT ->
              case GHC.Base.$p1Applicative sat_sc0kR of sat_sc0kS {
                __DEFAULT ->
                    GHC.Base.fmap
                        sat_sc0kS Data.Traversable.$fTraversableDual1 eta_sc0kQ;
              };
        };

Data.Traversable.$fTraversableDual [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Semigroup.Internal.Dual
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Semigroup.Internal.$fFunctorDual
                                                   Data.Foldable.$fFoldableDual
                                                   Data.Traversable.$fTraversableDual_$ctraverse
                                                   Data.Traversable.$fTraversableDual_$csequenceA
                                                   Data.Traversable.$fTraversableDual_$cmapM
                                                   Data.Traversable.$fTraversableDual_$csequence];

Data.Traversable.$fTraversableConst_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall m1 (m2 :: * -> *) a b.
     GHC.Base.Monad m2 =>
     (a -> m2 b)
     -> Data.Functor.Const.Const m1 a
     -> m2 (Data.Functor.Const.Const m1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0kT eta_sc0kU eta1_sc0kV]
        case GHC.Base.$p1Monad $dMonad_sc0kT of sat_sc0kW {
          __DEFAULT -> GHC.Base.pure sat_sc0kW eta1_sc0kV;
        };

Data.Traversable.$fTraversableConst_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall m1 (m2 :: * -> *) a.
     GHC.Base.Monad m2 =>
     Data.Functor.Const.Const m1 (m2 a)
     -> m2 (Data.Functor.Const.Const m1 a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LC(S)LLLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0kX eta_sc0kY]
        case GHC.Base.$p1Monad $dMonad_sc0kX of sat_sc0kZ {
          __DEFAULT -> GHC.Base.pure sat_sc0kZ eta_sc0kY;
        };

$fTraversableConst1_rbWTU
  :: forall m (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Functor.Const.Const m (f a)
     -> f (Data.Functor.Const.Const m a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(S)LLLL),1*U(A,1*C1(U),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0l0 ds_sc0l1]
        GHC.Base.pure $dApplicative_sc0l0 ds_sc0l1;

Data.Traversable.$fTraversableConst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall m.
     Data.Traversable.Traversable (Data.Functor.Const.Const m)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Functor.Const.$fFunctorConst
                                                   Data.Functor.Const.$fFoldableConst
                                                   Data.Traversable.$fTraversableConst_$ctraverse
                                                   $fTraversableConst1_rbWTU
                                                   Data.Traversable.$fTraversableConst_$cmapM
                                                   Data.Traversable.$fTraversableConst_$csequence];

Data.Traversable.$fTraversable(,)_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (f :: * -> *) a2.
     GHC.Base.Applicative f =>
     (a1, f a2) -> f (a1, a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0l2 eta_sc0l3]
        case eta_sc0l3 of {
          (,) x_sc0l5 [Occ=OnceL] y_sc0l6 [Occ=Once] ->
              let {
                sat_sc0l8 [Occ=Once] :: a1_abVWL -> (a_abVWj, a1_abVWL)
                [LclId] =
                    [x_sc0l5] \r [eta_B1] (,) [x_sc0l5 eta_B1];
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0l2 of sat_sc0l7 {
                  __DEFAULT -> GHC.Base.fmap sat_sc0l7 sat_sc0l8 y_sc0l6;
                };
        };

Data.Traversable.$fTraversable(,)_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2 b.
     GHC.Base.Monad m =>
     (a2 -> m b) -> (a1, a2) -> m (a1, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0l9 eta_sc0la eta1_sc0lb]
        case eta1_sc0lb of {
          (,) x_sc0ld [Occ=OnceL] y_sc0le [Occ=Once] ->
              let {
                sat_sc0li [Occ=Once] :: m_abVWW b_abVWY
                [LclId] =
                    [eta_sc0la y_sc0le] \u [] eta_sc0la y_sc0le; } in
              let {
                sat_sc0lh [Occ=Once] :: b_abVWY -> (a_abVWj, b_abVWY)
                [LclId] =
                    [x_sc0ld] \r [eta_B1] (,) [x_sc0ld eta_B1];
              } in 
                case GHC.Base.$p1Monad $dMonad_sc0l9 of sat_sc0lf {
                  __DEFAULT ->
                      case GHC.Base.$p1Applicative sat_sc0lf of sat_sc0lg {
                        __DEFAULT -> GHC.Base.fmap sat_sc0lg sat_sc0lh sat_sc0li;
                      };
                };
        };

Data.Traversable.$fTraversable(,)_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2.
     GHC.Base.Monad m =>
     (a1, m a2) -> m (a1, a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0lj eta_sc0lk]
        case eta_sc0lk of {
          (,) x_sc0lm [Occ=OnceL] y_sc0ln [Occ=Once] ->
              let {
                sat_sc0lq [Occ=Once] :: a1_abVXb -> (a_abVWj, a1_abVXb)
                [LclId] =
                    [x_sc0lm] \r [eta_B1] (,) [x_sc0lm eta_B1];
              } in 
                case GHC.Base.$p1Monad $dMonad_sc0lj of sat_sc0lo {
                  __DEFAULT ->
                      case GHC.Base.$p1Applicative sat_sc0lo of sat_sc0lp {
                        __DEFAULT -> GHC.Base.fmap sat_sc0lp sat_sc0lq y_sc0ln;
                      };
                };
        };

Data.Traversable.$fTraversable(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Traversable.Traversable ((,) a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Base.$fFunctor(,)
                                                   Data.Foldable.$fFoldable(,)
                                                   Data.Traversable.$fTraversable(,)_$ctraverse
                                                   Data.Traversable.$fTraversable(,)_$csequenceA
                                                   Data.Traversable.$fTraversable(,)_$cmapM
                                                   Data.Traversable.$fTraversable(,)_$csequence];

Data.Traversable.$fTraversableEither_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (f :: * -> *) a2.
     GHC.Base.Applicative f =>
     Data.Either.Either a1 (f a2) -> f (Data.Either.Either a1 a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0lr eta_sc0ls]
        case eta_sc0ls of {
          Data.Either.Left x_sc0lu [Occ=Once] ->
              GHC.Base.pure $dApplicative_sc0lr wild_sc0lt;
          Data.Either.Right y_sc0lw [Occ=Once] ->
              case GHC.Base.$p1Applicative $dApplicative_sc0lr of sat_sc0lx {
                __DEFAULT -> GHC.Base.fmap sat_sc0lx Data.Either.Right y_sc0lw;
              };
        };

Data.Traversable.$fTraversableEither_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2 b.
     GHC.Base.Monad m =>
     (a2 -> m b)
     -> Data.Either.Either a1 a2 -> m (Data.Either.Either a1 b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0ly eta_sc0lz eta1_sc0lA]
        case GHC.Base.$p1Monad $dMonad_sc0ly of sat_sc0lB {
          __DEFAULT ->
              Data.Traversable.$fTraversableEither_$ctraverse
                  sat_sc0lB eta_sc0lz eta1_sc0lA;
        };

Data.Traversable.$fTraversableEither_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall a1 (m :: * -> *) a2.
     GHC.Base.Monad m =>
     Data.Either.Either a1 (m a2) -> m (Data.Either.Either a1 a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0lC eta_sc0lD]
        case eta_sc0lD of {
          Data.Either.Left x_sc0lF [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0lC of sat_sc0lG {
                __DEFAULT -> GHC.Base.pure sat_sc0lG wild_sc0lE;
              };
          Data.Either.Right y_sc0lI [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0lC of sat_sc0lJ {
                __DEFAULT ->
                    case GHC.Base.$p1Applicative sat_sc0lJ of sat_sc0lK {
                      __DEFAULT -> GHC.Base.fmap sat_sc0lK Data.Either.Right y_sc0lI;
                    };
              };
        };

Data.Traversable.$fTraversableEither [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Data.Traversable.Traversable (Data.Either.Either a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Either.$fFunctorEither
                                                   Data.Foldable.$fFoldableEither
                                                   Data.Traversable.$fTraversableEither_$ctraverse
                                                   Data.Traversable.$fTraversableEither_$csequenceA
                                                   Data.Traversable.$fTraversableEither_$cmapM
                                                   Data.Traversable.$fTraversableEither_$csequence];

Data.Traversable.$fTraversable[]_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a. GHC.Base.Applicative f => [f a] -> f [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(A,1*C1(U),A,C(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0lL]
        let {
          z_sc0lM [Occ=OnceL] :: f_abW0j [a_abW0k]
          [LclId] =
              [$dApplicative_sc0lL] \u []
                  GHC.Base.pure $dApplicative_sc0lL GHC.Types.[]; } in
        let {
          go_sc0lN [Occ=LoopBreaker]
            :: [f_abW0j a_abW0k] -> f_abW0j [a_abW0k]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [$dApplicative_sc0lL z_sc0lM go_sc0lN] \r [ds_sc0lO]
                  case ds_sc0lO of {
                    [] -> z_sc0lM;
                    : y_sc0lQ [Occ=Once] ys_sc0lR [Occ=Once] ->
                        let {
                          sat_sc0lS [Occ=Once] :: f_abW0j [a_abW0k]
                          [LclId] =
                              [go_sc0lN ys_sc0lR] \u [] go_sc0lN ys_sc0lR;
                        } in 
                          GHC.Base.liftA2 $dApplicative_sc0lL GHC.Types.: y_sc0lQ sat_sc0lS;
                  };
        } in  go_sc0lN;

Data.Traversable.$fTraversable[]_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> [a] -> m [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0lT eta_sc0lU]
        let {
          $dApplicative_sc0lV [Dmd=<L,U(A,1*C1(U),A,C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative m_abW0v
          [LclId] =
              [$dMonad_sc0lT] \u [] GHC.Base.$p1Monad $dMonad_sc0lT; } in
        let {
          z_sc0lW [Occ=OnceL] :: m_abW0v [b_abW0x]
          [LclId] =
              [$dApplicative_sc0lV] \u []
                  GHC.Base.pure $dApplicative_sc0lV GHC.Types.[]; } in
        let {
          go_sc0lX [Occ=LoopBreaker] :: [a_abW0w] -> m_abW0v [b_abW0x]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [eta_sc0lU $dApplicative_sc0lV z_sc0lW go_sc0lX] \r [ds_sc0lY]
                  case ds_sc0lY of {
                    [] -> z_sc0lW;
                    : y_sc0m0 [Occ=Once] ys_sc0m1 [Occ=Once] ->
                        let {
                          sat_sc0m3 [Occ=Once] :: m_abW0v [b_abW0x]
                          [LclId] =
                              [go_sc0lX ys_sc0m1] \u [] go_sc0lX ys_sc0m1; } in
                        let {
                          sat_sc0m2 [Occ=Once] :: m_abW0v b_abW0x
                          [LclId] =
                              [eta_sc0lU y_sc0m0] \u [] eta_sc0lU y_sc0m0;
                        } in 
                          GHC.Base.liftA2
                              $dApplicative_sc0lV GHC.Types.: sat_sc0m2 sat_sc0m3;
                  };
        } in  go_sc0lX;

Data.Traversable.$fTraversable[]_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a. GHC.Base.Monad m => [m a] -> m [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(A,1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0m4]
        let {
          $dApplicative_sc0m5 [Dmd=<L,U(A,1*C1(U),A,C(C1(C1(U))),A,A)>]
            :: GHC.Base.Applicative m_abW0J
          [LclId] =
              [$dMonad_sc0m4] \u [] GHC.Base.$p1Monad $dMonad_sc0m4; } in
        let {
          z_sc0m6 [Occ=OnceL] :: m_abW0J [a_abW0K]
          [LclId] =
              [$dApplicative_sc0m5] \u []
                  GHC.Base.pure $dApplicative_sc0m5 GHC.Types.[]; } in
        let {
          go_sc0m7 [Occ=LoopBreaker]
            :: [m_abW0J a_abW0K] -> m_abW0J [a_abW0K]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [$dApplicative_sc0m5 z_sc0m6 go_sc0m7] \r [ds_sc0m8]
                  case ds_sc0m8 of {
                    [] -> z_sc0m6;
                    : y_sc0ma [Occ=Once] ys_sc0mb [Occ=Once] ->
                        let {
                          sat_sc0mc [Occ=Once] :: m_abW0J [a_abW0K]
                          [LclId] =
                              [go_sc0m7 ys_sc0mb] \u [] go_sc0m7 ys_sc0mb;
                        } in 
                          GHC.Base.liftA2 $dApplicative_sc0m5 GHC.Types.: y_sc0ma sat_sc0mc;
                  };
        } in  go_sc0m7;

Data.Traversable.$fTraversable[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable []
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Base.$fFunctor[]
                                                   Data.Foldable.$fFoldable[]
                                                   Data.Traversable.$fTraversable[]_$ctraverse
                                                   Data.Traversable.$fTraversable[]_$csequenceA
                                                   Data.Traversable.$fTraversable[]_$cmapM
                                                   Data.Traversable.$fTraversable[]_$csequence];

Data.Traversable.$fTraversableZipList1 :: forall b. [b] -> [b]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sc0md] v_sc0md;

Data.Traversable.$fTraversableZipList_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b)
     -> Control.Applicative.ZipList a
     -> f (Control.Applicative.ZipList b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A)><L,C(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0me eta_sc0mf eta1_sc0mg]
        let {
          sat_sc0mq [Occ=Once] :: f_abVMK [b_abVMM]
          [LclId] =
              [$dApplicative_sc0me eta_sc0mf eta1_sc0mg] \u []
                  let {
                    z_sc0mi [Occ=OnceL] :: f_abVMK [b_abVMM]
                    [LclId] =
                        [$dApplicative_sc0me] \u []
                            GHC.Base.pure $dApplicative_sc0me GHC.Types.[]; } in
                  let {
                    go_sc0mj [Occ=LoopBreaker] :: [a_abVML] -> f_abVMK [b_abVMM]
                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                        sat-only [$dApplicative_sc0me
                                  eta_sc0mf
                                  z_sc0mi
                                  go_sc0mj] \r [ds_sc0mk]
                            case ds_sc0mk of {
                              [] -> z_sc0mi;
                              : y_sc0mm [Occ=Once] ys_sc0mn [Occ=Once] ->
                                  let {
                                    sat_sc0mp [Occ=Once] :: f_abVMK [b_abVMM]
                                    [LclId] =
                                        [go_sc0mj ys_sc0mn] \u [] go_sc0mj ys_sc0mn; } in
                                  let {
                                    sat_sc0mo [Occ=Once] :: f_abVMK b_abVMM
                                    [LclId] =
                                        [eta_sc0mf y_sc0mm] \u [] eta_sc0mf y_sc0mm;
                                  } in 
                                    GHC.Base.liftA2
                                        $dApplicative_sc0me GHC.Types.: sat_sc0mo sat_sc0mp;
                            };
                  } in  go_sc0mj eta1_sc0mg;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0me of sat_sc0mh {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sc0mh Data.Traversable.$fTraversableZipList1 sat_sc0mq;
          };

Data.Traversable.$fTraversableZipList_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Control.Applicative.ZipList (f a)
     -> f (Control.Applicative.ZipList a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0mr eta_B1]
        Data.Traversable.$fTraversableZipList_$ctraverse
            $dApplicative_sc0mr GHC.Base.id eta_B1;

Data.Traversable.$fTraversableZipList_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b)
     -> Control.Applicative.ZipList a
     -> m (Control.Applicative.ZipList b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0ms eta_sc0mt eta1_sc0mu]
        case GHC.Base.$p1Monad $dMonad_sc0ms of sat_sc0mv {
          __DEFAULT ->
              Data.Traversable.$fTraversableZipList_$ctraverse
                  sat_sc0mv eta_sc0mt eta1_sc0mu;
        };

Data.Traversable.$fTraversableZipList_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Control.Applicative.ZipList (m a)
     -> m (Control.Applicative.ZipList a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0mw eta_sc0mx]
        case GHC.Base.$p1Monad $dMonad_sc0mw of sat_sc0my {
          __DEFAULT ->
              Data.Traversable.$fTraversableZipList_$ctraverse
                  sat_sc0my GHC.Base.id eta_sc0mx;
        };

Data.Traversable.$fTraversableZipList [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Control.Applicative.ZipList
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Control.Applicative.$fFunctorZipList
                                                   Control.Applicative.$fFoldableZipList
                                                   Data.Traversable.$fTraversableZipList_$ctraverse
                                                   Data.Traversable.$fTraversableZipList_$csequenceA
                                                   Data.Traversable.$fTraversableZipList_$cmapM
                                                   Data.Traversable.$fTraversableZipList_$csequence];

Data.Traversable.$fTraversableArray_$ctraverse
  :: forall i.
     GHC.Arr.Ix i =>
     forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Arr.Array i a -> f (GHC.Arr.Array i b)
[GblId,
 Arity=4,
 Str=<L,U(A,A,A,A,A,C(U(U)),A)><S(S(C(C(S))L)LLLLL),U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A)><L,C(U)><L,U(U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIx_sc0mz $dApplicative_sc0mA eta_sc0mB eta1_sc0mC]
        let {
          sat_sc0mX [Occ=Once] :: f_abVVc [b_abVVe]
          [LclId] =
              [$dApplicative_sc0mA eta_sc0mB eta1_sc0mC] \u []
                  case eta1_sc0mC of {
                    GHC.Arr.Array _ [Occ=Dead]
                                  _ [Occ=Dead]
                                  dt_sc0mJ [Occ=Once]
                                  ds2_sc0mK [Occ=OnceL] ->
                        case -# [dt_sc0mJ 1#] of y_sc0mL [Dmd=<S,U>] {
                          __DEFAULT ->
                              let {
                                n_sc0mM [Occ=OnceL*] :: f_abVVc [b_abVVe]
                                [LclId] =
                                    [$dApplicative_sc0mA] \u []
                                        GHC.Base.pure $dApplicative_sc0mA GHC.Types.[];
                              } in 
                                case ># [0# y_sc0mL] of {
                                  __DEFAULT ->
                                      let {
                                        go_sc0mO [Occ=LoopBreaker]
                                          :: GHC.Prim.Int# -> f_abVVc [b_abVVe]
                                        [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                                            sat-only [$dApplicative_sc0mA
                                                      eta_sc0mB
                                                      ds2_sc0mK
                                                      y_sc0mL
                                                      n_sc0mM
                                                      go_sc0mO] \r [x_sc0mP]
                                                let {
                                                  sat_sc0mW [Occ=Once] :: f_abVVc [b_abVVe]
                                                  [LclId] =
                                                      [y_sc0mL n_sc0mM go_sc0mO x_sc0mP] \u []
                                                          case ==# [x_sc0mP y_sc0mL] of {
                                                            __DEFAULT ->
                                                                case +# [x_sc0mP 1#] of sat_sc0mV {
                                                                  __DEFAULT -> go_sc0mO sat_sc0mV;
                                                                };
                                                            1# -> n_sc0mM;
                                                          }; } in
                                                let {
                                                  sat_sc0mT [Occ=Once] :: f_abVVc b_abVVe
                                                  [LclId] =
                                                      [eta_sc0mB ds2_sc0mK x_sc0mP] \u []
                                                          let {
                                                            sat_sc0mS [Occ=Once] :: a_abVVd
                                                            [LclId] =
                                                                [ds2_sc0mK x_sc0mP] \u []
                                                                    case
                                                                        indexArray# [ds2_sc0mK
                                                                                     x_sc0mP]
                                                                    of
                                                                    { Unit# ipv_sc0mR [Occ=Once] ->
                                                                          ipv_sc0mR;
                                                                    };
                                                          } in  eta_sc0mB sat_sc0mS;
                                                } in 
                                                  GHC.Base.liftA2
                                                      $dApplicative_sc0mA
                                                      GHC.Types.:
                                                      sat_sc0mT
                                                      sat_sc0mW;
                                      } in  go_sc0mO 0#;
                                  1# -> n_sc0mM;
                                };
                        };
                  }; } in
        let {
          sat_sc0mE [Occ=OnceL] :: (i_abVUZ, i_abVUZ)
          [LclId] =
              [eta1_sc0mC] \u [] GHC.Arr.bounds eta1_sc0mC; } in
        let {
          sat_sc0mF [Occ=Once] :: [b_abVVe] -> GHC.Arr.Array i_abVUZ b_abVVe
          [LclId] =
              [$dIx_sc0mz sat_sc0mE] \r [eta_B1]
                  GHC.Arr.listArray $dIx_sc0mz sat_sc0mE eta_B1;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0mA of sat_sc0mD {
            __DEFAULT -> GHC.Base.fmap sat_sc0mD sat_sc0mF sat_sc0mX;
          };

Data.Traversable.$fTraversableArray_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall i.
     GHC.Arr.Ix i =>
     forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Arr.Array i (f a) -> f (GHC.Arr.Array i a)
[GblId,
 Arity=3,
 Str=<L,U(A,A,A,A,A,C(U(U)),A)><L,U(U(C(C1(U)),A),C(U),A,C(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIx_sc0mY $dApplicative_sc0mZ eta_B1]
        Data.Traversable.$fTraversableArray_$ctraverse
            $dIx_sc0mY $dApplicative_sc0mZ GHC.Base.id eta_B1;

Data.Traversable.$fTraversableArray_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall i.
     GHC.Arr.Ix i =>
     forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Arr.Array i a -> m (GHC.Arr.Array i b)
[GblId,
 Arity=4,
 Str=<L,U(A,A,A,A,A,C(U(U)),A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><L,U(U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIx_sc0n0 $dMonad_sc0n1 eta_sc0n2 eta1_sc0n3]
        case GHC.Base.$p1Monad $dMonad_sc0n1 of sat_sc0n4 {
          __DEFAULT ->
              Data.Traversable.$fTraversableArray_$ctraverse
                  $dIx_sc0n0 sat_sc0n4 eta_sc0n2 eta1_sc0n3;
        };

Data.Traversable.$fTraversableArray_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall i.
     GHC.Arr.Ix i =>
     forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Arr.Array i (m a) -> m (GHC.Arr.Array i a)
[GblId,
 Arity=3,
 Str=<L,U(A,A,A,A,A,C(U(U)),A)><S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,U(U,U,U,U)>,
 Unf=OtherCon []] =
    [] \r [$dIx_sc0n5 $dMonad_sc0n6 eta_sc0n7]
        case GHC.Base.$p1Monad $dMonad_sc0n6 of sat_sc0n8 {
          __DEFAULT ->
              Data.Traversable.$fTraversableArray_$ctraverse
                  $dIx_sc0n5 sat_sc0n8 GHC.Base.id eta_sc0n7;
        };

Data.Traversable.$fTraversableArray [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i.
     GHC.Arr.Ix i =>
     Data.Traversable.Traversable (GHC.Arr.Array i)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,A,A,A,C(U(U)),A)>m] =
    [] \r [$dIx_sc0n9]
        let {
          sat_sc0nd [Occ=Once]
            :: forall (m :: * -> *) a.
               GHC.Base.Monad m =>
               GHC.Arr.Array i_abVUZ (m a) -> m (GHC.Arr.Array i_abVUZ a)
          [LclId] =
              [$dIx_sc0n9] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableArray_$csequence
                      $dIx_sc0n9 eta_B2 eta_B1; } in
        let {
          sat_sc0nc [Occ=Once]
            :: forall (m :: * -> *) a b.
               GHC.Base.Monad m =>
               (a -> m b)
               -> GHC.Arr.Array i_abVUZ a -> m (GHC.Arr.Array i_abVUZ b)
          [LclId] =
              [$dIx_sc0n9] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableArray_$cmapM
                      $dIx_sc0n9 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sc0nb [Occ=Once]
            :: forall (f :: * -> *) a.
               GHC.Base.Applicative f =>
               GHC.Arr.Array i_abVUZ (f a) -> f (GHC.Arr.Array i_abVUZ a)
          [LclId] =
              [$dIx_sc0n9] \r [eta_B2 eta_B1]
                  Data.Traversable.$fTraversableArray_$csequenceA
                      $dIx_sc0n9 eta_B2 eta_B1; } in
        let {
          sat_sc0na [Occ=Once]
            :: forall (f :: * -> *) a b.
               GHC.Base.Applicative f =>
               (a -> f b)
               -> GHC.Arr.Array i_abVUZ a -> f (GHC.Arr.Array i_abVUZ b)
          [LclId] =
              [$dIx_sc0n9] \r [eta_B3 eta_B2 eta_B1]
                  Data.Traversable.$fTraversableArray_$ctraverse
                      $dIx_sc0n9 eta_B3 eta_B2 eta_B1;
        } in 
          Data.Traversable.C:Traversable [GHC.Arr.$fFunctorArray
                                          Data.Foldable.$fFoldableArray
                                          sat_sc0na
                                          sat_sc0nb
                                          sat_sc0nc
                                          sat_sc0nd];

Data.Traversable.$fTraversableNonEmpty_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> GHC.Base.NonEmpty a -> f (GHC.Base.NonEmpty b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(S)))LL),U(A,1*C1(U),A,C(C1(C1(U))),A,A)><L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0ne f1_sc0nf ds_sc0ng]
        let {
          sat_sc0nx [Occ=Once] :: f_abVYD [b_abVYF]
          [LclId] =
              [$dApplicative_sc0ne f1_sc0nf ds_sc0ng] \u []
                  case ds_sc0ng of {
                    GHC.Base.:| _ [Occ=Dead] as_sc0no [Occ=Once] ->
                        let {
                          z_sc0np [Occ=OnceL] :: f_abVYD [b_abVYF]
                          [LclId] =
                              [$dApplicative_sc0ne] \u []
                                  GHC.Base.pure $dApplicative_sc0ne GHC.Types.[]; } in
                        let {
                          go_sc0nq [Occ=LoopBreaker] :: [a_abVYE] -> f_abVYD [b_abVYF]
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [$dApplicative_sc0ne
                                        f1_sc0nf
                                        z_sc0np
                                        go_sc0nq] \r [ds1_sc0nr]
                                  case ds1_sc0nr of {
                                    [] -> z_sc0np;
                                    : y_sc0nt [Occ=Once] ys_sc0nu [Occ=Once] ->
                                        let {
                                          sat_sc0nw [Occ=Once] :: f_abVYD [b_abVYF]
                                          [LclId] =
                                              [go_sc0nq ys_sc0nu] \u [] go_sc0nq ys_sc0nu; } in
                                        let {
                                          sat_sc0nv [Occ=Once] :: f_abVYD b_abVYF
                                          [LclId] =
                                              [f1_sc0nf y_sc0nt] \u [] f1_sc0nf y_sc0nt;
                                        } in 
                                          GHC.Base.liftA2
                                              $dApplicative_sc0ne GHC.Types.: sat_sc0nv sat_sc0nw;
                                  };
                        } in  go_sc0nq as_sc0no;
                  }; } in
        let {
          sat_sc0nl [Occ=Once] :: f_abVYD b_abVYF
          [LclId] =
              [f1_sc0nf ds_sc0ng] \u []
                  let {
                    sat_sc0nk [Occ=Once] :: a_abVYE
                    [LclId] =
                        [ds_sc0ng] \u []
                            case ds_sc0ng of {
                              GHC.Base.:| a1_sc0ni [Occ=Once] _ [Occ=Dead] -> a1_sc0ni;
                            };
                  } in  f1_sc0nf sat_sc0nk;
        } in 
          GHC.Base.liftA2
              $dApplicative_sc0ne GHC.Base.:| sat_sc0nl sat_sc0nx;

Data.Traversable.$fTraversableNonEmpty_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Base.NonEmpty (f a) -> f (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,C(U),A,C(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0ny eta_B1]
        Data.Traversable.$fTraversableNonEmpty_$ctraverse
            $dApplicative_sc0ny GHC.Base.id eta_B1;

Data.Traversable.$fTraversableNonEmpty_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Base.NonEmpty a -> m (GHC.Base.NonEmpty b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(A,1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0nz eta_sc0nA eta1_sc0nB]
        case GHC.Base.$p1Monad $dMonad_sc0nz of sat_sc0nC {
          __DEFAULT ->
              Data.Traversable.$fTraversableNonEmpty_$ctraverse
                  sat_sc0nC eta_sc0nA eta1_sc0nB;
        };

Data.Traversable.$fTraversableNonEmpty_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Base.NonEmpty (m a) -> m (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(A,1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0nD eta_sc0nE]
        case GHC.Base.$p1Monad $dMonad_sc0nD of sat_sc0nF {
          __DEFAULT ->
              Data.Traversable.$fTraversableNonEmpty_$ctraverse
                  sat_sc0nF GHC.Base.id eta_sc0nE;
        };

Data.Traversable.$fTraversableNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable GHC.Base.NonEmpty
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Base.$fFunctorNonEmpty
                                                   Data.Foldable.$fFoldableNonEmpty
                                                   Data.Traversable.$fTraversableNonEmpty_$ctraverse
                                                   Data.Traversable.$fTraversableNonEmpty_$csequenceA
                                                   Data.Traversable.$fTraversableNonEmpty_$cmapM
                                                   Data.Traversable.$fTraversableNonEmpty_$csequence];

Data.Traversable.$fTraversableMaybe_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     GHC.Base.Maybe (f a) -> f (GHC.Base.Maybe a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0nG eta_sc0nH]
        case eta_sc0nH of {
          GHC.Base.Nothing ->
              GHC.Base.pure $dApplicative_sc0nG GHC.Base.Nothing;
          GHC.Base.Just x_sc0nJ [Occ=Once] ->
              case GHC.Base.$p1Applicative $dApplicative_sc0nG of sat_sc0nK {
                __DEFAULT -> GHC.Base.fmap sat_sc0nK GHC.Base.Just x_sc0nJ;
              };
        };

Data.Traversable.$fTraversableMaybe_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> GHC.Base.Maybe a -> m (GHC.Base.Maybe b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0nL eta_sc0nM eta1_sc0nN]
        case GHC.Base.$p1Monad $dMonad_sc0nL of sat_sc0nO {
          __DEFAULT ->
              Data.Traversable.$fTraversableFirst_$ctraverse
                  sat_sc0nO eta_sc0nM eta1_sc0nN;
        };

Data.Traversable.$fTraversableMaybe_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     GHC.Base.Maybe (m a) -> m (GHC.Base.Maybe a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0nP eta_sc0nQ]
        case eta_sc0nQ of {
          GHC.Base.Nothing ->
              case GHC.Base.$p1Monad $dMonad_sc0nP of sat_sc0nS {
                __DEFAULT -> GHC.Base.pure sat_sc0nS GHC.Base.Nothing;
              };
          GHC.Base.Just x_sc0nT [Occ=Once] ->
              case GHC.Base.$p1Monad $dMonad_sc0nP of sat_sc0nU {
                __DEFAULT ->
                    case GHC.Base.$p1Applicative sat_sc0nU of sat_sc0nV {
                      __DEFAULT -> GHC.Base.fmap sat_sc0nV GHC.Base.Just x_sc0nT;
                    };
              };
        };

Data.Traversable.$fTraversableMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable GHC.Base.Maybe
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [GHC.Base.$fFunctorMaybe
                                                   Data.Foldable.$fFoldableMaybe
                                                   Data.Traversable.$fTraversableFirst_$ctraverse
                                                   Data.Traversable.$fTraversableMaybe_$csequenceA
                                                   Data.Traversable.$fTraversableMaybe_$cmapM
                                                   Data.Traversable.$fTraversableMaybe_$csequence];

Data.Traversable.$fTraversableFirst1
  :: forall b. GHC.Base.Maybe b -> GHC.Base.Maybe b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sc0nW] v_sc0nW;

Data.Traversable.$fTraversableLast_$ctraverse
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Monoid.Last a -> f (Data.Monoid.Last b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0nX eta_sc0nY eta1_sc0nZ]
        let {
          sat_sc0o1 [Occ=Once] :: f_abVNQ (GHC.Base.Maybe b_abVNS)
          [LclId] =
              [$dApplicative_sc0nX eta_sc0nY eta1_sc0nZ] \u []
                  Data.Traversable.$fTraversableFirst_$ctraverse
                      $dApplicative_sc0nX eta_sc0nY eta1_sc0nZ;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0nX of sat_sc0o0 {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sc0o0 Data.Traversable.$fTraversableFirst1 sat_sc0o1;
          };

Data.Traversable.$fTraversableLast_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Monoid.Last (f a) -> f (Data.Monoid.Last a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0o2 eta_sc0o3]
        let {
          sat_sc0o8 [Occ=Once] :: f_abVOa (GHC.Base.Maybe a_abVOb)
          [LclId] =
              [$dApplicative_sc0o2 eta_sc0o3] \u []
                  case eta_sc0o3 of {
                    GHC.Base.Nothing ->
                        GHC.Base.pure $dApplicative_sc0o2 GHC.Base.Nothing;
                    GHC.Base.Just x_sc0o6 [Occ=Once] ->
                        case GHC.Base.$p1Applicative $dApplicative_sc0o2 of sat_sc0o7 {
                          __DEFAULT -> GHC.Base.fmap sat_sc0o7 GHC.Base.Just x_sc0o6;
                        };
                  };
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0o2 of sat_sc0o4 {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sc0o4 Data.Traversable.$fTraversableFirst1 sat_sc0o8;
          };

Data.Traversable.$fTraversableLast_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Monoid.Last a -> m (Data.Monoid.Last b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(C(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0o9 eta_sc0oa eta1_sc0ob]
        case
            GHC.Base.$p1Monad $dMonad_sc0o9
        of
        $dApplicative_sc0oc [Dmd=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              let {
                sat_sc0oe [Occ=Once] :: m_abVOm (GHC.Base.Maybe b_abVOo)
                [LclId] =
                    [eta_sc0oa eta1_sc0ob $dApplicative_sc0oc] \u []
                        Data.Traversable.$fTraversableFirst_$ctraverse
                            $dApplicative_sc0oc eta_sc0oa eta1_sc0ob;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0oc of sat_sc0od {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sc0od Data.Traversable.$fTraversableFirst1 sat_sc0oe;
                };
        };

Data.Traversable.$fTraversableLast_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Monoid.Last (m a) -> m (Data.Monoid.Last a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(C(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0of eta_sc0og]
        case
            GHC.Base.$p1Monad $dMonad_sc0of
        of
        $dApplicative_sc0oh [Dmd=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              let {
                sat_sc0om [Occ=Once] :: m_abVOA (GHC.Base.Maybe a_abVOB)
                [LclId] =
                    [eta_sc0og $dApplicative_sc0oh] \u []
                        case eta_sc0og of {
                          GHC.Base.Nothing ->
                              GHC.Base.pure $dApplicative_sc0oh GHC.Base.Nothing;
                          GHC.Base.Just x_sc0ok [Occ=Once] ->
                              case GHC.Base.$p1Applicative $dApplicative_sc0oh of sat_sc0ol {
                                __DEFAULT -> GHC.Base.fmap sat_sc0ol GHC.Base.Just x_sc0ok;
                              };
                        };
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0oh of sat_sc0oi {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sc0oi Data.Traversable.$fTraversableFirst1 sat_sc0om;
                };
        };

Data.Traversable.$fTraversableLast [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Monoid.Last
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Monoid.$fFunctorLast
                                                   Data.Foldable.$fFoldableLast
                                                   Data.Traversable.$fTraversableLast_$ctraverse
                                                   Data.Traversable.$fTraversableLast_$csequenceA
                                                   Data.Traversable.$fTraversableLast_$cmapM
                                                   Data.Traversable.$fTraversableLast_$csequence];

Data.Traversable.$fTraversableFirst_$ctraverse1
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> Data.Monoid.First a -> f (Data.Monoid.First b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)><L,1*C1(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0on eta_sc0oo eta1_sc0op]
        let {
          sat_sc0or [Occ=Once] :: f_abVOW (GHC.Base.Maybe b_abVOY)
          [LclId] =
              [$dApplicative_sc0on eta_sc0oo eta1_sc0op] \u []
                  Data.Traversable.$fTraversableFirst_$ctraverse
                      $dApplicative_sc0on eta_sc0oo eta1_sc0op;
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0on of sat_sc0oq {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sc0oq Data.Traversable.$fTraversableFirst1 sat_sc0or;
          };

Data.Traversable.$fTraversableFirst_$csequenceA [InlPrag=INLINE (sat-args=0)]
  :: forall (f :: * -> *) a.
     GHC.Base.Applicative f =>
     Data.Monoid.First (f a) -> f (Data.Monoid.First a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sc0os eta_sc0ot]
        let {
          sat_sc0oy [Occ=Once] :: f_abVPg (GHC.Base.Maybe a_abVPh)
          [LclId] =
              [$dApplicative_sc0os eta_sc0ot] \u []
                  case eta_sc0ot of {
                    GHC.Base.Nothing ->
                        GHC.Base.pure $dApplicative_sc0os GHC.Base.Nothing;
                    GHC.Base.Just x_sc0ow [Occ=Once] ->
                        case GHC.Base.$p1Applicative $dApplicative_sc0os of sat_sc0ox {
                          __DEFAULT -> GHC.Base.fmap sat_sc0ox GHC.Base.Just x_sc0ow;
                        };
                  };
        } in 
          case GHC.Base.$p1Applicative $dApplicative_sc0os of sat_sc0ou {
            __DEFAULT ->
                GHC.Base.fmap
                    sat_sc0ou Data.Traversable.$fTraversableFirst1 sat_sc0oy;
          };

Data.Traversable.$fTraversableFirst_$cmapM [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> Data.Monoid.First a -> m (Data.Monoid.First b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(C(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*C1(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0oz eta_sc0oA eta1_sc0oB]
        case
            GHC.Base.$p1Monad $dMonad_sc0oz
        of
        $dApplicative_sc0oC [Dmd=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              let {
                sat_sc0oE [Occ=Once] :: m_abVPs (GHC.Base.Maybe b_abVPu)
                [LclId] =
                    [eta_sc0oA eta1_sc0oB $dApplicative_sc0oC] \u []
                        Data.Traversable.$fTraversableFirst_$ctraverse
                            $dApplicative_sc0oC eta_sc0oA eta1_sc0oB;
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0oC of sat_sc0oD {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sc0oD Data.Traversable.$fTraversableFirst1 sat_sc0oE;
                };
        };

Data.Traversable.$fTraversableFirst_$csequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a.
     GHC.Base.Monad m =>
     Data.Monoid.First (m a) -> m (Data.Monoid.First a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(U(C(C1(U)),A),1*C1(U),A,A,A,A),A,A,A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sc0oF eta_sc0oG]
        case
            GHC.Base.$p1Monad $dMonad_sc0oF
        of
        $dApplicative_sc0oH [Dmd=<S(S(C(C(S))L)LLLLL),U(U(C(C1(U)),A),1*C1(U),A,A,A,A)>]
        { __DEFAULT ->
              let {
                sat_sc0oM [Occ=Once] :: m_abVPG (GHC.Base.Maybe a_abVPH)
                [LclId] =
                    [eta_sc0oG $dApplicative_sc0oH] \u []
                        case eta_sc0oG of {
                          GHC.Base.Nothing ->
                              GHC.Base.pure $dApplicative_sc0oH GHC.Base.Nothing;
                          GHC.Base.Just x_sc0oK [Occ=Once] ->
                              case GHC.Base.$p1Applicative $dApplicative_sc0oH of sat_sc0oL {
                                __DEFAULT -> GHC.Base.fmap sat_sc0oL GHC.Base.Just x_sc0oK;
                              };
                        };
              } in 
                case GHC.Base.$p1Applicative $dApplicative_sc0oH of sat_sc0oI {
                  __DEFAULT ->
                      GHC.Base.fmap
                          sat_sc0oI Data.Traversable.$fTraversableFirst1 sat_sc0oM;
                };
        };

Data.Traversable.$fTraversableFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Traversable.Traversable Data.Monoid.First
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE Data.Traversable.C:Traversable! [Data.Monoid.$fFunctorFirst
                                                   Data.Foldable.$fFoldableFirst
                                                   Data.Traversable.$fTraversableFirst_$ctraverse1
                                                   Data.Traversable.$fTraversableFirst_$csequenceA
                                                   Data.Traversable.$fTraversableFirst_$cmapM
                                                   Data.Traversable.$fTraversableFirst_$csequence];

Data.Traversable.$dmtraverse [InlPrag=INLINE (sat-args=1)]
  :: forall (t :: * -> *).
     Data.Traversable.Traversable t =>
     forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> f b) -> t a -> f (t b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*C1(C(U)),A),A,A,1*C1(C(U)),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0oN eta_sc0oO eta1_sc0oP]
        let {
          f1_sc0oQ [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_abVfw (f_abVtL b_abVtN) -> f_abVtL (t_abVfw b_abVtN)
          [LclId] =
              [$dTraversable_sc0oN eta_sc0oO] \u []
                  Data.Traversable.sequenceA $dTraversable_sc0oN eta_sc0oO; } in
        let {
          g_sc0oR [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_abVfw a_abVtM -> t_abVfw (f_abVtL b_abVtN)
          [LclId] =
              [$dTraversable_sc0oN eta1_sc0oP] \u []
                  case
                      Data.Traversable.$p1Traversable $dTraversable_sc0oN
                  of
                  sat_sc0oS
                  { __DEFAULT -> GHC.Base.fmap sat_sc0oS eta1_sc0oP;
                  }; } in
        let {
          sat_sc0oV [Occ=OnceT[0]]
            :: t_abVfw a_abVtM -> f_abVtL (t_abVfw b_abVtN)
          [LclId] =
              [f1_sc0oQ g_sc0oR] \r [x_sc0oT]
                  let {
                    sat_sc0oU [Occ=Once] :: t_abVfw (f_abVtL b_abVtN)
                    [LclId] =
                        [g_sc0oR x_sc0oT] \u [] g_sc0oR x_sc0oT;
                  } in  f1_sc0oQ sat_sc0oU;
        } in  sat_sc0oV;

Data.Traversable.for [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (f :: * -> *) a b.
     (Data.Traversable.Traversable t, GHC.Base.Applicative f) =>
     t a -> (a -> f b) -> f (t b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C(C1(U))),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0oW $dApplicative_sc0oX]
        let {
          f1_sc0oY [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: (a_abVtu -> f_abVtt b_abVtv)
               -> t_abVts a_abVtu -> f_abVtt (t_abVts b_abVtv)
          [LclId] =
              [$dTraversable_sc0oW $dApplicative_sc0oX] \u []
                  Data.Traversable.traverse
                      $dTraversable_sc0oW $dApplicative_sc0oX; } in
        let {
          sat_sc0p1 [Occ=OnceT[0]]
            :: t_abVts a_abVtu
               -> (a_abVtu -> f_abVtt b_abVtv) -> f_abVtt (t_abVts b_abVtv)
          [LclId] =
              [f1_sc0oY] \r [x_sc0oZ y_sc0p0] f1_sc0oY y_sc0p0 x_sc0oZ;
        } in  sat_sc0p1;

Data.Traversable.forM [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) (m :: * -> *) a b.
     (Data.Traversable.Traversable t, GHC.Base.Monad m) =>
     t a -> (a -> m b) -> m (t b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,1*C1(C(C1(U))),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0p2 $dMonad_sc0p3]
        let {
          f_sc0p4 [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: (a_abVtd -> m_abVtc b_abVte)
               -> t_abVtb a_abVtd -> m_abVtc (t_abVtb b_abVte)
          [LclId] =
              [$dTraversable_sc0p2 $dMonad_sc0p3] \u []
                  Data.Traversable.mapM $dTraversable_sc0p2 $dMonad_sc0p3; } in
        let {
          sat_sc0p7 [Occ=OnceT[0]]
            :: t_abVtb a_abVtd
               -> (a_abVtd -> m_abVtc b_abVte) -> m_abVtc (t_abVtb b_abVte)
          [LclId] =
              [f_sc0p4] \r [x_sc0p5 y_sc0p6] f_sc0p4 y_sc0p6 x_sc0p5;
        } in  sat_sc0p7;

Data.Traversable.mapAccumL
  :: forall (t :: * -> *) a b c.
     Data.Traversable.Traversable t =>
     (a -> b -> (a, c)) -> a -> t b -> (a, t c)
[GblId,
 Arity=4,
 Str=<S(LLC(C(C(S)))LLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0p8 f_sc0p9 s_sc0pa t1_sc0pb]
        let {
          sat_sc0pe [Occ=Once]
            :: b_abVsM -> Data.Functor.Utils.StateL a_abVsL c_abVsN
          [LclId] =
              [f_sc0p9] \r [x_sc0pc y_sc0pd] f_sc0p9 y_sc0pd x_sc0pc;
        } in 
          Data.Traversable.traverse
              $dTraversable_sc0p8
              Data.Functor.Utils.$fApplicativeStateL
              sat_sc0pe
              t1_sc0pb
              s_sc0pa;

Data.Traversable.mapAccumR
  :: forall (t :: * -> *) a b c.
     Data.Traversable.Traversable t =>
     (a -> b -> (a, c)) -> a -> t b -> (a, t c)
[GblId,
 Arity=4,
 Str=<S(LLC(C(C(S)))LLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dTraversable_sc0pf f_sc0pg s_sc0ph t1_sc0pi]
        let {
          sat_sc0pl [Occ=Once]
            :: b_abVsl -> Data.Functor.Utils.StateR a_abVsk c_abVsm
          [LclId] =
              [f_sc0pg] \r [x_sc0pj y_sc0pk] f_sc0pg y_sc0pk x_sc0pj;
        } in 
          Data.Traversable.traverse
              $dTraversable_sc0pf
              Data.Functor.Utils.$fApplicativeStateR
              sat_sc0pl
              t1_sc0pi
              s_sc0ph;

fmapDefault1_rbWTV
  :: forall (t :: * -> *) a b.
     Data.Traversable.Traversable t =>
     (a -> Data.Functor.Identity.Identity b)
     -> t a -> Data.Functor.Identity.Identity (t b)
[GblId,
 Arity=1,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)>,
 Unf=OtherCon []] =
    sat-only [] \r [$dTraversable_sc0pm]
        Data.Traversable.traverse
            $dTraversable_sc0pm Data.Functor.Identity.$fApplicativeIdentity;

Data.Traversable.fmapDefault [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) a b.
     Data.Traversable.Traversable t =>
     (a -> b) -> t a -> t b
[GblId,
 Arity=1,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] fmapDefault1_rbWTV eta_B1;

foldMapDefault1_rbWTW
  :: forall (t :: * -> *) m a.
     (Data.Traversable.Traversable t, GHC.Base.Monoid m) =>
     (a -> Data.Functor.Const.Const m ())
     -> t a -> Data.Functor.Const.Const m (t ())
[GblId,
 Arity=2,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)><L,U(A,U,U,A)>,
 Unf=OtherCon []] =
    sat-only [] \r [$dTraversable_sc0pn $dMonoid_sc0po]
        let {
          sat_sc0pp [Occ=Once]
            :: GHC.Base.Applicative (Data.Functor.Const.Const m_abVrr)
          [LclId] =
              [$dMonoid_sc0po] \u []
                  Data.Functor.Const.$fApplicativeConst $dMonoid_sc0po;
        } in  Data.Traversable.traverse $dTraversable_sc0pn sat_sc0pp;

Data.Traversable.foldMapDefault [InlPrag=INLINE (sat-args=0)]
  :: forall (t :: * -> *) m a.
     (Data.Traversable.Traversable t, GHC.Base.Monoid m) =>
     (a -> m) -> t a -> m
[GblId,
 Arity=2,
 Str=<S(LLC(S)LLL),1*U(A,A,1*C1(U),A,A,A)><L,U(A,U,U,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] foldMapDefault1_rbWTW eta_B2 eta_B1;

Data.Traversable.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Traversable.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Traversable.$trModule4];

Data.Traversable.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Traversable"#;

Data.Traversable.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Traversable.$trModule2];

Data.Traversable.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Traversable.$trModule3
                                     Data.Traversable.$trModule1];

$krep_rbWTX :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Traversable.$tcTraversable1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep_rbWTX];

Data.Traversable.$tcTraversable3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Traversable"#;

Data.Traversable.$tcTraversable2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Traversable.$tcTraversable3];

Data.Traversable.$tcTraversable :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9002450311536760373##
                                    4172295783860716183##
                                    Data.Traversable.$trModule
                                    Data.Traversable.$tcTraversable2
                                    0#
                                    Data.Traversable.$tcTraversable1];

Data.Traversable.C:Traversable
  :: forall (t :: * -> *).
     (GHC.Base.Functor t, Data.Foldable.Foldable t) =>
     (forall (f :: * -> *) a b.
      GHC.Base.Applicative f =>
      (a -> f b) -> t a -> f (t b))
     -> (forall (f :: * -> *) a.
         GHC.Base.Applicative f =>
         t (f a) -> f (t a))
     -> (forall (m :: * -> *) a b.
         GHC.Base.Monad m =>
         (a -> m b) -> t a -> m (t b))
     -> (forall (m :: * -> *) a. GHC.Base.Monad m => t (m a) -> m (t a))
     -> Data.Traversable.Traversable t
[GblId[DataCon],
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Traversable.C:Traversable [eta_B6
                                        eta_B5
                                        eta_B4
                                        eta_B3
                                        eta_B2
                                        eta_B1];

