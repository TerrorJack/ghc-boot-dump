
==================== Tidy Core ====================
2018-03-16 16:11:45.224388535 UTC

Result size of Tidy Core
  = {terms: 433, types: 862, coercions: 118, joins: 0/4}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Void.$fIxVoid1 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Void.$fIxVoid1 = GHC.Types.I# 0#

-- RHS size: {terms: 2, types: 3, coercions: 0, joins: 0/0}
Data.Void.$fIxVoid_$crangeSize :: (Void, Void) -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Void.$fIxVoid1}]
Data.Void.$fIxVoid_$crangeSize
  = \ _ [Occ=Dead] -> Data.Void.$fIxVoid1

-- RHS size: {terms: 2, types: 4, coercions: 0, joins: 0/0}
Data.Void.$fIxVoid_$crange :: (Void, Void) -> [Void]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Types.[] @ Void}]
Data.Void.$fIxVoid_$crange = \ _ [Occ=Dead] -> GHC.Types.[] @ Void

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
Data.Void.$fSemigroupVoid_$cstimes
  :: forall b. Integral b => b -> Void -> Void
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_afVEm)
                 ($dIntegral_afVEo [Occ=Once] :: Integral b_afVEm) ->
                 stimesIdempotent @ b_afVEm @ Void $dIntegral_afVEo}]
Data.Void.$fSemigroupVoid_$cstimes
  = \ (@ b_afVEm) ($dIntegral_afVEo :: Integral b_afVEm) ->
      stimesIdempotent @ b_afVEm @ Void $dIntegral_afVEo

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Void.$fOrdVoid_$c<> :: Void -> Void -> Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (a_afVwT [Occ=Once] :: Void) _ [Occ=Dead] -> a_afVwT}]
Data.Void.$fOrdVoid_$c<>
  = \ (a_afVwT :: Void) _ [Occ=Dead] -> a_afVwT

-- RHS size: {terms: 8, types: 9, coercions: 0, joins: 0/0}
Data.Void.$fSemigroupVoid_$csconcat
  :: GHC.Base.NonEmpty Void -> Void
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_i9in9 [Occ=Once!] :: GHC.Base.NonEmpty Void) ->
                 case ds_i9in9 of
                 { GHC.Base.:| a1_i9ing [Occ=Once] as_i9inh [Occ=Once] ->
                 case as_i9inh of { __DEFAULT -> a1_i9ing }
                 }}]
Data.Void.$fSemigroupVoid_$csconcat
  = \ (ds_i9in9 :: GHC.Base.NonEmpty Void) ->
      case ds_i9in9 of { GHC.Base.:| a1_i9ing as_i9inh ->
      case as_i9inh of { __DEFAULT -> a1_i9ing }
      }

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
Data.Void.$fSemigroupVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: Semigroup Void
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Semigroup TYPE: Void
                            Data.Void.$fOrdVoid_$c<>
                            Data.Void.$fSemigroupVoid_$csconcat
                            Data.Void.$fSemigroupVoid_$cstimes]
Data.Void.$fSemigroupVoid
  = GHC.Base.C:Semigroup
      @ Void
      Data.Void.$fOrdVoid_$c<>
      Data.Void.$fSemigroupVoid_$csconcat
      Data.Void.$fSemigroupVoid_$cstimes

-- RHS size: {terms: 4, types: 3, coercions: 0, joins: 0/0}
Data.Void.$fShowVoid_$cshowsPrec :: Int -> Void -> ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ _ [Occ=Dead] (z_afVya [Occ=Once] :: Void) ->
                 case z_afVya of { }}]
Data.Void.$fShowVoid_$cshowsPrec
  = \ _ [Occ=Dead] (z_afVya :: Void) -> case z_afVya of { }

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Void.$fExceptionVoid_$cshow :: Void -> String
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<B,1*U>b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i7Jay [Occ=Once] :: Void) -> case x_i7Jay of { }}]
Data.Void.$fExceptionVoid_$cshow
  = \ (x_i7Jay :: Void) -> case x_i7Jay of { }

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Void.$fShowVoid1 :: Void -> ShowS
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<B,1*U>b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (z_afVya [Occ=Once] :: Void) -> case z_afVya of { }}]
Data.Void.$fShowVoid1 = \ (z_afVya :: Void) -> case z_afVya of { }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
Data.Void.$fShowVoid_$cshowList :: [Void] -> ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7JaB [Occ=Once] :: [Void])
                 (s_i7JaC [Occ=Once] :: String) ->
                 GHC.Show.showList__ @ Void Data.Void.$fShowVoid1 ls_i7JaB s_i7JaC}]
Data.Void.$fShowVoid_$cshowList
  = \ (ls_i7JaB :: [Void]) (s_i7JaC :: String) ->
      GHC.Show.showList__ @ Void Data.Void.$fShowVoid1 ls_i7JaB s_i7JaC

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
Data.Void.$fShowVoid [InlPrag=NOUSERINLINE CONLIKE] :: Show Void
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: Void
                       Data.Void.$fShowVoid_$cshowsPrec
                       Data.Void.$fExceptionVoid_$cshow
                       Data.Void.$fShowVoid_$cshowList]
Data.Void.$fShowVoid
  = GHC.Show.C:Show
      @ Void
      Data.Void.$fShowVoid_$cshowsPrec
      Data.Void.$fExceptionVoid_$cshow
      Data.Void.$fShowVoid_$cshowList

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
Data.Void.$fReadVoid2 :: ReadS Void
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
Data.Void.$fReadVoid2
  = Text.ParserCombinators.ReadP.run
      @ Void (Text.ParserCombinators.ReadP.Fail @ Void)

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Void.$fReadVoid_$creadsPrec :: Int -> ReadS Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Void.$fReadVoid2}]
Data.Void.$fReadVoid_$creadsPrec
  = \ _ [Occ=Dead] -> Data.Void.$fReadVoid2

-- RHS size: {terms: 2, types: 2, coercions: 9, joins: 0/0}
Data.Void.$fReadVoid_$creadListPrec
  :: Text.ParserCombinators.ReadPrec.ReadPrec [Void]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
Data.Void.$fReadVoid_$creadListPrec
  = GHC.Read.list
      @ Void
      ((Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4 @ Void)
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Void>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                    <Void>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Void -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Void :: *)))

-- RHS size: {terms: 3, types: 4, coercions: 6, joins: 0/0}
Data.Void.$fReadVoid1 :: Text.ParserCombinators.ReadP.P [Void]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
Data.Void.$fReadVoid1
  = (((Data.Void.$fReadVoid_$creadListPrec
       `cast` (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <[Void]>_R
               :: (Text.ParserCombinators.ReadPrec.ReadPrec [Void] :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.Prec
                       -> Text.ParserCombinators.ReadP.ReadP [Void] :: *)))
        GHC.Read.$fRead()7)
     `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <[Void]>_R
             :: (Text.ParserCombinators.ReadP.ReadP [Void] :: *)
                ~R# (forall b.
                     ([Void] -> Text.ParserCombinators.ReadP.P b)
                     -> Text.ParserCombinators.ReadP.P b :: *)))
      @ [Void]
      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure @ [Void])

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
Data.Void.$fReadVoid_$creadList :: ReadS [Void]
[GblId,
 Arity=1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
Data.Void.$fReadVoid_$creadList
  = Text.ParserCombinators.ReadP.run @ [Void] Data.Void.$fReadVoid1

-- RHS size: {terms: 5, types: 2, coercions: 9, joins: 0/0}
Data.Void.$fReadVoid [InlPrag=NOUSERINLINE CONLIKE] :: Read Void
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: Void
                       Data.Void.$fReadVoid_$creadsPrec
                       Data.Void.$fReadVoid_$creadList
                       (Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4 @ Void)
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Void>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                    <Void>_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Void -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Void :: *))
                       Data.Void.$fReadVoid_$creadListPrec]
Data.Void.$fReadVoid
  = GHC.Read.C:Read
      @ Void
      Data.Void.$fReadVoid_$creadsPrec
      Data.Void.$fReadVoid_$creadList
      ((Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4 @ Void)
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Void>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                    <Void>_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Void -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec Void :: *)))
      Data.Void.$fReadVoid_$creadListPrec

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Void.$fOrdVoid_$ccompare :: Void -> Void -> Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.EQ}]
Data.Void.$fOrdVoid_$ccompare
  = \ _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.EQ

-- RHS size: {terms: 4, types: 8, coercions: 16, joins: 0/0}
Data.Void.$fGenericVoid_$cto :: forall x. Rep Void x -> Void
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<B,1*U>b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ x_afVCz) (ds_dfVH4 [Occ=Once] :: Rep Void x_afVCz) ->
                 case ds_dfVH4
                      `cast` ((Sub (Data.Void.Rep_Void[0]) ; GHC.Generics.N:M1[0]
                                                                 <*>_N
                                                                 <D>_P
                                                                 <'MetaData
                                                                    "Void"
                                                                    "Data.Void"
                                                                    "base"
                                                                    'False>_P
                                                                 <V1>_R) <x_afVCz>_N
                              :: (Rep Void x_afVCz :: *) ~R# (V1 x_afVCz :: *))
                 of {
                 }}]
Data.Void.$fGenericVoid_$cto
  = \ (@ x_afVCz) (ds_dfVH4 :: Rep Void x_afVCz) ->
      case ds_dfVH4
           `cast` ((Sub (Data.Void.Rep_Void[0]) ; GHC.Generics.N:M1[0]
                                                      <*>_N
                                                      <D>_P
                                                      <'MetaData "Void" "Data.Void" "base" 'False>_P
                                                      <V1>_R) <x_afVCz>_N
                   :: (Rep Void x_afVCz :: *) ~R# (V1 x_afVCz :: *))
      of {
      }

-- RHS size: {terms: 4, types: 3, coercions: 0, joins: 0/0}
Data.Void.$fGenericVoid1 :: forall x. Void -> V1 x
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<B,1*U>b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ x_afVCj) (x1_afVy5 [Occ=Once] :: Void) ->
                 case x1_afVy5 of { }}]
Data.Void.$fGenericVoid1
  = \ (@ x_afVCj) (x1_afVy5 :: Void) -> case x1_afVy5 of { }

-- RHS size: {terms: 3, types: 1, coercions: 22, joins: 0/0}
Data.Void.$fGenericVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: Generic Void
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Generics.C:Generic TYPE: Void
                              Data.Void.$fGenericVoid1
                              `cast` (forall (x :: <*>_N).
                                      <Void>_R
                                      ->_R (Sym (GHC.Generics.N:M1[0]
                                                     <*>_N
                                                     <D>_P
                                                     <'MetaData "Void" "Data.Void" "base" 'False>_P
                                                     <V1>_R) ; Sub (Sym (Data.Void.Rep_Void[0]))) <x>_N
                                      :: (forall x. Void -> V1 x :: *)
                                         ~R# (forall x. Void -> Rep Void x :: *))
                              Data.Void.$fGenericVoid_$cto]
Data.Void.$fGenericVoid
  = GHC.Generics.C:Generic
      @ Void
      (Data.Void.$fGenericVoid1
       `cast` (forall (x :: <*>_N).
               <Void>_R
               ->_R (Sym (GHC.Generics.N:M1[0]
                              <*>_N
                              <D>_P
                              <'MetaData "Void" "Data.Void" "base" 'False>_P
                              <V1>_R) ; Sub (Sym (Data.Void.Rep_Void[0]))) <x>_N
               :: (forall x. Void -> V1 x :: *)
                  ~R# (forall x. Void -> Rep Void x :: *)))
      Data.Void.$fGenericVoid_$cto

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Void.$fDataVoid_$ctoConstr :: Void -> Constr
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<B,1*U>b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (z_afVy4 [Occ=Once] :: Void) -> case z_afVy4 of { }}]
Data.Void.$fDataVoid_$ctoConstr
  = \ (z_afVy4 :: Void) -> case z_afVy4 of { }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_rfVTe :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl_rfVTe = "Data/Void.hs:39:5-8|case"#

-- RHS size: {terms: 3, types: 7, coercions: 0, joins: 0/0}
lvl1_rfVTf :: forall (c :: * -> *). c Void
[GblId, Str=x]
lvl1_rfVTf
  = \ (@ (c_afVzn :: * -> *)) ->
      Control.Exception.Base.patError
        @ 'GHC.Types.LiftedRep @ (c_afVzn Void) lvl_rfVTe

-- RHS size: {terms: 14, types: 12, coercions: 0, joins: 0/0}
Data.Void.$w$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *). ConstrRep -> String -> c Void
[GblId, Arity=2, Str=<B,1*U><B,1*U>x, Unf=OtherCon []]
Data.Void.$w$cgunfold
  = \ (@ (c_sfVO2 :: * -> *))
      (ww_sfVO8 :: ConstrRep)
      (ww1_sfVOf :: String) ->
      case ww_sfVO8 of {
        __DEFAULT -> case Data.Data.$wlvl ww1_sfVOf of wild_00 { };
        AlgConstr idx_ae1Ws ->
          case idx_ae1Ws of { GHC.Types.I# ipv_sfVI9 ->
          lvl1_rfVTf @ c_sfVO2
          }
      }

-- RHS size: {terms: 13, types: 32, coercions: 0, joins: 0/0}
Data.Void.$fDataVoid_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Constr -> c Void
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,1*U(1*U,A,A,A,1*U(1*U,A))>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_sfVO2 :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (w2_sfVO5 [Occ=Once!] :: Constr) ->
                 case w2_sfVO5 of
                 { Data.Data.Constr ww1_sfVO8 [Occ=Once] _ [Occ=Dead] _ [Occ=Dead]
                                    _ [Occ=Dead] ww5_sfVOc [Occ=Once!] ->
                 case ww5_sfVOc of
                 { Data.Data.DataType ww7_sfVOf [Occ=Once] _ [Occ=Dead] ->
                 Data.Void.$w$cgunfold @ c_sfVO2 ww1_sfVO8 ww7_sfVOf
                 }
                 }}]
Data.Void.$fDataVoid_$cgunfold
  = \ (@ (c_sfVO2 :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead]
      (w2_sfVO5 :: Constr) ->
      case w2_sfVO5 of
      { Data.Data.Constr ww1_sfVO8 ww2_sfVO9 ww3_sfVOa ww4_sfVOb
                         ww5_sfVOc ->
      case ww5_sfVOc of { Data.Data.DataType ww7_sfVOf ww8_sfVOg ->
      Data.Void.$w$cgunfold @ c_sfVO2 ww1_sfVO8 ww7_sfVOf
      }
      }

-- RHS size: {terms: 6, types: 23, coercions: 0, joins: 0/0}
Data.Void.$fDataVoid_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Void -> c Void
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,1*U>b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (c_afVzg :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (z_afVy0 [Occ=Once] :: Void) ->
                 case z_afVy0 of { }}]
Data.Void.$fDataVoid_$cgfoldl
  = \ (@ (c_afVzg :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead]
      (z_afVy0 :: Void) ->
      case z_afVy0 of { }

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Void.$fEqVoid_$c== :: Void -> Void -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.True}]
Data.Void.$fEqVoid_$c==
  = \ _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.True

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Void.$fEqVoid_$c/= [InlPrag=INLINE (sat-args=2)]
  :: Void -> Void -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False}]
Data.Void.$fEqVoid_$c/=
  = \ _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Data.Void.$fEqVoid [InlPrag=NOUSERINLINE CONLIKE] :: Eq Void
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: Void
                        Data.Void.$fEqVoid_$c==
                        Data.Void.$fEqVoid_$c/=]
Data.Void.$fEqVoid
  = GHC.Classes.C:Eq
      @ Void Data.Void.$fEqVoid_$c== Data.Void.$fEqVoid_$c/=

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Void.$fOrdVoid_$c< :: Void -> Void -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False}]
Data.Void.$fOrdVoid_$c<
  = \ _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Data.Void.$fOrdVoid_$cmax :: Void -> Void -> Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (y_a55e [Occ=Once] :: Void) -> y_a55e}]
Data.Void.$fOrdVoid_$cmax
  = \ _ [Occ=Dead] (y_a55e :: Void) -> y_a55e

-- RHS size: {terms: 9, types: 1, coercions: 0, joins: 0/0}
Data.Void.$fOrdVoid [InlPrag=NOUSERINLINE CONLIKE] :: Ord Void
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: Void
                         Data.Void.$fEqVoid
                         Data.Void.$fOrdVoid_$ccompare
                         Data.Void.$fOrdVoid_$c<
                         Data.Void.$fEqVoid_$c==
                         Data.Void.$fOrdVoid_$c<
                         Data.Void.$fEqVoid_$c==
                         Data.Void.$fOrdVoid_$cmax
                         Data.Void.$fOrdVoid_$c<>]
Data.Void.$fOrdVoid
  = GHC.Classes.C:Ord
      @ Void
      Data.Void.$fEqVoid
      Data.Void.$fOrdVoid_$ccompare
      Data.Void.$fOrdVoid_$c<
      Data.Void.$fEqVoid_$c==
      Data.Void.$fOrdVoid_$c<
      Data.Void.$fEqVoid_$c==
      Data.Void.$fOrdVoid_$cmax
      Data.Void.$fOrdVoid_$c<>

-- RHS size: {terms: 4, types: 4, coercions: 0, joins: 0/0}
absurd :: forall a. Void -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<B,1*U>b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_afVyE) (a1_afVwX [Occ=Once] :: Void) ->
                 case a1_afVwX of { }}]
absurd = \ (@ a_afVyE) (a1_afVwX :: Void) -> case a1_afVwX of { }

-- RHS size: {terms: 6, types: 12, coercions: 0, joins: 0/0}
vacuous :: forall (f :: * -> *) a. Functor f => f Void -> f a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_afVyI :: * -> *))
                 (@ a_afVyJ)
                 ($dFunctor_afVyL [Occ=Once] :: Functor f_afVyI) ->
                 fmap
                   @ f_afVyI $dFunctor_afVyL @ Void @ a_afVyJ (absurd @ a_afVyJ)}]
vacuous
  = \ (@ (f_afVyI :: * -> *))
      (@ a_afVyJ)
      ($dFunctor_afVyL :: Functor f_afVyI) ->
      fmap @ f_afVyI $dFunctor_afVyL @ Void @ a_afVyJ (absurd @ a_afVyJ)

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Data.Void.$fIxVoid_$cindex :: (Void, Void) -> Void -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ _ [Occ=Dead] (eta_B1 [Occ=Once] :: Void) ->
                 case eta_B1 of { }}]
Data.Void.$fIxVoid_$cindex
  = \ _ [Occ=Dead] (eta_B1 :: Void) -> case eta_B1 of { }

-- RHS size: {terms: 4, types: 5, coercions: 0, joins: 0/0}
Data.Void.$fIxVoid_$cinRange :: (Void, Void) -> Void -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ _ [Occ=Dead] (eta_B1 [Occ=Once] :: Void) ->
                 case eta_B1 of { }}]
Data.Void.$fIxVoid_$cinRange
  = \ _ [Occ=Dead] (eta_B1 :: Void) -> case eta_B1 of { }

-- RHS size: {terms: 6, types: 9, coercions: 0, joins: 0/0}
Data.Void.$fIxVoid_$cunsafeRangeSize :: (Void, Void) -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<B,1*U(A,1*U)>b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (b_i814g [Occ=Once!] :: (Void, Void)) ->
                 case b_i814g of { (_ [Occ=Dead], h_i814k [Occ=Once]) ->
                 case h_i814k of { }
                 }}]
Data.Void.$fIxVoid_$cunsafeRangeSize
  = \ (b_i814g :: (Void, Void)) ->
      case b_i814g of { (_l_i814j, h_i814k) -> case h_i814k of { } }

-- RHS size: {terms: 8, types: 1, coercions: 0, joins: 0/0}
Data.Void.$fIxVoid [InlPrag=NOUSERINLINE CONLIKE] :: Ix Void
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Arr.C:Ix TYPE: Void
                    Data.Void.$fOrdVoid
                    Data.Void.$fIxVoid_$crange
                    Data.Void.$fIxVoid_$cindex
                    Data.Void.$fIxVoid_$cindex
                    Data.Void.$fIxVoid_$cinRange
                    Data.Void.$fIxVoid_$crangeSize
                    Data.Void.$fIxVoid_$cunsafeRangeSize]
Data.Void.$fIxVoid
  = GHC.Arr.C:Ix
      @ Void
      Data.Void.$fOrdVoid
      Data.Void.$fIxVoid_$crange
      Data.Void.$fIxVoid_$cindex
      Data.Void.$fIxVoid_$cindex
      Data.Void.$fIxVoid_$cinRange
      Data.Void.$fIxVoid_$crangeSize
      Data.Void.$fIxVoid_$cunsafeRangeSize

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Void.$fDataVoid5 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Void.$fDataVoid5 = "Void"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Void.$fDataVoid4 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Void.$fDataVoid4
  = GHC.CString.unpackCString# Data.Void.$fDataVoid5

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Void.$fDataVoid3 :: DataRep
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Void.$fDataVoid3 = Data.Data.AlgRep (GHC.Types.[] @ Constr)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Void.$tVoid :: DataType
[GblId,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Void.$tVoid
  = Data.Data.DataType Data.Void.$fDataVoid4 Data.Void.$fDataVoid3

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Void.$fDataVoid_$cdataTypeOf :: Void -> DataType
[GblId,
 Arity=1,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Data.Void.$tVoid}]
Data.Void.$fDataVoid_$cdataTypeOf
  = \ _ [Occ=Dead] -> Data.Void.$tVoid

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Void.$trModule4 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Data.Void.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Void.$trModule3 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Void.$trModule3 = GHC.Types.TrNameS Data.Void.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Data.Void.$trModule2 :: GHC.Prim.Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Data.Void.$trModule2 = "Data.Void"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Void.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Void.$trModule1 = GHC.Types.TrNameS Data.Void.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Data.Void.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Data.Void.$trModule
  = GHC.Types.Module Data.Void.$trModule3 Data.Void.$trModule1

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Data.Void.$fDataVoid7 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Data.Void.$fDataVoid7 = GHC.Types.TrNameS Data.Void.$fDataVoid5

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Data.Void.$tcVoid :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Data.Void.$tcVoid
  = GHC.Types.TyCon
      1716938828100304260##
      9065598981067935587##
      Data.Void.$trModule
      Data.Void.$fDataVoid7
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
Data.Void.$fDataVoid6 :: Data.Typeable.Internal.TypeRep Void
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 100 60}]
Data.Void.$fDataVoid6
  = case Data.Typeable.Internal.$wmkTrCon
           @ *
           @ Void
           1716938828100304260##
           9065598981067935587##
           Data.Void.$trModule
           Data.Void.$fDataVoid7
           0#
           GHC.Types.krep$*
           (GHC.Types.[] @ Data.Typeable.Internal.SomeTypeRep)
    of
    { (# ww8_idPJm, ww9_idPJn, ww10_idPJo, ww11_idPJp, ww12_idPJq #) ->
    Data.Typeable.Internal.TrTyCon
      @ * @ Void ww8_idPJm ww9_idPJn ww10_idPJo ww11_idPJp ww12_idPJq
    }

-- RHS size: {terms: 5, types: 23, coercions: 0, joins: 0/0}
Data.Void.$fDataVoid_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Typeable t =>
     (forall d. Data d => c (t d)) -> Maybe (c Void)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_afVzE :: * -> *))
                 (@ (c_afVzF :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_afVzF Void)}]
Data.Void.$fDataVoid_$cdataCast1
  = \ (@ (t_afVzE :: * -> *))
      (@ (c_afVzF :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_afVzF Void)

-- RHS size: {terms: 25, types: 31, coercions: 0, joins: 0/2}
Data.Void.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). GHC.Base.MonadPlus m => Void -> m Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 170 0}]
Data.Void.$w$cgmapMp
  = \ (@ (m_sfVOk :: * -> *))
      (w_sfVOl :: GHC.Base.MonadPlus m_sfVOk)
      (w1_sfVOn :: Void) ->
      let {
        lvl2_sfVJY :: m_sfVOk Void
        [LclId]
        lvl2_sfVJY = GHC.Base.mzero @ m_sfVOk w_sfVOl @ Void } in
      let {
        $dMonad_sfVJO [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_sfVOk
        [LclId]
        $dMonad_sfVJO = GHC.Base.$p2MonadPlus @ m_sfVOk w_sfVOl } in
      >>=
        @ m_sfVOk
        $dMonad_sfVJO
        @ (Void, Bool)
        @ Void
        (case w1_sfVOn of { })
        (\ (ds_de7oa :: (Void, Bool)) ->
           case ds_de7oa of { (x'_ae1TD, b_ae1TE) ->
           case b_ae1TE of {
             False -> lvl2_sfVJY;
             True -> return @ m_sfVOk $dMonad_sfVJO @ Void x'_ae1TD
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Void.$fDataVoid_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data d => d -> m d) -> Void -> m Void
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_sfVOk :: * -> *))
                 (w_sfVOl [Occ=Once] :: GHC.Base.MonadPlus m_sfVOk)
                 _ [Occ=Dead]
                 (w2_sfVOn [Occ=Once] :: Void) ->
                 Data.Void.$w$cgmapMp @ m_sfVOk w_sfVOl w2_sfVOn}]
Data.Void.$fDataVoid_$cgmapMp
  = \ (@ (m_sfVOk :: * -> *))
      (w_sfVOl :: GHC.Base.MonadPlus m_sfVOk)
      _ [Occ=Dead]
      (w2_sfVOn :: Void) ->
      Data.Void.$w$cgmapMp @ m_sfVOk w_sfVOl w2_sfVOn

-- RHS size: {terms: 6, types: 15, coercions: 0, joins: 0/0}
Data.Void.$fDataVoid_$cgmapM
  :: forall (m :: * -> *).
     Monad m =>
     (forall d. Data d => d -> m d) -> Void -> m Void
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,1*U>b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (m_afVBv :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (z_afVy0 [Occ=Once] :: Void) ->
                 case z_afVy0 of { }}]
Data.Void.$fDataVoid_$cgmapM
  = \ (@ (m_afVBv :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead]
      (z_afVy0 :: Void) ->
      case z_afVy0 of { }

-- RHS size: {terms: 6, types: 11, coercions: 0, joins: 0/0}
Data.Void.$fDataVoid_$cgmapQi
  :: forall u. Int -> (forall d. Data d => d -> u) -> Void -> u
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,1*U>b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_afVBh)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (x_ae1T7 [Occ=Once] :: Void) ->
                 case x_ae1T7 of { }}]
Data.Void.$fDataVoid_$cgmapQi
  = \ (@ u_afVBh) _ [Occ=Dead] _ [Occ=Dead] (x_ae1T7 :: Void) ->
      case x_ae1T7 of { }

-- RHS size: {terms: 8, types: 16, coercions: 0, joins: 0/0}
Data.Void.$fDataVoid_$cgmapQr
  :: forall r r'.
     (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> Void -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,A><B,1*U>b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_afVAM)
                 (@ r'_afVAN)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (x0_ae1SX [Occ=Once] :: Void) ->
                 case x0_ae1SX of { }}]
Data.Void.$fDataVoid_$cgmapQr
  = \ (@ r_afVAM)
      (@ r'_afVAN)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (x0_ae1SX :: Void) ->
      case x0_ae1SX of { }

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
Data.Void.$fDataVoid_$cgmapQ
  :: forall u. (forall d. Data d => d -> u) -> Void -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ u_afVB3) _ [Occ=Dead] (x0_ae1SX [Occ=Once] :: Void) ->
                 case x0_ae1SX of { }}]
Data.Void.$fDataVoid_$cgmapQ
  = \ (@ u_afVB3) _ [Occ=Dead] (x0_ae1SX :: Void) ->
      case x0_ae1SX of { }

-- RHS size: {terms: 8, types: 16, coercions: 0, joins: 0/0}
Data.Void.$fDataVoid1
  :: forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data d => d -> r')
     -> Void
     -> Data.Functor.Const.Const r Void
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,A><B,1*U>b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_afVAv)
                 (@ r'_afVAw)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (eta_B1 [Occ=Once] :: Void) ->
                 case eta_B1 of { }}]
Data.Void.$fDataVoid1
  = \ (@ r_afVAv)
      (@ r'_afVAw)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (eta_B1 :: Void) ->
      case eta_B1 of { }

-- RHS size: {terms: 4, types: 8, coercions: 0, joins: 0/0}
Data.Void.$fDataVoid2
  :: (forall b. Data b => b -> b)
     -> Void -> Data.Functor.Identity.Identity Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ _ [Occ=Dead] (x0_Xe2jm [Occ=Once] :: Void) ->
                 case x0_Xe2jm of { }}]
Data.Void.$fDataVoid2
  = \ _ [Occ=Dead] (x0_Xe2jm :: Void) -> case x0_Xe2jm of { }

-- RHS size: {terms: 5, types: 32, coercions: 0, joins: 0/0}
Data.Void.$fDataVoid_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Typeable t =>
     (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c Void)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (t_afVzX :: * -> * -> *))
                 (@ (c_afVzY :: * -> *))
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 GHC.Base.Nothing @ (c_afVzY Void)}]
Data.Void.$fDataVoid_$cdataCast2
  = \ (@ (t_afVzX :: * -> * -> *))
      (@ (c_afVzY :: * -> *))
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      GHC.Base.Nothing @ (c_afVzY Void)

-- RHS size: {terms: 25, types: 31, coercions: 0, joins: 0/2}
Data.Void.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *). GHC.Base.MonadPlus m => Void -> m Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 170 0}]
Data.Void.$w$cgmapMo
  = \ (@ (m_sfVOp :: * -> *))
      (w_sfVOq :: GHC.Base.MonadPlus m_sfVOp)
      (w1_sfVOs :: Void) ->
      let {
        lvl2_sfVK0 :: m_sfVOp Void
        [LclId]
        lvl2_sfVK0 = GHC.Base.mzero @ m_sfVOp w_sfVOq @ Void } in
      let {
        $dMonad_sfVJM [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          :: Monad m_sfVOp
        [LclId]
        $dMonad_sfVJM = GHC.Base.$p2MonadPlus @ m_sfVOp w_sfVOq } in
      >>=
        @ m_sfVOp
        $dMonad_sfVJM
        @ (Void, Bool)
        @ Void
        (case w1_sfVOs of { })
        (\ (ds_de7pa :: (Void, Bool)) ->
           case ds_de7pa of { (x'_ae1TS, b_ae1TT) ->
           case b_ae1TT of {
             False -> lvl2_sfVK0;
             True -> return @ m_sfVOp $dMonad_sfVJM @ Void x'_ae1TS
           }
           })

-- RHS size: {terms: 7, types: 15, coercions: 0, joins: 0/0}
Data.Void.$fDataVoid_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data d => d -> m d) -> Void -> m Void
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_sfVOp :: * -> *))
                 (w_sfVOq [Occ=Once] :: GHC.Base.MonadPlus m_sfVOp)
                 _ [Occ=Dead]
                 (w2_sfVOs [Occ=Once] :: Void) ->
                 Data.Void.$w$cgmapMo @ m_sfVOp w_sfVOq w2_sfVOs}]
Data.Void.$fDataVoid_$cgmapMo
  = \ (@ (m_sfVOp :: * -> *))
      (w_sfVOq :: GHC.Base.MonadPlus m_sfVOp)
      _ [Occ=Dead]
      (w2_sfVOs :: Void) ->
      Data.Void.$w$cgmapMo @ m_sfVOp w_sfVOq w2_sfVOs

-- RHS size: {terms: 16, types: 1, coercions: 42, joins: 0/0}
Data.Void.$fDataVoid [InlPrag=NOUSERINLINE CONLIKE] :: Data Void
[GblId[DFunId],
 Unf=DFun: \ ->
       Data.Data.C:Data TYPE: Void
                        Data.Void.$fDataVoid6
                        `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Void>_N
                                :: (Data.Typeable.Internal.TypeRep Void :: *)
                                   ~R# (Typeable Void :: Constraint))
                        Data.Void.$fDataVoid_$cgfoldl
                        Data.Void.$fDataVoid_$cgunfold
                        Data.Void.$fDataVoid_$ctoConstr
                        Data.Void.$fDataVoid_$cdataTypeOf
                        Data.Void.$fDataVoid_$cdataCast1
                        Data.Void.$fDataVoid_$cdataCast2
                        Data.Void.$fDataVoid2
                        `cast` (<forall b. Data b => b -> b>_R
                                ->_R <Void>_R
                                ->_R Data.Functor.Identity.N:Identity[0] <Void>_R
                                :: ((forall b. Data b => b -> b)
                                    -> Void -> Data.Functor.Identity.Identity Void :: *)
                                   ~R# ((forall b. Data b => b -> b) -> Void -> Void :: *))
                        Data.Void.$fDataVoid1
                        `cast` (forall (r :: <*>_N) (r' :: <*>_N).
                                <r -> r' -> r>_R
                                ->_R <r>_R
                                ->_R <forall d. Data d => d -> r'>_R
                                ->_R <Void>_R
                                ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <Void>_P
                                :: (forall r r'.
                                    (r -> r' -> r)
                                    -> r
                                    -> (forall d. Data d => d -> r')
                                    -> Void
                                    -> Data.Functor.Const.Const r Void :: *)
                                   ~R# (forall r r'.
                                        (r -> r' -> r)
                                        -> r -> (forall d. Data d => d -> r') -> Void -> r :: *))
                        Data.Void.$fDataVoid_$cgmapQr
                        Data.Void.$fDataVoid_$cgmapQ
                        Data.Void.$fDataVoid_$cgmapQi
                        Data.Void.$fDataVoid_$cgmapM
                        Data.Void.$fDataVoid_$cgmapMp
                        Data.Void.$fDataVoid_$cgmapMo]
Data.Void.$fDataVoid
  = Data.Data.C:Data
      @ Void
      (Data.Void.$fDataVoid6
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Void>_N
               :: (Data.Typeable.Internal.TypeRep Void :: *)
                  ~R# (Typeable Void :: Constraint)))
      Data.Void.$fDataVoid_$cgfoldl
      Data.Void.$fDataVoid_$cgunfold
      Data.Void.$fDataVoid_$ctoConstr
      Data.Void.$fDataVoid_$cdataTypeOf
      Data.Void.$fDataVoid_$cdataCast1
      Data.Void.$fDataVoid_$cdataCast2
      (Data.Void.$fDataVoid2
       `cast` (<forall b. Data b => b -> b>_R
               ->_R <Void>_R
               ->_R Data.Functor.Identity.N:Identity[0] <Void>_R
               :: ((forall b. Data b => b -> b)
                   -> Void -> Data.Functor.Identity.Identity Void :: *)
                  ~R# ((forall b. Data b => b -> b) -> Void -> Void :: *)))
      (Data.Void.$fDataVoid1
       `cast` (forall (r :: <*>_N) (r' :: <*>_N).
               <r -> r' -> r>_R
               ->_R <r>_R
               ->_R <forall d. Data d => d -> r'>_R
               ->_R <Void>_R
               ->_R Data.Functor.Const.N:Const[0] <*>_N <r>_R <Void>_P
               :: (forall r r'.
                   (r -> r' -> r)
                   -> r
                   -> (forall d. Data d => d -> r')
                   -> Void
                   -> Data.Functor.Const.Const r Void :: *)
                  ~R# (forall r r'.
                       (r -> r' -> r)
                       -> r -> (forall d. Data d => d -> r') -> Void -> r :: *)))
      Data.Void.$fDataVoid_$cgmapQr
      Data.Void.$fDataVoid_$cgmapQ
      Data.Void.$fDataVoid_$cgmapQi
      Data.Void.$fDataVoid_$cgmapM
      Data.Void.$fDataVoid_$cgmapMp
      Data.Void.$fDataVoid_$cgmapMo

-- RHS size: {terms: 14, types: 17, coercions: 9, joins: 0/0}
Data.Void.$fExceptionVoid_$cfromException
  :: SomeException -> Maybe Void
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 90 30}]
Data.Void.$fExceptionVoid_$cfromException
  = \ (ds_ifVHr :: SomeException) ->
      case ds_ifVHr of
      { SomeException @ e1_ifVHu $dException1_ifVHv e2_ifVHw ->
      case Data.Typeable.Internal.sameTypeRep
             @ *
             @ *
             @ e1_ifVHu
             @ Void
             ((GHC.Exception.$p1Exception @ e1_ifVHu $dException1_ifVHv)
              `cast` (Data.Typeable.Internal.N:Typeable[0] <*>_N <e1_ifVHu>_N
                      :: (Typeable e1_ifVHu :: Constraint)
                         ~R# (Data.Typeable.Internal.TypeRep e1_ifVHu :: *)))
             Data.Void.$fDataVoid6
      of {
        False -> GHC.Base.Nothing @ Void;
        True ->
          (GHC.Base.Just @ e1_ifVHu e2_ifVHw)
          `cast` ((Maybe (UnsafeCo representational e1_ifVHu Void))_R
                  :: (Maybe e1_ifVHu :: *) ~R# (Maybe Void :: *))
      }
      }

Rec {
-- RHS size: {terms: 6, types: 1, coercions: 5, joins: 0/0}
Data.Void.$fExceptionVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: Exception Void
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Exception.C:Exception TYPE: Void
                                 Data.Void.$fDataVoid6
                                 `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Void>_N
                                         :: (Data.Typeable.Internal.TypeRep Void :: *)
                                            ~R# (Typeable Void :: Constraint))
                                 Data.Void.$fShowVoid
                                 Data.Void.$fExceptionVoid_$ctoException
                                 Data.Void.$fExceptionVoid_$cfromException
                                 Data.Void.$fExceptionVoid_$cshow]
Data.Void.$fExceptionVoid
  = GHC.Exception.C:Exception
      @ Void
      (Data.Void.$fDataVoid6
       `cast` (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <Void>_N
               :: (Data.Typeable.Internal.TypeRep Void :: *)
                  ~R# (Typeable Void :: Constraint)))
      Data.Void.$fShowVoid
      Data.Void.$fExceptionVoid_$ctoException
      Data.Void.$fExceptionVoid_$cfromException
      Data.Void.$fExceptionVoid_$cshow

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Data.Void.$fExceptionVoid_$ctoException [Occ=LoopBreaker]
  :: Void -> SomeException
[GblId, Arity=1, Unf=OtherCon []]
Data.Void.$fExceptionVoid_$ctoException
  = GHC.Exception.SomeException @ Void Data.Void.$fExceptionVoid
end Rec }


