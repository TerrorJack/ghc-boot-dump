
==================== Pre unarise: ====================
2018-03-16 15:55:04.837492726 UTC

Data.Tuple.fst :: forall a b. (a, b) -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [ds_sr6p]
        case ds_sr6p of { (,) x_sr6r [Occ=Once] _ [Occ=Dead] -> x_sr6r; };

Data.Tuple.snd :: forall a b. (a, b) -> b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sr6t]
        case ds_sr6t of { (,) _ [Occ=Dead] y_sr6w [Occ=Once] -> y_sr6w; };

Data.Tuple.uncurry :: forall a b c. (a -> b -> c) -> (a, b) -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sr6x p_sr6y]
        let {
          sat_sr6G [Occ=Once] :: b_ar4E
          [LclId] =
              [p_sr6y] \u []
                  case p_sr6y of {
                    (,) _ [Occ=Dead] y_sr6F [Occ=Once] -> y_sr6F;
                  }; } in
        let {
          sat_sr6C [Occ=Once] :: a_ar4D
          [LclId] =
              [p_sr6y] \u []
                  case p_sr6y of { (,) x_sr6A [Occ=Once] _ [Occ=Dead] -> x_sr6A; };
        } in  f_sr6x sat_sr6C sat_sr6G;

Data.Tuple.curry :: forall a b c. ((a, b) -> c) -> a -> b -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sr6H x_sr6I y_sr6J]
        let {
          sat_sr6K [Occ=Once] :: (a_ar4t, b_ar4u)
          [LclId] =
              CCCS (,)! [x_sr6I y_sr6J];
        } in  f_sr6H sat_sr6K;

Data.Tuple.swap :: forall a b. (a, b) -> (b, a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sr6L]
        case ds_sr6L of {
          (,) a1_sr6N [Occ=Once] b1_sr6O [Occ=Once] -> (,) [b1_sr6O a1_sr6N];
        };

Data.Tuple.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Tuple.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Tuple.$trModule4];

Data.Tuple.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Tuple"#;

Data.Tuple.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Tuple.$trModule2];

Data.Tuple.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Tuple.$trModule3
                                     Data.Tuple.$trModule1];


==================== STG syntax: ====================
2018-03-16 15:55:04.839202303 UTC

Data.Tuple.fst :: forall a b. (a, b) -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [ds_sr6p]
        case ds_sr6p of { (,) x_sr6r [Occ=Once] _ [Occ=Dead] -> x_sr6r; };

Data.Tuple.snd :: forall a b. (a, b) -> b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sr6t]
        case ds_sr6t of { (,) _ [Occ=Dead] y_sr6w [Occ=Once] -> y_sr6w; };

Data.Tuple.uncurry :: forall a b c. (a -> b -> c) -> (a, b) -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sr6x p_sr6y]
        let {
          sat_sr6G [Occ=Once] :: b_ar4E
          [LclId] =
              [p_sr6y] \u []
                  case p_sr6y of {
                    (,) _ [Occ=Dead] y_sr6F [Occ=Once] -> y_sr6F;
                  }; } in
        let {
          sat_sr6C [Occ=Once] :: a_ar4D
          [LclId] =
              [p_sr6y] \u []
                  case p_sr6y of { (,) x_sr6A [Occ=Once] _ [Occ=Dead] -> x_sr6A; };
        } in  f_sr6x sat_sr6C sat_sr6G;

Data.Tuple.curry :: forall a b c. ((a, b) -> c) -> a -> b -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sr6H x_sr6I y_sr6J]
        let {
          sat_sr6K [Occ=Once] :: (a_ar4t, b_ar4u)
          [LclId] =
              CCCS (,)! [x_sr6I y_sr6J];
        } in  f_sr6H sat_sr6K;

Data.Tuple.swap :: forall a b. (a, b) -> (b, a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sr6L]
        case ds_sr6L of {
          (,) a1_sr6N [Occ=Once] b1_sr6O [Occ=Once] -> (,) [b1_sr6O a1_sr6N];
        };

Data.Tuple.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Tuple.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Tuple.$trModule4];

Data.Tuple.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Tuple"#;

Data.Tuple.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Tuple.$trModule2];

Data.Tuple.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Tuple.$trModule3
                                     Data.Tuple.$trModule1];


==================== Pre unarise: ====================
2018-03-16 15:55:04.946644611 UTC

Data.Tuple.fst :: forall a b. (a, b) -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [ds_sraI]
        case ds_sraI of { (,) x_sraK [Occ=Once] _ [Occ=Dead] -> x_sraK; };

Data.Tuple.snd :: forall a b. (a, b) -> b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sraM]
        case ds_sraM of { (,) _ [Occ=Dead] y_sraP [Occ=Once] -> y_sraP; };

Data.Tuple.uncurry :: forall a b c. (a -> b -> c) -> (a, b) -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sraQ p_sraR]
        let {
          sat_sraZ [Occ=Once] :: b_ar4E
          [LclId] =
              [p_sraR] \u []
                  case p_sraR of {
                    (,) _ [Occ=Dead] y_sraY [Occ=Once] -> y_sraY;
                  }; } in
        let {
          sat_sraV [Occ=Once] :: a_ar4D
          [LclId] =
              [p_sraR] \u []
                  case p_sraR of { (,) x_sraT [Occ=Once] _ [Occ=Dead] -> x_sraT; };
        } in  f_sraQ sat_sraV sat_sraZ;

Data.Tuple.curry :: forall a b c. ((a, b) -> c) -> a -> b -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_srb0 x_srb1 y_srb2]
        let {
          sat_srb3 [Occ=Once] :: (a_ar4t, b_ar4u)
          [LclId] =
              CCCS (,)! [x_srb1 y_srb2];
        } in  f_srb0 sat_srb3;

Data.Tuple.swap :: forall a b. (a, b) -> (b, a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_srb4]
        case ds_srb4 of {
          (,) a1_srb6 [Occ=Once] b1_srb7 [Occ=Once] -> (,) [b1_srb7 a1_srb6];
        };

Data.Tuple.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Tuple.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Tuple.$trModule4];

Data.Tuple.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Tuple"#;

Data.Tuple.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Tuple.$trModule2];

Data.Tuple.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Tuple.$trModule3
                                     Data.Tuple.$trModule1];


==================== STG syntax: ====================
2018-03-16 15:55:04.948615336 UTC

Data.Tuple.fst :: forall a b. (a, b) -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [ds_sraI]
        case ds_sraI of { (,) x_sraK [Occ=Once] _ [Occ=Dead] -> x_sraK; };

Data.Tuple.snd :: forall a b. (a, b) -> b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sraM]
        case ds_sraM of { (,) _ [Occ=Dead] y_sraP [Occ=Once] -> y_sraP; };

Data.Tuple.uncurry :: forall a b c. (a -> b -> c) -> (a, b) -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sraQ p_sraR]
        let {
          sat_sraZ [Occ=Once] :: b_ar4E
          [LclId] =
              [p_sraR] \u []
                  case p_sraR of {
                    (,) _ [Occ=Dead] y_sraY [Occ=Once] -> y_sraY;
                  }; } in
        let {
          sat_sraV [Occ=Once] :: a_ar4D
          [LclId] =
              [p_sraR] \u []
                  case p_sraR of { (,) x_sraT [Occ=Once] _ [Occ=Dead] -> x_sraT; };
        } in  f_sraQ sat_sraV sat_sraZ;

Data.Tuple.curry :: forall a b c. ((a, b) -> c) -> a -> b -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_srb0 x_srb1 y_srb2]
        let {
          sat_srb3 [Occ=Once] :: (a_ar4t, b_ar4u)
          [LclId] =
              CCCS (,)! [x_srb1 y_srb2];
        } in  f_srb0 sat_srb3;

Data.Tuple.swap :: forall a b. (a, b) -> (b, a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [ds_srb4]
        case ds_srb4 of {
          (,) a1_srb6 [Occ=Once] b1_srb7 [Occ=Once] -> (,) [b1_srb7 a1_srb6];
        };

Data.Tuple.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Tuple.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Tuple.$trModule4];

Data.Tuple.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Tuple"#;

Data.Tuple.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Tuple.$trModule2];

Data.Tuple.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Tuple.$trModule3
                                     Data.Tuple.$trModule1];

