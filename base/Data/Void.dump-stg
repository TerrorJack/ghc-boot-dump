
==================== Pre unarise: ====================
2018-03-16 16:11:45.254262588 UTC

Data.Void.$fIxVoid1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Void.$fIxVoid_$crangeSize
  :: (Data.Void.Void, Data.Void.Void) -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfVTh] Data.Void.$fIxVoid1;

Data.Void.$fIxVoid_$crange
  :: (Data.Void.Void, Data.Void.Void) -> [Data.Void.Void]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sfVTi] [] [];

Data.Void.$fSemigroupVoid_$cstimes
  :: forall b.
     GHC.Real.Integral b =>
     b -> Data.Void.Void -> Data.Void.Void
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfVTj eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotent
            $dIntegral_sfVTj eta_B2 eta_B1;

Data.Void.$fOrdVoid_$c<>
  :: Data.Void.Void -> Data.Void.Void -> Data.Void.Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a_sfVTk ds_sfVTl] a_sfVTk;

Data.Void.$fSemigroupVoid_$csconcat
  :: GHC.Base.NonEmpty Data.Void.Void -> Data.Void.Void
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfVTm]
        case ds_sfVTm of {
          GHC.Base.:| a1_sfVTo [Occ=Once] as_sfVTp [Occ=Once] ->
              case as_sfVTp of { __DEFAULT -> a1_sfVTo; };
        };

Data.Void.$fSemigroupVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Semigroup Data.Void.Void
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Void.$fOrdVoid_$c<>
                                         Data.Void.$fSemigroupVoid_$csconcat
                                         Data.Void.$fSemigroupVoid_$cstimes];

Data.Void.$fShowVoid_$cshowsPrec
  :: GHC.Types.Int -> Data.Void.Void -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfVTr z_sfVTs] z_sfVTs;

Data.Void.$fExceptionVoid_$cshow
  :: Data.Void.Void -> GHC.Base.String
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [x_sfVTu] x_sfVTu;

Data.Void.$fShowVoid1 :: Data.Void.Void -> GHC.Show.ShowS
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [z_sfVTw] z_sfVTw;

Data.Void.$fShowVoid_$cshowList
  :: [Data.Void.Void] -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [ls_sfVTy s_sfVTz]
        GHC.Show.showList__ Data.Void.$fShowVoid1 ls_sfVTy s_sfVTz;

Data.Void.$fShowVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Show.Show Data.Void.Void
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Void.$fShowVoid_$cshowsPrec
                                    Data.Void.$fExceptionVoid_$cshow
                                    Data.Void.$fShowVoid_$cshowList];

Data.Void.$fReadVoid2
  :: Text.ParserCombinators.ReadP.ReadS Data.Void.Void
[GblId, Arity=1, Caf=NoCafRefs, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadP.run
            Text.ParserCombinators.ReadP.Fail eta_B1;

Data.Void.$fReadVoid_$creadsPrec
  :: GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS Data.Void.Void
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [n_sfVTA eta_B1] Data.Void.$fReadVoid2 eta_B1;

Data.Void.$fReadVoid_$creadListPrec
  :: Text.ParserCombinators.ReadPrec.ReadPrec [Data.Void.Void]
[GblId] =
    [] \u []
        GHC.Read.list
            Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4;

Data.Void.$fReadVoid1
  :: Text.ParserCombinators.ReadP.P [Data.Void.Void]
[GblId] =
    [] \u []
        Data.Void.$fReadVoid_$creadListPrec
            GHC.Read.$fRead()7
            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;

Data.Void.$fReadVoid_$creadList
  :: Text.ParserCombinators.ReadP.ReadS [Data.Void.Void]
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadP.run Data.Void.$fReadVoid1 eta_B1;

Data.Void.$fReadVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Read.Read Data.Void.Void
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Read.C:Read! [Data.Void.$fReadVoid_$creadsPrec
                                    Data.Void.$fReadVoid_$creadList
                                    Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4
                                    Data.Void.$fReadVoid_$creadListPrec];

Data.Void.$fOrdVoid_$ccompare
  :: Data.Void.Void -> Data.Void.Void -> GHC.Types.Ordering
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sfVTB z_sfVTC] GHC.Types.EQ [];

Data.Void.$fGenericVoid_$cto
  :: forall x. GHC.Generics.Rep Data.Void.Void x -> Data.Void.Void
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [ds_sfVTD] ds_sfVTD;

Data.Void.$fGenericVoid1
  :: forall x. Data.Void.Void -> GHC.Generics.V1 x
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [x1_sfVTF] x1_sfVTF;

Data.Void.$fGenericVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic Data.Void.Void
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Void.$fGenericVoid1
                                           Data.Void.$fGenericVoid_$cto];

Data.Void.$fDataVoid_$ctoConstr
  :: Data.Void.Void -> Data.Data.Constr
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [z_sfVTH] z_sfVTH;

lvl_rfVTe :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data/Void.hs:39:5-8|case"#;

lvl1_rfVTf :: forall (c :: * -> *). c Data.Void.Void
[GblId, Str=x] =
    [] \u [] Control.Exception.Base.patError lvl_rfVTe;

Data.Void.$w$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     Data.Data.ConstrRep -> GHC.Base.String -> c Data.Void.Void
[GblId, Arity=2, Str=<B,1*U><B,1*U>x, Unf=OtherCon []] =
    [] \r [ww_sfVTJ ww1_sfVTK]
        case ww_sfVTJ of {
          __DEFAULT -> Data.Data.$wlvl ww1_sfVTK;
          Data.Data.AlgConstr idx_sfVTN [Occ=Once!] ->
              case idx_sfVTN of { GHC.Types.I# _ [Occ=Dead] -> lvl1_rfVTf; };
        };

Data.Void.$fDataVoid_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Data.Data.Constr -> c Data.Void.Void
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,1*U(1*U,A,A,A,1*U(1*U,A))>x,
 Unf=OtherCon []] =
    [] \r [w_sfVTQ w1_sfVTR w2_sfVTS]
        case w2_sfVTS of {
          Data.Data.Constr ww1_sfVTU [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           ww5_sfVTY [Occ=Once!] ->
              case ww5_sfVTY of {
                Data.Data.DataType ww7_sfVU0 [Occ=Once] _ [Occ=Dead] ->
                    Data.Void.$w$cgunfold ww1_sfVTU ww7_sfVU0;
              };
        };

Data.Void.$fDataVoid_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Data.Void.Void -> c Data.Void.Void
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfVU2 ds1_sfVU3 z_sfVU4] z_sfVU4;

Data.Void.$fEqVoid_$c==
  :: Data.Void.Void -> Data.Void.Void -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sfVU6 z_sfVU7] GHC.Types.True [];

Data.Void.$fEqVoid_$c/= [InlPrag=INLINE (sat-args=2)]
  :: Data.Void.Void -> Data.Void.Void -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [eta_sfVU8 eta1_sfVU9] GHC.Types.False [];

Data.Void.$fEqVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Eq Data.Void.Void
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [Data.Void.$fEqVoid_$c==
                                     Data.Void.$fEqVoid_$c/=];

Data.Void.$fOrdVoid_$c<
  :: Data.Void.Void -> Data.Void.Void -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [x_sfVUa y_sfVUb] GHC.Types.False [];

Data.Void.$fOrdVoid_$cmax
  :: Data.Void.Void -> Data.Void.Void -> Data.Void.Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_sfVUc y_sfVUd] y_sfVUd;

Data.Void.$fOrdVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Ord Data.Void.Void
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Void.$fEqVoid
                                      Data.Void.$fOrdVoid_$ccompare
                                      Data.Void.$fOrdVoid_$c<
                                      Data.Void.$fEqVoid_$c==
                                      Data.Void.$fOrdVoid_$c<
                                      Data.Void.$fEqVoid_$c==
                                      Data.Void.$fOrdVoid_$cmax
                                      Data.Void.$fOrdVoid_$c<>];

Data.Void.absurd :: forall a. Data.Void.Void -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [a1_sfVUe] a1_sfVUe;

Data.Void.vacuous
  :: forall (f :: * -> *) a.
     GHC.Base.Functor f =>
     f Data.Void.Void -> f a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sfVUg]
        GHC.Base.fmap $dFunctor_sfVUg Data.Void.absurd;

Data.Void.$fIxVoid_$cindex
  :: (Data.Void.Void, Data.Void.Void)
     -> Data.Void.Void -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfVUh eta_sfVUi] eta_sfVUi;

Data.Void.$fIxVoid_$cinRange
  :: (Data.Void.Void, Data.Void.Void)
     -> Data.Void.Void -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfVUk eta_sfVUl] eta_sfVUl;

Data.Void.$fIxVoid_$cunsafeRangeSize
  :: (Data.Void.Void, Data.Void.Void) -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<B,1*U(A,1*U)>b,
 Unf=OtherCon []] =
    [] \r [b_sfVUn]
        case b_sfVUn of {
          (,) _ [Occ=Dead] h_sfVUq [Occ=Once] -> h_sfVUq;
        };

Data.Void.$fIxVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Arr.Ix Data.Void.Void
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Arr.C:Ix! [Data.Void.$fOrdVoid
                                 Data.Void.$fIxVoid_$crange
                                 Data.Void.$fIxVoid_$cindex
                                 Data.Void.$fIxVoid_$cindex
                                 Data.Void.$fIxVoid_$cinRange
                                 Data.Void.$fIxVoid_$crangeSize
                                 Data.Void.$fIxVoid_$cunsafeRangeSize];

Data.Void.$fDataVoid5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Void"#;

Data.Void.$fDataVoid4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Void.$fDataVoid5;

Data.Void.$fDataVoid3 :: Data.Data.DataRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [GHC.Types.[]];

Data.Void.$tVoid :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Void.$fDataVoid4
                                       Data.Void.$fDataVoid3];

Data.Void.$fDataVoid_$cdataTypeOf
  :: Data.Void.Void -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfVUs] Data.Void.$tVoid;

Data.Void.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Void.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Void.$trModule4];

Data.Void.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Void"#;

Data.Void.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Void.$trModule2];

Data.Void.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Void.$trModule3
                                     Data.Void.$trModule1];

Data.Void.$fDataVoid7 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Void.$fDataVoid5];

Data.Void.$tcVoid :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1716938828100304260##
                                    9065598981067935587##
                                    Data.Void.$trModule
                                    Data.Void.$fDataVoid7
                                    0#
                                    GHC.Types.krep$*];

Data.Void.$fDataVoid6
  :: Data.Typeable.Internal.TypeRep Data.Void.Void
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                1716938828100304260##
                9065598981067935587##
                Data.Void.$trModule
                Data.Void.$fDataVoid7
                0#
                GHC.Types.krep$*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfVUu [Occ=Once]
                   ww9_sfVUv [Occ=Once]
                   ww10_sfVUw [Occ=Once]
                   ww11_sfVUx [Occ=Once]
                   ww12_sfVUy [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfVUu
                                              ww9_sfVUv
                                              ww10_sfVUw
                                              ww11_sfVUx
                                              ww12_sfVUy];
        };

Data.Void.$fDataVoid_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c Data.Void.Void)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfVUz ds_sfVUA] GHC.Base.Nothing [];

Data.Void.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     Data.Void.Void -> m Data.Void.Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfVUB w1_sfVUC]
        let {
          lvl2_sfVUD [Occ=OnceL] :: m_sfVOk Data.Void.Void
          [LclId] =
              [w_sfVUB] \u [] GHC.Base.mzero w_sfVUB;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sfVUB
          of
          $dMonad_sfVUE [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfVUL [Occ=Once]
                    :: (Data.Void.Void, GHC.Types.Bool) -> m_sfVOk Data.Void.Void
                  [LclId] =
                      [lvl2_sfVUD $dMonad_sfVUE] \r [ds_sfVUG]
                          case ds_sfVUG of {
                            (,) x'_sfVUI [Occ=Once] b_sfVUJ [Occ=Once!] ->
                                case b_sfVUJ of {
                                  GHC.Types.False -> lvl2_sfVUD;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfVUE x'_sfVUI;
                                };
                          };
                } in  GHC.Base.>>= $dMonad_sfVUE w1_sfVUC sat_sfVUL;
          };

Data.Void.$fDataVoid_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Void.Void -> m Data.Void.Void
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfVUM w1_sfVUN w2_sfVUO]
        Data.Void.$w$cgmapMp w_sfVUM w2_sfVUO;

Data.Void.$fDataVoid_$cgmapM
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Void.Void -> m Data.Void.Void
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfVUP ds_sfVUQ z_sfVUR] z_sfVUR;

Data.Void.$fDataVoid_$cgmapQi
  :: forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u) -> Data.Void.Void -> u
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfVUT ds1_sfVUU x_sfVUV] x_sfVUV;

Data.Void.$fDataVoid_$cgmapQr
  :: forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Void.Void
     -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfVUX ds1_sfVUY ds2_sfVUZ x0_sfVV0] x0_sfVV0;

Data.Void.$fDataVoid_$cgmapQ
  :: forall u.
     (forall d. Data.Data.Data d => d -> u) -> Data.Void.Void -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfVV2 x0_sfVV3] x0_sfVV3;

Data.Void.$fDataVoid1
  :: forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Void.Void
     -> Data.Functor.Const.Const r Data.Void.Void
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfVV5 ds1_sfVV6 ds2_sfVV7 eta_sfVV8] eta_sfVV8;

Data.Void.$fDataVoid2
  :: (forall b. Data.Data.Data b => b -> b)
     -> Data.Void.Void -> Data.Functor.Identity.Identity Data.Void.Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfVVa x0_sfVVb] x0_sfVVb;

Data.Void.$fDataVoid_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c Data.Void.Void)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfVVd ds_sfVVe] GHC.Base.Nothing [];

Data.Void.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     Data.Void.Void -> m Data.Void.Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfVVf w1_sfVVg]
        let {
          lvl2_sfVVh [Occ=OnceL] :: m_sfVOp Data.Void.Void
          [LclId] =
              [w_sfVVf] \u [] GHC.Base.mzero w_sfVVf;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sfVVf
          of
          $dMonad_sfVVi [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfVVp [Occ=Once]
                    :: (Data.Void.Void, GHC.Types.Bool) -> m_sfVOp Data.Void.Void
                  [LclId] =
                      [lvl2_sfVVh $dMonad_sfVVi] \r [ds_sfVVk]
                          case ds_sfVVk of {
                            (,) x'_sfVVm [Occ=Once] b_sfVVn [Occ=Once!] ->
                                case b_sfVVn of {
                                  GHC.Types.False -> lvl2_sfVVh;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfVVi x'_sfVVm;
                                };
                          };
                } in  GHC.Base.>>= $dMonad_sfVVi w1_sfVVg sat_sfVVp;
          };

Data.Void.$fDataVoid_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Void.Void -> m Data.Void.Void
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfVVq w1_sfVVr w2_sfVVs]
        Data.Void.$w$cgmapMo w_sfVVq w2_sfVVs;

Data.Void.$fDataVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Data.Data Data.Void.Void
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Data.C:Data! [Data.Void.$fDataVoid6
                                     Data.Void.$fDataVoid_$cgfoldl
                                     Data.Void.$fDataVoid_$cgunfold
                                     Data.Void.$fDataVoid_$ctoConstr
                                     Data.Void.$fDataVoid_$cdataTypeOf
                                     Data.Void.$fDataVoid_$cdataCast1
                                     Data.Void.$fDataVoid_$cdataCast2
                                     Data.Void.$fDataVoid2
                                     Data.Void.$fDataVoid1
                                     Data.Void.$fDataVoid_$cgmapQr
                                     Data.Void.$fDataVoid_$cgmapQ
                                     Data.Void.$fDataVoid_$cgmapQi
                                     Data.Void.$fDataVoid_$cgmapM
                                     Data.Void.$fDataVoid_$cgmapMp
                                     Data.Void.$fDataVoid_$cgmapMo];

Data.Void.$fExceptionVoid_$cfromException
  :: GHC.Exception.SomeException -> GHC.Base.Maybe Data.Void.Void
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfVVt]
        case ds_sfVVt of {
          GHC.Exception.SomeException $dException1_sfVVv [Occ=Once]
                                      e2_sfVVw [Occ=Once] ->
              case GHC.Exception.$p1Exception $dException1_sfVVv of sat_sfVVx {
                __DEFAULT ->
                    case
                        Data.Typeable.Internal.sameTypeRep sat_sfVVx Data.Void.$fDataVoid6
                    of
                    { GHC.Types.False -> GHC.Base.Nothing [];
                      GHC.Types.True -> GHC.Base.Just [e2_sfVVw];
                    };
              };
        };

Data.Void.$fExceptionVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Exception.Exception Data.Void.Void
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Exception.C:Exception! [Data.Void.$fDataVoid6
                                              Data.Void.$fShowVoid
                                              Data.Void.$fExceptionVoid_$ctoException
                                              Data.Void.$fExceptionVoid_$cfromException
                                              Data.Void.$fExceptionVoid_$cshow];
Data.Void.$fExceptionVoid_$ctoException [Occ=LoopBreaker]
  :: Data.Void.Void -> GHC.Exception.SomeException
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        GHC.Exception.SomeException [Data.Void.$fExceptionVoid eta_B1];


==================== STG syntax: ====================
2018-03-16 16:11:45.263310137 UTC

Data.Void.$fIxVoid1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Void.$fIxVoid_$crangeSize
  :: (Data.Void.Void, Data.Void.Void) -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfVTh] Data.Void.$fIxVoid1;

Data.Void.$fIxVoid_$crange
  :: (Data.Void.Void, Data.Void.Void) -> [Data.Void.Void]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sfVTi] [] [];

Data.Void.$fSemigroupVoid_$cstimes
  :: forall b.
     GHC.Real.Integral b =>
     b -> Data.Void.Void -> Data.Void.Void
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfVTj eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotent
            $dIntegral_sfVTj eta_B2 eta_B1;

Data.Void.$fOrdVoid_$c<>
  :: Data.Void.Void -> Data.Void.Void -> Data.Void.Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a_sfVTk ds_sfVTl] a_sfVTk;

Data.Void.$fSemigroupVoid_$csconcat
  :: GHC.Base.NonEmpty Data.Void.Void -> Data.Void.Void
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfVTm]
        case ds_sfVTm of {
          GHC.Base.:| a1_sfVTo [Occ=Once] as_sfVTp [Occ=Once] ->
              case as_sfVTp of { __DEFAULT -> a1_sfVTo; };
        };

Data.Void.$fSemigroupVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Semigroup Data.Void.Void
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Void.$fOrdVoid_$c<>
                                         Data.Void.$fSemigroupVoid_$csconcat
                                         Data.Void.$fSemigroupVoid_$cstimes];

Data.Void.$fShowVoid_$cshowsPrec
  :: GHC.Types.Int -> Data.Void.Void -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfVTr z_sfVTs] z_sfVTs;

Data.Void.$fExceptionVoid_$cshow
  :: Data.Void.Void -> GHC.Base.String
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [x_sfVTu] x_sfVTu;

Data.Void.$fShowVoid1 :: Data.Void.Void -> GHC.Show.ShowS
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [z_sfVTw] z_sfVTw;

Data.Void.$fShowVoid_$cshowList
  :: [Data.Void.Void] -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [ls_sfVTy s_sfVTz]
        GHC.Show.showList__ Data.Void.$fShowVoid1 ls_sfVTy s_sfVTz;

Data.Void.$fShowVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Show.Show Data.Void.Void
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Void.$fShowVoid_$cshowsPrec
                                    Data.Void.$fExceptionVoid_$cshow
                                    Data.Void.$fShowVoid_$cshowList];

Data.Void.$fReadVoid2
  :: Text.ParserCombinators.ReadP.ReadS Data.Void.Void
[GblId, Arity=1, Caf=NoCafRefs, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadP.run
            Text.ParserCombinators.ReadP.Fail eta_B1;

Data.Void.$fReadVoid_$creadsPrec
  :: GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS Data.Void.Void
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [n_sfVTA eta_B1] Data.Void.$fReadVoid2 eta_B1;

Data.Void.$fReadVoid_$creadListPrec
  :: Text.ParserCombinators.ReadPrec.ReadPrec [Data.Void.Void]
[GblId] =
    [] \u []
        GHC.Read.list
            Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4;

Data.Void.$fReadVoid1
  :: Text.ParserCombinators.ReadP.P [Data.Void.Void]
[GblId] =
    [] \u []
        Data.Void.$fReadVoid_$creadListPrec
            GHC.Read.$fRead()7
            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;

Data.Void.$fReadVoid_$creadList
  :: Text.ParserCombinators.ReadP.ReadS [Data.Void.Void]
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadP.run Data.Void.$fReadVoid1 eta_B1;

Data.Void.$fReadVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Read.Read Data.Void.Void
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Read.C:Read! [Data.Void.$fReadVoid_$creadsPrec
                                    Data.Void.$fReadVoid_$creadList
                                    Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4
                                    Data.Void.$fReadVoid_$creadListPrec];

Data.Void.$fOrdVoid_$ccompare
  :: Data.Void.Void -> Data.Void.Void -> GHC.Types.Ordering
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sfVTB z_sfVTC] GHC.Types.EQ [];

Data.Void.$fGenericVoid_$cto
  :: forall x. GHC.Generics.Rep Data.Void.Void x -> Data.Void.Void
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [ds_sfVTD] ds_sfVTD;

Data.Void.$fGenericVoid1
  :: forall x. Data.Void.Void -> GHC.Generics.V1 x
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [x1_sfVTF] x1_sfVTF;

Data.Void.$fGenericVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic Data.Void.Void
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Void.$fGenericVoid1
                                           Data.Void.$fGenericVoid_$cto];

Data.Void.$fDataVoid_$ctoConstr
  :: Data.Void.Void -> Data.Data.Constr
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [z_sfVTH] z_sfVTH;

lvl_rfVTe :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data/Void.hs:39:5-8|case"#;

lvl1_rfVTf :: forall (c :: * -> *). c Data.Void.Void
[GblId, Str=x] =
    [] \u [] Control.Exception.Base.patError lvl_rfVTe;

Data.Void.$w$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     Data.Data.ConstrRep -> GHC.Base.String -> c Data.Void.Void
[GblId, Arity=2, Str=<B,1*U><B,1*U>x, Unf=OtherCon []] =
    [] \r [ww_sfVTJ ww1_sfVTK]
        case ww_sfVTJ of {
          __DEFAULT -> Data.Data.$wlvl ww1_sfVTK;
          Data.Data.AlgConstr idx_sfVTN [Occ=Once!] ->
              case idx_sfVTN of { GHC.Types.I# _ [Occ=Dead] -> lvl1_rfVTf; };
        };

Data.Void.$fDataVoid_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Data.Data.Constr -> c Data.Void.Void
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,1*U(1*U,A,A,A,1*U(1*U,A))>x,
 Unf=OtherCon []] =
    [] \r [w_sfVTQ w1_sfVTR w2_sfVTS]
        case w2_sfVTS of {
          Data.Data.Constr ww1_sfVTU [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           ww5_sfVTY [Occ=Once!] ->
              case ww5_sfVTY of {
                Data.Data.DataType ww7_sfVU0 [Occ=Once] _ [Occ=Dead] ->
                    Data.Void.$w$cgunfold ww1_sfVTU ww7_sfVU0;
              };
        };

Data.Void.$fDataVoid_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Data.Void.Void -> c Data.Void.Void
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfVU2 ds1_sfVU3 z_sfVU4] z_sfVU4;

Data.Void.$fEqVoid_$c==
  :: Data.Void.Void -> Data.Void.Void -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sfVU6 z_sfVU7] GHC.Types.True [];

Data.Void.$fEqVoid_$c/= [InlPrag=INLINE (sat-args=2)]
  :: Data.Void.Void -> Data.Void.Void -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [eta_sfVU8 eta1_sfVU9] GHC.Types.False [];

Data.Void.$fEqVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Eq Data.Void.Void
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [Data.Void.$fEqVoid_$c==
                                     Data.Void.$fEqVoid_$c/=];

Data.Void.$fOrdVoid_$c<
  :: Data.Void.Void -> Data.Void.Void -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [x_sfVUa y_sfVUb] GHC.Types.False [];

Data.Void.$fOrdVoid_$cmax
  :: Data.Void.Void -> Data.Void.Void -> Data.Void.Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_sfVUc y_sfVUd] y_sfVUd;

Data.Void.$fOrdVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Ord Data.Void.Void
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Void.$fEqVoid
                                      Data.Void.$fOrdVoid_$ccompare
                                      Data.Void.$fOrdVoid_$c<
                                      Data.Void.$fEqVoid_$c==
                                      Data.Void.$fOrdVoid_$c<
                                      Data.Void.$fEqVoid_$c==
                                      Data.Void.$fOrdVoid_$cmax
                                      Data.Void.$fOrdVoid_$c<>];

Data.Void.absurd :: forall a. Data.Void.Void -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [a1_sfVUe] a1_sfVUe;

Data.Void.vacuous
  :: forall (f :: * -> *) a.
     GHC.Base.Functor f =>
     f Data.Void.Void -> f a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sfVUg]
        GHC.Base.fmap $dFunctor_sfVUg Data.Void.absurd;

Data.Void.$fIxVoid_$cindex
  :: (Data.Void.Void, Data.Void.Void)
     -> Data.Void.Void -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfVUh eta_sfVUi] eta_sfVUi;

Data.Void.$fIxVoid_$cinRange
  :: (Data.Void.Void, Data.Void.Void)
     -> Data.Void.Void -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfVUk eta_sfVUl] eta_sfVUl;

Data.Void.$fIxVoid_$cunsafeRangeSize
  :: (Data.Void.Void, Data.Void.Void) -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<B,1*U(A,1*U)>b,
 Unf=OtherCon []] =
    [] \r [b_sfVUn]
        case b_sfVUn of {
          (,) _ [Occ=Dead] h_sfVUq [Occ=Once] -> h_sfVUq;
        };

Data.Void.$fIxVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Arr.Ix Data.Void.Void
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Arr.C:Ix! [Data.Void.$fOrdVoid
                                 Data.Void.$fIxVoid_$crange
                                 Data.Void.$fIxVoid_$cindex
                                 Data.Void.$fIxVoid_$cindex
                                 Data.Void.$fIxVoid_$cinRange
                                 Data.Void.$fIxVoid_$crangeSize
                                 Data.Void.$fIxVoid_$cunsafeRangeSize];

Data.Void.$fDataVoid5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Void"#;

Data.Void.$fDataVoid4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Void.$fDataVoid5;

Data.Void.$fDataVoid3 :: Data.Data.DataRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [GHC.Types.[]];

Data.Void.$tVoid :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Void.$fDataVoid4
                                       Data.Void.$fDataVoid3];

Data.Void.$fDataVoid_$cdataTypeOf
  :: Data.Void.Void -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfVUs] Data.Void.$tVoid;

Data.Void.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Void.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Void.$trModule4];

Data.Void.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Void"#;

Data.Void.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Void.$trModule2];

Data.Void.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Void.$trModule3
                                     Data.Void.$trModule1];

Data.Void.$fDataVoid7 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Void.$fDataVoid5];

Data.Void.$tcVoid :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1716938828100304260##
                                    9065598981067935587##
                                    Data.Void.$trModule
                                    Data.Void.$fDataVoid7
                                    0#
                                    GHC.Types.krep$*];

Data.Void.$fDataVoid6
  :: Data.Typeable.Internal.TypeRep Data.Void.Void
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                1716938828100304260##
                9065598981067935587##
                Data.Void.$trModule
                Data.Void.$fDataVoid7
                0#
                GHC.Types.krep$*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfVUu [Occ=Once]
                   ww9_sfVUv [Occ=Once]
                   ww10_sfVUw [Occ=Once]
                   ww11_sfVUx [Occ=Once]
                   ww12_sfVUy [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfVUu
                                              ww9_sfVUv
                                              ww10_sfVUw
                                              ww11_sfVUx
                                              ww12_sfVUy];
        };

Data.Void.$fDataVoid_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c Data.Void.Void)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfVUz ds_sfVUA] GHC.Base.Nothing [];

Data.Void.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     Data.Void.Void -> m Data.Void.Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfVUB w1_sfVUC]
        let {
          lvl2_sfVUD [Occ=OnceL] :: m_sfVOk Data.Void.Void
          [LclId] =
              [w_sfVUB] \u [] GHC.Base.mzero w_sfVUB;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sfVUB
          of
          $dMonad_sfVUE [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfVUL [Occ=Once]
                    :: (Data.Void.Void, GHC.Types.Bool) -> m_sfVOk Data.Void.Void
                  [LclId] =
                      [lvl2_sfVUD $dMonad_sfVUE] \r [ds_sfVUG]
                          case ds_sfVUG of {
                            (,) x'_sfVUI [Occ=Once] b_sfVUJ [Occ=Once!] ->
                                case b_sfVUJ of {
                                  GHC.Types.False -> lvl2_sfVUD;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfVUE x'_sfVUI;
                                };
                          };
                } in  GHC.Base.>>= $dMonad_sfVUE w1_sfVUC sat_sfVUL;
          };

Data.Void.$fDataVoid_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Void.Void -> m Data.Void.Void
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfVUM w1_sfVUN w2_sfVUO]
        Data.Void.$w$cgmapMp w_sfVUM w2_sfVUO;

Data.Void.$fDataVoid_$cgmapM
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Void.Void -> m Data.Void.Void
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfVUP ds_sfVUQ z_sfVUR] z_sfVUR;

Data.Void.$fDataVoid_$cgmapQi
  :: forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u) -> Data.Void.Void -> u
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfVUT ds1_sfVUU x_sfVUV] x_sfVUV;

Data.Void.$fDataVoid_$cgmapQr
  :: forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Void.Void
     -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfVUX ds1_sfVUY ds2_sfVUZ x0_sfVV0] x0_sfVV0;

Data.Void.$fDataVoid_$cgmapQ
  :: forall u.
     (forall d. Data.Data.Data d => d -> u) -> Data.Void.Void -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfVV2 x0_sfVV3] x0_sfVV3;

Data.Void.$fDataVoid1
  :: forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Void.Void
     -> Data.Functor.Const.Const r Data.Void.Void
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfVV5 ds1_sfVV6 ds2_sfVV7 eta_sfVV8] eta_sfVV8;

Data.Void.$fDataVoid2
  :: (forall b. Data.Data.Data b => b -> b)
     -> Data.Void.Void -> Data.Functor.Identity.Identity Data.Void.Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfVVa x0_sfVVb] x0_sfVVb;

Data.Void.$fDataVoid_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c Data.Void.Void)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfVVd ds_sfVVe] GHC.Base.Nothing [];

Data.Void.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     Data.Void.Void -> m Data.Void.Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfVVf w1_sfVVg]
        let {
          lvl2_sfVVh [Occ=OnceL] :: m_sfVOp Data.Void.Void
          [LclId] =
              [w_sfVVf] \u [] GHC.Base.mzero w_sfVVf;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sfVVf
          of
          $dMonad_sfVVi [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfVVp [Occ=Once]
                    :: (Data.Void.Void, GHC.Types.Bool) -> m_sfVOp Data.Void.Void
                  [LclId] =
                      [lvl2_sfVVh $dMonad_sfVVi] \r [ds_sfVVk]
                          case ds_sfVVk of {
                            (,) x'_sfVVm [Occ=Once] b_sfVVn [Occ=Once!] ->
                                case b_sfVVn of {
                                  GHC.Types.False -> lvl2_sfVVh;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfVVi x'_sfVVm;
                                };
                          };
                } in  GHC.Base.>>= $dMonad_sfVVi w1_sfVVg sat_sfVVp;
          };

Data.Void.$fDataVoid_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Void.Void -> m Data.Void.Void
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfVVq w1_sfVVr w2_sfVVs]
        Data.Void.$w$cgmapMo w_sfVVq w2_sfVVs;

Data.Void.$fDataVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Data.Data Data.Void.Void
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Data.C:Data! [Data.Void.$fDataVoid6
                                     Data.Void.$fDataVoid_$cgfoldl
                                     Data.Void.$fDataVoid_$cgunfold
                                     Data.Void.$fDataVoid_$ctoConstr
                                     Data.Void.$fDataVoid_$cdataTypeOf
                                     Data.Void.$fDataVoid_$cdataCast1
                                     Data.Void.$fDataVoid_$cdataCast2
                                     Data.Void.$fDataVoid2
                                     Data.Void.$fDataVoid1
                                     Data.Void.$fDataVoid_$cgmapQr
                                     Data.Void.$fDataVoid_$cgmapQ
                                     Data.Void.$fDataVoid_$cgmapQi
                                     Data.Void.$fDataVoid_$cgmapM
                                     Data.Void.$fDataVoid_$cgmapMp
                                     Data.Void.$fDataVoid_$cgmapMo];

Data.Void.$fExceptionVoid_$cfromException
  :: GHC.Exception.SomeException -> GHC.Base.Maybe Data.Void.Void
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfVVt]
        case ds_sfVVt of {
          GHC.Exception.SomeException $dException1_sfVVv [Occ=Once]
                                      e2_sfVVw [Occ=Once] ->
              case GHC.Exception.$p1Exception $dException1_sfVVv of sat_sfVVx {
                __DEFAULT ->
                    case
                        Data.Typeable.Internal.sameTypeRep sat_sfVVx Data.Void.$fDataVoid6
                    of
                    { GHC.Types.False -> GHC.Base.Nothing [];
                      GHC.Types.True -> GHC.Base.Just [e2_sfVVw];
                    };
              };
        };

Data.Void.$fExceptionVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Exception.Exception Data.Void.Void
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Exception.C:Exception! [Data.Void.$fDataVoid6
                                              Data.Void.$fShowVoid
                                              Data.Void.$fExceptionVoid_$ctoException
                                              Data.Void.$fExceptionVoid_$cfromException
                                              Data.Void.$fExceptionVoid_$cshow];
Data.Void.$fExceptionVoid_$ctoException [Occ=LoopBreaker]
  :: Data.Void.Void -> GHC.Exception.SomeException
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        GHC.Exception.SomeException [Data.Void.$fExceptionVoid eta_B1];


==================== Pre unarise: ====================
2018-03-16 16:11:45.962556281 UTC

Data.Void.$fIxVoid1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Void.$fIxVoid_$crangeSize
  :: (Data.Void.Void, Data.Void.Void) -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfWrH] Data.Void.$fIxVoid1;

Data.Void.$fIxVoid_$crange
  :: (Data.Void.Void, Data.Void.Void) -> [Data.Void.Void]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sfWrI] [] [];

Data.Void.$fSemigroupVoid_$cstimes
  :: forall b.
     GHC.Real.Integral b =>
     b -> Data.Void.Void -> Data.Void.Void
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfWrJ eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotent
            $dIntegral_sfWrJ eta_B2 eta_B1;

Data.Void.$fOrdVoid_$c<>
  :: Data.Void.Void -> Data.Void.Void -> Data.Void.Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a_sfWrK ds_sfWrL] a_sfWrK;

Data.Void.$fSemigroupVoid_$csconcat
  :: GHC.Base.NonEmpty Data.Void.Void -> Data.Void.Void
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfWrM]
        case ds_sfWrM of {
          GHC.Base.:| a1_sfWrO [Occ=Once] as_sfWrP [Occ=Once] ->
              case as_sfWrP of { __DEFAULT -> a1_sfWrO; };
        };

Data.Void.$fSemigroupVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Semigroup Data.Void.Void
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Void.$fOrdVoid_$c<>
                                         Data.Void.$fSemigroupVoid_$csconcat
                                         Data.Void.$fSemigroupVoid_$cstimes];

Data.Void.$fShowVoid_$cshowsPrec
  :: GHC.Types.Int -> Data.Void.Void -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfWrR z_sfWrS] z_sfWrS;

Data.Void.$fExceptionVoid_$cshow
  :: Data.Void.Void -> GHC.Base.String
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [x_sfWrU] x_sfWrU;

Data.Void.$fShowVoid1 :: Data.Void.Void -> GHC.Show.ShowS
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [z_sfWrW] z_sfWrW;

Data.Void.$fShowVoid_$cshowList
  :: [Data.Void.Void] -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [ls_sfWrY s_sfWrZ]
        GHC.Show.showList__ Data.Void.$fShowVoid1 ls_sfWrY s_sfWrZ;

Data.Void.$fShowVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Show.Show Data.Void.Void
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Void.$fShowVoid_$cshowsPrec
                                    Data.Void.$fExceptionVoid_$cshow
                                    Data.Void.$fShowVoid_$cshowList];

Data.Void.$fReadVoid2
  :: Text.ParserCombinators.ReadP.ReadS Data.Void.Void
[GblId, Arity=1, Caf=NoCafRefs, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadP.run
            Text.ParserCombinators.ReadP.Fail eta_B1;

Data.Void.$fReadVoid_$creadsPrec
  :: GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS Data.Void.Void
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [n_sfWs0 eta_B1] Data.Void.$fReadVoid2 eta_B1;

Data.Void.$fReadVoid_$creadListPrec
  :: Text.ParserCombinators.ReadPrec.ReadPrec [Data.Void.Void]
[GblId] =
    [] \u []
        GHC.Read.list
            Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4;

Data.Void.$fReadVoid1
  :: Text.ParserCombinators.ReadP.P [Data.Void.Void]
[GblId] =
    [] \u []
        Data.Void.$fReadVoid_$creadListPrec
            GHC.Read.$fRead()7
            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;

Data.Void.$fReadVoid_$creadList
  :: Text.ParserCombinators.ReadP.ReadS [Data.Void.Void]
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadP.run Data.Void.$fReadVoid1 eta_B1;

Data.Void.$fReadVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Read.Read Data.Void.Void
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Read.C:Read! [Data.Void.$fReadVoid_$creadsPrec
                                    Data.Void.$fReadVoid_$creadList
                                    Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4
                                    Data.Void.$fReadVoid_$creadListPrec];

Data.Void.$fOrdVoid_$ccompare
  :: Data.Void.Void -> Data.Void.Void -> GHC.Types.Ordering
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sfWs1 z_sfWs2] GHC.Types.EQ [];

Data.Void.$fGenericVoid_$cto
  :: forall x. GHC.Generics.Rep Data.Void.Void x -> Data.Void.Void
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [ds_sfWs3] ds_sfWs3;

Data.Void.$fGenericVoid1
  :: forall x. Data.Void.Void -> GHC.Generics.V1 x
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [x1_sfWs5] x1_sfWs5;

Data.Void.$fGenericVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic Data.Void.Void
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Void.$fGenericVoid1
                                           Data.Void.$fGenericVoid_$cto];

Data.Void.$fDataVoid_$ctoConstr
  :: Data.Void.Void -> Data.Data.Constr
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [z_sfWs7] z_sfWs7;

lvl_rfVTe :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data/Void.hs:39:5-8|case"#;

lvl1_rfVTf :: forall (c :: * -> *). c Data.Void.Void
[GblId, Str=x] =
    [] \u [] Control.Exception.Base.patError lvl_rfVTe;

Data.Void.$w$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     Data.Data.ConstrRep -> GHC.Base.String -> c Data.Void.Void
[GblId, Arity=2, Str=<B,1*U><B,1*U>x, Unf=OtherCon []] =
    [] \r [ww_sfWs9 ww1_sfWsa]
        case ww_sfWs9 of {
          __DEFAULT -> Data.Data.$wlvl ww1_sfWsa;
          Data.Data.AlgConstr idx_sfWsd [Occ=Once!] ->
              case idx_sfWsd of { GHC.Types.I# _ [Occ=Dead] -> lvl1_rfVTf; };
        };

Data.Void.$fDataVoid_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Data.Data.Constr -> c Data.Void.Void
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,1*U(1*U,A,A,A,1*U(1*U,A))>x,
 Unf=OtherCon []] =
    [] \r [w_sfWsg w1_sfWsh w2_sfWsi]
        case w2_sfWsi of {
          Data.Data.Constr ww1_sfWsk [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           ww5_sfWso [Occ=Once!] ->
              case ww5_sfWso of {
                Data.Data.DataType ww7_sfWsq [Occ=Once] _ [Occ=Dead] ->
                    Data.Void.$w$cgunfold ww1_sfWsk ww7_sfWsq;
              };
        };

Data.Void.$fDataVoid_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Data.Void.Void -> c Data.Void.Void
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfWss ds1_sfWst z_sfWsu] z_sfWsu;

Data.Void.$fEqVoid_$c==
  :: Data.Void.Void -> Data.Void.Void -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sfWsw z_sfWsx] GHC.Types.True [];

Data.Void.$fEqVoid_$c/= [InlPrag=INLINE (sat-args=2)]
  :: Data.Void.Void -> Data.Void.Void -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [eta_sfWsy eta1_sfWsz] GHC.Types.False [];

Data.Void.$fEqVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Eq Data.Void.Void
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [Data.Void.$fEqVoid_$c==
                                     Data.Void.$fEqVoid_$c/=];

Data.Void.$fOrdVoid_$c<
  :: Data.Void.Void -> Data.Void.Void -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [x_sfWsA y_sfWsB] GHC.Types.False [];

Data.Void.$fOrdVoid_$cmax
  :: Data.Void.Void -> Data.Void.Void -> Data.Void.Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_sfWsC y_sfWsD] y_sfWsD;

Data.Void.$fOrdVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Ord Data.Void.Void
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Void.$fEqVoid
                                      Data.Void.$fOrdVoid_$ccompare
                                      Data.Void.$fOrdVoid_$c<
                                      Data.Void.$fEqVoid_$c==
                                      Data.Void.$fOrdVoid_$c<
                                      Data.Void.$fEqVoid_$c==
                                      Data.Void.$fOrdVoid_$cmax
                                      Data.Void.$fOrdVoid_$c<>];

Data.Void.absurd :: forall a. Data.Void.Void -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [a1_sfWsE] a1_sfWsE;

Data.Void.vacuous
  :: forall (f :: * -> *) a.
     GHC.Base.Functor f =>
     f Data.Void.Void -> f a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sfWsG]
        GHC.Base.fmap $dFunctor_sfWsG Data.Void.absurd;

Data.Void.$fIxVoid_$cindex
  :: (Data.Void.Void, Data.Void.Void)
     -> Data.Void.Void -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfWsH eta_sfWsI] eta_sfWsI;

Data.Void.$fIxVoid_$cinRange
  :: (Data.Void.Void, Data.Void.Void)
     -> Data.Void.Void -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfWsK eta_sfWsL] eta_sfWsL;

Data.Void.$fIxVoid_$cunsafeRangeSize
  :: (Data.Void.Void, Data.Void.Void) -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<B,1*U(A,1*U)>b,
 Unf=OtherCon []] =
    [] \r [b_sfWsN]
        case b_sfWsN of {
          (,) _ [Occ=Dead] h_sfWsQ [Occ=Once] -> h_sfWsQ;
        };

Data.Void.$fIxVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Arr.Ix Data.Void.Void
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Arr.C:Ix! [Data.Void.$fOrdVoid
                                 Data.Void.$fIxVoid_$crange
                                 Data.Void.$fIxVoid_$cindex
                                 Data.Void.$fIxVoid_$cindex
                                 Data.Void.$fIxVoid_$cinRange
                                 Data.Void.$fIxVoid_$crangeSize
                                 Data.Void.$fIxVoid_$cunsafeRangeSize];

Data.Void.$fDataVoid5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Void"#;

Data.Void.$fDataVoid4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Void.$fDataVoid5;

Data.Void.$fDataVoid3 :: Data.Data.DataRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [GHC.Types.[]];

Data.Void.$tVoid :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Void.$fDataVoid4
                                       Data.Void.$fDataVoid3];

Data.Void.$fDataVoid_$cdataTypeOf
  :: Data.Void.Void -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfWsS] Data.Void.$tVoid;

Data.Void.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Void.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Void.$trModule4];

Data.Void.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Void"#;

Data.Void.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Void.$trModule2];

Data.Void.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Void.$trModule3
                                     Data.Void.$trModule1];

Data.Void.$fDataVoid7 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Void.$fDataVoid5];

Data.Void.$tcVoid :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1716938828100304260##
                                    9065598981067935587##
                                    Data.Void.$trModule
                                    Data.Void.$fDataVoid7
                                    0#
                                    GHC.Types.krep$*];

Data.Void.$fDataVoid6
  :: Data.Typeable.Internal.TypeRep Data.Void.Void
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                1716938828100304260##
                9065598981067935587##
                Data.Void.$trModule
                Data.Void.$fDataVoid7
                0#
                GHC.Types.krep$*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfWsU [Occ=Once]
                   ww9_sfWsV [Occ=Once]
                   ww10_sfWsW [Occ=Once]
                   ww11_sfWsX [Occ=Once]
                   ww12_sfWsY [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfWsU
                                              ww9_sfWsV
                                              ww10_sfWsW
                                              ww11_sfWsX
                                              ww12_sfWsY];
        };

Data.Void.$fDataVoid_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c Data.Void.Void)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfWsZ ds_sfWt0] GHC.Base.Nothing [];

Data.Void.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     Data.Void.Void -> m Data.Void.Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfWt1 w1_sfWt2]
        let {
          lvl2_sfWt3 [Occ=OnceL] :: m_sfVOk Data.Void.Void
          [LclId] =
              [w_sfWt1] \u [] GHC.Base.mzero w_sfWt1;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sfWt1
          of
          $dMonad_sfWt4 [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfWtb [Occ=Once]
                    :: (Data.Void.Void, GHC.Types.Bool) -> m_sfVOk Data.Void.Void
                  [LclId] =
                      [lvl2_sfWt3 $dMonad_sfWt4] \r [ds_sfWt6]
                          case ds_sfWt6 of {
                            (,) x'_sfWt8 [Occ=Once] b_sfWt9 [Occ=Once!] ->
                                case b_sfWt9 of {
                                  GHC.Types.False -> lvl2_sfWt3;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfWt4 x'_sfWt8;
                                };
                          };
                } in  GHC.Base.>>= $dMonad_sfWt4 w1_sfWt2 sat_sfWtb;
          };

Data.Void.$fDataVoid_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Void.Void -> m Data.Void.Void
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfWtc w1_sfWtd w2_sfWte]
        Data.Void.$w$cgmapMp w_sfWtc w2_sfWte;

Data.Void.$fDataVoid_$cgmapM
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Void.Void -> m Data.Void.Void
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfWtf ds_sfWtg z_sfWth] z_sfWth;

Data.Void.$fDataVoid_$cgmapQi
  :: forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u) -> Data.Void.Void -> u
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfWtj ds1_sfWtk x_sfWtl] x_sfWtl;

Data.Void.$fDataVoid_$cgmapQr
  :: forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Void.Void
     -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfWtn ds1_sfWto ds2_sfWtp x0_sfWtq] x0_sfWtq;

Data.Void.$fDataVoid_$cgmapQ
  :: forall u.
     (forall d. Data.Data.Data d => d -> u) -> Data.Void.Void -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfWts x0_sfWtt] x0_sfWtt;

Data.Void.$fDataVoid1
  :: forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Void.Void
     -> Data.Functor.Const.Const r Data.Void.Void
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfWtv ds1_sfWtw ds2_sfWtx eta_sfWty] eta_sfWty;

Data.Void.$fDataVoid2
  :: (forall b. Data.Data.Data b => b -> b)
     -> Data.Void.Void -> Data.Functor.Identity.Identity Data.Void.Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfWtA x0_sfWtB] x0_sfWtB;

Data.Void.$fDataVoid_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c Data.Void.Void)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfWtD ds_sfWtE] GHC.Base.Nothing [];

Data.Void.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     Data.Void.Void -> m Data.Void.Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfWtF w1_sfWtG]
        let {
          lvl2_sfWtH [Occ=OnceL] :: m_sfVOp Data.Void.Void
          [LclId] =
              [w_sfWtF] \u [] GHC.Base.mzero w_sfWtF;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sfWtF
          of
          $dMonad_sfWtI [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfWtP [Occ=Once]
                    :: (Data.Void.Void, GHC.Types.Bool) -> m_sfVOp Data.Void.Void
                  [LclId] =
                      [lvl2_sfWtH $dMonad_sfWtI] \r [ds_sfWtK]
                          case ds_sfWtK of {
                            (,) x'_sfWtM [Occ=Once] b_sfWtN [Occ=Once!] ->
                                case b_sfWtN of {
                                  GHC.Types.False -> lvl2_sfWtH;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfWtI x'_sfWtM;
                                };
                          };
                } in  GHC.Base.>>= $dMonad_sfWtI w1_sfWtG sat_sfWtP;
          };

Data.Void.$fDataVoid_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Void.Void -> m Data.Void.Void
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfWtQ w1_sfWtR w2_sfWtS]
        Data.Void.$w$cgmapMo w_sfWtQ w2_sfWtS;

Data.Void.$fDataVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Data.Data Data.Void.Void
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Data.C:Data! [Data.Void.$fDataVoid6
                                     Data.Void.$fDataVoid_$cgfoldl
                                     Data.Void.$fDataVoid_$cgunfold
                                     Data.Void.$fDataVoid_$ctoConstr
                                     Data.Void.$fDataVoid_$cdataTypeOf
                                     Data.Void.$fDataVoid_$cdataCast1
                                     Data.Void.$fDataVoid_$cdataCast2
                                     Data.Void.$fDataVoid2
                                     Data.Void.$fDataVoid1
                                     Data.Void.$fDataVoid_$cgmapQr
                                     Data.Void.$fDataVoid_$cgmapQ
                                     Data.Void.$fDataVoid_$cgmapQi
                                     Data.Void.$fDataVoid_$cgmapM
                                     Data.Void.$fDataVoid_$cgmapMp
                                     Data.Void.$fDataVoid_$cgmapMo];

Data.Void.$fExceptionVoid_$cfromException
  :: GHC.Exception.SomeException -> GHC.Base.Maybe Data.Void.Void
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfWtT]
        case ds_sfWtT of {
          GHC.Exception.SomeException $dException1_sfWtV [Occ=Once]
                                      e2_sfWtW [Occ=Once] ->
              case GHC.Exception.$p1Exception $dException1_sfWtV of sat_sfWtX {
                __DEFAULT ->
                    case
                        Data.Typeable.Internal.sameTypeRep sat_sfWtX Data.Void.$fDataVoid6
                    of
                    { GHC.Types.False -> GHC.Base.Nothing [];
                      GHC.Types.True -> GHC.Base.Just [e2_sfWtW];
                    };
              };
        };

Data.Void.$fExceptionVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Exception.Exception Data.Void.Void
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Exception.C:Exception! [Data.Void.$fDataVoid6
                                              Data.Void.$fShowVoid
                                              Data.Void.$fExceptionVoid_$ctoException
                                              Data.Void.$fExceptionVoid_$cfromException
                                              Data.Void.$fExceptionVoid_$cshow];
Data.Void.$fExceptionVoid_$ctoException [Occ=LoopBreaker]
  :: Data.Void.Void -> GHC.Exception.SomeException
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        GHC.Exception.SomeException [Data.Void.$fExceptionVoid eta_B1];


==================== STG syntax: ====================
2018-03-16 16:11:45.972098305 UTC

Data.Void.$fIxVoid1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Void.$fIxVoid_$crangeSize
  :: (Data.Void.Void, Data.Void.Void) -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfWrH] Data.Void.$fIxVoid1;

Data.Void.$fIxVoid_$crange
  :: (Data.Void.Void, Data.Void.Void) -> [Data.Void.Void]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sfWrI] [] [];

Data.Void.$fSemigroupVoid_$cstimes
  :: forall b.
     GHC.Real.Integral b =>
     b -> Data.Void.Void -> Data.Void.Void
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,A,A,C(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_sfWrJ eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotent
            $dIntegral_sfWrJ eta_B2 eta_B1;

Data.Void.$fOrdVoid_$c<>
  :: Data.Void.Void -> Data.Void.Void -> Data.Void.Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [a_sfWrK ds_sfWrL] a_sfWrK;

Data.Void.$fSemigroupVoid_$csconcat
  :: GHC.Base.NonEmpty Data.Void.Void -> Data.Void.Void
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sfWrM]
        case ds_sfWrM of {
          GHC.Base.:| a1_sfWrO [Occ=Once] as_sfWrP [Occ=Once] ->
              case as_sfWrP of { __DEFAULT -> a1_sfWrO; };
        };

Data.Void.$fSemigroupVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Semigroup Data.Void.Void
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Void.$fOrdVoid_$c<>
                                         Data.Void.$fSemigroupVoid_$csconcat
                                         Data.Void.$fSemigroupVoid_$cstimes];

Data.Void.$fShowVoid_$cshowsPrec
  :: GHC.Types.Int -> Data.Void.Void -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfWrR z_sfWrS] z_sfWrS;

Data.Void.$fExceptionVoid_$cshow
  :: Data.Void.Void -> GHC.Base.String
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [x_sfWrU] x_sfWrU;

Data.Void.$fShowVoid1 :: Data.Void.Void -> GHC.Show.ShowS
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [z_sfWrW] z_sfWrW;

Data.Void.$fShowVoid_$cshowList
  :: [Data.Void.Void] -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [ls_sfWrY s_sfWrZ]
        GHC.Show.showList__ Data.Void.$fShowVoid1 ls_sfWrY s_sfWrZ;

Data.Void.$fShowVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Show.Show Data.Void.Void
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Void.$fShowVoid_$cshowsPrec
                                    Data.Void.$fExceptionVoid_$cshow
                                    Data.Void.$fShowVoid_$cshowList];

Data.Void.$fReadVoid2
  :: Text.ParserCombinators.ReadP.ReadS Data.Void.Void
[GblId, Arity=1, Caf=NoCafRefs, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadP.run
            Text.ParserCombinators.ReadP.Fail eta_B1;

Data.Void.$fReadVoid_$creadsPrec
  :: GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS Data.Void.Void
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [n_sfWs0 eta_B1] Data.Void.$fReadVoid2 eta_B1;

Data.Void.$fReadVoid_$creadListPrec
  :: Text.ParserCombinators.ReadPrec.ReadPrec [Data.Void.Void]
[GblId] =
    [] \u []
        GHC.Read.list
            Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4;

Data.Void.$fReadVoid1
  :: Text.ParserCombinators.ReadP.P [Data.Void.Void]
[GblId] =
    [] \u []
        Data.Void.$fReadVoid_$creadListPrec
            GHC.Read.$fRead()7
            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;

Data.Void.$fReadVoid_$creadList
  :: Text.ParserCombinators.ReadP.ReadS [Data.Void.Void]
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadP.run Data.Void.$fReadVoid1 eta_B1;

Data.Void.$fReadVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Read.Read Data.Void.Void
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Read.C:Read! [Data.Void.$fReadVoid_$creadsPrec
                                    Data.Void.$fReadVoid_$creadList
                                    Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4
                                    Data.Void.$fReadVoid_$creadListPrec];

Data.Void.$fOrdVoid_$ccompare
  :: Data.Void.Void -> Data.Void.Void -> GHC.Types.Ordering
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sfWs1 z_sfWs2] GHC.Types.EQ [];

Data.Void.$fGenericVoid_$cto
  :: forall x. GHC.Generics.Rep Data.Void.Void x -> Data.Void.Void
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [ds_sfWs3] ds_sfWs3;

Data.Void.$fGenericVoid1
  :: forall x. Data.Void.Void -> GHC.Generics.V1 x
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [x1_sfWs5] x1_sfWs5;

Data.Void.$fGenericVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic Data.Void.Void
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Void.$fGenericVoid1
                                           Data.Void.$fGenericVoid_$cto];

Data.Void.$fDataVoid_$ctoConstr
  :: Data.Void.Void -> Data.Data.Constr
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [z_sfWs7] z_sfWs7;

lvl_rfVTe :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data/Void.hs:39:5-8|case"#;

lvl1_rfVTf :: forall (c :: * -> *). c Data.Void.Void
[GblId, Str=x] =
    [] \u [] Control.Exception.Base.patError lvl_rfVTe;

Data.Void.$w$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     Data.Data.ConstrRep -> GHC.Base.String -> c Data.Void.Void
[GblId, Arity=2, Str=<B,1*U><B,1*U>x, Unf=OtherCon []] =
    [] \r [ww_sfWs9 ww1_sfWsa]
        case ww_sfWs9 of {
          __DEFAULT -> Data.Data.$wlvl ww1_sfWsa;
          Data.Data.AlgConstr idx_sfWsd [Occ=Once!] ->
              case idx_sfWsd of { GHC.Types.I# _ [Occ=Dead] -> lvl1_rfVTf; };
        };

Data.Void.$fDataVoid_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r) -> Data.Data.Constr -> c Data.Void.Void
[GblId,
 Arity=3,
 Str=<B,A><B,A><B,1*U(1*U,A,A,A,1*U(1*U,A))>x,
 Unf=OtherCon []] =
    [] \r [w_sfWsg w1_sfWsh w2_sfWsi]
        case w2_sfWsi of {
          Data.Data.Constr ww1_sfWsk [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           ww5_sfWso [Occ=Once!] ->
              case ww5_sfWso of {
                Data.Data.DataType ww7_sfWsq [Occ=Once] _ [Occ=Dead] ->
                    Data.Void.$w$cgunfold ww1_sfWsk ww7_sfWsq;
              };
        };

Data.Void.$fDataVoid_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g) -> Data.Void.Void -> c Data.Void.Void
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfWss ds1_sfWst z_sfWsu] z_sfWsu;

Data.Void.$fEqVoid_$c==
  :: Data.Void.Void -> Data.Void.Void -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sfWsw z_sfWsx] GHC.Types.True [];

Data.Void.$fEqVoid_$c/= [InlPrag=INLINE (sat-args=2)]
  :: Data.Void.Void -> Data.Void.Void -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [eta_sfWsy eta1_sfWsz] GHC.Types.False [];

Data.Void.$fEqVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Eq Data.Void.Void
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [Data.Void.$fEqVoid_$c==
                                     Data.Void.$fEqVoid_$c/=];

Data.Void.$fOrdVoid_$c<
  :: Data.Void.Void -> Data.Void.Void -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [x_sfWsA y_sfWsB] GHC.Types.False [];

Data.Void.$fOrdVoid_$cmax
  :: Data.Void.Void -> Data.Void.Void -> Data.Void.Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_sfWsC y_sfWsD] y_sfWsD;

Data.Void.$fOrdVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Ord Data.Void.Void
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Void.$fEqVoid
                                      Data.Void.$fOrdVoid_$ccompare
                                      Data.Void.$fOrdVoid_$c<
                                      Data.Void.$fEqVoid_$c==
                                      Data.Void.$fOrdVoid_$c<
                                      Data.Void.$fEqVoid_$c==
                                      Data.Void.$fOrdVoid_$cmax
                                      Data.Void.$fOrdVoid_$c<>];

Data.Void.absurd :: forall a. Data.Void.Void -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<B,1*U>b, Unf=OtherCon []] =
    [] \r [a1_sfWsE] a1_sfWsE;

Data.Void.vacuous
  :: forall (f :: * -> *) a.
     GHC.Base.Functor f =>
     f Data.Void.Void -> f a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sfWsG]
        GHC.Base.fmap $dFunctor_sfWsG Data.Void.absurd;

Data.Void.$fIxVoid_$cindex
  :: (Data.Void.Void, Data.Void.Void)
     -> Data.Void.Void -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfWsH eta_sfWsI] eta_sfWsI;

Data.Void.$fIxVoid_$cinRange
  :: (Data.Void.Void, Data.Void.Void)
     -> Data.Void.Void -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfWsK eta_sfWsL] eta_sfWsL;

Data.Void.$fIxVoid_$cunsafeRangeSize
  :: (Data.Void.Void, Data.Void.Void) -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<B,1*U(A,1*U)>b,
 Unf=OtherCon []] =
    [] \r [b_sfWsN]
        case b_sfWsN of {
          (,) _ [Occ=Dead] h_sfWsQ [Occ=Once] -> h_sfWsQ;
        };

Data.Void.$fIxVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Arr.Ix Data.Void.Void
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Arr.C:Ix! [Data.Void.$fOrdVoid
                                 Data.Void.$fIxVoid_$crange
                                 Data.Void.$fIxVoid_$cindex
                                 Data.Void.$fIxVoid_$cindex
                                 Data.Void.$fIxVoid_$cinRange
                                 Data.Void.$fIxVoid_$crangeSize
                                 Data.Void.$fIxVoid_$cunsafeRangeSize];

Data.Void.$fDataVoid5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Void"#;

Data.Void.$fDataVoid4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Void.$fDataVoid5;

Data.Void.$fDataVoid3 :: Data.Data.DataRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [GHC.Types.[]];

Data.Void.$tVoid :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [Data.Void.$fDataVoid4
                                       Data.Void.$fDataVoid3];

Data.Void.$fDataVoid_$cdataTypeOf
  :: Data.Void.Void -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfWsS] Data.Void.$tVoid;

Data.Void.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Void.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Void.$trModule4];

Data.Void.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Void"#;

Data.Void.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Void.$trModule2];

Data.Void.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Void.$trModule3
                                     Data.Void.$trModule1];

Data.Void.$fDataVoid7 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Void.$fDataVoid5];

Data.Void.$tcVoid :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1716938828100304260##
                                    9065598981067935587##
                                    Data.Void.$trModule
                                    Data.Void.$fDataVoid7
                                    0#
                                    GHC.Types.krep$*];

Data.Void.$fDataVoid6
  :: Data.Typeable.Internal.TypeRep Data.Void.Void
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                1716938828100304260##
                9065598981067935587##
                Data.Void.$trModule
                Data.Void.$fDataVoid7
                0#
                GHC.Types.krep$*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfWsU [Occ=Once]
                   ww9_sfWsV [Occ=Once]
                   ww10_sfWsW [Occ=Once]
                   ww11_sfWsX [Occ=Once]
                   ww12_sfWsY [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfWsU
                                              ww9_sfWsV
                                              ww10_sfWsW
                                              ww11_sfWsX
                                              ww12_sfWsY];
        };

Data.Void.$fDataVoid_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c Data.Void.Void)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfWsZ ds_sfWt0] GHC.Base.Nothing [];

Data.Void.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     Data.Void.Void -> m Data.Void.Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfWt1 w1_sfWt2]
        let {
          lvl2_sfWt3 [Occ=OnceL] :: m_sfVOk Data.Void.Void
          [LclId] =
              [w_sfWt1] \u [] GHC.Base.mzero w_sfWt1;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sfWt1
          of
          $dMonad_sfWt4 [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfWtb [Occ=Once]
                    :: (Data.Void.Void, GHC.Types.Bool) -> m_sfVOk Data.Void.Void
                  [LclId] =
                      [lvl2_sfWt3 $dMonad_sfWt4] \r [ds_sfWt6]
                          case ds_sfWt6 of {
                            (,) x'_sfWt8 [Occ=Once] b_sfWt9 [Occ=Once!] ->
                                case b_sfWt9 of {
                                  GHC.Types.False -> lvl2_sfWt3;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfWt4 x'_sfWt8;
                                };
                          };
                } in  GHC.Base.>>= $dMonad_sfWt4 w1_sfWt2 sat_sfWtb;
          };

Data.Void.$fDataVoid_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Void.Void -> m Data.Void.Void
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfWtc w1_sfWtd w2_sfWte]
        Data.Void.$w$cgmapMp w_sfWtc w2_sfWte;

Data.Void.$fDataVoid_$cgmapM
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Void.Void -> m Data.Void.Void
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfWtf ds_sfWtg z_sfWth] z_sfWth;

Data.Void.$fDataVoid_$cgmapQi
  :: forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u) -> Data.Void.Void -> u
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfWtj ds1_sfWtk x_sfWtl] x_sfWtl;

Data.Void.$fDataVoid_$cgmapQr
  :: forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Void.Void
     -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfWtn ds1_sfWto ds2_sfWtp x0_sfWtq] x0_sfWtq;

Data.Void.$fDataVoid_$cgmapQ
  :: forall u.
     (forall d. Data.Data.Data d => d -> u) -> Data.Void.Void -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfWts x0_sfWtt] x0_sfWtt;

Data.Void.$fDataVoid1
  :: forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> Data.Void.Void
     -> Data.Functor.Const.Const r Data.Void.Void
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<B,A><B,A><B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfWtv ds1_sfWtw ds2_sfWtx eta_sfWty] eta_sfWty;

Data.Void.$fDataVoid2
  :: (forall b. Data.Data.Data b => b -> b)
     -> Data.Void.Void -> Data.Functor.Identity.Identity Data.Void.Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<B,A><B,1*U>b,
 Unf=OtherCon []] =
    [] \r [ds_sfWtA x0_sfWtB] x0_sfWtB;

Data.Void.$fDataVoid_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c Data.Void.Void)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfWtD ds_sfWtE] GHC.Base.Nothing [];

Data.Void.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     Data.Void.Void -> m Data.Void.Void
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfWtF w1_sfWtG]
        let {
          lvl2_sfWtH [Occ=OnceL] :: m_sfVOp Data.Void.Void
          [LclId] =
              [w_sfWtF] \u [] GHC.Base.mzero w_sfWtF;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sfWtF
          of
          $dMonad_sfWtI [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfWtP [Occ=Once]
                    :: (Data.Void.Void, GHC.Types.Bool) -> m_sfVOp Data.Void.Void
                  [LclId] =
                      [lvl2_sfWtH $dMonad_sfWtI] \r [ds_sfWtK]
                          case ds_sfWtK of {
                            (,) x'_sfWtM [Occ=Once] b_sfWtN [Occ=Once!] ->
                                case b_sfWtN of {
                                  GHC.Types.False -> lvl2_sfWtH;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfWtI x'_sfWtM;
                                };
                          };
                } in  GHC.Base.>>= $dMonad_sfWtI w1_sfWtG sat_sfWtP;
          };

Data.Void.$fDataVoid_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> Data.Void.Void -> m Data.Void.Void
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sfWtQ w1_sfWtR w2_sfWtS]
        Data.Void.$w$cgmapMo w_sfWtQ w2_sfWtS;

Data.Void.$fDataVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Data.Data Data.Void.Void
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Data.C:Data! [Data.Void.$fDataVoid6
                                     Data.Void.$fDataVoid_$cgfoldl
                                     Data.Void.$fDataVoid_$cgunfold
                                     Data.Void.$fDataVoid_$ctoConstr
                                     Data.Void.$fDataVoid_$cdataTypeOf
                                     Data.Void.$fDataVoid_$cdataCast1
                                     Data.Void.$fDataVoid_$cdataCast2
                                     Data.Void.$fDataVoid2
                                     Data.Void.$fDataVoid1
                                     Data.Void.$fDataVoid_$cgmapQr
                                     Data.Void.$fDataVoid_$cgmapQ
                                     Data.Void.$fDataVoid_$cgmapQi
                                     Data.Void.$fDataVoid_$cgmapM
                                     Data.Void.$fDataVoid_$cgmapMp
                                     Data.Void.$fDataVoid_$cgmapMo];

Data.Void.$fExceptionVoid_$cfromException
  :: GHC.Exception.SomeException -> GHC.Base.Maybe Data.Void.Void
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sfWtT]
        case ds_sfWtT of {
          GHC.Exception.SomeException $dException1_sfWtV [Occ=Once]
                                      e2_sfWtW [Occ=Once] ->
              case GHC.Exception.$p1Exception $dException1_sfWtV of sat_sfWtX {
                __DEFAULT ->
                    case
                        Data.Typeable.Internal.sameTypeRep sat_sfWtX Data.Void.$fDataVoid6
                    of
                    { GHC.Types.False -> GHC.Base.Nothing [];
                      GHC.Types.True -> GHC.Base.Just [e2_sfWtW];
                    };
              };
        };

Data.Void.$fExceptionVoid [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Exception.Exception Data.Void.Void
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Exception.C:Exception! [Data.Void.$fDataVoid6
                                              Data.Void.$fShowVoid
                                              Data.Void.$fExceptionVoid_$ctoException
                                              Data.Void.$fExceptionVoid_$cfromException
                                              Data.Void.$fExceptionVoid_$cshow];
Data.Void.$fExceptionVoid_$ctoException [Occ=LoopBreaker]
  :: Data.Void.Void -> GHC.Exception.SomeException
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        GHC.Exception.SomeException [Data.Void.$fExceptionVoid eta_B1];

